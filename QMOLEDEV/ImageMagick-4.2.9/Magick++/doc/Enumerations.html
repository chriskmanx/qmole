<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.61 [en] (X11; U; SunOS 5.6 sun4u) [Netscape]">
   <meta name="Author" content="Bob Friesenhahn">
   <meta name="Description" content="Documentation for enumerations used by Magick++.">
   <title>Magick++ Enumerations</title>
</head>
<body text="#000000" bgcolor="#FFFFFF" link="#0000EE" vlink="#551A8B" alink="#FF0000">

<center>
<h1>
Magick++ Enumerations</h1></center>

<center>
<h3>
<a NAME="ClassType"></a>Magick::ClassType</h3></center>
<i>ClassType</i> specifies the image class.
<table BORDER WIDTH="100%" NOSAVE >
<caption>
<center><b>Magick::ClassType</b></center>
</caption>

<tr>
<td>
<center><b>Enumeration</b></center>
</td>

<td>
<center><b>Description</b></center>
</td>
</tr>

<tr NOSAVE>
<td NOSAVE>UndefinedClass</td>

<td>Unset value.</td>
</tr>

<tr NOSAVE>
<td>DirectClass</td>

<td NOSAVE>Image is composed of pixels which represent literal color values.</td>
</tr>

<tr>
<td>PseudoClass</td>

<td>Image is composed of pixels which specify an index in a color palette.</td>
</tr>
</table>

<center>
<h3>
<a NAME="ColorspaceType"></a>Magick::ColorspaceType</h3></center>
The ColorspaceType enumeration is used to specify the colorspace that quantization
(color reduction and mapping) is done under or to specify the colorspace
when encoding an output image. Colorspaces are ways of describing colors
to fit the requirements of a particular application (e.g. Television, offset
printing, color monitors).&nbsp; Color reduction, by default, takes place
in the <i>RGBColorspace</i>. Empirical evidence suggests that distances
in color spaces such as <i>YUVColorspace</i> or <i>YIQColorspace</i> correspond
to perceptual color differences more closely han do distances in RGB space.
These color spaces may give better results when color reducing an image.
Refer to <i>quantize</i> for more details.
<p>When encoding an output image, the colorspaces <i>RGBColorspace</i>,
<i>CMYKColorspace</i>,
and <i>GRAYColorspace</i> may be specified. The
<i>CMYKColorspace</i> option
is only applicable when writing TIFF, JPEG, and Adobe Photoshop bitmap
(PSD) files.
<br>&nbsp;
<table BORDER WIDTH="100%" NOSAVE >
<caption><b>Magick::ColorspaceType</b></caption>

<tr>
<td>
<center><b>Enumeration</b></center>
</td>

<td>
<center><b>Description</b></center>
</td>
</tr>

<tr NOSAVE>
<td NOSAVE>UndefinedColorspace</td>

<td>Unset value.</td>
</tr>

<tr>
<td>RGBColorspace</td>

<td>Red-Green-Blue colorspace.</td>
</tr>

<tr NOSAVE>
<td NOSAVE>GRAYColorspace</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>TransparentColorspace</td>

<td>The Transparent color space behaves uniquely in that it preserves the
matte channel of the image if it exists.</td>
</tr>

<tr>
<td>OHTAColorspace</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>XYZColorspace</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>YCbCrColorspace</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>YCCColorspace</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>YIQColorspace</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>YPbPrColorspace</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>YUVColorspace</td>

<td>Y-signal, U-signal, and V-signal colorspace. YUV is most widely used
to encode color for use in television transmission.</td>
</tr>

<tr>
<td>CMYKColorspace</td>

<td>Cyan-Magenta-Yellow-Black colorspace. CYMK is a subtractive color system
used by printers and photographers for the rendering of colors with ink
or emulsion, normally on a white surface.</td>
</tr>

<tr>
<td>sRGBColorspace</td>

<td>&nbsp;</td>
</tr>
</table>

<center>
<h3>
<a NAME="CompositeOperator"></a><b>Magick::CompositeOperator</b></h3></center>
<i>CompositeOperator</i> is used to select the image composition algorithm
used to compose a <i>composite image</i> with an <i>image</i>. By default,
each of the composite image pixels are replaced by the corresponding image
tile pixel. Specify <i>CompositeOperator</i> to select a different algorithm.
<br>&nbsp;
<table BORDER WIDTH="100%" NOSAVE >
<caption><b>Magick::CompositeOperator</b></caption>

<tr>
<td>
<center><b>Enumeration</b></center>
</td>

<td>
<center><b>Description</b></center>
</td>
</tr>

<tr NOSAVE>
<td NOSAVE>UndefinedCompositeOp</td>

<td>Unset value.</td>
</tr>

<tr NOSAVE>
<td>OverCompositeOp</td>

<td NOSAVE>The result is the union of the two image shapes with the
<i>composite
image</i> obscuring <i>image</i> in the region of overlap.</td>
</tr>

<tr>
<td>InCompositeOp</td>

<td>The result is a simply <i>composite image </i>cut by the shape of image.
None of the image data of <i>image</i> is included in the result.</td>
</tr>

<tr>
<td>OutCompositeOp</td>

<td>The resulting image is <i>composite image</i> with the shape of <i>image</i>
cut out.</td>
</tr>

<tr>
<td>AtopCompositeOp</td>

<td>The result is the same shape as image <i>image</i>, with <i>composite
image</i> obscuring <i>image</i> there the image shapes overlap. Note that
this differs from <i>OverCompositeOp</i> because the portion of <i>composite
image</i> outside of <i>image</i>'s shape does not appear in the result.</td>
</tr>

<tr>
<td>XorCompositeOp</td>

<td>The result is the image data from both c<i>omposite image</i> and <i>image</i>
that is outside the overlap region. The overlap region will be blank.</td>
</tr>

<tr>
<td>PlusCompositeOp</td>

<td>The result is just the sum of the&nbsp; image data. Output values are
cropped to 255 (no overflow). This operation is independent of the matte
channels.</td>
</tr>

<tr>
<td>MinusCompositeOp</td>

<td>The result of <i>composite image </i>- <i>image</i>, with overflow
cropped to zero. The matte chanel is ignored (set to 255, full coverage).</td>
</tr>

<tr>
<td>AddCompositeOp</td>

<td>The result of <i>composite image</i> + <i>image</i>, with overflow
wrapping around (mod 256).</td>
</tr>

<tr>
<td>SubtractCompositeOp</td>

<td>The result of <i>composite image </i>- <i>image</i>, with underflow
wrapping around (mod 256). The add and subtract operators can be used to
perform reverible transformations.</td>
</tr>

<tr>
<td>DifferenceCompositeOp</td>

<td>The result of abs(c<i>omposite image </i>- <i>image</i>). This is useful
for comparing two very similar images.</td>
</tr>

<tr>
<td>BumpmapCompositeOp</td>

<td>The result <i>image</i> shaded by <i>composite image.</i></td>
</tr>

<tr>
<td>ReplaceCompositeOp</td>

<td>The resulting <i>image</i> is image replaced with c<i>omposite image</i>.
Here the matte information is ignored.</td>
</tr>

<tr>
<td>ReplaceRedCompositeOp</td>

<td>The resulting image is the red layer in <i>image</i> replaced with
the red layer in <i>composite image</i>. The other layers are copied untouched.</td>
</tr>

<tr>
<td>ReplaceGreenCompositeOp</td>

<td>The resulting image is the green layer in <i>image</i> replaced with
the green layer in <i>composite image</i>. The other layers are copied
untouched.</td>
</tr>

<tr>
<td>ReplaceBlueCompositeOp</td>

<td>The resulting image is the blue layer in <i>image</i> replaced with
the blue layer in <i>composite image</i>. The other layers are copied untouched.</td>
</tr>

<tr>
<td>ReplaceMatteCompositeOp</td>

<td>The resulting image is the matte layer in <i>image</i> replaced with
the matte layer in <i>composite image</i>. The other layers are copied
untouched.
<p>The image compositor requires a matte, or alpha channel in the image
for some operations. This extra channel usually defines a mask which represents
a sort of a cookie-cutter for the image. This is the case when matte is
255 (full coverage) for pixels inside the shape, zero outside, and between
zero and 255 on the boundary.&nbsp; For certain operations, if <i>image</i>
does not have a matte channel, it is initialized with 0 for any pixel matching
in color to pixel location (0,0), otherwise 255 (to work properly <i>borderWidth</i>
must be 0).</td>
</tr>
</table>

<center>
<h3>
<a NAME="CompressionType"></a><b>Magick::CompressionType</b></h3></center>
<i>CompressionType</i> is used to express the desired compression type
when encoding an image. Be aware that most image types only support a sub-set
of the available compression types. If the compression type specified is
incompatable with the image, ImageMagick selects a compression type compatable
with the image type.
<br>&nbsp;
<table BORDER WIDTH="100%" NOSAVE >
<caption><b>Magick::CompressionType</b></caption>

<tr>
<td>
<center><b>Enumeration</b></center>
</td>

<td>
<center><b>Description</b></center>
</td>
</tr>

<tr>
<td>UndefinedCompression</td>

<td>Unset value.</td>
</tr>

<tr NOSAVE>
<td NOSAVE>NoCompression</td>

<td>No compression</td>
</tr>

<tr NOSAVE>
<td>BZipCompression</td>

<td NOSAVE>BZip (Burrows-Wheeler block-sorting text compression algorithm
and Huffman coding)&nbsp; as used by bzip2 utilities</td>
</tr>

<tr>
<td>FaxCompression</td>

<td>CCITT Group 3 FAX compression</td>
</tr>

<tr>
<td>Group4Compression</td>

<td>CCITT Group 4 FAX compression (used only for TIFF)</td>
</tr>

<tr>
<td>JPEGCompression</td>

<td>JPEG compression</td>
</tr>

<tr>
<td>LZWCompression</td>

<td>Lempel-Ziv-Welch (LZW) compression (caution, patented by Unisys)</td>
</tr>

<tr>
<td>RunlengthEncodedCompression</td>

<td>Run-Length encoded (RLE) compression</td>
</tr>

<tr>
<td>ZipCompression</td>

<td>Lempel-Ziv compression (LZ77) as used in PKZIP and GNU gzip.</td>
</tr>
</table>

<br>&nbsp;
<center>
<h3>
<a NAME="FilterType"></a><b>Magick::FilterType</b></h3></center>
<i>FilterType</i> is used to adjust the filter algorithm used when resizing
images. Different filters experience varying degrees of success with various
images and can take sigificantly different amounts of processing time.
ImageMagick uses the <i>LanczosFilter</i> by default since this filter
has been shown to provide the best results for most images in a reasonable
amount of time. Other filter types (e.g. <i>TriangleFilter</i>) may execute
much faster but may show artifacts when the image is re-sized or around
diagonal lines. The only way to be sure is to test the filter with sample
images.
<br>&nbsp;
<table BORDER WIDTH="100%" NOSAVE >
<caption><b>Magick::FilterType</b></caption>

<tr>
<td>
<center><b>Enumeration</b></center>
</td>

<td>
<center><b>Description</b></center>
</td>
</tr>

<tr NOSAVE>
<td NOSAVE>UndefinedFilter</td>

<td>Unset value.</td>
</tr>

<tr>
<td>PointFilter</td>

<td>Point Filter</td>
</tr>

<tr>
<td>BoxFilter</td>

<td>Box Filter</td>
</tr>

<tr>
<td>TriangleFilter</td>

<td>Triangle Filter</td>
</tr>

<tr NOSAVE>
<td NOSAVE>HermiteFilter</td>

<td>Hermite Filter</td>
</tr>

<tr>
<td>HanningFilter</td>

<td>Hanning Filter</td>
</tr>

<tr>
<td>HammingFilter</td>

<td>Hamming Filter</td>
</tr>

<tr>
<td>BlackmanFilter</td>

<td>Blackman Filter</td>
</tr>

<tr>
<td>GaussianFilter</td>

<td>Gaussian Filter</td>
</tr>

<tr>
<td>QuadraticFilter</td>

<td>Quadratic Filter</td>
</tr>

<tr>
<td>CubicFilter</td>

<td>Cubic Filter</td>
</tr>

<tr>
<td>CatromFilter</td>

<td>Catrom Filter</td>
</tr>

<tr>
<td>MitchellFilter</td>

<td>Mitchell Filter</td>
</tr>

<tr>
<td>LanczosFilter</td>

<td>Lanczos Filter</td>
</tr>

<tr>
<td>BesselFilter</td>

<td>Bessel Filter</td>
</tr>

<tr>
<td>SincFilter</td>

<td>Sinc Filter</td>
</tr>
</table>

<center>
<h3>
<a NAME="GravityType"></a><b>Magick::GravityType</b></h3></center>
Gravity specifies positioning of an object (e.g. text, image) within a
bounding region (e.g. an image). Gravity provides a convenient way to locate
objects irrespective of the size of the bounding region, in other words,
you don't need to provide absolute coordinates in order to position an
object. A common default for gravity is <i>NorthWestGravity</i>.
<br>&nbsp;
<br>&nbsp;
<table BORDER WIDTH="100%" NOSAVE >
<caption><b>Magick::GravityType</b></caption>

<tr>
<td>
<center><b>Enumeration</b></center>
</td>

<td>
<center><b>Description</b></center>
</td>
</tr>

<tr>
<td>ForgetGravity</td>

<td>Don't use gravity.</td>
</tr>

<tr>
<td>NorthWestGravity</td>

<td>Position object at top-left of region.</td>
</tr>

<tr NOSAVE>
<td NOSAVE>NorthGravity</td>

<td>Postiion object at top-center of region</td>
</tr>

<tr>
<td>NorthEastGravity</td>

<td>Position object at top-right of region</td>
</tr>

<tr>
<td>WestGravity</td>

<td>Position object at left-center of region</td>
</tr>

<tr>
<td>CenterGravity</td>

<td>Position object at center of region</td>
</tr>

<tr>
<td>EastGravity</td>

<td>Position object at right-center of region</td>
</tr>

<tr>
<td>SouthWestGravity</td>

<td>Position object at left-bottom of region</td>
</tr>

<tr>
<td>SouthGravity</td>

<td>Position object at bottom-center of region</td>
</tr>

<tr>
<td>SouthEastGravity</td>

<td>Position object at bottom-right of region</td>
</tr>
</table>

<center>
<h3>
<a NAME="ImageType"></a><b>Magick::ImageType</b></h3></center>
The ImageType enumeration indicates the type classification of the image.
<br>&nbsp;
<table BORDER WIDTH="100%" NOSAVE >
<caption><b>Magick::ImageType</b></caption>

<tr>
<td>
<center><b>Enumeration</b></center>
</td>

<td>
<center><b>Description</b></center>
</td>
</tr>

<tr>
<td>UndefinedType</td>

<td>Unset value.</td>
</tr>

<tr>
<td>BilevelType</td>

<td>Monochrome image</td>
</tr>

<tr>
<td>GrayscaleType</td>

<td>Grayscale image</td>
</tr>

<tr NOSAVE>
<td NOSAVE>PaletteType</td>

<td>Indexed color (palette) image</td>
</tr>

<tr>
<td>TrueColorType</td>

<td>Truecolor image</td>
</tr>

<tr>
<td>MatteType</td>

<td>Truecolor with opacity image</td>
</tr>

<tr>
<td>ColorSeparationType</td>

<td>Cyan/Yellow/Magenta/Black (CYMK) image</td>
</tr>
</table>

<center>
<h3>
<a NAME="InterlaceType"></a><b>Magick::InterlaceType</b></h3></center>
<i>InterlaceType</i> specifies the ordering of the red, green, and blue
pixel information in the image. Interlacing is usually used to make image
information available to the user faster by taking advantage of the space
vs time tradeoff. For example, interlacing allows images on the Web to
be recognizable sooner and satellite images to accumulate/render with image
resolution increasing over time.
<p>Use <i>LineInterlace</i> or <i>PlaneInterlace</i> to create an interlaced
GIF or progressive JPEG image.
<br>&nbsp;
<table BORDER WIDTH="100%" NOSAVE >
<caption><b>Magick::InterlaceType</b></caption>

<tr>
<td>
<center><b>Enumeration</b></center>
</td>

<td>
<center><b>Description</b></center>
</td>
</tr>

<tr>
<td>UndefinedInterlace</td>

<td>Unset value.</td>
</tr>

<tr NOSAVE>
<td NOSAVE>NoInterlace</td>

<td>Don't interlace image (RGBRGBRGBRGBRGBRGB...)</td>
</tr>

<tr>
<td>LineInterlace</td>

<td>Use scanline interlacing (RRR...GGG...BBB...RRR...GGG...BBB...)</td>
</tr>

<tr>
<td>PlaneInterlace</td>

<td>Use plane interlacing (RRRRRR...GGGGGG...BBBBBB...)</td>
</tr>

<tr>
<td>PartitionInterlace</td>

<td>Similar to plane interlaing except that the different planes are saved
to individual files (e.g. image.R, image.G, and image.B)</td>
</tr>
</table>

<center>
<h3>
<a NAME="LayerType"></a><b>Magick::LayerType</b></h3></center>
<i>LayerType</i> is used as an argument when doing color separations. Use
<i>LayerType</i>
when extracting a layer from an image. <i>MatteLayer</i> is useful for
extracting the opacity values from an image.
<br>&nbsp;
<table BORDER WIDTH="100%" NOSAVE >
<caption><b>Magick::LayerType</b></caption>

<tr>
<td>
<center><b>Enumeration</b></center>
</td>

<td>
<center><b>Description</b></center>
</td>
</tr>

<tr>
<td>UndefinedLayer</td>

<td>Unset value.</td>
</tr>

<tr NOSAVE>
<td NOSAVE>RedLayer</td>

<td>Select red layer</td>
</tr>

<tr>
<td>GreenLayer</td>

<td>Select green layer</td>
</tr>

<tr>
<td>BlueLayer</td>

<td>Select blue layer</td>
</tr>

<tr>
<td>MatteLayer</td>

<td>Select matte (opacity values) layer</td>
</tr>
</table>

<center>
<h3>
<a NAME="NoiseType"></a><b>Magick::NoiseType</b></h3></center>
NoiseType is used as an argument to select the type of noise to be added
to the image.
<br>&nbsp;
<table BORDER COLS=2 WIDTH="100%" NOSAVE >
<caption><b>Magick::NoiseType</b></caption>

<tr>
<td>
<center><b>Enumeration</b></center>
</td>

<td>
<center><b>Description</b></center>
</td>
</tr>

<tr>
<td>UniformNoise</td>

<td>Uniform noise</td>
</tr>

<tr>
<td>GaussianNoise</td>

<td>Gaussian noise</td>
</tr>

<tr NOSAVE>
<td>MultiplicativeGaussianNoise</td>

<td NOSAVE>Multiplicative Gaussian noise</td>
</tr>

<tr>
<td>ImpulseNoise</td>

<td>Impulse noise</td>
</tr>

<tr>
<td>LaplacianNoise</td>

<td>Laplacian noise</td>
</tr>

<tr>
<td>PoissonNoise</td>

<td>Poisson noise</td>
</tr>
</table>

<center>
<h3>
<a NAME="PaintMethod"></a><b>Magick::PaintMethod</b></h3></center>
PaintMethod specifies how pixel colors are to be replaced in the image.
It is used to select the pixel-filling algorithm employed.
<br>&nbsp;
<table BORDER WIDTH="100%" NOSAVE >
<caption><b>Magick::PaintMethod</b></caption>

<tr>
<td>
<center><b>Enumeration</b></center>
</td>

<td>
<center><b>Description</b></center>
</td>
</tr>

<tr>
<td>PointMethod</td>

<td>Replace pixel color at point.</td>
</tr>

<tr>
<td>ReplaceMethod</td>

<td>Replace color for all image pixels matching color at point.</td>
</tr>

<tr NOSAVE>
<td>FloodfillMethod</td>

<td NOSAVE>Replace color for pixels surrounding point until encountering
pixel that fails to match color at point.</td>
</tr>

<tr>
<td>FillToBorderMethod</td>

<td>Replace color for pixels surrounding point until encountering pixels
matching border color.</td>
</tr>

<tr>
<td>ResetMethod</td>

<td>Replace colors for <b>all</b> pixels in image with pen color.</td>
</tr>
</table>

<center>
<h3>
<a NAME="RenderingIntent"></a><b>Magick::RenderingIntent</b></h3></center>
Rendering intent is a concept defined by <a href="http://www.color.org/">ICC</a>
Spec ICC.1:1998-09, "File Format for Color Profiles". ImageMagick uses
<i>RenderingIntent</i>
in order to support ICC Color Profiles.
<p>From the specification: "Rendering intent specifies the style of reproduction
to be used during the evaluation of this profile in a sequence of profiles.
It applies specifically to that profile in the sequence and not to the
entire sequence. Typically, the user or application will set the rendering
intent dynamically at runtime or embedding time."
<br>&nbsp;
<table BORDER WIDTH="100%" NOSAVE >
<caption><b>Magick::RenderingIntent</b></caption>

<tr>
<td>
<center><b>Enumeration</b></center>
</td>

<td>
<center><b>Description</b></center>
</td>
</tr>

<tr>
<td>UndefinedIntent</td>

<td>Unset value.</td>
</tr>

<tr NOSAVE>
<td NOSAVE>SaturationIntent</td>

<td>A rendering intent that specifies the saturation of the pixels in the
image is preserved perhaps at the expense of accuracy in hue and lightness.</td>
</tr>

<tr>
<td>PerceptualIntent</td>

<td>A rendering intent that specifies the full gamut of the image is compressed
or expanded to fill the gamut of the destination device. Gray balance is
preserved but colorimetric accuracy might not be preserved.</td>
</tr>

<tr>
<td>AbsoluteIntent</td>

<td>Absolute colorimetric</td>
</tr>

<tr>
<td>RelativeIntent</td>

<td>Relative colorimetric</td>
</tr>
</table>

<center>
<h3>
<a NAME="ResolutionType"></a><b>Magick::ResolutionType</b></h3></center>
By default, ImageMagick defines resolutions in pixels per inch. <i>ResolutionType</i>
provides a means to adjust this.
<br>&nbsp;
<table BORDER WIDTH="100%" NOSAVE >
<caption>
<center><b>Magick::ResolutionType</b></center>
</caption>

<tr>
<td>
<center><b>Enumeration</b></center>
</td>

<td>
<center><b>Description</b></center>
</td>
</tr>

<tr>
<td>UndefinedResolution</td>

<td>Unset value.</td>
</tr>

<tr NOSAVE>
<td NOSAVE>PixelsPerInchResolution</td>

<td>Density specifications are specified in units of pixels per inch (english
units).</td>
</tr>

<tr>
<td>PixelsPerCentimeterResolution</td>

<td>Density specifications are specified in units of pixels per centimeter
(metric units).</td>
</tr>
</table>

</body>
</html>
