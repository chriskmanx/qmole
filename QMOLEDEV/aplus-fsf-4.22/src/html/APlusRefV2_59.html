<HTML>
<HEAD>
<TITLE>A+ Reference: The t Context</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<A NAME=HEADING863>
<H1><FONT color="#FF0000">The <A NAME=0>t Context</FONT></H1>
<a name="CONTENTS58">
<UL>
<A HREF="#HEADING864"> Introduction</A><BR>
<UL>
<A HREF="#HEADING865"> t-Tables: Base Tables and Views</A><BR>
<A HREF="#HEADING866"> Table and Column Names</A><BR>
<A HREF="#HEADING867"> Table Row and Column Domains</A><BR>
<A HREF="#HEADING868"> About the Examples</A><BR>
</UL>
<A HREF="#HEADING869"> Row and Column Selection</A><BR>
<UL>
<A HREF="#HEADING870"> How t Manages Row and Column Selection</A><BR>
</UL>
<A HREF="#HEADING871"> Group Fields and Group Functions</A><BR>
<UL>
<A HREF="#HEADING872">Table:&nbsp; Partitioning of the employees Table Based on One and Two Group Fields</A><BR>
<A HREF="#HEADING873"> How t Manages Group Fields</A><BR>
<A HREF="#HEADING874"> Grouping by Intervals</A><BR>
<A HREF="#HEADING875"> Static Grouping</A><BR>
<A HREF="#HEADING876"> Successive Multiple Group Fields</A><BR>
</UL>
<A HREF="#HEADING877"> Linking Tables</A><BR>
<UL>
<A HREF="#HEADING878">Table:&nbsp; Row Index Correspondence of departments and employees based on dept_no </A><BR>
<A HREF="#HEADING879"> How t Manages Table Links</A><BR>
<A HREF="#HEADING880"> Multiple Group Fields</A><BR>
<A HREF="#HEADING881"> Duplicate Items in a Link Field on the Partition Side</A><BR>
<A HREF="#HEADING882"> Static Links</A><BR>
</UL>
<A HREF="#HEADING883"> The Relational Set Operations: Union, Intersection, and Difference</A><BR>
<UL>
<A HREF="#HEADING884"> Intersection</A><BR>
<A HREF="#HEADING885"> Set Difference</A><BR>
<A HREF="#HEADING886"> Union</A><BR>
<A HREF="#HEADING887"> Outer Union</A><BR>
</UL>
<A HREF="#HEADING888"> Definitions of t-Context Functions</A><BR>
<UL><UL>
<A HREF="#HEADING889"> Selectors</A><BR>
<A HREF="#HEADING890"> Dependency Frames</A><BR>
<A HREF="#HEADING891"> How Group Functions are Specified and How t Applies Them</A><BR>
</UL>
<A HREF="#HEADING892"> Business Days</A><font face=Kapl> t.calendar{s}</font><BR>
<A HREF="#HEADING893"> Calendar Indices</A><font face=Kapl> t.series{w;x}</font><BR>
<A HREF="#HEADING894"> Catenation</A><font face=Kapl> t.cat{w;}</font><BR>
<A HREF="#HEADING895"> Close Columns of a Table</A><font face=Kapl> t.close{w;f}</font><BR>
<A HREF="#HEADING896"> Complement</A><font face=Kapl> t.not{w;e}</font><BR>
<A HREF="#HEADING897"> Create and Initialize a Base Table</A><font face=Kapl> t.open{w;x}</font><BR>
<A HREF="#HEADING898"> Define a Column</A><font face=Kapl> t.define{w;x}</font><BR>
<A HREF="#HEADING899"> Detach a Column from its Sources</A><font face=Kapl> t.detach{w;x}</font><BR>
<A HREF="#HEADING900"> Direct Static Link</A><font face=Kapl> t.link_d{w;f}</font><BR>
<A HREF="#HEADING901"> Direct Static Summary</A><font face=Kapl> t.group_d{w;f}</font><BR>
<A HREF="#HEADING902"> Disperse</A><font face=Kapl> t.disperse{w;s}</font><BR>
<A HREF="#HEADING903"> Dynamic Derived Table</A><font face=Kapl> t.always{w;e}</font><BR>
<A HREF="#HEADING904"> Dynamic Sorted Derived Table</A><font face=Kapl> t.sorted{w;x}</font><BR>
<A HREF="#HEADING905"> Find</A><font face=Kapl> t.in{a;b}</font><BR>
<A HREF="#HEADING906"> Fix a View</A><font face=Kapl> t.fix{d;b}</font><BR>
<A HREF="#HEADING907"> Index</A><font face=Kapl> t.index{i;x}</font><BR>
<A HREF="#HEADING908"> Indirect Static Link</A><font face=Kapl> t.link_i{w;f}</font><BR>
<A HREF="#HEADING909"> Indirect Static Summary</A><font face=Kapl> t.group_i{w;f}</font><BR>
<A HREF="#HEADING910"> Lightweight Column Definition</A><font face=Kapl> t.let{d;f}</font><BR>
<A HREF="#HEADING911"> Link and Send</A><font face=Kapl> t.relate{s;d;f;g;h}</font><BR>
<A HREF="#HEADING912"> Link Two Tables</A><font face=Kapl> t.link{w;f}</font><BR>
<A HREF="#HEADING913"> Link, with Permutation</A><font face=Kapl> t.link_b{w;f}</font><BR>
<A HREF="#HEADING914"> NA Value</A><font face=Kapl> t.na{x}</font><BR>
<A HREF="#HEADING915"> Populate a View Table</A><font face=Kapl> t.send{w;f}</font><BR>
<A HREF="#HEADING916"> Random Sample</A><font face=Kapl> t.sample{w;n}</font><BR>
<A HREF="#HEADING917"> Reset</A><font face=Kapl> t.reset{}</font><BR>
<A HREF="#HEADING918"> Restrict a Table</A><font face=Kapl> t.only{w;e}</font><BR>
<A HREF="#HEADING919"> Screen Table</A><font face=Kapl> t.table{w}</font><BR>
<A HREF="#HEADING920"> Sort</A><font face=Kapl> t.sort{w;x}</font><BR>
<A HREF="#HEADING921"> Successive Grouping</A><font face=Kapl> t.report{w;f}</font><BR>
<A HREF="#HEADING922"> Summarize a Table</A><font face=Kapl> t.group{w;f}</font> or <font face=Kapl>t.break{w;f}</font><BR>
<A HREF="#HEADING923"> Summarize and Send</A><font face=Kapl> t.partition{s;d;f;g}</font><BR>
<A HREF="#HEADING924"> Union</A><font face=Kapl> t.also{w;e}</font><BR>
<A HREF="#HEADING925"> View and Send</A><font face=Kapl> t.view{s;d;f}</font><BR>
</UL>
<A HREF="#HEADING926"> Table Variables and Dependencies</A><BR>
<UL>
<A HREF="#HEADING927">Table:&nbsp; t-Context Global Objects</A><BR>
<A HREF="#HEADING928">Table:&nbsp; t-Created Variables, Dependencies Common to All Table Contexts</A><BR>
</UL>
</UL>
<HR>
<A NAME=HEADING864>
<H1><FONT color="#20B2AA"><A NAME=3>Introduction</FONT></H1>
<blockquote>
In order to establish the t context, it is necessary to perform a<font face=Kapl> $load&nbsp;t</font>.<P>
Just as the screen management system, the s context, provides the support for displaying tables on screens, the t context provides support for creating and manipulating tables in ways conforming to database queries.  Like tables in the table display class (s-tables), t-tables are composed of <i>column</i>, or <i>field</i>, variables.  However, t-tables are more complex.  Each t-table is represented by an A+ context with the same name as the table, containing the column variables of the table as well as a set of variables and dependencies describing various characteristics of the table and its relationships to other tables; this set is described in the table "<A href="#143">t-Created Variables, Dependencies Common to All Table Contexts</A>".  For example, the variable <font face=Kapl>_T</font> is a list of the names of the column variables as symbols, and appears in every t-table context.  Programmers can define their own variables and dependencies in terms of this set, thereby integrating t-tables into their applications and synchronizing changes in data.  The t-generated objects in the table contexts are called <i>table variables</i> and <i>table dependencies</i>.  They, and column variables, are referred to here by their unqualified names unless it is necessary to do otherwise.<P>
With regard to database maintenance and manipulation, t is the manipulation component,
 i.e., the computational engine that implements query languages. It can be helpful to think
 of the t functions in terms of relational operations, which are conceptually simple and
 have proven to be an effective, complete set for implementing database queries. Even
 though there is not an exact fit between t functions and relational operations, they are
 comparable.  See "<A HREF="#30">The Relational Set Operations: Union, Intersection, and
 Difference</A>" for examples of defining relational operations in terms of t.<P>
<!----
See "<A HREF="APlusRefV2_2.html#3">Other Sources of A+ Information</A>" regarding aids to
 using SYBASE and SQL through A+.
//---->
</blockquote>
<A NAME=HEADING865>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;t-Tables: <A NAME=5>Base Tables and
 Views</FONT></H2>
<blockquote>
Every t-table is an A+ context; the name of the table is the name of the context. As the
 last sentence illustrates, t-tables will be referred to simply as tables where the context
 permits. The function <font face=Kapl>t.open</font> is the means of creating and
 initializing t-tables from mapped files, text files, and ordinary variables and
 dependencies. Tables created by <font face=Kapl>t.open</font> are called <i>base
 tables</i>. Other tables, called <i>views</i> or <i>derived tables</i>, are created from
 base tables and other views. In the process of creating a view, the view is called the
 <i>target</i>, and the table(s) from which it is created the <i>source(s)</i>. A view of
 the table <font face=Kapl>X</font>, for example, can be created as the result of applying
 a selection function such as <font face=Kapl>t.only</font> to <font face=Kapl>X</font>, or
 the summarization function <font face=Kapl>t.group</font> (for which
 <font face=Kapl>t.break</font> is a synonym). At the time of creation the view has no
 columns; it is populated by sending it some or all of the columns of
 <font face=Kapl>X</font> with the function <font face=Kapl>t.send</font>. The selection
 functions can also operate on views in place, i.e., without creating a second view to hold
 the selection; they cannot be applied to base tables in place. The function
 <font face=Kapl>t.define</font> is used to append new fields to existing tables. The
 function <font face=Kapl>t.link</font> is the means for relating one table to another; it
 includes a variation of <font face=Kapl>t.group</font>, and is the most distinctive
 feature of t.<P>
Not all t-tables are valid s-tables. The definition of <font face=Kapl>t.open</font> gives
 the full range of possibilities for t-tables.  See <font face=Kapl>t.table</font> for
 extracting the subset of a t-table that can be displayed on the screen.
</blockquote>
<A NAME=HEADING866>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Table and Column Names</FONT></H2>
<blockquote>
Names of tables and table columns always appear as symbols in A+ expressions, but elsewhere in this chapter they often appear in ordinary font.<P>
Tables are contexts, and while it is common to refer to objects in contexts by their fully qualified names, this is not the case for table columns.  Unqualified column names should always be used in the arguments of the t functions except for columns outside the table context; the table will be determined from context.<P>
Column names cannot begin with an underbar (<font face=Kapl>_</font>).
</blockquote>
<A NAME=HEADING867>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Table <A NAME=6>Row and Column Domains</FONT></H2>
<blockquote>
A table column is an A+ array whose <i>length</i> is its item count.  If all columns of a table have the same length, one can speak of the <i>length of the table</i> as the common length of its columns.  Like s-tables, t-tables need not have columns whose lengths are all the same, although that is most generally useful.  It is assumed in all examples in this chapter that all columns of a table have the same length.  When that assumption is true, the length of the table is maintained in the table variable <font face=Kapl>_N</font>.  Otherwise, <font face=Kapl>_N</font> is the number of items in the column named by <font face=Kapl>0#_T</font>, where <font face=Kapl>_T</font> is the table variable holding a list of all column names.<P>
If c1, c2, ... , cn are columns in a table then the list <font face=Kapl>(i#`c1;i#`c2;...;i#`cn)</font> is called their <font face=Kapl>i</font>th <i>row</i>, and if these are all the columns, then the list is called the <font face=Kapl>i</font>th <i>row of the table</i>.<P>
The <i>domain</i> of a table column consists of the shape of its items and its general type; two table columns are in the same domain if they are a valid left argument, right argument pair for the Catenate primitive.  More generally, two sets of table columns <font face=Kapl>c1, c2,</font> ... <font face=Kapl>, cn</font> and <font face=Kapl>d1, d2,</font> ... <font face=Kapl>, dn</font> are said to be in the <i>same domain</i> if every pair <font face=Kapl>ci</font> and <font face=Kapl>di</font> are in the same domain.<P>
See "<A HREF="#9">Row and Column Selection</A>", below, for more on the relationship between base tables and views.<P>
It is generally assumed throughout this chapter, unless something is said to the contrary, that tables have distinct rows.  This assumption is not restrictive in practice: when tables are constructed, intermediate results may have duplicate rows, but otherwise it is very rare for duplicate rows to be of use.
</blockquote>
<A NAME=HEADING868>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;About the Examples</FONT></H2>
<blockquote>
The <A NAME=7>tables and A+ expressions for creating the examples can be found online. The
 mapped files for these tables are created by the A+ script<font face=Courier>
 /usr/local/aplus-fsf-4.18/doc/tutorials/t.tutorial/files.+ </font>and the t tables
 are loaded by the A+ script<font face=Courier> model.+ </font>in the same directory. To
 create your own copies of the mapped files and experiment with variations of the t tables,
 make copies of these scripts and change their directory variables. There is also a script
 that recreates the examples in the text. See the <font face=Courier>README</font> file in
 that directory for more information.<P>
Only the tables named <font face=Kapl>employees</font> and <font face=Kapl>departments</font> are actually used in this
 document (see the base tables <A href="#GIF199">figure</A>).  They are created using the
 t function <font face=Kapl>t.open</font>, as follows:
</blockquote>
<pre><font face=Kapl>   $load t
   directoryû"/usr/local/aplus-fsf-4.18/doc/tutorials/t.tutorial/files/"
   (`departments;directory) t.open (
                            `dept_no;"0àdept.dept_no";
                            `dept_name;"¢1àdept.dept_name";
                            `mgr;"0àdept.mgr";
                            `supdept;"0àdept.supdept")
   (`employees;directory) t.open (
                            `emp_no;"0àemp.emp_no";
                            `emp_name;"¢1àemp.emp_name";
                            `dept_no;"0àemp.dept_no";
                            `hire_date;"0àemp.hire_date";
                            `sex;"0àemp.sex";
                            `salary;"0àemp.salary";
                            `commission;"0àemp.commission")
   employees.emp_nameûÎØÂ¡employees.emp_name</font></pre>
</blockquote>
<A NAME=GIF199><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Base Tables:</b>
<blockquote>
<IMG SRC="APlusRefV2_AFrame_199.gif"><P>
</blockquote>
<A NAME=HEADING869>
<H2><FONT color="#20B2AA">Row <A NAME=9>and Column Selection</FONT></H2>
<blockquote>
Row and column selection in t is done using <font face=Kapl>t.only</font> and <font face=Kapl>t.send</font>.  For example, the <font face=Kapl>employees</font> table in the <A href="#GIF199">figure</A> can be restricted to departments D11, D21, and D31 as follows:
<pre><font face=Kapl>   `employees `r_view t.only 'dept_noÅ3 3Ò"D11D21D31"'
   `employees `r_view t.send ()</font></pre>
Selection of the rows is done by <font face=Kapl>t.only</font> and is similar to the A+ primitive function called Replicate.  The left argument specifies the source table on which the selection is made and the target, in which the selection is realized.  The right argument is a character vector holding a boolean-valued expression that specifies the rows to be selected.  The view can already exist or not; if it already exists then its current definition is closed (see <font face=Kapl>t.close</font>) and replaced with the new one.<P>
Once <font face=Kapl>t.only</font> is executed, the table <font face=Kapl>r_view</font> has been created but has no columns.  To complete the row selection, send the columns of the source to the target.  The right argument <font face=Kapl>()</font> to <font face=Kapl>t.send</font> indicates that all columns are to be sent.  See the selection <A href="#GIF201">figure</A> for the result of this selection.<P>
As for column selection, columns <font face=Kapl>emp_no</font>, <font face=Kapl>emp_name</font>, and <font face=Kapl>dept_no</font> of the employees table can be selected as follows:
<pre><font face=Kapl>   `employees `p_view t.only ()
   `employees `p_view t.send `emp_no `emp_name `salary</font></pre>
The right argument <font face=Kapl>()</font> to <font face=Kapl>t.only</font> indicates that all rows are selected, and the right argument to <font face=Kapl>t.send</font> specifies the columns to send to the selection table, p_view.  See the <A href="#GIF201">figure</A>.<P>
Row and column selection can be combined.  For example, a view of the <font face=Kapl>emp_no</font>, <font face=Kapl>emp_name</font>, and <font face=Kapl>salary</font> columns for all employees in departments D11, D21, and D31 is:
<pre><font face=Kapl>   `employees `rp_view t.only 'dept_noÅ3 3Ò"D11D21D31"'
   `employees `rp_view t.send `emp_no `emp_name `salary</font></pre>
There is a utility function in t named <font face=Kapl>t.in</font> that allows a more English like specification of a set of values in a selection, in this case<BR ><font face=Kapl>"D11,D21,D31"</font> in place of <BR ><font face=Kapl>3 3Ò"D11D21D31"</font>.  See "<A HREF="#37">Selectors</A>" for more on this topic.<P>
There are several other points to be made about row selection.  First of all, it is not necessary to do the row selection all at once.  For example, after making the department selections above, department E01 can be added to the selection as follows:
<pre><font face=Kapl>   `employees `rp_view t.also 'dept_noÅ1 3Ò"E01"'</font></pre>
When both the source and target are specified in the left argument to <font face=Kapl>t.also</font>, the selection is evaluated on the source table.  However, if only the target is specified in that left argument, the selection is evaluated on the complement of the target (those rows that are not currently selected), and the result is appended to the target.  In the latter case, any columns named in the selection must have been sent to the target before the selection is made.<P>
For example, the selection using <font face=Kapl>t.also</font> above can be rephrased as:
<pre><font face=Kapl>   `employees `rp_view t.send `dept_no
   `rp_view t.also 'dept_noÅ1 3Ò"E01"'</font></pre>
Note that this formulation tends to be more efficient than the one above, which refers to all rows of the source table.<P>
Applications of <font face=Kapl>t.also</font> have the effect of ORing the selection specified in its right argument with any previous selections made with this function.  If a subsequent selection is done with <font face=Kapl>t.only</font>, it will replace the existing one.<P>
By default, selections ultimately refer to the entire source table of a view, or to the entire complement of a view in its source table.  For example, if the following selection is now executed:
<pre><font face=Kapl>   `employees `rp_view t.send `emp_no
   `rp_view t.also 'emp_noÅ60 90'</font></pre>
then one more row will appear in <font face=Kapl>rp_view</font>, the one for the employee with employee number 90, because that employee's department is not one of D11, D21, D31, and E01.  If, however, the view had been fixed before the employee number selection was made, as in:
<pre><font face=Kapl>   `rp_view t.fix 1</font></pre>
then the employee number selection would have applied only to the rows in the view table at the time that <font face=Kapl>t.fix</font> is executed, and consequently, no new rows would appear.  The logical effect of executing <font face=Kapl>t.fix</font> with a right argument of 1 is to And the selections made before its execution with those that follow, and a practical effect is to make subsequent selections more efficient by limiting their scope.
</blockquote>
<A NAME=HEADING870>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;How t <A NAME=10>Manages Row and Column Selection</FONT></H2>
<blockquote>
Every view table created by <font face=Kapl>t.only</font> has a table variable <font face=Kapl>_V</font>, which is a vector of row indices in the source table of the view that reflects any row selections done on the source; the <font face=Kapl>i</font>th item of any column sent to the view will be the<font face=Kapl> _V[i]</font>th item of the source column.  The value of <font face=Kapl>_V</font> is kept current with all selections and reordering of the rows in the view.<P>
When a column <font face=Kapl>col</font> is sent from a source table <font face=Kapl>src</font> to a target table <font face=Kapl>tar</font>, the target column is, in the default case, defined by the following dependency in the <font face=Kapl>tar</font> context:
<pre><font face=Kapl>     col:_V#src.col</font></pre>
Actually, the dependency is somewhat more complicated, and more like:
<pre><font face=Kapl>     col:_index{_V;src.col;NA}</font></pre>
where <font face=Kapl>NA</font> denotes the appropriate NA value to be used when indices in <font face=Kapl>_V</font> are out of range; see the definition of <font face=Kapl>t.index</font>, and the <font face=Kapl>`na</font> attribute in the definition of <font face=Kapl>t.open</font>.  This default dependency definition can be modified when the source column is sent; see "<A HREF="#39">Dependency Frames</A>" and the definition of <font face=Kapl>t.send</font>.<P>
The dependencies provide mappings from source columns to view columns.  There are also mapping provided by t in the other direction, from view columns to source columns.  These are accomplished by putting callbacks on the view columns which make the appropriate updates to source columns whenever they are called.<P>
Column selections are similarly maintained in the table variable <font face=Kapl>_T</font>.
</blockquote>
<A NAME=GIF201><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Row and Column Selection:</b>
<blockquote>
<IMG SRC="APlusRefV2_AFrame_201.gif"><P>
</blockquote>
<A NAME=HEADING871>
<H2><FONT color="#20B2AA">Group <A NAME=13>Fields and Group Functions</FONT></H2>
<blockquote>
The purpose of group fields is to <i>partition</i>, or <i>categorize</i>, or <i>group</i>
 the rows of a table by equal values in a selected column or equal sets of values in a set
 of columns, or by values within specified intervals in a column or set of columns. For
 example, consider the <font face=Kapl>dept_no</font> and <font face=Kapl>sex</font>
 columns in the <font face=Kapl>employees</font> table in the base table
 <A href="#GIF199">figure</A>.<P>
The two columns on the left in the partitioning <A HREF="#14">table</A> show the distinct entries in the <font face=Kapl>dept_no</font> column and the row indices for the employees in each department.  For instance, the employees in department D11 are in rows 4, 10, 11, and 12 of the <font face=Kapl>employees</font> table.  Thus the second column represents the partitioning when the column <font face=Kapl>dept_no</font> is the group field.<P>
The two columns on the right in this <A HREF="#14">table</A> represent the partitioning when the columns <font face=Kapl>dept_no</font> and <font face=Kapl>sex</font> are the set of group fields.  When <font face=Kapl>dept_no</font> alone is the group field there are eight groups in the partition because there are eight department numbers.  When <font face=Kapl>dept_no</font> and <font face=Kapl>sex</font> are the set of group fields there are sixteen groups, consisting of the females in each of the eight departments, and the males in each department.<P>
<A NAME=HEADING872>
<table border=1 cellspacing=0 cellpadding=8>
<caption><FONT color="#20B2AA" size=+2><B>
Partitioning <A NAME=14>of the employees Table Based on One and Two Group Fields</B></FONT>
</caption>
<tr>
<th rowspan=2>dept_no</th><th>One Group Field: dept_no</th>
<th colspan=2>Two Group Fields: dept_no and sex</th></tr>
<tr>
<th>dept_no row indices</th><th>dept_no and female</th><th>dept_no and male</th></tr>
<tr>
<td>A00</td><td>0, 7</td><td>0</td><td>7</td></tr>
<tr>
<td>B01</td><td>1</td><td>&nbsp;</td><td>1</td></tr>
<tr>
<td>C01</td><td>2, 8, 9</td><td>2, 8, 9</td><td>&nbsp;</td></tr>
<tr>
<td>E01</td><td>3</td><td>&nbsp;</td><td>3</td></tr>
<tr>
<td>D11</td><td>4, 10, 11, 12</td><td>&nbsp;</td><td>4, 10, 11, 12</td></tr>
<tr>
<td>D21</td><td>5, 13, 14</td><td>5</td><td>13, 14</td></tr>
<tr>
<td>E11</td><td>6</td><td>6</td><td>&nbsp;</td></tr>
<tr>
<td>D31</td><td>15, 16, 17</td><td>17</td><td>15, 16</td></tr>
</table><P>
The function <font face=Kapl>t.group</font> is used to establish views based on group fields.  In the example of <font face=Kapl>dept_no</font> as a group field for the <font face=Kapl>employees</font> table, a view could be formed as follows:
<pre><font face=Kapl>     `employees `bd_view t.group `dept_no</font></pre>
As with <font face=Kapl>t.also</font>, the effect of <font face=Kapl>t.group</font> is to create the view called <font face=Kapl>bd_view</font>, but the view must still be populated using <font face=Kapl>t.send</font>.  If the <font face=Kapl>salary</font> column is sent from the <font face=Kapl>employees</font> table to <font face=Kapl>bd_view</font>, it is not unreasonable to expect that the items of the target column would be salaries grouped by department.  Typically, however, it is not these groups that one wants, but the result of some function applied to the groups.  For instance, one might want the largest value in each group, the smallest, or the average.  <A NAME=15>A function applied to the groups is called a <i>group function</i>, or <i>summarization function</i>.  For instance, to get the largest salary in each group, the group function would be specified as follows:
<pre><font face=Kapl>     `employees `bd_view t.send (`salary;Ó/)</font></pre>
Different columns can be sent with different group functions.  For instance, if the <font face=Kapl>emp_no</font> field is sent to <font face=Kapl>bd_view</font> and its items are grouped by departments, then its group function might simply collect all the employee numbers in each group.  This group function would be specified as follows:
<pre><font face=Kapl>     `employees `bd_view t.send (`emp_no;&lt;)</font></pre>
For more on group functions, see "<A HREF="#40">How Group Functions are Specified and How t Applies Them</A>".
</blockquote>
<A NAME=HEADING873>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;How t<A NAME=16> Manages Group Fields</FONT></H2>
<blockquote>
Exactly how are group fields maintained?  Executing <font face=Kapl>t.group</font> establishes a mapping from the row indices of the source table to the row indices of the target table, which in this example is from the <font face=Kapl>employees</font> table to the <font face=Kapl>bd_view</font> table, and is:
<pre><font face=Kapl>     (&lt;@1 (D employees.dept_no) OE employees.dept_no
      )/¡&lt;É#employees.dept_no
&lt;  0 7
&lt;  1
&lt;  2 8 9
&lt;  3
&lt;  4 10 11 12
&lt;  5 13 14
&lt;  6
&lt;  15 16 17</font></pre>
The function <font face=Kapl>D{x}:((xÉx)=É#x)/x</font> is the usual one that produces the distinct items of the <font face=Kapl>dept_no</font> column.  The function <font face=Kapl>OE{x;y}:x½@1&nbsp;1&nbsp;0&nbsp;y</font> generalizes the outer product<font face=Kapl> aÊ.=b </font>to apply to items of matrices instead of items of vectors.  The result of the above expression is a vector of enclosed index vectors that reflects the grouping defined by the group field; compare this result with the <A HREF="#14">table</A>.<P>
For example, when the <font face=Kapl>salary</font> column is sent to the <font face=Kapl>bd_view</font> table, the fifth element of the mapped column, <font face=Kapl>bd_view.salary[4]</font>, is computed from elements 4, 10, 11, and 12 of the source column, and is <font face=Kapl>Ó/employees.salary[4&nbsp;10&nbsp;11&nbsp;12]</font>, or 36250.  The group function <font face=Kapl>Ó/</font> was specified when the <font face=Kapl>salary</font> column was sent to departments.  Different functions can be specified for different columns.<P>
This mapping is maintained by t in the table dependency <font face=Kapl>bd_view._J</font>.  When the <font face=Kapl>salary</font> column is sent from <font face=Kapl>employees</font> to <font face=Kapl>bd_view</font> with the group function <font face=Kapl>Ó/</font>, the new column is a dependency on the source column whose definition is essentially:
<pre><font face=Kapl>     bd_view.salary:&gt;Ó/¡bd_view._J#¡&lt;employees.salary</font></pre>
(but see the use of <font face=Kapl>_index</font> in the definition of <font face=Kapl>col</font> in "<A HREF="#10">How t Manages Row and Column Selection</A>").<P>
There are two parts to this dependency:<P>
<OL>
<LI><font face=Kapl>bd_view._J</font> is a partition of the row indices of the employees table with one element for each row in the <font face=Kapl>bd_view</font> table.  When a column is sent from employees to departments, say salary, that column is first partitioned according to this variable, essentially as:
<BR><font face=Kapl>partition_of_salaryûbd_view._J#¡&lt;employees.salary</font><P>
<LI>The partitioned column is a vector of subcolumns, with no item of the column appearing in more than one subcolumn.  The group function is applied to each of these subcolumns to produce the target column in the <font face=Kapl>departments</font> table:
<BR><font face=Kapl>Ó/¡partition_of_salary</font>
</OL>
</blockquote>
<A NAME=HEADING874>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Grouping <A NAME=18>by Intervals</FONT></H2>
<blockquote>
So far in this chapter, items in group fields have been grouped by equality.  An important variation of this practice, particularly for numeric group fields, is to group items according to intervals of minimum and maximum values, i.e., to group them in ranges.  For example, in the <font face=Kapl>employees</font> table in the base table <A href="#GIF199">figure</A>, it is generally more useful to group employees by salary ranges than by identical salaries.  For instance, the question as to how many salaries fall within each $5000 increment can be answered as follows.  First, make a view of the <font face=Kapl>employees</font> table with a few representative fields including <font face=Kapl>salary</font>, and in that view form two new columns representing the lower limit and upper limit of the salary interval for each salary.  These new columns will calibrate the group field.
<pre><font face=Kapl>   `employees `e_view t.only ()
   `employees `e_view t.send `emp_no `emp_name `salary
   `e_view t.define (`min_range;
                     'â1+5000«Äemployees.salaryß5000')
   `e_view t.define (`max_range;
                     'â5000«Óemployees.salaryß5000')</font></pre>
Now form a second view based on salary as a group field with intervals of $5000:
<pre><font face=Kapl>   `e_view `i_view t.group (`salary;5000«É12)</font></pre>
Finally, send salary to the second view with the A+ primitive <font face=Kapl>#</font> as its group function, and send both <font face=Kapl>min_range</font> and <font face=Kapl>max_range</font> with the default group function ("first item"):
<pre><font face=Kapl>   `e_view `i_view t.send (`min_range;;
                           `max_range;;
                           `salary_count;(`salary;#))</font></pre>
Both views are shown in the grouping <A href="#GIF203">figure</A>.  The reason for creating the <font face=Kapl>min_range</font> and <font face=Kapl>max_range</font> columns in the <font face=Kapl>e_view</font> table and sending them to <font face=Kapl>i_view</font> should now be apparent: in <font face=Kapl>i_view</font>, they serve to calibrate the <font face=Kapl>salary_count</font> table.  In a real application, they would most likely not appear in <font face=Kapl>e_view</font>.<P>
Furthermore, in a real application the last row of the i_view table, which is due to the missing salary for Smith, would be filtered out.
</blockquote>
<A NAME=GIF203><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Grouping By Intervals On the Salary Column Of e-view:</b>
<blockquote>
<IMG SRC="APlusRefV2_AFrame_203.gif"><P>
</blockquote>
<A NAME=HEADING875>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Static <A NAME=19>Grouping</FONT></H2>
<blockquote>
There are useful variations of the group fields called direct and indirect static group fields, which have these characteristics:<P>
<UL>
<LI>The map from the source table to the target table can be computed once and stored.  This is useful for large, relatively fixed files for which these computations are expensive.<P>
<LI>The map is represented as a triple of simple integers instead of a nested vector of integer vectors, which is better for large files and easy to save in mapped files for later use.
</UL>
To illustrate the indirect static link, suppose that the group view above had been formed with <font face=Kapl>t.group_i</font> instead of <font face=Kapl>t.group</font>:
<pre><font face=Kapl>     `employees `bd_view t.group_i `dept_no</font></pre>
Let <font face=Kapl>x</font> be the mapping <font face=Kapl>bd_view._J</font> defined above for the <font face=Kapl>t.group</font> case.  Then the mapping <font face=Kapl>bd_view._J</font> in the <font face=Kapl>t.group_i </font>case is simply a vector of counts of the items of the <font face=Kapl>x</font>, namely <font face=Kapl>Ø#¡x</font>:
<pre><font face=Kapl>     bd_view._J
 2 1 3 0 1 4 3 3 1 0</font></pre>
In addition, <font face=Kapl>t.group_i</font> generates a permutation vector named <font face=Kapl>employees._H_bd_view</font> that sorts the group field <font face=Kapl>dept_no</font> into nondecreasing order, and also a vector named <font face=Kapl>bd_view._K</font> of first occurrences of the unique elements of the group field in the sorted group field:
<pre><font face=Kapl>     employees._H_bd_view
 0 7 1 2 8 9 4 10 11 12 5 13 14 15 16 17 3 6
     bd_view._K
 0 2 3 18 16 6 10 13 17 18</font></pre>
Then for any n, the n-th item of the mapping <font face=Kapl>x</font> defined above can be obtained from these three vectors:
<pre><font face=Kapl>     employees._H_bd_view[bd_view._K[n]+Ébd_view._J[n]</font></pre>
Consequently, the group mappings for <font face=Kapl>t.group</font> and <font face=Kapl>t.group_i</font> are functionally equivalent.<P>
Once these variables have been created, they can be saved in mapped files, and in such a way that they will be retrieved automatically by t when needed.  Suppose all the columns of the employees table are kept in a directory named <font face=Kapl>source</font>, and nothing else is kept there.  Save <font face=Kapl>employees._H_bd_view</font> in that same directory, and with the file name the same as the variable name:
<pre><font face=Kapl>     'source/_H_bd_view.m'àemployees._H_bd_view</font></pre>
The target table is a view and therefore its columns did not come directly from mapped files.  So, choose a directory that will only hold the saved variables <font face=Kapl>bd_view._J</font> and <font face=Kapl>bd_view._K</font>, say <font face=Kapl>target</font>:
<pre><font face=Kapl>     'target/_J.m'àbd_view._J
     'target/_K.m'àbd_view._K</font></pre>
In a later session, the two tables are opened as follows:
<pre><font face=Kapl>     (`employees;'source') t.open ()
     (`bd_view;'target') t.open ()</font></pre>
 - yes, even the view is explicitly opened, in order to retrieve the saved table variables - and <font face=Kapl>bd_view</font> is made a view of employees:
<pre><font face=Kapl>     `employees `bd_view t.only ()</font></pre>
Send the grouping fields:
<pre><font face=Kapl>     `employees `bd_view t.send (`dept_no;)</font></pre>
The state is now the same as that after the original evaluation of <font face=Kapl>t.group_i</font>.  For example, send the <font face=Kapl>salary</font> field to the view, as in the <font face=Kapl>t.group</font> example (note that this can be combined with sending the grouping fields):
<pre>     <font face=Kapl>`employees `bd_view t.send (`salary;Ó/)</font></pre>
In addition to the indirect static group, there is a direct static group denoted by <font face=Kapl>t.group_d</font>.  The difference is that the permutation is not computed, i.e., in the above example, <font face=Kapl>employees._H_bd_view</font>.  It is still needed, however, and must be supplied by the user, similarly to <font face=Kapl>t.break_b</font>.  For example, after the following is executed:
<pre><font face=Kapl>     `employees `bd_view t.break_d `dept_no</font></pre>
the permutation vector must be defined before any fields are sent to the view.
</blockquote>
<A NAME=HEADING876>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Successive <A NAME=20>Multiple Group Fields</FONT></H2>
<blockquote>
The <A HREF="#14">partitioning table</A> illustrates grouping on multiple fields,
 in particular:
<pre><font face=Kapl>     `employees `view t.group `dept_no `sex</font></pre>
As that table indicates, rows of <font face=Kapl>employees</font> are grouped together based on equal rows of the column pair <font face=Kapl>dept_no</font> and <font face=Kapl>sex</font>.  An interesting variant of grouping on multiple fields is provided by <font face=Kapl>t.report</font>.  If the following is executed:
<pre><font face=Kapl>     `employees `view t.report `dept_no `sex</font></pre>
the result is as if an intermediate table were formed that grouped the <font face=Kapl>employees</font> table according to the first column named in the right argument, namely <font face=Kapl>dept_no</font>, and then view were formed from that intermediate table by further classifying the members of each department by <font face=Kapl>sex</font>, i.e. the second column named in the right argument. In fact, that intermediate table is actually formed.  If more columns had been named in the right argument then this successive refinement method would have continued for every named column, in the order of the names in the list, and an intermediate table for every step except the last would be created.<P>
A special first column named <font face=Kapl>view._</font> is automatically generated, providing row labels for the successive refinements.  If the screen management system called s is present, then the following provides a display of a representative examples of <font face=Kapl>t.report</font>:
<pre><font face=Kapl>     `employees `view t.send (`salary;Ó/)
     show t.table `view</font></pre>
</blockquote>
<A NAME=HEADING877>
<H2><FONT color="#20B2AA">Linking <A NAME=23>Tables</FONT></H2>
<blockquote>
Linking is the basic operation for relating the contents of two tables.  In the simplest cases the two tables must have a common field, called the <i>link field</i>; more general cases with several link fields will come up later.  That is, there is a column in one table with the same name as a column in the other, and these two columns are in the same domain (see "<A HREF="#6">Table Row and Column Domains</A>").  In most practical cases, the two columns have some matching items but are not identical.  Linking is not a symmetric operation.  One table is selected as the <i>partition side</i> of the link, largely because its link field has distinct items, and the other then becomes the <i>replication side</i>.  The link field on the partition side is also called the <i>index field</i>, and the one on the replication side the <i>grouping field</i>, or <i>group field</i>.<P>
A link is a relationship between two tables, based on identical items in their common link field.  The relationship is expressed in terms of a correspondence between the row indices of the partition side and the row indices of the link side.  The correspondence is illustrated in the <A HREF="#24">next table</A> for the two tables in the base table <A href="#GIF199">figure</A> and the common field <font face=Kapl>dept_no</font>.  For example, department number C01 appears in row 2 of the <font face=Kapl>departments</font> table and rows 2, 8, and 9 of the <font face=Kapl>employees</font> table.  The asymmetry of the link is a reflection of the asymmetry of this correspondence, which is one to many in one direction (and many to one in the other).<P>
Once a link is established, columns can be sent, or mapped, from either side of the link to the other based on the correspondence between the row indices of the two tables.  For example, suppose the <font face=Kapl>dept_name</font> column is mapped from the <font face=Kapl>departments</font> table to the <font face=Kapl>employees</font> table to form a new <font face=Kapl>dept_name</font> column.  Then item 2 of the <font face=Kapl>dept_name</font> column in <font face=Kapl>departments</font>, "Information Center", will appear in rows 2, 8, and 9 of the new <font face=Kapl>dept_name</font> column.  Or, if the <font face=Kapl>salary</font> column in the <font face=Kapl>employees</font> table is mapped to the <font face=Kapl>departments</font> table to form a new <font face=Kapl>salary</font> column there, then the salaries of the employees Pulaski, Jefferson, and Marino (i.e., rows 5, 13, and 14 of the <font face=Kapl>employees</font> table) will all appear in row 6 of the new <font face=Kapl>salary</font> column.<P>
Note that the mapping from the replication side of the link to the partition side is essentially the same as the one from a source table to a view created by <font face=Kapl>t.group</font>, up to a permutation of target table.<P>
<A NAME=HEADING878>
<table border=1 cellspacing=0 cellpadding=8>
<caption><FONT color="#20B2AA" size=+2><B>
Row <A NAME=24>Index Correspondence of departments and employees based on dept_no</B></FONT>
</caption>
<tr>
<th>Row Index<br >in departments</th><th>dept_no items</th>
<th>Row Index<br >in employees</th></tr>
<tr>
<td align=center>0</td><td>A00</td><td>0, 7</td></tr>
<tr>
<td align=center>1</td><td>B01</td><td>1</td></tr>
<tr>
<td align=center>2</td><td>C01</td><td>2, 8, 9</td></tr>
<tr>
<td align=center>3</td><td>D01</td><td>&nbsp;</td></tr>
<tr>
<td align=center>5</td><td>D11</td><td>4, 10, 11, 12</td></tr>
<tr>
<td align=center>6</td><td>D21</td><td>5, 13, 14</td></tr>
<tr>
<td align=center>7</td><td>D31</td><td>15, 16, 17</td></tr>
<tr>
<td align=center>4</td><td>E01</td><td>3</td></tr>
<tr>
<td align=center>8</td><td>E11</td><td>6</td></tr>
<tr>
<td align=center>9</td><td>E21</td><td>&nbsp;</td></tr>
</table><P>
<b>Example</b><P>
The most common situation in linking two tables occurs when the items of one of the link fields are distinct, while those of the other may or may not be distinct.  In this case the table whose link field is known to have distinct items should be selected as the partition side of the link, and the other becomes the replication side.  As an example, consider once again the two tables in the base table <A href="#GIF199">figure</A>.<P>
These tables have a common field called <font face=Kapl>dept_no</font>.  If they are linked on that field
 (as in the <A HREF="#24">table above</A>), tables corresponding to the results of the
 following queries (among many) can then be built:<P>
<UL>
<LI>Query 1: what are the department names for all employees?<P>
<LI>Query 2: what is the maximum salary in each department?
</UL>
Since department numbers uniquely identify departments, the <font face=Kapl>departments</font> table is chosen to be the partition side of the link.  The link is established as follows:
<pre><font face=Kapl>     `departments `employees t.link `dept_no</font></pre>
The left argument of <font face=Kapl>t.link</font> is always a two-element symbolic vector whose first element identifies the partition side of the link, and whose second element identifies the replication side.  The right argument is (a list of) the link field(s).  Once the link is established, any number of columns can be sent from one table to the other in order to answer a variety of queries.  To answer the first query, send the <font face=Kapl>dept_name</font> column from the <font face=Kapl>departments</font> table to the <font face=Kapl>employees</font> table, as follows:
<pre><font face=Kapl>     `departments `employees t.send `dept_name</font></pre>
The answer is then contained in the columns <font face=Kapl>emp_name</font> and <font face=Kapl>dept_name</font> of the augmented <font face=Kapl>employees</font> table.  These columns cannot be displayed separately because the column <font face=Kapl>emp_name</font> already appears in the display of <font face=Kapl>employees</font> (see the base table <A href="#GIF199">figure</A>) and the screen management system does not allow an object to appear on the screen more than once.  Therefore, for display purposes, create and populate a new table, <font face=Kapl>query1</font>, as follows:
<pre><font face=Kapl>     `employees `query1 t.only ()
     `employees `query1 t.send `emp_name `dept_name</font></pre>
See the query tables <A href="#GIF205">figure</A> for the display of this table. <P>
As for the second query, send the <font face=Kapl>salary</font> field in the <font face=Kapl>employees</font> table to the <font face=Kapl>departments</font> table, as follows:
<pre><font face=Kapl>     `employees `departments t.send (`salary;Ó/)</font></pre>
(the group function <font face=Kapl>Ó/</font> implements the "maximum salary" part of the query).  Create a query table as follows (see the query tables <A href="#GIF205">figure</A>):
<pre><font face=Kapl>     `departments `query2 t.only ()
     `departments `query2 t.send `dept_name `salary</font></pre>
</blockquote>
<A NAME=GIF205><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sample Query Tables Created Via
 <font face=Kapl>t.link</font>:</b><p>
<IMG SRC="APlusRefV2_AFrame_205.gif"><P>
<A NAME=HEADING879>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;How t <A NAME=25>Manages Table Links</FONT></H2>
<blockquote>
Exactly how are table links accomplished?  Executing <font face=Kapl>t.link</font> establishes two mappings between the two sides of the link, represented in the above <A HREF="#24">table</A> as correspondences between the row indices in column 1 and the row indices in column 3.  One is a mapping from the rows of the <font face=Kapl>departments</font> table to the rows of the <font face=Kapl>employees</font> table, and in general from the partition side to the replication side, which is:
<pre><font face=Kapl>     departments.dept_noÉemployees.dept_no
 0 1 2 4 5 6 8 0 2 2 5 5 5 6 6 7 7 7</font></pre>
E.g., where the <font face=Kapl>dept_name</font> column is sent to the <font face=Kapl>employees</font> table, item <font face=Kapl>employees.dept_name[6]</font> in the mapped column equals item <font face=Kapl>departments.dept_name[8]</font> in the source.<P>
This mapping is maintained by t in the table dependency <font face=Kapl>employees._I_departments</font>.  When the column <font face=Kapl>dept_name</font> is sent from <font face=Kapl>departments</font> to <font face=Kapl>employees</font>, the new column is a dependency on the source column whose definition is essentially:
<pre><font face=Kapl>employees.dept_no:{
          employees._I_departments#departments.dept_no}</font></pre>
(but see the use of <font face=Kapl>_index</font> in the definition of <font face=Kapl>col</font> in "<A HREF="#10">How t Manages Row and Column Selection</A>").<P>
A second mapping in the other direction is also established, i.e., from the replication side to the partition side, which is similar to the mapping associated with group fields (see "<A HREF="#16">How t Manages Group Fields</A>").  In this example the mapping is from the <font face=Kapl>employees</font> table to the <font face=Kapl>departments</font> table, and is:
<pre><font face=Kapl>     (&lt;@1 departments.dept_no OE employees.dept_no
      )/¡&lt;É#employees.dept_no
&lt;  0 7
&lt;  1
&lt;  2 8 9
&lt;
&lt;  3
&lt;  4 10 11 12
&lt;  5 13 14
&lt;  15 16 17
&lt;  6
&lt;</font></pre>
The function <font face=Kapl>OE</font> is defined in "<A HREF="#16">How t Manages Group Fields</A>".  Compare this result with the correspondence <A HREF="#24">table</A>, and the group field mapping in "<A HREF="#16">How t Manages Group Fields</A>".<P>
For example, when the <font face=Kapl>salary</font> column is sent to the <font face=Kapl>departments</font> table, the sixth element of the mapped column,<font face=Kapl> departments.salary[5]</font>, is computed from elements 4, 10, 11, and 12 of the source column, and is <font face=Kapl>Ó/employees.salary[4&nbsp;10&nbsp;11&nbsp;12]</font>, or 36250.  The group function <font face=Kapl>Ó/</font> was specified when the <font face=Kapl>salary</font> column was sent to <font face=Kapl>departments</font>.  Different functions can be specified for different columns.<P>
This mapping is maintained by t in the table dependency <font face=Kapl>departments._J_employees</font>.  When the column <font face=Kapl>salary</font> is sent from <font face=Kapl>employees</font> to <font face=Kapl>departments</font> with the group function <font face=Kapl>Ó/</font>, the new column is a dependency on the source column whose definition is essentially:
<pre><font face=Kapl>departments.salary:{
       &gt;Ó/¡departments._J_employees#¡&lt;employees.salary}</font></pre>
(but see the use of <font face=Kapl>_index</font> in the definition of <font face=Kapl>col</font> in "<A HREF="#10">How t Manages Row and Column Selection</A>").<P>
It is worth noting that the name of each map from one partner in a link to the other contains the name of the partner.  This suggests that a table can participate in more than one link, since there would be no name conflicts in the table dependencies by which the multiple links would be managed.  This is in fact true.  Moreover, a table participating in several links can serve as the partition side in some and the replication side in others.
</blockquote>
<A NAME=HEADING880>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Multiple <A NAME=26>Group Fields</FONT></H2>
<blockquote>
How can effective links be done if no column can be guaranteed to have distinct items?  The answer is that link fields are not restricted to a single column; any set of columns will do, as long as columns with these names appear in both tables, and the two sets of columns are in the same domain (see "<A HREF="#6">Table Row and Column Domains</A>").  The partition side of the link is then the table in which the rows have distinct sets of entries in the set of link fields.  The mapping from the partition side of the link to the replication side resembles the b context function <font face=Kapl>b.p</font> more than dyadic <font face=Kapl>É</font>, but is more general, and the mapping in the other direction is comparably general.  Several examples of linking on more than one column appear in the "<A HREF="#30">The Relational Set Operations: Union, Intersection, and Difference</A>".
</blockquote>
<A NAME=HEADING881>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Duplicate <A NAME=27>Items in a Link Field on the Partition Side</FONT></H2>
<blockquote>
Even if the items of a link field or the rows of link fields are not distinct on the partition side of a link, the link can still be made; how effective it will be depends on the application.  The effect of partition side duplicates can be seen from the mappings between the two sides of the link.  When there is one link field, the mapping from the partition side to the replication side is of the form:
<pre><font face=Kapl>     part.link_field É repl.link_field</font></pre>
If the <font face=Kapl>i</font>th and <font face=Kapl>j</font>th items of the column <font face=Kapl>partition.link_field</font> are identical and <font face=Kapl>i</font> is less than <font face=Kapl>j</font>, then <font face=Kapl>j</font> does not appear in this mapping, i.e., <font face=Kapl>j</font> is not in the result of the above expression.  Consequently the <font face=Kapl>j</font>th item of any column sent to the replication side of the link does not appear in that table.  As for the mapping in the other direction, which in its simplest form is
<pre><font face=Kapl>     (&lt;@1 part.link_field Ê.= repl.link_field
      )/¡&lt;É#repl.link_field ,</font></pre>
the <font face=Kapl>i</font>th and <font face=Kapl>j</font>th elements created by this mapping are identical, and so the <font face=Kapl>i</font>th and <font face=Kapl>j</font>th items of any column sent to the partition side are identical.
</blockquote>
<A NAME=HEADING882>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Static <A NAME=28>Links</FONT></H2>
<blockquote>
Analogous to <font face=Kapl>t.group</font>, there is an indirect static link function <font face=Kapl>t.link_i</font> and a direct static link function <font face=Kapl>t.link_d</font>.  They produce variations of the map from the replication side to the partition side which are the same as the variations produced by <font face=Kapl>t.group_i</font> and <font face=Kapl>t.group_d</font>.  In particular, <font face=Kapl>t.link_d</font> does not produce the required permutation vector on the replication side; this vector must be defined by the user before any columns are sent across the link.<P>
There is one difference between static links and static groups.  After the link is established and saved, and after the two linked tables are opened in a later A+ session, link pointers must be manually set.  For example, if the static link had been originally established as:
<pre><font face=Kapl>     `departments `employees t.link_i `dept_no</font></pre>
then the following establishes the link pointers in a later session:
<pre><font face=Kapl>     employees._L[,]û`departments
     departments.!R[,]û`employees</font></pre>
</blockquote>
<A NAME=HEADING883>
<H2><FONT color="#20B2AA">The <A NAME=30>Relational Set Operations: Union, Intersection, and Difference<A NAME=30></FONT></H2>
<blockquote>
The relational set operations provide examples of linking across multiple fields.
 They apply to pairs of tables with the same number of columns, where for every column index i, the i-th columns of the two tables are in the same domain (see "<A HREF="#6">Table Row and Column Domains</A>").  In other words, it is possible to link the two tables across the full set of columns.  To reiterate the point made earlier in the chapter, it is assumed that the tables have distinct rows (which is one of the criteria in the definition of relational tables).
</blockquote>
<A NAME=GIF210><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tables For the Relational Set Operation Examples:</b>
<blockquote>
<IMG SRC="APlusRefV2_AFrame_210.gif"><P>
Suppose that instead of the <font face=Kapl>employees</font> table, there are two other base tables, a <font face=Kapl>salary</font> table for all employees who receive a salary, and a <font face=Kapl>commission</font> table for all employees who receive a commission.  For the purpose of illustration, the <font face=Kapl>salary</font> table can be built from the <font face=Kapl>employees</font> table as follows:
<pre><font face=Kapl>   `employees `salary t.only 'salary¨`intØt.NA'
   `employees `salary t.send ()</font></pre>
(Note that there is now a <font face=Kapl>salary</font> table and a <font face=Kapl>salary</font> column.)  There is one employee who receives no salary.  The missing salary information for that employee is represented in the <font face=Kapl>salary</font> column by an NA value.  That value was chosen to be the default numeric NA value, <font face=Kapl>`intØt.NA</font>, when the mapped files for the base tables were built.  Consequently the selection expression in the right argument of <font face=Kapl>t.only</font> above selects all employees who receive a salary.  The resulting <font face=Kapl>salary</font> table will the same as the <font face=Kapl>employees</font> table, except that the row with emp_no equal to 300 is missing (see the base tables <A href="#GIF199">figure</A>, and the operations <A href="#GIF210">figure</A>).  The <font face=Kapl>commission</font> table is formed in the same way, and contains the last three rows of the <font face=Kapl>employees</font> table.
<pre><font face=Kapl>   `employees `commission t.only 'commission¨`intØt.NA'
   `employees `commission t.send ()</font></pre>
See the operations <A href="#GIF210">figure</A>.<p>
Link these tables on the full set of columns; since the rows of either table are distinct, either table can be used on the partition side of the link:
<pre><font face=Kapl>   `salary `commission t.link salary._T</font></pre>
</blockquote>
<A NAME=HEADING884>
<H3><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;<A NAME=31>Intersection</FONT></H3>
<blockquote>
If a row of the commission table occurs in the salary table, then the corresponding element of the mapping
<pre><font face=Kapl>     commission._I_salary</font></pre>
must be a valid row index of the <font face=Kapl>salary</font> table, and therefore not equal to the t-created variable <font face=Kapl>salary._N</font>, whose value is the number of rows in <font face=Kapl>salary</font>.  By definition, the set of rows of the <font face=Kapl>commission</font> table that also appear in the <font face=Kapl>salary</font> table is the intersection of the two tables, and therefore the intersection table can be defined as:
<pre><font face=Kapl>     t.only{`commission `intersection;
            'commission._I_salary¨salary._N'}
     `commission `intersection t.send ()</font></pre>
</blockquote>
<A NAME=GIF207><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Examples of The Set Operations:</b>
<blockquote>
<IMG SRC="APlusRefV2_AFrame_207.gif"><P>
</blockquote>
<A NAME=HEADING885>
<H3><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Set <A NAME=33>Difference</FONT></H3>
<blockquote>
The set difference "<font face=Kapl>commission</font> minus <font face=Kapl>salary</font>" is the set of rows of the <font face=Kapl>commission</font> table that are not in the <font face=Kapl>salary</font> table, i.e., the complement of the intersection relative to <font face=Kapl>commission</font>.  The difference can be formed simply by changing <font face=Kapl>¨</font> to <font face=Kapl>=</font> in the right argument of <font face=Kapl>t.only</font> above, or by using the same right argument in the complementary t function called <font face=Kapl>t.not</font>:
<pre><font face=Kapl>     t.not{`commission `comm_minus_sal;
           'commission._I_salary¨salary._N'}
     `commission `comm_minus_sal t.send ()</font></pre>
See the examples <A href="#GIF207">figure</A>.<p>
The other set difference, "<font face=Kapl>salary</font> minus <font face=Kapl>commission</font>", which is the set of rows of <font face=Kapl>salary</font> that are not in <font face=Kapl>commission</font>, can be obtained from the partition map <font face=Kapl>salary._J_commission</font>; it consists of all rows <font face=Kapl>j</font> of <font face=Kapl>salary</font> for which the <font face=Kapl>j</font>th partition is empty, i.e.,
<pre><font face=Kapl>     t.only{`salary `sal_minus_comm;
            '~&gt;#¡salary._J_commission'}
     `salary `sal_minus_comm t.send ()</font></pre>
See the examples <A href="#GIF207">figure</A>.
</blockquote>
<A NAME=HEADING886>
<H3><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;<A NAME=34>Union</FONT></H3>
<blockquote>
The union of the <font face=Kapl>salary</font> and <font face=Kapl>commission</font> tables is the catenation of <font face=Kapl>salary</font> and the set difference table <font face=Kapl>comm_minus_sal</font> formed above, rows on rows:
<pre><font face=Kapl>     `salary `comm_minus_sal `union t.cat ()
     `salary `comm_minus_sal `union t.send ()</font></pre>
See the examples <A href="#GIF207">figure</A>.  The resulting table, named <font face=Kapl>union</font>, is the same as <font face=Kapl>employees</font>, except that the row for <font face=Kapl>emp_no</font> equal to 300 is in a different position.  To make <font face=Kapl>union</font> the same as <font face=Kapl>employees</font>, sort it on the <font face=Kapl>emp_no</font> column:
<pre><font face=Kapl>     `union t.sort `emp_no</font></pre>
</blockquote>
<A NAME=HEADING887>
<H3><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Outer <A NAME=35>Union</FONT></H3>
<blockquote>
The set operations are too restrictive to be generally useful because they only apply to pairs of tables that can be linked on their entire set of columns, a situation that does not arise naturally in applications very often.  For example, the <font face=Kapl>salary</font> and <font face=Kapl>commission</font> tables in the previous example would most likely not occur in a real application; instead, the <font face=Kapl>salary</font> table would not have the <font face=Kapl>commission</font> column and the <font face=Kapl>commission</font> table would not have the <font face=Kapl>salary</font> column.  The outer union is the relational operation that produces the <font face=Kapl>employees</font> table from the more realistic salary and commission tables, which are defined below as <font face=Kapl>salary1</font> and <font face=Kapl>commission1</font>:
<pre><font face=Kapl>     `employees `salary1 t.only 'salary¨`intØt.NA'
     `employees `salary1 t.send (
        employees._T¨`commission)/employees._T
     `employees `commission1 t.only (
        'commission¨`intØt.NA')
     `employees `commission1 t.send (
        employees._T¨`salary)/employees._T</font></pre>
This example is reduced to the previous one - and in general outer union is reduced to union - by constructing the <font face=Kapl>salary</font> and <font face=Kapl>commission</font> tables from <font face=Kapl>salary1</font> and <font face=Kapl>commission1</font>.  To do that, link <font face=Kapl>salary1</font> and <font face=Kapl>commission1</font> on all columns except <font face=Kapl>salary</font> and <font face=Kapl>commission</font>:
<pre><font face=Kapl>     `salary1 `commission1 t.link (
        `salary1._T¨`salary)/salary1._T</font></pre>
and send each one the missing column from the other:
<pre><font face=Kapl>     `salary1 `commission1 t.send `salary
     `commission1 `salary1 t.send (`commission;)</font></pre>
The function to be applied to partitions when generating the <font face=Kapl>commission</font> column in <font face=Kapl>salary1</font> is "first element", as indicated by the right argument to <font face=Kapl>t.send</font> in the last expression (see "<A HREF="#40">How Group Functions are Specified and How t Applies Them</A>").  Since each partition happens to consist of a single element in this case (the collections of link fields in the two tables are identical), "first element" simply selects that element.  The resulting <font face=Kapl>salary1</font> and <font face=Kapl>commission1</font> tables are identical to <font face=Kapl>salary</font> and <font face=Kapl>commission</font>.
</blockquote>
<A NAME=HEADING888>
<H1><FONT color="#20B2AA">Definitions of t-Context Functions</FONT></H1>
<A NAME=HEADING889>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;<A NAME=37>Selectors</FONT></H2>
<blockquote>
In every example above of <font face=Kapl>t.only</font> and <font face=Kapl>t.also</font>, the right argument defining the selection, when not the Null, is a character vector containing a valid A+ expression.  One example in "<A HREF="#9">Row and Column Selection</A>", suggests the use of <font face=Kapl>t.in</font> to permit special syntax, namely a right argument of the form <font face=Kapl>"a,b,c"</font> in place of the typical right argument to Member of (<font face=Kapl>Å</font>) of the form<font face=Kapl> 3&nbsp;1Ò"abc"</font>.&nbsp; It is possible to extend this technique with application-specific functions that play the same role as <font face=Kapl>t.in</font>.  It is also possible to permit more English like selections on specific columns by connecting application-supplied selection evaluation functions to the t selection functions.  These selection evaluation functions are called <i>selectors</i>.<P>
For example, it is possible to permit selections on date fields of the form <font face=Kapl>'1/1/93&nbsp;to&nbsp;10/1/93'</font> if there is an application-supplied selector function that can parse this expression and apply it to table columns.  A selector function must satisfy the following conditions:<P>
<UL>
<LI>the syntax of a selector function is the same as callback functions, namely:<BR><font face=Kapl>selector{s;d;i;p;c;v}<BR></font>(the index argument <font face=Kapl>i</font> holds the selection criteria, such as <font face=Kapl>'1/1/93&nbsp;to&nbsp;10/1/93'</font>, the context argument <font face=Kapl>c</font> holds the table name, the variable argument <font face=Kapl>v</font> holds the column name, and the data argument <font face=Kapl>d</font> holds the value of the column variable);<P>
<LI>the result of a selector function is a boolean vector of the same length as the table column named by the arguments <font face=Kapl>c</font> and <font face=Kapl>v</font>, with 1 indicating that the corresponding item of the column is selected.<A NAME=APlusRefV2_FootNote_963 HREF=APlusRefV2_FootNote_963.html><b><SUP>1</SUP></b></A>
</UL>
For instance, if date ranges are given as <font face=Kapl>'1/1/93&nbsp;to&nbsp;10/1/93'</font>, the selector function might be:
<pre><font face=Kapl>     date_selection{s;d;i;p;c;v}:{
          iû' ',i;
          bû' '=i;
          (f;t)ûâ¡0 2#(Úb)Úi;
          (d¦f)^(f¤t)
     }</font></pre>
A selector function can be connected to the column of a table in one of two ways.  It may be specified when a table is opened with <font face=Kapl>t.open</font>, or the t.selector attribute is specified for the column with the selector function as its value, as in:
<pre><font face=Kapl>     `prices.date_col _set (`t.selector;date_selection)</font></pre>
where <font face=Kapl>prices</font> is the table containing <font face=Kapl>date_col</font>.  Once connected, whenever a selection of the following form is made on the <font face=Kapl>date_col</font> column of the table named <font face=Kapl>prices</font>:
<pre><font face=Kapl>     (`date_col;'1/1/93 to 10/1/93')</font></pre>
the selector function is called.  This type of selection can be made with any of the t selection functions, <font face=Kapl>t.only</font>, <font face=Kapl>t.also</font>, and <font face=Kapl>t.not</font>.<P>
A selector can also be specified by a pair <font face=Kapl>(fcn;static_data)</font>, as in
<pre><font face=Kapl>     `prices.date_col _set (`t.selector;
                           (date_selection;date_style))</font></pre>
where the data has the same significance as in the right argument of <font face=Kapl>_scb</font>.<P>
Several column selections can be made at once, as in:
<pre><font face=Kapl>     (`date_col;'1/1/93 to 10/1/93';
      `time_col;'9:00 A.M. to 4:30 P.M.')</font></pre>
Each of the two selector functions will create a boolean vector.  The two vectors can be combined into a single selection result in one of two ways, either by ORing or ANDing them together (although in this particular example only AND seems to make sense).  The function to be used, <font face=Kapl>©</font> or <font face=Kapl>^</font>, is the contents of the t-variable <font face=Kapl>t.CONNECT</font>.<P>
A column in a target table that is the image of one in a source table will use the selector of its source column if one of its own has not been specified.<P>
Selectors are specified in the right arguments of <font face=Kapl>t.open</font> and <font face=Kapl>t.define</font>.
</blockquote>
<A NAME=HEADING890>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Dependency <A NAME=39>Frames</FONT></H2>
<blockquote>
A dependency frame is a character vector whose contents are an A+ expression preceded by a colon.<P>
When a column is sent from one table to another, by default the target column is defined to be a dependency on the source column, basically of the following form, where <font face=Kapl>f</font> is defined by t:
<pre><font face=Kapl>     target.col:f{source.col}</font></pre>
A dependency frame is the means of modifying this definition (see <font face=Kapl>t.send</font>).  In this example, wherever the column name <font face=Kapl>col</font> appears in the dependency frame, it is replaced by <font face=Kapl>f{source.col}</font>, and the resulting expression becomes the definition of the dependency <font face=Kapl>target.col</font>.  For example, if the dependency frame is <font face=Kapl>":÷col"</font>, the target column dependency will be:
<pre><font face=Kapl>     target.col:÷f{source.col}</font></pre>
Dependencies are specified in the right argument of <font face=Kapl>t.send</font>.
</blockquote>
<A NAME=HEADING891>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;How <A NAME=40>Group Functions are Specified
 and How t Applies Them</FONT></H2>
<blockquote>
There are four ways that t applies group functions to a partitioned column, and the method
 chosen in most cases depends on how the group function is denoted in the right argument to
 <font face=Kapl>t.send</font>. There are various ways to attach a group function to a
 column, the simplest being as a column-function pair such as
 <font face=Kapl>(salary;f)</font>; see the definition of
 <A HREF="#113"><font face=Kapl>t.send</font></A> for the others. No matter how the
 attachment is done, the ways in which group functions themselves are denoted are always
 the same.<P>
Using the partitioned column <font face=Kapl>partition_of_salary</font> defined in
 "<A HREF="#16">How t Manages Group Fields</A>", the ways t applies group functions are:<P>
<OL>
<LI>if the group function is specified by <font face=Kapl>&lt;</font>, it is, in effect,
 not applied. The new salary column in the bd_view table is:<BR>
<font face=Kapl>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partition_of_salary</font><P>
<LI>if the group function is specified by the Null then it is taken to be the first item
 function<BR>
<font face=Kapl>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fe{v}:if&nbsp;(0=#v)&nbsp;_N&nbsp;else&nbsp;0#v</font><BR>
which is formally applied in the standard way (see 3) below):<BR>
<font face=Kapl>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;fe¡partition_of_salary</font><BR>
However, t maintains the t-created variable<font face=Kapl> bd_view._K </font>that is
 defined to be the vector of first items of the partition subcolumns:<BR>
<font face=Kapl>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bd_view._Kû&gt;fe¡ bd_view._J</font><BR>
and consequently the new salary column in the departments table is:<BR>
<font face=Kapl>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bd_view._K#employees.salary</font><P>
<LI>if the group function is specified by any valid function expression
 <font face=Kapl>f</font>, e.g. <font face=Kapl>+</font> or <font face=Kapl>+/</font>, it is
 applied as follows:<BR>
<font face=Kapl>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;f¡partition_of_salary</font><P>
<LI>if the group function is specified as a character vector containing any valid function
 expression, as in <font face=Kapl>"f"</font>, it is applied as follows:<BR>
<font face=Kapl>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f¡partition_of_salary</font>
</OL>
Similar definitions apply to group functions for linked tables.
</blockquote>
<A NAME=HEADING892>
<H2><FONT color="#20B2AA">Business<A NAME=44> Days  <font face=Kapl>t.calendar{s}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>s</font> is a character vector, and the result is an integer vector.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The argument <font face=Kapl>s</font> specifies the beginning date, ending date of a time series in the form:
<pre><font face=Kapl>     'begin-date ý end-date'</font></pre>
where both beginning date and ending date are of the form mm/dd/yyyy.  The result is an integer vector of all business days between beginning date and ending date.  Each integer in the result is of the form <BR>
<font face=Kapl>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;100&nbsp;100&nbsp;Âyear,month,day<BR>
</font>where <font face=Kapl>year</font> is a four-digit integer, as in 1993, and
 <font face=Kapl>month</font> and <font face=Kapl>day</font> are at most two-digit
 integers.<P>
Note that the script<font face=Courier> dio.+ </font>must be loaded before this function is
 used.<P>
</BLOCKQUOTE><A NAME=HEADING893>
<H2><FONT color="#20B2AA">Calendar Indices  <A NAME=47><font face=Kapl>t.series{w;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>w</font> is a symbol scalar holding the name of a global variable, the right argument <font face=Kapl>x</font> is a character vector, and the result is an integer vector.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
It is assumed that the variable named in the left argument has had its <font face=Kapl>`t.calendar</font> attribute set, either indirectly with <font face=Kapl>t.open</font> or directly with <font face=Kapl>_set</font>.  If so, this function produces indices into the value of that attribute, as follows (where <font face=Kapl>calendar</font> is <font face=Kapl>w _get `t.calendar</font>):
<pre></font><font face=Kapl>     w t.series 'begin_date ý end_date'
          ã </font>for<font face=Kapl> begin_date </font>to<font face=Kapl> end_date

     w t.series '           ý end_date'
          ã </font>for 0 to<font face=Kapl> end_date

     w t.series 'begin_date ý         '
          ã </font>for<font face=Kapl> begin_date </font>to<font face=Kapl> (#calendar)-1

     w t.series '           ý         '
          ã </font>for<font face=Kapl> É#calendar</font></pre>
The extra spaces in the right arguments are only for readability.  Both <font face=Kapl>begin_date</font> and <font face=Kapl>end_date</font> are in the same format as the right argument to <font face=Kapl>t.calendar</font>, basically dd/mm/yyyy.<P>
</BLOCKQUOTE><A NAME=HEADING894>
<H2><FONT color="#20B2AA">Catenation  <A NAME=50><font face=Kapl>t.cat{w;}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>w</font> is a symbol vector which must have at least three elements to be meaningful.  The result equals <font face=Kapl>w</font>.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
Suppose that <font face=Kapl>w</font>
 is<font face=Kapl> `s0&nbsp;`s1&nbsp;...&nbsp;`sn&nbsp;`v</font>.&nbsp; The effect of this
 function is to initialize the view <font face=Kapl>`v</font> as the catenation of the tables
 <font face=Kapl>`s0</font> through <font face=Kapl>`sn</font>. Every element
 <font face=Kapl>`si</font> is the name of an existing table, either a base table or a view.
 The names of the columns in any <font face=Kapl>`si</font> must be the same as in any other
 <font face=Kapl>`sj</font>.  In addition, any pair of columns from
 <font face=Kapl>`si</font> and <font face=Kapl>`sj</font> with the same name must be in the
 same domain (see "<A HREF="#6">Table Row and Column Domains</A>").<P>
When <font face=Kapl>t.send</font> is subsequently executed to populate the view
 <font face=Kapl>`v</font> with columns, its left argument need not equal
 <font face=Kapl>w</font>, even though <font face=Kapl>w</font> as the right argument of
 <font face=Kapl>t.send</font> is by far the most useful case. Only columns of those tables
 specified in the left argument to <font face=Kapl>t.send</font> will appear in
 <font face=Kapl>`v</font>, and in the same order (top to bottom) as table names appear in
 that left argument (left to right).</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
See the set union example in "<A HREF="#30">The Relational Set Operations: Union, Intersection, and Difference</A>".<P>
</BLOCKQUOTE><A NAME=HEADING895>
<H2><FONT color="#20B2AA">Close <A NAME=54>Columns of a Table  <font face=Kapl>t.close{w;f}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>w</font> is a symbol scalar, while the right argument <font face=Kapl>f</font> and the result are symbol vectors.  The right argument <font face=Kapl>f</font> can also be the Null.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The left argument <font face=Kapl>w</font> is the name of a t-table.  If the right argument <font face=Kapl>f</font> is nonempty, then its elements are the names of columns of the t-table <font face=Kapl>w</font>.  In this case the following is done:<P>
<UL>
<LI>the columns named in <font face=Kapl>f</font> are removed from the table <font face=Kapl>w</font>, i.e., from <font face=Kapl>w%`_T</font>;<P>
<LI>if the table <font face=Kapl>w</font> is a view, the objects that define the columns named in <font face=Kapl>f</font> are removed from the table context, but not if <font face=Kapl>w</font> is a base table;<P>
<LI>the columns in any other t-tables that were sent from any columns of <font face=Kapl>w</font> named in <font face=Kapl>f</font> are removed from those tables, and the objects that define them are removed from those table contexts; in addition, those table contexts are removed for views that now have no columns;<P>
<LI>any links to other t-tables are removed in which a column named in <font face=Kapl>f</font> is a link field.
</UL>
If <font face=Kapl>f</font> is the Null then all columns of the table are treated in this manner.  In addition, all table variables are removed, and in the case of a view, the table context itself is removed.<P>
The result is a list of names of all t-tables whose table variables <font face=Kapl>_T</font> are modified by this evaluation.<P>
Note that if the right argument is the Null and the table is bound to a display class when closed, it is unbound.<P>
</BLOCKQUOTE><A NAME=HEADING896>
<H2><FONT color="#20B2AA">Complement  <A NAME=57><font face=Kapl>t.not{w;e}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>w</font> is either a two-element symbol vector, a one-element symbol vector, or a symbol scalar.  The right argument <font face=Kapl>e</font> is either a character or integral vector or scalar, or the Null.  The result is an integer scalar.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
This function is the complement of <font face=Kapl>t.only</font>; it behaves exactly like <font face=Kapl>t.only</font>, except that it selects those rows that would not be selected if <font face=Kapl>t.only</font> were executed with the same arguments.  If both the source and target are named in the left argument, then <i>complement</i> refers to the source table, while if only the target is named, <i>complement</i> refers to current view.  In particular, if the right argument is the Null and both the source and target are named in the left argument, the resulting view has no rows, while if only the target is named, the resulting view has all rows in the source that are not in the current view.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
See the example in "<A HREF="#33">Set Difference</A>", as well as the example under <font face=Kapl>t.only</font> for a numeric right argument.  Also:
<pre></font><font face=Kapl>     tab.aûÉ100
     `tab t.open `a
     `tab `view t.only 'a&lt;90'
 90
     `tab `view t.send `a
     `view t.only 'a&lt;40'
 40
     `view t.not 'a&lt;10'      ã </font>The complement in the view.<font face=Kapl>
 30
     `tab `view t.not 'a&lt;10' ã </font>The complement in the source.<font face=Kapl>
 90
     `view t.not ()   ã </font>The complement of the current view in the source.<font face=Kapl>
 10
     `tab `view t.not ()     ã </font>The empty view.<font face=Kapl>
 0</font></pre>
</BLOCKQUOTE><A NAME=HEADING897>
<H2><FONT color="#20B2AA">Create <A NAME=59>and Initialize a Base Table  <font face=Kapl>t.open{w;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>w</font> is either a symbol scalar, a character vector, a two-element nested vector consisting of a symbol scalar and a character vector in either order, or the Null.  The right argument <font face=Kapl>x</font> is a symbol vector, an association list, a nested association list, a slotfiller, or a nested slotfiller.  The result is a symbol scalar.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
This function creates and initializes t-tables.  The meaning of the left argument is:<P>
<OL>
<LI>A symbol scalar left argument is the name of the table to be opened.  Any mapped files designated to be opened by the right argument are assumed to be in the current directory  (./, i.e., the directory displayed when <font face=Kapl>$pwd</font> is executed in the A+ session).<P>
<LI>A character vector left argument is the name of the directory location of the mapped files in the table.  The empty character vector designates the current directory (see the first case).  The name of the table is taken to be that of the current context.<P>
<LI>The meanings of the symbol scalar and character vector in the two-element nested vector form of the left argument are the same as 1 and 2.<P>
<LI>The Null left argument means that the name of the table is taken to be that of the current context, and the directory is the root directory (./).
</OL>
The meaning of the right argument is:<P>
<UL>
<LI>A symbol in a symbol vector right argument is both the name of a column of the table being opened and the name of the object defining that column, according to the left argument, as follows:<P>
<UL>
<LI>If the left argument is a symbol, then the right argument consists of names of existing A+ objects.  An unqualified name is assumed to refer to an object in the context of the table being opened.<P>
<LI>For any other left argument, the right argument consists of names of files in the directory determined by the above left argument rules.
</UL><P>
<LI>A Null right argument means:<P>
<UL>
<LI>If the left argument is a symbol, then the table columns are of all global existing variables and dependencies in the context named by the left argument.<P>
<LI>Any other left argument specifies a directory.  If that directory contains a file named .T, that file is assumed to be a mapped file containing the result of applying <font face=Kapl>sys.exp</font> to a nested slotfiller or nested association list that is a valid right argument of <font face=Kapl>t.open</font>.  That right argument is then substituted for the Null in this call to <font face=Kapl>t.open</font>.  Otherwise, the table consists of all files in that directory, except files named after any of the table variables associated with static grouping and static links.
</UL><P>
<LI>An association list right argument has symbol, value pairs in which the symbol is the name of a column in the table and the value is a character vector with one of the following forms:<P>
<UL>
<LI><font face=Kapl>'nàfilename'</font><BR>
meaning that the column is a mapped file in the usual sense if <font face=Kapl>n</font> is 0, 1, or 2, or<P>
<UL>
<LI>if <font face=Kapl>n</font> is -1, the column is <font face=Kapl>sys.imp</font> applied to the mapped file;<P>
<LI>if <font face=Kapl>n</font> is -2, the column is <font face=Kapl>â</font> applied to the mapped file;<P>
<LI>if <font face=Kapl>n</font> is -3, the column is <font face=Kapl>Û</font> applied to the mapped file, i.e., the column is an unmapped copy of the mapped file.<P>
</UL>
<LI><font face=Kapl>'nàfilename0,filename1, ... ,filenamek'</font><BR>
meaning that the column is formed by using the rules described for
 <font face=Kapl>'nàfilename0'</font> in the previous case, then the expression
 <font face=Kapl>column[,]ûnàfilename1</font> is evaluated, using the same rules for
 <font face=Kapl>'nàfilename1'</font>, and so on, until all files through
 <font face=Kapl>filenamek</font> are appended to the column in this way.<P>
<LI><font face=Kapl>':expression'<BR></font>meaning that the column is a dependency defined
 by <font face=Kapl>expression</font>.<P>
<LI><font face=Kapl>'[i]:expression'<BR></font>meaning that the column is an itemwise
 dependency, with index <font face=Kapl>i</font>, defined by
 <font face=Kapl>expression</font>.<P>
<LI><font face=Kapl>'âexpression'<BR></font>meaning that the column is a variable whose
 value is the value of <font face=Kapl>expression</font>.
</UL><P>
<LI>The values of a slotfiller right argument have the same meanings as those of an
 association list.<P>
<LI>A nested association list right argument has symbol, value pairs in which the symbol is
 either the name of a column in the table or <font face=Kapl>`.</font>, in which case the
 value refers to the entire column, and the value is also an association list, whose symbol,
 value pairs are as follows:<P>
<UL>
<LI>if the symbol is <font face=Kapl>`.</font> then the value is a character vector
 specifying the value of the column, in one of the ways described in the previous case.<P>
<LI>if the symbol is <font face=Kapl>`t.calendar</font> then the value is a vector of dates for a time series field (see <A HREF="#44"><font face=Kapl>t.calendar</font></A>). When specified in <font face=Kapl>t.open</font>, it can also be a character vector of the form 'begin date<font face=Kapl> ý</font> end date', e.g. <font face=Kapl>'1/1/89 ý 12/31/89'</font>, from which the vector of dates will automatically be computed using <font face=Kapl>t.calendar.<P>
<LI>if the symbol is</font><font face=Kapl> `t.close</font> then the value is a character string holding an A+ expression that is executed after the column (or table) is closed.<P>
<LI>if the symbol is <font face=Kapl>`na</font> then the value is the NA value to be used for this column.<P>
<LI>if the symbol is <font face=Kapl>`t.open</font> then the value is a character string holding an A+ expression that is executed when the column (or table) is opened.<P>
<LI>if the symbol is <font face=Kapl>`t.selector</font> then the value is a selector for this column (see "<A HREF="#37">Selectors</A>").<P>
<LI>if the symbol is <font face=Kapl>`t.visible</font> and the value is 0 then this column is not included in _T_ when <font face=Kapl>t.table</font> is executed, while if the value is 1 it will be (even if it is not a valid screen table column).<P>
<LI>if the symbol is <font face=Kapl>`t.sent</font> then the value is a symbol holding the name of the table from which this column is to be sent.<P>
<LI>any attribute from the list <font face=Kapl>s.attributes `tableField</font>.<P>
<LI>any other symbol represents an application-defined attribute and the value associated with the symbol becomes the value of the attribute.
</UL><P>
<LI>The values of a nested slotfiller right argument have the same meanings as those of a nested association list.
</UL>
Note that once an attribute is given a value in <font face=Kapl>t.open</font>, that value can be retrieved with <font face=Kapl>_get</font>.  Attributes can also be given values directly with <font face=Kapl>_set</font>, as well as with <font face=Kapl>t.open</font>.<P>
The result of the function is the name of the opened table.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<OL>
<LI>From the root context, open the table <font face=Kapl>x</font> whose columns are the
 existing variables <font face=Kapl>x.y</font> and <font face=Kapl>x.z</font>:<BR>
<font face=Kapl>`x&nbsp;t.open&nbsp;`y&nbsp;`z</font><P>
<LI>From the <font face=Kapl>x</font> context, open the table <font face=Kapl>x</font> whose
 columns are all existing variables (in the <font face=Kapl>x</font> context):<BR>
<font face=Kapl>`x&nbsp;t.open&nbsp;()</font><P>
<LI>Open the table <font face=Kapl>x</font> whose column <font face=Kapl>y</font> is to be
 defined as <font face=Kapl>É100</font>:<BR>
<font face=Kapl>`x&nbsp;t.open&nbsp;(`y;'âÉ100')</font><BR>
Note that when a column with an unqualified name is defined, the variable is created in the
 context of the table (<font face=Kapl>x</font> in this case).<P>
<LI>Open the table <font face=Kapl>x</font> whose column <font face=Kapl>y</font> is to be
 defined as <font face=Kapl>É100</font> and column <font face=Kapl>z</font> is to be defined
 by the dependency definition <font face=Kapl>w.z*2</font>:<BR>
<font face=Kapl>`x&nbsp;t.open&nbsp;(`y;'âÉ100';`z;':w.z*2')</font><BR>
or<BR>
<font face=Kapl>`x&nbsp;t.open&nbsp;(`y`z;('âÉ100';':w.z*2'))</font><P>
<LI>Open the table <font face=Kapl>x</font> whose column <font face=Kapl>y</font> is to be
 defined as <font face=Kapl>É100</font> with the NA value -1234:<BR>
<font face=Kapl>`x&nbsp;t.open&nbsp;(`y;(`;'âÉ100';`na;¢1234)</font><BR>
or<BR>
<font face=Kapl>`x&nbsp;t.open&nbsp;(`y;(`&nbsp;`na;('âÉ100';¢1234)))</font><P>
<LI>Open the table <font face=Kapl>x</font> whose column <font face=Kapl>y</font> is to be
 defined as <font face=Kapl>É100</font> with the application-defined attribute fill whose
 value is <font face=Kapl>'*'</font>:<BR>
<font face=Kapl>`x t.open (`y;(`;'âÉ100';`fill;'*'))</font><BR>
or<BR>
<font face=Kapl>`x t.open (`y;(` `fill;('âÉ100';'*')))</font><P>
<LI>Open the table <font face=Kapl>x</font> whose column <font face=Kapl>z</font> is to be
 defined by the itemwise dependency definition <font face=Kapl>[i]:w.z[i]*2</font>:<BR>
<font face=Kapl>`x&nbsp;t.open&nbsp;(`z;'[i]:w.z[i]*2')</font><P>
<LI>Open the table <font face=Kapl>x</font> whose column <font face=Kapl>z</font> is to be
 defined as the mapped file <font face=Courier>/usr/local/lib/data.m</font>, opened for
 reading only:<BR>
<font face=Kapl>(`x;'/usr/local/lib/')&nbsp;t.open&nbsp;(`z;'0àdata')</font><P>
<LI>From the <font face=Kapl>x</font> context, open the table <font face=Kapl>x</font> whose
 column <font face=Kapl>z</font> is to be defined as the mapped file
 <font face=Courier>/usr/local/lib/data.m</font>, opened for updating:<BR>
<font face=Kapl>$cx&nbsp;x<BR>
()&nbsp;t.open&nbsp;(`z;'1à/usr/local/lib/data')</font><P>
<LI>The current directory is the one displayed when <font face=Kapl>$pwd</font> is executed
 in the A+ session. Assuming that the current directory is
 <font face=Courier>/usr/local/lib/</font> and the current context is
 <font face=Kapl>x</font>, open the table <font face=Kapl>x</font> whose column
 <font face=Kapl>z</font> is to be defined as the mapped file
 <font face=Courier>/usr/local/lib/data.m</font>, opened for local updating:<BR>
<font face=Kapl>''&nbsp;t.open&nbsp;(`z;'2àdata')</font><P>
<LI>Open the table <font face=Kapl>x</font> whose column <font face=Kapl>z</font> is to be
 defined as the <font face=Kapl>sys.imp</font> of the contents of the mapped file
 <font face=Courier>/usr/local/lib/data.m</font>:<BR>
<font face=Kapl>(`x;'/usr/local/lib/')&nbsp;t.open&nbsp;(`z;'¢1àdata')</font><P>
<LI>Open the table <font face=Kapl>x</font> whose column <font face=Kapl>z</font> is to be
 defined as the <font face=Kapl>â</font> of the contents of the mapped file
 <font face=Courier>/usr/local/lib/data.m</font>:<BR>
<font face=Kapl>(`x;'/usr/local/lib/')&nbsp;t.open&nbsp;(`z;'¢2àdata')</font><P>
<LI>Everything is the same as the previous example, except the column is also named
 <font face=Kapl>data</font>:<BR>
<font face=Kapl>(`x;'/usr/local/lib/')&nbsp;t.open&nbsp;(`data;¢2</font>)<P>
<LI>Open the table <font face=Kapl>x</font> whose column <font face=Kapl>z</font> is to be
 defined as the mapped file <font face=Courier>/usr/local/lib/data.m</font>, opened for
 reading only, to which is appended the mapped file
 <font face=Courier>/usr/local/lib/data2.m</font>:<BR>
<font face=Kapl>(`x;'/usr/local/lib/')&nbsp;t.open&nbsp;(`z;'0àdata,data2')</font>
</OL>
<font face=Kapl>t.load</font> is a synonym for <font face=Kapl>t.open</font>.<P>
</BLOCKQUOTE><A NAME=HEADING898>
<H2><FONT color="#20B2AA">Define a <A NAME=63>Column  <font face=Kapl>t.define{w;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>w</font> is either a symbol scalar, a character vector, a two-element nested vector consisting of a symbol scalar and a character vector in either order, or the Null.  The right argument <font face=Kapl>x</font> is a symbol vector, an association list, a nested association list, a slotfiller, or a nested slotfiller.  The result is a symbol scalar.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
This function is like <font face=Kapl>t.open</font> except that only one column can be created; if the table already exists, this column is appended to it, and otherwise the table is created with this column as its only column.  The left argument <font face=Kapl>w</font> is the same as <font face=Kapl>t.open</font>.  The right argument <font face=Kapl>x</font> is also the same as <font face=Kapl>t.open</font>, except that it specifies just one column.  The result is a symbol scalar holding the fully qualified name of the defined column.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
See "<A HREF="#18">Grouping by Intervals</A>".<P>
</BLOCKQUOTE><A NAME=HEADING899>
<H2><FONT color="#20B2AA">Detach a <A NAME=67>Column from its Sources  <font face=Kapl>t.detach{w;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>w</font> is a nonempty symbol vector.  The right argument <font face=Kapl>x</font> is any array.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The left argument <font face=Kapl>w</font> holds a list of table names.  The table named in the last element of <font face=Kapl>w</font> is where the execution of this function has effect, and is called the target table in this definition.  Any table named as one of the other elements of <font face=Kapl>w</font> is called a source table in this definition.  The target table was either created from the source table(s) by a selection function such as <font face=Kapl>t.only</font>, or is the partition side of a link to the source table.  If <font face=Kapl>z</font> is any column in the target table that is defined by t as a dependency on a column in one of the source tables, then the effect of this function is to make <font face=Kapl>z</font> an ordinary variable with its value equal to the current value of the dependency.<P>
The right argument is currently not used.  The result equals the left argument when source tables are specified, and otherwise is the same as the result would have been had all source tables been specified.<P>
This function is useful when the columns in source tables are large and no longer of direct interest once links and views have been formed.  These columns can be detached from their targets, leaving the current values of the targets intact, and then expunged.<P>
</BLOCKQUOTE><A NAME=HEADING900>
<H2><FONT color="#20B2AA">Direct <A NAME=71>Static Link  <font face=Kapl>t.link_d{w;f}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>w</font> is a two-element symbol vector and the right argument <font face=Kapl>f</font> is a symbol vector, a two-element nested vector whose items are symbol vectors of the same length, or the Null.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The definition is analogous to that of <font face=Kapl>t.link</font>, and the differences are discussed in "<A HREF="#19">Static Grouping</A>" and "<A HREF="#28">Static Links</A>".</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
See "<A HREF="#19">Static Grouping</A>" and "<A HREF="#28">Static Links</A>".<P>
</BLOCKQUOTE><A NAME=HEADING901>
<H2><FONT color="#20B2AA">Direct <A NAME=75>Static Summary  <font face=Kapl>t.group_d{w;f}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>w</font> is a two-element symbol vector, and the right argument is a symbol vector or scalar, or the Null.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The definition is analogous to that of <font face=Kapl>t.group</font>, and the differences are discussed in "<A HREF="#19">Static Grouping</A>".</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
See "<A HREF="#19">Static Grouping</A>".<P>
</BLOCKQUOTE><A NAME=HEADING902>
<H2><FONT color="#20B2AA">Disperse  <A NAME=78><font face=Kapl>t.disperse{w;s}</FONT></H2>
</font><b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>w</font> is a two-element symbol vector, and the right argument <font face=Kapl>s</font> is a symbol scalar or one-element symbol vector.  The result is a symbol scalar or symbol vector.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
This function is a utility function in t.  It is t-like in its function, but not directly related to t-tables.<P>
The first element of the left argument <font face=Kapl>w</font> is a source context, and the second element is a target context.  The right argument <font face=Kapl>s</font> holds the name of a slotfiller or nested slotfiller in the source context, i.e., the slotfiller is <font face=Kapl>w[0]%s</font>. <P>
In the case of a slotfiller, this function creates a dependency in the target context for every symbolic index <font face=Kapl>y</font>, whose name is the name held by <font face=Kapl>y</font>, and whose definition is <font face=Kapl>yØw[0]%s</font>.  An assignment callback is defined on this dependency so that whenever the dependency is assigned a value, the slotfiller element <font face=Kapl>yØw[0]%s</font> is also assigned this value.  In this way data organized in a slotfiller is dispersed to global variables, where it can serve as columns in t-tables or screen objects.<P>
The result in the slotfiller case is <font face=Kapl>w[1]</font>.<P>
In the nested slotfiller case, contexts whose names are prefixed by the name in <font face=Kapl>w[1]</font> are created for every level of the slotfiller, dependencies are created in these contexts, and assignment callbacks are defined, all analogous to the slotfiller case above.  The result in this case is a list of names, as symbols, of the created contexts corresponding to the ordinary slotfillers at the bottom of the nested slotfiller.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
<pre><font face=Kapl>     x.bû10«x.aûÉ3
     x.slotû(`k`m;(x.a;x.b))
     `x `y t.disperse `slot

     _def `y.m
m:`mØx.slot
     y.mû-y.m
     `mØx.slot
 0 ¢10 ¢20</font></pre>
</BLOCKQUOTE><A NAME=HEADING903>
<H2><FONT color="#20B2AA">Dynamic <A NAME=82>Derived Table  <font face=Kapl>t.always{w;e}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>w</font> is either a a one- or two-element symbol vector, or a symbol scalar.  The right argument <font face=Kapl>e</font> is a character vector or scalar, or the Null.  The result is an integer scalar.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
If the right argument <font face=Kapl>e</font> is a nonempty character vector or character scalar, this function has the same effect as <font face=Kapl>t.only</font>, except that the selection defined by <font face=Kapl>e</font> remains active.  That is, if any column in the source table whose name appears in <font face=Kapl>e</font> changes, the selection is recalculated.  If the right argument is the Null then this function has the same effect as <font face=Kapl>t.only</font>, and in addition any active connection is broken. <P>
The result is the number of selected rows.<P>
</BLOCKQUOTE><A NAME=HEADING904>
<H2><FONT color="#20B2AA">Dynamic <A NAME=86>Sorted Derived Table  <font face=Kapl>t.sorted{w;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>w</font> is either a one- or two-element symbol vector, or a symbol scalar, or the Null.  The right argument is either a nonempty symbol vector or an association list.  The result is an integer scalar.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
This function is to <font face=Kapl>t.sort</font> as <font face=Kapl>t.always</font> is to <font face=Kapl>t.only</font>: a table is sorted just as it is by <font face=Kapl>t.sort</font>, but it is also sorted again whenever one of the columns named in <font face=Kapl>x</font> changes.<P>
The result is the number of rows in the sorted table.<P>
</BLOCKQUOTE><A NAME=HEADING905>
<H2><FONT color="#20B2AA">Find<A NAME=89>  <font face=Kapl>t.in{a;b}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>a</font> is a character matrix and the right argument <font face=Kapl>b</font> is a character vector or scalar.  The result is a boolean vector of size <font face=Kapl>#a</font>.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
This function is a utility function in t.  The right argument holds a list of character strings, each of length <font face=Kapl>1#Òa</font>, separated by commas.  If a matrix <font face=Kapl>c</font> is formed with these character strings as rows, then <font face=Kapl>t.in{a;b}</font> equals <font face=Kapl>aÅc</font>.<P>
This function can be used to form selections in the right argument of selection functions such as <font face=Kapl>t.only</font>.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
The selection <font face=Kapl>'dept_noÅ3&nbsp;3Ò"D11D21D31"'</font> in "<A HREF="#9">Row
 and Column Selection</A>" can be phrased in the more English like
 <font face=Kapl>'dept_no&nbsp;in&nbsp;"D11,D21,D31"'</font>. See
 "<A HREF="#37">Selectors</A>" for more on English like selections.<P>
</BLOCKQUOTE><A NAME=HEADING906>
<H2><FONT color="#20B2AA">Fix a <A NAME=92>View  <font face=Kapl>t.fix{d;b}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>d</font> is a one-element symbol vector or a symbol scalar.  The right argument <font face=Kapl>b</font> is a one-element integral vector or an integral scalar.  The result is an integer scalar.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The table named by the left argument <font face=Kapl>d</font> should be a view in which row selections are done, e.g., with <font face=Kapl>t.also</font>.  When <font face=Kapl>t.fix{d;1}</font> is executed the current view <font face=Kapl>d</font> is fixed; any further selections done in the view<A NAME=APlusRefV2_FootNote_964 HREF=APlusRefV2_FootNote_964.html><b><SUP>2</SUP></b></A> will refer to no rows in the source of <font face=Kapl>d</font> other than those present at the time <font face=Kapl>t.fix{d;1}</font> was executed.  A subsequent execution of <font face=Kapl>t.fix{d;0}</font> releases the fixed view, i.e., returns to the default setting.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     src.aûÉ100
     `src t.only 'a&lt;90'
 90            ã </font>The number of rows in <font face=Kapl>view
     `view t.fix 1
     `src `view t.only '20&lt;a'
 20
     `src `view t.also '80&gt;a'
 29            ã </font>Only 9 rows are appended, rows 81 through 89 of <font face=Kapl>src
     `view t.fix 0
     `src `view t.also '80&gt;a'
 39            ã </font>Now rows 90 through 99 of <font face=Kapl>src</font> appear in <font face=Kapl>view</font></pre>
</BLOCKQUOTE><A NAME=HEADING907>
<H2><FONT color="#20B2AA">Index  <A NAME=94><font face=Kapl>t.index{i;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>i</font> is an integer vector and the right argument <font face=Kapl>x</font> is a symbol scalar holding the name of a t-table column.  If <font face=Kapl>f</font> is the table column named by <font face=Kapl>x</font>, i.e., <font face=Kapl>fû%x</font>, then the result has shape <font face=Kapl>(Òi),(1ÕÒf)</font> and type <font face=Kapl>©f</font>.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
This function is a utility function in t.  It is used in the definitions of columns sent to views, which are defined formally as <font face=Kapl>i#x</font>, but are actually <font face=Kapl>t.index{i;x}</font>.  It is like the system function <font face=Kapl>_index</font>, except that the NA value is not specified.  Instead, the NA value is <font face=Kapl>t.na{x}</font>. <P>
A+ applications can use <font face=Kapl>t.index</font> wherever <font face=Kapl>_index</font> would otherwise be used but defaulting to this definition of NA values makes sense.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
See "<A HREF="#10">How t Manages Row and Column Selection</A>".<P>
</BLOCKQUOTE><A NAME=HEADING908>
<H2><FONT color="#20B2AA">Indirect <A NAME=96>Static Link  <font face=Kapl>t.link_i{w;f}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>w</font> is a two-element symbol vector and the right argument <font face=Kapl>f</font> is a symbol vector, a two-element nested vector whose items are symbol vectors of the same length, or the Null.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The definition is analogous to that of <font face=Kapl>t.link</font>, and the differences are discussed in "<A HREF="#19">Static Grouping</A>" and "<A HREF="#28">Static Links</A>".</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
See "<A HREF="#19">Static Grouping</A>" and "<A HREF="#28">Static Links</A>".<P>
</BLOCKQUOTE><A NAME=HEADING909>
<H2><FONT color="#20B2AA">Indirect <A NAME=98>Static Summary  <font face=Kapl>t.group_i{w;f}</FONT></H2>
</font><b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>w</font> is a two-element symbol vector, and the right argument is a symbol vector or scalar, or the Null.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The definition is analogous to that of <font face=Kapl>t.group</font>, and the differences are discussed in "<A HREF="#19">Static Grouping</A>".</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
See "<A HREF="#19">Static Grouping</A>".<P>
</BLOCKQUOTE><A NAME=HEADING910>
<H2><FONT color="#20B2AA">Lightweight <A NAME=101>Column Definition  <font face=Kapl>t.let{d;f}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>d</font> is a symbol scalar or one-element vector, and the right argument <font face=Kapl>f</font> is a symbol scalar or nonempty symbol vector.  The result is a symbol scalar or symbol vector with the same number of items as the right argument <font face=Kapl>f</font>.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The left argument <font face=Kapl>d</font> is the name of a table, and each symbol in the right argument <font face=Kapl>f</font> is the name of an existing global variable or dependency.  These names can be qualified or unqualified, and if unqualified, the object is assumed to be in the table context of <font face=Kapl>d</font>.  The effect of this function is to append the objects named in <font face=Kapl>f</font> to the table <font face=Kapl>d</font> as new columns; note that the definitions of these columns are independent of t, unlike columns specified in <font face=Kapl>t.open</font> or <font face=Kapl>t.define</font>.  The result is a symbol scalar or vector holding the fully qualified name of every defined column.<P>
</BLOCKQUOTE><A NAME=HEADING911>
<H2><FONT color="#20B2AA">Link and <A NAME=103>Send  <font face=Kapl>t.relate{s;d;f;g;h}</FONT></H2>
</font><b>&nbsp;&nbsp;&nbsp;Arguments</b><BLOCKQUOTE>
The arguments <font face=Kapl>s</font> and <font face=Kapl>d</font> are symbol scalars.  The argument <font face=Kapl>f</font> is a valid right argument of <font face=Kapl>t.link</font> when the left argument is <font face=Kapl>s,d</font>.  The arguments <font face=Kapl>g</font> and <font face=Kapl>h </font>are valid right arguments for <font face=Kapl>t.send</font> when the left arguments are <font face=Kapl>s,d</font> and <font face=Kapl>d,s</font>, respectively.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
<font face=Kapl>t.relate{s;d;f;g;h}</font> is equivalent to executing the following expressions:
<pre><font face=Kapl>     (s,d) t.link f
     (s,d) t.send g
     (d,s) t.send h</font></pre>
</BLOCKQUOTE><A NAME=HEADING912>
<H2><FONT color="#20B2AA">Link <A NAME=105>Two Tables  <font face=Kapl>t.link{w;f}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments</b><BLOCKQUOTE>
The left argument <font face=Kapl>w</font> is a two-element symbol vector and the right argument <font face=Kapl>f</font> is a symbol vector, or a two-element nested vector whose items are symbol vectors of the same length, or the Null.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The symbols in the left argument are the names of tables, either base or view.  The symbols in a symbol vector right argument are the names of columns called link fields that appear in both tables named in the left argument.  The effect of this function is to link the two tables on the specified link fields, which means that mappings are established between the two tables that govern the way columns are sent from one to the other.<P>
If the right argument is a two-element nested vector, then the symbols in the first item identify the link fields in the table named in the first element of the left argument, and the symbols in the second element identify the corresponding link fields in the other table.  A Null right argument breaks any existing links between the two tables named in the left argument.<P>
See "<A HREF="#23">Linking Tables</A>" for details.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
See the examples that follow "<A HREF="#23">Linking Tables</A>".<P>
</BLOCKQUOTE><A NAME=HEADING913>
<H2><FONT color="#20B2AA">Link, <A NAME=107>with Permutation  <font face=Kapl>t.link_b{w;f}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>w</font> is a two-element symbol vector and the right argument <font face=Kapl>f</font> is a symbol scalar, or a one-element symbol vector, or a two-element nested vector whose items are symbol scalars or a one-element symbol vectors.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
This function, like <font face=Kapl>t.link</font>, establishes a link between the two tables named in the left argument.  As with <font face=Kapl>t.link</font>, the first element of the left argument names the partition side of the link and the second element names the replication side, and the right argument names the link field(s).  The differences in the two functions are that there can only be one link field here, and the mappings between the two tables are computed differently: this function should be used for tables wherever <font face=Kapl>b.p</font> should be used instead of dyadic <font face=Kapl>É</font>.<P>
Let table <font face=Kapl>l</font> be the partition side and table <font face=Kapl>r</font> the replication side.  Unlike <font face=Kapl>t.link</font>, this function requires that a sort vector for the link field(s) on the replication side be known, and that sort vector is the user-defined table variable <font face=Kapl>r._H_l</font>.  Specifically, this vector must have the following meaning.  Say the link field on the partition side is <font face=Kapl>p</font> and on the replication side is <font face=Kapl>r</font>.  Then <font face=Kapl>r._H_l</font> must be a permutation vector so that the items of <font face=Kapl>r._H_l#r%p</font> are in nondecreasing order (see "<A HREF="APlusRefV2_55.html#1">Sorted Arguments to the b-Context Functions</A>", for the definition of nondecreasing order).  The t-defined table dependency <font face=Kapl>l._G_r</font> is defined by the expression:
<pre><font face=Kapl>     b.pr{r_f;r._H_l;r%p}</font></pre>
The partition side mapping <font face=Kapl>l._J_r</font> is derived directly from <font face=Kapl>l._G_r</font> and <font face=Kapl>r._H_l</font>, and the replication side mapping <font face=Kapl>r._I_l</font> is then derived directly from <font face=Kapl>l._J_r</font>.  See, for example, "<A HREF="#19">Static Grouping</A>".<P>
</BLOCKQUOTE><A NAME=HEADING914>
<H2><FONT color="#20B2AA">NA <A NAME=109>Value  <font face=Kapl>t.na{x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>x</font> is a symbol scalar holding the name of a t-table column.  The result is an array.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
This function is a utility function in t.  It is used to produce a substitute value for a column item when that column is indexed by t with an out of range value, which can occur when columns in tables are of different sizes.  The substitute value is determined as follows:<P>
<UL>
<LI>if the <font face=Kapl>`na</font> attribute of the column <font face=Kapl>x</font> has been set, use that value;<P>
<LI>otherwise, if the <font face=Kapl>`t.sent</font> attribute has been set and its value is the symbol <font face=Kapl>s</font> (see <font face=Kapl>t.open</font>) , and <font face=Kapl>sÖy</font> is the name of the source column of <font face=Kapl>x</font>, and if the A+ types of <font face=Kapl>x</font> and <font face=Kapl>sÖy</font> are identical , i.e., if <font face=Kapl>©%x</font> equals <font face=Kapl>©s%y</font>, use the NA value for <font face=Kapl>sÖy</font>, as determined by these same rules;<P>
<LI>otherwise, use <font face=Kapl>(©%x)Øt.NA</font>.
</UL>
</BLOCKQUOTE><A NAME=HEADING915>
<H2><FONT color="#20B2AA">Populate <A NAME=113>a View Table<font face=Kapl>  t.send{w;f}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>w</font> is a symbol vector with at least two elements, or an array complying with the left argument specification of <font face=Kapl>t.open</font>.  The right argument <font face=Kapl>f</font> is a symbol vector, or an association list, a nested slotfiller, or an array complying with the right argument specification of <font face=Kapl>t.open</font>.  The result is a two-column symbol matrix.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
This function is used to populate a view created by a selection function such as <font face=Kapl>t.only</font>, or <font face=Kapl>t.group</font>, or to send columns from one side of a link to the other.  This is accomplished by specifying three things: the names of the columns in the source table(s), the names of the corresponding columns in the target table, and the definitions of the target table columns in terms of the source table columns.<P>
The meaning of the left argument is:<P>
<UL>
<LI>A two-element symbol vector left argument specifies the source table from which columns are sent (<font face=Kapl>0Øw</font>) and the target table that receives columns (<font face=Kapl>1Øw</font>).<P>
<LI>A symbol vector left argument with more than two elements is a special case related to <font face=Kapl>t.cat</font>, and the execution of <font face=Kapl>t.send</font> should have been preceded by an execution of <font face=Kapl>t.cat</font>.  When <font face=Kapl>t.send</font> is used to populate the target of <font face=Kapl>t.cat</font>, not all the source tables of the target need be used, and the source tables can be given in any order.  Only columns from the source tables appearing in this left argument are catenated, in the order in which they appear.<P>
<LI>Any other left argument, taken together with the right argument, must form a valid left argument, right argument pair for <font face=Kapl>t.open</font>, and the meaning of this function in that case is exactly the same as for <font face=Kapl>t.open</font>.
</UL>
When the left argument is a symbol vector with at least two elements, the meaning of the right argument is:
<UL>
<LI>Every symbol in a symbol vector right argument is the name of a column to be sent from the source table(s) to the target table.  A new column in the target table has the same name as its source column(s).<P>
<LI>A nested slotfiller right argument has symbol, value pairs in which the symbol is the name of a column in the target table, say <font face=Kapl>`c</font>, and the value is also a slotfiller, whose symbol, value pairs are as follows:<P>
<UL>
<LI>if the symbol is <font face=Kapl>`_from</font>, the value is the name of the column in the source table(s) to be sent to <font face=Kapl>`c</font>.  In the default case, when this symbol, value pair is not present, the column(s) in the source table(s) are also named <font face=Kapl>`c</font>.<P>
<LI>if the symbol is <font face=Kapl>`_type</font>, the value is either 0 or any nonzero scalar.  If 0, the target column is defined to be a dependency according to the <font face=Kapl>`_frame</font> case below.  If nonzero, there should be a single source column, it should be a dependency, and any columns in the source table on which it depends, if not present in the target table, should be sent to it.  The target column is defined to be a dependency with exactly the same definition as that of the source column.  The default case, when this symbol, value pair is not present, is the value 0 case.<P>
<LI>if the symbol is <font face=Kapl>`_frame</font>, the value is a dependency frame for this column (see "<A HREF="#39">Dependency Frames</A>"), which is used as the basis for the dependency definition of this column in the target table.  When this symbol, value pair is not present, the dependency definition is a default one, which is essentially:<BR><font face=Kapl>t.index{_V;c}</font> <BR>(see "<A HREF="#10">How t Manages Row and Column Selection</A>").<P>
<LI>if the symbol is <font face=Kapl>`_func</font>, this must be one of two cases:<P>
<UL>
<LI>the column is being sent to a view initialized by <font face=Kapl>t.group</font> or one of its variants;<P>
<LI>the column is being sent to a partition side of a link.<P>
</UL>
If so, the value part of the pair is a group function for this column (see "<A HREF="#40">How Group Functions are Specified and How t Applies Them</A>").  When this symbol, value pair is not present, the group function is "first item".<P>
</UL>
<LI>The so-called <i>nested form</i> is a slotfiller right argument with symbol, value pairs in which the symbol is the name of a column received from the source table(s), say <font face=Kapl>`c</font>, and the value is a nested vector with at most four elements.  Each element has the meaning of a value associated with one of the symbolic indices of the nested slot-filler case: <font face=Kapl>`_from</font>, <font face=Kapl>`_type</font>, <font face=Kapl>`_frame</font>, and <font face=Kapl>`_func</font>; which meaning is deduced from the type and contents of the element.  If no element can be associated with a symbolic index, the default value associated with that symbolic index is used.
<P>Note that as a special case, when a value has only one element, that element does not have to be enclosed.<P>
<LI>An association list right argument has symbol, value pairs like those in either the nested slotfiller or nested form case.<P>
</UL>
A set callback is placed on each field that is sent.  It can be removed by executing<font face=Kapl> fld&nbsp;_scb&nbsp;(;)</font>.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
See the examples earlier in this chapter for various uses of <font face=Kapl>t.send</font>.
 Other cases when <font face=Kapl>t.send</font> is not equivalent to
 <font face=Kapl>t.open</font> are:<P>
<OL>
<LI>Send a column <font face=Kapl>csrc</font> from the source table
 <font face=Kapl>src</font> to the target table <font face=Kapl>ctar</font> and name it
 <font face=Kapl>csrc</font> in the target table:<BR>
<font face=Kapl>`src&nbsp;`tar&nbsp;t.send&nbsp;(`ctar;`csrc)</font><br>
or<BR>
<font face=Kapl>`src&nbsp;`tar&nbsp;t.send&nbsp;(`ctar;&lt;`csrc)</font><br>
or<BR>
<font face=Kapl>`src&nbsp;`tar&nbsp;t.send&nbsp;(`ctar;(`_from;`csrc)</font>)<P>
<LI>Adding to example 1, suppose that the target table was established by
 <font face=Kapl>t.group</font> and the group function <font face=Kapl>bf</font> is to be
 sent as well:<BR>
<font face=Kapl>`src&nbsp;`tar&nbsp;t.send&nbsp;(`ctar;(`csrc;bf))</font><br>
or<BR>
<font face=Kapl>`src&nbsp;`tar&nbsp;t.send&nbsp;(`ctar;(`_func`_from;(bf;`csrc)))</font>
</OL>
</BLOCKQUOTE><A NAME=HEADING916>
<H2><FONT color="#20B2AA">Random <A NAME=115>Sample  <font face=Kapl>t.sample{w;n}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>w</font> is either a symbol scalar or a one-element or two-element symbol vector.  The right argument <font face=Kapl>n</font> is an integer or the Null.  The result is also an integer.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
If the left argument has two elements, the first element holds the name of an existing table, base or view, and the second element holds the name of a table to be created by this function.  If the right argument is an integer, then the created table is a random sample of n rows of the existing table, and the result equals n.  If the right argument is the Null, then the created table is a rowwise permutation of the existing table, and the result is the number of rows in either one. <P>
A one-element left argument holds the name of an existing view.  If the right argument is an integer, the effect is to restrict the view to a random sample of n rows, and the result equals n.  If the right argument is the Null, the effect is permute the rows of the view, and the result equals the number of rows in the view.<P>
</BLOCKQUOTE><A NAME=HEADING917>
<H2><FONT color="#20B2AA">Reset  <A NAME=117><font face=Kapl>t.reset{}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Result</b><BLOCKQUOTE>
The result is a symbol vector.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
Close all t-tables, i.e., execute <font face=Kapl>s</font> <font face=Kapl>t.close</font> <font face=Kapl>()</font> for all existing t-tables <font face=Kapl>s</font>.  The result is a list of names, as symbols, of the closed tables.<P>
</BLOCKQUOTE><A NAME=HEADING918>
<H2><FONT color="#20B2AA">Restrict <A NAME=119>a Table  <font face=Kapl>t.only{w;e}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>w</font> is either a two-element symbol vector, a one-element symbol vector, or a symbol scalar.  The right argument <font face=Kapl>e</font> is either a character or integral vector or scalar, or the Null.  The result is an integer scalar.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The right argument <font face=Kapl>e</font> denotes a row selection in a source table that is realized in a target table.  The source and target tables are specified in the left argument.  The result is the number of rows selected.<P>
The symbols in the left argument are the names of tables, either base or view.  If the left argument has two elements, then the first one denotes the source table of the selection and the second one the target table; if it has one element, it denotes the target table.  When the left argument has two elements and the target table does not exist, it is created; when the argument has one element, it is assumed to be an existing table.<P>
The target table cannot be a base table, i.e., it cannot be one created by <font face=Kapl>t.open</font>.  A view table can serve as either the source and target table.<P>
In the case of a two-element left argument, the right argument defines a selection of the rows in the source table that will make up the target table.  If the right argument is an integer vector or scalar it is assumed to hold the indices of those rows in the source table.  If the right argument is a character vector or scalar it is assumed to hold an A+ integer-valued expression; calling the value of this expression <font face=Kapl>v</font>, the target table will consist of the source table rows with row indices <font face=Kapl>v/É#v</font>. <P>
In the case of a one-element left argument, the right argument defines a selection of rows in the existing target table.  If the right argument is an integer vector or scalar, it is assumed to hold the indices of rows in the source table that are currently in the target table, while if the right argument is a character vector or scalar it defines a selection of rows from the current target table.<P>
When the right argument is the Null, the resulting view contains all rows of the source, no matter whether the left argument has one or two elements.<P>
When the right argument is an integer vector or scalar it is most likely the result of an A+ expression, and when it is a character vector or scalar it contains an A+ expression.  The difference between the two forms of right argument is due to the way t evaluates a character right argument.  For example, suppose a selection is to choose all rows for which the value of the column named col is greater than 10.  Then a character right argument should be <font face=Kapl>'col&gt;10'</font> or an equivalent statement, and should not refer directly to the source table.  See the utility function <A HREF="#89"><font face=Kapl>t.in</font></A> for another example.<P>
Note that <font face=Kapl>t.only</font> simply defines view tables; it does not populate
 them with columns.  For that purpose, see
 <A HREF="#113"><font face=Kapl>t.send</font></A>.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
See "<A HREF="#9">Row and Column Selection</A>". Note that:
<pre><font face=Kapl>     `employees `p_employees t.only '18Ò1 0'</font></pre>
has the effect of creating the view <font face=Kapl>p_employees</font> with rows from
 the <font face=Kapl>employees</font> table with indices <font face=Kapl>(18Ò1 0)/É18</font>.
  The equivalent selection can be made with the latter expression as the numeric right
 argument to <font face=Kapl>t.only</font>, as in:
<pre><font face=Kapl>     `employees `p_employees t.only (18Ò1 0)/É18</font></pre>
</BLOCKQUOTE><A NAME=HEADING919>
<H2><FONT color="#20B2AA">Screen <A NAME=121>Table  <font face=Kapl>t.table{w}</FONT></H2>
</font><b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The argument w is either a one- or two-element symbol vector.  The result is a symbol scalar.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
If the argument <font face=Kapl>w</font> has one element then it is either a qualified or unqualified name; if unqualified, it is the name of a t-table, whereas if qualified, it is the name of a variable in the context of a t-table.  An unqualified name is treated as if it were the qualified name <font face=Kapl>wÖ_T_</font>.  A two-element argument <font face=Kapl>w</font> is treated as if it were the qualified name <font face=Kapl>w[0]Öw[1]</font>.  The result is this qualified name.  An object with this name is created that contains the same value as that described for <font face=Kapl>_T_</font> in the table
 "<A href="#143">t-Created Variables, Dependencies Common to All Table Contexts</A>".  And, finally, this object is bound to the table display class (in particular, this function assumes that the s context has been loaded).</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
See "<A HREF="#20">Successive Multiple Group Fields</A>".<P>
</BLOCKQUOTE><A NAME=HEADING920>
<H2><FONT color="#20B2AA">Sort  <A NAME=123><font face=Kapl>t.sort{w;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>w</font> is either a one- or two-element symbol vector, or a symbol scalar, or the Null.  The right argument is either a nonempty symbol vector or association list or the Null.  The result is an integer scalar.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The symbols in the left argument are the names of tables, either base or view.  If the left argument has two elements then the first one denotes the source table of the selection and the second one the target table; if it has one element, it denotes the target table.  When the left argument has two elements and the target table does not exist, it is created; when it has one element, it is assumed to be an existing table.<P>
The target table cannot be a base table, i.e., it cannot be one created by <font face=Kapl>t.open</font>.  A view table can serve as either the source and target table.<P>
If the left argument <font face=Kapl>w</font> has one element and the right argument <font face=Kapl>x</font> is a nonempty symbol vector or symbol scalar, the effect of this function is to sort the table named by <font face=Kapl>w</font>, as follows.  The A+ primitive Grade Up is applied to the column named by the last element in <font face=Kapl>x</font>, and the resulting permutation vector is applied to all columns of the table.  Grade Up is then applied to the column named by the next to last element in <font face=Kapl>x</font>, and the resulting permutation vector is applied to all columns of the table.  This process continues until Grade Up has been applied to all columns named in <font face=Kapl>x</font>, in their right to left order of appearance.<P>
If instead the right argument <font face=Kapl>x</font> is an association list, then the symbol in each symbol, value pair is the name of a column, and the value is either 0 or 1.  The sorting process described above is modified so that Grade Up is applied to a column only when its associated value is 1, and otherwise Grade Down is applied.<P>
When the left argument has two elements, the first element names a source table and the second element a view of that source.  The effect of this function is apply the sorting process to the source table to obtain a permutation vector, although that table is left unchanged; the permutation vector is applied to the rows of the view table instead.<P>
If the right argument is the Null then a table is returned to its unsorted order.<P>
</BLOCKQUOTE><A NAME=HEADING921>
<H2><FONT color="#20B2AA">Successive <A NAME=126>Grouping <font face=Kapl> t.report{w;f}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>w</font> is a two-element symbol vector.  The right argument <font face=Kapl>f</font> is a symbol scalar or nonempty symbol vector.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The symbols in the left argument hold the names of tables.  As in <font face=Kapl>t.group</font>, the first element names an existing base or view table, called the source table, and the second element names a view table to be created by this function, called the target table.  The symbols in the right argument hold the names of columns in the source table.  Unlike <font face=Kapl>t.group</font>, where grouping is done on the rows of the collection of columns named in the right argument, here the grouping is done successively on the individual columns, starting with the first one named in right argument.  That is, all rows with common values in the first column named in the right argument are grouped, just as in <font face=Kapl>t.group</font> with only one column named in the right argument.  Then within each such group, all rows with common values in the second column named in the right argument are grouped, and so on.  The effect of this function is to form a series of intermediate tables between the source and target tables, one for each column named in the right argument. <P>
As with other t functions, the view created by <font face=Kapl>t.report</font> must be populated with columns from the source table, using <font face=Kapl>t.send</font>.  In this case, however, t contributes a column of row headings indicating the successive grouping.  This column is named <font face=Kapl>_</font> and is the first name in <font face=Kapl>_T</font>.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
See "<A HREF="#20">Successive Multiple Group Fields</A>".<P>
</BLOCKQUOTE><A NAME=HEADING922>
<H2><FONT color="#20B2AA">Summarize <A NAME=129>a Table  <font face=Kapl>t.group{w;f}</font> or <font face=Kapl>t.break{w;f}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>w</font> is a two-element symbol vector, and the right argument is a symbol vector or scalar, or the Null, or a slotfiller.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The left argument holds the names of the source table and destination table.<P>
The symbols in the left argument are the names of tables. The first element names an existing base or view table, called the source table, and the second element names a view table to be created by this function, called the target table. The symbols in the right argument, including the case of the symbolic indices in a slotfiller, are the names of columns called group fields that appear in the source table; all fields are group fields if the right argument is the Null. The effect of this function is to establish a onesided link from the source table to the target table on the specified group fields, with the source table acting as the partition side of the link, which means that mappings are established between the two tables that govern the way columns are sent from one to the other. See "<A HREF="#13">Group Fields and Group Functions</A>" for details. In the case of a slotfiller right argument, every value <font face=Kapl>`aØf </font>is an integer vector specifying the group-by-interval values for the field <font face=Kapl>a</font>.<P>
<font face=Kapl>t.break</font> is a synonym for <font face=Kapl>t.group</font>.<P>
</BLOCKQUOTE><A NAME=HEADING923>
<H2><FONT color="#20B2AA">Summarize <A NAME=131>and Send  <font face=Kapl>t.partition{s;d;f;g}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments</b><BLOCKQUOTE>
The arguments <font face=Kapl>s</font> and <font face=Kapl>d</font> are symbol scalars.  The argument <font face=Kapl>f</font> is a valid right argument of <font face=Kapl>t.group</font> when the left argument is <font face=Kapl>s,d</font>.  The argument <font face=Kapl>g</font> is a valid right argument for <font face=Kapl>t.send</font> when the left argument is <font face=Kapl>s,d</font> .</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
<font face=Kapl>t.partition{s;d;f;g}</font> is equivalent to executing the following expressions:
<pre><font face=Kapl>     (s,d) t.group f
     (s,d) t.send g</font></pre>
</BLOCKQUOTE><A NAME=HEADING924>
<H2><FONT color="#20B2AA">Union  <A NAME=133><font face=Kapl>t.also{w;e}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>w</font> is either a one- or two-element symbol vector or a symbol scalar.  The right argument <font face=Kapl>e</font> is either a character or integral vector or scalar, or the Null.  The result is an integer scalar.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The right argument <font face=Kapl>e</font> denotes a row selection in a source table that is appended to a target table.  The source and target tables are specified in the left argument.  The result is the number of rows selected.<P>
The symbols in the left argument are the names of tables, either base or view.  If the left argument has two elements, then the first one denotes the source table of the selection and the second one the target table; if it has one element, it denotes the target table.  When the left argument has two elements and the target table does not exist, it is created; when the argument has one element, it is assumed to be an existing table.<P>
The target table cannot be a base table, i.e., it cannot be one created by <font face=Kapl>t.open</font>.  A view table can serve as either the source and target table.<P>
In the case of a two-element left argument, the right argument defines a selection of the rows in the source table that will be appended to the target table.  If the right argument is an integer vector or scalar, it is assumed to hold the indices of those rows in the source table.  If the right argument is a character vector or scalar, it is assumed to hold an A+ integer-valued expression; calling the value of this expression <font face=Kapl>v</font>, the source table rows to be appended to the target table are those in <font face=Kapl>v/É#v</font> not already in the target table.<P>
In the case of a one-element left argument, the right argument defines a selection of rows in the complement of the current target table, i.e., rows in the source table that are not in the target table.  If the right argument is an integer vector or scalar, it is assumed to hold the indices of rows in the source table that are currently in the complement of target table, whereas if the right argument is a character vector or scalar, it defines a selection of rows in the complement of the current target table.  The rows selected from the complement are appended to the current target table.<P>
In the case of a two-element left argument, any unqualified table column names in the right argument refer to the source table, whereas for a one-element left argument, they refer to the target table.  In the latter case, the columns so named must have already been sent to the target table.<P>
When the right argument is the Null, the resulting view contains all rows of the source, no matter whether the left argument has one or two elements.<P>
When the right argument is an integer vector or scalar, it is most likely the result of an A+ expression, and when it is a character vector or scalar it contains an A+ expression.  The difference between the two forms of right arguments are due to the way t evaluates a character right argument.  For example, suppose a selection is to choose all rows for which the value of the column named col is greater than 10.  Then a character right argument should be <font face=Kapl>'col&gt;10'</font> or an equivalent statement, and should not refer directly to the source table.  See <A HREF="#89"><font face=Kapl>t.in</font></A> for another example.<P>
Note that <font face=Kapl>t.also</font> simply defines view tables; it does not populate them with columns.  For that purpose, see <A HREF="#113"><font face=Kapl>t.send</font></A>.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
See "<A HREF="#9">Row and Column Selection</A>".<P>
</BLOCKQUOTE><A NAME=HEADING925>
<H2><FONT color="#20B2AA">View <A NAME=135>and Send  <font face=Kapl>t.view{s;d;f}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments</b><BLOCKQUOTE>
The arguments <font face=Kapl>s</font> and <font face=Kapl>d</font> are symbol scalars.  The argument <font face=Kapl>f</font> is a valid right argument of <font face=Kapl>t.send</font> for the left argument <font face=Kapl>s,d</font>.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
<font face=Kapl>t.view{s;d;f}</font> is equivalent to executing the following expressions:
<pre><font face=Kapl>     (s,d) t.only ()
     (s,d) t.send f</font></pre>
</BLOCKQUOTE><P><A NAME=HEADING926>
<H1><FONT color="#20B2AA">Table <A NAME=136>Variables and Dependencies</FONT></H1>
<A NAME=HEADING927>
<table border=1 cellspacing=0 cellpadding=8>
<caption><FONT color="#20B2AA" size=+2><B>
t-Context <A NAME=137>Global Objects</B></FONT></caption>
<tr>
<th>Name</th><th>Description</th></tr>
<tr>
<td><font face=Kapl>t.CONNECT</font></td>
<td><A NAME=138>This function is either <font face=Kapl>©</font> or <font face=Kapl>^</font>; see
 "<A HREF="#37">Selectors</A>" for its use.</td></tr>
<tr>
<td><font face=Kapl>t.NA</font></td><td><A NAME=140>This variable is a slotfiller holding the default NA
 values. It is:
 <font face=Kapl>(`int&nbsp;`float&nbsp;`char&nbsp;`sym&nbsp;`box&nbsp;`func&nbsp;`null;
 (¢999999999; ¢999999999.; '&nbsp;'; `; &lt;(); &lt;{Û}; &lt;()))</font></td></tr>
<tr>
<td><font face=Kapl>t.TABLES</font></td><td><A NAME=141>This variable holds a list of names, as symbols,
 of all the t-tables created in this A+ session.</td></tr>
</table><P>
The variables described in the following <A href="#143">table</A> appear in every table
 context created by t.  They are referred to by fully qualified names only when necessary.<P>
<A NAME=HEADING928>
<table border=1 cellspacing=0 cellpadding=8>
<caption><FONT color="#20B2AA" size=+2><B>
t-Created <A NAME=143>Variables, Dependencies Common to All Table Contexts</B></FONT>
</caption>
<tr>
<th>Name</th><th>Description</th></tr>
<tr>
<td><font face=Kapl>_A</font></td>
<td><A NAME=144>This variable holds the value <font face=Kapl>1Ò&lt;V</font> in the specification<font face=Kapl>
 </font>of the following (see "<A HREF="#18">Grouping by Intervals</A>"): <BR >
<font face=Kapl>`src&nbsp;`this_table&nbsp;t.group&nbsp;(`group_field;V)<BR>
</font>In general, this variable is a nested vector
 of integer vectors whose items are grouping by intervals specifications corresponding to
 the columns in <font face=Kapl>_T</font>.</td></tr>
<tr>
<td><font face=Kapl>_D</font></td>
<td><A NAME=145>This variable holds a list of names, as symbols, of the target tables for
 which this table is a source.</td></tr>
<tr>
<td><font face=Kapl>_D_</font></td>
<td><A NAME=146>This dependency is a nested slotfiller of the items in <font face=Kapl>_D</font>; the
 top level is the name of this table; the next level holds the names of the views created
 directly from this table; the next level holds the names of the views created directly
 from those views; and so on.<br>
Display this dependency as a tree object for a convenient representation.</td></tr>
<tr>
<td><font face=Kapl>_F</font></td>
<td><A NAME=147>When <font face=Kapl>t.fix</font> is executed with the right argument <font face=Kapl>1</font> for this
 table, this variable is assigned the current value of <font face=Kapl>_V</font>.  Initially, and when
<font face=Kapl>t.fix</font> is executed with the right argument <font face=Kapl>0</font> for this table, this variable
 is set to the Null.</td></tr>
<tr>
<td><font face=Kapl>_G_r</font></td>
<td><A NAME=148>This dependency is defined by t when this table is on the partition side of
 a link made with <font face=Kapl>t.link_b</font>. Let <font face=Kapl>l</font> denote this table and let <font face=Kapl>r</font>
 denote the table on the replication of the link. This dependency is computed from
 <font face=Kapl>b.pr</font> and the sort vector <font face=Kapl>r._H_l</font>, and is the first step in the efficient
 computation of the mappings between the two sides on the link.
 See <font face=Kapl>t.link_b</font>.</td></tr>
<tr>
<td><font face=Kapl>_H_l</font></td>
<td><A NAME=149>This dependency is user defined for <font face=Kapl>t.link_b</font>, <font face=Kapl>t.link_d</font>,
 and <font face=Kapl>t.group_d</font>, but defined by t for <font face=Kapl>t.link_i</font> and <font face=Kapl>t.group_i</font>. Its
 value is a permutation vector used in the definition of the map from the source (this
 table) to the view in the case of grouping, and in the case of links, from the replication
 side (this table) to the partition side. The view or partition side is table
 <font face=Kapl>l</font>.</td></tr>
<tr>
<td><font face=Kapl>_I_l</font></td>
<td><A NAME=150>This dependency defines the mapping from the partition side of a link (the
 table <font face=Kapl>l</font>) to the replication side (this table). See
 "<A HREF="#25">How t Manages Table Links</A>".<br>
Note that the name of this mapping is specific to these two tables, so any table can be
 linked to several others at the same time.</td></tr>
<tr>
<td><font face=Kapl>_J</font></td>
<td><A NAME=151>When this table is created by <font face=Kapl>t.group</font>, this dependency defines
 the mapping from the source table to this table.  See "<A HREF="#16">How t Manages Group
 Fields</A>".</td></tr>
<tr>
<td><font face=Kapl>_J_r</font></td>
<td><A NAME=152>This dependency defines the mapping from the replication side of a link
 (the table <font face=Kapl>r</font>) to the partition side (this table).  See
 "<A HREF="#25">How t Manages Table Links</A>".<br>
Note that the name of this mapping is specific to these two tables, so any table can be
 linked to several others at the same time.</td></tr>
<tr>
<td><font face=Kapl>_K</font></td>
<td><A NAME=153>When this table is created by <font face=Kapl>t.group</font>, the value of this dependency
 is the first element of every item of <font face=Kapl>_J</font>.  This dependency is used to implement
 the default group function for a column sent to this table.</td></tr>
<tr>
<td><font face=Kapl>_K_r</font></td>
<td><A NAME=154>This value of this dependency is the first element of every item of
 <font face=Kapl>_J_r</font>.  When this table is serving as the partition side of a link, this dependency
 is used to implement the default group function for a column sent to this table.</td></tr>
<tr>
<td><font face=Kapl>_L</font></td>
<td><A NAME=155>The value of this dependency is a list of names, as symbols, of those
 tables on the partition side of a link with this table.</td></tr>
<tr>
<td><font face=Kapl>_L_</font></td>
<td><A NAME=156>The value of this dependency is a two-column symbol matrix whose rows hold
 the names, as symbols, of partition side, replication side tables in table links.  All
 links with this table as the partition side appear in this matrix; for all tables on the
 replication side of a link with this table, all links with those tables as the partition
 side also appear in this matrix; and so on (until the transitive closure is
 complete).</td></tr>
<tr>
<td><font face=Kapl>_M</font></td>
<td><A NAME=157>The value of this dependency is the depth (monadic <font face=Kapl>½</font>) of the
 column named by <font face=Kapl>0#_T</font>; it is the depth of this table if all columns have the
 same depth.</td></tr>
<tr>
<td><font face=Kapl>_N</font></td>
<td><A NAME=158>The value of this dependency is the number of items in the column named
 by <font face=Kapl>0#_T</font>; it is the number of rows in this table if all columns have the same
 number of items.</td></tr>
<tr>
<td><font face=Kapl>_O</font></td>
<td><A NAME=159>This variable is a two-element nested vector that is set for this table if
 it is created with <font face=Kapl>t.open</font>; the first element holds the directory specified in the
 left argument of <font face=Kapl>t.open</font> (or the default), and the second element holds the field
 specifications in the right argument.</td></tr>
<tr>
<td><font face=Kapl>_R</font></td>
<td><A NAME=160>The value of this dependency is a list of names, as symbols, of those
 tables on the replication side of a link with this table.</td></tr>
<tr>
<td><font face=Kapl>_R_</font></td>
<td><A NAME=161>The value of this dependency is a two-column symbol matrix whose rows hold
 the names, as symbols, of replication side, partition side tables in table links. All
 links with this table as the replication side appear in this matrix; for all tables on the
 partition side of a link with this table, all links with those tables as the replication
 side also appear in this matrix; and so on (until the transitive closure is
 complete).</td></tr>
<tr>
<td><font face=Kapl>_S</font></td>
<td><A NAME=163>This variable holds a list of names, as symbols, of the source tables for
 which this table is a target; see <font face=Kapl>t.group</font>,<font face=Kapl> t.cat</font>, and <font face=Kapl>t.only</font>.
 If <font face=Kapl>_S</font> is identical to the Null, then this table is a base table.
 (More than one source table can occur with table catenation.)</td></tr>
<tr>
<td><font face=Kapl>_S_</font></td>
<td><A NAME=164>The value of this dependency is a list of names, as symbols, of the base
 tables that are the ultimate sources of this table, i.e. from which the creation of this
 table can be traced through a series of applications of <font face=Kapl>t.group</font>, <font face=Kapl>t.cat</font>,
 and <font face=Kapl>t.only</font>.</td></tr>
<tr>
<td><font face=Kapl>_T</font></td>
<td><A NAME=165>This variable holds a list of names, as symbols, of the column variables
 in this table.</td></tr>
<tr>
<td><font face=Kapl>_T_</font></td>
<td><A NAME=166><font face=Kapl>t.table</font> should be executed to set this variable, in which case
 if <font face=Kapl>_U</font> is the Null, this variable is set to a list of names, as symbols, of the
 column variables in this table that conform to the screen management definition of
 tableField. If <font face=Kapl>_U</font> is not the Null, then <font face=Kapl>t.table</font> sets this variable
 to equal <font face=Kapl>_U</font>.</td></tr>
<tr>
<td><font face=Kapl>_U</font></td>
<td><A NAME=167>This variable holds a list of names, as symbols, of the column variables
 in this table that are to appear on the screen, as determined by the application.  It is
 set by the user.</td></tr>
<tr>
<td><font face=Kapl>_V</font></td>
<td><A NAME=168>This variable is the mapping from a source table to this view table.
 See "<A HREF="#10">How t Manages Row and Column Selection</A>".</td></tr>
<tr>
<td><font face=Kapl>_V_</font></td>
<td><A NAME=169>When this view table has one source table, the value of this dependency
 represents the complementary view, in that every row of the source table is selected by
 <font face=Kapl>_V</font> or <font face=Kapl>_V_</font>.</td></tr>
</table><P>
<HR>
<ADDRESS><table width="100%"><tr><td><font size=2><i><a href="mailto:doc@aplusdev.org">doc@aplusdev.org</a></i></font></td><td align=right><font size=2><i>&#169; Copyright 1995&#150;2008 Morgan Stanley Dean Witter &amp; Co.  All rights reserved.</i></font></td></tr></table></ADDRESS>
</BODY>
</HTML>
