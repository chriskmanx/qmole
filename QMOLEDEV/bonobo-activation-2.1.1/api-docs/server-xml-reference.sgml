<chapter id="server-xml-reference">
<title><filename>.server</filename> file format reference</title>

<para>
This section describes the format of the .server files
used by applications to tell the Bonobo Activation daemon about the 
interfaces they support.
</para>

<sect1 id="server-tag">
<title>The &lt;oaf_server> tag</title>

<para>
Here follows a simple example of a minimalist .oafinfo file.
<programlisting>
&lt;oaf_info>
&lt;oaf_server iid="OAFIID:oaf_naming_service:7e2b90ef-eaf0-4239-bb7c-812606fcd80d" 
  type="exe" location="oafd">
&lt;/oaf_server>
&lt;oaf_info>
</programlisting>
Each oaf_server entry conventionally has 3 mandatory properties: <emphasis>iid</emphasis>
(an iid generated by <emphasis>uuidgen</emphasis>), <emphasis>type</emphasis> (can be 
<emphasis>exe</emphasis>, <emphasis>factory</emphasis> and <emphasis>shlib</emphasis>) and 
<emphasis>location</emphasis>. If the type is <emphasis>exe</emphasis>, location is the name of 
the executable which creates the CORBA interfaces associated to this entry and registers 
them to OAF. It the type is <emphasis>factory</emphasis>, location is the iid of the component 
which can create the corresponding CORBA server. Here follows a simple example of this:
<programlisting>
&lt;oaf_info>

&lt;oaf_server iid="OAFIID:demo_echo_factory:a7080731-d06c-42d2-852e-179c538f6ee5"
  type="exe" location="bonobo-echo">
&lt;/oaf_server>

&lt;oaf_server iid="OAFIID:demo_echo:fe45dab2-ae27-45e9-943d-34a49eefca96"
  type="factory" location="OAFIID:demo_echo_factory:a7080731-d06c-42d2-852e-179c538f6ee5">
&lt;/oaf_server>

&lt;/oaf_info>
</programlisting>
If you ask OAF to activate the <filename>OAFIID:demo_echo:fe45dab2-ae27-45e9-943d-34a49eefca96</filename>
component, OAF will first check it is a factory, make sure the corresponding factory compoenent is running 
(by activating it. Here, activating the factory component is a matter of launching the executable) and call
<function>::create</function> on the factory. It will return you that object.
</para>

<para>
If the <emphasis>type</emphasis> is <emphasis>shlib</emphasis>, <emphasis>location</emphasis> is the
name of the library the code is in: <filename>libgmf.so</filename> for example.
</para>

</sect1>

<sect1 id="attribute-tag">
<title>The &lt;oaf_attribute> tag</title>

<para>
Defining servers is useful (that is what .goad files did light-years ago)  but to 
use all the power of OAF (ie: queries ;-), you have to define <emphasis>oaf_attributes</emphasis> 
for each of those <emphasis>oaf_server</emphasis> entries. 
An example is worth all words.
<programlisting>
&lt;oaf_info>

&lt;oaf_server iid="OAFIID:demo_echo_factory:a7080731-d06c-42d2-852e-179c538f6ee5"
  type="exe" location="bonobo-echo">
&lt;oaf_attribute name="repo_ids" type="stringv">
&lt;item value="IDL:GNOME/GenericFactory:1.0"/>
&lt;/oaf_attribute>
&lt;oaf_attribute name="name" type="string" value="Echo component factory"/>
&lt;oaf_attribute name="description" type="string" value="Bonobo Echo server factory"/>
&lt;/oaf_server>

&lt;oaf_server iid="OAFIID:demo_echo:fe45dab2-ae27-45e9-943d-34a49eefca96"
  type="factory" location="OAFIID:demo_echo_factory:a7080731-d06c-42d2-852e-179c538f6ee5">
&lt;oaf_attribute name="repo_ids" type="stringv">
&lt;item value="IDL:Demo/Echo:1.0"/>
&lt;/oaf_attribute>
&lt;oaf_attribute name="name" type="string" value="Echo component"/>
&lt;oaf_attribute name="description" type="string" value="Bonobo Echo server sample program"/>
&lt;/oaf_server>

&lt;/oaf_info>
</programlisting>
Each oaf_server entry defines a set of attributes. 
Each attribute has a given name, type and value. The types of the attributes are those defined in the 
OAF query langage reference (<xref linkend="oaf-query-ref-types">). Type name should
be non-caps.
</para>

<para>
<emphasis>stringv</emphasis> types value is represented as follows:
<programlisting>
&lt;oaf_attribute name="repo_ids" type="stringv">
&lt;item value="IDL:GNOME/GenericFactory:1.0"/>
&lt;/oaf_attribute>
</programlisting>
All other types' values are simply in the <emphasis>value</emphasis> field.
</para>


<para>
A certain number of attributes have been normalized for OAF. Some of them are mandatory.
Their list follows.

	<table frame="all">
	<title>Normalized attributes</title>
	<tgroup cols="4">
	<colspec colwidth="3*" colnum="1" align="left">
	<colspec colwidth="*" colnum="2" align="left">
	<colspec colwidth="10*" colnum="3" align="left">
	<colspec colwidth="*" colnum="4" align="left">
	<thead>
		<row>
		<entry>Attribute name</entry>
		<entry>Type</entry>
		<entry>Signification</entry>
		<entry>Mandatory ?</entry>
		</row>
	</thead>
		<tbody>
		  <row>
		    <entry>repo_ids</entry>
		    <entry>stringv</entry>
		    <entry>the list of all IDL interfaces this component implements. i.e. the list of interfaces for which a queryInterface operation on the component will succeed.</entry>
		    <entry>yes</entry>
		  </row>
		  <row>
		    <entry>description</entry>
		    <entry>string</entry>
		    <entry>a human readable string describing what the component can do</entry>
		    <entry>yes</entry>
		  </row>
		  <row>
		    <entry>name</entry>
		    <entry>string</entry>
		    <entry>a short name for the component</entry>
		    <entry>yes</entry>
		  </row>
		  <row>
		    <entry>bonobo:editable</entry>
		    <entry>boolean</entry>
		    <entry>if component allows editing of its content</entry>
		    <entry>no</entry>
		  </row>
		  <row>
		    <entry>bonobo:supported_mime_types</entry>
		    <entry>stringv</entry>
		    <entry>a list of mime types this
  component understands as input. In addition to specific mime types,
  it is possible to include supertypes (e.g. "image/*" or "text/*") or
  "*/*" to indicate the component can display any mime
  type. Specifying "*/*" is only necessary if "supported_uri_schemes"
  is not specified, otherwise it is assumed. This only really makes
  sense if the component implements one of the following interfaces:
  Bonobo::PersistStream, Bonobo::ProgressiveDataSink, Nautilus::View.</entry>
		    <entry>no</entry>
		  </row>
		  <row>
		    <entry>bonobo:supported_uri_schemes</entry>
		    <entry>stringv</entry>
		    <entry>a list of protocols this
  component knows how to handle. This only really makes sense if the
  component implements one of the following interfaces:
  Bonobo::PersistFile or Nautilus::View</entry>
		    <entry>no</entry>
		  </row>
		  <row>
		    <entry>nautilus:view_as_name</entry>
		    <entry>string</entry>
		    <entry>a suitable name for use as a view
as name (it will be displayed as "View as &lt;foo>" where &lt;foo> is the
name). This must be implemented by any Bonobo Embeddables
or Controls that can be used as Nautilus views (for the content in
the main window, not in the sidebar).</entry>
		    <entry>no</entry>
		  </row>
		  <row>
		    <entry>nautilus:required_directory_content_mime_types</entry>
		    <entry>stringv</entry>
		    <entry>if the
component is to be activated on a URI with mime type
special/directory, it is only really applicable if the directory
contains one of these mime types. As before, supertypes like "audio/*"
are allowed. If this attribute is omitted, "*/*" is assumed.</entry>
		    <entry>no</entry>
		  </row>
		  <row>
		    <entry>nautilus:required_uri_tester</entry>
		    <entry>string</entry>
		    <entry>this specifies the OAFIID
of a component that implements the Nautilus::URITester interface (see
proposal below). If the criteria established by all the other
attributes are satisfied, an object with that OAFIID should be
activated and its is_applicable() method should be called on the URI
to test if it this component _really_, _really_ applies to the given
URI. This should be used as a last resort. (Not yet implemented.)</entry>
		    <entry>no</entry>
		  </row>
		  <row>
		    <entry>nautilus:sidebar_panel_name</entry>
		    <entry>string</entry>
		    <entry>a suitable name for use as
a sidebar panel label name. This must be implemented by any Bonobo
Controls that can be used as a Nautilus sidebar view.</entry>
		    <entry>no</entry>
		  </row>
		  <row>
		    <entry>nautilus:recommended_uri_schemes</entry>
		    <entry>string</entry>
		    <entry>the URI schemes this
meta view is most recommended for. If "*" is included, this component
is recommended for all schemes. If omitted or empty, it is not
recommended for any. (Not yet implemented.)</entry>
		    <entry>no</entry>
		  </row>
		</tbody>
	  </tgroup>
	</table>
</para>
<para>  If <emphasis>bonobo:supported_uri_schemes</emphasis> is specified but
<emphasis>bonobo:supported_mime_types</emphasis> is not, it is assumed the component can
handle any type of data that might come via that protocol. Some
schemes may not even have an associated mime type for any given URI,
for instance irc: or news:
</para>
<para>
  If <emphasis>bonobo:supported_mime_types</emphasis> is specified but
<emphasis>bonobo:supported_uri_schemes</emphasis> is not, the component is assumed to be
able to handle all common URI schemes (possible definition: anything
gnome-vfs can handle).
</para>

<para>
  If neither <emphasis>bonobo:supported_uri_schemes</emphasis> nor
<emphasis>bonobo:supported_mime_types</emphasis> is specified, it is assumed the
component cannot handle any data at all in a general way and should
never be generically selected for such purposes.
</para>

</sect1>


</chapter>




