.TH cmake 1 "December 19, 2011" "cmake 2.6-patch 0"
.SH NAME
.PP
  cmake - Cross-Platform Makefile Generator.
.SH USAGE
.PP
  cmake [options] <path-to-source>
  cmake [options] <path-to-existing-build>
.SH DESCRIPTION
.PP
The "cmake" executable is the CMake command-line interface.  It may be used to configure projects in scripts.  Project configuration settings may be specified on the command line with the -D option.  The -i option will cause cmake to interactively prompt for such settings.

.PP
CMake is a cross-platform build system generator.  Projects specify their build process with platform-independent CMake listfiles included in each directory of a source tree with the name CMakeLists.txt. Users build a project by using CMake to generate a build system for a native tool on their platform.

.SH OPTIONS
.TP
.B -C <initial-cache>
Pre-load a script to populate the cache.

When cmake is first run in an empty build tree, it creates a CMakeCache.txt file and populates it with customizable settings for the project.  This option may be used to specify a file from which to load cache entries before the first pass through the project's cmake listfiles.  The loaded entries take priority over the project's default values.  The given file should be a CMake script containing SET commands that use the CACHE option, not a cache-format file.

.TP
.B -D <var>:<type>=<value>
Create a cmake cache entry.

When cmake is first run in an empty build tree, it creates a CMakeCache.txt file and populates it with customizable settings for the project.  This option may be used to specify a setting that takes priority over the project's default value.  The option may be repeated for as many cache entries as desired.

.TP
.B -U <globbing_expr>
Remove matching entries from CMake cache.

This option may be used to remove one or more variables from the CMakeCache.txt file, globbing expressions using * and ? are supported. The option may be repeated for as many cache entries as desired.


Use with care, you can make your CMakeCache.txt non-working.

.TP
.B -G <generator-name>
Specify a makefile generator.

CMake may support multiple native build systems on certain platforms.  A makefile generator is responsible for generating a particular build system.  Possible generator names are specified in the Generators section.

.TP
.B -Wno-dev
Suppress developer warnings.

Suppress warnings that are meant for the author of the CMakeLists.txt files.

.TP
.B -Wdev
Enable developer warnings.

Enable warnings that are meant for the author of the CMakeLists.txt files.

.TP
.B -E
CMake command mode.

For true platform independence, CMake provides a list of commands that can be used on all systems. Run with -E help for the usage information.

.TP
.B -i
Run in wizard mode.

Wizard mode runs cmake interactively without a GUI.  The user is prompted to answer questions about the project configuration.  The answers are used to set cmake cache values.

.TP
.B -L[A][H]
List non-advanced cached variables.

List cache variables will run CMake and list all the variables from the CMake cache that are not marked as INTERNAL or ADVANCED. This will effectively display current CMake settings, which can be then changed with -D option. Changing some of the variable may result in more variables being created. If A is specified, then it will display also advanced variables. If H is specified, it will also display help for each variable.

.TP
.B -N
View mode only.

Only load the cache. Do not actually run configure and generate steps.

.TP
.B -P <file>
Process script mode.

Process the given cmake file as a script written in the CMake language.  No configure or generate step is performed and the cache is not modified. If variables are defined using -D, this must be done before the -P argument.

.TP
.B --graphviz=[file]
Generate graphviz of dependencies.

Generate a graphviz input file that will contain all the library and executable dependencies in the project.

.TP
.B --system-information [file]
Dump information about this system.

Dump a wide range of information about the current system. If run from the top of a binary tree for a CMake project it will dump additional information such as the cache, log files etc.

.TP
.B --debug-trycompile
Do not delete the try compile directories..

Do not delete the files and directories created for try_compile calls. This is useful in debugging failed try_compiles.

.TP
.B --debug-output
Put cmake in a debug mode.

Print extra stuff during the cmake run like stack traces with message(send_error ) calls.

.TP
.B --help-command cmd [file]
Print help for a single command and exit.

Full documentation specific to the given command is displayed. If a file is specified, the documentation is written into and the output format is determined depending on the filename suffix. Supported are man page, HTML, DocBook and plain text.

.TP
.B --help-command-list [file]
List available listfile commands and exit.

The list contains all commands for which help may be obtained by using the --help-command argument followed by a command name. If a file is specified, the documentation is written into and the output format is determined depending on the filename suffix. Supported are man page, HTML, DocBook and plain text.

.TP
.B --help-commands [file]
Print help for all commands and exit.

Full documentation specific for all current command is displayed.If a file is specified, the documentation is written into and the output format is determined depending on the filename suffix. Supported are man page, HTML, DocBook and plain text.

.TP
.B --help-compatcommands [file]
Print help for compatibility commands. 

Full documentation specific for all compatibility commands is displayed.If a file is specified, the documentation is written into and the output format is determined depending on the filename suffix. Supported are man page, HTML, DocBook and plain text.

.TP
.B --help-module module [file]
Print help for a single module and exit.

Full documentation specific to the given module is displayed.If a file is specified, the documentation is written into and the output format is determined depending on the filename suffix. Supported are man page, HTML, DocBook and plain text.

.TP
.B --help-module-list [file]
List available modules and exit.

The list contains all modules for which help may be obtained by using the --help-module argument followed by a module name. If a file is specified, the documentation is written into and the output format is determined depending on the filename suffix. Supported are man page, HTML, DocBook and plain text.

.TP
.B --help-modules [file]
Print help for all modules and exit.

Full documentation for all modules is displayed. If a file is specified, the documentation is written into and the output format is determined depending on the filename suffix. Supported are man page, HTML, DocBook and plain text.

.TP
.B --help-custom-modules [file]
Print help for all custom modules and exit.

Full documentation for all custom modules is displayed. If a file is specified, the documentation is written into and the output format is determined depending on the filename suffix. Supported are man page, HTML, DocBook and plain text.

.TP
.B --help-property prop [file]
Print help for a single property and exit.

Full documentation specific to the given property is displayed.If a file is specified, the documentation is written into and the output format is determined depending on the filename suffix. Supported are man page, HTML, DocBook and plain text.

.TP
.B --help-property-list [file]
List available properties and exit.

The list contains all properties for which help may be obtained by using the --help-property argument followed by a property name.  If a file is specified, the help is written into it.If a file is specified, the documentation is written into and the output format is determined depending on the filename suffix. Supported are man page, HTML, DocBook and plain text.

.TP
.B --help-properties [file]
Print help for all properties and exit.

Full documentation for all properties is displayed.If a file is specified, the documentation is written into and the output format is determined depending on the filename suffix. Supported are man page, HTML, DocBook and plain text.

.TP
.B --help-variable var [file]
Print help for a single variable and exit.

Full documentation specific to the given variable is displayed.If a file is specified, the documentation is written into and the output format is determined depending on the filename suffix. Supported are man page, HTML, DocBook and plain text.

.TP
.B --help-variable-list [file]
List documented variables and exit.

The list contains all variables for which help may be obtained by using the --help-variable argument followed by a variable name.  If a file is specified, the help is written into it.If a file is specified, the documentation is written into and the output format is determined depending on the filename suffix. Supported are man page, HTML, DocBook and plain text.

.TP
.B --help-variables [file]
Print help for all variables and exit.

Full documentation for all variables is displayed.If a file is specified, the documentation is written into and the output format is determined depending on the filename suffix. Supported are man page, HTML, DocBook and plain text.

.TP
.B --copyright [file]
Print the CMake copyright and exit.

If a file is specified, the copyright is written into it.

.TP
.B --help
Print usage information and exit.

Usage describes the basic command line interface and its options.

.TP
.B --help-full [file]
Print full help and exit.

Full help displays most of the documentation provided by the UNIX man page.  It is provided for use on non-UNIX platforms, but is also convenient if the man page is not installed.  If a file is specified, the help is written into it.

.TP
.B --help-html [file]
Print full help in HTML format.

This option is used by CMake authors to help produce web pages.  If a file is specified, the help is written into it.

.TP
.B --help-man [file]
Print full help as a UNIX man page and exit.

This option is used by the cmake build to generate the UNIX man page.  If a file is specified, the help is written into it.

.TP
.B --version [file]
Show program name/version banner and exit.

If a file is specified, the version is written into it.

.SH GENERATORS
.PP
The following generators are available on this platform:

.TP
.B Unix Makefiles
Generates standard UNIX makefiles.

A hierarchy of UNIX makefiles is generated into the build tree.  Any standard UNIX-style make program can build the project through the default make target.  A "make install" target is also provided.

.TP
.B CodeBlocks - Unix Makefiles
Generates CodeBlocks project files.

Project files for CodeBlocks will be created in the top directory and in every subdirectory which features a CMakeLists.txt file containing a PROJECT() call. Additionally a hierarchy of makefiles is generated into the build tree.  The appropriate make program can build the project through the default make target.  A "make install" target is also provided.

.TP
.B Eclipse CDT4 - Unix Makefiles
Generates Eclipse CDT 4.0 project files.

Project files for Eclipse will be created in the top directory and will have a linked resource to every subdirectory which features a CMakeLists.txt file containing a PROJECT() call.Additionally a hierarchy of makefiles is generated into the build tree. The appropriate make program can build the project through the default make target. A "make install" target is also provided.

.TP
.B KDevelop3
Generates KDevelop 3 project files.

Project files for KDevelop 3 will be created in the top directory and in every subdirectory which features a CMakeLists.txt file containing a PROJECT() call. If you change the settings using KDevelop cmake will try its best to keep your changes when regenerating the project files. Additionally a hierarchy of UNIX makefiles is generated into the build tree.  Any standard UNIX-style make program can build the project through the default make target.  A "make install" target is also provided.

.TP
.B KDevelop3 - Unix Makefiles
Generates KDevelop 3 project files.

Project files for KDevelop 3 will be created in the top directory and in every subdirectory which features a CMakeLists.txt file containing a PROJECT() call. If you change the settings using KDevelop cmake will try its best to keep your changes when regenerating the project files. Additionally a hierarchy of UNIX makefiles is generated into the build tree.  Any standard UNIX-style make program can build the project through the default make target.  A "make install" target is also provided.

.SH COMMANDS
.TP
.B add_custom_command
Add a custom build rule to the generated build system.

There are two main signatures for add_custom_command The first signature is for adding a custom command to produce an output.


  add_custom_command(OUTPUT output1 [output2 ...]
                     COMMAND command1 [ARGS] [args1...]
                     [COMMAND command2 [ARGS] [args2...] ...]
                     [MAIN_DEPENDENCY depend]
                     [DEPENDS [depends...]]
                     [IMPLICIT_DEPENDS <lang1> depend1 ...]
                     [WORKING_DIRECTORY dir]
                     [COMMENT comment] [VERBATIM] [APPEND])

This defines a new command that can be executed during the build process. The outputs named should be listed as source files in the target for which they are to be generated. If an output name is a relative path it will be interpreted relative to the build tree directory corresponding to the current source directory. Note that MAIN_DEPENDENCY is completely optional and is used as a suggestion to visual studio about where to hang the custom command. In makefile terms this creates a new target in the following form:


  OUTPUT: MAIN_DEPENDENCY DEPENDS
          COMMAND

If more than one command is specified they will be executed in order. The optional ARGS argument is for backward compatibility and will be ignored.


The second signature adds a custom command to a target such as a library or executable. This is useful for performing an operation before or after building the target. The command becomes part of the target and will only execute when the target itself is built.  If the target is already built, the command will not execute.


  add_custom_command(TARGET target
                     PRE_BUILD | PRE_LINK | POST_BUILD
                     COMMAND command1 [ARGS] [args1...]
                     [COMMAND command2 [ARGS] [args2...] ...]
                     [WORKING_DIRECTORY dir]
                     [COMMENT comment] [VERBATIM])

This defines a new command that will be associated with building the specified target. When the command will happen is determined by which of the following is specified:


  PRE_BUILD - run before all other dependencies
  PRE_LINK - run after other dependencies
  POST_BUILD - run after the target has been built

Note that the PRE_BUILD option is only supported on Visual Studio 7 or later. For all other generators PRE_BUILD will be treated as PRE_LINK.


If WORKING_DIRECTORY is specified the command will be executed in the directory given. If COMMENT is set, the value will be displayed as a message before the commands are executed at build time. If APPEND is specified the COMMAND and DEPENDS option values are appended to the custom command for the first output specified. There must have already been a previous call to this command with the same output. The COMMENT, WORKING_DIRECTORY, and MAIN_DEPENDENCY options are currently ignored when APPEND is given, but may be used in the future.


If VERBATIM is given then all the arguments to the commands will be passed exactly as specified no matter the build tool used. Note that one level of escapes is still used by the CMake language processor before ADD_CUSTOM_TARGET even sees the arguments. Use of VERBATIM is recommended as it enables correct behavior. When VERBATIM is not given the behavior is platform specific. In the future VERBATIM may be enabled by default. The only reason it is an option is to preserve compatibility with older CMake code.


If the output of the custom command is not actually created as a file on disk it should be marked as SYMBOLIC with SET_SOURCE_FILES_PROPERTIES.


The IMPLICIT_DEPENDS option requests scanning of implicit dependencies of an input file.  The language given specifies the programming language whose corresponding dependency scanner should be used.  Currently only C and CXX language scanners are supported. Dependencies discovered from the scanning are added to those of the custom command at build time.  Note that the IMPLICIT_DEPENDS option is currently supported only for Makefile generators and will be ignored by other generators.


If COMMAND specifies an executable target (created by ADD_EXECUTABLE) it will automatically be replaced by the location of the executable created at build time.  Additionally a target-level dependency will be added so that the executable target will be built before any target using this custom command.  However this does NOT add a file-level dependency that would cause the custom command to re-run whenever the executable is recompiled.


If DEPENDS specifies any target (created by an ADD_* command) a target-level dependency is created to make sure the target is built before any target using this custom command.  Additionally, if the target is an executable or library a file-level dependency is created to cause the custom command to re-run whenever the target is recompiled.


.TP
.B add_custom_target
Add a target with no output so it will always be built.

  add_custom_target(Name [ALL] [command1 [args1...]]
                    [COMMAND command2 [args2...] ...]
                    [DEPENDS depend depend depend ... ]
                    [WORKING_DIRECTORY dir]
                    [COMMENT comment] [VERBATIM])

Adds a target with the given name that executes the given commands. The target has no output file and is ALWAYS CONSIDERED OUT OF DATE even if the commands try to create a file with the name of the target. Use ADD_CUSTOM_COMMAND to generate a file with dependencies. By default nothing depends on the custom target. Use ADD_DEPENDENCIES to add dependencies to or from other targets. If the ALL option is specified it indicates that this target should be added to the default build target so that it will be run every time (the command cannot be called ALL). The command and arguments are optional and if not specified an empty target will be created. If WORKING_DIRECTORY is set, then the command will be run in that directory. If COMMENT is set, the value will be displayed as a message before the commands are executed at build time. Dependencies listed with the DEPENDS argument may reference files and outputs of custom commands created with ADD_CUSTOM_COMMAND.


If VERBATIM is given then all the arguments to the commands will be passed exactly as specified no matter the build tool used. Note that one level of escapes is still used by the CMake language processor before add_custom_target even sees the arguments. Use of VERBATIM is recommended as it enables correct behavior. When VERBATIM is not given the behavior is platform specific. In the future VERBATIM may be enabled by default. The only reason it is an option is to preserve compatibility with older CMake code.

.TP
.B add_definitions
Adds -D define flags to the compilation of source files.

  add_definitions(-DFOO -DBAR ...)

Adds flags to the compiler command line for sources in the current directory and below.  This command can be used to add any flags, but it was originally intended to add preprocessor definitions.  Flags beginning in -D or /D that look like preprocessor definitions are automatically added to the COMPILE_DEFINITIONS property for the current directory.  Definitions with non-trival values may be left in the set of flags instead of being converted for reasons of backwards compatibility.  See documentation of the directory, target, and source file COMPILE_DEFINITIONS properties for details on adding preprocessor definitions to specific scopes and configurations.

.TP
.B add_dependencies
Add a dependency between top-level targets.

  add_dependencies(target-name depend-target1
                   depend-target2 ...)

Make a top-level target depend on other top-level targets.  A top-level target is one created by ADD_EXECUTABLE, ADD_LIBRARY, or ADD_CUSTOM_TARGET.  Adding dependencies with this command can be used to make sure one target is built before another target.  See the DEPENDS option of ADD_CUSTOM_TARGET and ADD_CUSTOM_COMMAND for adding file-level dependencies in custom rules.  See the OBJECT_DEPENDS option in SET_SOURCE_FILES_PROPERTIES to add file-level dependencies to object files.

.TP
.B add_executable
Add an executable to the project using the specified source files.

  add_executable(<name> [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL]
                 source1 source2 ... sourceN)

Adds an executable target called <name> to be built from the source files listed in the command invocation.  The <name> corresponds to the logical target name and must be globally unique within a project.  The actual file name of the executable built is constructed based on conventions of the native platform (such as <name>.exe or just <name>).  


By default the executable file will be created in the build tree directory corresponding to the source tree directory in which the command was invoked.  See documentation of the RUNTIME_OUTPUT_DIRECTORY target property to change this location.  See documentation of the OUTPUT_NAME target property to change the <name> part of the final file name.  


If WIN32 is given the property WIN32_EXECUTABLE will be set on the target created.  See documentation of that target property for details.


If MACOSX_BUNDLE is given the corresponding property will be set on the created target.  See documentation of the MACOSX_BUNDLE target property for details.


If EXCLUDE_FROM_ALL is given the corresponding property will be set on the created target.  See documentation of the EXCLUDE_FROM_ALL target property for details.


The add_executable command can also create IMPORTED executable targets using this signature:


  add_executable(<name> IMPORTED)

An IMPORTED executable target references an executable file located outside the project.  No rules are generated to build it.  The target name has scope in the directory in which it is created and below.  It may be referenced like any target built within the project.  IMPORTED executables are useful for convenient reference from commands like add_custom_command.  Details about the imported executable are specified by setting properties whose names begin in "IMPORTED_".  The most important such property is IMPORTED_LOCATION (and its per-configuration version IMPORTED_LOCATION_<CONFIG>) which specifies the location of the main executable file on disk.  See documentation of the IMPORTED_* properties for more information.

.TP
.B add_library
Add a library to the project using the specified source files.

  add_library(<name> [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL]
              source1 source2 ... sourceN)

Adds a library target called <name> to be built from the source files listed in the command invocation.  The <name> corresponds to the logical target name and must be globally unique within a project.  The actual file name of the library built is constructed based on conventions of the native platform (such as lib<name>.a or <name>.lib).


STATIC, SHARED, or MODULE may be given to specify the type of library to be created.  STATIC libraries are archives of object files for use when linking other targets.  SHARED libraries are linked dynamically and loaded at runtime.  MODULE libraries are plugins that are not linked into other targets but may be loaded dynamically at runtime using dlopen-like functionality.  If no type is given explicitly the type is STATIC or SHARED based on whether the current value of the variable BUILD_SHARED_LIBS is true.


By default the library file will be created in the build tree directory corresponding to the source tree directory in which the command was invoked.  See documentation of the ARCHIVE_OUTPUT_DIRECTORY, LIBRARY_OUTPUT_DIRECTORY, and RUNTIME_OUTPUT_DIRECTORY target properties to change this location.  See documentation of the OUTPUT_NAME target property to change the <name> part of the final file name.  


If EXCLUDE_FROM_ALL is given the corresponding property will be set on the created target.  See documentation of the EXCLUDE_FROM_ALL target property for details.


The add_library command can also create IMPORTED library targets using this signature:


  add_library(<name> <SHARED|STATIC|MODULE> IMPORTED)

An IMPORTED library target references a library file located outside the project.  No rules are generated to build it.  The target name has scope in the directory in which it is created and below.  It may be referenced like any target built within the project.  IMPORTED libraries are useful for convenient reference from commands like target_link_libraries.  Details about the imported library are specified by setting properties whose names begin in "IMPORTED_".  The most important such property is IMPORTED_LOCATION (and its per-configuration version IMPORTED_LOCATION_<CONFIG>) which specifies the location of the main library file on disk.  See documentation of the IMPORTED_* properties for more information.

.TP
.B add_subdirectory
Add a subdirectory to the build.

  add_subdirectory(source_dir [binary_dir] 
                   [EXCLUDE_FROM_ALL])

Add a subdirectory to the build. The source_dir specifies the directory in which the source CmakeLists.txt and code files are located. If it is a relative path it will be evaluated with respect to the current directory (the typical usage), but it may also be an absolute path. The binary_dir specifies the directory in which to place the output files. If it is a relative path it will be evaluated with respect to the current output directory, but it may also be an absolute path. If binary_dir is not specified, the value of source_dir, before expanding any relative path, will be used (the typical usage). The CMakeLists.txt file in the specified source directory will be processed immediately by CMake before processing in the current input file continues beyond this command.


If the EXCLUDE_FROM_ALL argument is provided then this subdirectory will not be included in build by default. Users will have to explicitly start a build in the generated output directory. This is useful for having cmake create a build system for a set of examples in a project. One would want cmake to generate a single build system for all the examples, but one may not want the targets to show up in the main build system.

.TP
.B add_test
Add a test to the project with the specified arguments.

  add_test(testname Exename arg1 arg2 ...)

If the ENABLE_TESTING command has been run, this command adds a test target to the current directory. If ENABLE_TESTING has not been run, this command does nothing.  The tests are run by the testing subsystem by executing Exename with the specified arguments.  Exename can be either an executable built by this project or an arbitrary executable on the system (like tclsh).  The test will be run with the current working directory set to the CMakeList.txt files corresponding directory in the binary tree.

.TP
.B aux_source_directory
Find all source files in a directory.

  aux_source_directory(<dir> <variable>)

Collects the names of all the source files in the specified directory and stores the list in the <variable> provided.  This command is intended to be used by projects that use explicit template instantiation.  Template instantiation files can be stored in a "Templates" subdirectory and collected automatically using this command to avoid manually listing all instantiations.


It is tempting to use this command to avoid writing the list of source files for a library or executable target.  While this seems to work, there is no way for CMake to generate a build system that knows when a new source file has been added.  Normally the generated build system knows when it needs to rerun CMake because the CMakeLists.txt file is modified to add a new source.  When the source is just added to the directory without modifying this file, one would have to manually rerun CMake to generate a build system incorporating the new file.

.TP
.B break
Break from an enclosing foreach or while loop.

  break()

Breaks from an enclosing foreach loop or while loop

.TP
.B build_command
Get the command line that will build this project.

  build_command(<variable> <makecommand>)

Sets the given <variable> to a string containing the command that will build this project from the root of the build tree using the build tool given by <makecommand>.  <makecommand> should be msdev, nmake, make or one of the end user build tools.  This is useful for configuring testing systems.

.TP
.B cmake_minimum_required
Set the minimum required version of cmake for a project.

  cmake_minimum_required(VERSION major[.minor[.patch]]
                         [FATAL_ERROR])

If the current version of CMake is lower than that required it will stop processing the project and report an error.  When a version higher than 2.4 is specified the command implicitly invokes


  cmake_policy(VERSION major[.minor[.patch]])

which sets the cmake policy version level to the version specified.  When version 2.4 or lower is given the command implicitly invokes


  cmake_policy(VERSION 2.4)

which enables compatibility features for CMake 2.4 and lower.


The FATAL_ERROR option is accepted but ignored.  It is left from CMake versions 2.4 and lower in which failure to meet the minimum version was a warning by default.

.TP
.B cmake_policy
Manage CMake Policy settings.

As CMake evolves it is sometimes necessary to change existing behavior in order to fix bugs or improve implementations of existing features.  The CMake Policy mechanism is designed to help keep existing projects building as new versions of CMake introduce changes in behavior.  Each new policy (behavioral change) is given an identifier of the form "CMP<NNNN>" where "<NNNN>" is an integer index.  Documentation associated with each policy describes the OLD and NEW behavior and the reason the policy was introduced.  Projects may set each policy to select the desired behavior.  When CMake needs to know which behavior to use it checks for a setting specified by the project.  If no setting is available the OLD behavior is assumed and a warning is produced requesting that the policy be set.


The cmake_policy command is used to set policies to OLD or NEW behavior.  While setting policies individually is supported, we encourage projects to set policies based on CMake versions.


  cmake_policy(VERSION major.minor[.patch])

Specify that the current CMake list file is written for the given version of CMake.  All policies introduced in the specified version or earlier will be set to use NEW behavior.  All policies introduced after the specified version will be reset to use OLD behavior with a warning.  This effectively requests behavior preferred as of a given CMake version and tells newer CMake versions to warn about their new policies.  The policy version specified must be at least 2.4 or the command will report an error.  In order to get compatibility features supporting versions earlier than 2.4 see documentation of policy CMP0001.


  cmake_policy(SET CMP<NNNN> NEW)
  cmake_policy(SET CMP<NNNN> OLD)

Tell CMake to use the OLD or NEW behavior for a given policy.  Projects depending on the old behavior of a given policy may silence a policy warning by setting the policy state to OLD.  Alternatively one may fix the project to work with the new behavior and set the policy state to NEW.


  cmake_policy(PUSH)
  cmake_policy(POP)

Push and pop the current policy setting state on a stack.  Each PUSH must have a matching POP.  This is useful when mixing multiple projects, subprojects, and files included from external projects that may each have been written for a different version of CMake.  Each subdirectory entered by the project automatically pushes a new level on the stack to isolate the subdirectories from their parents.

.TP
.B configure_file
Copy a file to another location and modify its contents.

  configure_file(InputFile OutputFile
                 [COPYONLY] [ESCAPE_QUOTES] [@ONLY])

The Input and Output files have to have full paths.  This command replaces any variables in the input file referenced as ${VAR} or @VAR@ with their values as determined by CMake.  If a variable is not defined, it will be replaced with nothing.  If COPYONLY is specified, then no variable expansion will take place.  If ESCAPE_QUOTES is specified then any substituted quotes will be C-style escaped.  The file will be configured with the current values of CMake variables. If @ONLY is specified, only variables of the form @VAR@ will be replaces and ${VAR} will be ignored.  This is useful for configuring scripts that use ${VAR}. Any occurrences of #cmakedefine VAR will be replaced with either #define VAR or /* #undef VAR */ depending on the setting of VAR in CMake

.TP
.B create_test_sourcelist
Create a test driver and source list for building test programs.

  create_test_sourcelist(sourceListName driverName
                         test1 test2 test3
                         EXTRA_INCLUDE include.h
                         FUNCTION function)

A test driver is a program that links together many small tests into a single executable.  This is useful when building static executables with large libraries to shrink the total required size.  The list of source files needed to build the test driver will be in sourceListName.  DriverName is the name of the test driver program.  The rest of the arguments consist of a list of test source files, can be semicolon separated.  Each test source file should have a function in it that is the same name as the file with no extension (foo.cxx should have int foo(int, char*[]);) DriverName will be able to call each of the tests by name on the command line. If EXTRA_INCLUDE is specified, then the next argument is included into the generated file. If FUNCTION is specified, then the next argument is taken as a function name that is passed a pointer to ac and av.  This can be used to add extra command line processing to each test. The cmake variable CMAKE_TESTDRIVER_BEFORE_TESTMAIN can be set to have code that will be placed directly before calling the test main function.   CMAKE_TESTDRIVER_AFTER_TESTMAIN can be set to have code that will be placed directly after the call to the test main function.

.TP
.B define_property
Define and document custom properties.

  define_property(<GLOBAL | DIRECTORY | TARGET | SOURCE |
                   TEST | VARIABLE | CACHED_VARIABLE>
                   PROPERTY <name> [INHERITED]
                   BRIEF_DOCS <brief-doc>
                   FULL_DOCS <full-doc>)

Define one property in a scope for use with the set_property and get_property commands.  This is primarily useful to associate documentation with property names that may be retrieved with the get_property command.  The first argument determines the kind of scope in which the property should be used.  It must be one of the following:


  GLOBAL    = associated with the global namespace
  DIRECTORY = associated with one directory
  TARGET    = associated with one target
  SOURCE    = associated with one source file
  TEST      = associated with a test named with add_test command
  VARIABLE  = documents a CMake language variable
  CACHED_VARIABLE = documents a CMake cache variable

Note that unlike set_property and get_property no actual scope needs to be given; only the kind of scope is important.


The required PROPERTY option is immediately followed by the name of the property being defined.


If the INHERITED option then the get_property command will chain up to the next higher scope when the requested property is not set in the scope given to the command.  DIRECTORY scope chains to GLOBAL.  TARGET, SOURCE, and TEST chain to DIRECTORY.


The BRIEF_DOCS and FULL_DOCS options are followed by strings to be associated with the property as its brief and full documentation.  Corresponding options to the get_property command will retrieve the documentation.

.TP
.B else
Starts the else portion of an if block.

  else(expression)

See the if command.

.TP
.B elseif
Starts the elseif portion of an if block.

  elseif(expression)

See the if command.

.TP
.B enable_language
Enable a language (CXX/C/Fortran/etc)

  enable_language(languageName [OPTIONAL] )

This command enables support for the named language in CMake. This is the same as the project command but does not create any of the extra variables that are created by the project command. Example languages are CXX, C, Fortran.


If OPTIONAL is used, use the CMAKE_<languageName>_COMPILER_WORKS variable to check whether the language has been enabled successfully.

.TP
.B enable_testing
Enable testing for current directory and below.

  enable_testing()

Enables testing for this directory and below.  See also the add_test command.  Note that ctest expects to find a test file in the build directory root.  Therefore, this command should be in the source directory root.

.TP
.B endforeach
Ends a list of commands in a FOREACH block.

  endforeach(expression)

See the FOREACH command.

.TP
.B endfunction
Ends a list of commands in a function block.

  endfunction(expression)

See the function command.

.TP
.B endif
Ends a list of commands in an if block.

  endif(expression)

See the if command.

.TP
.B endmacro
Ends a list of commands in a macro block.

  endmacro(expression)

See the macro command.

.TP
.B endwhile
Ends a list of commands in a while block.

  endwhile(expression)

See the while command.

.TP
.B execute_process
Execute one or more child processes.

  execute_process(COMMAND <cmd1> [args1...]]
                  [COMMAND <cmd2> [args2...] [...]]
                  [WORKING_DIRECTORY <directory>]
                  [TIMEOUT <seconds>]
                  [RESULT_VARIABLE <variable>]
                  [OUTPUT_VARIABLE <variable>]
                  [ERROR_VARIABLE <variable>]
                  [INPUT_FILE <file>]
                  [OUTPUT_FILE <file>]
                  [ERROR_FILE <file>]
                  [OUTPUT_QUIET]
                  [ERROR_QUIET]
                  [OUTPUT_STRIP_TRAILING_WHITESPACE]
                  [ERROR_STRIP_TRAILING_WHITESPACE])

Runs the given sequence of one or more commands with the standard output of each process piped to the standard input of the next.  A single standard error pipe is used for all processes.  If WORKING_DIRECTORY is given the named directory will be set as the current working directory of the child processes.  If TIMEOUT is given the child processes will be terminated if they do not finish in the specified number of seconds (fractions are allowed).  If RESULT_VARIABLE is given the variable will be set to contain the result of running the processes.  This will be an integer return code from the last child or a string describing an error condition.  If OUTPUT_VARIABLE or ERROR_VARIABLE are given the variable named will be set with the contents of the standard output and standard error pipes respectively.  If the same variable is named for both pipes their output will be merged in the order produced.  If INPUT_FILE, OUTPUT_FILE, or ERROR_FILE is given the file named will be attached to the standard input of the first process, standard output of the last process, or standard error of all processes respectively.  If OUTPUT_QUIET or ERROR_QUIET is given then the standard output or standard error results will be quietly ignored.  If more than one OUTPUT_* or ERROR_* option is given for the same pipe the precedence is not specified.  If no OUTPUT_* or ERROR_* options are given the output will be shared with the corresponding pipes of the CMake process itself.


The execute_process command is a newer more powerful version of exec_program, but the old command has been kept for compatibility.

.TP
.B export
Export targets from the build tree for use by outside projects.

  export(TARGETS [target1 [target2 [...]]] [NAMESPACE <namespace>]
         [APPEND] FILE <filename>)

Create a file <filename> that may be included by outside projects to import targets from the current project's build tree.  This is useful during cross-compiling to build utility executables that can run on the host platform in one project and then import them into another project being compiled for the target platform.  If the NAMESPACE option is given the <namespace> string will be prepended to all target names written to the file.  If the APPEND option is given the generated code will be appended to the file instead of overwriting it.  If a library target is included in the export but a target to which it links is not included the behavior is unspecified.


The file created by this command is specific to the build tree and should never be installed.  See the install(EXPORT) command to export targets from an installation tree.

.TP
.B file
File manipulation command.

  file(WRITE filename "message to write"... )
  file(APPEND filename "message to write"... )
  file(READ filename variable [LIMIT numBytes] [OFFSET offset] [HEX])
  file(STRINGS filename variable [LIMIT_COUNT num]
       [LIMIT_INPUT numBytes] [LIMIT_OUTPUT numBytes]
       [LENGTH_MINIMUM numBytes] [LENGTH_MAXIMUM numBytes]
       [NEWLINE_CONSUME] [REGEX regex]
       [NO_HEX_CONVERSION])
  file(GLOB variable [RELATIVE path] [globbing expressions]...)
  file(GLOB_RECURSE variable [RELATIVE path] 
       [globbing expressions]...)
  file(REMOVE [file1 ...])
  file(REMOVE_RECURSE [file1 ...])
  file(MAKE_DIRECTORY [directory1 directory2 ...])
  file(RELATIVE_PATH variable directory file)
  file(TO_CMAKE_PATH path result)
  file(TO_NATIVE_PATH path result)
  file(DOWNLOAD url file [TIMEOUT timeout] [STATUS status] [LOG log])

WRITE will write a message into a file called 'filename'. It overwrites the file if it already exists, and creates the file if it does not exist.


APPEND will write a message into a file same as WRITE, except it will append it to the end of the file


READ will read the content of a file and store it into the variable. It will start at the given offset and read up to numBytes. If the argument HEX is given, the binary data will be converted to hexadecimal representation and this will be stored in the variable.


STRINGS will parse a list of ASCII strings from a file and store it in a variable. Binary data in the file are ignored. Carriage return (CR) characters are ignored. It works also for Intel Hex and Motorola S-record files, which are automatically converted to binary format when reading them. Disable this using NO_HEX_CONVERSION.


LIMIT_COUNT sets the maximum number of strings to return. LIMIT_INPUT sets the maximum number of bytes to read from the input file. LIMIT_OUTPUT sets the maximum number of bytes to store in the output variable. LENGTH_MINIMUM sets the minimum length of a string to return. Shorter strings are ignored. LENGTH_MAXIMUM sets the maximum length of a string to return.  Longer strings are split into strings no longer than the maximum length. NEWLINE_CONSUME allows newlines to be included in strings instead of terminating them.


REGEX specifies a regular expression that a string must match to be returned. Typical usage 


  file(STRINGS myfile.txt myfile)

stores a list in the variable "myfile" in which each item is a line from the input file.


GLOB will generate a list of all files that match the globbing expressions and store it into the variable. Globbing expressions are similar to regular expressions, but much simpler. If RELATIVE flag is specified for an expression, the results will be returned as a relative path to the given path.


Examples of globbing expressions include:


   *.cxx      - match all files with extension cxx
   *.vt?      - match all files with extension vta,...,vtz
   f[3-5].txt - match files f3.txt, f4.txt, f5.txt

GLOB_RECURSE will generate similar list as the regular GLOB, except it will traverse all the subdirectories of the matched directory and match the files.


Examples of recursive globbing include:


   /dir/*.py  - match all python files in /dir and subdirectories

MAKE_DIRECTORY will create the given directories, also if their parent directories don't exist yet


REMOVE will remove the given files, also in subdirectories


REMOVE_RECURSE will remove the given files and directories, also non-empty directories


RELATIVE_PATH will determine relative path from directory to the given file.


TO_CMAKE_PATH will convert path into a cmake style path with unix /.  The input can be a single path or a system path like "$ENV{PATH}".  Note the double quotes around the ENV call TO_CMAKE_PATH only takes  one argument.


TO_NATIVE_PATH works just like TO_CMAKE_PATH, but will convert from  a cmake style path into the native path style \\ for windows and / for UNIX.


DOWNLOAD will download the givin URL to the given file. If LOG var is specified a log of the download will be put in var. If STATUS var is specified the status of the operation will be put in var. The status is returned in a list of length 2. The first element is the numeric return value for the operation, and the second element is a string value for the error. A 0 numeric error means no error in the operation. If TIMEOUT time is specified, the operation will timeout after time seconds, time can be specified as a float.


.TP
.B find_file
Find the full path to a file.

   find_path(<VAR> name1 [path1 path2 ...])

This is the short-hand signature for the command that is sufficient in many cases.  It is the same as find_path(<VAR> name1 [PATHS path1 path2 ...])


   find_path(
             <VAR>
             name | NAMES name1 [name2 ...]
             [PATHS path1 [path2 ... ENV var]]
             [PATH_SUFFIXES suffix1 [suffix2 ...]]
             [DOC "cache documentation string"]
             [NO_DEFAULT_PATH]
             [NO_CMAKE_ENVIRONMENT_PATH]
             [NO_CMAKE_PATH]
             [NO_SYSTEM_ENVIRONMENT_PATH]
             [NO_CMAKE_SYSTEM_PATH]
             [CMAKE_FIND_ROOT_PATH_BOTH |
              ONLY_CMAKE_FIND_ROOT_PATH |
              NO_CMAKE_FIND_ROOT_PATH]
            )

This command is used to find a full path to named file. A cache entry named by <VAR> is created to store the result of this command.  If the full path to a file is found the result is stored in the variable and the search will not be repeated unless the variable is cleared.  If nothing is found, the result will be <VAR>-NOTFOUND, and the search will be attempted again the next time find_path is invoked with the same variable.  The name of the full path to a file that is searched for is specified by the names listed after the NAMES argument.   Additional search locations can be specified after the PATHS argument.  If ENV var is found in the PATHS section the environment variable var will be read and converted from a system environment variable to a cmake style list of paths.  For example ENV PATH would be a way to list the system path variable. The argument after DOC will be used for the documentation string in the cache.  PATH_SUFFIXES can be used to give sub directories that will be appended to the search paths.


If NO_DEFAULT_PATH is specified, then no additional paths are added to the search. If NO_DEFAULT_PATH is not specified, the search process is as follows:


1. Search cmake specific environment variables.  This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.


   <prefix>/include for each <prefix> in CMAKE_PREFIX_PATH
   CMAKE_INCLUDE_PATH
   CMAKE_FRAMEWORK_PATH

2. Search cmake variables with the same names as the cmake specific environment variables.  These are intended to be used on the command line with a -DVAR=value.  This can be skipped if NO_CMAKE_PATH is passed.


   <prefix>/include for each <prefix> in CMAKE_PREFIX_PATH
   CMAKE_INCLUDE_PATH
   CMAKE_FRAMEWORK_PATH

3. Search the standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH is an argument.


   PATH
   INCLUDE

4. Search cmake variables defined in the Platform files for the current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.


   <prefix>/include for each <prefix> in CMAKE_SYSTEM_PREFIX_PATH
   CMAKE_SYSTEM_INCLUDE_PATH
   CMAKE_SYSTEM_FRAMEWORK_PATH

5. Search the paths specified after PATHS or in the short-hand version of the command.


On Darwin or systems supporting OS X Frameworks, the cmake variable    CMAKE_FIND_FRAMEWORK can be set to empty or one of the following:


   "FIRST"  - Try to find frameworks before standard
              libraries or headers. This is the default on Darwin.
   "LAST"   - Try to find frameworks after standard
              libraries or headers.
   "ONLY"   - Only try to find frameworks.
   "NEVER". - Never try to find frameworks.

On Darwin or systems supporting OS X Application Bundles, the cmake variable CMAKE_FIND_APPBUNDLE can be set to empty or one of the following:


   "FIRST"  - Try to find application bundles before standard
              programs. This is the default on Darwin.
   "LAST"   - Try to find application bundles after standard
              programs.
   "ONLY"   - Only try to find application bundles.
   "NEVER". - Never try to find application bundles.

The CMake variable CMAKE_FIND_ROOT_PATH specifies one or more directories to be prepended to all other search directories. This effectively "re-roots" the entire search under given locations. By default it is empty. It is especially useful when cross-compiling to point to the root directory of the target environment and CMake will search there too. By default at first the directories listed in CMAKE_FIND_ROOT_PATH and then the non-rooted directories will be searched. The default behavior can be adjusted by setting CMAKE_FIND_ROOT_PATH_MODE_INCLUDE.  This behavior can be manually overridden on a per-call basis. By using CMAKE_FIND_ROOT_PATH_BOTH the search order will be as described above. If NO_CMAKE_FIND_ROOT_PATH is used then CMAKE_FIND_ROOT_PATH will not be used. If ONLY_CMAKE_FIND_ROOT_PATH is used then only the re-rooted directories will be searched.


The reason the paths listed in the call to the command are searched last is that most users of CMake would expect things to be found first in the locations specified by their environment.  Projects may override this behavior by simply calling the command twice:


   find_path(<VAR> NAMES name PATHS paths... NO_DEFAULT_PATH)
   find_path(<VAR> NAMES name)

Once one of these calls succeeds the result variable will be set and stored in the cache so that neither call will search again.

.TP
.B find_library
Find a library.

   find_library(<VAR> name1 [path1 path2 ...])

This is the short-hand signature for the command that is sufficient in many cases.  It is the same as find_library(<VAR> name1 [PATHS path1 path2 ...])


   find_library(
             <VAR>
             name | NAMES name1 [name2 ...]
             [PATHS path1 [path2 ... ENV var]]
             [PATH_SUFFIXES suffix1 [suffix2 ...]]
             [DOC "cache documentation string"]
             [NO_DEFAULT_PATH]
             [NO_CMAKE_ENVIRONMENT_PATH]
             [NO_CMAKE_PATH]
             [NO_SYSTEM_ENVIRONMENT_PATH]
             [NO_CMAKE_SYSTEM_PATH]
             [CMAKE_FIND_ROOT_PATH_BOTH |
              ONLY_CMAKE_FIND_ROOT_PATH |
              NO_CMAKE_FIND_ROOT_PATH]
            )

This command is used to find a library. A cache entry named by <VAR> is created to store the result of this command.  If the library is found the result is stored in the variable and the search will not be repeated unless the variable is cleared.  If nothing is found, the result will be <VAR>-NOTFOUND, and the search will be attempted again the next time find_library is invoked with the same variable.  The name of the library that is searched for is specified by the names listed after the NAMES argument.   Additional search locations can be specified after the PATHS argument.  If ENV var is found in the PATHS section the environment variable var will be read and converted from a system environment variable to a cmake style list of paths.  For example ENV PATH would be a way to list the system path variable. The argument after DOC will be used for the documentation string in the cache.  PATH_SUFFIXES can be used to give sub directories that will be appended to the search paths.


If NO_DEFAULT_PATH is specified, then no additional paths are added to the search. If NO_DEFAULT_PATH is not specified, the search process is as follows:


1. Search cmake specific environment variables.  This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.


   <prefix>/lib for each <prefix> in CMAKE_PREFIX_PATH
   CMAKE_LIBRARY_PATH
   CMAKE_FRAMEWORK_PATH

2. Search cmake variables with the same names as the cmake specific environment variables.  These are intended to be used on the command line with a -DVAR=value.  This can be skipped if NO_CMAKE_PATH is passed.


   <prefix>/lib for each <prefix> in CMAKE_PREFIX_PATH
   CMAKE_LIBRARY_PATH
   CMAKE_FRAMEWORK_PATH

3. Search the standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH is an argument.


   PATH
   LIB

4. Search cmake variables defined in the Platform files for the current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.


   <prefix>/lib for each <prefix> in CMAKE_SYSTEM_PREFIX_PATH
   CMAKE_SYSTEM_LIBRARY_PATH
   CMAKE_SYSTEM_FRAMEWORK_PATH

5. Search the paths specified after PATHS or in the short-hand version of the command.


On Darwin or systems supporting OS X Frameworks, the cmake variable    CMAKE_FIND_FRAMEWORK can be set to empty or one of the following:


   "FIRST"  - Try to find frameworks before standard
              libraries or headers. This is the default on Darwin.
   "LAST"   - Try to find frameworks after standard
              libraries or headers.
   "ONLY"   - Only try to find frameworks.
   "NEVER". - Never try to find frameworks.

On Darwin or systems supporting OS X Application Bundles, the cmake variable CMAKE_FIND_APPBUNDLE can be set to empty or one of the following:


   "FIRST"  - Try to find application bundles before standard
              programs. This is the default on Darwin.
   "LAST"   - Try to find application bundles after standard
              programs.
   "ONLY"   - Only try to find application bundles.
   "NEVER". - Never try to find application bundles.

The CMake variable CMAKE_FIND_ROOT_PATH specifies one or more directories to be prepended to all other search directories. This effectively "re-roots" the entire search under given locations. By default it is empty. It is especially useful when cross-compiling to point to the root directory of the target environment and CMake will search there too. By default at first the directories listed in CMAKE_FIND_ROOT_PATH and then the non-rooted directories will be searched. The default behavior can be adjusted by setting CMAKE_FIND_ROOT_PATH_MODE_LIBRARY.  This behavior can be manually overridden on a per-call basis. By using CMAKE_FIND_ROOT_PATH_BOTH the search order will be as described above. If NO_CMAKE_FIND_ROOT_PATH is used then CMAKE_FIND_ROOT_PATH will not be used. If ONLY_CMAKE_FIND_ROOT_PATH is used then only the re-rooted directories will be searched.


The reason the paths listed in the call to the command are searched last is that most users of CMake would expect things to be found first in the locations specified by their environment.  Projects may override this behavior by simply calling the command twice:


   find_library(<VAR> NAMES name PATHS paths... NO_DEFAULT_PATH)
   find_library(<VAR> NAMES name)

Once one of these calls succeeds the result variable will be set and stored in the cache so that neither call will search again.


If the library found is a framework, then VAR will be set to the full path to the framework <fullPath>/A.framework. When a full path to a framework is used as a library, CMake will use a -framework A, and a -F<fullPath> to link the framework to the target. 

.TP
.B find_package
Load settings for an external project.

  find_package(<package> [major[.minor[.patch]]] [EXACT] [QUIET]
               [[REQUIRED|COMPONENTS] [components...]])

Finds and loads settings from an external project.  <package>_FOUND will be set to indicate whether the package was found.  When the package is found package-specific information is provided through variables documented by the package itself.  The QUIET option disables messages if the package cannot be found.  The REQUIRED option stops processing with an error message if the package cannot be found.  A package-specific list of components may be listed after the REQUIRED option or after the COMPONENTS option if no REQUIRED option is given.  The "[major[.minor[.patch]]]" version argument specifies a desired version with which the package found should be compatible.  The EXACT option requests that the version be matched exactly.  Version support is currently provided only on a package-by-package basis (details below).


User code should generally look for packages using the above simple signature.  The remainder of this command documentation specifies the full command signature and details of the search process.  Project maintainers wishing to provide a package to be found by this command are encouraged to read on.


The command has two modes by which it searches for packages: "Module" mode and "Config" mode.  Module mode is available when the command is invoked with the above reduced signature.  CMake searches for a file called "Find<package>.cmake" in the CMAKE_MODULE_PATH followed by the CMake installation.  If the file is found, it is read and processed by CMake.  It is responsible for finding the package, checking the version, and producing any needed messages.  Many find-modules provide limited or no support for versioning; check the module documentation.  If no module is found the command proceeds to Config mode.


The complete Config mode command signature is:


  find_package(<package> [major[.minor[.patch]]] [EXACT] [QUIET]
               [[REQUIRED|COMPONENTS] [components...]] [NO_MODULE]
               [NAMES name1 [name2 ...]]
               [CONFIGS config1 [config2 ...]]
               [PATHS path1 [path2 ... ]]
               [PATH_SUFFIXES suffix1 [suffix2 ...]]
               [NO_DEFAULT_PATH]
               [NO_CMAKE_ENVIRONMENT_PATH]
               [NO_CMAKE_PATH]
               [NO_SYSTEM_ENVIRONMENT_PATH]
               [NO_CMAKE_BUILDS_PATH]
               [NO_CMAKE_SYSTEM_PATH]
               [CMAKE_FIND_ROOT_PATH_BOTH |
                ONLY_CMAKE_FIND_ROOT_PATH |
                NO_CMAKE_FIND_ROOT_PATH])

The NO_MODULE option may be used to skip Module mode explicitly.  It is also implied by use of options not specified in the reduced signature.  


Config mode attempts to locate a configuration file provided by the package to be found.  A cache entry called <package>_DIR is created to hold the directory containing the file.  By default the command searches for a package with the name <package>.  If the NAMES option is given the names following it are used instead of <package>.  The command searches for a file called "<name>Config.cmake" or "<lower-case-name>-config.cmake" for each name specified.  A replacement set of possible configuration file names may be given using the CONFIGS option.  The search procedure is specified below.  Once found, the configuration file is read and processed by CMake.  Since the file is provided by the package it already knows the location of package contents.  The full path to the configuration file is stored in the cmake variable <package>_CONFIG.


If the package configuration file cannot be found CMake will generate an error describing the problem unless the QUIET argument is specified.  If REQUIRED is specified and the package is not found a fatal error is generated and the configure step stops executing.  If <package>_DIR has been set to a directory not containing a configuration file a fatal error is always generated because user intervention is required.


When the "[major[.minor[.patch]]]" version argument is specified Config mode will only find a version of the package that claims compatibility with the requested version.  If the EXACT option is given only a version of the package claiming an exact match of the requested version may be found.  CMake does not establish any convention for the meaning of version numbers.  Package version numbers are checked by "version" files provided by the packages themselves.  For a candidate package confguration file "<config-file>.cmake" the corresponding version file is located next to it and named either "<config-file>-version.cmake" or "<config-file>Version.cmake".  If no such version file is available then the configuration file is assumed to not be compatible with any requested version.  When a version file is found it is loaded to check the requested version number.  The version file is loaded in a nested scope in which the following variables have been defined:


  PACKAGE_FIND_NAME          = the <package> name
  PACKAGE_FIND_VERSION       = full requested version string
  PACKAGE_FIND_VERSION_MAJOR = requested major version, if any
  PACKAGE_FIND_VERSION_MINOR = requested minor version, if any
  PACKAGE_FIND_VERSION_PATCH = requested patch version, if any

The version file checks whether it satisfies the requested version and sets these variables:


  PACKAGE_VERSION            = package version (major[.minor[.patch]])
  PACKAGE_VERSION_EXACT      = true if version is exact match
  PACKAGE_VERSION_COMPATIBLE = true if version is compatible

These variables are checked by the find_package command to determine whether the configuration file provides an acceptable version.  They are not available after the find_package call returns.  If the version is acceptable the following variables are set:


  <package>_VERSION       = package version (major[.minor[.patch]])
  <package>_VERSION_MAJOR = major from major[.minor[.patch]], if any
  <package>_VERSION_MINOR = minor from major[.minor[.patch]], if any
  <package>_VERSION_PATCH = patch from major[.minor[.patch]], if any

and the corresponding package configuration file is loaded.  When multiple package configuration files are available whose version files claim compatibility with the version requested it is unspecified which one is chosen.  No attempt is made to choose a highest or closest version number.


Config mode provides an elaborate interface and search procedure.  Much of the interface is provided for completeness and for use internally by find-modules loaded by Module mode.  Most user code should simply call


  find_package(<package> [major[.minor]] [EXACT] [REQUIRED|QUIET])

in order to find a package.  Package maintainers providing CMake package configuration files are encouraged to name and install them such that the procedure outlined below will find them without requiring use of additional options.


CMake constructs a set of possible installation prefixes for the package.  Under each prefix several directories are searched for a configuration file.  The tables below show the directories searched.  Each entry is meant for installation trees following Windows (W), UNIX (U), or Apple (A) conventions.


  <prefix>/                                               (W)
  <prefix>/(cmake|CMake)/                                 (W)
  <prefix>/(share|lib)/<name>*/                           (U)
  <prefix>/(share|lib)/<name>*/(cmake|CMake)/             (U)

On systems supporting OS X Frameworks and Application Bundles the following directories are searched for frameworks or bundles containing a configuration file:


  <prefix>/<name>.framework/Resources/                    (A)
  <prefix>/<name>.framework/Resources/CMake/              (A)
  <prefix>/<name>.framework/Versions/*/Resources/         (A)
  <prefix>/<name>.framework/Versions/*/Resources/CMake/   (A)
  <prefix>/<name>.app/Contents/Resources/                 (A)
  <prefix>/<name>.app/Contents/Resources/CMake/           (A)

In all cases the <name> is treated as case-insensitive and corresponds to any of the names specified (<package> or names given by NAMES).  If PATH_SUFFIXES is specified the suffixes are appended to each (W) or (U) directory entry one-by-one.


This set of directories is intended to work in cooperation with projects that provide configuration files in their installation trees.  Directories above marked with (W) are intended for installations on Windows where the prefix may point at the top of an application's installation directory.  Those marked with (U) are intended for installations on UNIX platforms where the prefix is shared by multiple packages.  This is merely a convention, so all (W) and (U) directories are still searched on all platforms.  Directories marked with (A) are intended for installations on Apple platforms.  The cmake variables CMAKE_FIND_FRAMEWORK and CMAKE_FIND_APPBUNDLE determine the order of preference as specified below.


The set of installation prefixes is constructed using the following steps.  If NO_DEFAULT_PATH is specified steps 1-5 are skipped.


1. Search cmake specific environment variables.  This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.


   CMAKE_PREFIX_PATH
   CMAKE_FRAMEWORK_PATH
   CMAKE_APPBUNDLE_PATH

2. Search cmake variables with the same names as the cmake specific environment variables.  These are intended to be used on the command line with a -DVAR=value.  This can be skipped if NO_CMAKE_PATH is passed.


   CMAKE_PREFIX_PATH
   CMAKE_FRAMEWORK_PATH
   CMAKE_APPBUNDLE_PATH

3. Search the standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH is passed.  Path entries ending in "/bin" or "/sbin" are automatically converted to their parent directories.


   PATH

4. Search project build trees recently configured in a CMake GUI.  This can be skipped if NO_CMAKE_BUILDS_PATH is passed.  It is intended for the case when a user is building multiple dependent projects one after another.


5. Search cmake variables defined in the Platform files for the current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.


   CMAKE_SYSTEM_PREFIX_PATH
   CMAKE_SYSTEM_FRAMEWORK_PATH
   CMAKE_SYSTEM_APPBUNDLE_PATH

6. Search paths specified by the PATHS option.


On Darwin or systems supporting OS X Frameworks, the cmake variable    CMAKE_FIND_FRAMEWORK can be set to empty or one of the following:


   "FIRST"  - Try to find frameworks before standard
              libraries or headers. This is the default on Darwin.
   "LAST"   - Try to find frameworks after standard
              libraries or headers.
   "ONLY"   - Only try to find frameworks.
   "NEVER". - Never try to find frameworks.

On Darwin or systems supporting OS X Application Bundles, the cmake variable CMAKE_FIND_APPBUNDLE can be set to empty or one of the following:


   "FIRST"  - Try to find application bundles before standard
              programs. This is the default on Darwin.
   "LAST"   - Try to find application bundles after standard
              programs.
   "ONLY"   - Only try to find application bundles.
   "NEVER". - Never try to find application bundles.

The CMake variable CMAKE_FIND_ROOT_PATH specifies one or more directories to be prepended to all other search directories. This effectively "re-roots" the entire search under given locations. By default it is empty. It is especially useful when cross-compiling to point to the root directory of the target environment and CMake will search there too. By default at first the directories listed in CMAKE_FIND_ROOT_PATH and then the non-rooted directories will be searched. The default behavior can be adjusted by setting CMAKE_FIND_ROOT_PATH_MODE_PACKAGE.  This behavior can be manually overridden on a per-call basis. By using CMAKE_FIND_ROOT_PATH_BOTH the search order will be as described above. If NO_CMAKE_FIND_ROOT_PATH is used then CMAKE_FIND_ROOT_PATH will not be used. If ONLY_CMAKE_FIND_ROOT_PATH is used then only the re-rooted directories will be searched.


The reason the paths listed in the call to the command are searched last is that most users of CMake would expect things to be found first in the locations specified by their environment.  Projects may override this behavior by simply calling the command twice:


   find_package(<package> PATHS paths... NO_DEFAULT_PATH)
   find_package(<package>)

Once one of these calls succeeds the result variable will be set and stored in the cache so that neither call will search again.

.TP
.B find_path
Find the directory containing a file.

   find_path(<VAR> name1 [path1 path2 ...])

This is the short-hand signature for the command that is sufficient in many cases.  It is the same as find_path(<VAR> name1 [PATHS path1 path2 ...])


   find_path(
             <VAR>
             name | NAMES name1 [name2 ...]
             [PATHS path1 [path2 ... ENV var]]
             [PATH_SUFFIXES suffix1 [suffix2 ...]]
             [DOC "cache documentation string"]
             [NO_DEFAULT_PATH]
             [NO_CMAKE_ENVIRONMENT_PATH]
             [NO_CMAKE_PATH]
             [NO_SYSTEM_ENVIRONMENT_PATH]
             [NO_CMAKE_SYSTEM_PATH]
             [CMAKE_FIND_ROOT_PATH_BOTH |
              ONLY_CMAKE_FIND_ROOT_PATH |
              NO_CMAKE_FIND_ROOT_PATH]
            )

This command is used to find a directory containing the named file. A cache entry named by <VAR> is created to store the result of this command.  If the file in a directory is found the result is stored in the variable and the search will not be repeated unless the variable is cleared.  If nothing is found, the result will be <VAR>-NOTFOUND, and the search will be attempted again the next time find_path is invoked with the same variable.  The name of the file in a directory that is searched for is specified by the names listed after the NAMES argument.   Additional search locations can be specified after the PATHS argument.  If ENV var is found in the PATHS section the environment variable var will be read and converted from a system environment variable to a cmake style list of paths.  For example ENV PATH would be a way to list the system path variable. The argument after DOC will be used for the documentation string in the cache.  PATH_SUFFIXES can be used to give sub directories that will be appended to the search paths.


If NO_DEFAULT_PATH is specified, then no additional paths are added to the search. If NO_DEFAULT_PATH is not specified, the search process is as follows:


1. Search cmake specific environment variables.  This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.


   <prefix>/include for each <prefix> in CMAKE_PREFIX_PATH
   CMAKE_INCLUDE_PATH
   CMAKE_FRAMEWORK_PATH

2. Search cmake variables with the same names as the cmake specific environment variables.  These are intended to be used on the command line with a -DVAR=value.  This can be skipped if NO_CMAKE_PATH is passed.


   <prefix>/include for each <prefix> in CMAKE_PREFIX_PATH
   CMAKE_INCLUDE_PATH
   CMAKE_FRAMEWORK_PATH

3. Search the standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH is an argument.


   PATH
   INCLUDE

4. Search cmake variables defined in the Platform files for the current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.


   <prefix>/include for each <prefix> in CMAKE_SYSTEM_PREFIX_PATH
   CMAKE_SYSTEM_INCLUDE_PATH
   CMAKE_SYSTEM_FRAMEWORK_PATH

5. Search the paths specified after PATHS or in the short-hand version of the command.


On Darwin or systems supporting OS X Frameworks, the cmake variable    CMAKE_FIND_FRAMEWORK can be set to empty or one of the following:


   "FIRST"  - Try to find frameworks before standard
              libraries or headers. This is the default on Darwin.
   "LAST"   - Try to find frameworks after standard
              libraries or headers.
   "ONLY"   - Only try to find frameworks.
   "NEVER". - Never try to find frameworks.

On Darwin or systems supporting OS X Application Bundles, the cmake variable CMAKE_FIND_APPBUNDLE can be set to empty or one of the following:


   "FIRST"  - Try to find application bundles before standard
              programs. This is the default on Darwin.
   "LAST"   - Try to find application bundles after standard
              programs.
   "ONLY"   - Only try to find application bundles.
   "NEVER". - Never try to find application bundles.

The CMake variable CMAKE_FIND_ROOT_PATH specifies one or more directories to be prepended to all other search directories. This effectively "re-roots" the entire search under given locations. By default it is empty. It is especially useful when cross-compiling to point to the root directory of the target environment and CMake will search there too. By default at first the directories listed in CMAKE_FIND_ROOT_PATH and then the non-rooted directories will be searched. The default behavior can be adjusted by setting CMAKE_FIND_ROOT_PATH_MODE_INCLUDE.  This behavior can be manually overridden on a per-call basis. By using CMAKE_FIND_ROOT_PATH_BOTH the search order will be as described above. If NO_CMAKE_FIND_ROOT_PATH is used then CMAKE_FIND_ROOT_PATH will not be used. If ONLY_CMAKE_FIND_ROOT_PATH is used then only the re-rooted directories will be searched.


The reason the paths listed in the call to the command are searched last is that most users of CMake would expect things to be found first in the locations specified by their environment.  Projects may override this behavior by simply calling the command twice:


   find_path(<VAR> NAMES name PATHS paths... NO_DEFAULT_PATH)
   find_path(<VAR> NAMES name)

Once one of these calls succeeds the result variable will be set and stored in the cache so that neither call will search again.


When searching for frameworks, if the file is specified as A/b.h, then the framework search will look for A.framework/Headers/b.h. If that is found the path will be set to the path to the framework. CMake will convert this to the correct -F option to include the file. 

.TP
.B find_program
Find an executable program.

   find_program(<VAR> name1 [path1 path2 ...])

This is the short-hand signature for the command that is sufficient in many cases.  It is the same as find_program(<VAR> name1 [PATHS path1 path2 ...])


   find_program(
             <VAR>
             name | NAMES name1 [name2 ...]
             [PATHS path1 [path2 ... ENV var]]
             [PATH_SUFFIXES suffix1 [suffix2 ...]]
             [DOC "cache documentation string"]
             [NO_DEFAULT_PATH]
             [NO_CMAKE_ENVIRONMENT_PATH]
             [NO_CMAKE_PATH]
             [NO_SYSTEM_ENVIRONMENT_PATH]
             [NO_CMAKE_SYSTEM_PATH]
             [CMAKE_FIND_ROOT_PATH_BOTH |
              ONLY_CMAKE_FIND_ROOT_PATH |
              NO_CMAKE_FIND_ROOT_PATH]
            )

This command is used to find a program. A cache entry named by <VAR> is created to store the result of this command.  If the program is found the result is stored in the variable and the search will not be repeated unless the variable is cleared.  If nothing is found, the result will be <VAR>-NOTFOUND, and the search will be attempted again the next time find_program is invoked with the same variable.  The name of the program that is searched for is specified by the names listed after the NAMES argument.   Additional search locations can be specified after the PATHS argument.  If ENV var is found in the PATHS section the environment variable var will be read and converted from a system environment variable to a cmake style list of paths.  For example ENV PATH would be a way to list the system path variable. The argument after DOC will be used for the documentation string in the cache.  PATH_SUFFIXES can be used to give sub directories that will be appended to the search paths.


If NO_DEFAULT_PATH is specified, then no additional paths are added to the search. If NO_DEFAULT_PATH is not specified, the search process is as follows:


1. Search cmake specific environment variables.  This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.


   <prefix>/[s]bin for each <prefix> in CMAKE_PREFIX_PATH
   CMAKE_PROGRAM_PATH
   CMAKE_APPBUNDLE_PATH

2. Search cmake variables with the same names as the cmake specific environment variables.  These are intended to be used on the command line with a -DVAR=value.  This can be skipped if NO_CMAKE_PATH is passed.


   <prefix>/[s]bin for each <prefix> in CMAKE_PREFIX_PATH
   CMAKE_PROGRAM_PATH
   CMAKE_APPBUNDLE_PATH

3. Search the standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH is an argument.


   PATH
   

4. Search cmake variables defined in the Platform files for the current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.


   <prefix>/[s]bin for each <prefix> in CMAKE_SYSTEM_PREFIX_PATH
   CMAKE_SYSTEM_PROGRAM_PATH
   CMAKE_SYSTEM_APPBUNDLE_PATH

5. Search the paths specified after PATHS or in the short-hand version of the command.


On Darwin or systems supporting OS X Frameworks, the cmake variable    CMAKE_FIND_FRAMEWORK can be set to empty or one of the following:


   "FIRST"  - Try to find frameworks before standard
              libraries or headers. This is the default on Darwin.
   "LAST"   - Try to find frameworks after standard
              libraries or headers.
   "ONLY"   - Only try to find frameworks.
   "NEVER". - Never try to find frameworks.

On Darwin or systems supporting OS X Application Bundles, the cmake variable CMAKE_FIND_APPBUNDLE can be set to empty or one of the following:


   "FIRST"  - Try to find application bundles before standard
              programs. This is the default on Darwin.
   "LAST"   - Try to find application bundles after standard
              programs.
   "ONLY"   - Only try to find application bundles.
   "NEVER". - Never try to find application bundles.

The CMake variable CMAKE_FIND_ROOT_PATH specifies one or more directories to be prepended to all other search directories. This effectively "re-roots" the entire search under given locations. By default it is empty. It is especially useful when cross-compiling to point to the root directory of the target environment and CMake will search there too. By default at first the directories listed in CMAKE_FIND_ROOT_PATH and then the non-rooted directories will be searched. The default behavior can be adjusted by setting CMAKE_FIND_ROOT_PATH_MODE_PROGRAM.  This behavior can be manually overridden on a per-call basis. By using CMAKE_FIND_ROOT_PATH_BOTH the search order will be as described above. If NO_CMAKE_FIND_ROOT_PATH is used then CMAKE_FIND_ROOT_PATH will not be used. If ONLY_CMAKE_FIND_ROOT_PATH is used then only the re-rooted directories will be searched.


The reason the paths listed in the call to the command are searched last is that most users of CMake would expect things to be found first in the locations specified by their environment.  Projects may override this behavior by simply calling the command twice:


   find_program(<VAR> NAMES name PATHS paths... NO_DEFAULT_PATH)
   find_program(<VAR> NAMES name)

Once one of these calls succeeds the result variable will be set and stored in the cache so that neither call will search again.

.TP
.B fltk_wrap_ui
Create FLTK user interfaces Wrappers.

  fltk_wrap_ui(resultingLibraryName source1
               source2 ... sourceN )

Produce .h and .cxx files for all the .fl and .fld files listed.  The resulting .h and .cxx files will be added to a variable named resultingLibraryName_FLTK_UI_SRCS which should be added to your library.

.TP
.B foreach
Evaluate a group of commands for each value in a list.

  foreach(loop_var arg1 arg2 ...)
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
  endforeach(loop_var)
  foreach(loop_var RANGE total)
  foreach(loop_var RANGE start stop [step])

All commands between foreach and the matching endforeach are recorded without being invoked.  Once the endforeach is evaluated, the recorded list of commands is invoked once for each argument listed in the original foreach command.  Before each iteration of the loop "${loop_var}" will be set as a variable with the current value in the list.


Foreach can also iterate over a generated range of numbers. There are three types of this iteration:


* When specifying single number, the range will have elements 0 to "total".


* When specifying two numbers, the range will have elements from the first number to the second number.


* The third optional number is the increment used to iterate from the first number to the second number.

.TP
.B function
Start recording a function for later invocation as a command.

  function(<name> [arg1 [arg2 [arg3 ...]]])
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
  endfunction(<name>)

Define a function named <name> that takes arguments named arg1 arg2 arg3 (...).  Commands listed after function, but before the matching endfunction, are not invoked until the function is invoked.  When it is invoked, the commands recorded in the function are first modified by replacing formal parameters (${arg1}) with the arguments passed, and then invoked as normal commands. In addition to referencing the formal parameters you can reference the variable ARGC which will be set to the number of arguments passed into the function as well as ARGV0 ARGV1 ARGV2 ... which will have the actual values of the arguments passed in. This facilitates creating functions with optional arguments. Additionally ARGV holds the list of all arguments given to the function and ARGN holds the list of argument pass the last expected argument.

.TP
.B get_cmake_property
Get a property of the CMake instance.

  get_cmake_property(VAR property)

Get a property from the CMake instance.  The value of the property is stored in the variable VAR. If the property is not found, CMake will report an error. Some supported properties include: VARIABLES, CACHE_VARIABLES, COMMANDS, and MACROS.

.TP
.B get_directory_property
Get a property of the directory.

  get_directory_property(VAR [DIRECTORY dir] property)

Get a property from the Directory.  The value of the property is stored in the variable VAR. If the property is not found, CMake will report an error. The properties include: VARIABLES, CACHE_VARIABLES, COMMANDS, MACROS, INCLUDE_DIRECTORIES, LINK_DIRECTORIES, DEFINITIONS, INCLUDE_REGULAR_EXPRESSION, LISTFILE_STACK, PARENT_DIRECTORY, and DEFINITION varname.  If the DIRECTORY argument is provided then the property of the provided directory will be retrieved instead of the current directory. You can only get properties of a directory during or after it has been traversed by cmake.

.TP
.B get_filename_component
Get a specific component of a full filename.

  get_filename_component(VarName FileName
                         PATH|ABSOLUTE|NAME|EXT|NAME_WE
                         [CACHE])

Set VarName to be the path (PATH), file name (NAME), file extension (EXT), file name without extension (NAME_WE) of FileName, or the full absolute (ABSOLUTE) file name without symlinks.  Note that the path is converted to Unix slashes format and has no trailing slashes. The longest file extension is always considered. If the optional CACHE argument is specified, the result variable is added to the cache.


  get_filename_component(VarName FileName
                         PROGRAM [PROGRAM_ARGS ArgVar]
                         [CACHE])

The program in FileName will be found in the system search path or left as a full path.  If PROGRAM_ARGS is present with PROGRAM, then any command-line arguments present in the FileName string are split from the program name and stored in ArgVar.  This is used to separate a program name from its arguments in a command line string.

.TP
.B get_property
Get a property.

  get_property(<variable>
               <GLOBAL             |
                DIRECTORY [dir]    |
                TARGET    <target> |
                SOURCE    <source> |
                TEST      <test>   |
                VARIABLE>
               PROPERTY <name>
               [SET | DEFINED | BRIEF_DOCS | FULL_DOCS])

Get one property from one object in a scope.  The first argument specifies the variable in which to store the result.  The second argument determines the scope from which to get the property.  It must be one of the following:


GLOBAL scope is unique and does not accept a name.


DIRECTORY scope defaults to the current directory but another directory (already processed by CMake) may be named by full or relative path.


TARGET scope must name one existing target.


SOURCE scope must name one source file.


TEST scope must name one existing test.


VARIABLE scope is unique and does not accept a name.


The required PROPERTY option is immediately followed by the name of the property to get.  If the property is not set an empty value is returned.  If the SET option is given the variable is set to a boolean value indicating whether the property has been set.If the DEFINED option is given the variable is set to a boolean value indicating whether the property has been defined such as with define_property. If BRIEF_DOCS or FULL_DOCS is given then the variable is set to a string containing documentation for the requested property.  If documentation is requested for a property that has not been defined NOTFOUND is returned.

.TP
.B get_source_file_property
Get a property for a source file.

  get_source_file_property(VAR file property)

Get a property from a source file.  The value of the property is stored in the variable VAR.  If the property is not found, VAR will be set to "NOTFOUND". Use set_source_files_properties to set property values.  Source file properties usually control how the file is built. One property that is always there is LOCATION

.TP
.B get_target_property
Get a property from a target.

  get_target_property(VAR target property)

Get a property from a target.   The value of the property is stored in the variable VAR.  If the property is not found, VAR will be set to "NOTFOUND".  Use set_target_properties to set property values.  Properties are usually used to control how a target is built.


The read-only property "<CONFIG>_LOCATION" provides the full path to the file on disk that will be created for the target when building under configuration <CONFIG> (in upper-case, such as "DEBUG_LOCATION"). The read-only property "LOCATION" specifies the full path to the file on disk that will be created for the target. The path may contain a build-system-specific portion that is replaced at build time with the configuration getting built (such as "$(ConfigurationName)" in VS). This is very useful for executable targets to get the path to the executable file for use in a custom command.


The read-only property "TYPE" returns which type the specified target has (EXECUTABLE, STATIC_LIBRARY, SHARED_LIBRARY, MODULE_LIBRARY, UTILITY, INSTALL_FILES or INSTALL_PROGRAMS). This command can get properties for any target so far created. The targets do not need to be in the current CMakeLists.txt file.

.TP
.B get_test_property
Get a property of the test.

  get_test_property(test VAR property)

Get a property from the Test.  The value of the property is stored in the variable VAR. If the property is not found, CMake will report an error. For a list of standard properties you can type cmake --help-property-list

.TP
.B if
Conditionally execute a group of commands.

  if(expression)
    # then section.
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
  elseif(expression2)
    # elseif section.
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
  else(expression)
    # else section.
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
  endif(expression)

Evaluates the given expression.  If the result is true, the commands in the THEN section are invoked.  Otherwise, the commands in the else section are invoked.  The elseif and else sections are optional. You may have multiple elseif clauses. Note that the same expression must be given to if, and endif.  Long expressions can be used and the order or precedence is that the EXISTS, COMMAND, and DEFINED operators will be evaluated first. Then any EQUAL, LESS, GREATER, STRLESS, STRGREATER, STREQUAL, MATCHES will be evaluated. Then NOT operators and finally AND, OR operators will be evaluated. Possible expressions are:


  if(variable)

True if the variable's value is not empty, 0, N, NO, OFF, FALSE, NOTFOUND, or <variable>-NOTFOUND.


  if(NOT variable)

True if the variable's value is empty, 0, N, NO, OFF, FALSE, NOTFOUND, or <variable>-NOTFOUND.


  if(variable1 AND variable2)

True if both variables would be considered true individually.


  if(variable1 OR variable2)

True if either variable would be considered true individually.


  if(COMMAND command-name)

True if the given name is a command, macro or function that can be invoked.


  if(POLICY policy-id)

True if the given name is an existing policy (of the form CMP<NNNN>).


  if(EXISTS file-name)
  if(EXISTS directory-name)

True if the named file or directory exists.  Behavior is well-defined only for full paths.


  if(file1 IS_NEWER_THAN file2)

True if file1 is newer than file2 or if one of the two files doesn't exist. Behavior is well-defined only for full paths.


  if(IS_DIRECTORY directory-name)

True if the given name is a directory.  Behavior is well-defined only for full paths.


  if(IS_ABSOLUTE path)

True if the given path is an absolute path.


   if(variable MATCHES regex)
  if(string MATCHES regex)

True if the given string or variable's value matches the given regular expression.


  if(variable LESS number)
  if(string LESS number)
  if(variable GREATER number)
  if(string GREATER number)
  if(variable EQUAL number)
  if(string EQUAL number)

True if the given string or variable's value is a valid number and the inequality or equality is true.


  if(variable STRLESS string)
  if(string STRLESS string)
  if(variable STRGREATER string)
  if(string STRGREATER string)
  if(variable STREQUAL string)
  if(string STREQUAL string)

True if the given string or variable's value is lexicographically less (or greater, or equal) than the string on the right.


  if(DEFINED variable)

True if the given variable is defined. It does not matter if the variable is true or false just if it has been set.

.TP
.B include
Read CMake listfile code from the given file.

  include(file1 [OPTIONAL] [RESULT_VARIABLE <VAR>])
  include(module [OPTIONAL] [RESULT_VARIABLE <VAR>])

Reads CMake listfile code from the given file.  Commands in the file are processed immediately as if they were written in place of the include command.  If OPTIONAL is present, then no error is raised if the file does not exist.  If RESULT_VARIABLE is given the variable will be set to the full filename which has been included or NOTFOUND if it failed.


If a module is specified instead of a file, the file with name <modulename>.cmake is searched in the CMAKE_MODULE_PATH.

.TP
.B include_directories
Add include directories to the build.

  include_directories([AFTER|BEFORE] [SYSTEM] dir1 dir2 ...)

Add the given directories to those searched by the compiler for include files. By default the directories are appended onto the current list of directories. This default behavior can be changed by setting CMAKE_include_directories_BEFORE to ON. By using BEFORE or AFTER you can select between appending and prepending, independent from the default. If the SYSTEM option is given the compiler will be told that the directories are meant as system include directories on some platforms.

.TP
.B include_external_msproject
Include an external Microsoft project file in a workspace.

  include_external_msproject(projectname location
                             dep1 dep2 ...)

Includes an external Microsoft project in the generated workspace file.  Currently does nothing on UNIX.

.TP
.B include_regular_expression
Set the regular expression used for dependency checking.

  include_regular_expression(regex_match [regex_complain])

Set the regular expressions used in dependency checking.  Only files matching regex_match will be traced as dependencies.  Only files matching regex_complain will generate warnings if they cannot be found (standard header paths are not searched).  The defaults are:


  regex_match    = "^.*$" (match everything)
  regex_complain = "^$" (match empty string only)
.TP
.B install
Specify rules to run at install time.

This command generates installation rules for a project.  Rules specified by calls to this command within a source directory are executed in order during installation.  The order across directories is not defined.


There are multiple signatures for this command.  Some of them define installation properties for files and targets.  Properties common to multiple signatures are covered here but they are valid only for signatures that specify them.


DESTINATION arguments specify the directory on disk to which a file will be installed.  If a full path (with a leading slash or drive letter) is given it is used directly.  If a relative path is given it is interpreted relative to the value of CMAKE_INSTALL_PREFIX.


PERMISSIONS arguments specify permissions for installed files.  Valid permissions are OWNER_READ, OWNER_WRITE, OWNER_EXECUTE, GROUP_READ, GROUP_WRITE, GROUP_EXECUTE, WORLD_READ, WORLD_WRITE, WORLD_EXECUTE, SETUID, and SETGID.  Permissions that do not make sense on certain platforms are ignored on those platforms.


The CONFIGURATIONS argument specifies a list of build configurations for which the install rule applies (Debug, Release, etc.).


The COMPONENT argument specifies an installation component name with which the install rule is associated, such as "runtime" or "development".  During component-specific installation only install rules associated with the given component name will be executed.  During a full installation all components are installed.


The RENAME argument specifies a name for an installed file that may be different from the original file.  Renaming is allowed only when a single file is installed by the command.


The OPTIONAL argument specifies that it is not an error if the file to be installed does not exist.  


The TARGETS signature:


  install(TARGETS targets... [EXPORT <export-name>]
          [[ARCHIVE|LIBRARY|RUNTIME|FRAMEWORK|BUNDLE|
            PRIVATE_HEADER|PUBLIC_HEADER|RESOURCE]
           [DESTINATION <dir>]
           [PERMISSIONS permissions...]
           [CONFIGURATIONS [Debug|Release|...]]
           [COMPONENT <component>]
           [OPTIONAL] [NAMELINK_ONLY|NAMELINK_SKIP]
          ] [...])

The TARGETS form specifies rules for installing targets from a project.  There are five kinds of target files that may be installed: ARCHIVE, LIBRARY, RUNTIME, FRAMEWORK, and BUNDLE.  Executables are treated as RUNTIME targets, except that those marked with the MACOSX_BUNDLE property are treated as BUNDLE targets on OS X. Static libraries are always treated as ARCHIVE targets. Module libraries are always treated as LIBRARY targets. For non-DLL platforms shared libraries are treated as LIBRARY targets, except that those marked with the FRAMEWORK property are treated as FRAMEWORK targets on OS X.  For DLL platforms the DLL part of a shared library is treated as a RUNTIME target and the corresponding import library is treated as an ARCHIVE target. All Windows-based systems including Cygwin are DLL platforms. The ARCHIVE, LIBRARY, RUNTIME, and FRAMEWORK arguments change the type of target to which the subsequent properties apply.  If none is given the installation properties apply to all target types.  If only one is given then only targets of that type will be installed (which can be used to install just a DLL or just an import library).


The PRIVATE_HEADER, PUBLIC_HEADER, and RESOURCE arguments cause subsequent properties to be applied to installing a FRAMEWORK shared library target's associated files on non-Apple platforms.  Rules defined by these arguments are ignored on Apple platforms because the associated files are installed into the appropriate locations inside the framework folder.  See documentation of the PRIVATE_HEADER, PUBLIC_HEADER, and RESOURCE target properties for details.


Either NAMELINK_ONLY or NAMELINK_SKIP may be specified as a LIBRARY option.  On some platforms a versioned shared library has a symbolic link such as


  lib<name>.so -> lib<name>.so.1

where "lib<name>.so.1" is the soname of the library and "lib<name>.so" is a "namelink" allowing linkers to find the library when given "-l<name>".  The NAMELINK_ONLY option causes installation of only the namelink when a library target is installed.  The NAMELINK_SKIP option causes installation of library files other than the namelink when a library target is installed.  When neither option is given both portions are installed.  On platforms where versioned shared libraries do not have namelinks or when a library is not versioned the NAMELINK_SKIP option installs the library and the NAMELINK_ONLY option installs nothing.  See the VERSION and SOVERSION target properties for details on creating versioned shared libraries.


One or more groups of properties may be specified in a single call to the TARGETS form of this command.  A target may be installed more than once to different locations.  Consider hypothetical targets "myExe", "mySharedLib", and "myStaticLib".  The code


    install(TARGETS myExe mySharedLib myStaticLib
            RUNTIME DESTINATION bin
            LIBRARY DESTINATION lib
            ARCHIVE DESTINATION lib/static)
    install(TARGETS mySharedLib DESTINATION /some/full/path)

will install myExe to <prefix>/bin and myStaticLib to <prefix>/lib/static.  On non-DLL platforms mySharedLib will be installed to <prefix>/lib and /some/full/path.  On DLL platforms the mySharedLib DLL will be installed to <prefix>/bin and /some/full/path and its import library will be installed to <prefix>/lib/static and /some/full/path. On non-DLL platforms mySharedLib will be installed to <prefix>/lib and /some/full/path.


The EXPORT option associates the installed target files with an export called <export-name>.  It must appear before any RUNTIME, LIBRARY, or ARCHIVE options.  See documentation of the install(EXPORT ...) signature below for details.


Installing a target with EXCLUDE_FROM_ALL set to true has undefined behavior.


The FILES signature:


  install(FILES files... DESTINATION <dir>
          [PERMISSIONS permissions...]
          [CONFIGURATIONS [Debug|Release|...]]
          [COMPONENT <component>]
          [RENAME <name>] [OPTIONAL])

The FILES form specifies rules for installing files for a project.  File names given as relative paths are interpreted with respect to the current source directory.  Files installed by this form are by default given permissions OWNER_WRITE, OWNER_READ, GROUP_READ, and WORLD_READ if no PERMISSIONS argument is given.


The PROGRAMS signature:


  install(PROGRAMS files... DESTINATION <dir>
          [PERMISSIONS permissions...]
          [CONFIGURATIONS [Debug|Release|...]]
          [COMPONENT <component>]
          [RENAME <name>] [OPTIONAL])

The PROGRAMS form is identical to the FILES form except that the default permissions for the installed file also include OWNER_EXECUTE, GROUP_EXECUTE, and WORLD_EXECUTE.  This form is intended to install programs that are not targets, such as shell scripts.  Use the TARGETS form to install targets built within the project.


The DIRECTORY signature:


  install(DIRECTORY dirs... DESTINATION <dir>
          [FILE_PERMISSIONS permissions...]
          [DIRECTORY_PERMISSIONS permissions...]
          [USE_SOURCE_PERMISSIONS]
          [CONFIGURATIONS [Debug|Release|...]]
          [COMPONENT <component>] [FILES_MATCHING]
          [[PATTERN <pattern> | REGEX <regex>]
           [EXCLUDE] [PERMISSIONS permissions...]] [...])

The DIRECTORY form installs contents of one or more directories to a given destination.  The directory structure is copied verbatim to the destination.  The last component of each directory name is appended to the destination directory but a trailing slash may be used to avoid this because it leaves the last component empty.  Directory names given as relative paths are interpreted with respect to the current source directory.  If no input directory names are given the destination directory will be created but nothing will be installed into it.  The FILE_PERMISSIONS and DIRECTORY_PERMISSIONS options specify permissions given to files and directories in the destination.  If USE_SOURCE_PERMISSIONS is specified and FILE_PERMISSIONS is not, file permissions will be copied from the source directory structure.  If no permissions are specified files will be given the default permissions specified in the FILES form of the command, and the directories will be given the default permissions specified in the PROGRAMS form of the command.


Installation of directories may be controlled with fine granularity using the PATTERN or REGEX options.  These "match" options specify a globbing pattern or regular expression to match directories or files encountered within input directories.  They may be used to apply certain options (see below) to a subset of the files and directories encountered.  The full path to each input file or directory (with forward slashes) is matched against the expression.  A PATTERN will match only complete file names: the portion of the full path matching the pattern must occur at the end of the file name and be preceded by a slash.  A REGEX will match any portion of the full path but it may use '/' and '$' to simulate the PATTERN behavior.  By default all files and directories are installed whether or not they are matched.  The FILES_MATCHING option may be given before the first match option to disable installation of files (but not directories) not matched by any expression.  For example, the code


  install(DIRECTORY src/ DESTINATION include/myproj
          FILES_MATCHING PATTERN "*.h")

will extract and install header files from a source tree.


Some options may follow a PATTERN or REGEX expression and are applied only to files or directories matching them.  The EXCLUDE option will skip the matched file or directory.  The PERMISSIONS option overrides the permissions setting for the matched file or directory.  For example the code


  install(DIRECTORY icons scripts/ DESTINATION share/myproj
          PATTERN "CVS" EXCLUDE
          PATTERN "scripts/*"
          PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ
                      GROUP_EXECUTE GROUP_READ)

will install the icons directory to share/myproj/icons and the scripts directory to share/myproj.  The icons will get default file permissions, the scripts will be given specific permissions, and any CVS directories will be excluded.


The SCRIPT and CODE signature:


  install([[SCRIPT <file>] [CODE <code>]] [...])

The SCRIPT form will invoke the given CMake script files during installation.  If the script file name is a relative path it will be interpreted with respect to the current source directory.  The CODE form will invoke the given CMake code during installation.  Code is specified as a single argument inside a double-quoted string. For example, the code


  install(CODE "MESSAGE(\\"Sample install message.\\")")

will print a message during installation.


The EXPORT signature:


  install(EXPORT <export-name> DESTINATION <dir>
          [NAMESPACE <namespace>] [FILE <name>.cmake]
          [PERMISSIONS permissions...]
          [CONFIGURATIONS [Debug|Release|...]]
          [COMPONENT <component>])

The EXPORT form generates and installs a CMake file containing code to import targets from the installation tree into another project.  Target installations are associated with the export <export-name> using the EXPORT option of the install(TARGETS ...) signature documented above.  The NAMESPACE option will prepend <namespace> to the target names as they are written to the import file.  By default the generated file will be called <export-name>.cmake but the FILE option may be used to specify a different name.  The value given to the FILE option must be a file name with the ".cmake" extension.  If a CONFIGURATIONS option is given then the file will only be installed when one of the named configurations is installed.  Additionally, the generated import file will reference only the matching target configurations.  If a COMPONENT option is specified that does not match that given to the targets associated with <export-name> the behavior is undefined.  If a library target is included in the export but a target to which it links is not included the behavior is unspecified.


The EXPORT form is useful to help outside projects use targets built and installed by the current project.  For example, the code


  install(TARGETS myexe EXPORT myproj DESTINATION bin)
  install(EXPORT myproj NAMESPACE mp_ DESTINATION lib/myproj)

will install the executable myexe to <prefix>/bin and code to import it in the file "<prefix>/lib/myproj/myproj.cmake".  An outside project may load this file with the include command and reference the myexe executable from the installation tree using the imported target name mp_myexe as if the target were built in its own tree.


NOTE: This command supercedes the INSTALL_TARGETS command and the target properties PRE_INSTALL_SCRIPT and POST_INSTALL_SCRIPT.  It also replaces the FILES forms of the INSTALL_FILES and INSTALL_PROGRAMS commands.  The processing order of these install rules relative to those generated by INSTALL_TARGETS, INSTALL_FILES, and INSTALL_PROGRAMS commands is not defined.


.TP
.B link_directories
Specify directories in which the linker will look for libraries.

  link_directories(directory1 directory2 ...)

Specify the paths in which the linker should search for libraries. The command will apply only to targets created after it is called.

.TP
.B list
List operations.

  list(LENGTH <list> <output variable>)
  list(GET <list> <element index> [<element index> ...] <output variable>)
  list(APPEND <list> <element> [<element> ...])
  list(FIND <list> <value> <output variable>)
  list(INSERT <list> <element_index> <element> [<element> ...])
  list(REMOVE_ITEM <list> <value> [<value> ...])
  list(REMOVE_AT <list> <index> [<index> ...])
  list(REMOVE_DUPLICATES <list>)
  list(REVERSE <list>)
  list(SORT <list>)

LENGTH will return a given list's length.


GET will return list of elements specified by indices from the list.


APPEND will append elements to the list.


FIND will return the index of the element specified in the list or -1 if it wasn't found.


INSERT will insert elements to the list to the specified location.


REMOVE_AT and REMOVE_ITEM will remove items from the list. The difference is that REMOVE_ITEM will remove the given items, while REMOVE_AT will remove the items at the given indices.


REMOVE_DUPLICATES will remove duplicated items in the list.


REVERSE reverses the contents of the list in-place.


SORT sorts the list in-place alphabetically.


NOTES: A list in cmake is a ; separated group of strings. To create a list the set command can be used. For example, set(var a b c d e)  creates a list with a;b;c;d;e, and set(var "a b c d e") creates a string or a list with one item in it.


When specifying index values, if <element index> is 0 or greater, it is indexed from the beginning of the list, with 0 representing the first list element. If <element index> is -1 or lesser, it is indexed from the end of the list, with -1 representing the last list element. Be careful when counting with negative indices: they do not start from 0. -0 is equivalent to 0, the first list element.


.TP
.B load_cache
Load in the values from another project's CMake cache.

  load_cache(pathToCacheFile READ_WITH_PREFIX
             prefix entry1...)

Read the cache and store the requested entries in variables with their name prefixed with the given prefix.  This only reads the values, and does not create entries in the local project's cache.


  load_cache(pathToCacheFile [EXCLUDE entry1...]
             [INCLUDE_INTERNALS entry1...])

Load in the values from another cache and store them in the local project's cache as internal entries.  This is useful for a project that depends on another project built in a different tree.  EXCLUDE option can be used to provide a list of entries to be excluded.  INCLUDE_INTERNALS can be used to provide a list of internal entries to be included.  Normally, no internal entries are brought in.  Use of this form of the command is strongly discouraged, but it is provided for backward compatibility.

.TP
.B load_command
Load a command into a running CMake.

  load_command(COMMAND_NAME <loc1> [loc2 ...])

The given locations are searched for a library whose name is cmCOMMAND_NAME.  If found, it is loaded as a module and the command is added to the set of available CMake commands.  Usually, TRY_COMPILE is used before this command to compile the module. If the command is successfully loaded a variable named


  CMAKE_LOADED_COMMAND_<COMMAND_NAME>

will be set to the full path of the module that was loaded.  Otherwise the variable will not be set.

.TP
.B macro
Start recording a macro for later invocation as a command.

  macro(<name> [arg1 [arg2 [arg3 ...]]])
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
  endmacro(<name>)

Define a macro named <name> that takes arguments named arg1 arg2 arg3 (...).  Commands listed after macro, but before the matching endmacro, are not invoked until the macro is invoked.  When it is invoked, the commands recorded in the macro are first modified by replacing formal parameters (${arg1}) with the arguments passed, and then invoked as normal commands. In addition to referencing the formal parameters you can reference the values ${ARGC} which will be set to the number of arguments passed into the function as well as ${ARGV0} ${ARGV1} ${ARGV2} ... which will have the actual values of the arguments passed in. This facilitates creating macros with optional arguments. Additionally ${ARGV} holds the list of all arguments given to the macro and ${ARGN} holds the list of argument pass the last expected argument. Note that the parameters to a macro and values such as ARGN are not variables in the usual CMake sense. They are string replacements much like the c preprocessor would do with a macro. If you want true CMake variables you should look at the function command.

.TP
.B mark_as_advanced
Mark cmake cached variables as advanced.

  mark_as_advanced([CLEAR|FORCE] VAR VAR2 VAR...)

Mark the named cached variables as advanced.  An advanced variable will not be displayed in any of the cmake GUIs unless the show advanced option is on.  If CLEAR is the first argument advanced variables are changed back to unadvanced.  If FORCE is the first argument, then the variable is made advanced.  If neither FORCE nor CLEAR is specified, new values will be marked as advanced, but if the variable already has an advanced/non-advanced state, it will not be changed.


It does nothing in script mode.

.TP
.B math
Mathematical expressions.

  math(EXPR <output variable> <math expression>)

EXPR evaluates mathematical expression and return result in the output variable. Example mathematical expression is '5 * ( 10 + 13 )'.  Supported operators are + - * / % | & ^ ~ << >> * / %.  They have the same meaning  as they do in c code.

.TP
.B message
Display a message to the user.

  message([SEND_ERROR | STATUS | FATAL_ERROR]
          "message to display" ...)

By default the message is displayed in a pop up window (CMakeSetup), or in the stdout of cmake, or the error section of ccmake. If the first argument is SEND_ERROR then an error is raised, and the generate phase will be skipped.  If the first argument is FATAL_ERROR, all processing is halted. If the first argument is STATUS then the message is displayed in the progress line for the GUI, or with a -- in the command line cmake.

.TP
.B option
Provides an option that the user can optionally select.

  option(<option_variable> "help string describing option"
         [initial value])

Provide an option for the user to select as ON or OFF.  If no initial value is provided, OFF is used.

.TP
.B output_required_files
Output a list of required source files for a specified source file.

  output_required_files(srcfile outputfile)

Outputs a list of all the source files that are required by the specified srcfile. This list is written into outputfile. This is similar to writing out the dependencies for srcfile except that it jumps from .h files into .cxx, .c and .cpp files if possible.

.TP
.B project
Set a name for the entire project.

  project(projectname [CXX] [C] [Java])

Sets the name of the project.  This creates the variables projectname_BINARY_DIR and projectname_SOURCE_DIR.  Optionally you can specify which languages your project supports.  By default all languages are supported.  If you do not have a C++ compiler, but want to build a c program with cmake, then use this option.

.TP
.B qt_wrap_cpp
Create Qt Wrappers.

  qt_wrap_cpp(resultingLibraryName DestName
              SourceLists ...)

Produce moc files for all the .h files listed in the SourceLists.  The moc files will be added to the library using the DestName source list.

.TP
.B qt_wrap_ui
Create Qt user interfaces Wrappers.

  qt_wrap_ui(resultingLibraryName HeadersDestName
             SourcesDestName SourceLists ...)

Produce .h and .cxx files for all the .ui files listed in the SourceLists.  The .h files will be added to the library using the HeadersDestNamesource list.  The .cxx files will be added to the library using the SourcesDestNamesource list.

.TP
.B remove_definitions
Removes -D define flags added by add_definitions.

  remove_definitions(-DFOO -DBAR ...)

Removes flags (added by add_definitions) from the compiler command line for sources in the current directory and below.

.TP
.B return
Return from a directory or function.

  return()

Returns from a directory or function. When this command is encountered, it caused process of the current function or directory to stop and control is return to the caller of the function, or the parent directory if any. Note that a macro is not a function and does not handle return like a function does.

.TP
.B separate_arguments
Split space separated arguments into a semi-colon separated list.

  separate_arguments(VARIABLE)

Convert the value of VARIABLE to a semi-colon separated list.  All spaces are replaced with ';'.  This helps with generating command lines.

.TP
.B set
Set a CMAKE variable to a given value.

  set(<variable> <value> [[CACHE <type> <docstring> [FORCE]] | PARENT_SCOPE])

Within CMake sets <variable> to the value <value>.  <value> is expanded  before <variable> is set to it.  If CACHE is present, then the <variable> is put in the cache. <type> and <docstring> are then required. <type> is used by the CMake GUI to choose a widget with which the user sets a value.  The value for <type> may be one of


  FILEPATH = File chooser dialog.
  PATH     = Directory chooser dialog.
  STRING   = Arbitrary string.
  BOOL     = Boolean ON/OFF checkbox.
  INTERNAL = No GUI entry (used for persistent variables).

If <type> is INTERNAL, then the <value> is always written into the cache, replacing any values existing in the cache.  If it is not a cache variable, then this always writes into the current makefile. The FORCE option will overwrite the cache value removing any changes by the user.


If PARENT_SCOPE is present, the variable will be set in the scope above the current scope. Each new directory or function creates a new scope. This command will set the value of a variable into the parent directory or calling function (whichever is applicable to the case at hand) If VALUE is not specified then the variable is removed from the parent scope.


  set(<variable> <value1> ... <valueN>)

In this case <variable> is set to a semicolon separated list of values.


<variable> can be an environment variable such as:


  set( ENV{PATH} /home/martink )

in which case the environment variable will be set.

.TP
.B set_directory_properties
Set a property of the directory.

  set_directory_properties(PROPERTIES prop1 value1 prop2 value2)

Set a property for the current directory and subdirectories. If the property is not found, CMake will report an error. The properties include: INCLUDE_DIRECTORIES, LINK_DIRECTORIES, INCLUDE_REGULAR_EXPRESSION, and ADDITIONAL_MAKE_CLEAN_FILES.


ADDITIONAL_MAKE_CLEAN_FILES is a list of files that will be cleaned as a part of "make clean" stage.

.TP
.B set_property
Set a named property in a given scope.

  set_property(<GLOBAL                            |
                DIRECTORY [dir]                   |
                TARGET    [target1 [target2 ...]] |
                SOURCE    [src1 [src2 ...]]       |
                TEST      [test1 [test2 ...]]>
               [APPEND]
               PROPERTY <name> [value1 [value2 ...]])

Set one property on zero or more objects of a scope.  The first argument determines the scope in which the property is set.  It must be one of the following:


GLOBAL scope is unique and does not accept a name.


DIRECTORY scope defaults to the current directory but another directory (already processed by CMake) may be named by full or relative path.


TARGET scope may name zero or more existing targets.


SOURCE scope may name zero or more source files.


TEST scope may name zero or more existing tests.


The required PROPERTY option is immediately followed by the name of the property to set.  Remaining arguments are used to compose the property value in the form of a semicolon-separated list.  If the APPEND option is given the list is appended to any existing property value.

.TP
.B set_source_files_properties
Source files can have properties that affect how they are built.

  set_source_files_properties(file1 file2 ...
                              PROPERTIES prop1 value1
                              prop2 value2 ...)

Set properties on a file. The syntax for the command is to list all the files you want to change, and then provide the values you want to set next.  You can make up your own properties as well.  The following are used by CMake.  The ABSTRACT flag (boolean) is used by some class wrapping commands. If WRAP_EXCLUDE (boolean) is true then many wrapping commands will ignore this file. If GENERATED (boolean) is true then it is not an error if this source file does not exist when it is added to a target.  Obviously, it must be created (presumably by a custom command) before the target is built.  If the HEADER_FILE_ONLY (boolean) property is true then the file is not compiled.  This is useful if you want to add extra non build files to an IDE. OBJECT_DEPENDS (string) adds dependencies to the object file.  COMPILE_FLAGS (string) is passed to the compiler as additional command line arguments when the source file is compiled.  LANGUAGE (string) CXX|C will change the default compiler used to compile the source file. The languages used need to be enabled in the PROJECT command. If SYMBOLIC (boolean) is set to true the build system will be informed that the source file is not actually created on disk but instead used as a symbolic name for a build rule.

.TP
.B set_target_properties
Targets can have properties that affect how they are built.

  set_target_properties(target1 target2 ...
                        PROPERTIES prop1 value1
                        prop2 value2 ...)

Set properties on a target. The syntax for the command is to list all the files you want to change, and then provide the values you want to set next.  You can use any prop value pair you want and extract it later with the GET_TARGET_PROPERTY command.


Properties that affect the name of a target's output file are as follows.  The PREFIX and SUFFIX properties override the default target name prefix (such as "lib") and suffix (such as ".so"). IMPORT_PREFIX and IMPORT_SUFFIX are the equivalent properties for the import library corresponding to a DLL (for SHARED library targets).  OUTPUT_NAME sets the real name of a target when it is built and can be used to help create two targets of the same name even though CMake requires unique logical target names.  There is also a <CONFIG>_OUTPUT_NAME that can set the output name on a per-configuration basis.  <CONFIG>_POSTFIX sets a postfix for the real name of the target when it is built under the configuration named by <CONFIG> (in upper-case, such as "DEBUG_POSTFIX").  The value of this property is initialized when the target is created to the value of the variable CMAKE_<CONFIG>_POSTFIX (except for executable targets because earlier CMake versions which did not use this variable for executables).


The LINK_FLAGS property can be used to add extra flags to the link step of a target. LINK_FLAGS_<CONFIG> will add to the configuration <CONFIG>, for example, DEBUG, RELEASE, MINSIZEREL, RELWITHDEBINFO. DEFINE_SYMBOL sets the name of the preprocessor symbol defined when compiling sources in a shared library. If not set here then it is set to target_EXPORTS by default (with some substitutions if the target is not a valid C identifier). This is useful for headers to know whether they are being included from inside their library our outside to properly setup dllexport/dllimport decorations. The COMPILE_FLAGS property sets additional compiler flags used to build sources within the target.  It may also be used to pass additional preprocessor definitions.


The LINKER_LANGUAGE property is used to change the tool used to link an executable or shared library. The default is set the language to match the files in the library. CXX and C are common values for this property.


For shared libraries VERSION and SOVERSION can be used to specify the build version and api version respectively. When building or installing appropriate symlinks are created if the platform supports symlinks and the linker supports so-names. If only one of both is specified the missing is assumed to have the same version number. For executables VERSION can be used to specify the build version. When building or installing appropriate symlinks are created if the platform supports symlinks. For shared libraries and executables on Windows the VERSION attribute is parsed to extract a "major.minor" version number. These numbers are used as the image version of the binary. 


There are a few properties used to specify RPATH rules. INSTALL_RPATH is a semicolon-separated list specifying the rpath to use in installed targets (for platforms that support it). INSTALL_RPATH_USE_LINK_PATH is a boolean that if set to true will append directories in the linker search path and outside the project to the INSTALL_RPATH. SKIP_BUILD_RPATH is a boolean specifying whether to skip automatic generation of an rpath allowing the target to run from the build tree. BUILD_WITH_INSTALL_RPATH is a boolean specifying whether to link the target in the build tree with the INSTALL_RPATH.  This takes precedence over SKIP_BUILD_RPATH and avoids the need for relinking before installation.  INSTALL_NAME_DIR is a string specifying the directory portion of the "install_name" field of shared libraries on Mac OSX to use in the installed targets. When the target is created the values of the variables CMAKE_INSTALL_RPATH, CMAKE_INSTALL_RPATH_USE_LINK_PATH, CMAKE_SKIP_BUILD_RPATH, CMAKE_BUILD_WITH_INSTALL_RPATH, and CMAKE_INSTALL_NAME_DIR are used to initialize these properties.


PROJECT_LABEL can be used to change the name of the target in an IDE like visual studio.  VS_KEYWORD can be set to change the visual studio keyword, for example QT integration works better if this is set to Qt4VSv1.0.


When a library is built CMake by default generates code to remove any existing library using all possible names.  This is needed to support libraries that switch between STATIC and SHARED by a user option.  However when using OUTPUT_NAME to build a static and shared library of the same name using different logical target names the two targets will remove each other's files.  This can be prevented by setting the CLEAN_DIRECT_OUTPUT property to 1.


The PRE_INSTALL_SCRIPT and POST_INSTALL_SCRIPT properties are the old way to specify CMake scripts to run before and after installing a target.  They are used only when the old INSTALL_TARGETS command is used to install the target.  Use the INSTALL command instead.


The EXCLUDE_FROM_DEFAULT_BUILD property is used by the visual studio generators.  If it is set to 1 the target will not be part of the default build when you select "Build Solution".

.TP
.B set_tests_properties
Set a property of the tests.

  set_tests_properties(test1 [test2...] PROPERTIES prop1 value1 prop2 value2)

Set a property for the tests. If the property is not found, CMake will report an error. The properties include:


WILL_FAIL: If set to true, this will invert the pass/fail flag of the test.


PASS_REGULAR_EXPRESSION: If set, the test output will be checked against the specified regular expressions and at least one of the regular expressions has to match, otherwise the test will fail.


  Example: PASS_REGULAR_EXPRESSION "TestPassed;All ok"

FAIL_REGULAR_EXPRESSION: If set, if the output will match to one of specified regular expressions, the test will fail.


  Example: PASS_REGULAR_EXPRESSION "[^a-z]Error;ERROR;Failed"

Both PASS_REGULAR_EXPRESSION and FAIL_REGULAR_EXPRESSION expect a list of regular expressions.


.TP
.B site_name
Set the given variable to the name of the computer.

  site_name(variable)

.TP
.B source_group
Define a grouping for sources in the makefile.

  source_group(name [REGULAR_EXPRESSION regex] [FILES src1 src2 ...])

Defines a group into which sources will be placed in project files.  This is mainly used to setup file tabs in Visual Studio.  Any file whose name is listed or matches the regular expression will be placed in this group.  If a file matches multiple groups, the LAST group that explicitly lists the file will be favored, if any.  If no group explicitly lists the file, the LAST group whose regular expression matches the file will be favored.


The name of the group may contain backslashes to specify subgroups:


  source_group(outer\\\\inner ...)

For backwards compatibility, this command is also supports the format:


  source_group(name regex)
.TP
.B string
String operations.

  string(REGEX MATCH <regular_expression>
         <output variable> <input> [<input>...])
  string(REGEX MATCHALL <regular_expression>
         <output variable> <input> [<input>...])
  string(REGEX REPLACE <regular_expression>
         <replace_expression> <output variable>
         <input> [<input>...])
  string(REPLACE <match_string>
         <replace_string> <output variable>
         <input> [<input>...])
  string(COMPARE EQUAL <string1> <string2> <output variable>)
  string(COMPARE NOTEQUAL <string1> <string2> <output variable>)
  string(COMPARE LESS <string1> <string2> <output variable>)
  string(COMPARE GREATER <string1> <string2> <output variable>)
  string(ASCII <number> [<number> ...] <output variable>)
  string(CONFIGURE <string1> <output variable>
         [@ONLY] [ESCAPE_QUOTES])
  string(TOUPPER <string1> <output variable>)
  string(TOLOWER <string1> <output variable>)
  string(LENGTH <string> <output variable>)
  string(SUBSTRING <string> <begin> <length> <output variable>)
  string(STRIP <string> <output variable>)
  string(RANDOM [LENGTH <length>] [ALPHABET <alphabet>]
         <output variable>)

REGEX MATCH will match the regular expression once and store the match in the output variable.


REGEX MATCHALL will match the regular expression as many times as possible and store the matches in the output variable as a list.


REGEX REPLACE will match the regular expression as many times as possible and substitute the replacement expression for the match in the output.  The replace expression may refer to paren-delimited subexpressions of the match using \\1, \\2, ..., \\9.  Note that two backslashes (\\\\1) are required in CMake code to get a backslash through argument parsing.


REPLACE will replace all occurrences of match_string in the input with replace_string and store the result in the output.


COMPARE EQUAL/NOTEQUAL/LESS/GREATER will compare the strings and store true or false in the output variable.


ASCII will convert all numbers into corresponding ASCII characters.


CONFIGURE will transform a string like CONFIGURE_FILE transforms a file.


TOUPPER/TOLOWER will convert string to upper/lower characters.


LENGTH will return a given string's length.


SUBSTRING will return a substring of a given string.


STRIP will return a substring of a given string with leading and trailing spaces removed.


RANDOM will return a random string of given length consisting of characters from the given alphabet. Default length is 5 characters and default alphabet is all numbers and upper and lower case letters.


The following characters have special meaning in regular expressions:


   ^         Matches at beginning of a line
   $         Matches at end of a line
   .         Matches any single character
   [ ]       Matches any character(s) inside the brackets
   [^ ]      Matches any character(s) not inside the brackets
    -        Matches any character in range on either side of a dash
   *         Matches preceding pattern zero or more times
   +         Matches preceding pattern one or more times
   ?         Matches preceding pattern zero or once only
   |         Matches a pattern on either side of the |
   ()        Saves a matched subexpression, which can be referenced in the REGEX REPLACE operation. Additionally it is saved in the special CMake variables CMAKE_MATCH_(0..9).
.TP
.B target_link_libraries
Link a target to given libraries.

  target_link_libraries(target library1
                        <debug | optimized | general> library2
                        ...)

Specify a list of libraries to be linked into the specified target.  The debug and optimized strings may be used to indicate that the next library listed is to be used only for that specific type of build. general indicates it is used for all build types and is assumed if not specified.


If any library name matches that of a target in the current project a dependency will automatically be added in the build system to make sure the library being linked is up-to-date before the target links.

.TP
.B try_compile
Try compiling some code.

  try_compile(RESULT_VAR bindir srcdir
              projectName <targetname> [CMAKE_FLAGS <Flags>]
              [OUTPUT_VARIABLE var])

Try compiling a program.  In this form, srcdir should contain a complete CMake project with a CMakeLists.txt file and all sources. The bindir and srcdir will not be deleted after this command is run. If <target name> is specified then build just that target otherwise the all or ALL_BUILD target is built.


  try_compile(RESULT_VAR bindir srcfile
              [CMAKE_FLAGS <Flags>]
              [COMPILE_DEFINITIONS <flags> ...]
              [OUTPUT_VARIABLE var]
              [COPY_FILE <filename> )

Try compiling a srcfile.  In this case, the user need only supply a source file.  CMake will create the appropriate CMakeLists.txt file to build the source. If COPY_FILE is used, the compiled file will be copied to the given file.


In this version all files in bindir/CMakeFiles/CMakeTmp, will be cleaned automatically, for debugging a --debug-trycompile can be passed to cmake to avoid the clean. Some extra flags that  can be included are,  INCLUDE_DIRECTORIES, LINK_DIRECTORIES, and LINK_LIBRARIES.  COMPILE_DEFINITIONS are -Ddefinition that will be passed to the compile line.  try_compile creates a CMakeList.txt file on the fly that looks like this:


  add_definitions( <expanded COMPILE_DEFINITIONS from calling cmake>)
  include_directories(${INCLUDE_DIRECTORIES})
  link_directories(${LINK_DIRECTORIES})
  add_executable(cmTryCompileExec sources)
  target_link_libraries(cmTryCompileExec ${LINK_LIBRARIES})

In both versions of the command, if OUTPUT_VARIABLE is specified, then the output from the build process is stored in the given variable. Return the success or failure in RESULT_VAR. CMAKE_FLAGS can be used to pass -DVAR:TYPE=VALUE flags to the cmake that is run during the build. 

.TP
.B try_run
Try compiling and then running some code.

  try_run(RUN_RESULT_VAR COMPILE_RESULT_VAR
          bindir srcfile [CMAKE_FLAGS <Flags>]
          [COMPILE_DEFINITIONS <flags>]
          [COMPILE_OUTPUT_VARIABLE comp]
          [RUN_OUTPUT_VARIABLE run]
          [OUTPUT_VARIABLE var]
          [ARGS <arg1> <arg2>...])

Try compiling a srcfile.  Return TRUE or FALSE for success or failure in COMPILE_RESULT_VAR.  Then if the compile succeeded, run the executable and return its exit code in RUN_RESULT_VAR. If the executable was built, but failed to run, then RUN_RESULT_VAR will be set to FAILED_TO_RUN. COMPILE_OUTPUT_VARIABLE specifies the variable where the output from the compile step goes. RUN_OUTPUT_VARIABLE specifies the variable where the output from the running executable goes.


For compatibility reasons OUTPUT_VARIABLE is still supported, which gives you the output from the compile and run step combined.





Cross compiling issues


When cross compiling, the executable compiled in the first step usually cannot be run on the build host. try_run() checks the CMAKE_CROSSCOMPILING variable to detect whether CMake is in crosscompiling mode. If that's the case, it will still try to compile the executable, but it will not try to run the executable. Instead it will create cache variables which must be filled by the user or by presetting them in some CMake script file to the values the executable would have produced if it would have been run on its actual target platform. These variables are RUN_RESULT_VAR (explanation see above) and if RUN_OUTPUT_VARIABLE (or OUTPUT_VARIABLE) was used, an additional cache variable RUN_RESULT_VAR__COMPILE_RESULT_VAR__TRYRUN_OUTPUT.This is intended to hold stdout and stderr from the executable.


In order to make cross compiling your project easier, use try_run only if really required. If you use try_run, use RUN_OUTPUT_VARIABLE (or OUTPUT_VARIABLE) only if really required. Using them will require that when crosscompiling, the cache variables will have to be set manually to the output of the executable. You can also "guard" the calls to try_run with if(CMAKE_CROSSCOMPILING) and provide an easy-to-preset alternative for this case.


.TP
.B variable_watch
Watch the CMake variable for change.

  variable_watch(<variable name> [<command to execute>])

If the specified variable changes, the message will be printed about the variable being changed. If the command is specified, the command will be executed. The command will receive the following arguments: COMMAND(<variable> <access> <value> <current list file> <stack>)

.TP
.B while
Evaluate a group of commands while a condition is true

  while(condition)
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
  endwhile(condition)

All commands between while and the matching endwhile are recorded without being invoked.  Once the endwhile is evaluated, the recorded list of commands is invoked as long as the condition is true. The condition is evaluated using the same logic as the if command.

.SH PROPERTIES
.PP
  CMake Properties - Properties supported by CMake, the Cross-Platform Makefile Generator.
.PP
This is the documentation for the properties supported by CMake. Properties can have different scopes. They can either be assigned to a source file, a directory, a target or globally to CMake. By modifying the values of properties the behaviour of the build system can be customized.

.SH PROPERTIES OF GLOBAL SCOPE
.TP
.B ALLOW_DUPLICATE_CUSTOM_TARGETS
Allow duplicate custom targets to be created.

Normally CMake requires that all targets built in a project have globally unique logical names (see policy CMP0002).  This is necessary to generate meaningful project file names in Xcode and VS IDE generators.  It also allows the target names to be referenced unambiguously.


Makefile generators are capable of supporting duplicate custom target names.  For projects that care only about Makefile generators and do not wish to support Xcode or VS IDE generators, one may set this property to true to allow duplicate custom targets.  The property allows multiple add_custom_target command calls in different directories to specify the same target name.  However, setting this property will cause non-Makefile generators to produce an error and refuse to generate the project.

.TP
.B DISABLED_FEATURES
List of features which are disabled during the CMake run.

List of features which are disabled during the CMake run. Be default it contains the names of all packages which were not found. This is determined using the <NAME>_FOUND variables. Packages which are searched QUIET are not listed. A project can add its own features to this list.This property is used by the macros in FeatureSummary.cmake.

.TP
.B ENABLED_FEATURES
List of features which are enabled during the CMake run.

List of features which are enabled during the CMake run. Be default it contains the names of all packages which were found. This is determined using the <NAME>_FOUND variables. Packages which are searched QUIET are not listed. A project can add its own features to this list.This property is used by the macros in FeatureSummary.cmake.

.TP
.B FIND_LIBRARY_USE_LIB64_PATHS
Whether FIND_LIBRARY should automatically search lib64 directories.

FIND_LIBRARY_USE_LIB64_PATHS is a boolean specifying whether the FIND_LIBRARY command should automatically search the lib64 variant of directories called lib in the search path when building 64-bit binaries.

.TP
.B GLOBAL_DEPENDS_DEBUG_MODE
Enable global target dependency graph debug mode.

CMake automatically analyzes the global inter-target dependency graph at the beginning of native build system generation.  This property causes it to display details of its analysis to stderr.

.TP
.B IN_TRY_COMPILE
Read-only property that is true during a try-compile configuration.

True when building a project inside a TRY_COMPILE or TRY_RUN command.

.TP
.B PACKAGES_FOUND
List of packages which were found during the CMake run.

List of packages which were found during the CMake run. Whether a package has been found is determined using the <NAME>_FOUND variables.

.TP
.B PACKAGES_NOT_FOUND
List of packages which were not found during the CMake run.

List of packages which were not found during the CMake run. Whether a package has been found is determined using the <NAME>_FOUND variables.

.TP
.B REPORT_UNDEFINED_PROPERTIES
If set, report any undefined properties to this file.

If this property is set to a filename then when CMake runs it will report any properties or variables that were accessed but not defined into the filename specified in this property.

.TP
.B TARGET_ARCHIVES_MAY_BE_SHARED_LIBS
Set if shared libraries may be named like archives.

On AIX shared libraries may be named "lib<name>.a".  This property is set to true on such platforms.

.TP
.B TARGET_SUPPORTS_SHARED_LIBS
Does the target platform support shared libraries.

TARGET_SUPPORTS_SHARED_LIBS is a boolean specifying whether the target platform supports shared libraries. Basically all current general general purpose OS do so, the exception are usually embedded systems with no or special OSs.

.TP
.B __CMAKE_DELETE_CACHE_CHANGE_VARS_
Internal property

Used to detect compiler changes, Do not set.

.SH PROPERTIES ON DIRECTORIES
.TP
.B ADDITIONAL_MAKE_CLEAN_FILES
Additional files to clean during the make clean stage.

A list of files that will be cleaned as a part of the "make clean" stage. 

.TP
.B CLEAN_NO_CUSTOM
Should the output of custom commands be left.

If this is true then the outputs of custom commands for this directory will not be removed during the "make clean" stage. 

.TP
.B COMPILE_DEFINITIONS
Preprocessor definitions for compiling a directory's sources.

The COMPILE_DEFINITIONS property may be set to a list of preprocessor definitions using the syntax VAR or VAR=value.  Function-style definitions are not supported.  CMake will automatically escape the value correctly for the native build system (note that CMake language syntax may require escapes to specify some values).  This property may be set on a per-configuration basis using the name COMPILE_DEFINITIONS_<CONFIG> where <CONFIG> is an upper-case name (ex. "COMPILE_DEFINITIONS_DEBUG").  This property will be initialized in each directory by its value in the directory's parent.


CMake will automatically drop some definitions that are not supported by the native build tool.  The VS6 IDE does not support definitions with values (but NMake does).


Dislaimer: Most native build tools have poor support for escaping certain values.  CMake has work-arounds for many cases but some values may just not be possible to pass correctly.  If a value does not seem to be escaped correctly, do not attempt to work-around the problem by adding escape sequences to the value.  Your work-around may break in a future version of CMake that has improved escape support.  Instead consider defining the macro in a (configured) header file.  Then report the limitation.

.TP
.B COMPILE_DEFINITIONS_<CONFIG>
Per-configuration preprocessor definitions in a directory.

This is the configuration-specific version of COMPILE_DEFINITIONS.  This property will be initialized in each directory by its value in the directory's parent.


.TP
.B EXCLUDE_FROM_ALL
Exclude the directory from the all target of its parent.

A property on a directory that indicates if its targets are excluded from the default build target. If it is not, then with a Makefile for example typing make will cause the targets to be built. The same concept applies to the default build of other generators.

.TP
.B LISTFILE_STACK
The current stack of listfiles being processed.

This property is mainly useful when trying to debug errors in your CMake scripts. It returns a list of what list files are currently being processed, in order. So if one listfile does an INCLUDE command then that is effectively pushing the included listfile onto the stack.

.TP
.B TEST_INCLUDE_FILE
A cmake file that will be included when ctest is run.

If you specify TEST_INCLUDE_FILE, that file will be included and processed when ctest is run on the directory.

.SH PROPERTIES ON TARGETS
.TP
.B ARCHIVE_OUTPUT_DIRECTORY
Output directory in which to build ARCHIVE target files.

This property specifies the directory into which archive target files should be built. There are three kinds of target files that may be built: archive, library, and runtime.  Executables are always treated as runtime targets. Static libraries are always treated as archive targets. Module libraries are always treated as library targets. For non-DLL platforms shared libraries are treated as library targets. For DLL platforms the DLL part of a shared library is treated as a runtime target and the corresponding import library is treated as an archive target. All Windows-based systems including Cygwin are DLL platforms. This property is initialized by the value of the variable CMAKE_ARCHIVE_OUTPUT_DIRECTORY if it is set when a target is created.

.TP
.B BUILD_WITH_INSTALL_RPATH
Should build tree targets have install tree rpaths.

BUILD_WITH_INSTALL_RPATH is a boolean specifying whether to link the target in the build tree with the INSTALL_RPATH.  This takes precedence over SKIP_BUILD_RPATH and avoids the need for relinking before installation.

.TP
.B CLEAN_DIRECT_OUTPUT
Do not delete other variants of this target.

When a library is built CMake by default generates code to remove any existing library using all possible names.  This is needed to support libraries that switch between STATIC and SHARED by a user option.  However when using OUTPUT_NAME to build a static and shared library of the same name using different logical target names the two targets will remove each other's files.  This can be prevented by setting the CLEAN_DIRECT_OUTPUT property to 1.

.TP
.B COMPILE_DEFINITIONS
Preprocessor definitions for compiling a target's sources.

The COMPILE_DEFINITIONS property may be set to a list of preprocessor definitions using the syntax VAR or VAR=value.  Function-style definitions are not supported.  CMake will automatically escape the value correctly for the native build system (note that CMake language syntax may require escapes to specify some values).  This property may be set on a per-configuration basis using the name COMPILE_DEFINITIONS_<CONFIG> where <CONFIG> is an upper-case name (ex. "COMPILE_DEFINITIONS_DEBUG").


CMake will automatically drop some definitions that are not supported by the native build tool.  The VS6 IDE does not support definitions with values (but NMake does).


Dislaimer: Most native build tools have poor support for escaping certain values.  CMake has work-arounds for many cases but some values may just not be possible to pass correctly.  If a value does not seem to be escaped correctly, do not attempt to work-around the problem by adding escape sequences to the value.  Your work-around may break in a future version of CMake that has improved escape support.  Instead consider defining the macro in a (configured) header file.  Then report the limitation.

.TP
.B COMPILE_DEFINITIONS_<CONFIG>
Per-configuration preprocessor definitions on a target.

This is the configuration-specific version of COMPILE_DEFINITIONS.

.TP
.B COMPILE_FLAGS
Additional flags to use when compiling this target's sources.

The COMPILE_FLAGS property sets additional compiler flags used to build sources within the target.  Use COMPILE_DEFINITIONS to pass additional preprocessor definitions.

.TP
.B DEBUG_POSTFIX
A postfix that will be applied to this target when build debug.

A property on a target that specifies a postfix to add to the target name when built in debug mode. For example "foo.dll" versus "fooD.dll".  Ignored for Mac Frameworks and App Bundles.

.TP
.B DEFINE_SYMBOL
Define a symbol when compiling this target's sources.

DEFINE_SYMBOL sets the name of the preprocessor symbol defined when compiling sources in a shared library. If not set here then it is set to target_EXPORTS by default (with some substitutions if the target is not a valid C identifier). This is useful for headers to know whether they are being included from inside their library our outside to properly setup dllexport/dllimport decorations. 

.TP
.B ENABLE_EXPORTS
Specify whether an executable exports symbols for loadable modules.

Normally an executable does not export any symbols because it is the final program.  It is possible for an executable to export symbols to be used by loadable modules.  When this property is set to true CMake will allow other targets to "link" to the executable with the TARGET_LINK_LIBRARIES command.  On all platforms a target-level dependency on the executable is created for targets that link to it.  For non-DLL platforms the link rule is simply ignored since the dynamic loader will automatically bind symbols when the module is loaded.  For DLL platforms an import library will be created for the exported symbols and then used for linking.  All Windows-based systems including Cygwin are DLL platforms.

.TP
.B EXCLUDE_FROM_ALL
Exclude the target from the all target.

A property on a target that indicates if the target is excluded from the default build target. If it is not, then with a Makefile for example typing make will cause this target to be built. The same concept applies to the default build of other generators. Installing a target with EXCLUDE_FROM_ALL set to true has undefined behavior.

.TP
.B EchoString
A message to be displayed when the target is built.

A message to display on some generators (such as makefiles) when the target is built.

.TP
.B FRAMEWORK
This target is a framework on the Mac.

If a shared library target has this property set to true it will be built as a framework when built on the mac. It will have the directory structure required for a framework and will be suitable to be used with the -framework option

.TP
.B Fortran_MODULE_DIRECTORY
Specify output directory for Fortran modules provided by the target.

If the target contains Fortran source files that provide modules and the compiler supports a module output directory this specifies the directory in which the modules will be placed.  When this property is not set the modules will be placed in the build directory corresponding to the target's source directory.  If the variable CMAKE_Fortran_MODULE_DIRECTORY is set when a target is created its value is used to initialize this property.

.TP
.B GENERATOR_FILE_NAME
Generator's file for this target.

An internal property used by some generators to record the name of project or dsp file associated with this target.

.TP
.B HAS_CXX
Force a target to use the CXX linker.

Setting HAS_CXX on a target will force the target to use the C++ linker (and C++ runtime libraries) for linking even if the target has no C++ code in it.

.TP
.B IMPORTED
Read-only indication of whether a target is IMPORTED.

The boolean value of this property is true for targets created with the IMPORTED option to add_executable or add_library.  It is false for targets built within the project.

.TP
.B IMPORTED_CONFIGURATIONS
Configurations provided for an IMPORTED target.

Lists configuration names available for an IMPORTED target.  The names correspond to configurations defined in the project from which the target is imported.  If the importing project uses a different set of configurations the names may be mapped using the MAP_IMPORTED_CONFIG_<CONFIG> property.  Ignored for non-imported targets.

.TP
.B IMPORTED_IMPLIB
Full path to the import library for an IMPORTED target.

Specifies the location of the ".lib" part of a windows DLL.  Ignored for non-imported targets.

.TP
.B IMPORTED_IMPLIB_<CONFIG>
Per-configuration version of IMPORTED_IMPLIB property.

This property is used when loading settings for the <CONFIG> configuration of an imported target.  Configuration names correspond to those provided by the project from which the target is imported.

.TP
.B IMPORTED_LINK_DEPENDENT_LIBRARIES
Dependent shared libraries of an imported shared library.

Shared libraries may be linked to other shared libraries as part of their implementation.  On some platforms the linker searches for the dependent libraries of shared libraries they are including in the link.  This property lists the dependent shared libraries of an imported library.  The list should be disjoint from the list of interface libraries in the IMPORTED_LINK_INTERFACE_LIBRARIES property.  On platforms requiring dependent shared libraries to be found at link time CMake uses this list to add appropriate files or paths to the link command line.  Ignored for non-imported targets.

.TP
.B IMPORTED_LINK_DEPENDENT_LIBRARIES_<CONFIG>
Per-configuration version of IMPORTED_LINK_DEPENDENT_LIBRARIES.

This property is used when loading settings for the <CONFIG> configuration of an imported target.  Configuration names correspond to those provided by the project from which the target is imported.

.TP
.B IMPORTED_LINK_INTERFACE_LIBRARIES
Transitive link interface of an IMPORTED target.

Lists libraries whose interface is included when an IMPORTED library target is linked to another target.  The libraries will be included on the link line for the target.  Ignored for non-imported targets.

.TP
.B IMPORTED_LINK_INTERFACE_LIBRARIES_<CONFIG>
Per-configuration version of IMPORTED_LINK_INTERFACE_LIBRARIES.

This property is used when loading settings for the <CONFIG> configuration of an imported target.  Configuration names correspond to those provided by the project from which the target is imported.

.TP
.B IMPORTED_LOCATION
Full path to the main file on disk for an IMPORTED target.

Specifies the location of an IMPORTED target file on disk.  For executables this is the location of the executable file.  For bundles on OS X this is the location of the executable file inside Contents/MacOS under the application bundle folder.  For static libraries and modules this is the location of the library or module.  For shared libraries on non-DLL platforms this is the location of the shared library.  For frameworks on OS X this is the location of the library file symlink just inside the framework folder.  For DLLs this is the location of the ".dll" part of the library.  Ignored for non-imported targets.

.TP
.B IMPORTED_LOCATION_<CONFIG>
Per-configuration version of IMPORTED_LOCATION property.

This property is used when loading settings for the <CONFIG> configuration of an imported target.  Configuration names correspond to those provided by the project from which the target is imported.

.TP
.B IMPORTED_SONAME
The "soname" of an IMPORTED target of shared library type.

Specifies the "soname" embedded in an imported shared library.  This is meaningful only on platforms supporting the feature.  Ignored for non-imported targets.

.TP
.B IMPORTED_SONAME_<CONFIG>
Per-configuration version of IMPORTED_SONAME property.

This property is used when loading settings for the <CONFIG> configuration of an imported target.  Configuration names correspond to those provided by the project from which the target is imported.

.TP
.B IMPORT_PREFIX
What comes before the import library name.

Similar to the target property PREFIX, but used for import libraries (typically corresponding to a DLL) instead of regular libraries. A target property that can be set to override the prefix (such as "lib") on an import library name.

.TP
.B IMPORT_SUFFIX
What comes after the import library name.

Similar to the target property SUFFIX, but used for import libraries (typically corresponding to a DLL) instead of regular libraries. A target property that can be set to override the suffix (such as ".lib") on an import library name.

.TP
.B INSTALL_NAME_DIR
Mac OSX directory name for installed targets.

INSTALL_NAME_DIR is a string specifying the directory portion of the "install_name" field of shared libraries on Mac OSX to use in the installed targets. 

.TP
.B INSTALL_RPATH
The rpath to use for installed targets.

A semicolon-separated list specifying the rpath to use in installed targets (for platforms that support it).

.TP
.B INSTALL_RPATH_USE_LINK_PATH
Add paths to linker search and installed rpath.

INSTALL_RPATH_USE_LINK_PATH is a boolean that if set to true will append directories in the linker search path and outside the project to the INSTALL_RPATH. 

.TP
.B LIBRARY_OUTPUT_DIRECTORY
Output directory in which to build LIBRARY target files.

This property specifies the directory into which library target files should be built. There are three kinds of target files that may be built: archive, library, and runtime.  Executables are always treated as runtime targets. Static libraries are always treated as archive targets. Module libraries are always treated as library targets. For non-DLL platforms shared libraries are treated as library targets. For DLL platforms the DLL part of a shared library is treated as a runtime target and the corresponding import library is treated as an archive target. All Windows-based systems including Cygwin are DLL platforms. This property is initialized by the value of the variable CMAKE_LIBRARY_OUTPUT_DIRECTORY if it is set when a target is created.

.TP
.B LINKER_LANGUAGE
What tool to use for linking, based on language.

The LINKER_LANGUAGE property is used to change the tool used to link an executable or shared library. The default is set the language to match the files in the library. CXX and C are common values for this property.

.TP
.B LINK_FLAGS
Additional flags to use when linking this target.

The LINK_FLAGS property can be used to add extra flags to the link step of a target. LINK_FLAGS_<CONFIG> will add to the configuration <CONFIG>, for example, DEBUG, RELEASE, MINSIZEREL, RELWITHDEBINFO. 

.TP
.B LINK_FLAGS_<CONFIG>
Per-configuration linker flags for a target.

This is the configuration-specific version of LINK_FLAGS.

.TP
.B LINK_INTERFACE_LIBRARIES
List public interface libraries for a shared library or executable.

By default linking to a shared library target transitively links to targets with which the library itself was linked.  For an executable with exports (see the ENABLE_EXPORTS property) no default transitive link dependencies are used.  This property replaces the default transitive link dependencies with an explict list.  When the target is linked into another target the libraries listed (and recursively their link interface libraries) will be provided to the other target also.  If the list is empty then no transitive link dependencies will be incorporated when this target is linked into another target even if the default set is non-empty.

.TP
.B LINK_INTERFACE_LIBRARIES_<CONFIG>
Per-configuration list of public interface libraries for a target.

This is the configuration-specific version of LINK_INTERFACE_LIBRARIES.

.TP
.B LINK_SEARCH_END_STATIC
End a link line such that static system libraries are used.

Some linkers support switches such as -Bstatic and -Bdynamic to determine whether to use static or shared libraries for -lXXX options.  CMake uses these options to set the link type for libraries whose full paths are not known or (in some cases) are in implicit link directories for the platform.  By default the linker search type is left at -Bdynamic by the end of the library list.  This property switches the final linker search type to -Bstatic.

.TP
.B LOCATION
Deprecated.  Use LOCATION_<CONFIG> or avoid altogether.

This property is provided for compatibility with CMake 2.4 and below. It was meant to get the location of an executable target's output file for use in add_custom_command.  In CMake 2.6 and above add_custom_command automatically recognizes a target name in its COMMAND and DEPENDS options and computes the target location.  Therefore this property need not be used.  This property is not defined for IMPORTED targets because they were not available in CMake 2.4 or below anyway.

.TP
.B LOCATION_<CONFIG>
Read-only property providing a target location on disk.

A read-only property that indicates where a target's main file is located on disk for the configuration <CONFIG>.  The property is defined only for library and executable targets.

.TP
.B MACOSX_BUNDLE
Build an executable as an application bundle on Mac OS X.

When this property is set to true the executable when built on Mac OS X will be created as an application bundle.  This makes it a GUI executable that can be launched from the Finder.


The bundle Info.plist file is generated automatically.  The following target properties may be set to specify its content:  MACOSX_BUNDLE_INFO_STRING


  MACOSX_BUNDLE_ICON_FILE
  MACOSX_BUNDLE_GUI_IDENTIFIER
  MACOSX_BUNDLE_LONG_VERSION_STRING
  MACOSX_BUNDLE_BUNDLE_NAME
  MACOSX_BUNDLE_SHORT_VERSION_STRING
  MACOSX_BUNDLE_BUNDLE_VERSION
  MACOSX_BUNDLE_COPYRIGHT

.TP
.B MAP_IMPORTED_CONFIG_<CONFIG>
Map from project configuration to IMPORTED target's configuration.

List configurations of an imported target that may be used for the current project's <CONFIG> configuration.  Targets imported from another project may not provide the same set of configuration names available in the current project.  Setting this property tells CMake what imported configurations are suitable for use when building the <CONFIG> configuration.  The first configuration in the list found to be provided by the imported target is selected.  If no matching configurations are available the imported target is considered to be not found.  This property is ignored for non-imported targets.

.TP
.B OUTPUT_NAME
Sets the real name of a target when it is built.

Sets the real name of a target when it is built and can be used to help create two targets of the same name even though CMake requires unique logical target names.  There is also a <CONFIG>_OUTPUT_NAME that can set the output name on a per-configuration basis.

.TP
.B POST_INSTALL_SCRIPT
Deprecated install support.

The PRE_INSTALL_SCRIPT and POST_INSTALL_SCRIPT properties are the old way to specify CMake scripts to run before and after installing a target.  They are used only when the old INSTALL_TARGETS command is used to install the target.  Use the INSTALL command instead.

.TP
.B PREFIX
What comes before the library name.

A target property that can be set to override the prefix (such as "lib") on a library name.

.TP
.B PRE_INSTALL_SCRIPT
Deprecated install support.

The PRE_INSTALL_SCRIPT and POST_INSTALL_SCRIPT properties are the old way to specify CMake scripts to run before and after installing a target.  They are used only when the old INSTALL_TARGETS command is used to install the target.  Use the INSTALL command instead.

.TP
.B PRIVATE_HEADER
Specify private header files in a FRAMEWORK shared library target.

Shared library targets marked with the FRAMEWORK property generate frameworks on OS X and normal shared libraries on other platforms.  This property may be set to a list of header files to be placed in the PrivateHeaders directory inside the framework folder.  On non-Apple platforms these headers may be installed using the PRIVATE_HEADER option to the install(TARGETS) command.

.TP
.B PUBLIC_HEADER
Specify public header files in a FRAMEWORK shared library target.

Shared library targets marked with the FRAMEWORK property generate frameworks on OS X and normal shared libraries on other platforms.  This property may be set to a list of header files to be placed in the Headers directory inside the framework folder.  On non-Apple platforms these headers may be installed using the PUBLIC_HEADER option to the install(TARGETS) command.

.TP
.B RESOURCE
Specify resource files in a FRAMEWORK shared library target.

Shared library targets marked with the FRAMEWORK property generate frameworks on OS X and normal shared libraries on other platforms.  This property may be set to a list of files to be placed in the Resources directory inside the framework folder.  On non-Apple platforms these files may be installed using the RESOURCE option to the install(TARGETS) command.

.TP
.B RUNTIME_OUTPUT_DIRECTORY
Output directory in which to build RUNTIME target files.

This property specifies the directory into which runtime target files should be built. There are three kinds of target files that may be built: archive, library, and runtime.  Executables are always treated as runtime targets. Static libraries are always treated as archive targets. Module libraries are always treated as library targets. For non-DLL platforms shared libraries are treated as library targets. For DLL platforms the DLL part of a shared library is treated as a runtime target and the corresponding import library is treated as an archive target. All Windows-based systems including Cygwin are DLL platforms. This property is initialized by the value of the variable CMAKE_RUNTIME_OUTPUT_DIRECTORY if it is set when a target is created.

.TP
.B SKIP_BUILD_RPATH
Should rpaths be used for the build tree.

SKIP_BUILD_RPATH is a boolean specifying whether to skip automatic generation of an rpath allowing the target to run from the build tree. 

.TP
.B SOURCES
Source names specified for a target.

Read-only list of sources specified for a target.  The names returned are suitable for passing to the set_source_files_properties command.

.TP
.B SOVERSION
What version number is this target.

For shared libraries VERSION and SOVERSION can be used to specify the build version and api version respectively. When building or installing appropriate symlinks are created if the platform supports symlinks and the linker supports so-names. If only one of both is specified the missing is assumed to have the same version number. For shared libraries and executables on Windows the VERSION attribute is parsed to extract a "major.minor" version number. These numbers are used as the image version of the binary. 

.TP
.B STATIC_LIBRARY_FLAGS
Extra flags to use when linking static libraries.

Extra flags to use when linking a static library.

.TP
.B SUFFIX
What comes after the library name.

A target property that can be set to override the suffix (such as ".so") on a library name.

.TP
.B VERSION
What version number is this target.

For shared libraries VERSION and SOVERSION can be used to specify the build version and api version respectively. When building or installing appropriate symlinks are created if the platform supports symlinks and the linker supports so-names. If only one of both is specified the missing is assumed to have the same version number. For executables VERSION can be used to specify the build version. When building or installing appropriate symlinks are created if the platform supports symlinks. For shared libraries and executables on Windows the VERSION attribute is parsed to extract a "major.minor" version number. These numbers are used as the image version of the binary. 

.TP
.B WIN32_EXECUTABLE
Build an executable with a WinMain entry point on windows.

When this property is set to true the executable when linked on Windows will be created with a WinMain() entry point instead of of just main().This makes it a GUI executable instead of a console application.  See the CMAKE_MFC_FLAG variable documentation to configure use of MFC for WinMain executables.

.TP
.B XCODE_ATTRIBUTE_<an-attribute>
Set Xcode target attributes directly.

Tell the Xcode generator to set '<an-attribute>' to a given value in the generated Xcode project.  Ignored on other generators.

.SH PROPERTIES ON TESTS
.TP
.B FAIL_REGULAR_EXPRESSION
If the output matches this regular expression the test will fail.

If set, if the output matches one of specified regular expressions, the test will fail.For example: PASS_REGULAR_EXPRESSION "[^a-z]Error;ERROR;Failed"

.TP
.B MEASUREMENT
Specify a DART measurement and value to be reported for a test.

If set to a name then that name will be reported to DART as a named measurement with a value of 1. You may also specify a value by setting MEASUREMENT to "measurement=value".

.TP
.B PASS_REGULAR_EXPRESSION
The output must match this regular expression for the test to pass.

If set, the test output will be checked against the specified regular expressions and at least one of the regular expressions has to match, otherwise the test will fail.

.TP
.B TIMEOUT
How many seconds to allow for this test.

This property if set will limit a test to not take more than the specified number of seconds to run. If it exceeds that the test process will be killed and ctest will move to the next test. This setting takes precedence over DART_TESTING_TIMEOUT and CTEST_TESTING_TIMEOUT.

.TP
.B WILL_FAIL
If set to true, this will invert the pass/fail flag of the test.

This property can be used for tests that are expected to fail and return a non zero return code.

.SH PROPERTIES ON SOURCE FILES
.TP
.B ABSTRACT
Is this source file an abstract class.

A property on a source file that indicates if the source file represents a class that is abstract. This only makes sense for languages that have a notion of an abstract class and it is only used by some tools that wrap classes into other languages.

.TP
.B COMPILE_DEFINITIONS
Preprocessor definitions for compiling a source file.

The COMPILE_DEFINITIONS property may be set to a list of preprocessor definitions using the syntax VAR or VAR=value.  Function-style definitions are not supported.  CMake will automatically escape the value correctly for the native build system (note that CMake language syntax may require escapes to specify some values).  This property may be set on a per-configuration basis using the name COMPILE_DEFINITIONS_<CONFIG> where <CONFIG> is an upper-case name (ex. "COMPILE_DEFINITIONS_DEBUG").


CMake will automatically drop some definitions that are not supported by the native build tool.  The VS6 IDE does not support definitions with values (but NMake does).  Xcode does not support per-configuration definitions on source files.


Dislaimer: Most native build tools have poor support for escaping certain values.  CMake has work-arounds for many cases but some values may just not be possible to pass correctly.  If a value does not seem to be escaped correctly, do not attempt to work-around the problem by adding escape sequences to the value.  Your work-around may break in a future version of CMake that has improved escape support.  Instead consider defining the macro in a (configured) header file.  Then report the limitation.

.TP
.B COMPILE_DEFINITIONS_<CONFIG>
Per-configuration preprocessor definitions on a source file.

This is the configuration-specific version of COMPILE_DEFINITIONS.  Note that Xcode does not support per-configuration source file flags so this property will be ignored by the Xcode generator.

.TP
.B COMPILE_FLAGS
Additional flags to be added when compiling this source file.

These flags will be added to the list of compile flags when this source file builds.  Use COMPILE_DEFINITIONS to pass additional preprocessor definitions.

.TP
.B EXTERNAL_OBJECT
If set to true then this is an object file.

If this property is set to true then the source file is really an object file and should not be compiled.  It will still be linked into the target though.

.TP
.B GENERATED
Is this source file generated as part of the build process.

If a source file is generated by the build process CMake will handle it differently in temrs of dependency checking etc. Otherwise having a non-existent source file could create problems.

.TP
.B HEADER_FILE_ONLY
Is this source file only a header file.

A property on a source file that indicates if the source file is a header file with no associated implementation. This is set automatically based on the file extension and is used by CMake to determine is certain dependency information should be computed.

.TP
.B KEEP_EXTENSION
Make the output file have the same extension as the source file.

If this property is set then the file extension of the output file will be the same as that of the source file. Normally the output file extension is computed based on the language of the source file, for example .cxx will go to a .o extension.

.TP
.B LANGUAGE
What programming language is the file.

A property that can be set to indicate what programming language the source file is. If it is not set the language is determined based on the file extension. Typical values are CXX C etc.

.TP
.B LOCATION
The full path to a source file.

A read only property on a SOURCE FILE that contains the full path to the source file.

.TP
.B MACOSX_PACKAGE_LOCATION
Place a source file inside a Mac OS X bundle or framework.

Executable targets with the MACOSX_BUNDLE property set are built as Mac OS X application bundles on Apple platforms.  Shared library targets with the FRAMEWORK property set are built as Mac OS X frameworks on Apple platforms.  Source files listed in the target with this property set will be copied to a directory inside the bundle or framework content folder specified by the property value.  For bundles the content folder is "<name>.app/Contents".  For frameworks the content folder is "<name>.framework/Versions/<version>".  See the PUBLIC_HEADER, PRIVATE_HEADER, and RESOURCE target properties for specifying files meant for Headers, PrivateHeadres, or Resources directories.

.TP
.B OBJECT_DEPENDS
Additional dependencies.

Additional dependencies that should be checked as part of building this source file.

.TP
.B OBJECT_OUTPUTS
Additional outputs for a Makefile rule.

Additional outputs created by compilation of this source file. If any of these outputs is missing the object will be recompiled. This is supported only on Makefile generators and will be ignored on other generators.

.TP
.B SYMBOLIC
Is this just a name for a rule.

If SYMBOLIC (boolean) is set to true the build system will be informed that the source file is not actually created on disk but instead used as a symbolic name for a build rule.

.TP
.B WRAP_EXCLUDE
Exclude this source file from any code wrapping techniques.

Some packages can wrap source files into alternate languages to provide additional functionality. For example, C++ code can be wrapped into Java or Python etc using SWIG etc. If WRAP_EXCLUDE is set to true (1 etc) that indicates then this source file should not be wrapped.

.SH COMPATIBILITY COMMANDS
.PP
  CMake Compatibility Listfile Commands - Obsolete commands supported by CMake for compatibility.
.PP
This is the documentation for now obsolete listfile commands from previous CMake versions, which are still supported for compatibility reasons. You should instead use the newer, faster and shinier new commands. ;-)

.TP
.B build_name
Deprecated.  Use ${CMAKE_SYSTEM} and ${CMAKE_CXX_COMPILER} instead.

  build_name(variable)

Sets the specified variable to a string representing the platform and compiler settings.  These values are now available through the CMAKE_SYSTEM and CMAKE_CXX_COMPILER variables.

.TP
.B exec_program
Deprecated.  Use the execute_process() command instead.

Run an executable program during the processing of the CMakeList.txt file.


  exec_program(Executable [directory in which to run]
               [ARGS <arguments to executable>]
               [OUTPUT_VARIABLE <var>]
               [RETURN_VALUE <var>])

The executable is run in the optionally specified directory.  The executable can include arguments if it is double quoted, but it is better to use the optional ARGS argument to specify arguments to the program.   This is because cmake will then be able to escape spaces in the executable path.  An optional argument OUTPUT_VARIABLE specifies a variable in which to store the output. To capture the return value of the execution, provide a RETURN_VALUE. If OUTPUT_VARIABLE is specified, then no output will go to the stdout/stderr of the console running cmake.


.TP
.B export_library_dependencies
Deprecated.  Use INSTALL(EXPORT) or EXPORT command.

This command generates an old-style library dependencies file.  Projects requiring CMake 2.6 or later should not use the command.  Use instead the install(EXPORT) command to help export targets from an installation tree and the export() command to export targets from a build tree.


The old-style library dependencies file does not take into account per-configuration names of libraries or the LINK_INTERFACE_LIBRARIES target property.


  export_library_dependencies(<file> [APPEND])

Create a file named <file> that can be included into a CMake listfile with the INCLUDE command.  The file will contain a number of SET commands that will set all the variables needed for library dependency information.  This should be the last command in the top level CMakeLists.txt file of the project.  If the APPEND option is specified, the SET commands will be appended to the given file instead of replacing it.

.TP
.B install_files
Deprecated.  Use the install(FILES ) command instead.

This command has been superceded by the install command.  It is provided for compatibility with older CMake code.  The FILES form is directly replaced by the FILES form of the install command.  The regexp form can be expressed more clearly using the GLOB form of the file command.


  install_files(<dir> extension file file ...)

Create rules to install the listed files with the given extension into the given directory.  Only files existing in the current source tree or its corresponding location in the binary tree may be listed.  If a file specified already has an extension, that extension will be removed first.  This is useful for providing lists of source files such as foo.cxx when you want the corresponding foo.h to be installed. A typical extension is '.h'.


  install_files(<dir> regexp)

Any files in the current source directory that match the regular expression will be installed.


  install_files(<dir> FILES file file ...)

Any files listed after the FILES keyword will be installed explicitly from the names given.  Full paths are allowed in this form.


The directory <dir> is relative to the installation prefix, which is stored in the variable CMAKE_INSTALL_PREFIX.

.TP
.B install_programs
Deprecated. Use the install(PROGRAMS ) command instead.

This command has been superceded by the install command.  It is provided for compatibility with older CMake code.  The FILES form is directly replaced by the PROGRAMS form of the INSTALL command.  The regexp form can be expressed more clearly using the GLOB form of the FILE command.


  install_programs(<dir> file1 file2 [file3 ...])
  install_programs(<dir> FILES file1 [file2 ...])

Create rules to install the listed programs into the given directory. Use the FILES argument to guarantee that the file list version of the command will be used even when there is only one argument.


  install_programs(<dir> regexp)

In the second form any program in the current source directory that matches the regular expression will be installed.


This command is intended to install programs that are not built by cmake, such as shell scripts.  See the TARGETS form of the INSTALL command to create installation rules for targets built by cmake.


The directory <dir> is relative to the installation prefix, which is stored in the variable CMAKE_INSTALL_PREFIX.

.TP
.B install_targets
Deprecated. Use the install(TARGETS )  command instead.

This command has been superceded by the install command.  It is provided for compatibility with older CMake code.


  install_targets(<dir> [RUNTIME_DIRECTORY dir] target target)

Create rules to install the listed targets into the given directory.  The directory <dir> is relative to the installation prefix, which is stored in the variable CMAKE_INSTALL_PREFIX. If RUNTIME_DIRECTORY is specified, then on systems with special runtime files (Windows DLL), the files will be copied to that directory.

.TP
.B link_libraries
Deprecated. Use the target_link_libraries() command instead.

Link libraries to all targets added later.


  link_libraries(library1 <debug | optimized> library2 ...)

Specify a list of libraries to be linked into any following targets (typically added with the add_executable or add_library calls).  This command is passed down to all subdirectories.  The debug and optimized strings may be used to indicate that the next library listed is to be used only for that specific type of build.

.TP
.B make_directory
Deprecated. Use the file(MAKE_DIRECTORY ) command instead.

  make_directory(directory)

Creates the specified directory.  Full paths should be given.  Any parent directories that do not exist will also be created.  Use with care.

.TP
.B remove
Deprecated. Use the list(REMOVE_ITEM ) command instead.

  remove(VAR VALUE VALUE ...)

Removes VALUE from the variable VAR.  This is typically used to remove entries from a vector (e.g. semicolon separated list).  VALUE is expanded.

.TP
.B subdir_depends
Deprecated.  Does nothing.

  subdir_depends(subdir dep1 dep2 ...)

Does not do anything.  This command used to help projects order parallel builds correctly.  This functionality is now automatic.

.TP
.B subdirs
Deprecated. Use the add_subdirectory() command instead.

Add a list of subdirectories to the build.


  subdirs(dir1 dir2 ...[EXCLUDE_FROM_ALL exclude_dir1 exclude_dir2 ...] [PREORDER] )

Add a list of subdirectories to the build. The add_subdirectory command should be used instead of subdirs although subdirs will still work. This will cause any CMakeLists.txt files in the sub directories to be processed by CMake.  Any directories after the PREORDER flag are traversed first by makefile builds, the PREORDER flag has no effect on IDE projects.  Any directories after the EXCLUDE_FROM_ALL marker will not be included in the top level makefile or project file. This is useful for having CMake create makefiles or projects for a set of examples in a project. You would want CMake to generate makefiles or project files for all the examples at the same time, but you would not want them to show up in the top level project or be built each time make is run from the top.

.TP
.B use_mangled_mesa
Copy mesa headers for use in combination with system GL.

  use_mangled_mesa(PATH_TO_MESA OUTPUT_DIRECTORY)

The path to mesa includes, should contain gl_mangle.h.  The mesa headers are copied to the specified output directory.  This allows mangled mesa headers to override other GL headers by being added to the include directory path earlier.

.TP
.B utility_source
Specify the source tree of a third-party utility.

  utility_source(cache_entry executable_name
                 path_to_source [file1 file2 ...])

When a third-party utility's source is included in the distribution, this command specifies its location and name.  The cache entry will not be set unless the path_to_source and all listed files exist.  It is assumed that the source tree of the utility will have been built before it is needed.


When cross compiling CMake will print a warning if a utility_source() command is executed, because in many cases it is used to build an executable which is executed later on. This doesn't work when cross compiling, since the executable can run only on their target platform. So in this case the cache entry has to be adjusted manually so it points to an executable which is runnable on the build host.

.TP
.B variable_requires
Deprecated. Use the if() command instead.

Assert satisfaction of an option's required variables.


  variable_requires(TEST_VARIABLE RESULT_VARIABLE
                    REQUIRED_VARIABLE1
                    REQUIRED_VARIABLE2 ...)

The first argument (TEST_VARIABLE) is the name of the variable to be tested, if that variable is false nothing else is done. If TEST_VARIABLE is true, then the next argument (RESULT_VARIABLE) is a variable that is set to true if all the required variables are set. The rest of the arguments are variables that must be true or not set to NOTFOUND to avoid an error.  If any are not true, an error is reported.

.TP
.B write_file
Deprecated. Use the file(WRITE ) command instead.

  write_file(filename "message to write"... [APPEND])

The first argument is the file name, the rest of the arguments are messages to write. If the argument APPEND is specified, then the message will be appended.


NOTE 1: file(WRITE ... and file(APPEND ... do exactly the same as this one but add some more functionality.


NOTE 2: When using write_file the produced file cannot be used as an input to CMake (CONFIGURE_FILE, source file ...) because it will lead to an infinite loop. Use configure_file if you want to generate input files to CMake.

.SH MODULES
.PP
The following modules are provided with CMake. They can be used with INCLUDE(ModuleName).

.PP
  CMake Modules - Modules coming with CMake, the Cross-Platform Makefile Generator.
.PP
This is the documentation for the modules and scripts coming with CMake. Using these modules you can check the computer system for installed software packages, features of the compiler and the existance of headers to name just a few.

.TP
.B AddFileDependencies
ADD_FILE_DEPENDENCIES(source_file depend_files...)

Adds the given files as dependencies to source_file


.TP
.B CMakeBackwardCompatibilityCXX
define a bunch of backwards compatibility variables

  CMAKE_ANSI_CXXFLAGS - flag for ansi c++ 
  CMAKE_HAS_ANSI_STRING_STREAM - has <strstream>
  INCLUDE(TestForANSIStreamHeaders)
  INCLUDE(CheckIncludeFileCXX)
  INCLUDE(TestForSTDNamespace)
  INCLUDE(TestForANSIForScope)

.TP
.B CMakeDependentOption
Macro to provide an option dependent on other options.

This macro presents an option to the user only if a set of other conditions are true.  When the option is not presented a default value is used, but any value set by the user is preserved for when the option is presented again. Example invocation:


  CMAKE_DEPENDENT_OPTION(USE_FOO "Use Foo" ON
                         "USE_BAR;NOT USE_ZOT" OFF)

If USE_BAR is true and USE_ZOT is false, this provides an option called USE_FOO that defaults to ON.  Otherwise, it sets USE_FOO to OFF.  If the status of USE_BAR or USE_ZOT ever changes, any value for the USE_FOO option is saved so that when the option is re-enabled it retains its old value.

.TP
.B CMakeDetermineASM-ATTCompiler
 
determine the compiler to use for ASM using AT&T syntax

.TP
.B CMakeDetermineASMCompiler
 
determine the compiler to use for ASM programs

.TP
.B CMakeExportBuildSettings
export build settings from a project.

  CMAKE_EXPORT_BUILD_SETTINGS(SETTINGS_FILE)

macro defined to export the build settings for use by another project.


  SETTINGS_FILE - the file into which the settings are to be stored.

.TP
.B CMakeFindFrameworks
helper module to find OSX frameworks

.TP
.B CMakeForceCompiler
 
This module defines macros intended for use by cross-compiling toolchain files when CMake is not able to automatically detect the compiler identification.


Macro CMAKE_FORCE_C_COMPILER has the following signature:


   CMAKE_FORCE_C_COMPILER(<compiler> <compiler-id>)

It sets CMAKE_C_COMPILER to the given compiler and the cmake internal variable CMAKE_C_COMPILER_ID to the given compiler-id. It also bypasses the check for working compiler and basic compiler information tests.


Macro CMAKE_FORCE_CXX_COMPILER has the following signature:


   CMAKE_FORCE_CXX_COMPILER(<compiler> <compiler-id>)

It sets CMAKE_CXX_COMPILER to the given compiler and the cmake internal variable CMAKE_CXX_COMPILER_ID to the given compiler-id. It also bypasses the check for working compiler and basic compiler information tests.


So a simple toolchain file could look like this:


   INCLUDE (CMakeForceCompiler)
   SET(CMAKE_SYSTEM_NAME Generic)
   CMAKE_FORCE_C_COMPILER   (chc12 MetrowerksHicross)
   CMAKE_FORCE_CXX_COMPILER (chc12 MetrowerksHicross)

.TP
.B CMakeImportBuildSettings
import build settings from another project

  CMAKE_IMPORT_BUILD_SETTINGS(SETTINGS_FILE) 

macro defined to import the build settings from another project.   SETTINGS_FILE is a file created by the other project's call to the CMAKE_EXPORT_BUILD_SETTINGS macro, see CMakeExportBuildSettings.

.TP
.B CMakeJavaInformation
 
This should be included before the _INIT variables are used to initialize the cache.  Since the rule variables  have if blocks on them, users can still define them here. But, it should still be after the platform file so changes can be made to those values.

.TP
.B CMakePrintSystemInformation
print system information

This file can be used for diagnostic purposes just include it in a project to see various internal CMake variables.

.TP
.B CPack
 
Default output files will be CPackConfig.cmake and CPackSourceConfig.cmake. This can be overwritten with CPACK_OUTPUT_CONFIG_FILE and CPACK_SOURCE_OUTPUT_CONFIG_FILE.

.TP
.B CPackRPM
 
CPack script for creating RPM package Author: Eric Noulard with the help of Alexander Neundorf. All variables used by CPackRPM begins with CPACK_RPM_ prefix


Here comes the list of used variables:


.TP
.B CTest
Configure a project for testing with CTest/Dart

This file configures a project to use the CTest/Dart testing/dashboard process.  This module should be included in the CMakeLists.txt file at the top of a project.  Typical usage:


  INCLUDE(CTest)
  IF(BUILD_TESTING)
    # ... testing related CMake code ...
  ENDIF(BUILD_TESTING)

The BUILD_TESTING option is created by the CTest module to determine whether testing support should be enabled.  The default is ON.

.TP
.B CTestTestfile
 
CMake generated Testfile for  Source directory: /home/chris/cmake-2.6.0/Modules Build directory: /home/chris/cmake-2.6.0/Modules


This file replicates the SUBDIRS() and ADD_TEST() commands from the source tree CMakeLists.txt file, skipping any SUBDIRS() or ADD_TEST() commands that are excluded by CMake control structures, i.e. IF() commands.

.TP
.B CheckCCompilerFlag
Check whether the C compiler supports a given flag.

CHECK_C_COMPILER_FLAG(FLAG VARIABLE)


  FLAG - the compiler flag
  VARIABLE - variable to store the result

.TP
.B CheckCSourceCompiles
macro which checks if the source code compiles

CHECK_C_SOURCE_COMPILES(SOURCE VAR)


  SOURCE   - source code to try to compile
  VAR      - variable to store whether the source code compiled




The following variables may be set before calling this macro to modify the way the check is run:


  CMAKE_REQUIRED_FLAGS = string of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
  CMAKE_REQUIRED_LIBRARIES = list of libraries to link

.TP
.B CheckCSourceRuns
macro which checks if the source code runs

CHECK_C_SOURCE_RUNS(SOURCE VAR)


  SOURCE   - source code to try to compile
  VAR      - variable to store the result, 1 for success, empty for failure




The following variables may be set before calling this macro to modify the way the check is run:


  CMAKE_REQUIRED_FLAGS = string of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
  CMAKE_REQUIRED_LIBRARIES = list of libraries to link

.TP
.B CheckCXXCompilerFlag
Check whether the CXX compiler supports a given flag.

CHECK_CXX_COMPILER_FLAG(FLAG VARIABLE)


  FLAG - the compiler flag
  VARIABLE - variable to store the result

.TP
.B CheckCXXSourceCompiles
macro which checks if the source code compiles

CHECK_CXX_SOURCE_COMPILES(SOURCE VAR)


  SOURCE - source code to try to compile
  VAR    - variable to store whether the source code compiled




The following variables may be set before calling this macro to modify the way the check is run:


  CMAKE_REQUIRED_FLAGS = string of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
  CMAKE_REQUIRED_LIBRARIES = list of libraries to link

.TP
.B CheckCXXSourceRuns
macro which checks if the source code compiles

CHECK_CXX_SOURCE_RUNS(SOURCE VAR)


  SOURCE - source code to try to compile
  VAR    - variable to store the result, 1 for success, empty for failure




The following variables may be set before calling this macro to modify the way the check is run:


  CMAKE_REQUIRED_FLAGS = string of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
  CMAKE_REQUIRED_LIBRARIES = list of libraries to link

.TP
.B CheckFortranFunctionExists
macro which checks if the Fortran function exists

CHECK_FORTRAN_FUNCTION_EXISTS(FUNCTION VARIABLE)


  FUNCTION - the name of the Fortran function
  VARIABLE - variable to store the result




The following variables may be set before calling this macro to modify the way the check is run:


  CMAKE_REQUIRED_LIBRARIES = list of libraries to link




.TP
.B CheckFunctionExists
macro which checks if the function exists

CHECK_FUNCTION_EXISTS(FUNCTION VARIABLE)


  FUNCTION - the name of the function
  VARIABLE - variable to store the result




The following variables may be set before calling this macro to modify the way the check is run:


  CMAKE_REQUIRED_FLAGS = string of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
  CMAKE_REQUIRED_LIBRARIES = list of libraries to link

.TP
.B CheckIncludeFile
macro which checks the include file exists.

CHECK_INCLUDE_FILE(INCLUDE VARIABLE)


  INCLUDE  - name of include file
  VARIABLE - variable to return result
   

an optional third argument is the CFlags to add to the compile line  or you can use CMAKE_REQUIRED_FLAGS


The following variables may be set before calling this macro to modify the way the check is run:


  CMAKE_REQUIRED_FLAGS = string of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories




.TP
.B CheckIncludeFileCXX
Check if the include file exists.

  CHECK_INCLUDE_FILE_CXX(INCLUDE VARIABLE)




  INCLUDE  - name of include file
  VARIABLE - variable to return result
  

An optional third argument is the CFlags to add to the compile line  or you can use CMAKE_REQUIRED_FLAGS.


The following variables may be set before calling this macro to modify the way the check is run:


  CMAKE_REQUIRED_FLAGS = string of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories




.TP
.B CheckIncludeFiles
Check if the files can be included




CHECK_INCLUDE_FILES(INCLUDE VARIABLE)


  INCLUDE  - list of files to include
  VARIABLE - variable to return result




The following variables may be set before calling this macro to modify the way the check is run:


  CMAKE_REQUIRED_FLAGS = string of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories

.TP
.B CheckLibraryExists
Check if the function exists.

CHECK_LIBRARY_EXISTS (LIBRARY FUNCTION LOCATION VARIABLE)


  LIBRARY  - the name of the library you are looking for
  FUNCTION - the name of the function
  LOCATION - location where the library should be found
  VARIABLE - variable to store the result




The following variables may be set before calling this macro to modify the way the check is run:


  CMAKE_REQUIRED_FLAGS = string of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
  CMAKE_REQUIRED_LIBRARIES = list of libraries to link

.TP
.B CheckStructHasMember
Check if the given struct or class has the specified member variable

CHECK_STRUCT_HAS_MEMBER (STRUCT MEMBER HEADER VARIABLE)


  STRUCT - the name of the struct or class you are interested in
  MEMBER - the member which existence you want to check
  HEADER - the header(s) where the prototype should be declared
  VARIABLE - variable to store the result




The following variables may be set before calling this macro to modify the way the check is run:


  CMAKE_REQUIRED_FLAGS = string of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories




Example: CHECK_STRUCT_HAS_MEMBER("struct timeval" tv_sec sys/select.h HAVE_TIMEVAL_TV_SEC)

.TP
.B CheckSymbolExists
Check if the symbol exists in include files

CHECK_SYMBOL_EXISTS(SYMBOL FILES VARIABLE)


  SYMBOL   - symbol
  FILES    - include files to check
  VARIABLE - variable to return result




The following variables may be set before calling this macro to modify the way the check is run:


  CMAKE_REQUIRED_FLAGS = string of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
  CMAKE_REQUIRED_LIBRARIES = list of libraries to link

.TP
.B CheckTypeSize
Check sizeof a type

  CHECK_TYPE_SIZE(TYPE VARIABLE [BUILTIN_TYPES_ONLY])

Check if the type exists and determine size of type.  if the type exists, the size will be stored to the variable. This also calls check_include_file for sys/types.h stdint.h and stddef.h, setting HAVE_SYS_TYPES_H, HAVE_STDINT_H,  and HAVE_STDDEF_H.  This is because many types are stored in these include files.  


  VARIABLE - variable to store size if the type exists.
  HAVE_${VARIABLE} - does the variable exists or not
  BUILTIN_TYPES_ONLY - The third argument is optional and if 
                       it is set to the string BUILTIN_TYPES_ONLY
                       this macro will not check for any header files.

The following variables may be set before calling this macro to modify the way the check is run:


  CMAKE_REQUIRED_FLAGS = string of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
  CMAKE_REQUIRED_LIBRARIES = list of libraries to link

.TP
.B CheckVariableExists
Check if the variable exists.

  CHECK_VARIABLE_EXISTS(VAR VARIABLE)
  
  VAR      - the name of the variable
  VARIABLE - variable to store the result




This macro is only for C variables.


The following variables may be set before calling this macro to modify the way the check is run:


  CMAKE_REQUIRED_FLAGS = string of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
  CMAKE_REQUIRED_LIBRARIES = list of libraries to link

.TP
.B Dart
Configure a project for testing with CTest or old Dart Tcl Client

This file is the backwards-compatibility version of the CTest module. It supports using the old Dart 1 Tcl client for driving dashboard submissions as well as testing with CTest.  This module should be included in the CMakeLists.txt file at the top of a project.  Typical usage:


  INCLUDE(Dart)
  IF(BUILD_TESTING)
    # ... testing related CMake code ...
  ENDIF(BUILD_TESTING)

The BUILD_TESTING option is created by the Dart module to determine whether testing support should be enabled.  The default is ON.

.TP
.B Documentation
DocumentationVTK.cmake

This file provides support for the VTK documentation framework. It relies on several tools (Doxygen, Perl, etc).

.TP
.B FeatureSummary
Macros for generating a summary of enabled/disabled features




PRINT_ENABLED_FEATURES()


   Print a summary of all enabled features. By default all successfull
   FIND_PACKAGE() calls will appear here, except the ones which used the QUIET keyword.
   Additional features can be added by appending an entry to the global ENABLED_FEATURES
   property. If SET_FEATURE_INFO() is used for that feature, the output will be much 
   more informative.




PRINT_DISABLED_FEATURES()


   Same as PRINT_ENABLED_FEATURES(), but for disabled features. It can be extended
   the same way by adding to the global property DISABLED_FEATURES.




SET_FEATURE_INFO(NAME DESCRIPTION [URL [COMMENT] ] )


    Use this macro to set up information about the named feature, which will
    then be displayed by PRINT_ENABLED/DISABLED_FEATURES().
    Example: SET_FEATURE_INFO(LibXml2 "XML processing library." "http://xmlsoft.org/")




.TP
.B FindASPELL
Try to find ASPELL

Once done this will define


  ASPELL_FOUND - system has ASPELL
  ASPELL_INCLUDE_DIR - the ASPELL include directory
  ASPELL_LIBRARIES - The libraries needed to use ASPELL
  ASPELL_DEFINITIONS - Compiler switches required for using ASPELL

.TP
.B FindAVIFile
Locate AVIFILE library and include paths

AVIFILE (http://avifile.sourceforge.net/)is a set of libraries for  i386 machines to use various AVI codecs. Support is limited beyond Linux. Windows provides native AVI support, and so doesn't need this library. This module defines


  AVIFILE_INCLUDE_DIR, where to find avifile.h , etc.
  AVIFILE_LIBRARIES, the libraries to link against
  AVIFILE_DEFINITIONS, definitions to use when compiling
  AVIFILE_FOUND, If false, don't try to use AVIFILE

.TP
.B FindBLAS
Find BLAS library

This module finds an installed fortran library that implements the BLAS  linear-algebra interface (see http://www.netlib.org/blas/).   The list of libraries searched for is taken from the autoconf macro file, acx_blas.m4 (distributed at http://ac-archive.sourceforge.net/ac-archive/acx_blas.html).


This module sets the following variables:


  BLAS_FOUND - set to true if a library implementing the BLAS interface
    is found
  BLAS_LINKER_FLAGS - uncached list of required linker flags (excluding -l
    and -L).
  BLAS_LIBRARIES - uncached list of libraries (using full path name) to 
    link against to use BLAS
  BLAS95_LIBRARIES - uncached list of libraries (using full path name) # to link against to use BLAS95 interface




.TP
.B FindBZip2
Try to find BZip2

Once done this will define


  BZIP2_FOUND - system has BZip2
  BZIP2_INCLUDE_DIR - the BZip2 include directory
  BZIP2_LIBRARIES - Link these to use BZip2
  BZIP2_DEFINITIONS - Compiler switches required for using BZip2
  BZIP2_NEED_PREFIX - this is set if the functions are prefixed with BZ2_

.TP
.B FindBoost
Try to find Boost include dirs and libraries

Usage of this module as follows:


     SET(Boost_USE_STATIC_LIBS ON)
     SET(Boost_USE_MULTITHREAD OFF)
     FIND_PACKAGE( Boost 1.34.1 COMPONENTS date_time filesystem iostreams ... )




The Boost_ADDITIONAL_VERSIONS variable can be used to specify a list of boost version numbers that should be taken into account when searching for the libraries. Unfortunately boost puts the version number into the actual filename for the libraries, so this might be needed in the future when new Boost versions are released.


Currently this module searches for the following version numbers: 1.33, 1.33.0, 1.33.1, 1.34, 1.34.0, 1.34.1, 1.35, 1.35.0, 1.35.1, 1.36.0, 1.36.1


The components list needs to be the actual names of boost libraries, that is the part of the actual library files that differ on different libraries. So its "date_time" for "libboost_date_time...". Anything else will result in errors


You can provide a minimum version number that should be used. If you provide this  version number and specify the REQUIRED attribute, this module will fail if it can't find the specified or a later version. If you specify a version number this is automatically put into the considered list of version numbers and thus doesn't need to be specified in the Boost_ADDITIONAL_VERSIONS variable


Variables used by this module, they can change the default behaviour and need to be set before calling find_package:


  Boost_USE_MULTITHREAD         Can be set to OFF to use the non-multithreaded
                                boost libraries. Defaults to ON.
  Boost_USE_STATIC_LIBS         Can be set to ON to force the use of the static
                                boost libraries. Defaults to OFF.
  Boost_ADDITIONAL_VERSIONS     A list of version numbers to use for searching
                                the boost include directory. The default list
                                of version numbers is:
                                1.33, 1.33.0, 1.33.1, 1.34, 1.34.0, 1.34.1, 
                                1.35, 1.35.0, 1.35.1, 1.36.0, 1.36.1
                                If you want to look for an older or newer
                                version set this variable to a list of
                                strings, where each string contains a number, i.e.
                                SET(Boost_ADDITIONAL_VERSIONS "0.99.0" "1.35.0")
  BOOST_ROOT                    Preferred installation prefix for searching for Boost,
                                set this if the module has problems finding the proper Boost installation
  BOOST_INCLUDEDIR              Set this to the include directory of Boost, if the
                                module has problems finding the proper Boost installation
  BOOST_LIBRARYDIR              Set this to the lib directory of Boost, if the
                                module has problems finding the proper Boost installation




  The last three variables are available also as environment variables







Variables defined by this module:


  Boost_FOUND                          System has Boost, this means the include dir was found,
                                       as well as all the libraries specified in the COMPONENTS list
  Boost_INCLUDE_DIRS                   Boost include directories, not cached
  Boost_INCLUDE_DIR                    This is almost the same as above, but this one is cached and may be
                                       modified by advanced users
  Boost_LIBRARIES                      Link these to use the Boost libraries that you specified, not cached
  Boost_LIBRARY_DIRS                   The path to where the Boost library files are.
  Boost_VERSION                        The version number of the boost libraries that have been found,
                                       same as in version.hpp from Boost
  Boost_LIB_VERSION                    The version number in filename form as its appended to the library filenames
  Boost_MAJOR_VERSION                  major version number of boost
  Boost_MINOR_VERSION                  minor version number of boost
  Boost_SUBMINOR_VERSION               subminor version number of boost
  Boost_LIB_DIAGNOSTIC_DEFINITIONS     Only set on windows. Can be used with add_definitions 
                                       to print diagnostic information about the automatic 
                                       linking done on windows.

.TP
.B FindCABLE
Find CABLE

This module finds if CABLE is installed and determines where the include files and libraries are.  This code sets the following variables:


  CABLE             the path to the cable executable
  CABLE_TCL_LIBRARY the path to the Tcl wrapper library
  CABLE_INCLUDE_DIR the path to the include directory




To build Tcl wrappers, you should add shared library and link it to ${CABLE_TCL_LIBRARY}.  You should also add ${CABLE_INCLUDE_DIR} as an include directory.

.TP
.B FindCURL
Find curl

Find the native CURL headers and libraries.


  CURL_INCLUDE_DIRS - where to find curl/curl.h, etc.
  CURL_LIBRARIES    - List of libraries when using curl.
  CURL_FOUND        - True if curl found.

.TP
.B FindCVS
 
The module defines the following variables:


   CVS_EXECUTABLE - path to cvs command line client
   CVS_FOUND - true if the command line client was found

Example usage:


   find_package(CVS)
   if(CVS_FOUND)
     message("CVS found: ${CVS_EXECUTABLE}")
   endif(CVS_FOUND)

.TP
.B FindCups
Try to find the Cups printing system

Once done this will define


  CUPS_FOUND - system has Cups
  CUPS_INCLUDE_DIR - the Cups include directory
  CUPS_LIBRARIES - Libraries needed to use Cups
  Set CUPS_REQUIRE_IPP_DELETE_ATTRIBUTE to TRUE if you need a version which 
  features this function (i.e. at least 1.1.19)

.TP
.B FindCurses
Find the curses include file and library




  CURSES_FOUND - system has Curses
  CURSES_INCLUDE_DIR - the Curses include directory
  CURSES_LIBRARIES - The libraries needed to use Curses
  CURSES_HAVE_CURSES_H - true if curses.h is available
  CURSES_HAVE_NCURSES_H - true if ncurses.h is available
  CURSES_HAVE_NCURSES_NCURSES_H - true if ncurses/ncurses.h is available
  CURSES_HAVE_NCURSES_CURSES_H - true if ncurses/curses.h is available
  CURSES_LIBRARY - set for backwards compatibility with 2.4 CMake




Set CURSES_NEED_NCURSES to TRUE before the FIND_PACKAGE() command if NCurses  functionality is required.

.TP
.B FindCygwin
this module looks for Cygwin




.TP
.B FindDCMTK
find DCMTK libraries




.TP
.B FindDart
Find DART

This module looks for the dart testing software and sets DART_ROOT to point to where it found it.


.TP
.B FindDoxygen
This module looks for Doxygen and the path to Graphviz's dot

Doxygen is a documentation generation tool see http://www.doxygen.org With the OS X GUI version, it likes to be installed to /Applications and it contains the doxygen executable in the bundle. In the versions I've  seen, it is located in Resources, but in general, more often binaries are  located in MacOS. This code sets the following variables:


  DOXYGEN_EXECUTABLE     = The path to the doxygen command.
  DOXYGEN_DOT_EXECUTABLE = The path to the dot program used by doxygen.
  DOXYGEN_DOT_PATH       = The path to dot not including the executable
  DOXYGEN = same as DOXYGEN_EXECUTABLE for backwards compatibility
  DOT = same as DOXYGEN_DOT_EXECUTABLE for backwards compatibility

.TP
.B FindEXPAT
Find expat

Find the native EXPAT headers and libraries.


  EXPAT_INCLUDE_DIRS - where to find expat.h, etc.
  EXPAT_LIBRARIES    - List of libraries when using expat.
  EXPAT_FOUND        - True if expat found.

.TP
.B FindFLTK
Find the native FLTK includes and library

The following settings are defined


  FLTK_FLUID_EXECUTABLE, where to find the Fluid tool
  FLTK_WRAP_UI, This enables the FLTK_WRAP_UI command
  FLTK_INCLUDE_DIR, where to find include files
  FLTK_LIBRARIES, list of fltk libraries
  FLTK_FOUND, Don't use FLTK if false.

The following settings should not be used in general.


  FLTK_BASE_LIBRARY   = the full path to fltk.lib
  FLTK_GL_LIBRARY     = the full path to fltk_gl.lib
  FLTK_FORMS_LIBRARY  = the full path to fltk_forms.lib
  FLTK_IMAGES_LIBRARY = the full path to fltk_images.lib

.TP
.B FindFLTK2
Find the native FLTK2 includes and library

The following settings are defined


  FLTK2_FLUID_EXECUTABLE, where to find the Fluid tool
  FLTK2_WRAP_UI, This enables the FLTK2_WRAP_UI command
  FLTK2_INCLUDE_DIR, where to find include files
  FLTK2_LIBRARIES, list of fltk2 libraries
  FLTK2_FOUND, Don't use FLTK2 if false.

The following settings should not be used in general.


  FLTK2_BASE_LIBRARY   = the full path to fltk2.lib
  FLTK2_GL_LIBRARY     = the full path to fltk2_gl.lib
  FLTK2_IMAGES_LIBRARY = the full path to fltk2_images.lib

.TP
.B FindFreetype
Locate FreeType library

This module defines


  FREETYPE_LIBRARIES, the library to link against
  FREETYPE_FOUND, if false, do not try to link to FREETYPE
  FREETYPE_INCLUDE_DIRS, where to find headers.
  This is the concatenation of the paths:
  FREETYPE_INCLUDE_DIR_ft2build
  FREETYPE_INCLUDE_DIR_freetype2




$FREETYPE_DIR is an environment variable that would correspond to the ./configure --prefix=$FREETYPE_DIR used in building FREETYPE.

.TP
.B FindGCCXML
Find the GCC-XML front-end executable.

.TP
.B FindGDAL
 
Locate gdal This module defines GDAL_LIBRARY GDAL_FOUND, if false, do not try to link to gdal  GDAL_INCLUDE_DIR, where to find the headers


$GDALDIR is an environment variable that would correspond to the ./configure --prefix=$GDAL_DIR used in building gdal.


Created by Eric Wing. I'm not a gdal user, but OpenSceneGraph uses it  for osgTerrain so I whipped this module together for completeness. I actually don't know the conventions or where files are typically placed in distros. Any real gdal users are encouraged to correct this (but please don't break the OS X framework stuff when doing so which is what usually seems  to happen).

.TP
.B FindGIF
 
This module defines GIF_LIBRARIES - libraries to link to in order to use GIF GIF_FOUND, if false, do not try to link  GIF_INCLUDE_DIR, where to find the headers


$GIF_DIR is an environment variable that would correspond to the ./configure --prefix=$GIF_DIR

.TP
.B FindGLUT
try to find glut library and include files

  GLUT_INCLUDE_DIR, where to find GL/glut.h, etc.
  GLUT_LIBRARIES, the libraries to link against
  GLUT_FOUND, If false, do not try to use GLUT.

Also defined, but not for general use are:


  GLUT_glut_LIBRARY = the full path to the glut library.
  GLUT_Xmu_LIBRARY  = the full path to the Xmu library.
  GLUT_Xi_LIBRARY   = the full path to the Xi Library.

.TP
.B FindGTK
try to find GTK (and glib) and GTKGLArea

  GTK_INCLUDE_DIR   - Directories to include to use GTK
  GTK_LIBRARIES     - Files to link against to use GTK
  GTK_FOUND         - GTK was found
  GTK_GL_FOUND      - GTK's GL features were found

.TP
.B FindGettext
Find GNU gettext tools

This module looks for the GNU gettext tools. This module defines the  following values:


  GETTEXT_MSGMERGE_EXECUTABLE: the full path to the msgmerge tool.
  GETTEXT_MSGFMT_EXECUTABLE: the full path to the msgfmt tool.
  GETTEXT_FOUND: True if gettext has been found.




Additionally it provides the following macros: GETTEXT_CREATE_TRANSLATIONS ( outputFile [ALL] file1 ... fileN )


    This will create a target "translations" which will convert the 
    given input po files into the binary output mo file. If the 
    ALL option is used, the translations will also be created when
    building the default target.

.TP
.B FindGnuplot
this module looks for gnuplot




Once done this will define


  GNUPLOT_FOUND - system has Gnuplot
  GNUPLOT_EXECUTABLE - the Gnuplot executable

.TP
.B FindHSPELL
Try to find HSPELL

Once done this will define


  HSPELL_FOUND - system has HSPELL
  HSPELL_INCLUDE_DIR - the HSPELL include directory
  HSPELL_LIBRARIES - The libraries needed to use HSPELL
  HSPELL_DEFINITIONS - Compiler switches required for using HSPELL

.TP
.B FindHTMLHelp
This module looks for Microsoft HTML Help Compiler

It defines:


   HTML_HELP_COMPILER     : full path to the Compiler (hhc.exe)
   HTML_HELP_INCLUDE_PATH : include path to the API (htmlhelp.h)
   HTML_HELP_LIBRARY      : full path to the library (htmlhelp.lib)




.TP
.B FindITK
Find an ITK installation or build tree.

.TP
.B FindImageMagick
Find Image Magick

This module finds if ImageMagick tools are installed and determines  where the executables are. This code sets the following variables:


  IMAGEMAGICK_CONVERT_EXECUTABLE   = 
     the full path to the 'convert' utility 
  IMAGEMAGICK_MOGRIFY_EXECUTABLE   = 
     the full path to the 'mogrify' utility 
  IMAGEMAGICK_IMPORT_EXECUTABLE    = 
     the full path to the 'import'  utility 
  IMAGEMAGICK_MONTAGE_EXECUTABLE   = 
     the full path to the 'montage' utility 
  IMAGEMAGICK_COMPOSITE_EXECUTABLE = 
     the full path to the 'composite' utility 




.TP
.B FindJNI
Find JNI java libraries.

This module finds if Java is installed and determines where the include files and libraries are. It also determines what the name of the library is. This code sets the following variables:


   
  JAVA_AWT_LIB_PATH     = the path to the jawt library
  JAVA_JVM_LIB_PATH     = the path to the jvm library
  JAVA_INCLUDE_PATH     = the include path to jni.h
  JAVA_INCLUDE_PATH2    = the include path to jni_md.h
  JAVA_AWT_INCLUDE_PATH = the include path to jawt.h




.TP
.B FindJPEG
Find JPEG

Find the native JPEG includes and library This module defines


  JPEG_INCLUDE_DIR, where to find jpeglib.h, etc.
  JPEG_LIBRARIES, the libraries needed to use JPEG.
  JPEG_FOUND, If false, do not try to use JPEG.

also defined, but not for general use are


  JPEG_LIBRARY, where to find the JPEG library.

.TP
.B FindJasper
Try to find the Jasper JPEG2000 library

Once done this will define


  JASPER_FOUND - system has Jasper
  JASPER_INCLUDE_DIR - the Jasper include directory
  JASPER_LIBRARIES - The libraries needed to use Jasper

.TP
.B FindJava
Find Java

This module finds if Java is installed and determines where the include files and libraries are. This code sets the following variables:


  JAVA_RUNTIME    = the full path to the Java runtime
  JAVA_COMPILE    = the full path to the Java compiler
  JAVA_ARCHIVE    = the full path to the Java archiver




.TP
.B FindKDE3
Find the KDE3 include and library dirs, KDE preprocessors and define a some macros




This module defines the following variables:


  KDE3_DEFINITIONS         - compiler definitions required for compiling KDE software
  KDE3_INCLUDE_DIR         - the KDE include directory
  KDE3_INCLUDE_DIRS        - the KDE and the Qt include directory, for use with INCLUDE_DIRECTORIES()
  KDE3_LIB_DIR             - the directory where the KDE libraries are installed, for use with LINK_DIRECTORIES()
  QT_AND_KDECORE_LIBS      - this contains both the Qt and the kdecore library
  KDE3_DCOPIDL_EXECUTABLE  - the dcopidl executable
  KDE3_DCOPIDL2CPP_EXECUTABLE - the dcopidl2cpp executable
  KDE3_KCFGC_EXECUTABLE    - the kconfig_compiler executable
  KDE3_FOUND               - set to TRUE if all of the above has been found




The following user adjustable options are provided:


  KDE3_BUILD_TESTS - enable this to build KDE testcases







It also adds the following macros (from KDE3Macros.cmake) SRCS_VAR is always the variable which contains the list of source files for your application or library.


KDE3_AUTOMOC(file1 ... fileN)


    Call this if you want to have automatic moc file handling.
    This means if you include "foo.moc" in the source file foo.cpp
    a moc file for the header foo.h will be created automatically.
    You can set the property SKIP_AUTOMAKE using SET_SOURCE_FILES_PROPERTIES()
    to exclude some files in the list from being processed.




KDE3_ADD_MOC_FILES(SRCS_VAR file1 ... fileN )


    If you don't use the KDE3_AUTOMOC() macro, for the files
    listed here moc files will be created (named "foo.moc.cpp")




KDE3_ADD_DCOP_SKELS(SRCS_VAR header1.h ... headerN.h )


    Use this to generate DCOP skeletions from the listed headers.




KDE3_ADD_DCOP_STUBS(SRCS_VAR header1.h ... headerN.h )


     Use this to generate DCOP stubs from the listed headers.




KDE3_ADD_UI_FILES(SRCS_VAR file1.ui ... fileN.ui )


    Use this to add the Qt designer ui files to your application/library.




KDE3_ADD_KCFG_FILES(SRCS_VAR file1.kcfgc ... fileN.kcfgc )


    Use this to add KDE kconfig compiler files to your application/library.




KDE3_INSTALL_LIBTOOL_FILE(target)


    This will create and install a simple libtool file for the given target.




KDE3_ADD_EXECUTABLE(name file1 ... fileN )


    Currently identical to ADD_EXECUTABLE(), may provide some advanced features in the future.




KDE3_ADD_KPART(name [WITH_PREFIX] file1 ... fileN )


    Create a KDE plugin (KPart, kioslave, etc.) from the given source files.
    If WITH_PREFIX is given, the resulting plugin will have the prefix "lib", otherwise it won't.
    It creates and installs an appropriate libtool la-file.




KDE3_ADD_KDEINIT_EXECUTABLE(name file1 ... fileN )


    Create a KDE application in the form of a module loadable via kdeinit.
    A library named kdeinit_<name> will be created and a small executable which links to it.




The option KDE3_ENABLE_FINAL to enable all-in-one compilation is no longer supported.





Author: Alexander Neundorf <neundorf@kde.org>

.TP
.B FindKDE4
 
Find KDE4 and provide all necessary variables and macros to compile software for it. It looks for KDE 4 in the following directories in the given order:


  CMAKE_INSTALL_PREFIX
  KDEDIRS
  /opt/kde4




Please look in FindKDE4Internal.cmake and KDE4Macros.cmake for more information. They are installed with the KDE 4 libraries in $KDEDIRS/share/apps/cmake/modules/.


Author: Alexander Neundorf <neundorf@kde.org>

.TP
.B FindLAPACK
Find LAPACK library

This module finds an installed fortran library that implements the LAPACK linear-algebra interface (see http://www.netlib.org/lapack/).


The approach follows that taken for the autoconf macro file, acx_lapack.m4 (distributed at http://ac-archive.sourceforge.net/ac-archive/acx_lapack.html).


This module sets the following variables:


  LAPACK_FOUND - set to true if a library implementing the LAPACK interface
    is found
  LAPACK_LINKER_FLAGS - uncached list of required linker flags (excluding -l
    and -L).
  LAPACK_LIBRARIES - uncached list of libraries (using full path name) to 
    link against to use LAPACK
  LAPACK95_LIBRARIES - uncached list of libraries (using full path name) to 
    link against to use LAPACK95

.TP
.B FindLATEX
Find Latex

This module finds if Latex is installed and determines where the executables are. This code sets the following variables:


  
  LATEX_COMPILER:       path to the LaTeX compiler
  PDFLATEX_COMPILER:    path to the PdfLaTeX compiler
  BIBTEX_COMPILER:      path to the BibTeX compiler
  MAKEINDEX_COMPILER:   path to the MakeIndex compiler
  DVIPS_CONVERTER:      path to the DVIPS converter
  PS2PDF_CONVERTER:     path to the PS2PDF converter
  LATEX2HTML_CONVERTER: path to the LaTeX2Html converter 




.TP
.B FindLibXml2
Try to find LibXml2

Once done this will define


  LIBXML2_FOUND - system has LibXml2
  LIBXML2_INCLUDE_DIR - the LibXml2 include directory
  LIBXML2_LIBRARIES - the libraries needed to use LibXml2
  LIBXML2_DEFINITIONS - Compiler switches required for using LibXml2

.TP
.B FindLibXslt
Try to find LibXslt

Once done this will define


  LIBXSLT_FOUND - system has LibXslt
  LIBXSLT_INCLUDE_DIR - the LibXslt include directory
  LIBXSLT_LIBRARIES - Link these to LibXslt
  LIBXSLT_DEFINITIONS - Compiler switches required for using LibXslt

.TP
.B FindLua50
 
Locate Lua library This module defines


  LUA_LIBRARIES, both lua and lualib
  LUA_FOUND, if false, do not try to link to Lua 
  LUA_INCLUDE_DIR, where to find lua.h and lualib.h (and probably lauxlib.h)




Note that the expected include convention is


  #include "lua.h"

and not


  #include <lua/lua.h>

This is because, the lua location is not standardized and may exist in locations other than lua/

.TP
.B FindLua51
 
Locate Lua library This module defines


  LUA_LIBRARIES
  LUA_FOUND, if false, do not try to link to Lua 
  LUA_INCLUDE_DIR, where to find lua.h 




Note that the expected include convention is


  #include "lua.h"

and not


  #include <lua/lua.h>

This is because, the lua location is not standardized and may exist in locations other than lua/

.TP
.B FindMFC
Find MFC on Windows

Find the native MFC - i.e. decide if this is an MS VC box.


  MFC_FOUND - Was MFC support found

You don't need to include anything or link anything to use it.

.TP
.B FindMPEG
Find the native MPEG includes and library

This module defines


  MPEG_INCLUDE_DIR, where to find MPEG.h, etc.
  MPEG_LIBRARIES, the libraries required to use MPEG.
  MPEG_FOUND, If false, do not try to use MPEG.

also defined, but not for general use are


  MPEG_mpeg2_LIBRARY, where to find the MPEG library.
  MPEG_vo_LIBRARY, where to find the vo library.

.TP
.B FindMPEG2
Find the native MPEG2 includes and library

This module defines


  MPEG2_INCLUDE_DIR, path to mpeg2dec/mpeg2.h, etc.
  MPEG2_LIBRARIES, the libraries required to use MPEG2.
  MPEG2_FOUND, If false, do not try to use MPEG2.

also defined, but not for general use are


  MPEG2_mpeg2_LIBRARY, where to find the MPEG2 library.
  MPEG2_vo_LIBRARY, where to find the vo library.

.TP
.B FindMPI
Message Passing Interface (MPI) module.




The Message Passing Interface (MPI) is a library used to write high-performance parallel applications that use message passing, and is typically deployed on a cluster. MPI is a standard interface (defined by the MPI forum) for which many implementations are available. All of these implementations have somewhat different compilation approaches (different include paths, libraries to link against, etc.), and this module tries to smooth out those differences.


This module will set the following variables:


   MPI_FOUND                  TRUE if we have found MPI
   MPI_COMPILE_FLAGS          Compilation flags for MPI programs
   MPI_INCLUDE_PATH           Include path(s) for MPI header
   MPI_LINK_FLAGS             Linking flags for MPI programs
   MPI_LIBRARY                First MPI library to link against (cached)
   MPI_EXTRA_LIBRARY          Extra MPI libraries to link against (cached)
   MPI_LIBRARIES              All libraries to link MPI programs against
   MPIEXEC                    Executable for running MPI programs
   MPIEXEC_NUMPROC_FLAG       Flag to pass to MPIEXEC before giving it the
                              number of processors to run on
   MPIEXEC_PREFLAGS           Flags to pass to MPIEXEC directly before the
                              executable to run.
   MPIEXEC_POSTFLAGS          Flags to pass to MPIEXEC after all other flags.




This module will attempt to auto-detect these settings, first by looking for a MPI compiler, which many MPI implementations provide as a pass-through to the native compiler to simplify the compilation of MPI programs. The MPI compiler is stored in the cache variable MPI_COMPILER, and will attempt to look for commonly-named drivers mpic++, mpicxx, mpiCC, or mpicc. If the compiler driver is found and recognized, it will be used to set all of the module variables. To skip this auto-detection, set MPI_LIBRARY and MPI_INCLUDE_PATH in the CMake cache.


If no compiler driver is found or the compiler driver is not recognized, this module will then search for common include paths and library names to try to detect MPI. 


If CMake initially finds a different MPI than was intended, and you want to use the MPI compiler auto-detection for a different MPI implementation, set MPI_COMPILER to the MPI compiler driver you want to use (e.g., mpicxx) and then set MPI_LIBRARY to the string MPI_LIBRARY-NOTFOUND. When you re-configure, auto-detection of MPI will run again with the newly-specified MPI_COMPILER.


When using MPIEXEC to execute MPI applications, you should typically use all of the MPIEXEC flags as follows:


   ${MPIEXEC} ${MPIEXEC_NUMPROC_FLAG} PROCS ${MPIEXEC_PREFLAGS} EXECUTABLE
     ${MPIEXEC_POSTFLAGS} ARGS

where PROCS is the number of processors on which to execute the program, EXECUTABLE is the MPI program, and ARGS are the arguments to pass to the  MPI program.

.TP
.B FindMatlab
this module looks for Matlab

Defines:


  MATLAB_INCLUDE_DIR: include path for mex.h, engine.h
  MATLAB_LIBRARIES:   required libraries: libmex, etc
  MATLAB_MEX_LIBRARY: path to libmex.lib
  MATLAB_MX_LIBRARY:  path to libmx.lib
  MATLAB_ENG_LIBRARY: path to libeng.lib

.TP
.B FindMotif
Try to find Motif (or lesstif)

Once done this will define:


  MOTIF_FOUND        - system has MOTIF
  MOTIF_INCLUDE_DIR  - incude paths to use Motif
  MOTIF_LIBRARIES    - Link these to use Motif

.TP
.B FindOpenAL
 
Locate OpenAL This module defines OPENAL_LIBRARY OPENAL_FOUND, if false, do not try to link to OpenAL  OPENAL_INCLUDE_DIR, where to find the headers


$OPENALDIR is an environment variable that would correspond to the ./configure --prefix=$OPENALDIR used in building OpenAL.


Created by Eric Wing. This was influenced by the FindSDL.cmake module.

.TP
.B FindOpenGL
Try to find OpenGL

Once done this will define


  
  OPENGL_FOUND        - system has OpenGL
  OPENGL_XMESA_FOUND  - system has XMESA
  OPENGL_GLU_FOUND    - system has GLU
  OPENGL_INCLUDE_DIR  - the GL include directory
  OPENGL_LIBRARIES    - Link these to use OpenGL and GLU
   

If you want to use just GL you can use these values


  OPENGL_gl_LIBRARY   - Path to OpenGL Library
  OPENGL_glu_LIBRARY  - Path to GLU Library
  

On OSX default to using the framework version of opengl People will have to change the cache values of OPENGL_glu_LIBRARY  and OPENGL_gl_LIBRARY to use OpenGL with X11 on OSX

.TP
.B FindOpenSSL
Try to find the OpenSSL encryption library

Once done this will define


  OPENSSL_FOUND - system has the OpenSSL library
  OPENSSL_INCLUDE_DIR - the OpenSSL include directory
  OPENSSL_LIBRARIES - The libraries needed to use OpenSSL

.TP
.B FindOpenThreads
 
OpenThreads is a C++ based threading library. Its largest userbase  seems to OpenSceneGraph so you might notice I accept OSGDIR as an environment path. I consider this part of the Findosg* suite used to find OpenSceneGraph  components. Each component is separate and you must opt in to each module.


Locate OpenThreads This module defines OPENTHREADS_LIBRARY OPENTHREADS_FOUND, if false, do not try to link to OpenThreads OPENTHREADS_INCLUDE_DIR, where to find the headers


$OPENTHREADS_DIR is an environment variable that would correspond to the ./configure --prefix=$OPENTHREADS_DIR used in building osg.


Created by Eric Wing.

.TP
.B FindPHP4
Find PHP4

This module finds if PHP4 is installed and determines where the include files and libraries are. It also determines what the name of the library is. This code sets the following variables:


  PHP4_INCLUDE_PATH       = path to where php.h can be found
  PHP4_EXECUTABLE         = full path to the php4 binary




.TP
.B FindPNG
Find the native PNG includes and library




This module defines


  PNG_INCLUDE_DIR, where to find png.h, etc.
  PNG_LIBRARIES, the libraries to link against to use PNG.
  PNG_DEFINITIONS - You should ADD_DEFINITONS(${PNG_DEFINITIONS}) before compiling code that includes png library files.
  PNG_FOUND, If false, do not try to use PNG.

also defined, but not for general use are


  PNG_LIBRARY, where to find the PNG library.

None of the above will be defined unles zlib can be found. PNG depends on Zlib

.TP
.B FindPackageHandleStandardArgs
 
FIND_PACKAGE_HANDLE_STANDARD_ARGS(NAME (DEFAULT_MSG|"Custom failure message") VAR1 ... )


    This macro is intended to be used in FindXXX.cmake modules files.
    It handles the REQUIRED and QUIET argument to FIND_PACKAGE() and
    it also sets the <UPPERCASED_NAME>_FOUND variable.
    The package is found if all variables listed are TRUE.
    Example:




    FIND_PACKAGE_HANDLE_STANDARD_ARGS(LibXml2 DEFAULT_MSG LIBXML2_LIBRARIES LIBXML2_INCLUDE_DIR)




    LibXml2 is considered to be found, if both LIBXML2_LIBRARIES and 
    LIBXML2_INCLUDE_DIR are valid. Then also LIBXML2_FOUND is set to TRUE.
    If it is not found and REQUIRED was used, it fails with FATAL_ERROR, 
    independent whether QUIET was used or not.
    If it is found, the location is reported using the VAR1 argument, so 
    here a message "Found LibXml2: /usr/lib/libxml2.so" will be printed out.
    If the second argument is DEFAULT_MSG, the message in the failure case will 
    be "Could NOT find LibXml2", if you don't like this message you can specify
    your own custom failure message there.

.TP
.B FindPackageMessage
 
FIND_PACKAGE_MESSAGE(<name> "message for user" "find result details")


This macro is intended to be used in FindXXX.cmake modules files. It will print a message once for each unique find result. This is useful for telling the user where a package was found. The first argument specifies the name (XXX) of the package. The second argument specifies the message to display. The third argument lists details about the find result so that if they change the message will be displayed again. The macro also obeys the QUIET argument to the find_package command.


Example:


  IF(X11_FOUND)
    FIND_PACKAGE_MESSAGE(X11 "Found X11: ${X11_X11_LIB}"
      "[${X11_X11_LIB}][${X11_INCLUDE_DIR}]")
  ELSE(X11_FOUND)
   ...
  ENDIF(X11_FOUND)

.TP
.B FindPerl
Find perl

this module looks for Perl


  PERL_EXECUTABLE - the full path to perl
  PERL_FOUND      - If false, don't attempt to use perl.

.TP
.B FindPerlLibs
Find Perl libraries

This module finds if PERL is installed and determines where the include files and libraries are. It also determines what the name of the library is. This code sets the following variables:


  PERL_INCLUDE_PATH = path to where perl.h is found
  PERL_EXECUTABLE   = full path to the perl binary




.TP
.B FindPhysFS
 
Locate PhysFS library This module defines PHYSFS_LIBRARY, the name of the library to link against PHYSFS_FOUND, if false, do not try to link to PHYSFS PHYSFS_INCLUDE_DIR, where to find physfs.h


$PHYSFSDIR is an environment variable that would correspond to the ./configure --prefix=$PHYSFSDIR used in building PHYSFS.


Created by Eric Wing. 

.TP
.B FindPike
Find Pike

This module finds if PIKE is installed and determines where the include files and libraries are. It also determines what the name of the library is. This code sets the following variables:


  PIKE_INCLUDE_PATH       = path to where program.h is found
  PIKE_EXECUTABLE         = full path to the pike binary




.TP
.B FindPkgConfig
a pkg-config module for CMake




Usage:


   pkg_check_modules(<PREFIX> [REQUIRED] <MODULE> [<MODULE>]*)
     checks for all the given modules




   pkg_search_module(<PREFIX> [REQUIRED] <MODULE> [<MODULE>]*)
     checks for given modules and uses the first working one




When the 'REQUIRED' argument was set, macros will fail with an error when module(s) could not be found


It sets the following variables:


   PKG_CONFIG_FOUND         ... true if pkg-config works on the system
   PKG_CONFIG_EXECUTABLE    ... pathname of the pkg-config program
   <PREFIX>_FOUND           ... set to 1 if module(s) exist




For the following variables two sets of values exist; first one is the common one and has the given PREFIX. The second set contains flags which are given out when pkgconfig was called with the '--static' option.


   <XPREFIX>_LIBRARIES      ... only the libraries (w/o the '-l')
   <XPREFIX>_LIBRARY_DIRS   ... the paths of the libraries (w/o the '-L')
   <XPREFIX>_LDFLAGS        ... all required linker flags
   <XPREFIX>_LDFLAGS_OTHER  ... all other linker flags
   <XPREFIX>_INCLUDE_DIRS   ... the '-I' preprocessor flags (w/o the '-I')
   <XPREFIX>_CFLAGS         ... all required cflags
   <XPREFIX>_CFLAGS_OTHER   ... the other compiler flags




   <XPREFIX> = <PREFIX>        for common case
   <XPREFIX> = <PREFIX>_STATIC for static linking




There are some special variables whose prefix depends on the count of given modules. When there is only one module, <PREFIX> stays unchanged. When there are multiple modules, the prefix will be changed to <PREFIX>_<MODNAME>:


   <XPREFIX>_VERSION    ... version of the module
   <XPREFIX>_PREFIX     ... prefix-directory of the module
   <XPREFIX>_INCLUDEDIR ... include-dir of the module
   <XPREFIX>_LIBDIR     ... lib-dir of the module




   <XPREFIX> = <PREFIX>  when |MODULES| == 1, else
   <XPREFIX> = <PREFIX>_<MODNAME>




A <MODULE> parameter can have the following formats:


   {MODNAME}            ... matches any version
   {MODNAME}>={VERSION} ... at least version <VERSION> is required
   {MODNAME}={VERSION}  ... exactly version <VERSION> is required
   {MODNAME}<={VERSION} ... modules must not be newer than <VERSION>




Examples


   pkg_check_modules (GLIB2   glib-2.0)




   pkg_check_modules (GLIB2   glib-2.0>=2.10)
     requires at least version 2.10 of glib2 and defines e.g.
       GLIB2_VERSION=2.10.3




   pkg_check_modules (FOO     glib-2.0>=2.10 gtk+-2.0)
     requires both glib2 and gtk2, and defines e.g.
       FOO_glib-2.0_VERSION=2.10.3
       FOO_gtk+-2.0_VERSION=2.8.20




   pkg_check_modules (XRENDER REQUIRED xrender)
     defines e.g.:
       XRENDER_LIBRARIES=Xrender;X11
       XRENDER_STATIC_LIBRARIES=Xrender;X11;pthread;Xau;Xdmcp




   pkg_search_module (BAR     libxml-2.0 libxml2 libxml>=2)

.TP
.B FindProducer
 
Though Producer isn't directly part of OpenSceneGraph, its primary user is OSG so I consider this part of the Findosg* suite used to find  OpenSceneGraph components. You'll notice that I accept OSGDIR as an environment path.


Each component is separate and you must opt in to each module. You must  also opt into OpenGL (and OpenThreads?) as these  modules won't do it for you. This is to allow you control over your own  system piece by piece in case you need to opt out of certain components or change the Find behavior for a particular module (perhaps because the default FindOpenGL.cmake module doesn't work with your system as an example). If you want to use a more convenient module that includes everything, use the FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.


Locate Producer This module defines PRODUCER_LIBRARY PRODUCER_FOUND, if false, do not try to link to Producer PRODUCER_INCLUDE_DIR, where to find the headers


$PRODUCER_DIR is an environment variable that would correspond to the ./configure --prefix=$PRODUCER_DIR used in building osg.


Created by Eric Wing.

.TP
.B FindPythonInterp
Find python interpreter

This module finds if Python interpreter is installed and determines where the executables are. This code sets the following variables:


  PYTHONINTERP_FOUND - Was the Python executable found
  PYTHON_EXECUTABLE  - path to the Python interpreter




.TP
.B FindPythonLibs
Find python libraries

This module finds if Python is installed and determines where the include files and libraries are. It also determines what the name of the library is. This code sets the following variables:


  PYTHONLIBS_FOUND     = have the Python libs been found
  PYTHON_LIBRARIES     = path to the python library
  PYTHON_INCLUDE_PATH  = path to where Python.h is found
  PYTHON_DEBUG_LIBRARIES = path to the debug library




.TP
.B FindQt
Searches for all installed versions of QT.

This should only be used if your project can work with multiple versions of QT.  If not, you should just directly use FindQt4 or FindQt3. If multiple versions of QT are found on the machine, then The user must set the option DESIRED_QT_VERSION to the version they want to use.  If only one version of qt is found on the machine, then the DESIRED_QT_VERSION is set to that version and the  matching FindQt3 or FindQt4 module is included. Once the user sets DESIRED_QT_VERSION, then the FindQt3 or FindQt4 module is included.


  QT_REQUIRED if this is set to TRUE then if CMake can 
              not find QT4 or QT3 an error is raised 
              and a message is sent to the user.




  DESIRED_QT_VERSION OPTION is created
  QT4_INSTALLED is set to TRUE if qt4 is found.
  QT3_INSTALLED is set to TRUE if qt3 is found.

.TP
.B FindQt3
Locate Qt include paths and libraries

This module defines:


  QT_INCLUDE_DIR - where to find qt.h, etc.
  QT_LIBRARIES   - the libraries to link against to use Qt.
  QT_DEFINITIONS - definitions to use when
                   compiling code that uses Qt.
  QT_FOUND       - If false, don't try to use Qt.




If you need the multithreaded version of Qt, set QT_MT_REQUIRED to TRUE


Also defined, but not for general use are:


  QT_MOC_EXECUTABLE, where to find the moc tool.
  QT_UIC_EXECUTABLE, where to find the uic tool.
  QT_QT_LIBRARY, where to find the Qt library.
  QT_QTMAIN_LIBRARY, where to find the qtmain
   library. This is only required by Qt3 on Windows.

.TP
.B FindQt4
Find QT 4

This module can be used to find Qt4. The most important issue is that the Qt4 qmake is available via the system path. This qmake is then used to detect basically everything else. This module defines a number of key variables and macros.  First is QT_USE_FILE which is the path to a CMake file that can be included  to compile Qt 4 applications and libraries.  By default, the QtCore and QtGui  libraries are loaded. This behavior can be changed by setting one or more  of the following variables to true before doing INCLUDE(${QT_USE_FILE}):


                    QT_DONT_USE_QTCORE
                    QT_DONT_USE_QTGUI
                    QT_USE_QT3SUPPORT
                    QT_USE_QTASSISTANT
                    QT_USE_QTDESIGNER
                    QT_USE_QTMOTIF
                    QT_USE_QTMAIN
                    QT_USE_QTNETWORK
                    QT_USE_QTNSPLUGIN
                    QT_USE_QTOPENGL
                    QT_USE_QTSQL
                    QT_USE_QTXML
                    QT_USE_QTSVG
                    QT_USE_QTTEST
                    QT_USE_QTUITOOLS
                    QT_USE_QTDBUS
                    QT_USE_QTSCRIPT
                    QT_USE_QTASSISTANTCLIENT
                    QT_USE_QTHELP
                    QT_USE_QTWEBKIT
                    QT_USE_QTXMLPATTERNS
                    QT_USE_PHONON




The file pointed to by QT_USE_FILE will set up your compile environment by adding include directories, preprocessor defines, and populate a QT_LIBRARIES variable containing all the Qt libraries and their dependencies. Add the QT_LIBRARIES variable to your TARGET_LINK_LIBRARIES.


Typical usage could be something like:


   FIND_PACKAGE(Qt4)
   SET(QT_USE_QTXML 1)
   INCLUDE(${QT_USE_FILE})
   ADD_EXECUTABLE(myexe main.cpp)
   TARGET_LINK_LIBRARIES(myexe ${QT_LIBRARIES})







There are also some files that need processing by some Qt tools such as moc and uic.  Listed below are macros that may be used to process those files.


  
  macro QT4_WRAP_CPP(outfiles inputfile ... OPTIONS ...)
        create moc code from a list of files containing Qt class with
        the Q_OBJECT declaration.  Options may be given to moc, such as those found
        when executing "moc -help"




  macro QT4_WRAP_UI(outfiles inputfile ... OPTIONS ...)
        create code from a list of Qt designer ui files.
        Options may be given to uic, such as those found
        when executing "uic -help"




  macro QT4_ADD_RESOURCES(outfiles inputfile ... OPTIONS ...)
        create code from a list of Qt resource files.
        Options may be given to rcc, such as those found
        when executing "rcc -help"




  macro QT4_GENERATE_MOC(inputfile outputfile )
        creates a rule to run moc on infile and create outfile.
        Use this if for some reason QT4_WRAP_CPP() isn't appropriate, e.g.
        because you need a custom filename for the moc file or something similar.




  macro QT4_AUTOMOC(sourcefile1 sourcefile2 ... )
        This macro is still experimental.
        It can be used to have moc automatically handled.
        So if you have the files foo.h and foo.cpp, and in foo.h a 
        a class uses the Q_OBJECT macro, moc has to run on it. If you don't
        want to use QT4_WRAP_CPP() (which is reliable and mature), you can insert
        #include "foo.moc"
        in foo.cpp and then give foo.cpp as argument to QT4_AUTOMOC(). This will the
        scan all listed files at cmake-time for such included moc files and if it finds
        them cause a rule to be generated to run moc at build time on the 
        accompanying header file foo.h.
        If a source file has the SKIP_AUTOMOC property set it will be ignored by this macro.




  macro QT4_ADD_DBUS_INTERFACE(outfiles interface basename)
        create a the interface header and implementation files with the 
        given basename from the given interface xml file and add it to 
        the list of sources




  macro QT4_ADD_DBUS_INTERFACES(outfiles inputfile ... )
        create the interface header and implementation files 
        for all listed interface xml files
        the name will be automatically determined from the name of the xml file




  macro QT4_ADD_DBUS_ADAPTOR(outfiles xmlfile parentheader parentclassname [basename] )
        create a dbus adaptor (header and implementation file) from the xml file
        describing the interface, and add it to the list of sources. The adaptor
        forwards the calls to a parent class, defined in parentheader and named
        parentclassname. The name of the generated files will be
        <basename>adaptor.{cpp,h} where basename is the basename of the xml file.




  macro QT4_GENERATE_DBUS_INTERFACE( header [interfacename] )
        generate the xml interface file from the given header.
        If the optional argument interfacename is omitted, the name of the 
        interface file is constructed from the basename of the header with
        the suffix .xml appended.




  macro QT4_CREATE_TRANSLATION( qm_files sources ... ts_files ... )
        out: qm_files
        in:  sources ts_files
        generates commands to create .ts (vie lupdate) and .qm
        (via lrelease) - files from sources. The ts files are 
        created and/or updated in the source tree (unless given with full paths).
        The qm files are generated in the build tree.
        Updating the translations can be done by adding the qm_files
        to the source list of your library/executable, so they are
        always updated, or by adding a custom target to control when
        they get updated/generated.




  macro QT4_ADD_TRANSLATION( qm_files ts_files ... )
        out: qm_files
        in:  ts_files
        generates commands to create .qm from .ts - files. The generated
        filenames can be found in qm_files. The ts_files
        must exists and are not updated in any way.







  QT_FOUND         If false, don't try to use Qt.
  QT4_FOUND        If false, don't try to use Qt 4.




  QT_VERSION_MAJOR The major version of Qt found.
  QT_VERSION_MINOR The minor version of Qt found.
  QT_VERSION_PATCH The patch version of Qt found.




  QT_EDITION               Set to the edition of Qt (i.e. DesktopLight)
  QT_EDITION_DESKTOPLIGHT  True if QT_EDITION == DesktopLight
  QT_QTCORE_FOUND          True if QtCore was found.
  QT_QTGUI_FOUND           True if QtGui was found.
  QT_QT3SUPPORT_FOUND      True if Qt3Support was found.
  QT_QTASSISTANT_FOUND     True if QtAssistant was found.
  QT_QTDBUS_FOUND          True if QtDBus was found.
  QT_QTDESIGNER_FOUND      True if QtDesigner was found.
  QT_QTDESIGNERCOMPONENTS  True if QtDesignerComponents was found.
  QT_QTMOTIF_FOUND         True if QtMotif was found.
  QT_QTNETWORK_FOUND       True if QtNetwork was found.
  QT_QTNSPLUGIN_FOUND      True if QtNsPlugin was found.
  QT_QTOPENGL_FOUND        True if QtOpenGL was found.
  QT_QTSQL_FOUND           True if QtSql was found.
  QT_QTXML_FOUND           True if QtXml was found.
  QT_QTSVG_FOUND           True if QtSvg was found.
  QT_QTSCRIPT_FOUND        True if QtScript was found.
  QT_QTTEST_FOUND          True if QtTest was found.
  QT_QTUITOOLS_FOUND       True if QtUiTools was found.
  QT_QTASSISTANTCLIENT_FOUND  True if QtAssistantClient was found.
  QT_QTHELP_FOUND          True if QtHelp was found.
  QT_QTWEBKIT_FOUND        True if QtWebKit was found.
  QT_QTXMLPATTERNS_FOUND   True if QtXmlPatterns was found.
  QT_PHONON_FOUND          True if phonon was found.







  QT_DEFINITIONS   Definitions to use when compiling code that uses Qt.
                   You do not need to use this if you include QT_USE_FILE.
                   The QT_USE_FILE will also define QT_DEBUG and QT_NO_DEBUG
                   to fit your current build type.  Those are not contained
                   in QT_DEFINITIONS.
                  
  QT_INCLUDES      List of paths to all include directories of 
                   Qt4 QT_INCLUDE_DIR and QT_QTCORE_INCLUDE_DIR are
                   always in this variable even if NOTFOUND,
                   all other INCLUDE_DIRS are
                   only added if they are found.
                   You do not need to use this if you include QT_USE_FILE.
   




  Include directories for the Qt modules are listed here.
  You do not need to use these variables if you include QT_USE_FILE.




  QT_INCLUDE_DIR              Path to "include" of Qt4
  QT_QT_INCLUDE_DIR           Path to "include/Qt" 
  QT_QT3SUPPORT_INCLUDE_DIR   Path to "include/Qt3Support" 
  QT_QTASSISTANT_INCLUDE_DIR  Path to "include/QtAssistant" 
  QT_QTCORE_INCLUDE_DIR       Path to "include/QtCore"         
  QT_QTDESIGNER_INCLUDE_DIR   Path to "include/QtDesigner" 
  QT_QTDESIGNERCOMPONENTS_INCLUDE_DIR   Path to "include/QtDesigner"
  QT_QTDBUS_INCLUDE_DIR       Path to "include/QtDBus" 
  QT_QTGUI_INCLUDE_DIR        Path to "include/QtGui" 
  QT_QTMOTIF_INCLUDE_DIR      Path to "include/QtMotif" 
  QT_QTNETWORK_INCLUDE_DIR    Path to "include/QtNetwork" 
  QT_QTNSPLUGIN_INCLUDE_DIR   Path to "include/QtNsPlugin" 
  QT_QTOPENGL_INCLUDE_DIR     Path to "include/QtOpenGL" 
  QT_QTSQL_INCLUDE_DIR        Path to "include/QtSql" 
  QT_QTXML_INCLUDE_DIR        Path to "include/QtXml" 
  QT_QTSVG_INCLUDE_DIR        Path to "include/QtSvg"
  QT_QTSCRIPT_INCLUDE_DIR     Path to "include/QtScript"
  QT_QTTEST_INCLUDE_DIR       Path to "include/QtTest"
  QT_QTASSISTANTCLIENT_INCLUDE_DIR       Path to "include/QtAssistant"
  QT_QTHELP_INCLUDE_DIR       Path to "include/QtHelp"
  QT_QTWEBKIT_INCLUDE_DIR     Path to "include/QtWebKit"
  QT_QTXMLPATTERNS_INCLUDE_DIR  Path to "include/QtXmlPatterns"
  QT_PHONON_INCLUDE_DIR       Path to "include/phonon"
                            
  QT_LIBRARY_DIR              Path to "lib" of Qt4




  QT_PLUGINS_DIR              Path to "plugins" for Qt4
                            




The Qt toolkit may contain both debug and release libraries. In that case, the following library variables will contain both. You do not need to use these variables if you include QT_USE_FILE, and use QT_LIBRARIES.


  QT_QT3SUPPORT_LIBRARY            The Qt3Support library
  QT_QTASSISTANT_LIBRARY           The QtAssistant library
  QT_QTCORE_LIBRARY                The QtCore library
  QT_QTDBUS_LIBRARY                The QtDBus library
  QT_QTDESIGNER_LIBRARY            The QtDesigner library
  QT_QTDESIGNERCOMPONENTS_LIBRARY  The QtDesignerComponents library
  QT_QTGUI_LIBRARY                 The QtGui library
  QT_QTMOTIF_LIBRARY               The QtMotif library
  QT_QTNETWORK_LIBRARY             The QtNetwork library
  QT_QTNSPLUGIN_LIBRARY            The QtNsPLugin library
  QT_QTOPENGL_LIBRARY              The QtOpenGL library
  QT_QTSQL_LIBRARY                 The QtSql library
  QT_QTXML_LIBRARY                 The QtXml library
  QT_QTSVG_LIBRARY                 The QtSvg library
  QT_QTSCRIPT_LIBRARY              The QtScript library
  QT_QTTEST_LIBRARY                The QtTest library
  QT_QTMAIN_LIBRARY                The qtmain library for Windows
  QT_QTUITOOLS_LIBRARY             The QtUiTools library
  QT_QTASSISTANTCLIENT_LIBRARY     The QtAssistantClient library
  QT_QTHELP_LIBRARY                The QtHelp library
  QT_QTWEBKIT_LIBRARY              The QtWebKit library
  QT_QTXMLPATTERNS_LIBRARY         The QtXmlPatterns library
  QT_PHONON_LIBRARY                The phonon library
  

also defined, but NOT for general use are


  QT_MOC_EXECUTABLE          Where to find the moc tool.
  QT_UIC_EXECUTABLE          Where to find the uic tool.
  QT_UIC3_EXECUTABLE         Where to find the uic3 tool.
  QT_RCC_EXECUTABLE          Where to find the rcc tool
  QT_DBUSCPP2XML_EXECUTABLE  Where to find the qdbuscpp2xml tool.
  QT_DBUSXML2CPP_EXECUTABLE  Where to find the qdbusxml2cpp tool.
  QT_LUPDATE_EXECUTABLE      Where to find the lupdate tool.
  QT_LRELEASE_EXECUTABLE     Where to find the lrelease tool.
  
  QT_DOC_DIR                 Path to "doc" of Qt4
  QT_MKSPECS_DIR             Path to "mkspecs" of Qt4







These are around for backwards compatibility  they will be set


  QT_WRAP_CPP  Set true if QT_MOC_EXECUTABLE is found
  QT_WRAP_UI   Set true if QT_UIC_EXECUTABLE is found
  

These variables do _NOT_ have any effect anymore (compared to FindQt.cmake)


  QT_MT_REQUIRED         Qt4 is now always multithreaded
  

These variables are set to "" Because Qt structure changed  (They make no sense in Qt4)


  QT_QT_LIBRARY        Qt-Library is now split

.TP
.B FindQuickTime
 
Locate QuickTime This module defines QUICKTIME_LIBRARY QUICKTIME_FOUND, if false, do not try to link to gdal  QUICKTIME_INCLUDE_DIR, where to find the headers


$QUICKTIME_DIR is an environment variable that would correspond to the ./configure --prefix=$QUICKTIME_DIR


Created by Eric Wing. 

.TP
.B FindRuby
Find Ruby

This module finds if Ruby is installed and determines where the include files and libraries are. It also determines what the name of the library is. This code sets the following variables:


  RUBY_INCLUDE_PATH = path to where ruby.h can be found
  RUBY_EXECUTABLE   = full path to the ruby binary
  RUBY_LIBRARY      = full path to the ruby library

.TP
.B FindSDL
 
Locate SDL library This module defines SDL_LIBRARY, the name of the library to link against SDL_FOUND, if false, do not try to link to SDL SDL_INCLUDE_DIR, where to find SDL.h


This module responds to the the flag: SDL_BUILDING_LIBRARY If this is defined, then no SDL_main will be linked in because  only applications need main(). Otherwise, it is assumed you are building an application and this module will attempt to locate and set the the proper link flags as part of the returned SDL_LIBRARY variable.


Don't forget to include SDLmain.h and SDLmain.m your project for the  OS X framework based version. (Other versions link to -lSDLmain which this module will try to find on your behalf.) Also for OS X, this  module will automatically add the -framework Cocoa on your behalf.





Additional Note: If you see an empty SDL_LIBRARY_TEMP in your configuration and no SDL_LIBRARY, it means CMake did not find your SDL library  (SDL.dll, libsdl.so, SDL.framework, etc).  Set SDL_LIBRARY_TEMP to point to your SDL library, and configure again.  Similarly, if you see an empty SDLMAIN_LIBRARY, you should set this value as appropriate. These values are used to generate the final SDL_LIBRARY variable, but when these values are unset, SDL_LIBRARY does not get created.





$SDLDIR is an environment variable that would correspond to the ./configure --prefix=$SDLDIR used in building SDL. l.e.galup  9-20-02


Modified by Eric Wing.  Added code to assist with automated building by using environmental variables and providing a more controlled/consistent search behavior. Added new modifications to recognize OS X frameworks and  additional Unix paths (FreeBSD, etc).  Also corrected the header search path to follow "proper" SDL guidelines. Added a search for SDLmain which is needed by some platforms. Added a search for threads which is needed by some platforms. Added needed compile switches for MinGW.


On OSX, this will prefer the Framework version (if found) over others. People will have to manually change the cache values of  SDL_LIBRARY to override this selection or set the CMake environment CMAKE_INCLUDE_PATH to modify the search paths.


Note that the header path has changed from SDL/SDL.h to just SDL.h This needed to change because "proper" SDL convention is #include "SDL.h", not <SDL/SDL.h>. This is done for portability reasons because not all systems place things in SDL/ (see FreeBSD).

.TP
.B FindSDL_image
 
Locate SDL_image library This module defines SDLIMAGE_LIBRARY, the name of the library to link against SDLIMAGE_FOUND, if false, do not try to link to SDL SDLIMAGE_INCLUDE_DIR, where to find SDL/SDL.h


$SDLDIR is an environment variable that would correspond to the ./configure --prefix=$SDLDIR used in building SDL.


Created by Eric Wing. This was influenced by the FindSDL.cmake  module, but with modifications to recognize OS X frameworks and  additional Unix paths (FreeBSD, etc).

.TP
.B FindSDL_mixer
 
Locate SDL_mixer library This module defines SDLMIXER_LIBRARY, the name of the library to link against SDLMIXER_FOUND, if false, do not try to link to SDL SDLMIXER_INCLUDE_DIR, where to find SDL/SDL.h


$SDLDIR is an environment variable that would correspond to the ./configure --prefix=$SDLDIR used in building SDL.


Created by Eric Wing. This was influenced by the FindSDL.cmake  module, but with modifications to recognize OS X frameworks and  additional Unix paths (FreeBSD, etc).

.TP
.B FindSDL_net
 
Locate SDL_net library This module defines SDLNET_LIBRARY, the name of the library to link against SDLNET_FOUND, if false, do not try to link against SDLNET_INCLUDE_DIR, where to find the headers


$SDLDIR is an environment variable that would correspond to the ./configure --prefix=$SDLDIR used in building SDL.


Created by Eric Wing. This was influenced by the FindSDL.cmake  module, but with modifications to recognize OS X frameworks and  additional Unix paths (FreeBSD, etc).

.TP
.B FindSDL_sound
 
Locates the SDL_sound library

.TP
.B FindSDL_ttf
 
Locate SDL_ttf library This module defines SDLTTF_LIBRARY, the name of the library to link against SDLTTF_FOUND, if false, do not try to link to SDL SDLTTF_INCLUDE_DIR, where to find SDL/SDL.h


$SDLDIR is an environment variable that would correspond to the ./configure --prefix=$SDLDIR used in building SDL.


Created by Eric Wing. This was influenced by the FindSDL.cmake  module, but with modifications to recognize OS X frameworks and  additional Unix paths (FreeBSD, etc).

.TP
.B FindSWIG
Find SWIG

This module finds an installed SWIG.  It sets the following variables:


  SWIG_FOUND - set to true if SWIG is found
  SWIG_DIR - the directory where swig is installed
  SWIG_EXECUTABLE - the path to the swig executable
  SWIG_VERSION   - the version number of the swig executable




All informations are collected from the SWIG_EXECUTABLE so the version to be found can be changed from the command line by means of setting SWIG_EXECUTABLE


.TP
.B FindSelfPackers
Find upx

This module looks for some executable packers (i.e. softwares that compress executables or shared libs into on-the-fly self-extracting executables or shared libs. Examples:


  UPX: http://wildsau.idv.uni-linz.ac.at/mfx/upx.html

.TP
.B FindSubversion
Extract information from a subversion working copy

The module defines the following variables:


  Subversion_SVN_EXECUTABLE - path to svn command line client
  Subversion_VERSION_SVN - version of svn command line client
  Subversion_FOUND - true if the command line client was found

If the command line client executable is found the macro


  Subversion_WC_INFO(<dir> <var-prefix>)

is defined to extract information of a subversion working copy at a given location. The macro defines the following variables:


  <var-prefix>_WC_URL - url of the repository (at <dir>)
  <var-prefix>_WC_ROOT - root url of the repository
  <var-prefix>_WC_REVISION - current revision
  <var-prefix>_WC_LAST_CHANGED_AUTHOR - author of last commit
  <var-prefix>_WC_LAST_CHANGED_DATE - date of last commit
  <var-prefix>_WC_LAST_CHANGED_REV - revision of last commit
  <var-prefix>_WC_LAST_CHANGED_LOG - last log of base revision
  <var-prefix>_WC_INFO - output of command `svn info <dir>'

Example usage:


  FIND_PACKAGE(Subversion)
  IF(Subversion_FOUND)
    Subversion_WC_INFO(${PROJECT_SOURCE_DIR} Project)
    MESSAGE("Current revision is ${Project_WC_REVISION}")
  ENDIF(Subversion_FOUND)

.TP
.B FindTCL
TK_INTERNAL_PATH was removed.

This module finds if Tcl is installed and determines where the include files and libraries are. It also determines what the name of the library is. This code sets the following variables:


  TCL_FOUND              = Tcl was found
  TK_FOUND               = Tk was found
  TCLTK_FOUND            = Tcl and Tk were found
  TCL_LIBRARY            = path to Tcl library (tcl tcl80)
  TCL_INCLUDE_PATH       = path to where tcl.h can be found
  TCL_TCLSH              = path to tclsh binary (tcl tcl80)
  TK_LIBRARY             = path to Tk library (tk tk80 etc)
  TK_INCLUDE_PATH        = path to where tk.h can be found
  TK_WISH                = full path to the wish executable




In an effort to remove some clutter and clear up some issues for people who are not necessarily Tcl/Tk gurus/developpers, some variables were moved or removed. Changes compared to CMake 2.4 are:


   => they were only useful for people writing Tcl/Tk extensions.
   => these libs are not packaged by default with Tcl/Tk distributions. 
      Even when Tcl/Tk is built from source, several flavors of debug libs
      are created and there is no real reason to pick a single one
      specifically (say, amongst tcl84g, tcl84gs, or tcl84sgx). 
      Let's leave that choice to the user by allowing him to assign 
      TCL_LIBRARY to any Tcl library, debug or not.
   => this ended up being only a Win32 variable, and there is a lot of
      confusion regarding the location of this file in an installed Tcl/Tk
      tree anyway (see 8.5 for example). If you need the internal path at
      this point it is safer you ask directly where the *source* tree is
      and dig from there.

.TP
.B FindTIFF
Find TIFF library

Find the native TIFF includes and library This module defines


  TIFF_INCLUDE_DIR, where to find tiff.h, etc.
  TIFF_LIBRARIES, libraries to link against to use TIFF.
  TIFF_FOUND, If false, do not try to use TIFF.

also defined, but not for general use are


  TIFF_LIBRARY, where to find the TIFF library.

.TP
.B FindTclStub
TCL_STUB_LIBRARY_DEBUG and TK_STUB_LIBRARY_DEBUG were removed.

This module finds Tcl stub libraries. It first finds Tcl include files and libraries by calling FindTCL.cmake. How to Use the Tcl Stubs Library:


   http://tcl.activestate.com/doc/howto/stubs.html

Using Stub Libraries:


   http://safari.oreilly.com/0130385603/ch48lev1sec3

This code sets the following variables:


  TCL_STUB_LIBRARY       = path to Tcl stub library
  TK_STUB_LIBRARY        = path to Tk stub library




In an effort to remove some clutter and clear up some issues for people who are not necessarily Tcl/Tk gurus/developpers, some variables were moved or removed. Changes compared to CMake 2.4 are:


   => these libs are not packaged by default with Tcl/Tk distributions. 
      Even when Tcl/Tk is built from source, several flavors of debug libs
      are created and there is no real reason to pick a single one
      specifically (say, amongst tclstub84g, tclstub84gs, or tclstub84sgx). 
      Let's leave that choice to the user by allowing him to assign 
      TCL_STUB_LIBRARY to any Tcl library, debug or not.

.TP
.B FindTclsh
Find tclsh

This module finds if TCL is installed and determines where the include files and libraries are. It also determines what the name of the library is. This code sets the following variables:


  TCLSH_FOUND = TRUE if tclsh has been found
  TCL_TCLSH = the path to the tclsh executable

In cygwin, look for the cygwin version first.  Don't look for it later to avoid finding the cygwin version on a Win32 build.

.TP
.B FindThreads
This module determines the thread library of the system.

The following variables are set


  CMAKE_THREAD_LIBS_INIT     - the thread library
  CMAKE_USE_SPROC_INIT       - are we using sproc?
  CMAKE_USE_WIN32_THREADS_INIT - using WIN32 threads?
  CMAKE_USE_PTHREADS_INIT    - are we using pthreads
  CMAKE_HP_PTHREADS_INIT     - are we using hp pthreads

.TP
.B FindUnixCommands
Find unix commands from cygwin

This module looks for some usual Unix commands.


.TP
.B FindVTK
Find a VTK installation or build tree.

The following variables are set if VTK is found.  If VTK is not found, VTK_FOUND is set to false.


  VTK_FOUND         - Set to true when VTK is found.
  VTK_USE_FILE      - CMake file to use VTK.
  VTK_MAJOR_VERSION - The VTK major version number.
  VTK_MINOR_VERSION - The VTK minor version number 
                       (odd non-release).
  VTK_BUILD_VERSION - The VTK patch level 
                       (meaningless for odd minor).
  VTK_INCLUDE_DIRS  - Include directories for VTK
  VTK_LIBRARY_DIRS  - Link directories for VTK libraries
  VTK_KITS          - List of VTK kits, in CAPS 
                      (COMMON,IO,) etc.
  VTK_LANGUAGES     - List of wrapped languages, in CAPS
                      (TCL, PYHTON,) etc.

The following cache entries must be set by the user to locate VTK:


  VTK_DIR  - The directory containing VTKConfig.cmake.  
             This is either the root of the build tree,
             or the lib/vtk directory.  This is the 
             only cache entry.

The following variables are set for backward compatibility and should not be used in new code:


  USE_VTK_FILE - The full path to the UseVTK.cmake file.
                 This is provided for backward 
                 compatibility.  Use VTK_USE_FILE 
                 instead.




.TP
.B FindWget
Find wget

This module looks for wget. This module defines the  following values:


  WGET_EXECUTABLE: the full path to the wget tool.
  WGET_FOUND: True if wget has been found.

.TP
.B FindWish
Find wish installation

This module finds if TCL is installed and determines where the include files and libraries are. It also determines what the name of the library is. This code sets the following variables:


  TK_WISH = the path to the wish executable




if UNIX is defined, then it will look for the cygwin version first

.TP
.B FindX11
Find X11 installation

Try to find X11 on UNIX systems. The following values are defined


  X11_FOUND        - True if X11 is available
  X11_INCLUDE_DIR  - include directories to use X11
  X11_LIBRARIES    - link against these to use X11




and also the following more fine grained variables: Include paths: X11_ICE_INCLUDE_PATH,          X11_ICE_LIB,        X11_ICE_FOUND


                X11_Xaccessrules_INCLUDE_PATH,                     X11_Xaccess_FOUND
                X11_Xaccessstr_INCLUDE_PATH,                       X11_Xaccess_FOUND
                X11_Xau_INCLUDE_PATH,          X11_Xau_LIB,        X11_Xau_FOUND
                X11_Xcomposite_INCLUDE_PATH,   X11_Xcomposite_LIB, X11_Xcomposite_FOUND
                X11_Xcursor_INCLUDE_PATH,      X11_Xcursor_LIB,    X11_Xcursor_FOUND
                X11_Xdamage_INCLUDE_PATH,      X11_Xdamage_LIB,    X11_Xdamage_FOUND
                X11_Xdmcp_INCLUDE_PATH,        X11_Xdmcp_LIB,      X11_Xdmcp_FOUND
                                               X11_Xext_LIB,       X11_Xext_FOUND
                X11_dpms_INCLUDE_PATH,         (in X11_Xext_LIB),  X11_dpms_FOUND
                X11_XShm_INCLUDE_PATH,         (in X11_Xext_LIB),  X11_XShm_FOUND
                X11_Xshape_INCLUDE_PATH,       (in X11_Xext_LIB),  X11_Xshape_FOUND
                X11_xf86misc_INCLUDE_PATH,     X11_Xxf86misc_LIB,  X11_xf86misc_FOUND
                X11_xf86vmode_INCLUDE_PATH,                        X11_xf86vmode_FOUND
                X11_Xfixes_INCLUDE_PATH,       X11_Xfixes_LIB,     X11_Xfixes_FOUND
                X11_Xft_INCLUDE_PATH,          X11_Xft_LIB,        X11_Xft_FOUND
                X11_Xinerama_INCLUDE_PATH,     X11_Xinerama_LIB,   X11_Xinerama_FOUND
                X11_Xinput_INCLUDE_PATH,       X11_Xinput_LIB,     X11_Xinput_FOUND
                X11_Xkb_INCLUDE_PATH,                              X11_Xkb_FOUND
                X11_Xkblib_INCLUDE_PATH,                           X11_Xkb_FOUND
                X11_Xpm_INCLUDE_PATH,          X11_Xpm_LIB,        X11_Xpm_FOUND
                X11_XTest_INCLUDE_PATH,        X11_XTest_LIB,      X11_XTest_FOUND
                X11_Xrandr_INCLUDE_PATH,       X11_Xrandr_LIB,     X11_Xrandr_FOUND
                X11_Xrender_INCLUDE_PATH,      X11_Xrender_LIB,    X11_Xrender_FOUND
                X11_Xscreensaver_INCLUDE_PATH, X11_Xscreensaver_LIB, X11_Xscreensaver_FOUND
                X11_Xt_INCLUDE_PATH,           X11_Xt_LIB,         X11_Xt_FOUND
                X11_Xutil_INCLUDE_PATH,                            X11_Xutil_FOUND
                X11_Xv_INCLUDE_PATH,           X11_Xv_LIB,         X11_Xv_FOUND

.TP
.B FindXMLRPC
Find xmlrpc

Find the native XMLRPC headers and libraries.


  XMLRPC_INCLUDE_DIRS      - where to find xmlrpc.h, etc.
  XMLRPC_LIBRARIES         - List of libraries when using xmlrpc.
  XMLRPC_FOUND             - True if xmlrpc found.

XMLRPC modules may be specified as components for this find module. Modules may be listed by running "xmlrpc-c-config".  Modules include:


  c++            C++ wrapper code
  libwww-client  libwww-based client
  cgi-server     CGI-based server
  abyss-server   ABYSS-based server

Typical usage:


  FIND_PACKAGE(XMLRPC REQUIRED libwww-client)

.TP
.B FindZLIB
Find zlib

Find the native ZLIB includes and library


  ZLIB_INCLUDE_DIR - where to find zlib.h, etc.
  ZLIB_LIBRARIES   - List of libraries when using zlib.
  ZLIB_FOUND       - True if zlib found.

.TP
.B Findosg
 
This is part of the Findosg* suite used to find OpenSceneGraph components. Each component is separate and you must opt in to each module. You must  also opt into OpenGL and OpenThreads (and Producer if needed) as these  modules won't do it for you. This is to allow you control over your own  system piece by piece in case you need to opt out of certain components or change the Find behavior for a particular module (perhaps because the default FindOpenGL.cmake module doesn't work with your system as an example). If you want to use a more convenient module that includes everything, use the FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.


Locate osg This module defines OSG_LIBRARY OSG_FOUND, if false, do not try to link to osg OSG_INCLUDE_DIR, where to find the headers


$OSGDIR is an environment variable that would correspond to the ./configure --prefix=$OSGDIR used in building osg.


Created by Eric Wing.

.TP
.B FindosgDB
 
This is part of the Findosg* suite used to find OpenSceneGraph components. Each component is separate and you must opt in to each module. You must  also opt into OpenGL and OpenThreads (and Producer if needed) as these  modules won't do it for you. This is to allow you control over your own  system piece by piece in case you need to opt out of certain components or change the Find behavior for a particular module (perhaps because the default FindOpenGL.cmake module doesn't work with your system as an example). If you want to use a more convenient module that includes everything, use the FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.


Locate osgDB This module defines OSGDB_LIBRARY OSGDB_FOUND, if false, do not try to link to osgDB OSGDB_INCLUDE_DIR, where to find the headers


$OSGDIR is an environment variable that would correspond to the ./configure --prefix=$OSGDIR used in building osg.


Created by Eric Wing.

.TP
.B FindosgFX
 
This is part of the Findosg* suite used to find OpenSceneGraph components. Each component is separate and you must opt in to each module. You must  also opt into OpenGL and OpenThreads (and Producer if needed) as these  modules won't do it for you. This is to allow you control over your own  system piece by piece in case you need to opt out of certain components or change the Find behavior for a particular module (perhaps because the default FindOpenGL.cmake module doesn't work with your system as an example). If you want to use a more convenient module that includes everything, use the FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.


Locate osgFX This module defines OSGFX_LIBRARY OSGFX_FOUND, if false, do not try to link to osgFX OSGFX_INCLUDE_DIR, where to find the headers


$OSGDIR is an environment variable that would correspond to the ./configure --prefix=$OSGDIR used in building osg.


Created by Eric Wing.

.TP
.B FindosgGA
 
This is part of the Findosg* suite used to find OpenSceneGraph components. Each component is separate and you must opt in to each module. You must  also opt into OpenGL and OpenThreads (and Producer if needed) as these  modules won't do it for you. This is to allow you control over your own  system piece by piece in case you need to opt out of certain components or change the Find behavior for a particular module (perhaps because the default FindOpenGL.cmake module doesn't work with your system as an example). If you want to use a more convenient module that includes everything, use the FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.


Locate osgGA This module defines OSGGA_LIBRARY OSGGA_FOUND, if false, do not try to link to osgGA OSGGA_INCLUDE_DIR, where to find the headers


$OSGDIR is an environment variable that would correspond to the ./configure --prefix=$OSGDIR used in building osg.


Created by Eric Wing.

.TP
.B FindosgIntrospection
 
This is part of the Findosg* suite used to find OpenSceneGraph components. Each component is separate and you must opt in to each module. You must  also opt into OpenGL and OpenThreads (and Producer if needed) as these  modules won't do it for you. This is to allow you control over your own  system piece by piece in case you need to opt out of certain components or change the Find behavior for a particular module (perhaps because the default FindOpenGL.cmake module doesn't work with your system as an example). If you want to use a more convenient module that includes everything, use the FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.


Locate osgIntrospection This module defines OSGINTROSPECTION_LIBRARY OSGINTROSPECTION_FOUND, if false, do not try to link to osgIntrospection OSGINTROSPECTION_INCLUDE_DIR, where to find the headers


$OSGDIR is an environment variable that would correspond to the ./configure --prefix=$OSGDIR used in building osg.


Created by Eric Wing.

.TP
.B FindosgManipulator
 
This is part of the Findosg* suite used to find OpenSceneGraph components. Each component is separate and you must opt in to each module. You must  also opt into OpenGL and OpenThreads (and Producer if needed) as these  modules won't do it for you. This is to allow you control over your own  system piece by piece in case you need to opt out of certain components or change the Find behavior for a particular module (perhaps because the default FindOpenGL.cmake module doesn't work with your system as an example). If you want to use a more convenient module that includes everything, use the FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.


Locate osgManipulator This module defines OSG_LIBRARY OSGMANIPULATOR_FOUND, if false, do not try to link to osgManipulator OSGMANIPULATOR_INCLUDE_DIR, where to find the headers


$OSGDIR is an environment variable that would correspond to the ./configure --prefix=$OSGDIR used in building osg.


Created by Eric Wing.

.TP
.B FindosgParticle
 
This is part of the Findosg* suite used to find OpenSceneGraph components. Each component is separate and you must opt in to each module. You must  also opt into OpenGL and OpenThreads (and Producer if needed) as these  modules won't do it for you. This is to allow you control over your own  system piece by piece in case you need to opt out of certain components or change the Find behavior for a particular module (perhaps because the default FindOpenGL.cmake module doesn't work with your system as an example). If you want to use a more convenient module that includes everything, use the FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.


Locate osgParticle This module defines OSGPARTICLE_LIBRARY OSGPARTICLE_FOUND, if false, do not try to link to osgParticle OSGPARTICLE_INCLUDE_DIR, where to find the headers


$OSGDIR is an environment variable that would correspond to the ./configure --prefix=$OSGDIR used in building osg.


Created by Eric Wing.

.TP
.B FindosgProducer
 
This is part of the Findosg* suite used to find OpenSceneGraph components. Each component is separate and you must opt in to each module. You must  also opt into OpenGL and OpenThreads (and Producer if needed) as these  modules won't do it for you. This is to allow you control over your own  system piece by piece in case you need to opt out of certain components or change the Find behavior for a particular module (perhaps because the default FindOpenGL.cmake module doesn't work with your system as an example). If you want to use a more convenient module that includes everything, use the FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.


Locate osgProducer This module defines OSGPRODUCER_LIBRARY OSGPRODUCER_FOUND, if false, do not try to link to osgProducer OSGPRODUCER_INCLUDE_DIR, where to find the headers


$OSGDIR is an environment variable that would correspond to the ./configure --prefix=$OSGDIR used in building osg.


Created by Eric Wing.

.TP
.B FindosgShadow
 
This is part of the Findosg* suite used to find OpenSceneGraph components. Each component is separate and you must opt in to each module. You must  also opt into OpenGL and OpenThreads (and Producer if needed) as these  modules won't do it for you. This is to allow you control over your own  system piece by piece in case you need to opt out of certain components or change the Find behavior for a particular module (perhaps because the default FindOpenGL.cmake module doesn't work with your system as an example). If you want to use a more convenient module that includes everything, use the FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.


Locate osgShadow This module defines OSGSHADOW_LIBRARY OSGSHADOW_FOUND, if false, do not try to link to osgShadow OSGSHADOW_INCLUDE_DIR, where to find the headers


$OSGDIR is an environment variable that would correspond to the ./configure --prefix=$OSGDIR used in building osg.


Created by Eric Wing.

.TP
.B FindosgSim
 
This is part of the Findosg* suite used to find OpenSceneGraph components. Each component is separate and you must opt in to each module. You must  also opt into OpenGL and OpenThreads (and Producer if needed) as these  modules won't do it for you. This is to allow you control over your own  system piece by piece in case you need to opt out of certain components or change the Find behavior for a particular module (perhaps because the default FindOpenGL.cmake module doesn't work with your system as an example). If you want to use a more convenient module that includes everything, use the FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.


Locate osgSim This module defines OSGSIM_LIBRARY OSGSIM_FOUND, if false, do not try to link to osgSim OSGSIM_INCLUDE_DIR, where to find the headers


$OSGDIR is an environment variable that would correspond to the ./configure --prefix=$OSGDIR used in building osg.


Created by Eric Wing.

.TP
.B FindosgTerrain
 
This is part of the Findosg* suite used to find OpenSceneGraph components. Each component is separate and you must opt in to each module. You must  also opt into OpenGL and OpenThreads (and Producer if needed) as these  modules won't do it for you. This is to allow you control over your own  system piece by piece in case you need to opt out of certain components or change the Find behavior for a particular module (perhaps because the default FindOpenGL.cmake module doesn't work with your system as an example). If you want to use a more convenient module that includes everything, use the FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.


Locate osgTerrain This module defines OSGTERRAIN_LIBRARY OSGTERRAIN_FOUND, if false, do not try to link to osgTerrain OSGTERRAIN_INCLUDE_DIR, where to find the headers


$OSGDIR is an environment variable that would correspond to the ./configure --prefix=$OSGDIR used in building osg.


Created by Eric Wing.

.TP
.B FindosgText
 
This is part of the Findosg* suite used to find OpenSceneGraph components. Each component is separate and you must opt in to each module. You must  also opt into OpenGL and OpenThreads (and Producer if needed) as these  modules won't do it for you. This is to allow you control over your own  system piece by piece in case you need to opt out of certain components or change the Find behavior for a particular module (perhaps because the default FindOpenGL.cmake module doesn't work with your system as an example). If you want to use a more convenient module that includes everything, use the FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.


Locate osgText This module defines OSGTEXT_LIBRARY OSGTEXT_FOUND, if false, do not try to link to osgText OSGTEXT_INCLUDE_DIR, where to find the headers


$OSGDIR is an environment variable that would correspond to the ./configure --prefix=$OSGDIR used in building osg.


Created by Eric Wing.

.TP
.B FindosgUtil
 
This is part of the Findosg* suite used to find OpenSceneGraph components. Each component is separate and you must opt in to each module. You must  also opt into OpenGL and OpenThreads (and Producer if needed) as these  modules won't do it for you. This is to allow you control over your own  system piece by piece in case you need to opt out of certain components or change the Find behavior for a particular module (perhaps because the default FindOpenGL.cmake module doesn't work with your system as an example). If you want to use a more convenient module that includes everything, use the FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.


Locate osgUtil This module defines OSGUTIL_LIBRARY OSGUTIL_FOUND, if false, do not try to link to osgUtil OSGUTIL_INCLUDE_DIR, where to find the headers


$OSGDIR is an environment variable that would correspond to the ./configure --prefix=$OSGDIR used in building osg.


Created by Eric Wing.

.TP
.B FindosgViewer
 
This is part of the Findosg* suite used to find OpenSceneGraph components. Each component is separate and you must opt in to each module. You must  also opt into OpenGL and OpenThreads (and Producer if needed) as these  modules won't do it for you. This is to allow you control over your own  system piece by piece in case you need to opt out of certain components or change the Find behavior for a particular module (perhaps because the default FindOpenGL.cmake module doesn't work with your system as an example). If you want to use a more convenient module that includes everything, use the FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.


Locate osgViewer This module defines OSGVIEWER_LIBRARY OSGVIEWER_FOUND, if false, do not try to link to osgViewer OSGVIEWER_INCLUDE_DIR, where to find the headers


$OSGDIR is an environment variable that would correspond to the ./configure --prefix=$OSGDIR used in building osg.


Created by Eric Wing.

.TP
.B FindwxWidgets
Find a wxWidgets (a.k.a., wxWindows) installation.

This module finds if wxWidgets is installed and selects a default configuration to use. wxWidgets is a modular library. To specify the modules that you will use, you need to name them as components to the package:


FIND_PACKAGE(wxWidgets COMPONENTS base core ...)


There are two search branches: a windows style and a unix style. For windows, the following variables are searched for and set to defaults in case of multiple choices. Change them if the defaults are not desired (i.e., these are the only variables you should change to select a configuration):


  wxWidgets_ROOT_DIR      - Base wxWidgets directory
                            (e.g., C:/wxWidgets-2.6.3).
  wxWidgets_LIB_DIR       - Path to wxWidgets libraries
                            (e.g., C:/wxWidgets-2.6.3/lib/vc_lib).
  wxWidgets_CONFIGURATION - Configuration to use
                            (e.g., msw, mswd, mswu, mswunivud, etc.)




For unix style it uses the wx-config utility. You can select between debug/release, unicode/ansi, universal/non-universal, and static/shared in the QtDialog or ccmake interfaces by turning ON/OFF the following variables:


  wxWidgets_USE_DEBUG
  wxWidgets_USE_UNICODE
  wxWidgets_USE_UNIVERSAL
  wxWidgets_USE_STATIC
  

The following are set after the configuration is done for both windows and unix style:


  wxWidgets_FOUND            - Set to TRUE if wxWidgets was found.
  wxWidgets_INCLUDE_DIRS     - Include directories for WIN32
                               i.e., where to find "wx/wx.h" and
                               "wx/setup.h"; possibly empty for unices.
  wxWidgets_LIBRARIES        - Path to the wxWidgets libraries.
  wxWidgets_LIBRARY_DIRS     - compile time link dirs, useful for
                               rpath on UNIX. Typically an empty string
                               in WIN32 environment.
  wxWidgets_DEFINITIONS      - Contains defines required to compile/link
                               against WX, e.g. -DWXUSINGDLL
  wxWidgets_CXX_FLAGS        - Include dirs and ompiler flags for
                               unices, empty on WIN32. Esentially
                               "`wx-config --cxxflags`".
  wxWidgets_USE_FILE         - Convenience include file.




Sample usage:


   FIND_PACKAGE(wxWidgets COMPONENTS base core gl net)
   IF(wxWidgets_FOUND)
     INCLUDE(${wxWidgets_USE_FILE})
     # and for each of your dependant executable/library targets:
     TARGET_LINK_LIBRARIES(<YourTarget> ${wxWidgets_LIBRARIES})
   ENDIF(wxWidgets_FOUND)




If wxWidgets is required (i.e., not an optional part):


   FIND_PACKAGE(wxWidgets REQUIRED base core gl net)
   INCLUDE(${wxWidgets_USE_FILE})
   # and for each of your dependant executable/library targets:
   TARGET_LINK_LIBRARIES(<YourTarget> ${wxWidgets_LIBRARIES})

.TP
.B FindwxWindows
Find wxWindows (wxWidgets) installation

This module finds if wxWindows/wxWidgets is installed and determines where the include files and libraries are. It also determines what the name of the library is. Please note this file is DEPRECATED and replaced by FindwxWidgets.cmake. This code sets the following variables:


  WXWINDOWS_FOUND     = system has WxWindows
  WXWINDOWS_LIBRARIES = path to the wxWindows libraries
                        on Unix/Linux with additional
                        linker flags from
                        "wx-config --libs"
  CMAKE_WXWINDOWS_CXX_FLAGS  = Compiler flags for wxWindows,
                               essentially "`wx-config --cxxflags`"
                               on Linux
  WXWINDOWS_INCLUDE_DIR      = where to find "wx/wx.h" and "wx/setup.h"
  WXWINDOWS_LINK_DIRECTORIES = link directories, useful for rpath on
                                Unix
  WXWINDOWS_DEFINITIONS      = extra defines




OPTIONS If you need OpenGL support please


  SET(WXWINDOWS_USE_GL 1)

in your CMakeLists.txt *before* you include this file.


  HAVE_ISYSTEM      - true required to replace -I by -isystem on g++




For convenience include Use_wxWindows.cmake in your project's CMakeLists.txt using INCLUDE(Use_wxWindows).


USAGE


  SET(WXWINDOWS_USE_GL 1)
  FIND_PACKAGE(wxWindows)




NOTES wxWidgets 2.6.x is supported for monolithic builds e.g. compiled  in wx/build/msw dir as:


  nmake -f makefile.vc BUILD=debug SHARED=0 USE_OPENGL=1 MONOLITHIC=1




DEPRECATED


  CMAKE_WX_CAN_COMPILE
  WXWINDOWS_LIBRARY
  CMAKE_WX_CXX_FLAGS
  WXWINDOWS_INCLUDE_PATH




AUTHOR Jan Woetzel <http://www.mip.informatik.uni-kiel.de/~jw> (07/2003-01/2006)

.TP
.B GetPrerequisites
 
GetPrerequisites.cmake


This script provides functions to list the .dll, .dylib or .so files that an executable or shared library file depends on. (Its prerequisites.)


It uses various tools to obtain the list of required shared library files:


   dumpbin (Windows)
   ldd (Linux/Unix)
   otool (Mac OSX)




The following functions are provided by this script:


   gp_append_unique
   gp_file_type
   is_file_executable
   get_prerequisites
   list_prerequisites




Requires CMake 2.5 or greater because it uses function, break, return and PARENT_SCOPE.


.TP
.B ITKCompatibility
 
work around an old bug in ITK prior to verison 3.0

.TP
.B InstallRequiredSystemLibraries
 
By including this file, all files in the CMAKE_INSTALL_DEBUG_LIBRARIES, will be installed with INSTALL_PROGRAMS into /bin for WIN32 and /lib for non-win32. If CMAKE_SKIP_INSTALL_RULES is set to TRUE before including this file, then the INSTALL command is not called.  The use can use  the variable CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS to use a custom install  command and install them into any directory they want. If it is the MSVC compiler, then the microsoft run time libraries will be found add automatically added to the CMAKE_INSTALL_DEBUG_LIBRARIES, and installed.   If CMAKE_INSTALL_DEBUG_LIBRARIES is set and it is the MSVC compiler, then the debug libraries are installed when available. If CMAKE_INSTALL_MFC_LIBRARIES is set then the MFC run time libraries are installed as well as the CRT run time libraries.

.TP
.B MacroAddFileDependencies
MACRO_ADD_FILE_DEPENDENCIES(<_file> depend_files...)

MACRO_OPTIONAL_FIND_PACKAGE( <name> [QUIT] )

.TP
.B TestBigEndian
Define macro to determine endian type

Check if the system is big endian or little endian


  TEST_BIG_ENDIAN(VARIABLE)
  VARIABLE - variable to store the result to




.TP
.B TestCXXAcceptsFlag
Test CXX compiler for a flag

Check if the CXX compiler accepts a flag


  Macro CHECK_CXX_ACCEPTS_FLAG(FLAGS VARIABLE) -
     checks if the function exists
  FLAGS - the flags to try
  VARIABLE - variable to store the result




.TP
.B TestForANSIForScope
Check for ANSI for scope support

Check if the compiler supports std:: on stl classes.


  CMAKE_NO_ANSI_FOR_SCOPE - holds result




.TP
.B TestForANSIStreamHeaders
Test for compiler support of ANSI stream headers iostream, etc.

check if we they have the standard ansi stream files (without the .h)


  CMAKE_NO_ANSI_STREAM_HEADERS - defined by the results




.TP
.B TestForSSTREAM
 
# - Test for std:: namespace support check if the compiler supports std:: on stl classes


  CMAKE_NO_ANSI_STRING_STREAM - defined by the results




.TP
.B TestForSTDNamespace
Test for std:: namespace support

check if the compiler supports std:: on stl classes


  CMAKE_NO_STD_NAMESPACE - defined by the results




.TP
.B UseEcos
This module defines variables and macros required to build eCos application.

This file contains the following macros: ECOS_ADD_INCLUDE_DIRECTORIES() - add the eCos include dirs ECOS_ADD_EXECUTABLE(name source1 ... sourceN ) - create an eCos executable ECOS_ADJUST_DIRECTORY(VAR source1 ... sourceN ) - adjusts the path of the source files and puts the result into VAR


Macros for selecting the toolchain: ECOS_USE_ARM_ELF_TOOLS()       - enable the ARM ELF toolchain for the directory where it is called ECOS_USE_I386_ELF_TOOLS()      - enable the i386 ELF toolchain for the directory where it is called ECOS_USE_PPC_EABI_TOOLS()      - enable the PowerPC toolchain for the directory where it is called


It contains the following variables: ECOS_DEFINITIONS ECOSCONFIG_EXECUTABLE ECOS_CONFIG_FILE               - defaults to ecos.ecc, if your eCos configuration file has a different name, adjust this variable for internal use only:


  ECOS_ADD_TARGET_LIB

.TP
.B UsePkgConfig
obsolete pkg-config module for CMake




Defines the following macros:


PKGCONFIG(package includedir libdir linkflags cflags)


Calling PKGCONFIG will fill the desired information into the 4 given arguments, e.g. PKGCONFIG(libart-2.0 LIBART_INCLUDE_DIR LIBART_LINK_DIR LIBART_LINK_FLAGS LIBART_CFLAGS) if pkg-config was NOT found or the specified software package doesn't exist, the variable will be empty when the function returns, otherwise they will contain the respective information


.TP
.B UseQt4
Use Module for QT4

Sets up C and C++ to use Qt 4.  It is assumed that FindQt.cmake has already been loaded.  See FindQt.cmake for information on how to load Qt 4 into your CMake project.

.TP
.B UseSWIG
SWIG module for CMake

Defines the following macros:


   SWIG_ADD_MODULE(name language [ files ])
     - Define swig module with given name and specified language
   SWIG_LINK_LIBRARIES(name [ libraries ])
     - Link libraries to swig module

All other macros are for internal use only. To get the actual name of the swig module, use: ${SWIG_MODULE_name_REAL_NAME}. Set Source files properties such as CPLUSPLUS and SWIG_FLAGS to specify special behavior of SWIG. Also global CMAKE_SWIG_FLAGS can be used to add special flags to all swig calls. Another special variable is CMAKE_SWIG_OUTDIR, it allows one to specify  where to write all the swig generated module (swig -outdir option) The name-specific variable SWIG_MODULE_<name>_EXTRA_DEPS may be used to specify extra dependencies for the generated modules.

.TP
.B Use_wxWindows
---------------------------------------------------




This convenience include finds if wxWindows is installed and set the appropriate libs, incdirs, flags etc. author Jan Woetzel <jw -at- mip.informatik.uni-kiel.de> (07/2003)


USAGE:


   just include Use_wxWindows.cmake
   in your projects CMakeLists.txt

INCLUDE( ${CMAKE_MODULE_PATH}/Use_wxWindows.cmake)


   if you are sure you need GL then

SET(WXWINDOWS_USE_GL 1)


   *before* you include this file.




16.Feb.2004: changed INCLUDE to FIND_PACKAGE to read from users own non-system CMAKE_MODULE_PATH (Jan Woetzel JW) 07/2006: rewrite as FindwxWidgets.cmake, kept for backward compatibilty JW

.TP
.B UsewxWidgets
Convenience include for using wxWidgets library

Finds if wxWidgets is installed and set the appropriate libs, incdirs, flags etc. INCLUDE_DIRECTORIES, LINK_DIRECTORIES and ADD_DEFINITIONS are called.


USAGE


  SET( wxWidgets_USE_LIBS  gl xml xrc ) # optionally: more than wx std libs
  FIND_PACKAGE(wxWidgets REQUIRED)
  INCLUDE( ${xWidgets_USE_FILE} )
  ... add your targets here, e.g. ADD_EXECUTABLE/ ADD_LIBRARY ...
  TARGET_LINK_LIBRARIERS( <yourWxDependantTarget>  ${wxWidgets_LIBRARIES})




DEPRECATED


  LINK_LIBRARIES is not called in favor of adding dependencies per target.




AUTHOR


  Jan Woetzel <jw -at- mip.informatik.uni-kiel.de>

.TP
.B cmake_install
 
Install script for directory: /home/chris/cmake-2.6.0/Modules

.SH POLICIES
.TP
.B CMP0000
A minimum required CMake version must be specified.

CMake requires that projects specify the version of CMake to which they have been written.  This policy has been put in place so users trying to build the project may be told when they need to update their CMake.  Specifying a version also helps the project build with CMake versions newer than that specified.  Use the cmake_minimum_required command at the top of your main  CMakeLists.txt file:


  cmake_minimum_required(VERSION <major>.<minor>)

where "<major>.<minor>" is the version of CMake you want to support (such as "2.6").  The command will ensure that at least the given version of CMake is running and help newer versions be compatible with the project.  See documentation of cmake_minimum_required for details.


Note that the command invocation must appear in the CMakeLists.txt file itself; a call in an included file is not sufficient.  However, the cmake_policy command may be called to set policy CMP0000 to OLD or NEW behavior explicitly.  The OLD behavior is to silently ignore the missing invocation.  The NEW behavior is to issue an error instead of a warning.  An included file may set CMP0000 explicitly to affect how this policy is enforced for the main CMakeLists.txt file.


This policy was introduced in CMake version 2.6.0.

.TP
.B CMP0001
CMAKE_BACKWARDS_COMPATIBILITY should no longer be used.

The OLD behavior is to check CMAKE_BACKWARDS_COMPATIBILITY and present it to the user.  The NEW behavior is to ignore CMAKE_BACKWARDS_COMPATIBILITY completely.


In CMake 2.4 and below the variable CMAKE_BACKWARDS_COMPATIBILITY was used to request compatibility with earlier versions of CMake.  In CMake 2.6 and above all compatibility issues are handled by policies and the cmake_policy command.  However, CMake must still check CMAKE_BACKWARDS_COMPATIBILITY for projects written for CMake 2.4 and below.


This policy was introduced in CMake version 2.6.0.  CMake version 2.6 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.

.TP
.B CMP0002
Logical target names must be globally unique.

Targets names created with add_executable, add_library, or add_custom_target are logical build target names.  Logical target names must be globally unique because:


  - Unique names may be referenced unambiguously both in CMake
    code and on make tool command lines.
  - Logical names are used by Xcode and VS IDE generators
    to produce meaningful project names for the targets.

The logical name of executable and library targets does not have to correspond to the physical file names built.  Consider using the OUTPUT_NAME target property to create two targets with the same physical name while keeping logical names distinct.  Custom targets must simply have globally unique names (unless one uses the global property ALLOW_DUPLICATE_CUSTOM_TARGETS with a Makefiles generator).


This policy was introduced in CMake version 2.6.0.  CMake version 2.6 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.

.TP
.B CMP0003
Libraries linked via full path no longer produce linker search paths.

This policy affects how libraries whose full paths are NOT known are found at link time, but was created due to a change in how CMake deals with libraries whose full paths are known.  Consider the code


  target_link_libraries(myexe /path/to/libA.so)

CMake 2.4 and below implemented linking to libraries whose full paths are known by splitting them on the link line into separate components consisting of the linker search path and the library name.  The example code might have produced something like


  ... -L/path/to -lA ...

in order to link to library A.  An analysis was performed to order multiple link directories such that the linker would find library A in the desired location, but there are cases in which this does not work.  CMake versions 2.6 and above use the more reliable approach of passing the full path to libraries directly to the linker in most cases.  The example code now produces something like


  ... /path/to/libA.so ....

Unfortunately this change can break code like


  target_link_libraries(myexe /path/to/libA.so B)

where "B" is meant to find "/path/to/libB.so".  This code is wrong because the user is asking the linker to find library B but has not provided a linker search path (which may be added with the link_directories command).  However, with the old linking implementation the code would work accidentally because the linker search path added for library A allowed library B to be found.


In order to support projects depending on linker search paths added by linking to libraries with known full paths, the OLD behavior for this policy will add the linker search paths even though they are not needed for their own libraries.  When this policy is set to OLD, CMake will produce a link line such as


  ... -L/path/to /path/to/libA.so -lB ...

which will allow library B to be found as it was previously.  When this policy is set to NEW, CMake will produce a link line such as


  ... /path/to/libA.so -lB ...

which more accurately matches what the project specified.


The setting for this policy used when generating the link line is that in effect when the target is created by an add_executable or add_library command.  For the example described above, the code


  cmake_policy(SET CMP0003 OLD) # or cmake_policy(VERSION 2.4)
  add_executable(myexe myexe.c)
  target_link_libraries(myexe /path/to/libA.so B)

will work and suppress the warning for this policy.  It may also be updated to work with the corrected linking approach:


  cmake_policy(SET CMP0003 NEW) # or cmake_policy(VERSION 2.6)
  link_directories(/path/to) # needed to find library B
  add_executable(myexe myexe.c)
  target_link_libraries(myexe /path/to/libA.so B)

Even better, library B may be specified with a full path:


  add_executable(myexe myexe.c)
  target_link_libraries(myexe /path/to/libA.so /path/to/libB.so)

When all items on the link line have known paths CMake does not check this policy so it has no effect.


Note that the warning for this policy will be issued for at most one target.  This avoids flooding users with messages for every target when setting the policy once will probably fix all targets.


This policy was introduced in CMake version 2.6.0.  CMake version 2.6 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.

.TP
.B CMP0004
Libraries linked may not have leading or trailing whitespace.

CMake versions 2.4 and below silently removed leading and trailing whitespace from libraries linked with code like


  target_link_libraries(myexe " A ")

This could lead to subtle errors in user projects.


The OLD behavior for this policy is to silently remove leading and trailing whitespace.  The NEW behavior for this policy is to diagnose the existence of such whitespace as an error.  The setting for this policy used when checking the library names is that in effect when the target is created by an add_executable or add_library command.


This policy was introduced in CMake version 2.6.0.  CMake version 2.6 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.

.TP
.B CMP0005
Preprocessor definition values are now escaped automatically.

This policy determines whether or not CMake should generate escaped preprocessor definition values added via add_definitions.  CMake versions 2.4 and below assumed that only trivial values would be given for macros in add_definitions calls.  It did not attempt to escape non-trivial values such as string literals in generated build rules.  CMake versions 2.6 and above support escaping of most values, but cannot assume the user has not added escapes already in an attempt to work around limitations in earlier versions.


The OLD behavior for this policy is to place definition values given to add_definitions directly in the generated build rules without attempting to escape anything.  The NEW behavior for this policy is to generate correct escapes for all native build tools automatically.  See documentation of the COMPILE_DEFINITIONS target property for limitations of the escaping implementation.


This policy was introduced in CMake version 2.6.0.  CMake version 2.6 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.

.TP
.B CMP0006
Installing MACOSX_BUNDLE targets requires a BUNDLE DESTINATION.

This policy determines whether the install(TARGETS) command must be given a BUNDLE DESTINATION when asked to install a target with the MACOSX_BUNDLE property set.  CMake 2.4 and below did not distinguish application bundles from normal executables when installing targets.  CMake 2.6 provides a BUNDLE option to the install(TARGETS) command that specifies rules specific to application bundles on the Mac.  Projects should use this option when installing a target with the MACOSX_BUNDLE property set.


The OLD behavior for this policy is to fall back to the RUNTIME DESTINATION if a BUNDLE DESTINATION is not given.  The NEW behavior for this policy is to produce an error if a bundle target is installed without a BUNDLE DESTINATION.


This policy was introduced in CMake version 2.6.0.  CMake version 2.6 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.

.TP
.B CMP0007
list command no longer ignores empty elements.

This policy determines whether the list command will ignore empty elements in the list. CMake 2.4 and below list commands ignored all empty elements in the list.  For example, a;b;;c would have length 3 and not 4. The OLD behavior for this policy is to ignore empty list elements. The NEW behavior for this policy is to correctly count empty elements in a list. 


This policy was introduced in CMake version 2.6.0.  CMake version 2.6 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.

.SH VARIABLES
.SH VARIABLES THAT CHANGE BEHAVIOR
.TP
.B BUILD_SHARED_LIBS
Global flag to cause add_library to create shared libraries if on.

If present and true, this will cause all libraries to be built shared unless the library was explicitly added as a static library.  This variable is often added to projects as an OPTION so that each user of a project can decide if they want to build the project using shared or static libraries.

.TP
.B CMAKE_BACKWARDS_COMPATIBILITY
Version of cmake required to build project

From the point of view of backwards compatibility, this specifies what version of CMake should be supported. By default this value is the version number of CMake that you are running. You can set this to an older version of CMake to support deprecated commands of CMake in projects that were written to use older versions of CMake. This can be set by the user or set at the beginning of a CMakeLists file.

.TP
.B CMAKE_BUILD_TYPE
Specifies the build type for make based generators.

This specifies what build type will be built in this tree.  Possible values are empty, Debug, Release, RelWithDebInfo and MinSizeRel. This variable is only supported for make based generators. If this variable is supported, then CMake will also provide initial values for the variables with the name  CMAKE_C_FLAGS_[Debug|Release|RelWithDebInfo|MinSizeRel]. For example, if CMAKE_BUILD_TYPE is Debug, then CMAKE_C_FLAGS_DEBUG will be added to the CMAKE_C_FLAGS.

.TP
.B CMAKE_CONFIGURATION_TYPES
Specifies the available build types.

This specifies what build types will be available such as Debug, Release, RelWithDebInfo etc. This has reasonable defaults on most platforms. But can be extended to provide other build types. See also CMAKE_BUILD_TYPE.

.TP
.B CMAKE_CROSSCOMPILING
Is CMake currently cross compiling.

This variable will be set to true by CMake if CMake is cross compiling. Specifically if the build platform is different from the target platform.

.TP
.B CMAKE_FIND_LIBRARY_PREFIXES
Prefixes to prepend when looking for libraries.

This specifies what prefixes to add to library names when the find_library command looks for libraries. On UNIX systems this is typically lib, meaning that when trying to find the foo library it will look for libfoo.

.TP
.B CMAKE_FIND_LIBRARY_SUFFIXES
Suffixes to append when looking for libraries.

This specifies what suffixes to add to library names when the find_library command looks for libraries. On Windows systems this is typically .lib and .dll, meaning that when trying to find the foo library it will look for foo.dll etc.

.TP
.B CMAKE_INSTALL_PREFIX
Install directory used by install.

If "make install" is invoked or INSTALL is built, this directory is pre-pended onto all install directories. This variable defaults to /usr/local on UNIX and c:/Program Files on Windows.

.TP
.B CMAKE_MFC_FLAG
Tell cmake to use MFC for an executable or dll.

This can be set in a CMakeLists.txt file and will enable MFC in the application.  It should be set to 1 for static the static MFC library, and 2 for the shared MFC library.  This is used in visual studio 6 and 7 project files.   The CMakeSetup dialog uses MFC and the CMakeLists.txt looks like this:


ADD_DEFINITIONS(-D_AFXDLL)


set(CMAKE_MFC_FLAG 2)


add_executable(CMakeSetup WIN32 ${SRCS})


.TP
.B CMAKE_MODULE_PATH
Path to look for cmake modules to load.

Specifies a path to override the default seach path for CMake modules. For example include commands will look in this path first for modules to include.

.TP
.B CMAKE_NOT_USING_CONFIG_FLAGS
Skip _BUILD_TYPE flags if true.

This is an internal flag used by the generators in CMake to tell CMake to skip the _BUILD_TYPE flags.

.TP
.B CMAKE_USER_MAKE_RULES_OVERRIDE
Specify a file that can change the build rule variables.

If this variable is set, it should to point to a CMakeLists.txt file that will be read in by CMake after all the system settings have been set, but before they have been used.  This would allow you to override any variables that need to be changed for some special project. 

.SH VARIABLES THAT DESCRIBE THE SYSTEM
.TP
.B APPLE
True if running on Mac OSX.

Set to true on Mac OSX.

.TP
.B BORLAND
True of the borland compiler is being used.

This is set to true if the Borland compiler is being used.

.TP
.B CMAKE_CL_64
Using the 64 bit compiler from Microsoft

Set to true when using the 64 bit cl compiler from Microsoft.

.TP
.B CMAKE_COMPILER_2005
Using the Visual Studio 2005 compiler from Microsoft

Set to true when using the Visual Studio 2005 compiler from Microsoft.

.TP
.B CMAKE_HOST_APPLE
True for Apple OSXoperating systems.

Set to true when the host system is Apple OSX.

.TP
.B CMAKE_HOST_SYSTEM
Name of system cmake is being run on.

The same as CMAKE_SYSTEM but for the host system instead of the target system when cross compiling.

.TP
.B CMAKE_HOST_SYSTEM_NAME
Name of the OS CMake is running on.

The same as CMAKE_SYSTEM_NAME but for the host system instead of the target system when cross compiling.

.TP
.B CMAKE_HOST_SYSTEM_PROCESSOR
The name of the CPU CMake is running on.

The same as CMAKE_SYSTEM_PROCESSOR but for the host system instead of the target system when cross compiling.

.TP
.B CMAKE_HOST_SYSTEM_VERSION
OS version CMake is running on.

The same as CMAKE_SYSTEM_VERSION but for the host system instead of the target system when cross compiling.

.TP
.B CMAKE_HOST_UNIX
True for UNIX and UNIX like operating systems.

Set to true when the host system is UNIX or UNIX like (i.e. APPLE and CYGWIN).

.TP
.B CMAKE_HOST_WIN32
True on windows systems, including win64.

Set to true when the host system is Windows and on cygwin.

.TP
.B CMAKE_SYSTEM
Name of system cmake is compiling for.

This variable is the composite of CMAKE_SYSTEM_NAMEand CMAKE_SYSTEM_VERSION, like this ${CMAKE_SYSTEM_NAME}-${CMAKE_SYSTEM_VERSION}. If CMAKE_SYSTEM_VERSION is not set, then CMAKE_SYSTEM is the same as CMAKE_SYSTEM_NAME.

.TP
.B CMAKE_SYSTEM_NAME
Name of the OS CMake is building for.

This is the name of the operating system on which CMake is targeting.   On systems that have the uname command, this variable is set to the output of uname -s.  Linux, Windows,  and Darwin for Mac OSX are the values found  on the big three operating systems.

.TP
.B CMAKE_SYSTEM_PROCESSOR
The name of the CPU CMake is building for.

On systems that support uname, this variable is set to the output of uname -p, on windows it is set to the value of the environment variable PROCESSOR_ARCHITECTURE

.TP
.B CMAKE_SYSTEM_VERSION
OS version CMake is building for.

A numeric version string for the system, on systems that support uname, this variable is set to the output of uname -r. On other systems this is set to major-minor version numbers.

.TP
.B CYGWIN
True for cygwin.

Set to true when using CYGWIN.

.TP
.B MSVC
True when using Microsoft Visual C

Set to true when the compiler is some version of Microsoft Visual C.

.TP
.B MSVC80
True when using Microsoft Visual C 8.0

Set to true when the compiler is version 8.0 of Microsoft Visual C.

.TP
.B MSVC_IDE
True when using the Microsoft Visual C IDE

Set to true when the target platform is the Microsoft Visual C IDE, as opposed to the command line compiler.

.TP
.B MSVC_VERSION
The version of Microsoft Visual C/C++ being used if any.

The version of Microsoft Visual C/C++ being used if any. For example 1300 is MSVC 6.0.

.TP
.B UNIX
True for UNIX and UNIX like operating systems.

Set to true when the target system is UNIX or UNIX like (i.e. APPLE and CYGWIN).

.TP
.B WIN32
True on windows systems, including win64.

Set to true when the target system is Windows and on cygwin.

.SH VARIABLES FOR LANGUAGES
.TP
.B CMAKE_<LANG>_ARCHIVE_APPEND
Rule variable to append to a static archive.

This is a rule variable that tells CMake how to append to a static archive.  It is used in place of CMAKE_<LANG>_CREATE_STATIC_LIBRARY on some platforms in order to support large object counts.  See also CMAKE_<LANG>_ARCHIVE_CREATE and CMAKE_<LANG>_ARCHIVE_FINISH.

.TP
.B CMAKE_<LANG>_ARCHIVE_CREATE
Rule variable to create a new static archive.

This is a rule variable that tells CMake how to create a static archive.  It is used in place of CMAKE_<LANG>_CREATE_STATIC_LIBRARY on some platforms in order to support large object counts.  See also CMAKE_<LANG>_ARCHIVE_APPEND and CMAKE_<LANG>_ARCHIVE_FINISH.

.TP
.B CMAKE_<LANG>_ARCHIVE_FINISH
Rule variable to finish an existing static archive.

This is a rule variable that tells CMake how to finish a static archive.  It is used in place of CMAKE_<LANG>_CREATE_STATIC_LIBRARY on some platforms in order to support large object counts.  See also CMAKE_<LANG>_ARCHIVE_CREATE and CMAKE_<LANG>_ARCHIVE_APPEND.

.TP
.B CMAKE_<LANG>_COMPILER
The full path to the compiler for LANG.

This is the command that will be used as the <LANG> compiler. Once set, you can not change this variable.

.TP
.B CMAKE_<LANG>_COMPILER_ABI
An internal variable subject to change.

This is used in determining the compiler ABI and is subject to change.

.TP
.B CMAKE_<LANG>_COMPILER_ID
An internal variable subject to change.

This is used in determining the compiler and is subject to change.

.TP
.B CMAKE_<LANG>_COMPILE_OBJECT
Rule variable to compile a single object file.

This is a rule variable that tells CMake how to compile a single object file for for the language <LANG>.

.TP
.B CMAKE_<LANG>_CREATE_SHARED_LIBRARY
Rule variable to create a shared library.

This is a rule variable that tells CMake how to create a shared library for the language <LANG>.

.TP
.B CMAKE_<LANG>_CREATE_SHARED_MODULE
Rule variable to create a shared module.

This is a rule variable that tells CMake how to create a shared library for the language <LANG>.

.TP
.B CMAKE_<LANG>_CREATE_STATIC_LIBRARY
Rule variable to create a static library.

This is a rule variable that tells CMake how to create a static library for the language <LANG>.

.TP
.B CMAKE_<LANG>_FLAGS_DEBUG
Flags for Debug build type or configuration.

<LANG> flags used when CMAKE_BUILD_TYPE is Debug.

.TP
.B CMAKE_<LANG>_FLAGS_MINSIZEREL
Flags for MinSizeRel build type or configuration.

<LANG> flags used when CMAKE_BUILD_TYPE is MinSizeRel.Short for minimum size release.

.TP
.B CMAKE_<LANG>_FLAGS_RELEASE
Flags for Release build type or configuration.

<LANG> flags used when CMAKE_BUILD_TYPE is Release

.TP
.B CMAKE_<LANG>_FLAGS_RELWITHDEBINFO
Flags for RelWithDebInfo type or configuration.

<LANG> flags used when CMAKE_BUILD_TYPE is RelWithDebInfo. Short for Release With Debug Information.

.TP
.B CMAKE_<LANG>_IGNORE_EXTENSIONS
File extensions that should be ignored by the build.

This is a list of file extensions that may be part of a project for a given language but are not compiled. 

.TP
.B CMAKE_<LANG>_LINKER_PREFERENCE
Determine if a language should be used for linking.

If this is "Preferred" then if there is a mixed language shared library or executable, then this languages linker command will be used.

.TP
.B CMAKE_<LANG>_LINK_EXECUTABLE 
Rule variable to link and executable.

Rule variable to link and executable for the given language.

.TP
.B CMAKE_<LANG>_OUTPUT_EXTENSION
Extension for the output of a compile for a single file.

This is the extension for an object file for the given <LANG>. For example .obj for C on Windows.

.TP
.B CMAKE_<LANG>_PLATFORM_ID
An internal variable subject to change.

This is used in determining the platform and is subject to change.

.TP
.B CMAKE_<LANG>_SIZEOF_DATA_PTR
An internal variable subject to change.

This is used in determining the architecture and is subject to change.

.TP
.B CMAKE_<LANG>_SOURCE_FILE_EXTENSIONS
Extensions of source files for the given language.

This is the list of extensions for a given languages source files.

.TP
.B CMAKE_COMPILER_IS_GNU<LANG>
True if the compiler is GNU.

If the selected <LANG> compiler is the GNU compiler then this is TRUE, if not it is FALSE.

.TP
.B CMAKE_INTERNAL_PLATFORM_ABI
An internal variable subject to change.

This is used in determining the compiler ABI and is subject to change.

.TP
.B CMAKE_USER_MAKE_RULES_OVERRIDE_<LANG>
Specify a file that can change the build rule variables.

If this variable is set, it should to point to a CMakeLists.txt file that will be read in by CMake after all the system settings have been set, but before they have been used.  This would allow you to override any variables that need to be changed for some language. 

.SH VARIABLES THAT CONTROL THE BUILD
.TP
.B CMAKE_ARCHIVE_OUTPUT_DIRECTORY
Where to put all the ARCHIVE targets when built.

This variable is used to initialize the ARCHIVE_OUTPUT_DIRECTORY property on all the targets. See that target property for additional information.

.TP
.B CMAKE_BUILD_WITH_INSTALL_RPATH
Use the install path for the RPATH

Normally CMake uses the build tree for the RPATH when building executables etc on systems that use RPATH. When the software is installed the executables etc are relinked by CMake to have the install RPATH. If this variable is set to true then the software is always built with the install path for the RPATH and does not need to be relinked when installed.

.TP
.B CMAKE_DEBUG_POSTFIX
A postfix to add to targets when build as debug.

This variable is used to initialize the DEBUG_POSTFIX property on all the targets. If set the postfix will be appended to any targets built when the configuration is Debug.

.TP
.B CMAKE_EXE_LINKER_FLAGS
Linker flags used to create executables.

Flags used by the linker when creating an executable.

.TP
.B CMAKE_EXE_LINKER_FLAGS_[CMAKE_BUILD_TYPE]
Flag used when linking an executable.

Same as CMAKE_C_FLAGS_* but used by the linker when creating executables.

.TP
.B CMAKE_Fortran_MODULE_DIRECTORY
Fortran module output directory.

This variable is used to initialize the Fortran_MODULE_DIRECTORY property on all the targets. See that target property for additional information.

.TP
.B CMAKE_INSTALL_NAME_DIR
Mac OSX directory name for installed targets.

CMAKE_INSTALL_NAME_DIR is used to initialize the INSTALL_NAME_DIR property on all targets. See that target property for more information.

.TP
.B CMAKE_INSTALL_RPATH
The rpath to use for installed targets.

A semicolon-separated list specifying the rpath to use in installed targets (for platforms that support it). This is used to initialize the target property INSTALL_RPATH for all targets.

.TP
.B CMAKE_INSTALL_RPATH_USE_LINK_PATH
Add paths to linker search and installed rpath.

CMAKE_INSTALL_RPATH_USE_LINK_PATH is a boolean that if set to true will append directories in the linker search path and outside the project to the INSTALL_RPATH. This is used to initialize the target property INSTALL_RPATH_USE_LINK_PATH for all targets.

.TP
.B CMAKE_LIBRARY_OUTPUT_DIRECTORY
Where to put all the LIBRARY targets when built.

This variable is used to initialize the LIBRARY_OUTPUT_DIRECTORY property on all the targets. See that target property for additional information.

.TP
.B CMAKE_LIBRARY_PATH_FLAG
The flag used to add a library search path to a compiler.

The flag used to specify a library directory to the compiler. On most compilers this is "-L".

.TP
.B CMAKE_LINK_DEF_FILE_FLAG  
Linker flag used to specify a .def file for dll creation.

The flag used to add a .def file when creating a dll on Windows, this is only defined on Windows.

.TP
.B CMAKE_LINK_LIBRARY_FILE_FLAG
Flag used to link a library specified by a path to its file.

The flag used before a library file path is given to the linker.  This is needed only on very few platforms.

.TP
.B CMAKE_LINK_LIBRARY_FLAG
Flag used to link a library into an executable.

The flag used to specify a library to link to an executable.  On most compilers this is "-l".

.TP
.B CMAKE_RUNTIME_OUTPUT_DIRECTORY
Where to put all the RUNTIME targets when built.

This variable is used to initialize the RUNTIME_OUTPUT_DIRECTORY property on all the targets. See that target property for additional information.

.TP
.B CMAKE_SKIP_BUILD_RPATH
Do not include RPATHs in the build tree.

Normally CMake uses the build tree for the RPATH when building executables etc on systems that use RPATH. When the software is installed the executables etc are relinked by CMake to have the install RPATH. If this variable is set to true then the software is always built with no RPATH.

.TP
.B CMAKE_USE_RELATIVE_PATHS
Use relative paths (May not work!).

If this is set to TRUE, then the CMake will use relative paths between the source and binary tree. This option does not work for more complicated projects, and relative paths are used when possible.  In general, it is not possible to move CMake generated makefiles to a different location regardless of the value of this variable.

.TP
.B EXECUTABLE_OUTPUT_PATH
Old executable location variable.

This variable should no longer be used as of CMake 2.6.  Use the RUNTIME_OUTPUT_DIRECTORY target property instead.  It will override this variable if it is set.


If set, this is the directory where all executables built during the build process will be placed.

.TP
.B LIBRARY_OUTPUT_PATH
Old library location variable.

This variable should no longer be used as of CMake 2.6.  Use the ARCHIVE_OUTPUT_DIRECTORY, LIBRARY_OUTPUT_DIRECTORY, and RUNTIME_OUTPUT_DIRECTORY target properties instead.  They will override this variable if they are set.


If set, this is the directory where all the libraries built during the build process will be placed.

.SH VARIABLES THAT PROVIDE INFORMATION
.PP
variables defined by cmake, that give information about the project, and cmake

.TP
.B CMAKE_AR
Name of archiving tool for static libraries.

This specifies name of the program that creates archive or static libraries.

.TP
.B CMAKE_BINARY_DIR
The path to the top level of the build tree.

This is the full path to the top level of the current CMake build tree. For an in-source build, this would be the same as CMAKE_SOURCE_DIR. 

.TP
.B CMAKE_BUILD_TOOL
Tool used for the acutal build process.

This variable is set to the program that will be needed to build the output of CMake.   If the generator selected was Visual Studio 6, the CMAKE_MAKE_PROGRAM will be set to msdev, for Unix makefiles it will be set to make or gmake, and for Visual Studio 7 it set to devenv.  For Nmake Makefiles the value is nmake. This can be useful for adding special flags and commands based on the final build environment. 

.TP
.B CMAKE_CACHEFILE_DIR
The directory with the CMakeCache.txt file.

This is the full path to the directory that has the CMakeCache.txt file in it.  This is the same as CMAKE_BINARY_DIR.

.TP
.B CMAKE_CACHE_MAJOR_VERSION
Major version of CMake used to create the CMakeCache.txt file

This is stores the major version of CMake used to write a CMake cache file. It is only different when a different version of CMake is run on a previously created cache file.

.TP
.B CMAKE_CACHE_MINOR_VERSION
Minor version of CMake used to create the CMakeCache.txt file

This is stores the minor version of CMake used to write a CMake cache file. It is only different when a different version of CMake is run on a previously created cache file.

.TP
.B CMAKE_CACHE_RELEASE_VERSION
Release version of CMake used to create the CMakeCache.txt file

This is stores the release version of CMake used to write a CMake cache file. It is only different when a different version of CMake is run on a previously created cache file.

.TP
.B CMAKE_CFG_INTDIR
Build time configuration directory for project.

This is a variable that is used to provide developers access to the intermediate directory used by Visual Studio IDE projects.   For example, if building Debug all executables and libraries end up in a Debug directory.   On UNIX systems this variable is set to ".".  However, with Visual Studio this variable is set to $(IntDir).   $(IntDir) is expanded by the IDE only.  So this variable should only be used in custom commands that will be run during the build process.   This variable should not be used directly in a CMake command.  CMake has no way of knowing if Debug or Release will be picked by the IDE for a build type. If a program needs to know the directory it was built in, it can use CMAKE_INTDIR. CMAKE_INTDIR is a C/C++ preprocessor macro that is defined on the command line of the compiler.   If it has a value, it will be the intermediate directory used to build the file.   This way an executable or a library can find files that are located in the build directory.

.TP
.B CMAKE_COMMAND
The full path to the cmake executable.

This is the full path to the CMake executable cmake which is useful from custom commands that want to use the cmake -E option for portable system commands. (e.g. /usr/local/bin/cmake

.TP
.B CMAKE_CTEST_COMMAND
Full path to ctest command installed with cmake.

This is the full path to the CTest executable ctest which is useful from custom commands that want  to use the cmake -E option for portable system commands.

.TP
.B CMAKE_CURRENT_BINARY_DIR
The path to the binary directory currently being processed.

This the full path to the build directory that is currently being processed by cmake.  Each directory added by add_subdirectory will create a binary directory in the build tree, and as it is being processed this variable will be set. For in-source builds this is the current source directory being processed.

.TP
.B CMAKE_CURRENT_LIST_FILE
Full path to the listfile currently being processed.

As CMake processes the listfiles in your project this variable will always be set to the one currently being processed. See also CMAKE_PARENT_LIST_FILE.

.TP
.B CMAKE_CURRENT_LIST_LINE
The line number of the current file being processed.

This is the line number of the file currently being processed by cmake.

.TP
.B CMAKE_CURRENT_SOURCE_DIR
The path to the source directory currently being processed.

This the full path to the source directory that is currently being processed by cmake.  

.TP
.B CMAKE_DL_LIBS
Name of library containing dlopen and dlcose.

The name of the library that has dlopen and dlclose in it, usually -ldl on most UNIX machines.

.TP
.B CMAKE_EDIT_COMMAND
Full path to CMakeSetup or ccmake.

This is the full path to the CMake executable that can graphically edit the cache.  For example, CMakeSetup, ccmake, or cmake -i.

.TP
.B CMAKE_EXECUTABLE_SUFFIX
The suffix for executables on this platform.

The suffix to use for the end of an executable if any, .exe on Windows.

.TP
.B CMAKE_GENERATOR
The generator used to build the project.

The name of the generator that is being used to generate the build files.  (e.g. "Unix Makefiles", "Visual Studio 6", etc.)

.TP
.B CMAKE_HOME_DIRECTORY
Path to top of source tree.

This is the path to the top level of the source tree.

.TP
.B CMAKE_IMPORT_LIBRARY_PREFIX
The prefix for import libraries that you link to.

The prefix to use for the name of an import library if used on this platform.

.TP
.B CMAKE_IMPORT_LIBRARY_SUFFIX
The suffix for import  libraries that you link to.

The suffix to use for the end of an import library if used onthis platform.

.TP
.B CMAKE_LINK_LIBRARY_SUFFIX
The suffix for libraries that you link to.

The suffix to use for the end of a library, .lib on Windows.

.TP
.B CMAKE_MAJOR_VERSION
The Major version of cmake (i.e. the 2 in 2.X.X)

This specifies the major version of the CMake executable being run.

.TP
.B CMAKE_MAKE_PROGRAM
See CMAKE_BUILD_TOOL.

This variable is around for backwards compatibility, see CMAKE_BUILD_TOOL.

.TP
.B CMAKE_MINOR_VERSION
The Minor version of cmake (i.e. the 4 in X.4.X).

This specifies the minor version of the CMake executable being run.

.TP
.B CMAKE_PARENT_LIST_FILE
Full path to the parent listfile of the one currently being processed.

As CMake processes the listfiles in your project this variable will always be set to the listfile that included or somehow invoked the one currently being processed. See also CMAKE_CURRENT_LIST_FILE.

.TP
.B CMAKE_PROJECT_NAME
The name of the current project.

This specifies name of the current project from the closest inherited PROJECT command.

.TP
.B CMAKE_RANLIB
Name of randomizing tool for static libraries.

This specifies name of the program that randomizes libraries on UNIX, not used on Windows, but may be present.

.TP
.B CMAKE_ROOT
Install directory for running cmake.

This is the install root for the running CMake and the Modules directory can be found here. This is commonly used in this format: ${CMAKE_ROOT}/Modules

.TP
.B CMAKE_SHARED_LIBRARY_PREFIX
The prefix for shared libraries that you link to.

The prefix to use for the name of a shared library, lib on UNIX.

.TP
.B CMAKE_SHARED_LIBRARY_SUFFIX
The suffix for shared libraries that you link to.

The suffix to use for the end of a shared library, .dll on Windows.

.TP
.B CMAKE_SHARED_MODULE_PREFIX
The prefix for loadable modules that you link to.

The prefix to use for the name of a loadable module on this platform.

.TP
.B CMAKE_SHARED_MODULE_SUFFIX
The suffix for shared libraries that you link to.

The suffix to use for the end of a loadable module on this platform

.TP
.B CMAKE_SIZEOF_VOID_P
Size of a void pointer.

This is set to the size of a pointer on the machine, and is determined by a try compile. If a 64 bit size is found, then the library search path is modified to look for 64 bit libraries first.

.TP
.B CMAKE_SKIP_RPATH
If true, do not add run time path information.

If this is set to TRUE, then the rpath information is not added to compiled executables.  The defaultis to add rpath information if the platform supports it.This allows for easy running from the build tree.

.TP
.B CMAKE_SOURCE_DIR
The path to the top level of the source tree.

This is the full path to the top level of the current CMake source tree. For an in-source build, this would be the same as CMAKE_BINARY_DIR. 

.TP
.B CMAKE_STANDARD_LIBRARIES
Libraries linked into every executable and shared library.

This is the list of libraries that are linked into all executables and libraries.

.TP
.B CMAKE_STATIC_LIBRARY_PREFIX
The prefix for static libraries that you link to.

The prefix to use for the name of a static library, lib on UNIX.

.TP
.B CMAKE_STATIC_LIBRARY_SUFFIX
The suffix for static libraries that you link to.

The suffix to use for the end of a static library, .lib on Windows.

.TP
.B CMAKE_USING_VC_FREE_TOOLS
True if free visual studio tools being used.

This is set to true if the compiler is Visual Studio free tools.

.TP
.B CMAKE_VERBOSE_MAKEFILE
Create verbose makefiles if on.

This variable defaults to false. You can set this variable to true to make CMake produce verbose makefiles that show each command line as it is used.

.TP
.B PROJECT_BINARY_DIR
Full path to build directory for project.

This is the binary directory of the most recent PROJECT command.

.TP
.B PROJECT_NAME
Name of the project given to the project command.

This is the name given to the most recent PROJECT command. 

.TP
.B PROJECT_SOURCE_DIR
Top level source directory for the current project.

This is the source directory of the most recent PROJECT command.

.TP
.B [Project name]_BINARY_DIR
Top level binary directory for the named project.

A variable is created with the name used in the PROJECT command, and is the binary directory for the project.   This can be useful when SUBDIR is used to connect several projects.

.TP
.B [Project name]_SOURCE_DIR
Top level source directory for the named project.

A variable is created with the name used in the PROJECT command, and is the source directory for the project.   This can be useful when add_subdirectory is used to connect several projects.

.SH COPYRIGHT
.PP
Copyright (c) 2002 Kitware, Inc., Insight Consortium.  All rights reserved.

.PP
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

.PP
Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

.PP
Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

.PP
The names of Kitware, Inc., the Insight Consortium, or the names of any consortium members, or of any contributors, may not be used to endorse or promote products derived from this software without specific prior written permission.

.PP
Modified source versions must be plainly marked as such, and must not be misrepresented as being the original software.

.PP
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

.SH SEE ALSO
.PP
.B ccmake(1), cpack(1), ctest(1), cmakecommands(1), cmakecompat(1), cmakemodules(1), cmakeprops(1), cmakevars(1)

.PP
The following resources are available to get help using CMake:

.TP
.B Home Page
http://www.cmake.org

The primary starting point for learning about CMake.

.TP
.B Frequently Asked Questions
http://www.cmake.org/Wiki/CMake_FAQ

A Wiki is provided containing answers to frequently asked questions. 

.TP
.B Online Documentation
http://www.cmake.org/HTML/Documentation.html

Links to available documentation may be found on this web page.

.TP
.B Mailing List
http://www.cmake.org/HTML/MailingLists.html

For help and discussion about using cmake, a mailing list is provided at cmake@cmake.org. The list is member-post-only but one may sign up on the CMake web page. Please first read the full documentation at http://www.cmake.org before posting questions to the list.

.PP
Summary of helpful links:


  Home: http://www.cmake.org
  Docs: http://www.cmake.org/HTML/Documentation.html
  Mail: http://www.cmake.org/HTML/MailingLists.html
  FAQ:  http://www.cmake.org/Wiki/CMake_FAQ

.SH AUTHOR
.PP
This manual page was generated by the "--help-man" option.

