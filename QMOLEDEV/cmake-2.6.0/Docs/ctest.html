<html><body>
<h2><a name="section_Index"/>Master Index</h2>
<ul>
  <li><a href="#section_Name"<b>Name</b></a></li>
  <li><a href="#section_Usage"<b>Usage</b></a></li>
  <li><a href="#section_Description"<b>Description</b></a></li>
  <li><a href="#section_Options"<b>Options</b></a></li>
  <li><a href="#section_Generators"<b>Generators</b></a></li>
  <li><a href="#section_Commands"<b>Commands</b></a></li>
  <li><a href="#section_Properties"<b>Properties</b></a></li>
  <li><a href="#section_Compatibility Commands"<b>Compatibility Commands</b></a></li>
  <li><a href="#section_Standard CMake Modules"<b>Standard CMake Modules</b></a></li>
  <li><a href="#section_Copyright"<b>Copyright</b></a></li>
  <li><a href="#section_See Also"<b>See Also</b></a></li>
</ul>
<h2><a name="section_Name"/>Name</h2>
<ul>
</ul>
<pre>  ctest - Testing driver provided by CMake.</pre>
    
<h2><a name="section_Usage"/>Usage</h2>
<ul>
</ul>
<pre>  ctest [options]</pre>
    
<h2><a name="section_Description"/>Description</h2>
<ul>
</ul>
<p>The "ctest" executable is the CMake test driver program.  CMake-generated build trees created for projects that use the ENABLE_TESTING and ADD_TEST commands have testing support.  This program will run the tests and report results.
<h2><a name="section_Options"/>Options</h2>
<ul>
    <li><a href="#opt:-Ccfg--build-configcfg"><b><code>-C &lt;cfg&gt;, --build-config &lt;cfg&gt;</code></b></a></li>    <li><a href="#opt:-V--verbose"><b><code>-V,--verbose</code></b></a></li>    <li><a href="#opt:-VV--extra-verbose"><b><code>-VV,--extra-verbose</code></b></a></li>    <li><a href="#opt:--debug"><b><code>--debug</code></b></a></li>    <li><a href="#opt:-Q--quiet"><b><code>-Q,--quiet</code></b></a></li>    <li><a href="#opt:-Ofile--output-logfile"><b><code>-O &lt;file&gt;, --output-log &lt;file&gt;</code></b></a></li>    <li><a href="#opt:-N--show-only"><b><code>-N,--show-only</code></b></a></li>    <li><a href="#opt:-Rregex--tests-regexregex"><b><code>-R &lt;regex&gt;, --tests-regex &lt;regex&gt;</code></b></a></li>    <li><a href="#opt:-Eregex--exclude-regexregex"><b><code>-E &lt;regex&gt;, --exclude-regex &lt;regex&gt;</code></b></a></li>    <li><a href="#opt:-Ddashboard--dashboarddashboard"><b><code>-D &lt;dashboard&gt;, --dashboard &lt;dashboard&gt;</code></b></a></li>    <li><a href="#opt:-Mmodel--test-modelmodel"><b><code>-M &lt;model&gt;, --test-model &lt;model&gt;</code></b></a></li>    <li><a href="#opt:-Taction--test-actionaction"><b><code>-T &lt;action&gt;, --test-action &lt;action&gt;</code></b></a></li>    <li><a href="#opt:--tracktrack"><b><code>--track &lt;track&gt;</code></b></a></li>    <li><a href="#opt:-Sscript--scriptscript"><b><code>-S &lt;script&gt;, --script &lt;script&gt;</code></b></a></li>    <li><a href="#opt:-SPscript--script-new-processscript"><b><code>-SP &lt;script&gt;, --script-new-process &lt;script&gt;</code></b></a></li>    <li><a href="#opt:-Afile--add-notesfile"><b><code>-A &lt;file&gt;, --add-notes &lt;file&gt;</code></b></a></li>    <li><a href="#opt:-IStartEndStridetesttestTestfile--tests-information"><b><code>-I [Start,End,Stride,test#,test#|Test file], --tests-information</code></b></a></li>    <li><a href="#opt:-U--union"><b><code>-U, --union</code></b></a></li>    <li><a href="#opt:--interactive-debug-mode01"><b><code>--interactive-debug-mode [0|1]</code></b></a></li>    <li><a href="#opt:--build-and-test"><b><code>--build-and-test</code></b></a></li>    <li><a href="#opt:--build-target"><b><code>--build-target</code></b></a></li>    <li><a href="#opt:--build-nocmake"><b><code>--build-nocmake</code></b></a></li>    <li><a href="#opt:--build-run-dir"><b><code>--build-run-dir</code></b></a></li>    <li><a href="#opt:--build-two-config"><b><code>--build-two-config</code></b></a></li>    <li><a href="#opt:--build-exe-dir"><b><code>--build-exe-dir</code></b></a></li>    <li><a href="#opt:--build-generator"><b><code>--build-generator</code></b></a></li>    <li><a href="#opt:--build-project"><b><code>--build-project</code></b></a></li>    <li><a href="#opt:--build-makeprogram"><b><code>--build-makeprogram</code></b></a></li>    <li><a href="#opt:--build-noclean"><b><code>--build-noclean</code></b></a></li>    <li><a href="#opt:--build-config-sample"><b><code>--build-config-sample</code></b></a></li>    <li><a href="#opt:--build-options"><b><code>--build-options</code></b></a></li>    <li><a href="#opt:--test-command"><b><code>--test-command</code></b></a></li>    <li><a href="#opt:--test-timeout"><b><code>--test-timeout</code></b></a></li>    <li><a href="#opt:--tomorrow-tag"><b><code>--tomorrow-tag</code></b></a></li>    <li><a href="#opt:--ctest-config"><b><code>--ctest-config</code></b></a></li>    <li><a href="#opt:--overwrite"><b><code>--overwrite</code></b></a></li>    <li><a href="#opt:--extra-submitfilefile"><b><code>--extra-submit &lt;file&gt;[;&lt;file&gt;]</code></b></a></li>    <li><a href="#opt:--force-new-ctest-process"><b><code>--force-new-ctest-process</code></b></a></li>    <li><a href="#opt:--submit-index"><b><code>--submit-index</code></b></a></li></ul>
<ul>
  <li>
    <a name="opt:-Ccfg--build-configcfg"><b><code>-C &lt;cfg&gt;, --build-config &lt;cfg&gt;</code></b></a>: Choose configuration to test.<br>
    <p>Some CMake-generated build trees can have multiple build configurations in the same tree.  This option can be used to specify which one should be tested.  Example configurations are "Debug" and "Release".
  </li>
  <li>
    <a name="opt:-V--verbose"><b><code>-V,--verbose</code></b></a>: Enable verbose output from tests.<br>
    <p>Test output is normally suppressed and only summary information is displayed.  This option will show all test output.
  </li>
  <li>
    <a name="opt:-VV--extra-verbose"><b><code>-VV,--extra-verbose</code></b></a>: Enable more verbose output from tests.<br>
    <p>Test output is normally suppressed and only summary information is displayed.  This option will show even more test output.
  </li>
  <li>
    <a name="opt:--debug"><b><code>--debug</code></b></a>: Displaying more verbose internals of CTest.<br>
    <p>This feature will result in large number of output that is mostly useful for debugging dashboard problems.
  </li>
  <li>
    <a name="opt:-Q--quiet"><b><code>-Q,--quiet</code></b></a>: Make ctest quiet.<br>
    <p>This option will suppress all the output. The output log file will still be generated if the --output-log is specified. Options such as --verbose, --extra-verbose, and --debug are ignored if --quiet is specified.
  </li>
  <li>
    <a name="opt:-Ofile--output-logfile"><b><code>-O &lt;file&gt;, --output-log &lt;file&gt;</code></b></a>: Output to log file<br>
    <p>This option tells ctest to write all its output to a log file.
  </li>
  <li>
    <a name="opt:-N--show-only"><b><code>-N,--show-only</code></b></a>: Disable actual execution of tests.<br>
    <p>This option tells ctest to list the tests that would be run but not actually run them.  Useful in conjunction with the -R and -E options.
  </li>
  <li>
    <a name="opt:-Rregex--tests-regexregex"><b><code>-R &lt;regex&gt;, --tests-regex &lt;regex&gt;</code></b></a>: Run tests matching regular expression.<br>
    <p>This option tells ctest to run only the tests whose names match the given regular expression.
  </li>
  <li>
    <a name="opt:-Eregex--exclude-regexregex"><b><code>-E &lt;regex&gt;, --exclude-regex &lt;regex&gt;</code></b></a>: Exclude tests matching regular expression.<br>
    <p>This option tells ctest to NOT run the tests whose names match the given regular expression.
  </li>
  <li>
    <a name="opt:-Ddashboard--dashboarddashboard"><b><code>-D &lt;dashboard&gt;, --dashboard &lt;dashboard&gt;</code></b></a>: Execute dashboard test<br>
    <p>This option tells ctest to perform act as a Dart client and perform a dashboard test. All tests are &lt;Mode&gt;&lt;Test&gt;, where Mode can be Experimental, Nightly, and Continuous, and Test can be Start, Update, Configure, Build, Test, Coverage, and Submit.
  </li>
  <li>
    <a name="opt:-Mmodel--test-modelmodel"><b><code>-M &lt;model&gt;, --test-model &lt;model&gt;</code></b></a>: Sets the model for a dashboard<br>
    <p>This option tells ctest to act as a Dart client where the TestModel can be Experimental, Nightly, and Continuous. Combining -M and -T is similar to -D
  </li>
  <li>
    <a name="opt:-Taction--test-actionaction"><b><code>-T &lt;action&gt;, --test-action &lt;action&gt;</code></b></a>: Sets the dashboard action to perform<br>
    <p>This option tells ctest to act as a Dart client and perform some action such as start, build, test etc. Combining -M and -T is similar to -D
  </li>
  <li>
    <a name="opt:--tracktrack"><b><code>--track &lt;track&gt;</code></b></a>: Specify the track to submit dashboard to<br>
    <p>Submit dashboard to specified track instead of default one. By default, the dashboard is submitted to Nightly, Experimental, or Continuous track, but by specifying this option, the track can be arbitrary.
  </li>
  <li>
    <a name="opt:-Sscript--scriptscript"><b><code>-S &lt;script&gt;, --script &lt;script&gt;</code></b></a>: Execute a dashboard for a configuration<br>
    <p>This option tells ctest to load in a configuration script which sets a number of parameters such as the binary and source directories. Then ctest will do what is required to create and run a dashboard. This option basically sets up a dashboard and then runs ctest -D with the appropriate options.
  </li>
  <li>
    <a name="opt:-SPscript--script-new-processscript"><b><code>-SP &lt;script&gt;, --script-new-process &lt;script&gt;</code></b></a>: Execute a dashboard for a configuration<br>
    <p>This option does the same operations as -S but it will do them in a seperate process. This is primarily useful in cases where the script may modify the environment and you do not want the modified enviroment to impact other -S scripts.
  </li>
  <li>
    <a name="opt:-Afile--add-notesfile"><b><code>-A &lt;file&gt;, --add-notes &lt;file&gt;</code></b></a>: Add a notes file with submission<br>
    <p>This option tells ctest to include a notes file when submitting dashboard. 
  </li>
  <li>
    <a name="opt:-IStartEndStridetesttestTestfile--tests-information"><b><code>-I [Start,End,Stride,test#,test#|Test file], --tests-information</code></b></a>: Run a specific number of tests by number.<br>
    <p>This option causes ctest to run tests starting at number Start, ending at number End, and incrementing by Stride. Any additional numbers after Stride are considered individual test numbers.  Start, End,or stride can be empty.  Optionally a file can be given that contains the same syntax as the command line.
  </li>
  <li>
    <a name="opt:-U--union"><b><code>-U, --union</code></b></a>: Take the Union of -I and -R<br>
    <p>When both -R and -I are specified by default the intersection of tests are run. By specifying -U the union of tests is run instead.
  </li>
  <li>
    <a name="opt:--interactive-debug-mode01"><b><code>--interactive-debug-mode [0|1]</code></b></a>: Set the interactive mode to 0 or 1.<br>
    <p>This option causes ctest to run tests in either an interactive mode or a non-interactive mode. On Windows this means that in non-interactive mode, all system debug pop up windows are blocked. In dashboard mode (Experimental, Nightly, Continuous), the default is non-interactive.  When just running tests not for a dashboard the default is to allow popups and interactive debugging.
  </li>
  <li>
    <a name="opt:--build-and-test"><b><code>--build-and-test</code></b></a>: Configure, build and run a test.<br>
    <p>This option tells ctest to configure (i.e. run cmake on), build, and or execute a test. The configure and test steps are optional. The arguments to this command line are the source and binary directories. By default this will run CMake on the Source/Bin directories specified unless --build-nocmake is specified. Both --build-makeprogram and --build-generator MUST be provided to use --built-and-test. If --test-command is specified then that will be run after the build is complete. Other options that affect this mode are --build-target --build-nocmake, --build-run-dir, --build-two-config, --build-exe-dir, --build-project,--build-noclean, --build-options
  </li>
  <li>
    <a name="opt:--build-target"><b><code>--build-target</code></b></a>: Specify a specific target to build.<br>
    <p>This option goes with the --build-and-test option, if left out the all target is built.
  </li>
  <li>
    <a name="opt:--build-nocmake"><b><code>--build-nocmake</code></b></a>: Run the build without running cmake first.<br>
    <p>Skip the cmake step.
  </li>
  <li>
    <a name="opt:--build-run-dir"><b><code>--build-run-dir</code></b></a>: Specify directory to run programs from.<br>
    <p>Directory where programs will be after it has been compiled.
  </li>
  <li>
    <a name="opt:--build-two-config"><b><code>--build-two-config</code></b></a>: Run CMake twice
  </li>
  <li>
    <a name="opt:--build-exe-dir"><b><code>--build-exe-dir</code></b></a>: Specify the directory for the executable.
  </li>
  <li>
    <a name="opt:--build-generator"><b><code>--build-generator</code></b></a>: Specify the generator to use.
  </li>
  <li>
    <a name="opt:--build-project"><b><code>--build-project</code></b></a>: Specify the name of the project to build.
  </li>
  <li>
    <a name="opt:--build-makeprogram"><b><code>--build-makeprogram</code></b></a>: Specify the make program to use.
  </li>
  <li>
    <a name="opt:--build-noclean"><b><code>--build-noclean</code></b></a>: Skip the make clean step.
  </li>
  <li>
    <a name="opt:--build-config-sample"><b><code>--build-config-sample</code></b></a>: A sample executable to use to determine the configuraiton<br>
    <p>A sample executable to use to determine the configuraiton that should be used. e.g. Debug/Release/etc
  </li>
  <li>
    <a name="opt:--build-options"><b><code>--build-options</code></b></a>: Add extra options to the build step.<br>
    <p>This option must be the last option with the exception of --test-command
  </li>
  <li>
    <a name="opt:--test-command"><b><code>--test-command</code></b></a>: The test to run with the --build-and-test option.
  </li>
  <li>
    <a name="opt:--test-timeout"><b><code>--test-timeout</code></b></a>: The time limit in seconds, internal use only.
  </li>
  <li>
    <a name="opt:--tomorrow-tag"><b><code>--tomorrow-tag</code></b></a>: Nightly or experimental starts with next day tag.<br>
    <p>This is useful if the build will not finish in one day.
  </li>
  <li>
    <a name="opt:--ctest-config"><b><code>--ctest-config</code></b></a>: The configuration file used to initialize CTest state when submitting dashboards.<br>
    <p>This option tells CTest to use different initialization file instead of CTestConfiguration.tcl. This way multiple initialization files can be used for example to submit to multiple dashboards.
  </li>
  <li>
    <a name="opt:--overwrite"><b><code>--overwrite</code></b></a>: Overwrite CTest configuration option.<br>
    <p>By default ctest uses configuration options from configuration file. This option will overwrite the configuration option.
  </li>
  <li>
    <a name="opt:--extra-submitfilefile"><b><code>--extra-submit &lt;file&gt;[;&lt;file&gt;]</code></b></a>: Submit extra files to the dashboard.<br>
    <p>This option will submit extra files to the dashboard.
  </li>
  <li>
    <a name="opt:--force-new-ctest-process"><b><code>--force-new-ctest-process</code></b></a>: Run child CTest instances as new processes<br>
    <p>By default CTest will run child CTest instances within the same process. If this behavior is not desired, this argument will enforce new processes for child CTest processes.
  </li>
  <li>
    <a name="opt:--submit-index"><b><code>--submit-index</code></b></a>: Submit individual dashboard tests with specific index<br>
    <p>This option allows performing the same CTest action (such as test) multiple times and submit all stages to the same dashboard (Dart2 required). Each execution requires different index.
  </li>
</ul>
<h2><a name="section_Generators"/>Generators</h2>
<ul>
</ul>
<p>The following generators are available on this platform:
<h2><a name="section_Commands"/>Commands</h2>
<ul>
    <li><a href="#command:break"><b><code>break</code></b></a></li>    <li><a href="#command:build_name"><b><code>build_name</code></b></a></li>    <li><a href="#command:cmake_minimum_required"><b><code>cmake_minimum_required</code></b></a></li>    <li><a href="#command:cmake_policy"><b><code>cmake_policy</code></b></a></li>    <li><a href="#command:configure_file"><b><code>configure_file</code></b></a></li>    <li><a href="#command:CTEST_BUILD"><b><code>CTEST_BUILD</code></b></a></li>    <li><a href="#command:CTEST_CONFIGURE"><b><code>CTEST_CONFIGURE</code></b></a></li>    <li><a href="#command:CTEST_COVERAGE"><b><code>CTEST_COVERAGE</code></b></a></li>    <li><a href="#command:CTEST_EMPTY_BINARY_DIRECTORY"><b><code>CTEST_EMPTY_BINARY_DIRECTORY</code></b></a></li>    <li><a href="#command:CTEST_MEMCHECK"><b><code>CTEST_MEMCHECK</code></b></a></li>    <li><a href="#command:CTEST_READ_CUSTOM_FILES"><b><code>CTEST_READ_CUSTOM_FILES</code></b></a></li>    <li><a href="#command:CTEST_RUN_SCRIPT"><b><code>CTEST_RUN_SCRIPT</code></b></a></li>    <li><a href="#command:CTEST_SLEEP"><b><code>CTEST_SLEEP</code></b></a></li>    <li><a href="#command:CTEST_START"><b><code>CTEST_START</code></b></a></li>    <li><a href="#command:CTEST_SUBMIT"><b><code>CTEST_SUBMIT</code></b></a></li>    <li><a href="#command:CTEST_TEST"><b><code>CTEST_TEST</code></b></a></li>    <li><a href="#command:CTEST_UPDATE"><b><code>CTEST_UPDATE</code></b></a></li>    <li><a href="#command:else"><b><code>else</code></b></a></li>    <li><a href="#command:elseif"><b><code>elseif</code></b></a></li>    <li><a href="#command:endforeach"><b><code>endforeach</code></b></a></li>    <li><a href="#command:endfunction"><b><code>endfunction</code></b></a></li>    <li><a href="#command:endif"><b><code>endif</code></b></a></li>    <li><a href="#command:endmacro"><b><code>endmacro</code></b></a></li>    <li><a href="#command:endwhile"><b><code>endwhile</code></b></a></li>    <li><a href="#command:exec_program"><b><code>exec_program</code></b></a></li>    <li><a href="#command:execute_process"><b><code>execute_process</code></b></a></li>    <li><a href="#command:file"><b><code>file</code></b></a></li>    <li><a href="#command:find_file"><b><code>find_file</code></b></a></li>    <li><a href="#command:find_library"><b><code>find_library</code></b></a></li>    <li><a href="#command:find_package"><b><code>find_package</code></b></a></li>    <li><a href="#command:find_path"><b><code>find_path</code></b></a></li>    <li><a href="#command:find_program"><b><code>find_program</code></b></a></li>    <li><a href="#command:foreach"><b><code>foreach</code></b></a></li>    <li><a href="#command:function"><b><code>function</code></b></a></li>    <li><a href="#command:get_cmake_property"><b><code>get_cmake_property</code></b></a></li>    <li><a href="#command:get_directory_property"><b><code>get_directory_property</code></b></a></li>    <li><a href="#command:get_filename_component"><b><code>get_filename_component</code></b></a></li>    <li><a href="#command:get_property"><b><code>get_property</code></b></a></li>    <li><a href="#command:if"><b><code>if</code></b></a></li>    <li><a href="#command:include"><b><code>include</code></b></a></li>    <li><a href="#command:list"><b><code>list</code></b></a></li>    <li><a href="#command:macro"><b><code>macro</code></b></a></li>    <li><a href="#command:make_directory"><b><code>make_directory</code></b></a></li>    <li><a href="#command:mark_as_advanced"><b><code>mark_as_advanced</code></b></a></li>    <li><a href="#command:math"><b><code>math</code></b></a></li>    <li><a href="#command:message"><b><code>message</code></b></a></li>    <li><a href="#command:option"><b><code>option</code></b></a></li>    <li><a href="#command:remove"><b><code>remove</code></b></a></li>    <li><a href="#command:return"><b><code>return</code></b></a></li>    <li><a href="#command:separate_arguments"><b><code>separate_arguments</code></b></a></li>    <li><a href="#command:set"><b><code>set</code></b></a></li>    <li><a href="#command:set_directory_properties"><b><code>set_directory_properties</code></b></a></li>    <li><a href="#command:set_property"><b><code>set_property</code></b></a></li>    <li><a href="#command:site_name"><b><code>site_name</code></b></a></li>    <li><a href="#command:string"><b><code>string</code></b></a></li>    <li><a href="#command:variable_watch"><b><code>variable_watch</code></b></a></li>    <li><a href="#command:while"><b><code>while</code></b></a></li>    <li><a href="#command:write_file"><b><code>write_file</code></b></a></li></ul>
<ul>
  <li>
    <a name="command:break"><b><code>break</code></b></a>: Break from an enclosing foreach or while loop.<br>
    <pre>  break()<br></pre>
    <p>Breaks from an enclosing foreach loop or while loop
  </li>
  <li>
    <a name="command:build_name"><b><code>build_name</code></b></a>: Deprecated.  Use ${CMAKE_SYSTEM} and ${CMAKE_CXX_COMPILER} instead.<br>
    <pre>  build_name(variable)<br></pre>
    <p>Sets the specified variable to a string representing the platform and compiler settings.  These values are now available through the CMAKE_SYSTEM and CMAKE_CXX_COMPILER variables.
  </li>
  <li>
    <a name="command:cmake_minimum_required"><b><code>cmake_minimum_required</code></b></a>: Set the minimum required version of cmake for a project.<br>
    <pre>  cmake_minimum_required(VERSION major[.minor[.patch]]<br>                         [FATAL_ERROR])<br></pre>
    <p>If the current version of CMake is lower than that required it will stop processing the project and report an error.  When a version higher than 2.4 is specified the command implicitly invokes<br><pre>  cmake_policy(VERSION major[.minor[.patch]])<br></pre>
    <p>which sets the cmake policy version level to the version specified.  When version 2.4 or lower is given the command implicitly invokes<br><pre>  cmake_policy(VERSION 2.4)<br></pre>
    <p>which enables compatibility features for CMake 2.4 and lower.<br><p>The FATAL_ERROR option is accepted but ignored.  It is left from CMake versions 2.4 and lower in which failure to meet the minimum version was a warning by default.
  </li>
  <li>
    <a name="command:cmake_policy"><b><code>cmake_policy</code></b></a>: Manage CMake Policy settings.<br>
    <p>As CMake evolves it is sometimes necessary to change existing behavior in order to fix bugs or improve implementations of existing features.  The CMake Policy mechanism is designed to help keep existing projects building as new versions of CMake introduce changes in behavior.  Each new policy (behavioral change) is given an identifier of the form "CMP&lt;NNNN&gt;" where "&lt;NNNN&gt;" is an integer index.  Documentation associated with each policy describes the OLD and NEW behavior and the reason the policy was introduced.  Projects may set each policy to select the desired behavior.  When CMake needs to know which behavior to use it checks for a setting specified by the project.  If no setting is available the OLD behavior is assumed and a warning is produced requesting that the policy be set.<br><p>The cmake_policy command is used to set policies to OLD or NEW behavior.  While setting policies individually is supported, we encourage projects to set policies based on CMake versions.<br><pre>  cmake_policy(VERSION major.minor[.patch])<br></pre>
    <p>Specify that the current CMake list file is written for the given version of CMake.  All policies introduced in the specified version or earlier will be set to use NEW behavior.  All policies introduced after the specified version will be reset to use OLD behavior with a warning.  This effectively requests behavior preferred as of a given CMake version and tells newer CMake versions to warn about their new policies.  The policy version specified must be at least 2.4 or the command will report an error.  In order to get compatibility features supporting versions earlier than 2.4 see documentation of policy CMP0001.<br><pre>  cmake_policy(SET CMP&lt;NNNN&gt; NEW)<br>  cmake_policy(SET CMP&lt;NNNN&gt; OLD)<br></pre>
    <p>Tell CMake to use the OLD or NEW behavior for a given policy.  Projects depending on the old behavior of a given policy may silence a policy warning by setting the policy state to OLD.  Alternatively one may fix the project to work with the new behavior and set the policy state to NEW.<br><pre>  cmake_policy(PUSH)<br>  cmake_policy(POP)<br></pre>
    <p>Push and pop the current policy setting state on a stack.  Each PUSH must have a matching POP.  This is useful when mixing multiple projects, subprojects, and files included from external projects that may each have been written for a different version of CMake.  Each subdirectory entered by the project automatically pushes a new level on the stack to isolate the subdirectories from their parents.
  </li>
  <li>
    <a name="command:configure_file"><b><code>configure_file</code></b></a>: Copy a file to another location and modify its contents.<br>
    <pre>  configure_file(InputFile OutputFile<br>                 [COPYONLY] [ESCAPE_QUOTES] [@ONLY])<br></pre>
    <p>The Input and Output files have to have full paths.  This command replaces any variables in the input file referenced as ${VAR} or @VAR@ with their values as determined by CMake.  If a variable is not defined, it will be replaced with nothing.  If COPYONLY is specified, then no variable expansion will take place.  If ESCAPE_QUOTES is specified then any substituted quotes will be C-style escaped.  The file will be configured with the current values of CMake variables. If @ONLY is specified, only variables of the form @VAR@ will be replaces and ${VAR} will be ignored.  This is useful for configuring scripts that use ${VAR}. Any occurrences of #cmakedefine VAR will be replaced with either #define VAR or /* #undef VAR */ depending on the setting of VAR in CMake
  </li>
  <li>
    <a name="command:CTEST_BUILD"><b><code>CTEST_BUILD</code></b></a>: Builds the repository.<br>
    <pre>  CTEST_BUILD([BUILD build_dir] [RETURN_VALUE res])<br></pre>
    <p>Builds the given build directory and stores results in Build.xml.
  </li>
  <li>
    <a name="command:CTEST_CONFIGURE"><b><code>CTEST_CONFIGURE</code></b></a>: Configures the repository.<br>
    <pre>  CTEST_CONFIGURE(BUILD build_dir RETURN_VALUE res)<br></pre>
    <p>Configures the given build directory and stores results in Configure.xml. The second argument is a variable that will hold return value.
  </li>
  <li>
    <a name="command:CTEST_COVERAGE"><b><code>CTEST_COVERAGE</code></b></a>: Tests the repository.<br>
    <pre>  CTEST_COVERAGE([BUILD build_dir] [RETURN_VALUE res])<br></pre>
    <p>Perform the coverage of the given build directory and stores results in Coverage.xml. The second argument is a variable that will hold value.
  </li>
  <li>
    <a name="command:CTEST_EMPTY_BINARY_DIRECTORY"><b><code>CTEST_EMPTY_BINARY_DIRECTORY</code></b></a>: empties the binary directory<br>
    <pre>  CTEST_EMPTY_BINARY_DIRECTORY( directory )<br></pre>
    <p>Removes a binary directory. This command will perform some checks prior to deleting the directory in an attempt to avoid malicious or accidental directory deletion.
  </li>
  <li>
    <a name="command:CTEST_MEMCHECK"><b><code>CTEST_MEMCHECK</code></b></a>: Tests the repository.<br>
    <pre>  CTEST_MEMCHECK([BUILD build_dir] [RETURN_VALUE res])<br></pre>
    <p>Performs a memory checking of tests in the given build directory and stores results in MemCheck.xml. The second argument is a variable that will hold value.
  </li>
  <li>
    <a name="command:CTEST_READ_CUSTOM_FILES"><b><code>CTEST_READ_CUSTOM_FILES</code></b></a>: read CTestCustom files.<br>
    <pre>  CTEST_READ_CUSTOM_FILES( directory ... )<br></pre>
    <p>Read all the CTestCustom.ctest or CTestCustom.cmake files from the given directory.
  </li>
  <li>
    <a name="command:CTEST_RUN_SCRIPT"><b><code>CTEST_RUN_SCRIPT</code></b></a>: runs a ctest -S script<br>
    <pre>  CTEST_RUN_SCRIPT([NEW_PROCESS] script_file_name script_file_name1 <br>              script_file_name2 ...)<br></pre>
    <p>Runs a script or scripts much like if it was run from ctest -S. If no argument is provided then the current script is run using the current settings of the variables. If NEW_PROCESS is specified then each script will be run in a seperate process.
  </li>
  <li>
    <a name="command:CTEST_SLEEP"><b><code>CTEST_SLEEP</code></b></a>: sleeps for some amount of time<br>
    <pre>  CTEST_SLEEP( seconds )<br>  CTEST_SLEEP( time1 duration time2 )<br></pre>
    <p>With one argument it will sleep for a given number of seconds. With three arguments it will wait for time2 - time1 - duration seconds.
  </li>
  <li>
    <a name="command:CTEST_START"><b><code>CTEST_START</code></b></a>: Starts the testing for a given model<br>
    <pre>  CTEST_START(Model [TRACK &lt;track&gt;] [source [binary]])<br></pre>
    <p>Starts the testing for a given model. The command should be called after the binary directory is initialized. If the 'source' and 'binary' directory are not specified, it reads the CTEST_SOURCE_DIRECTORY and CTEST_BINARY_DIRECTORY. If the track is specified, the submissions will go to the specified track.
  </li>
  <li>
    <a name="command:CTEST_SUBMIT"><b><code>CTEST_SUBMIT</code></b></a>: Submits the repository.<br>
    <pre>  CTEST_SUBMIT([RETURN_VALUE res])<br></pre>
    <p>Submits the test results for the project.
  </li>
  <li>
    <a name="command:CTEST_TEST"><b><code>CTEST_TEST</code></b></a>: Tests the repository.<br>
    <pre>  CTEST_TEST([BUILD build_dir] [RETURN_VALUE res])<br></pre>
    <p>Tests the given build directory and stores results in Test.xml. The second argument is a variable that will hold value.
  </li>
  <li>
    <a name="command:CTEST_UPDATE"><b><code>CTEST_UPDATE</code></b></a>: Updates the repository.<br>
    <pre>  CTEST_UPDATE([SOURCE source] [RETURN_VALUE res])<br></pre>
    <p>Updates the given source directory and stores results in Update.xml. The second argument is a variable that will hold the number of files modified. If there is a problem, the variable will be -1.
  </li>
  <li>
    <a name="command:else"><b><code>else</code></b></a>: Starts the else portion of an if block.<br>
    <pre>  else(expression)<br></pre>
    <p>See the if command.
  </li>
  <li>
    <a name="command:elseif"><b><code>elseif</code></b></a>: Starts the elseif portion of an if block.<br>
    <pre>  elseif(expression)<br></pre>
    <p>See the if command.
  </li>
  <li>
    <a name="command:endforeach"><b><code>endforeach</code></b></a>: Ends a list of commands in a FOREACH block.<br>
    <pre>  endforeach(expression)<br></pre>
    <p>See the FOREACH command.
  </li>
  <li>
    <a name="command:endfunction"><b><code>endfunction</code></b></a>: Ends a list of commands in a function block.<br>
    <pre>  endfunction(expression)<br></pre>
    <p>See the function command.
  </li>
  <li>
    <a name="command:endif"><b><code>endif</code></b></a>: Ends a list of commands in an if block.<br>
    <pre>  endif(expression)<br></pre>
    <p>See the if command.
  </li>
  <li>
    <a name="command:endmacro"><b><code>endmacro</code></b></a>: Ends a list of commands in a macro block.<br>
    <pre>  endmacro(expression)<br></pre>
    <p>See the macro command.
  </li>
  <li>
    <a name="command:endwhile"><b><code>endwhile</code></b></a>: Ends a list of commands in a while block.<br>
    <pre>  endwhile(expression)<br></pre>
    <p>See the while command.
  </li>
  <li>
    <a name="command:exec_program"><b><code>exec_program</code></b></a>: Deprecated.  Use the execute_process() command instead.<br>
    <p>Run an executable program during the processing of the CMakeList.txt file.<br><pre>  exec_program(Executable [directory in which to run]<br>               [ARGS &lt;arguments to executable&gt;]<br>               [OUTPUT_VARIABLE &lt;var&gt;]<br>               [RETURN_VALUE &lt;var&gt;])<br></pre>
    <p>The executable is run in the optionally specified directory.  The executable can include arguments if it is double quoted, but it is better to use the optional ARGS argument to specify arguments to the program.   This is because cmake will then be able to escape spaces in the executable path.  An optional argument OUTPUT_VARIABLE specifies a variable in which to store the output. To capture the return value of the execution, provide a RETURN_VALUE. If OUTPUT_VARIABLE is specified, then no output will go to the stdout/stderr of the console running cmake.<br>
  </li>
  <li>
    <a name="command:execute_process"><b><code>execute_process</code></b></a>: Execute one or more child processes.<br>
    <pre>  execute_process(COMMAND &lt;cmd1&gt; [args1...]]<br>                  [COMMAND &lt;cmd2&gt; [args2...] [...]]<br>                  [WORKING_DIRECTORY &lt;directory&gt;]<br>                  [TIMEOUT &lt;seconds&gt;]<br>                  [RESULT_VARIABLE &lt;variable&gt;]<br>                  [OUTPUT_VARIABLE &lt;variable&gt;]<br>                  [ERROR_VARIABLE &lt;variable&gt;]<br>                  [INPUT_FILE &lt;file&gt;]<br>                  [OUTPUT_FILE &lt;file&gt;]<br>                  [ERROR_FILE &lt;file&gt;]<br>                  [OUTPUT_QUIET]<br>                  [ERROR_QUIET]<br>                  [OUTPUT_STRIP_TRAILING_WHITESPACE]<br>                  [ERROR_STRIP_TRAILING_WHITESPACE])<br></pre>
    <p>Runs the given sequence of one or more commands with the standard output of each process piped to the standard input of the next.  A single standard error pipe is used for all processes.  If WORKING_DIRECTORY is given the named directory will be set as the current working directory of the child processes.  If TIMEOUT is given the child processes will be terminated if they do not finish in the specified number of seconds (fractions are allowed).  If RESULT_VARIABLE is given the variable will be set to contain the result of running the processes.  This will be an integer return code from the last child or a string describing an error condition.  If OUTPUT_VARIABLE or ERROR_VARIABLE are given the variable named will be set with the contents of the standard output and standard error pipes respectively.  If the same variable is named for both pipes their output will be merged in the order produced.  If INPUT_FILE, OUTPUT_FILE, or ERROR_FILE is given the file named will be attached to the standard input of the first process, standard output of the last process, or standard error of all processes respectively.  If OUTPUT_QUIET or ERROR_QUIET is given then the standard output or standard error results will be quietly ignored.  If more than one OUTPUT_* or ERROR_* option is given for the same pipe the precedence is not specified.  If no OUTPUT_* or ERROR_* options are given the output will be shared with the corresponding pipes of the CMake process itself.<br><p>The execute_process command is a newer more powerful version of exec_program, but the old command has been kept for compatibility.
  </li>
  <li>
    <a name="command:file"><b><code>file</code></b></a>: File manipulation command.<br>
    <pre>  file(WRITE filename "message to write"... )<br>  file(APPEND filename "message to write"... )<br>  file(READ filename variable [LIMIT numBytes] [OFFSET offset] [HEX])<br>  file(STRINGS filename variable [LIMIT_COUNT num]<br>       [LIMIT_INPUT numBytes] [LIMIT_OUTPUT numBytes]<br>       [LENGTH_MINIMUM numBytes] [LENGTH_MAXIMUM numBytes]<br>       [NEWLINE_CONSUME] [REGEX regex]<br>       [NO_HEX_CONVERSION])<br>  file(GLOB variable [RELATIVE path] [globbing expressions]...)<br>  file(GLOB_RECURSE variable [RELATIVE path] <br>       [globbing expressions]...)<br>  file(REMOVE [file1 ...])<br>  file(REMOVE_RECURSE [file1 ...])<br>  file(MAKE_DIRECTORY [directory1 directory2 ...])<br>  file(RELATIVE_PATH variable directory file)<br>  file(TO_CMAKE_PATH path result)<br>  file(TO_NATIVE_PATH path result)<br>  file(DOWNLOAD url file [TIMEOUT timeout] [STATUS status] [LOG log])<br></pre>
    <p>WRITE will write a message into a file called 'filename'. It overwrites the file if it already exists, and creates the file if it does not exist.<br><p>APPEND will write a message into a file same as WRITE, except it will append it to the end of the file<br><p>READ will read the content of a file and store it into the variable. It will start at the given offset and read up to numBytes. If the argument HEX is given, the binary data will be converted to hexadecimal representation and this will be stored in the variable.<br><p>STRINGS will parse a list of ASCII strings from a file and store it in a variable. Binary data in the file are ignored. Carriage return (CR) characters are ignored. It works also for Intel Hex and Motorola S-record files, which are automatically converted to binary format when reading them. Disable this using NO_HEX_CONVERSION.<br><p>LIMIT_COUNT sets the maximum number of strings to return. LIMIT_INPUT sets the maximum number of bytes to read from the input file. LIMIT_OUTPUT sets the maximum number of bytes to store in the output variable. LENGTH_MINIMUM sets the minimum length of a string to return. Shorter strings are ignored. LENGTH_MAXIMUM sets the maximum length of a string to return.  Longer strings are split into strings no longer than the maximum length. NEWLINE_CONSUME allows newlines to be included in strings instead of terminating them.<br><p>REGEX specifies a regular expression that a string must match to be returned. Typical usage <br><pre>  file(STRINGS myfile.txt myfile)<br></pre>
    <p>stores a list in the variable "myfile" in which each item is a line from the input file.<br><p>GLOB will generate a list of all files that match the globbing expressions and store it into the variable. Globbing expressions are similar to regular expressions, but much simpler. If RELATIVE flag is specified for an expression, the results will be returned as a relative path to the given path.<br><p>Examples of globbing expressions include:<br><pre>   *.cxx      - match all files with extension cxx<br>   *.vt?      - match all files with extension vta,...,vtz<br>   f[3-5].txt - match files f3.txt, f4.txt, f5.txt<br></pre>
    <p>GLOB_RECURSE will generate similar list as the regular GLOB, except it will traverse all the subdirectories of the matched directory and match the files.<br><p>Examples of recursive globbing include:<br><pre>   /dir/*.py  - match all python files in /dir and subdirectories<br></pre>
    <p>MAKE_DIRECTORY will create the given directories, also if their parent directories don't exist yet<br><p>REMOVE will remove the given files, also in subdirectories<br><p>REMOVE_RECURSE will remove the given files and directories, also non-empty directories<br><p>RELATIVE_PATH will determine relative path from directory to the given file.<br><p>TO_CMAKE_PATH will convert path into a cmake style path with unix /.  The input can be a single path or a system path like "$ENV{PATH}".  Note the double quotes around the ENV call TO_CMAKE_PATH only takes  one argument.<br><p>TO_NATIVE_PATH works just like TO_CMAKE_PATH, but will convert from  a cmake style path into the native path style \ for windows and / for UNIX.<br><p>DOWNLOAD will download the givin URL to the given file. If LOG var is specified a log of the download will be put in var. If STATUS var is specified the status of the operation will be put in var. The status is returned in a list of length 2. The first element is the numeric return value for the operation, and the second element is a string value for the error. A 0 numeric error means no error in the operation. If TIMEOUT time is specified, the operation will timeout after time seconds, time can be specified as a float.<br>
  </li>
  <li>
    <a name="command:find_file"><b><code>find_file</code></b></a>: Find the full path to a file.<br>
    <pre>   find_path(&lt;VAR&gt; name1 [path1 path2 ...])<br></pre>
    <p>This is the short-hand signature for the command that is sufficient in many cases.  It is the same as find_path(&lt;VAR&gt; name1 [PATHS path1 path2 ...])<br><pre>   find_path(<br>             &lt;VAR&gt;<br>             name | NAMES name1 [name2 ...]<br>             [PATHS path1 [path2 ... ENV var]]<br>             [PATH_SUFFIXES suffix1 [suffix2 ...]]<br>             [DOC "cache documentation string"]<br>             [NO_DEFAULT_PATH]<br>             [NO_CMAKE_ENVIRONMENT_PATH]<br>             [NO_CMAKE_PATH]<br>             [NO_SYSTEM_ENVIRONMENT_PATH]<br>             [NO_CMAKE_SYSTEM_PATH]<br>             [CMAKE_FIND_ROOT_PATH_BOTH |<br>              ONLY_CMAKE_FIND_ROOT_PATH |<br>              NO_CMAKE_FIND_ROOT_PATH]<br>            )<br></pre>
    <p>This command is used to find a full path to named file. A cache entry named by &lt;VAR&gt; is created to store the result of this command.  If the full path to a file is found the result is stored in the variable and the search will not be repeated unless the variable is cleared.  If nothing is found, the result will be &lt;VAR&gt;-NOTFOUND, and the search will be attempted again the next time find_path is invoked with the same variable.  The name of the full path to a file that is searched for is specified by the names listed after the NAMES argument.   Additional search locations can be specified after the PATHS argument.  If ENV var is found in the PATHS section the environment variable var will be read and converted from a system environment variable to a cmake style list of paths.  For example ENV PATH would be a way to list the system path variable. The argument after DOC will be used for the documentation string in the cache.  PATH_SUFFIXES can be used to give sub directories that will be appended to the search paths.<br><p>If NO_DEFAULT_PATH is specified, then no additional paths are added to the search. If NO_DEFAULT_PATH is not specified, the search process is as follows:<br><p>1. Search cmake specific environment variables.  This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.<br><pre>   &lt;prefix&gt;/include for each &lt;prefix&gt; in CMAKE_PREFIX_PATH<br>   CMAKE_INCLUDE_PATH<br>   CMAKE_FRAMEWORK_PATH<br></pre>
    <p>2. Search cmake variables with the same names as the cmake specific environment variables.  These are intended to be used on the command line with a -DVAR=value.  This can be skipped if NO_CMAKE_PATH is passed.<br><pre>   &lt;prefix&gt;/include for each &lt;prefix&gt; in CMAKE_PREFIX_PATH<br>   CMAKE_INCLUDE_PATH<br>   CMAKE_FRAMEWORK_PATH<br></pre>
    <p>3. Search the standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH is an argument.<br><pre>   PATH<br>   INCLUDE<br></pre>
    <p>4. Search cmake variables defined in the Platform files for the current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.<br><pre>   &lt;prefix&gt;/include for each &lt;prefix&gt; in CMAKE_SYSTEM_PREFIX_PATH<br>   CMAKE_SYSTEM_INCLUDE_PATH<br>   CMAKE_SYSTEM_FRAMEWORK_PATH<br></pre>
    <p>5. Search the paths specified after PATHS or in the short-hand version of the command.<br><p>On Darwin or systems supporting OS X Frameworks, the cmake variable    CMAKE_FIND_FRAMEWORK can be set to empty or one of the following:<br><pre>   "FIRST"  - Try to find frameworks before standard<br>              libraries or headers. This is the default on Darwin.<br>   "LAST"   - Try to find frameworks after standard<br>              libraries or headers.<br>   "ONLY"   - Only try to find frameworks.<br>   "NEVER". - Never try to find frameworks.<br></pre>
    <p>On Darwin or systems supporting OS X Application Bundles, the cmake variable CMAKE_FIND_APPBUNDLE can be set to empty or one of the following:<br><pre>   "FIRST"  - Try to find application bundles before standard<br>              programs. This is the default on Darwin.<br>   "LAST"   - Try to find application bundles after standard<br>              programs.<br>   "ONLY"   - Only try to find application bundles.<br>   "NEVER". - Never try to find application bundles.<br></pre>
    <p>The CMake variable CMAKE_FIND_ROOT_PATH specifies one or more directories to be prepended to all other search directories. This effectively "re-roots" the entire search under given locations. By default it is empty. It is especially useful when cross-compiling to point to the root directory of the target environment and CMake will search there too. By default at first the directories listed in CMAKE_FIND_ROOT_PATH and then the non-rooted directories will be searched. The default behavior can be adjusted by setting CMAKE_FIND_ROOT_PATH_MODE_INCLUDE.  This behavior can be manually overridden on a per-call basis. By using CMAKE_FIND_ROOT_PATH_BOTH the search order will be as described above. If NO_CMAKE_FIND_ROOT_PATH is used then CMAKE_FIND_ROOT_PATH will not be used. If ONLY_CMAKE_FIND_ROOT_PATH is used then only the re-rooted directories will be searched.<br><p>The reason the paths listed in the call to the command are searched last is that most users of CMake would expect things to be found first in the locations specified by their environment.  Projects may override this behavior by simply calling the command twice:<br><pre>   find_path(&lt;VAR&gt; NAMES name PATHS paths... NO_DEFAULT_PATH)<br>   find_path(&lt;VAR&gt; NAMES name)<br></pre>
    <p>Once one of these calls succeeds the result variable will be set and stored in the cache so that neither call will search again.
  </li>
  <li>
    <a name="command:find_library"><b><code>find_library</code></b></a>: Find a library.<br>
    <pre>   find_library(&lt;VAR&gt; name1 [path1 path2 ...])<br></pre>
    <p>This is the short-hand signature for the command that is sufficient in many cases.  It is the same as find_library(&lt;VAR&gt; name1 [PATHS path1 path2 ...])<br><pre>   find_library(<br>             &lt;VAR&gt;<br>             name | NAMES name1 [name2 ...]<br>             [PATHS path1 [path2 ... ENV var]]<br>             [PATH_SUFFIXES suffix1 [suffix2 ...]]<br>             [DOC "cache documentation string"]<br>             [NO_DEFAULT_PATH]<br>             [NO_CMAKE_ENVIRONMENT_PATH]<br>             [NO_CMAKE_PATH]<br>             [NO_SYSTEM_ENVIRONMENT_PATH]<br>             [NO_CMAKE_SYSTEM_PATH]<br>             [CMAKE_FIND_ROOT_PATH_BOTH |<br>              ONLY_CMAKE_FIND_ROOT_PATH |<br>              NO_CMAKE_FIND_ROOT_PATH]<br>            )<br></pre>
    <p>This command is used to find a library. A cache entry named by &lt;VAR&gt; is created to store the result of this command.  If the library is found the result is stored in the variable and the search will not be repeated unless the variable is cleared.  If nothing is found, the result will be &lt;VAR&gt;-NOTFOUND, and the search will be attempted again the next time find_library is invoked with the same variable.  The name of the library that is searched for is specified by the names listed after the NAMES argument.   Additional search locations can be specified after the PATHS argument.  If ENV var is found in the PATHS section the environment variable var will be read and converted from a system environment variable to a cmake style list of paths.  For example ENV PATH would be a way to list the system path variable. The argument after DOC will be used for the documentation string in the cache.  PATH_SUFFIXES can be used to give sub directories that will be appended to the search paths.<br><p>If NO_DEFAULT_PATH is specified, then no additional paths are added to the search. If NO_DEFAULT_PATH is not specified, the search process is as follows:<br><p>1. Search cmake specific environment variables.  This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.<br><pre>   &lt;prefix&gt;/lib for each &lt;prefix&gt; in CMAKE_PREFIX_PATH<br>   CMAKE_LIBRARY_PATH<br>   CMAKE_FRAMEWORK_PATH<br></pre>
    <p>2. Search cmake variables with the same names as the cmake specific environment variables.  These are intended to be used on the command line with a -DVAR=value.  This can be skipped if NO_CMAKE_PATH is passed.<br><pre>   &lt;prefix&gt;/lib for each &lt;prefix&gt; in CMAKE_PREFIX_PATH<br>   CMAKE_LIBRARY_PATH<br>   CMAKE_FRAMEWORK_PATH<br></pre>
    <p>3. Search the standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH is an argument.<br><pre>   PATH<br>   LIB<br></pre>
    <p>4. Search cmake variables defined in the Platform files for the current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.<br><pre>   &lt;prefix&gt;/lib for each &lt;prefix&gt; in CMAKE_SYSTEM_PREFIX_PATH<br>   CMAKE_SYSTEM_LIBRARY_PATH<br>   CMAKE_SYSTEM_FRAMEWORK_PATH<br></pre>
    <p>5. Search the paths specified after PATHS or in the short-hand version of the command.<br><p>On Darwin or systems supporting OS X Frameworks, the cmake variable    CMAKE_FIND_FRAMEWORK can be set to empty or one of the following:<br><pre>   "FIRST"  - Try to find frameworks before standard<br>              libraries or headers. This is the default on Darwin.<br>   "LAST"   - Try to find frameworks after standard<br>              libraries or headers.<br>   "ONLY"   - Only try to find frameworks.<br>   "NEVER". - Never try to find frameworks.<br></pre>
    <p>On Darwin or systems supporting OS X Application Bundles, the cmake variable CMAKE_FIND_APPBUNDLE can be set to empty or one of the following:<br><pre>   "FIRST"  - Try to find application bundles before standard<br>              programs. This is the default on Darwin.<br>   "LAST"   - Try to find application bundles after standard<br>              programs.<br>   "ONLY"   - Only try to find application bundles.<br>   "NEVER". - Never try to find application bundles.<br></pre>
    <p>The CMake variable CMAKE_FIND_ROOT_PATH specifies one or more directories to be prepended to all other search directories. This effectively "re-roots" the entire search under given locations. By default it is empty. It is especially useful when cross-compiling to point to the root directory of the target environment and CMake will search there too. By default at first the directories listed in CMAKE_FIND_ROOT_PATH and then the non-rooted directories will be searched. The default behavior can be adjusted by setting CMAKE_FIND_ROOT_PATH_MODE_LIBRARY.  This behavior can be manually overridden on a per-call basis. By using CMAKE_FIND_ROOT_PATH_BOTH the search order will be as described above. If NO_CMAKE_FIND_ROOT_PATH is used then CMAKE_FIND_ROOT_PATH will not be used. If ONLY_CMAKE_FIND_ROOT_PATH is used then only the re-rooted directories will be searched.<br><p>The reason the paths listed in the call to the command are searched last is that most users of CMake would expect things to be found first in the locations specified by their environment.  Projects may override this behavior by simply calling the command twice:<br><pre>   find_library(&lt;VAR&gt; NAMES name PATHS paths... NO_DEFAULT_PATH)<br>   find_library(&lt;VAR&gt; NAMES name)<br></pre>
    <p>Once one of these calls succeeds the result variable will be set and stored in the cache so that neither call will search again.<br><p>If the library found is a framework, then VAR will be set to the full path to the framework &lt;fullPath&gt;/A.framework. When a full path to a framework is used as a library, CMake will use a -framework A, and a -F&lt;fullPath&gt; to link the framework to the target. 
  </li>
  <li>
    <a name="command:find_package"><b><code>find_package</code></b></a>: Load settings for an external project.<br>
    <pre>  find_package(&lt;package&gt; [major[.minor[.patch]]] [EXACT] [QUIET]<br>               [[REQUIRED|COMPONENTS] [components...]])<br></pre>
    <p>Finds and loads settings from an external project.  &lt;package&gt;_FOUND will be set to indicate whether the package was found.  When the package is found package-specific information is provided through variables documented by the package itself.  The QUIET option disables messages if the package cannot be found.  The REQUIRED option stops processing with an error message if the package cannot be found.  A package-specific list of components may be listed after the REQUIRED option or after the COMPONENTS option if no REQUIRED option is given.  The "[major[.minor[.patch]]]" version argument specifies a desired version with which the package found should be compatible.  The EXACT option requests that the version be matched exactly.  Version support is currently provided only on a package-by-package basis (details below).<br><p>User code should generally look for packages using the above simple signature.  The remainder of this command documentation specifies the full command signature and details of the search process.  Project maintainers wishing to provide a package to be found by this command are encouraged to read on.<br><p>The command has two modes by which it searches for packages: "Module" mode and "Config" mode.  Module mode is available when the command is invoked with the above reduced signature.  CMake searches for a file called "Find&lt;package&gt;.cmake" in the CMAKE_MODULE_PATH followed by the CMake installation.  If the file is found, it is read and processed by CMake.  It is responsible for finding the package, checking the version, and producing any needed messages.  Many find-modules provide limited or no support for versioning; check the module documentation.  If no module is found the command proceeds to Config mode.<br><p>The complete Config mode command signature is:<br><pre>  find_package(&lt;package&gt; [major[.minor[.patch]]] [EXACT] [QUIET]<br>               [[REQUIRED|COMPONENTS] [components...]] [NO_MODULE]<br>               [NAMES name1 [name2 ...]]<br>               [CONFIGS config1 [config2 ...]]<br>               [PATHS path1 [path2 ... ]]<br>               [PATH_SUFFIXES suffix1 [suffix2 ...]]<br>               [NO_DEFAULT_PATH]<br>               [NO_CMAKE_ENVIRONMENT_PATH]<br>               [NO_CMAKE_PATH]<br>               [NO_SYSTEM_ENVIRONMENT_PATH]<br>               [NO_CMAKE_BUILDS_PATH]<br>               [NO_CMAKE_SYSTEM_PATH]<br>               [CMAKE_FIND_ROOT_PATH_BOTH |<br>                ONLY_CMAKE_FIND_ROOT_PATH |<br>                NO_CMAKE_FIND_ROOT_PATH])<br></pre>
    <p>The NO_MODULE option may be used to skip Module mode explicitly.  It is also implied by use of options not specified in the reduced signature.  <br><p>Config mode attempts to locate a configuration file provided by the package to be found.  A cache entry called &lt;package&gt;_DIR is created to hold the directory containing the file.  By default the command searches for a package with the name &lt;package&gt;.  If the NAMES option is given the names following it are used instead of &lt;package&gt;.  The command searches for a file called "&lt;name&gt;Config.cmake" or "&lt;lower-case-name&gt;-config.cmake" for each name specified.  A replacement set of possible configuration file names may be given using the CONFIGS option.  The search procedure is specified below.  Once found, the configuration file is read and processed by CMake.  Since the file is provided by the package it already knows the location of package contents.  The full path to the configuration file is stored in the cmake variable &lt;package&gt;_CONFIG.<br><p>If the package configuration file cannot be found CMake will generate an error describing the problem unless the QUIET argument is specified.  If REQUIRED is specified and the package is not found a fatal error is generated and the configure step stops executing.  If &lt;package&gt;_DIR has been set to a directory not containing a configuration file a fatal error is always generated because user intervention is required.<br><p>When the "[major[.minor[.patch]]]" version argument is specified Config mode will only find a version of the package that claims compatibility with the requested version.  If the EXACT option is given only a version of the package claiming an exact match of the requested version may be found.  CMake does not establish any convention for the meaning of version numbers.  Package version numbers are checked by "version" files provided by the packages themselves.  For a candidate package confguration file "&lt;config-file&gt;.cmake" the corresponding version file is located next to it and named either "&lt;config-file&gt;-version.cmake" or "&lt;config-file&gt;Version.cmake".  If no such version file is available then the configuration file is assumed to not be compatible with any requested version.  When a version file is found it is loaded to check the requested version number.  The version file is loaded in a nested scope in which the following variables have been defined:<br><pre>  PACKAGE_FIND_NAME          = the &lt;package&gt; name<br>  PACKAGE_FIND_VERSION       = full requested version string<br>  PACKAGE_FIND_VERSION_MAJOR = requested major version, if any<br>  PACKAGE_FIND_VERSION_MINOR = requested minor version, if any<br>  PACKAGE_FIND_VERSION_PATCH = requested patch version, if any<br></pre>
    <p>The version file checks whether it satisfies the requested version and sets these variables:<br><pre>  PACKAGE_VERSION            = package version (major[.minor[.patch]])<br>  PACKAGE_VERSION_EXACT      = true if version is exact match<br>  PACKAGE_VERSION_COMPATIBLE = true if version is compatible<br></pre>
    <p>These variables are checked by the find_package command to determine whether the configuration file provides an acceptable version.  They are not available after the find_package call returns.  If the version is acceptable the following variables are set:<br><pre>  &lt;package&gt;_VERSION       = package version (major[.minor[.patch]])<br>  &lt;package&gt;_VERSION_MAJOR = major from major[.minor[.patch]], if any<br>  &lt;package&gt;_VERSION_MINOR = minor from major[.minor[.patch]], if any<br>  &lt;package&gt;_VERSION_PATCH = patch from major[.minor[.patch]], if any<br></pre>
    <p>and the corresponding package configuration file is loaded.  When multiple package configuration files are available whose version files claim compatibility with the version requested it is unspecified which one is chosen.  No attempt is made to choose a highest or closest version number.<br><p>Config mode provides an elaborate interface and search procedure.  Much of the interface is provided for completeness and for use internally by find-modules loaded by Module mode.  Most user code should simply call<br><pre>  find_package(&lt;package&gt; [major[.minor]] [EXACT] [REQUIRED|QUIET])<br></pre>
    <p>in order to find a package.  Package maintainers providing CMake package configuration files are encouraged to name and install them such that the procedure outlined below will find them without requiring use of additional options.<br><p>CMake constructs a set of possible installation prefixes for the package.  Under each prefix several directories are searched for a configuration file.  The tables below show the directories searched.  Each entry is meant for installation trees following Windows (W), UNIX (U), or Apple (A) conventions.<br><pre>  &lt;prefix&gt;/                                               (W)<br>  &lt;prefix&gt;/(cmake|CMake)/                                 (W)<br>  &lt;prefix&gt;/(share|lib)/&lt;name&gt;*/                           (U)<br>  &lt;prefix&gt;/(share|lib)/&lt;name&gt;*/(cmake|CMake)/             (U)<br></pre>
    <p>On systems supporting OS X Frameworks and Application Bundles the following directories are searched for frameworks or bundles containing a configuration file:<br><pre>  &lt;prefix&gt;/&lt;name&gt;.framework/Resources/                    (A)<br>  &lt;prefix&gt;/&lt;name&gt;.framework/Resources/CMake/              (A)<br>  &lt;prefix&gt;/&lt;name&gt;.framework/Versions/*/Resources/         (A)<br>  &lt;prefix&gt;/&lt;name&gt;.framework/Versions/*/Resources/CMake/   (A)<br>  &lt;prefix&gt;/&lt;name&gt;.app/Contents/Resources/                 (A)<br>  &lt;prefix&gt;/&lt;name&gt;.app/Contents/Resources/CMake/           (A)<br></pre>
    <p>In all cases the &lt;name&gt; is treated as case-insensitive and corresponds to any of the names specified (&lt;package&gt; or names given by NAMES).  If PATH_SUFFIXES is specified the suffixes are appended to each (W) or (U) directory entry one-by-one.<br><p>This set of directories is intended to work in cooperation with projects that provide configuration files in their installation trees.  Directories above marked with (W) are intended for installations on Windows where the prefix may point at the top of an application's installation directory.  Those marked with (U) are intended for installations on UNIX platforms where the prefix is shared by multiple packages.  This is merely a convention, so all (W) and (U) directories are still searched on all platforms.  Directories marked with (A) are intended for installations on Apple platforms.  The cmake variables CMAKE_FIND_FRAMEWORK and CMAKE_FIND_APPBUNDLE determine the order of preference as specified below.<br><p>The set of installation prefixes is constructed using the following steps.  If NO_DEFAULT_PATH is specified steps 1-5 are skipped.<br><p>1. Search cmake specific environment variables.  This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.<br><pre>   CMAKE_PREFIX_PATH<br>   CMAKE_FRAMEWORK_PATH<br>   CMAKE_APPBUNDLE_PATH<br></pre>
    <p>2. Search cmake variables with the same names as the cmake specific environment variables.  These are intended to be used on the command line with a -DVAR=value.  This can be skipped if NO_CMAKE_PATH is passed.<br><pre>   CMAKE_PREFIX_PATH<br>   CMAKE_FRAMEWORK_PATH<br>   CMAKE_APPBUNDLE_PATH<br></pre>
    <p>3. Search the standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH is passed.  Path entries ending in "/bin" or "/sbin" are automatically converted to their parent directories.<br><pre>   PATH<br></pre>
    <p>4. Search project build trees recently configured in a CMake GUI.  This can be skipped if NO_CMAKE_BUILDS_PATH is passed.  It is intended for the case when a user is building multiple dependent projects one after another.<br><p>5. Search cmake variables defined in the Platform files for the current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.<br><pre>   CMAKE_SYSTEM_PREFIX_PATH<br>   CMAKE_SYSTEM_FRAMEWORK_PATH<br>   CMAKE_SYSTEM_APPBUNDLE_PATH<br></pre>
    <p>6. Search paths specified by the PATHS option.<br><p>On Darwin or systems supporting OS X Frameworks, the cmake variable    CMAKE_FIND_FRAMEWORK can be set to empty or one of the following:<br><pre>   "FIRST"  - Try to find frameworks before standard<br>              libraries or headers. This is the default on Darwin.<br>   "LAST"   - Try to find frameworks after standard<br>              libraries or headers.<br>   "ONLY"   - Only try to find frameworks.<br>   "NEVER". - Never try to find frameworks.<br></pre>
    <p>On Darwin or systems supporting OS X Application Bundles, the cmake variable CMAKE_FIND_APPBUNDLE can be set to empty or one of the following:<br><pre>   "FIRST"  - Try to find application bundles before standard<br>              programs. This is the default on Darwin.<br>   "LAST"   - Try to find application bundles after standard<br>              programs.<br>   "ONLY"   - Only try to find application bundles.<br>   "NEVER". - Never try to find application bundles.<br></pre>
    <p>The CMake variable CMAKE_FIND_ROOT_PATH specifies one or more directories to be prepended to all other search directories. This effectively "re-roots" the entire search under given locations. By default it is empty. It is especially useful when cross-compiling to point to the root directory of the target environment and CMake will search there too. By default at first the directories listed in CMAKE_FIND_ROOT_PATH and then the non-rooted directories will be searched. The default behavior can be adjusted by setting CMAKE_FIND_ROOT_PATH_MODE_PACKAGE.  This behavior can be manually overridden on a per-call basis. By using CMAKE_FIND_ROOT_PATH_BOTH the search order will be as described above. If NO_CMAKE_FIND_ROOT_PATH is used then CMAKE_FIND_ROOT_PATH will not be used. If ONLY_CMAKE_FIND_ROOT_PATH is used then only the re-rooted directories will be searched.<br><p>The reason the paths listed in the call to the command are searched last is that most users of CMake would expect things to be found first in the locations specified by their environment.  Projects may override this behavior by simply calling the command twice:<br><pre>   find_package(&lt;package&gt; PATHS paths... NO_DEFAULT_PATH)<br>   find_package(&lt;package&gt;)<br></pre>
    <p>Once one of these calls succeeds the result variable will be set and stored in the cache so that neither call will search again.
  </li>
  <li>
    <a name="command:find_path"><b><code>find_path</code></b></a>: Find the directory containing a file.<br>
    <pre>   find_path(&lt;VAR&gt; name1 [path1 path2 ...])<br></pre>
    <p>This is the short-hand signature for the command that is sufficient in many cases.  It is the same as find_path(&lt;VAR&gt; name1 [PATHS path1 path2 ...])<br><pre>   find_path(<br>             &lt;VAR&gt;<br>             name | NAMES name1 [name2 ...]<br>             [PATHS path1 [path2 ... ENV var]]<br>             [PATH_SUFFIXES suffix1 [suffix2 ...]]<br>             [DOC "cache documentation string"]<br>             [NO_DEFAULT_PATH]<br>             [NO_CMAKE_ENVIRONMENT_PATH]<br>             [NO_CMAKE_PATH]<br>             [NO_SYSTEM_ENVIRONMENT_PATH]<br>             [NO_CMAKE_SYSTEM_PATH]<br>             [CMAKE_FIND_ROOT_PATH_BOTH |<br>              ONLY_CMAKE_FIND_ROOT_PATH |<br>              NO_CMAKE_FIND_ROOT_PATH]<br>            )<br></pre>
    <p>This command is used to find a directory containing the named file. A cache entry named by &lt;VAR&gt; is created to store the result of this command.  If the file in a directory is found the result is stored in the variable and the search will not be repeated unless the variable is cleared.  If nothing is found, the result will be &lt;VAR&gt;-NOTFOUND, and the search will be attempted again the next time find_path is invoked with the same variable.  The name of the file in a directory that is searched for is specified by the names listed after the NAMES argument.   Additional search locations can be specified after the PATHS argument.  If ENV var is found in the PATHS section the environment variable var will be read and converted from a system environment variable to a cmake style list of paths.  For example ENV PATH would be a way to list the system path variable. The argument after DOC will be used for the documentation string in the cache.  PATH_SUFFIXES can be used to give sub directories that will be appended to the search paths.<br><p>If NO_DEFAULT_PATH is specified, then no additional paths are added to the search. If NO_DEFAULT_PATH is not specified, the search process is as follows:<br><p>1. Search cmake specific environment variables.  This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.<br><pre>   &lt;prefix&gt;/include for each &lt;prefix&gt; in CMAKE_PREFIX_PATH<br>   CMAKE_INCLUDE_PATH<br>   CMAKE_FRAMEWORK_PATH<br></pre>
    <p>2. Search cmake variables with the same names as the cmake specific environment variables.  These are intended to be used on the command line with a -DVAR=value.  This can be skipped if NO_CMAKE_PATH is passed.<br><pre>   &lt;prefix&gt;/include for each &lt;prefix&gt; in CMAKE_PREFIX_PATH<br>   CMAKE_INCLUDE_PATH<br>   CMAKE_FRAMEWORK_PATH<br></pre>
    <p>3. Search the standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH is an argument.<br><pre>   PATH<br>   INCLUDE<br></pre>
    <p>4. Search cmake variables defined in the Platform files for the current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.<br><pre>   &lt;prefix&gt;/include for each &lt;prefix&gt; in CMAKE_SYSTEM_PREFIX_PATH<br>   CMAKE_SYSTEM_INCLUDE_PATH<br>   CMAKE_SYSTEM_FRAMEWORK_PATH<br></pre>
    <p>5. Search the paths specified after PATHS or in the short-hand version of the command.<br><p>On Darwin or systems supporting OS X Frameworks, the cmake variable    CMAKE_FIND_FRAMEWORK can be set to empty or one of the following:<br><pre>   "FIRST"  - Try to find frameworks before standard<br>              libraries or headers. This is the default on Darwin.<br>   "LAST"   - Try to find frameworks after standard<br>              libraries or headers.<br>   "ONLY"   - Only try to find frameworks.<br>   "NEVER". - Never try to find frameworks.<br></pre>
    <p>On Darwin or systems supporting OS X Application Bundles, the cmake variable CMAKE_FIND_APPBUNDLE can be set to empty or one of the following:<br><pre>   "FIRST"  - Try to find application bundles before standard<br>              programs. This is the default on Darwin.<br>   "LAST"   - Try to find application bundles after standard<br>              programs.<br>   "ONLY"   - Only try to find application bundles.<br>   "NEVER". - Never try to find application bundles.<br></pre>
    <p>The CMake variable CMAKE_FIND_ROOT_PATH specifies one or more directories to be prepended to all other search directories. This effectively "re-roots" the entire search under given locations. By default it is empty. It is especially useful when cross-compiling to point to the root directory of the target environment and CMake will search there too. By default at first the directories listed in CMAKE_FIND_ROOT_PATH and then the non-rooted directories will be searched. The default behavior can be adjusted by setting CMAKE_FIND_ROOT_PATH_MODE_INCLUDE.  This behavior can be manually overridden on a per-call basis. By using CMAKE_FIND_ROOT_PATH_BOTH the search order will be as described above. If NO_CMAKE_FIND_ROOT_PATH is used then CMAKE_FIND_ROOT_PATH will not be used. If ONLY_CMAKE_FIND_ROOT_PATH is used then only the re-rooted directories will be searched.<br><p>The reason the paths listed in the call to the command are searched last is that most users of CMake would expect things to be found first in the locations specified by their environment.  Projects may override this behavior by simply calling the command twice:<br><pre>   find_path(&lt;VAR&gt; NAMES name PATHS paths... NO_DEFAULT_PATH)<br>   find_path(&lt;VAR&gt; NAMES name)<br></pre>
    <p>Once one of these calls succeeds the result variable will be set and stored in the cache so that neither call will search again.<br><p>When searching for frameworks, if the file is specified as A/b.h, then the framework search will look for A.framework/Headers/b.h. If that is found the path will be set to the path to the framework. CMake will convert this to the correct -F option to include the file. 
  </li>
  <li>
    <a name="command:find_program"><b><code>find_program</code></b></a>: Find an executable program.<br>
    <pre>   find_program(&lt;VAR&gt; name1 [path1 path2 ...])<br></pre>
    <p>This is the short-hand signature for the command that is sufficient in many cases.  It is the same as find_program(&lt;VAR&gt; name1 [PATHS path1 path2 ...])<br><pre>   find_program(<br>             &lt;VAR&gt;<br>             name | NAMES name1 [name2 ...]<br>             [PATHS path1 [path2 ... ENV var]]<br>             [PATH_SUFFIXES suffix1 [suffix2 ...]]<br>             [DOC "cache documentation string"]<br>             [NO_DEFAULT_PATH]<br>             [NO_CMAKE_ENVIRONMENT_PATH]<br>             [NO_CMAKE_PATH]<br>             [NO_SYSTEM_ENVIRONMENT_PATH]<br>             [NO_CMAKE_SYSTEM_PATH]<br>             [CMAKE_FIND_ROOT_PATH_BOTH |<br>              ONLY_CMAKE_FIND_ROOT_PATH |<br>              NO_CMAKE_FIND_ROOT_PATH]<br>            )<br></pre>
    <p>This command is used to find a program. A cache entry named by &lt;VAR&gt; is created to store the result of this command.  If the program is found the result is stored in the variable and the search will not be repeated unless the variable is cleared.  If nothing is found, the result will be &lt;VAR&gt;-NOTFOUND, and the search will be attempted again the next time find_program is invoked with the same variable.  The name of the program that is searched for is specified by the names listed after the NAMES argument.   Additional search locations can be specified after the PATHS argument.  If ENV var is found in the PATHS section the environment variable var will be read and converted from a system environment variable to a cmake style list of paths.  For example ENV PATH would be a way to list the system path variable. The argument after DOC will be used for the documentation string in the cache.  PATH_SUFFIXES can be used to give sub directories that will be appended to the search paths.<br><p>If NO_DEFAULT_PATH is specified, then no additional paths are added to the search. If NO_DEFAULT_PATH is not specified, the search process is as follows:<br><p>1. Search cmake specific environment variables.  This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.<br><pre>   &lt;prefix&gt;/[s]bin for each &lt;prefix&gt; in CMAKE_PREFIX_PATH<br>   CMAKE_PROGRAM_PATH<br>   CMAKE_APPBUNDLE_PATH<br></pre>
    <p>2. Search cmake variables with the same names as the cmake specific environment variables.  These are intended to be used on the command line with a -DVAR=value.  This can be skipped if NO_CMAKE_PATH is passed.<br><pre>   &lt;prefix&gt;/[s]bin for each &lt;prefix&gt; in CMAKE_PREFIX_PATH<br>   CMAKE_PROGRAM_PATH<br>   CMAKE_APPBUNDLE_PATH<br></pre>
    <p>3. Search the standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH is an argument.<br><pre>   PATH<br>   <br></pre>
    <p>4. Search cmake variables defined in the Platform files for the current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.<br><pre>   &lt;prefix&gt;/[s]bin for each &lt;prefix&gt; in CMAKE_SYSTEM_PREFIX_PATH<br>   CMAKE_SYSTEM_PROGRAM_PATH<br>   CMAKE_SYSTEM_APPBUNDLE_PATH<br></pre>
    <p>5. Search the paths specified after PATHS or in the short-hand version of the command.<br><p>On Darwin or systems supporting OS X Frameworks, the cmake variable    CMAKE_FIND_FRAMEWORK can be set to empty or one of the following:<br><pre>   "FIRST"  - Try to find frameworks before standard<br>              libraries or headers. This is the default on Darwin.<br>   "LAST"   - Try to find frameworks after standard<br>              libraries or headers.<br>   "ONLY"   - Only try to find frameworks.<br>   "NEVER". - Never try to find frameworks.<br></pre>
    <p>On Darwin or systems supporting OS X Application Bundles, the cmake variable CMAKE_FIND_APPBUNDLE can be set to empty or one of the following:<br><pre>   "FIRST"  - Try to find application bundles before standard<br>              programs. This is the default on Darwin.<br>   "LAST"   - Try to find application bundles after standard<br>              programs.<br>   "ONLY"   - Only try to find application bundles.<br>   "NEVER". - Never try to find application bundles.<br></pre>
    <p>The CMake variable CMAKE_FIND_ROOT_PATH specifies one or more directories to be prepended to all other search directories. This effectively "re-roots" the entire search under given locations. By default it is empty. It is especially useful when cross-compiling to point to the root directory of the target environment and CMake will search there too. By default at first the directories listed in CMAKE_FIND_ROOT_PATH and then the non-rooted directories will be searched. The default behavior can be adjusted by setting CMAKE_FIND_ROOT_PATH_MODE_PROGRAM.  This behavior can be manually overridden on a per-call basis. By using CMAKE_FIND_ROOT_PATH_BOTH the search order will be as described above. If NO_CMAKE_FIND_ROOT_PATH is used then CMAKE_FIND_ROOT_PATH will not be used. If ONLY_CMAKE_FIND_ROOT_PATH is used then only the re-rooted directories will be searched.<br><p>The reason the paths listed in the call to the command are searched last is that most users of CMake would expect things to be found first in the locations specified by their environment.  Projects may override this behavior by simply calling the command twice:<br><pre>   find_program(&lt;VAR&gt; NAMES name PATHS paths... NO_DEFAULT_PATH)<br>   find_program(&lt;VAR&gt; NAMES name)<br></pre>
    <p>Once one of these calls succeeds the result variable will be set and stored in the cache so that neither call will search again.
  </li>
  <li>
    <a name="command:foreach"><b><code>foreach</code></b></a>: Evaluate a group of commands for each value in a list.<br>
    <pre>  foreach(loop_var arg1 arg2 ...)<br>    COMMAND1(ARGS ...)<br>    COMMAND2(ARGS ...)<br>    ...<br>  endforeach(loop_var)<br>  foreach(loop_var RANGE total)<br>  foreach(loop_var RANGE start stop [step])<br></pre>
    <p>All commands between foreach and the matching endforeach are recorded without being invoked.  Once the endforeach is evaluated, the recorded list of commands is invoked once for each argument listed in the original foreach command.  Before each iteration of the loop "${loop_var}" will be set as a variable with the current value in the list.<br><p>Foreach can also iterate over a generated range of numbers. There are three types of this iteration:<br><p>* When specifying single number, the range will have elements 0 to "total".<br><p>* When specifying two numbers, the range will have elements from the first number to the second number.<br><p>* The third optional number is the increment used to iterate from the first number to the second number.
  </li>
  <li>
    <a name="command:function"><b><code>function</code></b></a>: Start recording a function for later invocation as a command.<br>
    <pre>  function(&lt;name&gt; [arg1 [arg2 [arg3 ...]]])<br>    COMMAND1(ARGS ...)<br>    COMMAND2(ARGS ...)<br>    ...<br>  endfunction(&lt;name&gt;)<br></pre>
    <p>Define a function named &lt;name&gt; that takes arguments named arg1 arg2 arg3 (...).  Commands listed after function, but before the matching endfunction, are not invoked until the function is invoked.  When it is invoked, the commands recorded in the function are first modified by replacing formal parameters (${arg1}) with the arguments passed, and then invoked as normal commands. In addition to referencing the formal parameters you can reference the variable ARGC which will be set to the number of arguments passed into the function as well as ARGV0 ARGV1 ARGV2 ... which will have the actual values of the arguments passed in. This facilitates creating functions with optional arguments. Additionally ARGV holds the list of all arguments given to the function and ARGN holds the list of argument pass the last expected argument.
  </li>
  <li>
    <a name="command:get_cmake_property"><b><code>get_cmake_property</code></b></a>: Get a property of the CMake instance.<br>
    <pre>  get_cmake_property(VAR property)<br></pre>
    <p>Get a property from the CMake instance.  The value of the property is stored in the variable VAR. If the property is not found, CMake will report an error. Some supported properties include: VARIABLES, CACHE_VARIABLES, COMMANDS, and MACROS.
  </li>
  <li>
    <a name="command:get_directory_property"><b><code>get_directory_property</code></b></a>: Get a property of the directory.<br>
    <pre>  get_directory_property(VAR [DIRECTORY dir] property)<br></pre>
    <p>Get a property from the Directory.  The value of the property is stored in the variable VAR. If the property is not found, CMake will report an error. The properties include: VARIABLES, CACHE_VARIABLES, COMMANDS, MACROS, INCLUDE_DIRECTORIES, LINK_DIRECTORIES, DEFINITIONS, INCLUDE_REGULAR_EXPRESSION, LISTFILE_STACK, PARENT_DIRECTORY, and DEFINITION varname.  If the DIRECTORY argument is provided then the property of the provided directory will be retrieved instead of the current directory. You can only get properties of a directory during or after it has been traversed by cmake.
  </li>
  <li>
    <a name="command:get_filename_component"><b><code>get_filename_component</code></b></a>: Get a specific component of a full filename.<br>
    <pre>  get_filename_component(VarName FileName<br>                         PATH|ABSOLUTE|NAME|EXT|NAME_WE<br>                         [CACHE])<br></pre>
    <p>Set VarName to be the path (PATH), file name (NAME), file extension (EXT), file name without extension (NAME_WE) of FileName, or the full absolute (ABSOLUTE) file name without symlinks.  Note that the path is converted to Unix slashes format and has no trailing slashes. The longest file extension is always considered. If the optional CACHE argument is specified, the result variable is added to the cache.<br><pre>  get_filename_component(VarName FileName<br>                         PROGRAM [PROGRAM_ARGS ArgVar]<br>                         [CACHE])<br></pre>
    <p>The program in FileName will be found in the system search path or left as a full path.  If PROGRAM_ARGS is present with PROGRAM, then any command-line arguments present in the FileName string are split from the program name and stored in ArgVar.  This is used to separate a program name from its arguments in a command line string.
  </li>
  <li>
    <a name="command:get_property"><b><code>get_property</code></b></a>: Get a property.<br>
    <pre>  get_property(&lt;variable&gt;<br>               &lt;GLOBAL             |<br>                DIRECTORY [dir]    |<br>                TARGET    &lt;target&gt; |<br>                SOURCE    &lt;source&gt; |<br>                TEST      &lt;test&gt;   |<br>                VARIABLE&gt;<br>               PROPERTY &lt;name&gt;<br>               [SET | DEFINED | BRIEF_DOCS | FULL_DOCS])<br></pre>
    <p>Get one property from one object in a scope.  The first argument specifies the variable in which to store the result.  The second argument determines the scope from which to get the property.  It must be one of the following:<br><p>GLOBAL scope is unique and does not accept a name.<br><p>DIRECTORY scope defaults to the current directory but another directory (already processed by CMake) may be named by full or relative path.<br><p>TARGET scope must name one existing target.<br><p>SOURCE scope must name one source file.<br><p>TEST scope must name one existing test.<br><p>VARIABLE scope is unique and does not accept a name.<br><p>The required PROPERTY option is immediately followed by the name of the property to get.  If the property is not set an empty value is returned.  If the SET option is given the variable is set to a boolean value indicating whether the property has been set.If the DEFINED option is given the variable is set to a boolean value indicating whether the property has been defined such as with define_property. If BRIEF_DOCS or FULL_DOCS is given then the variable is set to a string containing documentation for the requested property.  If documentation is requested for a property that has not been defined NOTFOUND is returned.
  </li>
  <li>
    <a name="command:if"><b><code>if</code></b></a>: Conditionally execute a group of commands.<br>
    <pre>  if(expression)<br>    # then section.<br>    COMMAND1(ARGS ...)<br>    COMMAND2(ARGS ...)<br>    ...<br>  elseif(expression2)<br>    # elseif section.<br>    COMMAND1(ARGS ...)<br>    COMMAND2(ARGS ...)<br>    ...<br>  else(expression)<br>    # else section.<br>    COMMAND1(ARGS ...)<br>    COMMAND2(ARGS ...)<br>    ...<br>  endif(expression)<br></pre>
    <p>Evaluates the given expression.  If the result is true, the commands in the THEN section are invoked.  Otherwise, the commands in the else section are invoked.  The elseif and else sections are optional. You may have multiple elseif clauses. Note that the same expression must be given to if, and endif.  Long expressions can be used and the order or precedence is that the EXISTS, COMMAND, and DEFINED operators will be evaluated first. Then any EQUAL, LESS, GREATER, STRLESS, STRGREATER, STREQUAL, MATCHES will be evaluated. Then NOT operators and finally AND, OR operators will be evaluated. Possible expressions are:<br><pre>  if(variable)<br></pre>
    <p>True if the variable's value is not empty, 0, N, NO, OFF, FALSE, NOTFOUND, or &lt;variable&gt;-NOTFOUND.<br><pre>  if(NOT variable)<br></pre>
    <p>True if the variable's value is empty, 0, N, NO, OFF, FALSE, NOTFOUND, or &lt;variable&gt;-NOTFOUND.<br><pre>  if(variable1 AND variable2)<br></pre>
    <p>True if both variables would be considered true individually.<br><pre>  if(variable1 OR variable2)<br></pre>
    <p>True if either variable would be considered true individually.<br><pre>  if(COMMAND command-name)<br></pre>
    <p>True if the given name is a command, macro or function that can be invoked.<br><pre>  if(POLICY policy-id)<br></pre>
    <p>True if the given name is an existing policy (of the form CMP&lt;NNNN&gt;).<br><pre>  if(EXISTS file-name)<br>  if(EXISTS directory-name)<br></pre>
    <p>True if the named file or directory exists.  Behavior is well-defined only for full paths.<br><pre>  if(file1 IS_NEWER_THAN file2)<br></pre>
    <p>True if file1 is newer than file2 or if one of the two files doesn't exist. Behavior is well-defined only for full paths.<br><pre>  if(IS_DIRECTORY directory-name)<br></pre>
    <p>True if the given name is a directory.  Behavior is well-defined only for full paths.<br><pre>  if(IS_ABSOLUTE path)<br></pre>
    <p>True if the given path is an absolute path.<br><pre>   if(variable MATCHES regex)<br>  if(string MATCHES regex)<br></pre>
    <p>True if the given string or variable's value matches the given regular expression.<br><pre>  if(variable LESS number)<br>  if(string LESS number)<br>  if(variable GREATER number)<br>  if(string GREATER number)<br>  if(variable EQUAL number)<br>  if(string EQUAL number)<br></pre>
    <p>True if the given string or variable's value is a valid number and the inequality or equality is true.<br><pre>  if(variable STRLESS string)<br>  if(string STRLESS string)<br>  if(variable STRGREATER string)<br>  if(string STRGREATER string)<br>  if(variable STREQUAL string)<br>  if(string STREQUAL string)<br></pre>
    <p>True if the given string or variable's value is lexicographically less (or greater, or equal) than the string on the right.<br><pre>  if(DEFINED variable)<br></pre>
    <p>True if the given variable is defined. It does not matter if the variable is true or false just if it has been set.
  </li>
  <li>
    <a name="command:include"><b><code>include</code></b></a>: Read CMake listfile code from the given file.<br>
    <pre>  include(file1 [OPTIONAL] [RESULT_VARIABLE &lt;VAR&gt;])<br>  include(module [OPTIONAL] [RESULT_VARIABLE &lt;VAR&gt;])<br></pre>
    <p>Reads CMake listfile code from the given file.  Commands in the file are processed immediately as if they were written in place of the include command.  If OPTIONAL is present, then no error is raised if the file does not exist.  If RESULT_VARIABLE is given the variable will be set to the full filename which has been included or NOTFOUND if it failed.<br><p>If a module is specified instead of a file, the file with name &lt;modulename&gt;.cmake is searched in the CMAKE_MODULE_PATH.
  </li>
  <li>
    <a name="command:list"><b><code>list</code></b></a>: List operations.<br>
    <pre>  list(LENGTH &lt;list&gt; &lt;output variable&gt;)<br>  list(GET &lt;list&gt; &lt;element index&gt; [&lt;element index&gt; ...] &lt;output variable&gt;)<br>  list(APPEND &lt;list&gt; &lt;element&gt; [&lt;element&gt; ...])<br>  list(FIND &lt;list&gt; &lt;value&gt; &lt;output variable&gt;)<br>  list(INSERT &lt;list&gt; &lt;element_index&gt; &lt;element&gt; [&lt;element&gt; ...])<br>  list(REMOVE_ITEM &lt;list&gt; &lt;value&gt; [&lt;value&gt; ...])<br>  list(REMOVE_AT &lt;list&gt; &lt;index&gt; [&lt;index&gt; ...])<br>  list(REMOVE_DUPLICATES &lt;list&gt;)<br>  list(REVERSE &lt;list&gt;)<br>  list(SORT &lt;list&gt;)<br></pre>
    <p>LENGTH will return a given list's length.<br><p>GET will return list of elements specified by indices from the list.<br><p>APPEND will append elements to the list.<br><p>FIND will return the index of the element specified in the list or -1 if it wasn't found.<br><p>INSERT will insert elements to the list to the specified location.<br><p>REMOVE_AT and REMOVE_ITEM will remove items from the list. The difference is that REMOVE_ITEM will remove the given items, while REMOVE_AT will remove the items at the given indices.<br><p>REMOVE_DUPLICATES will remove duplicated items in the list.<br><p>REVERSE reverses the contents of the list in-place.<br><p>SORT sorts the list in-place alphabetically.<br><p>NOTES: A list in cmake is a ; separated group of strings. To create a list the set command can be used. For example, set(var a b c d e)  creates a list with a;b;c;d;e, and set(var "a b c d e") creates a string or a list with one item in it.<br><p>When specifying index values, if &lt;element index&gt; is 0 or greater, it is indexed from the beginning of the list, with 0 representing the first list element. If &lt;element index&gt; is -1 or lesser, it is indexed from the end of the list, with -1 representing the last list element. Be careful when counting with negative indices: they do not start from 0. -0 is equivalent to 0, the first list element.<br>
  </li>
  <li>
    <a name="command:macro"><b><code>macro</code></b></a>: Start recording a macro for later invocation as a command.<br>
    <pre>  macro(&lt;name&gt; [arg1 [arg2 [arg3 ...]]])<br>    COMMAND1(ARGS ...)<br>    COMMAND2(ARGS ...)<br>    ...<br>  endmacro(&lt;name&gt;)<br></pre>
    <p>Define a macro named &lt;name&gt; that takes arguments named arg1 arg2 arg3 (...).  Commands listed after macro, but before the matching endmacro, are not invoked until the macro is invoked.  When it is invoked, the commands recorded in the macro are first modified by replacing formal parameters (${arg1}) with the arguments passed, and then invoked as normal commands. In addition to referencing the formal parameters you can reference the values ${ARGC} which will be set to the number of arguments passed into the function as well as ${ARGV0} ${ARGV1} ${ARGV2} ... which will have the actual values of the arguments passed in. This facilitates creating macros with optional arguments. Additionally ${ARGV} holds the list of all arguments given to the macro and ${ARGN} holds the list of argument pass the last expected argument. Note that the parameters to a macro and values such as ARGN are not variables in the usual CMake sense. They are string replacements much like the c preprocessor would do with a macro. If you want true CMake variables you should look at the function command.
  </li>
  <li>
    <a name="command:make_directory"><b><code>make_directory</code></b></a>: Deprecated. Use the file(MAKE_DIRECTORY ) command instead.<br>
    <pre>  make_directory(directory)<br></pre>
    <p>Creates the specified directory.  Full paths should be given.  Any parent directories that do not exist will also be created.  Use with care.
  </li>
  <li>
    <a name="command:mark_as_advanced"><b><code>mark_as_advanced</code></b></a>: Mark cmake cached variables as advanced.<br>
    <pre>  mark_as_advanced([CLEAR|FORCE] VAR VAR2 VAR...)<br></pre>
    <p>Mark the named cached variables as advanced.  An advanced variable will not be displayed in any of the cmake GUIs unless the show advanced option is on.  If CLEAR is the first argument advanced variables are changed back to unadvanced.  If FORCE is the first argument, then the variable is made advanced.  If neither FORCE nor CLEAR is specified, new values will be marked as advanced, but if the variable already has an advanced/non-advanced state, it will not be changed.<br><p>It does nothing in script mode.
  </li>
  <li>
    <a name="command:math"><b><code>math</code></b></a>: Mathematical expressions.<br>
    <pre>  math(EXPR &lt;output variable&gt; &lt;math expression&gt;)<br></pre>
    <p>EXPR evaluates mathematical expression and return result in the output variable. Example mathematical expression is '5 * ( 10 + 13 )'.  Supported operators are + - * / % | &amp; ^ ~ &lt;&lt; &gt;&gt; * / %.  They have the same meaning  as they do in c code.
  </li>
  <li>
    <a name="command:message"><b><code>message</code></b></a>: Display a message to the user.<br>
    <pre>  message([SEND_ERROR | STATUS | FATAL_ERROR]<br>          "message to display" ...)<br></pre>
    <p>By default the message is displayed in a pop up window (CMakeSetup), or in the stdout of cmake, or the error section of ccmake. If the first argument is SEND_ERROR then an error is raised, and the generate phase will be skipped.  If the first argument is FATAL_ERROR, all processing is halted. If the first argument is STATUS then the message is displayed in the progress line for the GUI, or with a -- in the command line cmake.
  </li>
  <li>
    <a name="command:option"><b><code>option</code></b></a>: Provides an option that the user can optionally select.<br>
    <pre>  option(&lt;option_variable&gt; "help string describing option"<br>         [initial value])<br></pre>
    <p>Provide an option for the user to select as ON or OFF.  If no initial value is provided, OFF is used.
  </li>
  <li>
    <a name="command:remove"><b><code>remove</code></b></a>: Deprecated. Use the list(REMOVE_ITEM ) command instead.<br>
    <pre>  remove(VAR VALUE VALUE ...)<br></pre>
    <p>Removes VALUE from the variable VAR.  This is typically used to remove entries from a vector (e.g. semicolon separated list).  VALUE is expanded.
  </li>
  <li>
    <a name="command:return"><b><code>return</code></b></a>: Return from a directory or function.<br>
    <pre>  return()<br></pre>
    <p>Returns from a directory or function. When this command is encountered, it caused process of the current function or directory to stop and control is return to the caller of the function, or the parent directory if any. Note that a macro is not a function and does not handle return like a function does.
  </li>
  <li>
    <a name="command:separate_arguments"><b><code>separate_arguments</code></b></a>: Split space separated arguments into a semi-colon separated list.<br>
    <pre>  separate_arguments(VARIABLE)<br></pre>
    <p>Convert the value of VARIABLE to a semi-colon separated list.  All spaces are replaced with ';'.  This helps with generating command lines.
  </li>
  <li>
    <a name="command:set"><b><code>set</code></b></a>: Set a CMAKE variable to a given value.<br>
    <pre>  set(&lt;variable&gt; &lt;value&gt; [[CACHE &lt;type&gt; &lt;docstring&gt; [FORCE]] | PARENT_SCOPE])<br></pre>
    <p>Within CMake sets &lt;variable&gt; to the value &lt;value&gt;.  &lt;value&gt; is expanded  before &lt;variable&gt; is set to it.  If CACHE is present, then the &lt;variable&gt; is put in the cache. &lt;type&gt; and &lt;docstring&gt; are then required. &lt;type&gt; is used by the CMake GUI to choose a widget with which the user sets a value.  The value for &lt;type&gt; may be one of<br><pre>  FILEPATH = File chooser dialog.<br>  PATH     = Directory chooser dialog.<br>  STRING   = Arbitrary string.<br>  BOOL     = Boolean ON/OFF checkbox.<br>  INTERNAL = No GUI entry (used for persistent variables).<br></pre>
    <p>If &lt;type&gt; is INTERNAL, then the &lt;value&gt; is always written into the cache, replacing any values existing in the cache.  If it is not a cache variable, then this always writes into the current makefile. The FORCE option will overwrite the cache value removing any changes by the user.<br><p>If PARENT_SCOPE is present, the variable will be set in the scope above the current scope. Each new directory or function creates a new scope. This command will set the value of a variable into the parent directory or calling function (whichever is applicable to the case at hand) If VALUE is not specified then the variable is removed from the parent scope.<br><pre>  set(&lt;variable&gt; &lt;value1&gt; ... &lt;valueN&gt;)<br></pre>
    <p>In this case &lt;variable&gt; is set to a semicolon separated list of values.<br><p>&lt;variable&gt; can be an environment variable such as:<br><pre>  set( ENV{PATH} /home/martink )<br></pre>
    <p>in which case the environment variable will be set.
  </li>
  <li>
    <a name="command:set_directory_properties"><b><code>set_directory_properties</code></b></a>: Set a property of the directory.<br>
    <pre>  set_directory_properties(PROPERTIES prop1 value1 prop2 value2)<br></pre>
    <p>Set a property for the current directory and subdirectories. If the property is not found, CMake will report an error. The properties include: INCLUDE_DIRECTORIES, LINK_DIRECTORIES, INCLUDE_REGULAR_EXPRESSION, and ADDITIONAL_MAKE_CLEAN_FILES.<br><p>ADDITIONAL_MAKE_CLEAN_FILES is a list of files that will be cleaned as a part of "make clean" stage.
  </li>
  <li>
    <a name="command:set_property"><b><code>set_property</code></b></a>: Set a named property in a given scope.<br>
    <pre>  set_property(&lt;GLOBAL                            |<br>                DIRECTORY [dir]                   |<br>                TARGET    [target1 [target2 ...]] |<br>                SOURCE    [src1 [src2 ...]]       |<br>                TEST      [test1 [test2 ...]]&gt;<br>               [APPEND]<br>               PROPERTY &lt;name&gt; [value1 [value2 ...]])<br></pre>
    <p>Set one property on zero or more objects of a scope.  The first argument determines the scope in which the property is set.  It must be one of the following:<br><p>GLOBAL scope is unique and does not accept a name.<br><p>DIRECTORY scope defaults to the current directory but another directory (already processed by CMake) may be named by full or relative path.<br><p>TARGET scope may name zero or more existing targets.<br><p>SOURCE scope may name zero or more source files.<br><p>TEST scope may name zero or more existing tests.<br><p>The required PROPERTY option is immediately followed by the name of the property to set.  Remaining arguments are used to compose the property value in the form of a semicolon-separated list.  If the APPEND option is given the list is appended to any existing property value.
  </li>
  <li>
    <a name="command:site_name"><b><code>site_name</code></b></a>: Set the given variable to the name of the computer.<br>
    <pre>  site_name(variable)<br></pre>
    
  </li>
  <li>
    <a name="command:string"><b><code>string</code></b></a>: String operations.<br>
    <pre>  string(REGEX MATCH &lt;regular_expression&gt;<br>         &lt;output variable&gt; &lt;input&gt; [&lt;input&gt;...])<br>  string(REGEX MATCHALL &lt;regular_expression&gt;<br>         &lt;output variable&gt; &lt;input&gt; [&lt;input&gt;...])<br>  string(REGEX REPLACE &lt;regular_expression&gt;<br>         &lt;replace_expression&gt; &lt;output variable&gt;<br>         &lt;input&gt; [&lt;input&gt;...])<br>  string(REPLACE &lt;match_string&gt;<br>         &lt;replace_string&gt; &lt;output variable&gt;<br>         &lt;input&gt; [&lt;input&gt;...])<br>  string(COMPARE EQUAL &lt;string1&gt; &lt;string2&gt; &lt;output variable&gt;)<br>  string(COMPARE NOTEQUAL &lt;string1&gt; &lt;string2&gt; &lt;output variable&gt;)<br>  string(COMPARE LESS &lt;string1&gt; &lt;string2&gt; &lt;output variable&gt;)<br>  string(COMPARE GREATER &lt;string1&gt; &lt;string2&gt; &lt;output variable&gt;)<br>  string(ASCII &lt;number&gt; [&lt;number&gt; ...] &lt;output variable&gt;)<br>  string(CONFIGURE &lt;string1&gt; &lt;output variable&gt;<br>         [@ONLY] [ESCAPE_QUOTES])<br>  string(TOUPPER &lt;string1&gt; &lt;output variable&gt;)<br>  string(TOLOWER &lt;string1&gt; &lt;output variable&gt;)<br>  string(LENGTH &lt;string&gt; &lt;output variable&gt;)<br>  string(SUBSTRING &lt;string&gt; &lt;begin&gt; &lt;length&gt; &lt;output variable&gt;)<br>  string(STRIP &lt;string&gt; &lt;output variable&gt;)<br>  string(RANDOM [LENGTH &lt;length&gt;] [ALPHABET &lt;alphabet&gt;]<br>         &lt;output variable&gt;)<br></pre>
    <p>REGEX MATCH will match the regular expression once and store the match in the output variable.<br><p>REGEX MATCHALL will match the regular expression as many times as possible and store the matches in the output variable as a list.<br><p>REGEX REPLACE will match the regular expression as many times as possible and substitute the replacement expression for the match in the output.  The replace expression may refer to paren-delimited subexpressions of the match using \1, \2, ..., \9.  Note that two backslashes (\\1) are required in CMake code to get a backslash through argument parsing.<br><p>REPLACE will replace all occurrences of match_string in the input with replace_string and store the result in the output.<br><p>COMPARE EQUAL/NOTEQUAL/LESS/GREATER will compare the strings and store true or false in the output variable.<br><p>ASCII will convert all numbers into corresponding ASCII characters.<br><p>CONFIGURE will transform a string like CONFIGURE_FILE transforms a file.<br><p>TOUPPER/TOLOWER will convert string to upper/lower characters.<br><p>LENGTH will return a given string's length.<br><p>SUBSTRING will return a substring of a given string.<br><p>STRIP will return a substring of a given string with leading and trailing spaces removed.<br><p>RANDOM will return a random string of given length consisting of characters from the given alphabet. Default length is 5 characters and default alphabet is all numbers and upper and lower case letters.<br><p>The following characters have special meaning in regular expressions:<br><pre>   ^         Matches at beginning of a line<br>   $         Matches at end of a line<br>   .         Matches any single character<br>   [ ]       Matches any character(s) inside the brackets<br>   [^ ]      Matches any character(s) not inside the brackets<br>    -        Matches any character in range on either side of a dash<br>   *         Matches preceding pattern zero or more times<br>   +         Matches preceding pattern one or more times<br>   ?         Matches preceding pattern zero or once only<br>   |         Matches a pattern on either side of the |<br>   ()        Saves a matched subexpression, which can be referenced in the REGEX REPLACE operation. Additionally it is saved in the special CMake variables CMAKE_MATCH_(0..9).</pre>
    
  </li>
  <li>
    <a name="command:variable_watch"><b><code>variable_watch</code></b></a>: Watch the CMake variable for change.<br>
    <pre>  variable_watch(&lt;variable name&gt; [&lt;command to execute&gt;])<br></pre>
    <p>If the specified variable changes, the message will be printed about the variable being changed. If the command is specified, the command will be executed. The command will receive the following arguments: COMMAND(&lt;variable&gt; &lt;access&gt; &lt;value&gt; &lt;current list file&gt; &lt;stack&gt;)
  </li>
  <li>
    <a name="command:while"><b><code>while</code></b></a>: Evaluate a group of commands while a condition is true<br>
    <pre>  while(condition)<br>    COMMAND1(ARGS ...)<br>    COMMAND2(ARGS ...)<br>    ...<br>  endwhile(condition)<br></pre>
    <p>All commands between while and the matching endwhile are recorded without being invoked.  Once the endwhile is evaluated, the recorded list of commands is invoked as long as the condition is true. The condition is evaluated using the same logic as the if command.
  </li>
  <li>
    <a name="command:write_file"><b><code>write_file</code></b></a>: Deprecated. Use the file(WRITE ) command instead.<br>
    <pre>  write_file(filename "message to write"... [APPEND])<br></pre>
    <p>The first argument is the file name, the rest of the arguments are messages to write. If the argument APPEND is specified, then the message will be appended.<br><p>NOTE 1: file(WRITE ... and file(APPEND ... do exactly the same as this one but add some more functionality.<br><p>NOTE 2: When using write_file the produced file cannot be used as an input to CMake (CONFIGURE_FILE, source file ...) because it will lead to an infinite loop. Use configure_file if you want to generate input files to CMake.
  </li>
</ul>
<h2><a name="section_Properties"/>Properties</h2>
<ul>
</ul>
<pre>  CMake Properties - Properties supported by CMake, the Cross-Platform Makefile Generator.</pre>
    
<p>This is the documentation for the properties supported by CMake. Properties can have different scopes. They can either be assigned to a source file, a directory, a target or globally to CMake. By modifying the values of properties the behaviour of the build system can be customized.
<h2><a name="section_Compatibility Commands"/>Compatibility Commands</h2>
<ul>
</ul>
<pre>  CMake Compatibility Listfile Commands - Obsolete commands supported by CMake for compatibility.</pre>
    
<p>This is the documentation for now obsolete listfile commands from previous CMake versions, which are still supported for compatibility reasons. You should instead use the newer, faster and shinier new commands. ;-)
<h2><a name="section_Standard CMake Modules"/>Standard CMake Modules</h2>
<ul>
</ul>
<h2><a name="section_Copyright"/>Copyright</h2>
<ul>
</ul>
<p>Copyright (c) 2002 Kitware, Inc., Insight Consortium.  All rights reserved.
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
<p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
<p>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
<p>The names of Kitware, Inc., the Insight Consortium, or the names of any consortium members, or of any contributors, may not be used to endorse or promote products derived from this software without specific prior written permission.
<p>Modified source versions must be plainly marked as such, and must not be misrepresented as being the original software.
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<h2><a name="section_See Also"/>See Also</h2>
<ul>
    <li><a href="#see:HomePage"><b><code>Home Page</code></b></a></li>    <li><a href="#see:FrequentlyAskedQuestions"><b><code>Frequently Asked Questions</code></b></a></li>    <li><a href="#see:OnlineDocumentation"><b><code>Online Documentation</code></b></a></li>    <li><a href="#see:MailingList"><b><code>Mailing List</code></b></a></li></ul>
<p>The following resources are available to get help using CMake:
<ul>
  <li>
    <a name="see:HomePage"><b><code>Home Page</code></b></a>: <a href="http://www.cmake.org">http://www.cmake.org</a><br>
    <p>The primary starting point for learning about CMake.
  </li>
  <li>
    <a name="see:FrequentlyAskedQuestions"><b><code>Frequently Asked Questions</code></b></a>: <a href="http://www.cmake.org/Wiki/CMake_FAQ">http://www.cmake.org/Wiki/CMake_FAQ</a><br>
    <p>A Wiki is provided containing answers to frequently asked questions. 
  </li>
  <li>
    <a name="see:OnlineDocumentation"><b><code>Online Documentation</code></b></a>: <a href="http://www.cmake.org/HTML/Documentation.html">http://www.cmake.org/HTML/Documentation.html</a><br>
    <p>Links to available documentation may be found on this web page.
  </li>
  <li>
    <a name="see:MailingList"><b><code>Mailing List</code></b></a>: <a href="http://www.cmake.org/HTML/MailingLists.html">http://www.cmake.org/HTML/MailingLists.html</a><br>
    <p>For help and discussion about using cmake, a mailing list is provided at cmake@cmake.org. The list is member-post-only but one may sign up on the CMake web page. Please first read the full documentation at <a href="http://www.cmake.org">http://www.cmake.org</a> before posting questions to the list.
  </li>
</ul>
<p>Summary of helpful links:<br><pre>  Home: <a href="http://www.cmake.org">http://www.cmake.org</a><br>  Docs: <a href="http://www.cmake.org/HTML/Documentation.html">http://www.cmake.org/HTML/Documentation.html</a><br>  Mail: <a href="http://www.cmake.org/HTML/MailingLists.html">http://www.cmake.org/HTML/MailingLists.html</a><br>  FAQ:  <a href="http://www.cmake.org/Wiki/CMake_FAQ">http://www.cmake.org/Wiki/CMake_FAQ</a><br></pre>
    
</body></html>
