This is ../../info/gnus, produced by makeinfo version 4.11 from
gnus.texi.

Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover texts
     being "A GNU Manual", and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     "GNU Free Documentation License".

     (a) The FSF's Back-Cover Text is: "You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom."

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Gnus: (gnus).         The newsreader Gnus.
END-INFO-DIR-ENTRY


File: gnus,  Node: Directory Groups,  Next: Anything Groups,  Up: Other Sources

6.6.1 Directory Groups
----------------------

If you have a directory that has lots of articles in separate files in
it, you might treat it as a newsgroup.  The files have to have numerical
names, of course.

   This might be an opportune moment to mention `ange-ftp' (and its
successor `efs'), that most wonderful of all wonderful Emacs packages.
When I wrote `nndir', I didn't think much about it--a back end to read
directories.  Big deal.

   `ange-ftp' changes that picture dramatically.  For instance, if you
enter the `ange-ftp' file name `/ftp.hpc.uh.edu:/pub/emacs/ding-list/'
as the directory name, `ange-ftp' or `efs' will actually allow you to
read this directory over at `sina' as a newsgroup.  Distributed news
ahoy!

   `nndir' will use NOV files if they are present.

   `nndir' is a "read-only" back end--you can't delete or expire
articles with this method.  You can use `nnmh' or `nnml' for whatever
you use `nndir' for, so you could switch to any of those methods if you
feel the need to have a non-read-only `nndir'.


File: gnus,  Node: Anything Groups,  Next: Document Groups,  Prev: Directory Groups,  Up: Other Sources

6.6.2 Anything Groups
---------------------

From the `nndir' back end (which reads a single spool-like directory),
it's just a hop and a skip to `nneething', which pretends that any
arbitrary directory is a newsgroup.  Strange, but true.

   When `nneething' is presented with a directory, it will scan this
directory and assign article numbers to each file.  When you enter such
a group, `nneething' must create "headers" that Gnus can use.  After
all, Gnus is a newsreader, in case you're forgetting.  `nneething' does
this in a two-step process.  First, it snoops each file in question.
If the file looks like an article (i.e., the first few lines look like
headers), it will use this as the head.  If this is just some arbitrary
file without a head (e.g. a C source file), `nneething' will cobble up
a header out of thin air.  It will use file ownership, name and date
and do whatever it can with these elements.

   All this should happen automatically for you, and you will be
presented with something that looks very much like a newsgroup.
Totally like a newsgroup, to be precise.  If you select an article, it
will be displayed in the article buffer, just as usual.

   If you select a line that represents a directory, Gnus will pop you
into a new summary buffer for this `nneething' group.  And so on.  You
can traverse the entire disk this way, if you feel like, but remember
that Gnus is not dired, really, and does not intend to be, either.

   There are two overall modes to this action--ephemeral or solid.  When
doing the ephemeral thing (i.e., `G D' from the group buffer), Gnus
will not store information on what files you have read, and what files
are new, and so on.  If you create a solid `nneething' group the normal
way with `G m', Gnus will store a mapping table between article numbers
and file names, and you can treat this group like any other groups.
When you activate a solid `nneething' group, you will be told how many
unread articles it contains, etc., etc.

   Some variables:

`nneething-map-file-directory'
     All the mapping files for solid `nneething' groups will be stored
     in this directory, which defaults to `~/.nneething/'.

`nneething-exclude-files'
     All files that match this regexp will be ignored.  Nice to use to
     exclude auto-save files and the like, which is what it does by
     default.

`nneething-include-files'
     Regexp saying what files to include in the group.  If this
     variable is non-`nil', only files matching this regexp will be
     included.

`nneething-map-file'
     Name of the map files.


File: gnus,  Node: Document Groups,  Next: SOUP,  Prev: Anything Groups,  Up: Other Sources

6.6.3 Document Groups
---------------------

`nndoc' is a cute little thing that will let you read a single file as
a newsgroup.  Several files types are supported:

`babyl'
     The Babyl format.

`mbox'
     The standard Unix mbox file.

`mmdf'
     The MMDF mail box format.

`news'
     Several news articles appended into a file.

`rnews'
     The rnews batch transport format.

`nsmail'
     Netscape mail boxes.

`mime-parts'
     MIME multipart messages.

`standard-digest'
     The standard (RFC 1153) digest format.

`mime-digest'
     A MIME digest of messages.

`lanl-gov-announce'
     Announcement messages from LANL Gov Announce.

`rfc822-forward'
     A message forwarded according to RFC822.

`outlook'
     The Outlook mail box.

`oe-dbx'
     The Outlook Express dbx mail box.

`exim-bounce'
     A bounce message from the Exim MTA.

`forward'
     A message forwarded according to informal rules.

`rfc934'
     An RFC934-forwarded message.

`mailman'
     A mailman digest.

`clari-briefs'
     A digest of Clarinet brief news items.

`slack-digest'
     Non-standard digest format--matches most things, but does it badly.

`mail-in-mail'
     The last resort.

   You can also use the special "file type" `guess', which means that
`nndoc' will try to guess what file type it is looking at.  `digest'
means that `nndoc' should guess what digest type the file is.

   `nndoc' will not try to change the file or insert any extra headers
into it--it will simply, like, let you use the file as the basis for a
group.  And that's it.

   If you have some old archived articles that you want to insert into
your new & spiffy Gnus mail back end, `nndoc' can probably help you with
that.  Say you have an old `RMAIL' file with mail that you now want to
split into your new `nnml' groups.  You look at that file using `nndoc'
(using the `G f' command in the group buffer (*note Foreign Groups::)),
set the process mark on all the articles in the buffer (`M P b', for
instance), and then re-spool (`B r') using `nnml'.  If all goes well,
all the mail in the `RMAIL' file is now also stored in lots of `nnml'
directories, and you can delete that pesky `RMAIL' file.  If you have
the guts!

   Virtual server variables:

`nndoc-article-type'
     This should be one of `mbox', `babyl', `digest', `news', `rnews',
     `mmdf', `forward', `rfc934', `rfc822-forward', `mime-parts',
     `standard-digest', `slack-digest', `clari-briefs', `nsmail',
     `outlook', `oe-dbx', `mailman', and `mail-in-mail' or `guess'.

`nndoc-post-type'
     This variable says whether Gnus is to consider the group a news
     group or a mail group.  There are two valid values:  `mail' (the
     default) and `news'.

* Menu:

* Document Server Internals::   How to add your own document types.


File: gnus,  Node: Document Server Internals,  Up: Document Groups

6.6.3.1 Document Server Internals
.................................

Adding new document types to be recognized by `nndoc' isn't difficult.
You just have to whip up a definition of what the document looks like,
write a predicate function to recognize that document type, and then
hook into `nndoc'.

   First, here's an example document type definition:

     (mmdf
      (article-begin .  "^\^A\^A\^A\^A\n")
      (body-end .  "^\^A\^A\^A\^A\n"))

   The definition is simply a unique "name" followed by a series of
regexp pseudo-variable settings.  Below are the possible
variables--don't be daunted by the number of variables; most document
types can be defined with very few settings:

`first-article'
     If present, `nndoc' will skip past all text until it finds
     something that match this regexp.  All text before this will be
     totally ignored.

`article-begin'
     This setting has to be present in all document type definitions.
     It says what the beginning of each article looks like.  To do more
     complicated things that cannot be dealt with a simple regexp, you
     can use `article-begin-function' instead of this.

`article-begin-function'
     If present, this should be a function that moves point to the
     beginning of each article.  This setting overrides `article-begin'.

`head-begin'
     If present, this should be a regexp that matches the head of the
     article.  To do more complicated things that cannot be dealt with a
     simple regexp, you can use `head-begin-function' instead of this.

`head-begin-function'
     If present, this should be a function that moves point to the head
     of the article.  This setting overrides `head-begin'.

`head-end'
     This should match the end of the head of the article.  It defaults
     to `^$'--the empty line.

`body-begin'
     This should match the beginning of the body of the article.  It
     defaults to `^\n'.  To do more complicated things that cannot be
     dealt with a simple regexp, you can use `body-begin-function'
     instead of this.

`body-begin-function'
     If present, this function should move point to the beginning of
     the body of the article.  This setting overrides `body-begin'.

`body-end'
     If present, this should match the end of the body of the article.
     To do more complicated things that cannot be dealt with a simple
     regexp, you can use `body-end-function' instead of this.

`body-end-function'
     If present, this function should move point to the end of the body
     of the article.  This setting overrides `body-end'.

`file-begin'
     If present, this should match the beginning of the file.  All text
     before this regexp will be totally ignored.

`file-end'
     If present, this should match the end of the file.  All text after
     this regexp will be totally ignored.


   So, using these variables `nndoc' is able to dissect a document file
into a series of articles, each with a head and a body.  However, a few
more variables are needed since not all document types are all that
news-like--variables needed to transform the head or the body into
something that's palatable for Gnus:

`prepare-body-function'
     If present, this function will be called when requesting an
     article.  It will be called with point at the start of the body,
     and is useful if the document has encoded some parts of its
     contents.

`article-transform-function'
     If present, this function is called when requesting an article.
     It's meant to be used for more wide-ranging transformation of both
     head and body of the article.

`generate-head-function'
     If present, this function is called to generate a head that Gnus
     can understand.  It is called with the article number as a
     parameter, and is expected to generate a nice head for the article
     in question.  It is called when requesting the headers of all
     articles.

`generate-article-function'
     If present, this function is called to generate an entire article
     that Gnus can understand.  It is called with the article number as
     a parameter when requesting all articles.

`dissection-function'
     If present, this function is called to dissect a document by
     itself, overriding `first-article', `article-begin',
     `article-begin-function', `head-begin', `head-begin-function',
     `head-end', `body-begin', `body-begin-function', `body-end',
     `body-end-function', `file-begin', and `file-end'.


   Let's look at the most complicated example I can come up
with--standard digests:

     (standard-digest
      (first-article . ,(concat "^" (make-string 70 ?-) "\n\n+"))
      (article-begin . ,(concat "\n\n" (make-string 30 ?-) "\n\n+"))
      (prepare-body-function . nndoc-unquote-dashes)
      (body-end-function . nndoc-digest-body-end)
      (head-end . "^ ?$")
      (body-begin . "^ ?\n")
      (file-end . "^End of .*digest.*[0-9].*\n\\*\\*\\|^End of.*Digest *$")
      (subtype digest guess))

   We see that all text before a 70-width line of dashes is ignored; all
text after a line that starts with that `^End of' is also ignored; each
article begins with a 30-width line of dashes; the line separating the
head from the body may contain a single space; and that the body is run
through `nndoc-unquote-dashes' before being delivered.

   To hook your own document definition into `nndoc', use the
`nndoc-add-type' function.  It takes two parameters--the first is the
definition itself and the second (optional) parameter says where in the
document type definition alist to put this definition.  The alist is
traversed sequentially, and `nndoc-TYPE-type-p' is called for a given
type TYPE.  So `nndoc-mmdf-type-p' is called to see whether a document
is of `mmdf' type, and so on.  These type predicates should return
`nil' if the document is not of the correct type; `t' if it is of the
correct type; and a number if the document might be of the correct
type.  A high number means high probability; a low number means low
probability with `0' being the lowest valid number.


File: gnus,  Node: SOUP,  Next: Mail-To-News Gateways,  Prev: Document Groups,  Up: Other Sources

6.6.4 SOUP
----------

In the PC world people often talk about "offline" newsreaders.  These
are thingies that are combined reader/news transport monstrosities.
With built-in modem programs.  Yecchh!

   Of course, us Unix Weenie types of human beans use things like
`uucp' and, like, `nntpd' and set up proper news and mail transport
things like Ghod intended.  And then we just use normal newsreaders.

   However, it can sometimes be convenient to do something that's a bit
easier on the brain if you have a very slow modem, and you're not really
that interested in doing things properly.

   A file format called SOUP has been developed for transporting news
and mail from servers to home machines and back again.  It can be a bit
fiddly.

   First some terminology:

"server"
     This is the machine that is connected to the outside world and
     where you get news and/or mail from.

"home machine"
     This is the machine that you want to do the actual reading and
     responding on.  It is typically not connected to the rest of the
     world in any way.

"packet"
     Something that contains messages and/or commands.  There are two
     kinds of packets:

    "message packets"
          These are packets made at the server, and typically contain
          lots of messages for you to read.  These are called
          `SoupoutX.tgz' by default, where X is a number.

    "response packets"
          These are packets made at the home machine, and typically
          contains replies that you've written.  These are called
          `SoupinX.tgz' by default, where X is a number.



  1. You log in on the server and create a SOUP packet.  You can either
     use a dedicated SOUP thingie (like the `awk' program), or you can
     use Gnus to create the packet with its SOUP commands (`O s' and/or
     `G s b'; and then `G s p') (*note SOUP Commands::).

  2. You transfer the packet home.  Rail, boat, car or modem will do
     fine.

  3. You put the packet in your home directory.

  4. You fire up Gnus on your home machine using the `nnsoup' back end
     as the native or secondary server.

  5. You read articles and mail and answer and followup to the things
     you want (*note SOUP Replies::).

  6. You do the `G s r' command to pack these replies into a SOUP
     packet.

  7. You transfer this packet to the server.

  8. You use Gnus to mail this packet out with the `G s s' command.

  9. You then repeat until you die.


   So you basically have a bipartite system--you use `nnsoup' for
reading and Gnus for packing/sending these SOUP packets.

* Menu:

* SOUP Commands::               Commands for creating and sending SOUP packets
* SOUP Groups::                 A back end for reading SOUP packets.
* SOUP Replies::                How to enable `nnsoup' to take over mail and news.


File: gnus,  Node: SOUP Commands,  Next: SOUP Groups,  Up: SOUP

6.6.4.1 SOUP Commands
.....................

These are commands for creating and manipulating SOUP packets.

`G s b'
     Pack all unread articles in the current group
     (`gnus-group-brew-soup').  This command understands the
     process/prefix convention.

`G s w'
     Save all SOUP data files (`gnus-soup-save-areas').

`G s s'
     Send all replies from the replies packet
     (`gnus-soup-send-replies').

`G s p'
     Pack all files into a SOUP packet (`gnus-soup-pack-packet').

`G s r'
     Pack all replies into a replies packet (`nnsoup-pack-replies').

`O s'
     This summary-mode command adds the current article to a SOUP packet
     (`gnus-soup-add-article').  It understands the process/prefix
     convention (*note Process/Prefix::).


   There are a few variables to customize where Gnus will put all these
thingies:

`gnus-soup-directory'
     Directory where Gnus will save intermediate files while composing
     SOUP packets.  The default is `~/SoupBrew/'.

`gnus-soup-replies-directory'
     This is what Gnus will use as a temporary directory while sending
     our reply packets.  `~/SoupBrew/SoupReplies/' is the default.

`gnus-soup-prefix-file'
     Name of the file where Gnus stores the last used prefix.  The
     default is `gnus-prefix'.

`gnus-soup-packer'
     A format string command for packing a SOUP packet.  The default is
     `tar cf - %s | gzip > $HOME/Soupout%d.tgz'.

`gnus-soup-unpacker'
     Format string command for unpacking a SOUP packet.  The default is
     `gunzip -c %s | tar xvf -'.

`gnus-soup-packet-directory'
     Where Gnus will look for reply packets.  The default is `~/'.

`gnus-soup-packet-regexp'
     Regular expression matching SOUP reply packets in
     `gnus-soup-packet-directory'.



File: gnus,  Node: SOUP Groups,  Next: SOUP Replies,  Prev: SOUP Commands,  Up: SOUP

6.6.4.2 SOUP Groups
...................

`nnsoup' is the back end for reading SOUP packets.  It will read
incoming packets, unpack them, and put them in a directory where you
can read them at leisure.

   These are the variables you can use to customize its behavior:

`nnsoup-tmp-directory'
     When `nnsoup' unpacks a SOUP packet, it does it in this directory.
     (`/tmp/' by default.)

`nnsoup-directory'
     `nnsoup' then moves each message and index file to this directory.
     The default is `~/SOUP/'.

`nnsoup-replies-directory'
     All replies will be stored in this directory before being packed
     into a reply packet.  The default is `~/SOUP/replies/'.

`nnsoup-replies-format-type'
     The SOUP format of the replies packets.  The default is `?n'
     (rnews), and I don't think you should touch that variable.  I
     probably shouldn't even have documented it.  Drats!  Too late!

`nnsoup-replies-index-type'
     The index type of the replies packet.  The default is `?n', which
     means "none".  Don't fiddle with this one either!

`nnsoup-active-file'
     Where `nnsoup' stores lots of information.  This is not an "active
     file" in the `nntp' sense; it's an Emacs Lisp file.  If you lose
     this file or mess it up in any way, you're dead.  The default is
     `~/SOUP/active'.

`nnsoup-packer'
     Format string command for packing a reply SOUP packet.  The default
     is `tar cf - %s | gzip > $HOME/Soupin%d.tgz'.

`nnsoup-unpacker'
     Format string command for unpacking incoming SOUP packets.  The
     default is `gunzip -c %s | tar xvf -'.

`nnsoup-packet-directory'
     Where `nnsoup' will look for incoming packets.  The default is
     `~/'.

`nnsoup-packet-regexp'
     Regular expression matching incoming SOUP packets.  The default is
     `Soupout'.

`nnsoup-always-save'
     If non-`nil', save the replies buffer after each posted message.



File: gnus,  Node: SOUP Replies,  Prev: SOUP Groups,  Up: SOUP

6.6.4.3 SOUP Replies
....................

Just using `nnsoup' won't mean that your postings and mailings end up
in SOUP reply packets automagically.  You have to work a bit more for
that to happen.

   The `nnsoup-set-variables' command will set the appropriate
variables to ensure that all your followups and replies end up in the
SOUP system.

   In specific, this is what it does:

     (setq message-send-news-function 'nnsoup-request-post)
     (setq message-send-mail-function 'nnsoup-request-mail)

   And that's it, really.  If you only want news to go into the SOUP
system you just use the first line.  If you only want mail to be SOUPed
you use the second.


File: gnus,  Node: Mail-To-News Gateways,  Prev: SOUP,  Up: Other Sources

6.6.5 Mail-To-News Gateways
---------------------------

If your local `nntp' server doesn't allow posting, for some reason or
other, you can post using one of the numerous mail-to-news gateways.
The `nngateway' back end provides the interface.

   Note that you can't read anything from this back end--it can only be
used to post with.

   Server variables:

`nngateway-address'
     This is the address of the mail-to-news gateway.

`nngateway-header-transformation'
     News headers often have to be transformed in some odd way or other
     for the mail-to-news gateway to accept it.  This variable says what
     transformation should be called, and defaults to
     `nngateway-simple-header-transformation'.  The function is called
     narrowed to the headers to be transformed and with one
     parameter--the gateway address.

     This default function just inserts a new `To' header based on the
     `Newsgroups' header and the gateway address.  For instance, an
     article with this `Newsgroups' header:

          Newsgroups: alt.religion.emacs

     will get this `To' header inserted:

          To: alt-religion-emacs@GATEWAY

     The following pre-defined functions exist:

    `nngateway-simple-header-transformation'
          Creates a `To' header that looks like
          NEWSGROUP@`nngateway-address'.

    `nngateway-mail2news-header-transformation'
          Creates a `To' header that looks like `nngateway-address'.


   Here's an example:

     (setq gnus-post-method
           '(nngateway
             "mail2news@replay.com"
             (nngateway-header-transformation
              nngateway-mail2news-header-transformation)))

   So, to use this, simply say something like:

     (setq gnus-post-method '(nngateway "GATEWAY.ADDRESS"))


File: gnus,  Node: Combined Groups,  Next: Email Based Diary,  Prev: Other Sources,  Up: Select Methods

6.7 Combined Groups
===================

Gnus allows combining a mixture of all the other group types into bigger
groups.

* Menu:

* Virtual Groups::              Combining articles from many groups.
* Kibozed Groups::              Looking through parts of the newsfeed for articles.


File: gnus,  Node: Virtual Groups,  Next: Kibozed Groups,  Up: Combined Groups

6.7.1 Virtual Groups
--------------------

An "nnvirtual group" is really nothing more than a collection of other
groups.

   For instance, if you are tired of reading many small groups, you can
put them all in one big group, and then grow tired of reading one big,
unwieldy group.  The joys of computing!

   You specify `nnvirtual' as the method.  The address should be a
regexp to match component groups.

   All marks in the virtual group will stick to the articles in the
component groups.  So if you tick an article in a virtual group, the
article will also be ticked in the component group from whence it came.
(And vice versa--marks from the component groups will also be shown in
the virtual group.).  To create an empty virtual group, run `G V'
(`gnus-group-make-empty-virtual') in the group buffer and edit the
method regexp with `M-e' (`gnus-group-edit-group-method')

   Here's an example `nnvirtual' method that collects all Andrea Dworkin
newsgroups into one, big, happy newsgroup:

     (nnvirtual "^alt\\.fan\\.andrea-dworkin$\\|^rec\\.dworkin.*")

   The component groups can be native or foreign; everything should work
smoothly, but if your computer explodes, it was probably my fault.

   Collecting the same group from several servers might actually be a
good idea if users have set the Distribution header to limit
distribution.  If you would like to read `soc.motss' both from a server
in Japan and a server in Norway, you could use the following as the
group regexp:

     "^nntp\\+server\\.jp:soc\\.motss$\\|^nntp\\+server\\.no:soc\\.motss$"

   (Remember, though, that if you're creating the group with `G m', you
shouldn't double the backslashes, and you should leave off the quote
characters at the beginning and the end of the string.)

   This should work kinda smoothly--all articles from both groups should
end up in this one, and there should be no duplicates.  Threading (and
the rest) will still work as usual, but there might be problems with the
sequence of articles.  Sorting on date might be an option here (*note
Selecting a Group::).

   One limitation, however--all groups included in a virtual group have
to be alive (i.e., subscribed or unsubscribed).  Killed or zombie
groups can't be component groups for `nnvirtual' groups.

   If the `nnvirtual-always-rescan' variable is non-`nil' (which is the
default), `nnvirtual' will always scan groups for unread articles when
entering a virtual group.  If this variable is `nil' and you read
articles in a component group after the virtual group has been
activated, the read articles from the component group will show up when
you enter the virtual group.  You'll also see this effect if you have
two virtual groups that have a component group in common.  If that's
the case, you should set this variable to `t'.  Or you can just tap
`M-g' on the virtual group every time before you enter it--it'll have
much the same effect.

   `nnvirtual' can have both mail and news groups as component groups.
When responding to articles in `nnvirtual' groups, `nnvirtual' has to
ask the back end of the component group the article comes from whether
it is a news or mail back end.  However, when you do a `^', there is
typically no sure way for the component back end to know this, and in
that case `nnvirtual' tells Gnus that the article came from a not-news
back end.  (Just to be on the safe side.)

   `C-c C-n' in the message buffer will insert the `Newsgroups' line
from the article you respond to in these cases.

   `nnvirtual' groups do not inherit anything but articles and marks
from component groups--group parameters, for instance, are not
inherited.


File: gnus,  Node: Kibozed Groups,  Prev: Virtual Groups,  Up: Combined Groups

6.7.2 Kibozed Groups
--------------------

"Kibozing" is defined by the OED as "grepping through (parts of) the
news feed".  `nnkiboze' is a back end that will do this for you.  Oh
joy!  Now you can grind any NNTP server down to a halt with useless
requests!  Oh happiness!

   To create a kibozed group, use the `G k' command in the group buffer.

   The address field of the `nnkiboze' method is, as with `nnvirtual',
a regexp to match groups to be "included" in the `nnkiboze' group.
That's where most similarities between `nnkiboze' and `nnvirtual' end.

   In addition to this regexp detailing component groups, an `nnkiboze'
group must have a score file to say what articles are to be included in
the group (*note Scoring::).

   You must run `M-x nnkiboze-generate-groups' after creating the
`nnkiboze' groups you want to have.  This command will take time.  Lots
of time.  Oodles and oodles of time.  Gnus has to fetch the headers
from all the articles in all the component groups and run them through
the scoring process to determine if there are any articles in the
groups that are to be part of the `nnkiboze' groups.

   Please limit the number of component groups by using restrictive
regexps.  Otherwise your sysadmin may become annoyed with you, and the
NNTP site may throw you off and never let you back in again.  Stranger
things have happened.

   `nnkiboze' component groups do not have to be alive--they can be
dead, and they can be foreign.  No restrictions.

   The generation of an `nnkiboze' group means writing two files in
`nnkiboze-directory', which is `~/News/kiboze/' by default.  One
contains the NOV header lines for all the articles in the group, and
the other is an additional `.newsrc' file to store information on what
groups have been searched through to find component articles.

   Articles marked as read in the `nnkiboze' group will have their NOV
lines removed from the NOV file.


File: gnus,  Node: Email Based Diary,  Next: Gnus Unplugged,  Prev: Combined Groups,  Up: Select Methods

6.8 Email Based Diary
=====================

This section describes a special mail back end called `nndiary', and
its companion library `gnus-diary'.  It is "special" in the sense that
it is not meant to be one of the standard alternatives for reading mail
with Gnus.  See *note Choosing a Mail Back End:: for that.  Instead, it
is used to treat _some_ of your mails in a special way, namely, as
event reminders.

   Here is a typical scenario:

   * You've got a date with Andy Mc Dowell or Bruce Willis (select
     according to your sexual preference) in one month.  You don't want
     to forget it.

   * So you send a "reminder" message (actually, a diary one) to
     yourself.

   * You forget all about it and keep on getting and reading new mail,
     as usual.

   * From time to time, as you type `g' in the group buffer and as the
     date is getting closer, the message will pop up again to remind
     you of your appointment, just as if it were new and unread.

   * Read your "new" messages, this one included, and start dreaming
     again of the night you're gonna have.

   * Once the date is over (you actually fell asleep just after
     dinner), the message will be automatically deleted if it is marked
     as expirable.

   The Gnus Diary back end has the ability to handle regular
appointments (that wouldn't ever be deleted) as well as punctual ones,
operates as a real mail back end and is configurable in many ways.  All
of this is explained in the sections below.

* Menu:

* The NNDiary Back End::        Basic setup and usage.
* The Gnus Diary Library::      Utility toolkit on top of nndiary.
* Sending or Not Sending::      A final note on sending diary messages.


File: gnus,  Node: The NNDiary Back End,  Next: The Gnus Diary Library,  Up: Email Based Diary

6.8.1 The NNDiary Back End
--------------------------

`nndiary' is a back end very similar to `nnml' (*note Mail Spool::).
Actually, it could appear as a mix of `nnml' and `nndraft'.  If you
know `nnml', you're already familiar with the message storing scheme of
`nndiary': one file per message, one directory per group.

   Before anything, there is one requirement to be able to run
`nndiary' properly: you _must_ use the group timestamp feature of Gnus.
This adds a timestamp to each group's parameters.  *note Group
Timestamp:: to see how it's done.

* Menu:

* Diary Messages::              What makes a message valid for nndiary.
* Running NNDiary::             NNDiary has two modes of operation.
* Customizing NNDiary::         Bells and whistles.


File: gnus,  Node: Diary Messages,  Next: Running NNDiary,  Up: The NNDiary Back End

6.8.1.1 Diary Messages
......................

`nndiary' messages are just normal ones, except for the mandatory
presence of 7 special headers.  These headers are of the form
`X-Diary-<something>', `<something>' being one of `Minute', `Hour',
`Dom', `Month', `Year', `Time-Zone' and `Dow'.  `Dom' means "Day of
Month", and `dow' means "Day of Week".  These headers actually behave
like crontab specifications and define the event date(s):

   * For all headers except the `Time-Zone' one, a header value is
     either a star (meaning all possible values), or a list of fields
     (separated by a comma).

   * A field is either an integer, or a range.

   * A range is two integers separated by a dash.

   * Possible integer values are 0-59 for `Minute', 0-23 for `Hour',
     1-31 for `Dom', 1-12 for `Month', above 1971 for `Year' and 0-6
     for `Dow' (0 meaning Sunday).

   * As a special case, a star in either `Dom' or `Dow' doesn't mean
     "all possible values", but "use only the other field".  Note that
     if both are star'ed, the use of either one gives the same result.

   * The `Time-Zone' header is special in that it can only have one
     value (`GMT', for instance).  A star doesn't mean "all possible
     values" (because it makes no sense), but "the current local time
     zone".  Most of the time, you'll be using a star here.  However,
     for a list of available time zone values, see the variable
     `nndiary-headers'.

   As a concrete example, here are the diary headers to add to your
message for specifying "Each Monday and each 1st of month, at 12:00,
20:00, 21:00, 22:00, 23:00 and 24:00, from 1999 to 2010" (I'll let you
find what to do then):

     X-Diary-Minute: 0
     X-Diary-Hour: 12, 20-24
     X-Diary-Dom: 1
     X-Diary-Month: *
     X-Diary-Year: 1999-2010
     X-Diary-Dow: 1
     X-Diary-Time-Zone: *


File: gnus,  Node: Running NNDiary,  Next: Customizing NNDiary,  Prev: Diary Messages,  Up: The NNDiary Back End

6.8.1.2 Running NNDiary
.......................

`nndiary' has two modes of operation: "traditional" (the default) and
"autonomous".  In traditional mode, `nndiary' does not get new mail by
itself.  You have to move (`B m') or copy (`B c') mails from your
primary mail back end to nndiary groups in order to handle them as
diary messages.  In autonomous mode, `nndiary' retrieves its own mail
and handles it independently from your primary mail back end.

   One should note that Gnus is not inherently designed to allow several
"master" mail back ends at the same time.  However, this does make
sense with `nndiary': you really want to send and receive diary
messages to your diary groups directly.  So, `nndiary' supports being
sort of a "second primary mail back end" (to my knowledge, it is the
only back end offering this feature).  However, there is a limitation
(which I hope to fix some day): respooling doesn't work in autonomous
mode.

   In order to use `nndiary' in autonomous mode, you have several
things to do:

   * Allow `nndiary' to retrieve new mail by itself.  Put the following
     line in your `~/.gnus.el' file:

          (setq nndiary-get-new-mail t)

   * You must arrange for diary messages (those containing `X-Diary-*'
     headers) to be split in a private folder _before_ Gnus treat them.
     Again, this is needed because Gnus cannot (yet ?) properly handle
     multiple primary mail back ends.  Getting those messages from a
     separate source will compensate this misfeature to some extent.

     As an example, here's my procmailrc entry to store diary files in
     `~/.nndiary' (the default `nndiary' mail source file):

          :0 HD :
          * ^X-Diary
          .nndiary

   Once this is done, you might want to customize the following two
options that affect the diary mail retrieval and splitting processes:

 -- Variable: nndiary-mail-sources
     This is the diary-specific replacement for the standard
     `mail-sources' variable.  It obeys the same syntax, and defaults to
     `(file :path "~/.nndiary")'.

 -- Variable: nndiary-split-methods
     This is the diary-specific replacement for the standard
     `nnmail-split-methods' variable.  It obeys the same syntax.

   Finally, you may add a permanent `nndiary' virtual server (something
like `(nndiary "diary")' should do) to your
`gnus-secondary-select-methods'.

   Hopefully, almost everything (see the TODO section in `nndiary.el')
will work as expected when you restart Gnus: in autonomous mode, typing
`g' and `M-g' in the group buffer, will also get your new diary mails
and split them according to your diary-specific rules, `F' will find
your new diary groups etc.


File: gnus,  Node: Customizing NNDiary,  Prev: Running NNDiary,  Up: The NNDiary Back End

6.8.1.3 Customizing NNDiary
...........................

Now that `nndiary' is up and running, it's time to customize it.  The
custom group is called `nndiary' (no, really ?!).  You should browse it
to figure out which options you'd like to tweak.  The following two
variables are probably the only ones you will want to change:

 -- Variable: nndiary-reminders
     This is the list of times when you want to be reminded of your
     appointments (e.g. 3 weeks before, then 2 days before, then 1 hour
     before and that's it).  Remember that "being reminded" means that
     the diary message will pop up as brand new and unread again when
     you get new mail.

 -- Variable: nndiary-week-starts-on-monday
     Rather self-explanatory.  Otherwise, Sunday is assumed (this is the
     default).


File: gnus,  Node: The Gnus Diary Library,  Next: Sending or Not Sending,  Prev: The NNDiary Back End,  Up: Email Based Diary

6.8.2 The Gnus Diary Library
----------------------------

Using `nndiary' manually (I mean, writing the headers by hand and so
on) would be rather boring.  Fortunately, there is a library called
`gnus-diary' written on top of `nndiary', that does many useful things
for you.

   In order to use it, add the following line to your `~/.gnus.el' file:

     (require 'gnus-diary)

   Also, you shouldn't use any `gnus-user-format-function-[d|D]' (*note
Summary Buffer Lines::).  `gnus-diary' provides both of these (sorry if
you used them before).

* Menu:

* Diary Summary Line Format::           A nicer summary buffer line format.
* Diary Articles Sorting::              A nicer way to sort messages.
* Diary Headers Generation::            Not doing it manually.
* Diary Group Parameters::              Not handling them manually.


File: gnus,  Node: Diary Summary Line Format,  Next: Diary Articles Sorting,  Up: The Gnus Diary Library

6.8.2.1 Diary Summary Line Format
.................................

Displaying diary messages in standard summary line format (usually
something like `From Joe: Subject') is pretty useless.  Most of the
time, you're the one who wrote the message, and you mostly want to see
the event's date.

   `gnus-diary' provides two supplemental user formats to be used in
summary line formats.  `D' corresponds to a formatted time string for
the next occurrence of the event (e.g. "Sat, Sep 22 01, 12:00"), while
`d' corresponds to an approximative remaining time until the next
occurrence of the event (e.g. "in 6 months, 1 week").

   For example, here's how Joe's birthday is displayed in my
`nndiary+diary:birthdays' summary buffer (note that the message is
expirable, but will never be deleted, as it specifies a periodic event):

        E  Sat, Sep 22 01, 12:00: Joe's birthday (in 6 months, 1 week)

   In order to get something like the above, you would normally add the
following line to your diary groups'parameters:

     (gnus-summary-line-format "%U%R%z %uD: %(%s%) (%ud)\n")

   However, `gnus-diary' does it automatically (*note Diary Group
Parameters::).  You can however customize the provided summary line
format with the following user options:

 -- Variable: gnus-diary-summary-line-format
     Defines the summary line format used for diary groups (*note
     Summary Buffer Lines::).  `gnus-diary' uses it to automatically
     update the diary groups'parameters.

 -- Variable: gnus-diary-time-format
     Defines the format to display dates in diary summary buffers.
     This is used by the `D' user format.  See the docstring for
     details.

 -- Variable: gnus-diary-delay-format-function
     Defines the format function to use for displaying delays (remaining
     times) in diary summary buffers.  This is used by the `d' user
     format.  There are currently built-in functions for English and
     French; you can also define your own.  See the docstring for
     details.


File: gnus,  Node: Diary Articles Sorting,  Next: Diary Headers Generation,  Prev: Diary Summary Line Format,  Up: The Gnus Diary Library

6.8.2.2 Diary Articles Sorting
..............................

`gnus-diary' provides new sorting functions (*note Sorting the Summary
Buffer:: ) called `gnus-summary-sort-by-schedule',
`gnus-thread-sort-by-schedule' and `gnus-article-sort-by-schedule'.
These functions let you organize your diary summary buffers from the
closest event to the farthest one.

   `gnus-diary' automatically installs `gnus-summary-sort-by-schedule'
as a menu item in the summary buffer's "sort" menu, and the two others
as the primary (hence default) sorting functions in the group
parameters (*note Diary Group Parameters::).


File: gnus,  Node: Diary Headers Generation,  Next: Diary Group Parameters,  Prev: Diary Articles Sorting,  Up: The Gnus Diary Library

6.8.2.3 Diary Headers Generation
................................

`gnus-diary' provides a function called `gnus-diary-check-message' to
help you handle the `X-Diary-*' headers.  This function ensures that
the current message contains all the required diary headers, and
prompts you for values or corrections if needed.

   This function is hooked into the `nndiary' back end, so that moving
or copying an article to a diary group will trigger it automatically.
It is also bound to `C-c C-f d' in `message-mode' and
`article-edit-mode' in order to ease the process of converting a usual
mail to a diary one.

   This function takes a prefix argument which will force prompting of
all diary headers, regardless of their presence or validity.  That way,
you can very easily reschedule an already valid diary message, for
instance.


File: gnus,  Node: Diary Group Parameters,  Prev: Diary Headers Generation,  Up: The Gnus Diary Library

6.8.2.4 Diary Group Parameters
..............................

When you create a new diary group, or visit one, `gnus-diary'
automatically checks your group parameters and if needed, sets the
summary line format to the diary-specific value, installs the
diary-specific sorting functions, and also adds the different
`X-Diary-*' headers to the group's posting-style.  It is then easier to
send a diary message, because if you use `C-u a' or `C-u m' on a diary
group to prepare a message, these headers will be inserted
automatically (although not filled with proper values yet).


File: gnus,  Node: Sending or Not Sending,  Prev: The Gnus Diary Library,  Up: Email Based Diary

6.8.3 Sending or Not Sending
----------------------------

Well, assuming you've read all of the above, here are two final notes on
mail sending with `nndiary':

   * `nndiary' is a _real_ mail back end.  You really send real diary
     messsages for real.  This means for instance that you can give
     appointments to anybody (provided they use Gnus and `nndiary') by
     sending the diary message to them as well.

   * However, since `nndiary' also has a `request-post' method, you can
     also use `C-u a' instead of `C-u m' on a diary group and the
     message won't actually be sent; just stored locally in the group.
     This comes in very handy for private appointments.


File: gnus,  Node: Gnus Unplugged,  Prev: Email Based Diary,  Up: Select Methods

6.9 Gnus Unplugged
==================

In olden times (ca. February '88), people used to run their newsreaders
on big machines with permanent connections to the net.  News transport
was dealt with by news servers, and all the newsreaders had to do was to
read news.  Believe it or not.

   Nowadays most people read news and mail at home, and use some sort of
modem to connect to the net.  To avoid running up huge phone bills, it
would be nice to have a way to slurp down all the news and mail, hang up
the phone, read for several hours, and then upload any responses you
have to make.  And then you repeat the procedure.

   Of course, you can use news servers for doing this as well.  I've
used `inn' together with `slurp', `pop' and `sendmail' for some years,
but doing that's a bore.  Moving the news server functionality up to
the newsreader makes sense if you're the only person reading news on a
machine.

   Setting up Gnus as an "offline" newsreader is quite simple.  In
fact, you don't have to configure anything as the agent is now enabled
by default (*note gnus-agent: Agent Variables.).

   Of course, to use it as such, you have to learn a few new commands.

* Menu:

* Agent Basics::                How it all is supposed to work.
* Agent Categories::            How to tell the Gnus Agent what to download.
* Agent Commands::              New commands for all the buffers.
* Agent Visuals::               Ways that the agent may effect your summary buffer.
* Agent as Cache::              The Agent is a big cache too.
* Agent Expiry::                How to make old articles go away.
* Agent Regeneration::          How to recover from lost connections and other accidents.
* Agent and flags::             How the Agent maintains flags.
* Agent and IMAP::              How to use the Agent with IMAP.
* Outgoing Messages::           What happens when you post/mail something?
* Agent Variables::             Customizing is fun.
* Example Setup::               An example `~/.gnus.el' file for offline people.
* Batching Agents::             How to fetch news from a `cron' job.
* Agent Caveats::               What you think it'll do and what it does.


File: gnus,  Node: Agent Basics,  Next: Agent Categories,  Up: Gnus Unplugged

6.9.1 Agent Basics
------------------

First, let's get some terminology out of the way.

   The Gnus Agent is said to be "unplugged" when you have severed the
connection to the net (and notified the Agent that this is the case).
When the connection to the net is up again (and Gnus knows this), the
Agent is "plugged".

   The "local" machine is the one you're running on, and which isn't
connected to the net continuously.

   "Downloading" means fetching things from the net to your local
machine.  "Uploading" is doing the opposite.

   You know that Gnus gives you all the opportunity you'd ever want for
shooting yourself in the foot.  Some people call it flexibility.  Gnus
is also customizable to a great extent, which means that the user has a
say on how Gnus behaves.  Other newsreaders might unconditionally shoot
you in your foot, but with Gnus, you have a choice!

   Gnus is never really in plugged or unplugged state.  Rather, it
applies that state to each server individually.  This means that some
servers can be plugged while others can be unplugged.  Additionally,
some servers can be ignored by the Agent altogether (which means that
they're kinda like plugged always).

   So when you unplug the Agent and then wonder why is Gnus opening a
connection to the Net, the next step to do is to look whether all
servers are agentized.  If there is an unagentized server, you found
the culprit.

   Another thing is the "offline" state.  Sometimes, servers aren't
reachable.  When Gnus notices this, it asks you whether you want the
server to be switched to offline state.  If you say yes, then the
server will behave somewhat as if it was unplugged, except that Gnus
will ask you whether you want to switch it back online again.

   Let's take a typical Gnus session using the Agent.

   * You start Gnus with `gnus-unplugged'.  This brings up the Gnus
     Agent in a disconnected state.  You can read all the news that you
     have already fetched while in this mode.

   * You then decide to see whether any new news has arrived.  You
     connect your machine to the net (using PPP or whatever), and then
     hit `J j' to make Gnus become "plugged" and use `g' to check for
     new mail as usual.  To check for new mail in unplugged mode (*note
     Mail Source Specifiers::).

   * You can then read the new news immediately, or you can download the
     news onto your local machine.  If you want to do the latter, you
     press `g' to check if there are any new news and then `J s' to
     fetch all the eligible articles in all the groups.  (To let Gnus
     know which articles you want to download, *note Agent
     Categories::).

   * After fetching the articles, you press `J j' to make Gnus become
     unplugged again, and you shut down the PPP thing (or whatever).
     And then you read the news offline.

   * And then you go to step 2.

   Here are some things you should do the first time (or so) that you
use the Agent.

   * Decide which servers should be covered by the Agent.  If you have
     a mail back end, it would probably be nonsensical to have it
     covered by the Agent.  Go to the server buffer (`^' in the group
     buffer) and press `J a' on the server (or servers) that you wish
     to have covered by the Agent (*note Server Agent Commands::), or
     `J r' on automatically added servers you do not wish to have
     covered by the Agent.  By default, all `nntp' and `nnimap' servers
     in `gnus-select-method' and `gnus-secondary-select-methods' are
     agentized.

   * Decide on download policy.  It's fairly simple once you decide
     whether you are going to use agent categories, topic parameters,
     and/or group parameters to implement your policy.  If you're new
     to gnus, it is probably best to start with a category, *Note Agent
     Categories::.

     Both topic parameters (*note Topic Parameters::) and agent
     categories (*note Agent Categories::) provide for setting a policy
     that applies to multiple groups.  Which you use is entirely up to
     you.  Topic parameters do override categories so, if you mix the
     two, you'll have to take that into account.  If you have a few
     groups that deviate from your policy, you can use group parameters
     (*note Group Parameters::) to configure them.

   * Uhm... that's it.


File: gnus,  Node: Agent Categories,  Next: Agent Commands,  Prev: Agent Basics,  Up: Gnus Unplugged

6.9.2 Agent Categories
----------------------

One of the main reasons to integrate the news transport layer into the
newsreader is to allow greater control over what articles to download.
There's not much point in downloading huge amounts of articles, just to
find out that you're not interested in reading any of them.  It's better
to be somewhat more conservative in choosing what to download, and then
mark the articles for downloading manually if it should turn out that
you're interested in the articles anyway.

   One of the more effective methods for controlling what is to be
downloaded is to create a "category" and then assign some (or all)
groups to this category.  Groups that do not belong in any other
category belong to the `default' category.  Gnus has its own buffer for
creating and managing categories.

   If you prefer, you can also use group parameters (*note Group
Parameters::) and topic parameters (*note Topic Parameters::) for an
alternative approach to controlling the agent.  The only real
difference is that categories are specific to the agent (so there is
less to learn) while group and topic parameters include the kitchen
sink.

   Since you can set agent parameters in several different places we
have a rule to decide which source to believe.  This rule specifies that
the parameter sources are checked in the following order: group
parameters, topic parameters, agent category, and finally customizable
variables.  So you can mix all of these sources to produce a wide range
of behavior, just don't blame me if you don't remember where you put
your settings.

* Menu:

* Category Syntax::             What a category looks like.
* Category Buffer::             A buffer for maintaining categories.
* Category Variables::          Customize'r'Us.


File: gnus,  Node: Category Syntax,  Next: Category Buffer,  Up: Agent Categories

6.9.2.1 Category Syntax
.......................

A category consists of a name, the list of groups belonging to the
category, and a number of optional parameters that override the
customizable variables.  The complete list of agent parameters are
listed below.

`agent-groups'
     The list of groups that are in this category.

`agent-predicate'
     A predicate which (generally) gives a rough outline of which
     articles are eligible for downloading; and

`agent-score'
     a score rule which (generally) gives you a finer granularity when
     deciding what articles to download.  (Note that this "download
     score" is not necessarily related to normal scores.)

`agent-enable-expiration'
     a boolean indicating whether the agent should expire old articles
     in this group.  Most groups should be expired to conserve disk
     space.  In fact, its probably safe to say that the gnus.*
     hierarchy contains the only groups that should not be expired.

`agent-days-until-old'
     an integer indicating the number of days that the agent should wait
     before deciding that a read article is safe to expire.

`agent-low-score'
     an integer that overrides the value of `gnus-agent-low-score'.

`agent-high-score'
     an integer that overrides the value of `gnus-agent-high-score'.

`agent-short-article'
     an integer that overrides the value of `gnus-agent-short-article'.

`agent-long-article'
     an integer that overrides the value of `gnus-agent-long-article'.

`agent-enable-undownloaded-faces'
     a symbol indicating whether the summary buffer should display
     undownloaded articles using the `gnus-summary-*-undownloaded-face'
     faces.  Any symbol other than `nil' will enable the use of
     undownloaded faces.

   The name of a category can not be changed once the category has been
created.

   Each category maintains a list of groups that are exclusive members
of that category.  The exclusivity rule is automatically enforced, add a
group to a new category and it is automatically removed from its old
category.

   A predicate in its simplest form can be a single predicate such as
`true' or `false'.  These two will download every available article or
nothing respectively.  In the case of these two special predicates an
additional score rule is superfluous.

   Predicates of `high' or `low' download articles in respect of their
scores in relationship to `gnus-agent-high-score' and
`gnus-agent-low-score' as described below.

   To gain even finer control of what is to be regarded eligible for
download a predicate can consist of a number of predicates with logical
operators sprinkled in between.

   Perhaps some examples are in order.

   Here's a simple predicate.  (It's the default predicate, in fact,
used for all groups that don't belong to any other category.)

     short

   Quite simple, eh?  This predicate is true if and only if the article
is short (for some value of "short").

   Here's a more complex predicate:

     (or high
         (and
          (not low)
          (not long)))

   This means that an article should be downloaded if it has a high
score, or if the score is not low and the article is not long.  You get
the drift.

   The available logical operators are `or', `and' and `not'.  (If you
prefer, you can use the more "C"-ish operators `|', `&' and `!'
instead.)

   The following predicates are pre-defined, but if none of these fit
what you want to do, you can write your own.

   When evaluating each of these predicates, the named constant will be
bound to the value determined by calling `gnus-agent-find-parameter' on
the appropriate parameter.  For example, gnus-agent-short-article will
be bound to `(gnus-agent-find-parameter group 'agent-short-article)'.
This means that you can specify a predicate in your category then tune
that predicate to individual groups.

`short'
     True if the article is shorter than `gnus-agent-short-article'
     lines; default 100.

`long'
     True if the article is longer than `gnus-agent-long-article'
     lines; default 200.

`low'
     True if the article has a download score less than
     `gnus-agent-low-score'; default 0.

`high'
     True if the article has a download score greater than
     `gnus-agent-high-score'; default 0.

`spam'
     True if the Gnus Agent guesses that the article is spam.  The
     heuristics may change over time, but at present it just computes a
     checksum and sees whether articles match.

`true'
     Always true.

`false'
     Always false.

   If you want to create your own predicate function, here's what you
have to know:  The functions are called with no parameters, but the
`gnus-headers' and `gnus-score' dynamic variables are bound to useful
values.

   For example, you could decide that you don't want to download
articles that were posted more than a certain number of days ago (e.g.
posted more than `gnus-agent-expire-days' ago) you might write a
function something along the lines of the following:

     (defun my-article-old-p ()
       "Say whether an article is old."
       (< (time-to-days (date-to-time (mail-header-date gnus-headers)))
          (- (time-to-days (current-time)) gnus-agent-expire-days)))

   with the predicate then defined as:

     (not my-article-old-p)

   or you could append your predicate to the predefined
`gnus-category-predicate-alist' in your `~/.gnus.el' or wherever.

     (require 'gnus-agent)
     (setq  gnus-category-predicate-alist
       (append gnus-category-predicate-alist
              '((old . my-article-old-p))))

   and simply specify your predicate as:

     (not old)

   If/when using something like the above, be aware that there are many
misconfigured systems/mailers out there and so an article's date is not
always a reliable indication of when it was posted.  Hell, some people
just don't give a damn.

   The above predicates apply to _all_ the groups which belong to the
category.  However, if you wish to have a specific predicate for an
individual group within a category, or you're just too lazy to set up a
new category, you can enter a group's individual predicate in its group
parameters like so:

     (agent-predicate . short)

   This is the group/topic parameter equivalent of the agent category
default.  Note that when specifying a single word predicate like this,
the `agent-predicate' specification must be in dotted pair notation.

   The equivalent of the longer example from above would be:

     (agent-predicate or high (and (not low) (not long)))

   The outer parenthesis required in the category specification are not
entered here as, not being in dotted pair notation, the value of the
predicate is assumed to be a list.

   Now, the syntax of the download score is the same as the syntax of
normal score files, except that all elements that require actually
seeing the article itself are verboten.  This means that only the
following headers can be scored on: `Subject', `From', `Date',
`Message-ID', `References', `Chars', `Lines', and `Xref'.

   As with predicates, the specification of the `download score rule'
to use in respect of a group can be in either the category definition if
it's to be applicable to all groups in therein, or a group's parameters
if it's to be specific to that group.

   In both of these places the `download score rule' can take one of
three forms:

  1. Score rule

     This has the same syntax as a normal Gnus score file except only a
     subset of scoring keywords are available as mentioned above.

     example:

        * Category specification

               (("from"
                      ("Lars Ingebrigtsen" 1000000 nil s))
               ("lines"
                      (500 -100 nil <)))

        * Group/Topic Parameter specification

               (agent-score ("from"
                                  ("Lars Ingebrigtsen" 1000000 nil s))
                            ("lines"
                                  (500 -100 nil <)))

          Again, note the omission of the outermost parenthesis here.

  2. Agent score file

     These score files must _only_ contain the permitted scoring
     keywords stated above.

     example:

        * Category specification

               ("~/News/agent.SCORE")

          or perhaps

               ("~/News/agent.SCORE" "~/News/agent.group.SCORE")

        * Group Parameter specification

               (agent-score "~/News/agent.SCORE")

          Additional score files can be specified as above.  Need I say
          anything about parenthesis?

  3. Use `normal' score files

     If you don't want to maintain two sets of scoring rules for a
     group, and your desired `downloading' criteria for a group are the
     same as your `reading' criteria then you can tell the agent to
     refer to your `normal' score files when deciding what to download.

     These directives in either the category definition or a group's
     parameters will cause the agent to read in all the applicable score
     files for a group, _filtering out_ those sections that do not
     relate to one of the permitted subset of scoring keywords.

        * Category Specification

               file

        * Group Parameter specification

               (agent-score . file)


File: gnus,  Node: Category Buffer,  Next: Category Variables,  Prev: Category Syntax,  Up: Agent Categories

6.9.2.2 Category Buffer
.......................

You'd normally do all category maintenance from the category buffer.
When you enter it for the first time (with the `J c' command from the
group buffer), you'll only see the `default' category.

   The following commands are available in this buffer:

`q'
     Return to the group buffer (`gnus-category-exit').

`e'
     Use a customization buffer to set all of the selected category's
     parameters at one time (`gnus-category-customize-category').

`k'
     Kill the current category (`gnus-category-kill').

`c'
     Copy the current category (`gnus-category-copy').

`a'
     Add a new category (`gnus-category-add').

`p'
     Edit the predicate of the current category
     (`gnus-category-edit-predicate').

`g'
     Edit the list of groups belonging to the current category
     (`gnus-category-edit-groups').

`s'
     Edit the download score rule of the current category
     (`gnus-category-edit-score').

`l'
     List all the categories (`gnus-category-list').


File: gnus,  Node: Category Variables,  Prev: Category Buffer,  Up: Agent Categories

6.9.2.3 Category Variables
..........................

`gnus-category-mode-hook'
     Hook run in category buffers.

`gnus-category-line-format'
     Format of the lines in the category buffer (*note Formatting
     Variables::).  Valid elements are:

    `c'
          The name of the category.

    `g'
          The number of groups in the category.

`gnus-category-mode-line-format'
     Format of the category mode line (*note Mode Line Formatting::).

`gnus-agent-short-article'
     Articles that have fewer lines than this are short.  Default 100.

`gnus-agent-long-article'
     Articles that have more lines than this are long.  Default 200.

`gnus-agent-low-score'
     Articles that have a score lower than this have a low score.
     Default 0.

`gnus-agent-high-score'
     Articles that have a score higher than this have a high score.
     Default 0.

`gnus-agent-expire-days'
     The number of days that a `read' article must stay in the agent's
     local disk before becoming eligible for expiration (While the name
     is the same, this doesn't mean expiring the article on the server.
     It just means deleting the local copy of the article).  What is
     also important to understand is that the counter starts with the
     time the article was written to the local disk and not the time
     the article was read.  Default 7.

`gnus-agent-enable-expiration'
     Determines whether articles in a group are, by default, expired or
     retained indefinitely.  The default is `ENABLE' which means that
     you'll have to disable expiration when desired.  On the other hand,
     you could set this to `DISABLE'.  In that case, you would then
     have to enable expiration in selected groups.



File: gnus,  Node: Agent Commands,  Next: Agent Visuals,  Prev: Agent Categories,  Up: Gnus Unplugged

6.9.3 Agent Commands
--------------------

All the Gnus Agent commands are on the `J' submap.  The `J j'
(`gnus-agent-toggle-plugged') command works in all modes, and toggles
the plugged/unplugged state of the Gnus Agent.

* Menu:

* Group Agent Commands::        Configure groups and fetch their contents.
* Summary Agent Commands::      Manually select then fetch specific articles.
* Server Agent Commands::       Select the servers that are supported by the agent.


File: gnus,  Node: Group Agent Commands,  Next: Summary Agent Commands,  Up: Agent Commands

6.9.3.1 Group Agent Commands
............................

`J u'
     Fetch all eligible articles in the current group
     (`gnus-agent-fetch-groups').

`J c'
     Enter the Agent category buffer (`gnus-enter-category-buffer').

`J s'
     Fetch all eligible articles in all groups
     (`gnus-agent-fetch-session').

`J S'
     Send all sendable messages in the queue group
     (`gnus-group-send-queue').  *Note Drafts::.

`J a'
     Add the current group to an Agent category
     (`gnus-agent-add-group').  This command understands the
     process/prefix convention (*note Process/Prefix::).

`J r'
     Remove the current group from its category, if any
     (`gnus-agent-remove-group').  This command understands the
     process/prefix convention (*note Process/Prefix::).

`J Y'
     Synchronize flags changed while unplugged with remote server, if
     any.



File: gnus,  Node: Summary Agent Commands,  Next: Server Agent Commands,  Prev: Group Agent Commands,  Up: Agent Commands

6.9.3.2 Summary Agent Commands
..............................

`J #'
     Mark the article for downloading (`gnus-agent-mark-article').

`J M-#'
     Remove the downloading mark from the article
     (`gnus-agent-unmark-article').

`@'
     Toggle whether to download the article (`gnus-agent-toggle-mark').
     The download mark is `%' by default.

`J c'
     Mark all articles as read (`gnus-agent-catchup') that are neither
     cached, downloaded, nor downloadable.

`J S'
     Download all eligible (*note Agent Categories::) articles in this
     group.  (`gnus-agent-fetch-group').

`J s'
     Download all processable articles in this group.
     (`gnus-agent-summary-fetch-series').

`J u'
     Download all downloadable articles in the current group
     (`gnus-agent-summary-fetch-group').



File: gnus,  Node: Server Agent Commands,  Prev: Summary Agent Commands,  Up: Agent Commands

6.9.3.3 Server Agent Commands
.............................

`J a'
     Add the current server to the list of servers covered by the Gnus
     Agent (`gnus-agent-add-server').

`J r'
     Remove the current server from the list of servers covered by the
     Gnus Agent (`gnus-agent-remove-server').



File: gnus,  Node: Agent Visuals,  Next: Agent as Cache,  Prev: Agent Commands,  Up: Gnus Unplugged

6.9.4 Agent Visuals
-------------------

If you open a summary while unplugged and, Gnus knows from the group's
active range that there are more articles than the headers currently
stored in the Agent, you may see some articles whose subject looks
something like `[Undownloaded article #####]'.  These are placeholders
for the missing headers.  Aside from setting a mark, there is not much
that can be done with one of these placeholders.  When Gnus finally
gets a chance to fetch the group's headers, the placeholders will
automatically be replaced by the actual headers.  You can configure the
summary buffer's maneuvering to skip over the placeholders if you care
(See `gnus-auto-goto-ignores').

   While it may be obvious to all, the only headers and articles
available while unplugged are those headers and articles that were
fetched into the Agent while previously plugged.  To put it another
way, "If you forget to fetch something while plugged, you might have a
less than satisfying unplugged session".  For this reason, the Agent
adds two visual effects to your summary buffer.  These effects display
the download status of each article so that you always know which
articles will be available when unplugged.

   The first visual effect is the `%O' spec.  If you customize
`gnus-summary-line-format' to include this specifier, you will add a
single character field that indicates an article's download status.
Articles that have been fetched into either the Agent or the Cache,
will display `gnus-downloaded-mark' (defaults to `+').  All other
articles will display `gnus-undownloaded-mark' (defaults to `-').  If
you open a group that has not been agentized, a space (` ') will be
displayed.

   The second visual effect are the undownloaded faces.  The faces,
there are three indicating the article's score (low, normal, high),
seem to result in a love/hate response from many Gnus users.  The
problem is that the face selection is controlled by a list of condition
tests and face names (See `gnus-summary-highlight').  Each condition is
tested in the order in which it appears in the list so early conditions
have precedence over later conditions.  All of this means that, if you
tick an undownloaded article, the article will continue to be displayed
in the undownloaded face rather than the ticked face.

   If you use the Agent as a cache (to avoid downloading the same
article each time you visit it or to minimize your connection time), the
undownloaded face will probably seem like a good idea.  The reason
being that you do all of our work (marking, reading, deleting) with
downloaded articles so the normal faces always appear.  For those users
using the agent to improve online performance by caching the NOV
database (most users since 5.10.2), the undownloaded faces may appear
to be an absolutely horrible idea.  The issue being that, since none of
their articles have been fetched into the Agent, all of the normal
faces will be obscured by the undownloaded faces.

   If you would like to use the undownloaded faces, you must enable the
undownloaded faces by setting the `agent-enable-undownloaded-faces'
group parameter to `t'.  This parameter, like all other agent
parameters, may be set on an Agent Category (*note Agent Categories::),
a Group Topic (*note Topic Parameters::), or an individual group (*note
Group Parameters::).

   The one problem common to all users using the agent is how quickly it
can consume disk space.  If you using the agent on many groups, it is
even more difficult to effectively recover disk space.  One solution is
the `%F' format available in `gnus-group-line-format'.  This format
will display the actual disk space used by articles fetched into both
the agent and cache.  By knowing which groups use the most space, users
know where to focus their efforts when "agent expiring" articles.


File: gnus,  Node: Agent as Cache,  Next: Agent Expiry,  Prev: Agent Visuals,  Up: Gnus Unplugged

6.9.5 Agent as Cache
--------------------

When Gnus is plugged, it is not efficient to download headers or
articles from the server again, if they are already stored in the
Agent.  So, Gnus normally only downloads headers once, and stores them
in the Agent.  These headers are later used when generating the summary
buffer, regardless of whether you are plugged or unplugged.  Articles
are not cached in the Agent by default though (that would potentially
consume lots of disk space), but if you have already downloaded an
article into the Agent, Gnus will not download the article from the
server again but use the locally stored copy instead.

   If you so desire, you can configure the agent (see `gnus-agent-cache'
*note Agent Variables::) to always download headers and articles while
plugged.  Gnus will almost certainly be slower, but it will be kept
synchronized with the server.  That last point probably won't make any
sense if you are using a nntp or nnimap back end.


File: gnus,  Node: Agent Expiry,  Next: Agent Regeneration,  Prev: Agent as Cache,  Up: Gnus Unplugged

6.9.6 Agent Expiry
------------------

The Agent back end, `nnagent', doesn't handle expiry.  Well, at least
it doesn't handle it like other back ends.  Instead, there are special
`gnus-agent-expire' and `gnus-agent-expire-group' commands that will
expire all read articles that are older than `gnus-agent-expire-days'
days.  They can be run whenever you feel that you're running out of
space.  Neither are particularly fast or efficient, and it's not a
particularly good idea to interrupt them (with `C-g' or anything else)
once you've started one of them.

   Note that other functions, e.g. `gnus-request-expire-articles',
might run `gnus-agent-expire' for you to keep the agent synchronized
with the group.

   The agent parameter `agent-enable-expiration' may be used to prevent
expiration in selected groups.

   If `gnus-agent-expire-all' is non-`nil', the agent expiration
commands will expire all articles--unread, read, ticked and dormant.
If `nil' (which is the default), only read articles are eligible for
expiry, and unread, ticked and dormant articles will be kept
indefinitely.

   If you find that some articles eligible for expiry are never expired,
perhaps some Gnus Agent files are corrupted.  There's are special
commands, `gnus-agent-regenerate' and `gnus-agent-regenerate-group', to
fix possible problems.


File: gnus,  Node: Agent Regeneration,  Next: Agent and flags,  Prev: Agent Expiry,  Up: Gnus Unplugged

6.9.7 Agent Regeneration
------------------------

The local data structures used by `nnagent' may become corrupted due to
certain exceptional conditions.  When this happens, `nnagent'
functionality may degrade or even fail.  The solution to this problem
is to repair the local data structures by removing all internal
inconsistencies.

   For example, if your connection to your server is lost while
downloaded articles into the agent, the local data structures will not
know about articles successfully downloaded prior to the connection
failure.  Running `gnus-agent-regenerate' or
`gnus-agent-regenerate-group' will update the data structures such that
you don't need to download these articles a second time.

   The command `gnus-agent-regenerate' will perform
`gnus-agent-regenerate-group' on every agentized group.  While you can
run `gnus-agent-regenerate' in any buffer, it is strongly recommended
that you first close all summary buffers.

   The command `gnus-agent-regenerate-group' uses the local copies of
individual articles to repair the local NOV(header) database.  It then
updates the internal data structures that document which articles are
stored locally.  An optional argument will mark articles in the agent
as unread.


File: gnus,  Node: Agent and flags,  Next: Agent and IMAP,  Prev: Agent Regeneration,  Up: Gnus Unplugged

6.9.8 Agent and flags
---------------------

The Agent works with any Gnus back end including those, such as nnimap,
that store flags (read, ticked, etc) on the server.  Sadly, the Agent
does not actually know which backends keep their flags in the backend
server rather than in `.newsrc'.  This means that the Agent, while
unplugged or disconnected, will always record all changes to the flags
in its own files.

   When you plug back in, Gnus will then check to see if you have any
changed any flags and ask if you wish to synchronize these with the
server.  This behavior is customizable by
`gnus-agent-synchronize-flags'.

   If `gnus-agent-synchronize-flags' is `nil', the Agent will never
automatically synchronize flags.  If it is `ask', which is the default,
the Agent will check if you made any changes and if so ask if you wish
to synchronize these when you re-connect.  If it has any other value,
all flags will be synchronized automatically.

   If you do not wish to synchronize flags automatically when you
re-connect, you can do it manually with the
`gnus-agent-synchronize-flags' command that is bound to `J Y' in the
group buffer.

   Technical note: the synchronization algorithm does not work by
"pushing" all local flags to the server, but rather by incrementally
updated the server view of flags by changing only those flags that were
changed by the user.  Thus, if you set one flag on an article, quit the
group then re-select the group and remove the flag; the flag will be
set and removed from the server when you "synchronize".  The queued flag
operations can be found in the per-server `flags' file in the Agent
directory.  It's emptied when you synchronize flags.


File: gnus,  Node: Agent and IMAP,  Next: Outgoing Messages,  Prev: Agent and flags,  Up: Gnus Unplugged

6.9.9 Agent and IMAP
--------------------

The Agent works with any Gnus back end, including nnimap.  However,
since there are some conceptual differences between NNTP and IMAP, this
section (should) provide you with some information to make Gnus Agent
work smoother as a IMAP Disconnected Mode client.

   Some things are currently not implemented in the Agent that you'd
might expect from a disconnected IMAP client, including:

   * Copying/moving articles into nnimap groups when unplugged.

   * Creating/deleting nnimap groups when unplugged.



File: gnus,  Node: Outgoing Messages,  Next: Agent Variables,  Prev: Agent and IMAP,  Up: Gnus Unplugged

6.9.10 Outgoing Messages
------------------------

By default, when Gnus is unplugged, all outgoing messages (both mail
and news) are stored in the draft group "queue" (*note Drafts::).  You
can view them there after posting, and edit them at will.

   You can control the circumstances under which outgoing mail is queued
(see `gnus-agent-queue-mail', *note Agent Variables::).  Outgoing news
is always queued when Gnus is unplugged, and never otherwise.

   You can send the messages either from the draft group with the
special commands available there, or you can use the `J S' command in
the group buffer to send all the sendable messages in the draft group.
Posting news will only work when Gnus is plugged, but you can send mail
at any time.

   If sending mail while unplugged does not work for you and you worry
about hitting `J S' by accident when unplugged, you can have Gnus ask
you to confirm your action (see `gnus-agent-prompt-send-queue', *note
Agent Variables::).


File: gnus,  Node: Agent Variables,  Next: Example Setup,  Prev: Outgoing Messages,  Up: Gnus Unplugged

6.9.11 Agent Variables
----------------------

`gnus-agent'
     Is the agent enabled?  The default is `t'.  When first enabled,
     the agent will use `gnus-agent-auto-agentize-methods' to
     automatically mark some back ends as agentized.  You may change
     which back ends are agentized using the agent commands in the
     server buffer.

     To enter the server buffer, use the `^'
     (`gnus-group-enter-server-mode') command in the group buffer.

`gnus-agent-directory'
     Where the Gnus Agent will store its files.  The default is
     `~/News/agent/'.

`gnus-agent-handle-level'
     Groups on levels (*note Group Levels::) higher than this variable
     will be ignored by the Agent.  The default is
     `gnus-level-subscribed', which means that only subscribed group
     will be considered by the Agent by default.

`gnus-agent-plugged-hook'
     Hook run when connecting to the network.

`gnus-agent-unplugged-hook'
     Hook run when disconnecting from the network.

`gnus-agent-fetched-hook'
     Hook run when finished fetching articles.

`gnus-agent-cache'
     Variable to control whether use the locally stored NOV and
     articles when plugged, e.g. essentially using the Agent as a cache.
     The default is non-`nil', which means to use the Agent as a cache.

`gnus-agent-go-online'
     If `gnus-agent-go-online' is `nil', the Agent will never
     automatically switch offline servers into online status.  If it is
     `ask', the default, the Agent will ask if you wish to switch
     offline servers into online status when you re-connect.  If it has
     any other value, all offline servers will be automatically
     switched into online status.

`gnus-agent-mark-unread-after-downloaded'
     If `gnus-agent-mark-unread-after-downloaded' is non-`nil', mark
     articles as unread after downloading.  This is usually a safe
     thing to do as the newly downloaded article has obviously not been
     read.  The default is `t'.

`gnus-agent-synchronize-flags'
     If `gnus-agent-synchronize-flags' is `nil', the Agent will never
     automatically synchronize flags.  If it is `ask', which is the
     default, the Agent will check if you made any changes and if so
     ask if you wish to synchronize these when you re-connect.  If it
     has any other value, all flags will be synchronized automatically.

`gnus-agent-consider-all-articles'
     If `gnus-agent-consider-all-articles' is non-`nil', the agent will
     let the agent predicate decide whether articles need to be
     downloaded or not, for all articles.  When `nil', the default, the
     agent will only let the predicate decide whether unread articles
     are downloaded or not.  If you enable this, you may also want to
     look into the agent expiry settings (*note Category Variables::),
     so that the agent doesn't download articles which the agent will
     later expire, over and over again.

`gnus-agent-max-fetch-size'
     The agent fetches articles into a temporary buffer prior to parsing
     them into individual files.  To avoid exceeding the max. buffer
     size, the agent alternates between fetching and parsing until all
     articles have been fetched.  `gnus-agent-max-fetch-size' provides
     a size limit to control how often the cycling occurs.  A large
     value improves performance.  A small value minimizes the time lost
     should the connection be lost while fetching (You may need to run
     `gnus-agent-regenerate-group' to update the group's state.
     However, all articles parsed prior to loosing the connection will
     be available while unplugged).  The default is 10M so it is
     unusual to see any cycling.

`gnus-server-unopen-status'
     Perhaps not an Agent variable, but closely related to the Agent,
     this variable says what will happen if Gnus cannot open a server.
     If the Agent is enabled, the default, `nil', makes Gnus ask the
     user whether to deny the server or whether to unplug the agent.
     If the Agent is disabled, Gnus always simply deny the server.
     Other choices for this variable include `denied' and `offline' the
     latter is only valid if the Agent is used.

`gnus-auto-goto-ignores'
     Another variable that isn't an Agent variable, yet so closely
     related that most will look for it here, this variable tells the
     summary buffer how to maneuver around undownloaded (only headers
     stored in the agent) and unfetched (neither article nor headers
     stored) articles.

     The valid values are `nil' (maneuver to any article),
     `undownloaded' (maneuvering while unplugged ignores articles that
     have not been fetched), `always-undownloaded' (maneuvering always
     ignores articles that have not been fetched), `unfetched'
     (maneuvering ignores articles whose headers have not been fetched).

`gnus-agent-queue-mail'
     When `gnus-agent-queue-mail' is `always', Gnus will always queue
     mail rather than sending it straight away.  When `t', Gnus will
     queue mail when unplugged only.  When `nil', never queue mail.
     The default is `t'.

`gnus-agent-prompt-send-queue'
     When `gnus-agent-prompt-send-queue' is non-`nil' Gnus will prompt
     you to confirm that you really wish to proceed if you hit `J S'
     while unplugged.  The default is `nil'.

`gnus-agent-auto-agentize-methods'
     If you have never used the Agent before (or more technically, if
     `~/News/agent/lib/servers' does not exist), Gnus will
     automatically agentize a few servers for you.  This variable
     control which back ends should be auto-agentized.  It is typically
     only useful to agentize remote back ends.  The auto-agentizing has
     the same effect as running `J a' on the servers (*note Server
     Agent Commands::).  If the file exist, you must manage the servers
     manually by adding or removing them, this variable is only
     applicable the first time you start Gnus.  The default is `(nntp
     nnimap)'.



File: gnus,  Node: Example Setup,  Next: Batching Agents,  Prev: Agent Variables,  Up: Gnus Unplugged

6.9.12 Example Setup
--------------------

If you don't want to read this manual, and you have a fairly standard
setup, you may be able to use something like the following as your
`~/.gnus.el' file to get started.

     ;; Define how Gnus is to fetch news.  We do this over NNTP
     ;; from your ISP's server.
     (setq gnus-select-method '(nntp "news.your-isp.com"))

     ;; Define how Gnus is to read your mail.  We read mail from
     ;; your ISP's POP server.
     (setq mail-sources '((pop :server "pop.your-isp.com")))

     ;; Say how Gnus is to store the mail.  We use nnml groups.
     (setq gnus-secondary-select-methods '((nnml "")))

     ;; Make Gnus into an offline newsreader.
     ;; (gnus-agentize) ; The obsolete setting.
     ;; (setq gnus-agent t) ; Now the default.

   That should be it, basically.  Put that in your `~/.gnus.el' file,
edit to suit your needs, start up PPP (or whatever), and type `M-x
gnus'.

   If this is the first time you've run Gnus, you will be subscribed
automatically to a few default newsgroups.  You'll probably want to
subscribe to more groups, and to do that, you have to query the NNTP
server for a complete list of groups with the `A A' command.  This
usually takes quite a while, but you only have to do it once.

   After reading and parsing a while, you'll be presented with a list of
groups.  Subscribe to the ones you want to read with the `u' command.
`l' to make all the killed groups disappear after you've subscribe to
all the groups you want to read.  (`A k' will bring back all the killed
groups.)

   You can now read the groups at once, or you can download the articles
with the `J s' command.  And then read the rest of this manual to find
out which of the other gazillion things you want to customize.


File: gnus,  Node: Batching Agents,  Next: Agent Caveats,  Prev: Example Setup,  Up: Gnus Unplugged

6.9.13 Batching Agents
----------------------

Having the Gnus Agent fetch articles (and post whatever messages you've
written) is quite easy once you've gotten things set up properly.  The
following shell script will do everything that is necessary:

   You can run a complete batch command from the command line with the
following incantation:

     #!/bin/sh
     emacs -batch -l ~/.emacs -l ~/.gnus.el -f gnus-agent-batch >/dev/null 2>&1


File: gnus,  Node: Agent Caveats,  Prev: Batching Agents,  Up: Gnus Unplugged

6.9.14 Agent Caveats
--------------------

The Gnus Agent doesn't seem to work like most other offline
newsreaders.  Here are some common questions that some imaginary people
may ask:

"If I read an article while plugged, do they get entered into the Agent?"
     *No*.  If you want this behavior, add
     `gnus-agent-fetch-selected-article' to `gnus-select-article-hook'.

"If I read an article while plugged, and the article already exists in"
     the Agent, will it get downloaded once more?

     *No*, unless `gnus-agent-cache' is `nil'.


   In short, when Gnus is unplugged, it only looks into the locally
stored articles; when it's plugged, it talks to your ISP and may also
use the locally stored articles.


File: gnus,  Node: Scoring,  Next: Various,  Prev: Select Methods,  Up: Top

7 Scoring
*********

Other people use "kill files", but we here at Gnus Towers like scoring
better than killing, so we'd rather switch than fight.  They do
something completely different as well, so sit up straight and pay
attention!

   All articles have a default score (`gnus-summary-default-score'),
which is 0 by default.  This score may be raised or lowered either
interactively or by score files.  Articles that have a score lower than
`gnus-summary-mark-below' are marked as read.

   Gnus will read any "score files" that apply to the current group
before generating the summary buffer.

   There are several commands in the summary buffer that insert score
entries based on the current article.  You can, for instance, ask Gnus
to lower or increase the score of all articles with a certain subject.

   There are two sorts of scoring entries: Permanent and temporary.
Temporary score entries are self-expiring entries.  Any entries that are
temporary and have not been used for, say, a week, will be removed
silently to help keep the sizes of the score files down.

* Menu:

* Summary Score Commands::      Adding score entries for the current group.
* Group Score Commands::        General score commands.
* Score Variables::             Customize your scoring.  (My, what terminology).
* Score File Format::           What a score file may contain.
* Score File Editing::          You can edit score files by hand as well.
* Adaptive Scoring::            Big Sister Gnus knows what you read.
* Home Score File::             How to say where new score entries are to go.
* Followups To Yourself::       Having Gnus notice when people answer you.
* Scoring On Other Headers::    Scoring on non-standard headers.
* Scoring Tips::                How to score effectively.
* Reverse Scoring::             That problem child of old is not problem.
* Global Score Files::          Earth-spanning, ear-splitting score files.
* Kill Files::                  They are still here, but they can be ignored.
* Converting Kill Files::       Translating kill files to score files.
* Advanced Scoring::            Using logical expressions to build score rules.
* Score Decays::                It can be useful to let scores wither away.


File: gnus,  Node: Summary Score Commands,  Next: Group Score Commands,  Up: Scoring

7.1 Summary Score Commands
==========================

The score commands that alter score entries do not actually modify real
score files.  That would be too inefficient.  Gnus maintains a cache of
previously loaded score files, one of which is considered the "current
score file alist".  The score commands simply insert entries into this
list, and upon group exit, this list is saved.

   The current score file is by default the group's local score file,
even if no such score file actually exists.  To insert score commands
into some other score file (e.g. `all.SCORE'), you must first make this
score file the current one.

   General score commands that don't actually change the score file:

`V s'
     Set the score of the current article (`gnus-summary-set-score').

`V S'
     Display the score of the current article
     (`gnus-summary-current-score').

`V t'
     Display all score rules that have been used on the current article
     (`gnus-score-find-trace').  In the `*Score Trace*' buffer, you may
     type `e' to edit score file corresponding to the score rule on
     current line and `f' to format (`gnus-score-pretty-print') the
     score file and edit it.

`V w'
     List words used in scoring (`gnus-score-find-favourite-words').

`V R'
     Run the current summary through the scoring process
     (`gnus-summary-rescore').  This might be useful if you're playing
     around with your score files behind Gnus' back and want to see the
     effect you're having.

`V c'
     Make a different score file the current
     (`gnus-score-change-score-file').

`V e'
     Edit the current score file (`gnus-score-edit-current-scores').
     You will be popped into a `gnus-score-mode' buffer (*note Score
     File Editing::).

`V f'
     Edit a score file and make this score file the current one
     (`gnus-score-edit-file').

`V F'
     Flush the score cache (`gnus-score-flush-cache').  This is useful
     after editing score files.

`V C'
     Customize a score file in a visually pleasing manner
     (`gnus-score-customize').


   The rest of these commands modify the local score file.

`V m'
     Prompt for a score, and mark all articles with a score below this
     as read (`gnus-score-set-mark-below').

`V x'
     Prompt for a score, and add a score rule to the current score file
     to expunge all articles below this score
     (`gnus-score-set-expunge-below').

   The keystrokes for actually making score entries follow a very
regular pattern, so there's no need to list all the commands.
(Hundreds of them.)

  1. The first key is either `I' (upper case i) for increasing the score
     or `L' for lowering the score.

  2. The second key says what header you want to score on.  The
     following keys are available:
    `a'
          Score on the author name.

    `s'
          Score on the subject line.

    `x'
          Score on the `Xref' line--i.e., the cross-posting line.

    `r'
          Score on the `References' line.

    `d'
          Score on the date.

    `l'
          Score on the number of lines.

    `i'
          Score on the `Message-ID' header.

    `e'
          Score on an "extra" header, that is, one of those in
          gnus-extra-headers, if your NNTP server tracks additional
          header data in overviews.

    `f'
          Score on followups--this matches the author name, and adds
          scores to the followups to this author.  (Using this key
          leads to the creation of `ADAPT' files.)

    `b'
          Score on the body.

    `h'
          Score on the head.

    `t'
          Score on thread.  (Using this key leads to the creation of
          `ADAPT' files.)


  3. The third key is the match type.  Which match types are valid
     depends on what headers you are scoring on.

    `strings'

         `e'
               Exact matching.

         `s'
               Substring matching.

         `f'
               Fuzzy matching (*note Fuzzy Matching::).

         `r'
               Regexp matching

    `date'

         `b'
               Before date.

         `a'
               After date.

         `n'
               This date.

    `number'

         `<'
               Less than number.

         `='
               Equal to number.

         `>'
               Greater than number.

  4. The fourth and usually final key says whether this is a temporary
     (i.e., expiring) score entry, or a permanent (i.e., non-expiring)
     score entry, or whether it is to be done immediately, without
     adding to the score file.
    `t'
          Temporary score entry.

    `p'
          Permanent score entry.

    `i'
          Immediately scoring.

  5. If you are scoring on `e' (extra) headers, you will then be
     prompted for the header name on which you wish to score.  This
     must be a header named in gnus-extra-headers, and `TAB' completion
     is available.


   So, let's say you want to increase the score on the current author
with exact matching permanently: `I a e p'.  If you want to lower the
score based on the subject line, using substring matching, and make a
temporary score entry: `L s s t'.  Pretty easy.

   To make things a bit more complicated, there are shortcuts.  If you
use a capital letter on either the second or third keys, Gnus will use
defaults for the remaining one or two keystrokes.  The defaults are
"substring" and "temporary".  So `I A' is the same as `I a s t', and `I
a R' is the same as `I a r t'.

   These functions take both the numerical prefix and the symbolic
prefix (*note Symbolic Prefixes::).  A numerical prefix says how much
to lower (or increase) the score of the article.  A symbolic prefix of
`a' says to use the `all.SCORE' file for the command instead of the
current score file.

   The `gnus-score-mimic-keymap' says whether these commands will
pretend they are keymaps or not.


File: gnus,  Node: Group Score Commands,  Next: Score Variables,  Prev: Summary Score Commands,  Up: Scoring

7.2 Group Score Commands
========================

There aren't many of these as yet, I'm afraid.

`W e'
     Edit the apply-to-all-groups all.SCORE file.  You will be popped
     into a `gnus-score-mode' buffer (*note Score File Editing::).

`W f'
     Gnus maintains a cache of score alists to avoid having to reload
     them all the time.  This command will flush the cache
     (`gnus-score-flush-cache').


   You can do scoring from the command line by saying something like:

     $ emacs -batch -l ~/.emacs -l ~/.gnus.el -f gnus-batch-score


File: gnus,  Node: Score Variables,  Next: Score File Format,  Prev: Group Score Commands,  Up: Scoring

7.3 Score Variables
===================

`gnus-use-scoring'
     If `nil', Gnus will not check for score files, and will not, in
     general, do any score-related work.  This is `t' by default.

`gnus-kill-killed'
     If this variable is `nil', Gnus will never apply score files to
     articles that have already been through the kill process.  While
     this may save you lots of time, it also means that if you apply a
     kill file to a group, and then change the kill file and want to
     run it over you group again to kill more articles, it won't work.
     You have to set this variable to `t' to do that.  (It is `t' by
     default.)

`gnus-kill-files-directory'
     All kill and score files will be stored in this directory, which is
     initialized from the `SAVEDIR' environment variable by default.
     This is `~/News/' by default.

`gnus-score-file-suffix'
     Suffix to add to the group name to arrive at the score file name
     (`SCORE' by default.)

`gnus-score-uncacheable-files'
     All score files are normally cached to avoid excessive re-loading
     of score files.  However, this might make your Emacs grow big and
     bloated, so this regexp can be used to weed out score files
     unlikely to be needed again.  It would be a bad idea to deny
     caching of `all.SCORE', while it might be a good idea to not cache
     `comp.infosystems.www.authoring.misc.ADAPT'.  In fact, this
     variable is `ADAPT$' by default, so no adaptive score files will
     be cached.

`gnus-save-score'
     If you have really complicated score files, and do lots of batch
     scoring, then you might set this variable to `t'.  This will make
     Gnus save the scores into the `.newsrc.eld' file.

     If you do not set this to `t', then manual scores (like those set
     with `V s' (`gnus-summary-set-score')) will not be preserved
     across group visits.

`gnus-score-interactive-default-score'
     Score used by all the interactive raise/lower commands to
     raise/lower score with.  Default is 1000, which may seem
     excessive, but this is to ensure that the adaptive scoring scheme
     gets enough room to play with.  We don't want the small changes
     from the adaptive scoring to overwrite manually entered data.

`gnus-summary-default-score'
     Default score of an article, which is 0 by default.

`gnus-summary-expunge-below'
     Don't display the summary lines of articles that have scores lower
     than this variable.  This is `nil' by default, which means that no
     articles will be hidden.  This variable is local to the summary
     buffers, and has to be set from `gnus-summary-mode-hook'.

`gnus-score-over-mark'
     Mark (in the third column) used for articles with a score over the
     default.  Default is `+'.

`gnus-score-below-mark'
     Mark (in the third column) used for articles with a score below the
     default.  Default is `-'.

`gnus-score-find-score-files-function'
     Function used to find score files for the current group.  This
     function is called with the name of the group as the argument.

     Predefined functions available are:
    `gnus-score-find-single'
          Only apply the group's own score file.

    `gnus-score-find-bnews'
          Apply all score files that match, using bnews syntax.  This
          is the default.  If the current group is `gnu.emacs.gnus',
          for instance, `all.emacs.all.SCORE', `not.alt.all.SCORE' and
          `gnu.all.SCORE' would all apply.  In short, the instances of
          `all' in the score file names are translated into `.*', and
          then a regexp match is done.

          This means that if you have some score entries that you want
          to apply to all groups, then you put those entries in the
          `all.SCORE' file.

          The score files are applied in a semi-random order, although
          Gnus will try to apply the more general score files before
          the more specific score files.  It does this by looking at
          the number of elements in the score file names--discarding
          the `all' elements.

    `gnus-score-find-hierarchical'
          Apply all score files from all the parent groups.  This means
          that you can't have score files like `all.SCORE', but you can
          have `SCORE', `comp.SCORE' and `comp.emacs.SCORE' for each
          server.

     This variable can also be a list of functions.  In that case, all
     these functions will be called with the group name as argument, and
     all the returned lists of score files will be applied.  These
     functions can also return lists of lists of score alists directly.
     In that case, the functions that return these non-file score alists
     should probably be placed before the "real" score file functions,
     to ensure that the last score file returned is the local score
     file.  Phu.

     For example, to do hierarchical scoring but use a
     non-server-specific overall score file, you could use the value
          (list (lambda (group) ("all.SCORE"))
                'gnus-score-find-hierarchical)

`gnus-score-expiry-days'
     This variable says how many days should pass before an unused
     score file entry is expired.  If this variable is `nil', no score
     file entries are expired.  It's 7 by default.

`gnus-update-score-entry-dates'
     If this variable is non-`nil', temporary score entries that have
     been triggered (matched) will have their dates updated.  (This is
     how Gnus controls expiry--all non-matched-entries will become too
     old while matched entries will stay fresh and young.)  However, if
     you set this variable to `nil', even matched entries will grow old
     and will have to face that oh-so grim reaper.

`gnus-score-after-write-file-function'
     Function called with the name of the score file just written.

`gnus-score-thread-simplify'
     If this variable is non-`nil', article subjects will be simplified
     for subject scoring purposes in the same manner as with
     threading--according to the current value of
     `gnus-simplify-subject-functions'.  If the scoring entry uses
     `substring' or `exact' matching, the match will also be simplified
     in this manner.



File: gnus,  Node: Score File Format,  Next: Score File Editing,  Prev: Score Variables,  Up: Scoring

7.4 Score File Format
=====================

A score file is an `emacs-lisp' file that normally contains just a
single form.  Casual users are not expected to edit these files;
everything can be changed from the summary buffer.

   Anyway, if you'd like to dig into it yourself, here's an example:

     (("from"
       ("Lars Ingebrigtsen" -10000)
       ("Per Abrahamsen")
       ("larsi\\|lmi" -50000 nil R))
      ("subject"
       ("Ding is Badd" nil 728373))
      ("xref"
       ("alt.politics" -1000 728372 s))
      ("lines"
       (2 -100 nil <))
      (mark 0)
      (expunge -1000)
      (mark-and-expunge -10)
      (read-only nil)
      (orphan -10)
      (adapt t)
      (files "/hom/larsi/News/gnu.SCORE")
      (exclude-files "all.SCORE")
      (local (gnus-newsgroup-auto-expire t)
             (gnus-summary-make-false-root empty))
      (eval (ding)))

   This example demonstrates most score file elements.  *Note Advanced
Scoring::, for a different approach.

   Even though this looks much like Lisp code, nothing here is actually
`eval'ed.  The Lisp reader is used to read this form, though, so it has
to be valid syntactically, if not semantically.

   Six keys are supported by this alist:

`STRING'
     If the key is a string, it is the name of the header to perform the
     match on.  Scoring can only be performed on these eight headers:
     `From', `Subject', `References', `Message-ID', `Xref', `Lines',
     `Chars' and `Date'.  In addition to these headers, there are three
     strings to tell Gnus to fetch the entire article and do the match
     on larger parts of the article: `Body' will perform the match on
     the body of the article, `Head' will perform the match on the head
     of the article, and `All' will perform the match on the entire
     article.  Note that using any of these last three keys will slow
     down group entry _considerably_.  The final "header" you can score
     on is `Followup'.  These score entries will result in new score
     entries being added for all follow-ups to articles that matches
     these score entries.

     Following this key is an arbitrary number of score entries, where
     each score entry has one to four elements.
       1. The first element is the "match element".  On most headers
          this will be a string, but on the Lines and Chars headers,
          this must be an integer.

       2. If the second element is present, it should be a number--the
          "score element".  This number should be an integer in the
          neginf to posinf interval.  This number is added to the score
          of the article if the match is successful.  If this element
          is not present, the `gnus-score-interactive-default-score'
          number will be used instead.  This is 1000 by default.

       3. If the third element is present, it should be a number--the
          "date element".  This date says when the last time this score
          entry matched, which provides a mechanism for expiring the
          score entries.  It this element is not present, the score
          entry is permanent.  The date is represented by the number of
          days since December 31, 1 BCE.

       4. If the fourth element is present, it should be a symbol--the
          "type element".  This element specifies what function should
          be used to see whether this score entry matches the article.
          What match types that can be used depends on what header you
          wish to perform the match on.
         "From, Subject, References, Xref, Message-ID"
               For most header types, there are the `r' and `R'
               (regexp), as well as `s' and `S' (substring) types, and
               `e' and `E' (exact match), and `w' (word match) types.
               If this element is not present, Gnus will assume that
               substring matching should be used.  `R', `S', and `E'
               differ from the others in that the matches will be done
               in a case-sensitive manner.  All these one-letter types
               are really just abbreviations for the `regexp',
               `string', `exact', and `word' types, which you can use
               instead, if you feel like.

         "Extra"
               Just as for the standard string overview headers, if you
               are using gnus-extra-headers, you can score on these
               headers' values.  In this case, there is a 5th element
               in the score entry, being the name of the header to be
               scored.  The following entry is useful in your
               `all.SCORE' file in case of spam attacks from a single
               origin host, if your NNTP server tracks
               `NNTP-Posting-Host' in overviews:

                    ("111.222.333.444" -1000 nil s
                     "NNTP-Posting-Host")

         "Lines, Chars"
               These two headers use different match types: `<', `>',
               `=', `>=' and `<='.

               These predicates are true if

                    (PREDICATE HEADER MATCH)

               evaluates to non-`nil'.  For instance, the advanced match
               `("lines" 4 <)' (*note Advanced Scoring::) will result
               in the following form:

                    (< header-value 4)

               Or to put it another way: When using `<' on `Lines' with
               4 as the match, we get the score added if the article
               has less than 4 lines.  (It's easy to get confused and
               think it's the other way around.  But it's not.  I
               think.)

               When matching on `Lines', be careful because some back
               ends (like `nndir') do not generate `Lines' header, so
               every article ends up being marked as having 0 lines.
               This can lead to strange results if you happen to lower
               score of the articles with few lines.

         "Date"
               For the Date header we have three kinda silly match
               types: `before', `at' and `after'.  I can't really
               imagine this ever being useful, but, like, it would feel
               kinda silly not to provide this function.  Just in case.
               You never know.  Better safe than sorry.  Once burnt,
               twice shy.  Don't judge a book by its cover.  Never not
               have sex on a first date.  (I have been told that at
               least one person, and I quote, "found this function
               indispensable", however.)

               A more useful match type is `regexp'.  With it, you can
               match the date string using a regular expression.  The
               date is normalized to ISO8601 compact format
               first--YYYYMMDD`T'HHMMSS.  If you want to match all
               articles that have been posted on April 1st in every
               year, you could use `....0401.........' as a match
               string, for instance.  (Note that the date is kept in
               its original time zone, so this will match articles that
               were posted when it was April 1st where the article was
               posted from.  Time zones are such wholesome fun for the
               whole family, eh?)

         "Head, Body, All"
               These three match keys use the same match types as the
               `From' (etc) header uses.

         "Followup"
               This match key is somewhat special, in that it will
               match the `From' header, and affect the score of not
               only the matching articles, but also all followups to
               the matching articles.  This allows you e.g. increase
               the score of followups to your own articles, or decrease
               the score of followups to the articles of some known
               trouble-maker.  Uses the same match types as the `From'
               header uses.  (Using this match key will lead to
               creation of `ADAPT' files.)

         "Thread"
               This match key works along the same lines as the
               `Followup' match key.  If you say that you want to score
               on a (sub-)thread started by an article with a
               `Message-ID' X, then you add a `thread' match.  This
               will add a new `thread' match for each article that has
               X in its `References' header.  (These new `thread'
               matches will use the `Message-ID's of these matching
               articles.)  This will ensure that you can raise/lower
               the score of an entire thread, even though some articles
               in the thread may not have complete `References'
               headers.  Note that using this may lead to
               undeterministic scores of the articles in the thread.
               (Using this match key will lead to creation of `ADAPT'
               files.)

`mark'
     The value of this entry should be a number.  Any articles with a
     score lower than this number will be marked as read.

`expunge'
     The value of this entry should be a number.  Any articles with a
     score lower than this number will be removed from the summary
     buffer.

`mark-and-expunge'
     The value of this entry should be a number.  Any articles with a
     score lower than this number will be marked as read and removed
     from the summary buffer.

`thread-mark-and-expunge'
     The value of this entry should be a number.  All articles that
     belong to a thread that has a total score below this number will
     be marked as read and removed from the summary buffer.
     `gnus-thread-score-function' says how to compute the total score
     for a thread.

`files'
     The value of this entry should be any number of file names.  These
     files are assumed to be score files as well, and will be loaded
     the same way this one was.

`exclude-files'
     The clue of this entry should be any number of files.  These files
     will not be loaded, even though they would normally be so, for
     some reason or other.

`eval'
     The value of this entry will be `eval'ed.  This element will be
     ignored when handling global score files.

`read-only'
     Read-only score files will not be updated or saved.  Global score
     files should feature this atom (*note Global Score Files::).
     (Note: "Global" here really means "global"; not your personal
     apply-to-all-groups score files.)

`orphan'
     The value of this entry should be a number.  Articles that do not
     have parents will get this number added to their scores.  Imagine
     you follow some high-volume newsgroup, like `comp.lang.c'.  Most
     likely you will only follow a few of the threads, also want to see
     any new threads.

     You can do this with the following two score file entries:

                  (orphan -500)
                  (mark-and-expunge -100)

     When you enter the group the first time, you will only see the new
     threads.  You then raise the score of the threads that you find
     interesting (with `I T' or `I S'), and ignore (`c y') the rest.
     Next time you enter the group, you will see new articles in the
     interesting threads, plus any new threads.

     I.e.--the orphan score atom is for high-volume groups where a few
     interesting threads which can't be found automatically by ordinary
     scoring rules exist.

`adapt'
     This entry controls the adaptive scoring.  If it is `t', the
     default adaptive scoring rules will be used.  If it is `ignore', no
     adaptive scoring will be performed on this group.  If it is a
     list, this list will be used as the adaptive scoring rules.  If it
     isn't present, or is something other than `t' or `ignore', the
     default adaptive scoring rules will be used.  If you want to use
     adaptive scoring on most groups, you'd set
     `gnus-use-adaptive-scoring' to `t', and insert an `(adapt ignore)'
     in the groups where you do not want adaptive scoring.  If you only
     want adaptive scoring in a few groups, you'd set
     `gnus-use-adaptive-scoring' to `nil', and insert `(adapt t)' in
     the score files of the groups where you want it.

`adapt-file'
     All adaptive score entries will go to the file named by this
     entry.  It will also be applied when entering the group.  This
     atom might be handy if you want to adapt on several groups at
     once, using the same adaptive file for a number of groups.

`local'
     The value of this entry should be a list of `(VAR VALUE)' pairs.
     Each VAR will be made buffer-local to the current summary buffer,
     and set to the value specified.  This is a convenient, if somewhat
     strange, way of setting variables in some groups if you don't like
     hooks much.  Note that the VALUE won't be evaluated.


File: gnus,  Node: Score File Editing,  Next: Adaptive Scoring,  Prev: Score File Format,  Up: Scoring

7.5 Score File Editing
======================

You normally enter all scoring commands from the summary buffer, but you
might feel the urge to edit them by hand as well, so we've supplied you
with a mode for that.

   It's simply a slightly customized `emacs-lisp' mode, with these
additional commands:

`C-c C-c'
     Save the changes you have made and return to the summary buffer
     (`gnus-score-edit-exit').

`C-c C-d'
     Insert the current date in numerical format
     (`gnus-score-edit-insert-date').  This is really the day number, if
     you were wondering.

`C-c C-p'
     The adaptive score files are saved in an unformatted fashion.  If
     you intend to read one of these files, you want to "pretty print"
     it first.  This command (`gnus-score-pretty-print') does that for
     you.


   Type `M-x gnus-score-mode' to use this mode.

   `gnus-score-menu-hook' is run in score mode buffers.

   In the summary buffer you can use commands like `V f', `V e' and `V
t' to begin editing score files.


File: gnus,  Node: Adaptive Scoring,  Next: Home Score File,  Prev: Score File Editing,  Up: Scoring

7.6 Adaptive Scoring
====================

If all this scoring is getting you down, Gnus has a way of making it all
happen automatically--as if by magic.  Or rather, as if by artificial
stupidity, to be precise.

   When you read an article, or mark an article as read, or kill an
article, you leave marks behind.  On exit from the group, Gnus can sniff
these marks and add score elements depending on what marks it finds.
You turn on this ability by setting `gnus-use-adaptive-scoring' to `t'
or `(line)'.  If you want score adaptively on separate words appearing
in the subjects, you should set this variable to `(word)'.  If you want
to use both adaptive methods, set this variable to `(word line)'.

   To give you complete control over the scoring process, you can
customize the `gnus-default-adaptive-score-alist' variable.  For
instance, it might look something like this:

     (setq gnus-default-adaptive-score-alist
       '((gnus-unread-mark)
         (gnus-ticked-mark (from 4))
         (gnus-dormant-mark (from 5))
         (gnus-del-mark (from -4) (subject -1))
         (gnus-read-mark (from 4) (subject 2))
         (gnus-expirable-mark (from -1) (subject -1))
         (gnus-killed-mark (from -1) (subject -3))
         (gnus-kill-file-mark)
         (gnus-ancient-mark)
         (gnus-low-score-mark)
         (gnus-catchup-mark (from -1) (subject -1))))

   As you see, each element in this alist has a mark as a key (either a
variable name or a "real" mark--a character).  Following this key is a
arbitrary number of header/score pairs.  If there are no header/score
pairs following the key, no adaptive scoring will be done on articles
that have that key as the article mark.  For instance, articles with
`gnus-unread-mark' in the example above will not get adaptive score
entries.

   Each article can have only one mark, so just a single of these rules
will be applied to each article.

   To take `gnus-del-mark' as an example--this alist says that all
articles that have that mark (i.e., are marked with `e') will have a
score entry added to lower based on the `From' header by -4, and
lowered by `Subject' by -1.  Change this to fit your prejudices.

   If you have marked 10 articles with the same subject with
`gnus-del-mark', the rule for that mark will be applied ten times.
That means that that subject will get a score of ten times -1, which
should be, unless I'm much mistaken, -10.

   If you have auto-expirable (mail) groups (*note Expiring Mail::), all
the read articles will be marked with the `E' mark.  This'll probably
make adaptive scoring slightly impossible, so auto-expiring and
adaptive scoring doesn't really mix very well.

   The headers you can score on are `from', `subject', `message-id',
`references', `xref', `lines', `chars' and `date'.  In addition, you
can score on `followup', which will create an adaptive score entry that
matches on the `References' header using the `Message-ID' of the
current article, thereby matching the following thread.

   If you use this scheme, you should set the score file atom `mark' to
something small--like -300, perhaps, to avoid having small random
changes result in articles getting marked as read.

   After using adaptive scoring for a week or so, Gnus should start to
become properly trained and enhance the authors you like best, and kill
the authors you like least, without you having to say so explicitly.

   You can control what groups the adaptive scoring is to be performed
on by using the score files (*note Score File Format::).  This will also
let you use different rules in different groups.

   The adaptive score entries will be put into a file where the name is
the group name with `gnus-adaptive-file-suffix' appended.  The default
is `ADAPT'.

   Adaptive score files can get huge and are not meant to be edited by
human hands.  If `gnus-adaptive-pretty-print' is `nil' (the deafult)
those files will not be written in a human readable way.

   When doing adaptive scoring, substring or fuzzy matching would
probably give you the best results in most cases.  However, if the
header one matches is short, the possibility for false positives is
great, so if the length of the match is less than
`gnus-score-exact-adapt-limit', exact matching will be used.  If this
variable is `nil', exact matching will always be used to avoid this
problem.

   As mentioned above, you can adapt either on individual words or
entire headers.  If you adapt on words, the
`gnus-default-adaptive-word-score-alist' variable says what score each
instance of a word should add given a mark.

     (setq gnus-default-adaptive-word-score-alist
           `((,gnus-read-mark . 30)
             (,gnus-catchup-mark . -10)
             (,gnus-killed-mark . -20)
             (,gnus-del-mark . -15)))

   This is the default value.  If you have adaption on words enabled,
every word that appears in subjects of articles marked with
`gnus-read-mark' will result in a score rule that increase the score
with 30 points.

   Words that appear in the `gnus-default-ignored-adaptive-words' list
will be ignored.  If you wish to add more words to be ignored, use the
`gnus-ignored-adaptive-words' list instead.

   Some may feel that short words shouldn't count when doing adaptive
scoring.  If so, you may set `gnus-adaptive-word-length-limit' to an
integer.  Words shorter than this number will be ignored.  This
variable defaults to `nil'.

   When the scoring is done, `gnus-adaptive-word-syntax-table' is the
syntax table in effect.  It is similar to the standard syntax table, but
it considers numbers to be non-word-constituent characters.

   If `gnus-adaptive-word-minimum' is set to a number, the adaptive
word scoring process will never bring down the score of an article to
below this number.  The default is `nil'.

   If `gnus-adaptive-word-no-group-words' is set to `t', gnus won't
adaptively word score any of the words in the group name.  Useful for
groups like `comp.editors.emacs', where most of the subject lines
contain the word `emacs'.

   After using this scheme for a while, it might be nice to write a
`gnus-psychoanalyze-user' command to go through the rules and see what
words you like and what words you don't like.  Or perhaps not.

   Note that the adaptive word scoring thing is highly experimental and
is likely to change in the future.  Initial impressions seem to indicate
that it's totally useless as it stands.  Some more work (involving more
rigorous statistical methods) will have to be done to make this useful.


File: gnus,  Node: Home Score File,  Next: Followups To Yourself,  Prev: Adaptive Scoring,  Up: Scoring

7.7 Home Score File
===================

The score file where new score file entries will go is called the "home
score file".  This is normally (and by default) the score file for the
group itself.  For instance, the home score file for `gnu.emacs.gnus'
is `gnu.emacs.gnus.SCORE'.

   However, this may not be what you want.  It is often convenient to
share a common home score file among many groups--all `emacs' groups
could perhaps use the same home score file.

   The variable that controls this is `gnus-home-score-file'.  It can
be:

  1. A string.  Then this file will be used as the home score file for
     all groups.

  2. A function.  The result of this function will be used as the home
     score file.  The function will be called with the name of the
     group as the parameter.

  3. A list.  The elements in this list can be:

       1. `(REGEXP FILE-NAME)'.  If the REGEXP matches the group name,
          the FILE-NAME will be used as the home score file.

       2. A function.  If the function returns non-`nil', the result
          will be used as the home score file.  The function will be
          called with the name of the group as the parameter.

       3. A string.  Use the string as the home score file.

     The list will be traversed from the beginning towards the end
     looking for matches.


   So, if you want to use just a single score file, you could say:

     (setq gnus-home-score-file
           "my-total-score-file.SCORE")

   If you want to use `gnu.SCORE' for all `gnu' groups and `rec.SCORE'
for all `rec' groups (and so on), you can say:

     (setq gnus-home-score-file
           'gnus-hierarchial-home-score-file)

   This is a ready-made function provided for your convenience.  Other
functions include

`gnus-current-home-score-file'
     Return the "current" regular score file.  This will make scoring
     commands add entry to the "innermost" matching score file.


   If you want to have one score file for the `emacs' groups and
another for the `comp' groups, while letting all other groups use their
own home score files:

     (setq gnus-home-score-file
           ;; All groups that match the regexp `"\\.emacs"'
           '(("\\.emacs" "emacs.SCORE")
             ;; All the comp groups in one score file
             ("^comp" "comp.SCORE")))

   `gnus-home-adapt-file' works exactly the same way as
`gnus-home-score-file', but says what the home adaptive score file is
instead.  All new adaptive file entries will go into the file specified
by this variable, and the same syntax is allowed.

   In addition to using `gnus-home-score-file' and
`gnus-home-adapt-file', you can also use group parameters (*note Group
Parameters::) and topic parameters (*note Topic Parameters::) to
achieve much the same.  Group and topic parameters take precedence over
this variable.


File: gnus,  Node: Followups To Yourself,  Next: Scoring On Other Headers,  Prev: Home Score File,  Up: Scoring

7.8 Followups To Yourself
=========================

Gnus offers two commands for picking out the `Message-ID' header in the
current buffer.  Gnus will then add a score rule that scores using this
`Message-ID' on the `References' header of other articles.  This will,
in effect, increase the score of all articles that respond to the
article in the current buffer.  Quite useful if you want to easily note
when people answer what you've said.

`gnus-score-followup-article'
     This will add a score to articles that directly follow up your own
     article.

`gnus-score-followup-thread'
     This will add a score to all articles that appear in a thread
     "below" your own article.

   These two functions are both primarily meant to be used in hooks like
`message-sent-hook', like this:
     (add-hook 'message-sent-hook 'gnus-score-followup-thread)

   If you look closely at your own `Message-ID', you'll notice that the
first two or three characters are always the same.  Here's two of mine:

     <x6u3u47icf.fsf@eyesore.no>
     <x6sp9o7ibw.fsf@eyesore.no>

   So "my" ident on this machine is `x6'.  This can be exploited--the
following rule will raise the score on all followups to myself:

     ("references"
      ("<x6[0-9a-z]+\\.fsf\\(_-_\\)?@.*eyesore\\.no>"
       1000 nil r))

   Whether it's the first two or first three characters that are "yours"
is system-dependent.


File: gnus,  Node: Scoring On Other Headers,  Next: Scoring Tips,  Prev: Followups To Yourself,  Up: Scoring

7.9 Scoring On Other Headers
============================

Gnus is quite fast when scoring the "traditional" headers--`From',
`Subject' and so on.  However, scoring other headers requires writing a
`head' scoring rule, which means that Gnus has to request every single
article from the back end to find matches.  This takes a long time in
big groups.

   You can inhibit this slow scoring on headers or body by setting the
variable `gnus-inhibit-slow-scoring'.  If `gnus-inhibit-slow-scoring'
is regexp, slow scoring is inhibited if the group matches the regexp.
If it is t, slow scoring on it is inhibited for all groups.

   Now, there's not much you can do about the slowness for news groups,
but for mail groups, you have greater control.  In *note To From
Newsgroups::, it's explained in greater detail what this mechanism
does, but here's a cookbook example for `nnml' on how to allow scoring
on the `To' and `Cc' headers.

   Put the following in your `~/.gnus.el' file.

     (setq gnus-extra-headers '(To Cc Newsgroups Keywords)
           nnmail-extra-headers gnus-extra-headers)

   Restart Gnus and rebuild your `nnml' overview files with the `M-x
nnml-generate-nov-databases' command.  This will take a long time if
you have much mail.

   Now you can score on `To' and `Cc' as "extra headers" like so: `I e
s p To RET <your name> RET'.

   See?  Simple.


File: gnus,  Node: Scoring Tips,  Next: Reverse Scoring,  Prev: Scoring On Other Headers,  Up: Scoring

7.10 Scoring Tips
=================

"Crossposts"
     If you want to lower the score of crossposts, the line to match on
     is the `Xref' header.
          ("xref" (" talk.politics.misc:" -1000))

"Multiple crossposts"
     If you want to lower the score of articles that have been
     crossposted to more than, say, 3 groups:
          ("xref"
            ("[^:\n]+:[0-9]+ +[^:\n]+:[0-9]+ +[^:\n]+:[0-9]+"
             -1000 nil r))

"Matching on the body"
     This is generally not a very good idea--it takes a very long time.
     Gnus actually has to fetch each individual article from the
     server.  But you might want to anyway, I guess.  Even though there
     are three match keys (`Head', `Body' and `All'), you should choose
     one and stick with it in each score file.  If you use any two,
     each article will be fetched _twice_.  If you want to match a bit
     on the `Head' and a bit on the `Body', just use `All' for all the
     matches.

"Marking as read"
     You will probably want to mark articles that have scores below a
     certain number as read.  This is most easily achieved by putting
     the following in your `all.SCORE' file:
          ((mark -100))
     You may also consider doing something similar with `expunge'.

"Negated character classes"
     If you say stuff like `[^abcd]*', you may get unexpected results.
     That will match newlines, which might lead to, well, The Unknown.
     Say `[^abcd\n]*' instead.


File: gnus,  Node: Reverse Scoring,  Next: Global Score Files,  Prev: Scoring Tips,  Up: Scoring

7.11 Reverse Scoring
====================

If you want to keep just articles that have `Sex with Emacs' in the
subject header, and expunge all other articles, you could put something
like this in your score file:

     (("subject"
       ("Sex with Emacs" 2))
      (mark 1)
      (expunge 1))

   So, you raise all articles that match `Sex with Emacs' and mark the
rest as read, and expunge them to boot.


File: gnus,  Node: Global Score Files,  Next: Kill Files,  Prev: Reverse Scoring,  Up: Scoring

7.12 Global Score Files
=======================

Sure, other newsreaders have "global kill files".  These are usually
nothing more than a single kill file that applies to all groups, stored
in the user's home directory.  Bah!  Puny, weak newsreaders!

   What I'm talking about here are Global Score Files.  Score files from
all over the world, from users everywhere, uniting all nations in one
big, happy score file union!  Ange-score!  New and untested!

   All you have to do to use other people's score files is to set the
`gnus-global-score-files' variable.  One entry for each score file, or
each score file directory.  Gnus will decide by itself what score files
are applicable to which group.

   To use the score file
`/ftp@ftp.gnus.org:/pub/larsi/ding/score/soc.motss.SCORE' and all score
files in the `/ftp@ftp.some-where:/pub/score' directory, say this:

     (setq gnus-global-score-files
           '("/ftp@ftp.gnus.org:/pub/larsi/ding/score/soc.motss.SCORE"
             "/ftp@ftp.some-where:/pub/score/"))

Simple, eh?  Directory names must end with a `/'.  These directories
are typically scanned only once during each Gnus session.  If you feel
the need to manually re-scan the remote directories, you can use the
`gnus-score-search-global-directories' command.

   Note that, at present, using this option will slow down group entry
somewhat.  (That is--a lot.)

   If you want to start maintaining score files for other people to use,
just put your score file up for anonymous ftp and announce it to the
world.  Become a retro-moderator!  Participate in the retro-moderator
wars sure to ensue, where retro-moderators battle it out for the
sympathy of the people, luring them to use their score files on false
premises!  Yay!  The net is saved!

   Here are some tips for the would-be retro-moderator, off the top of
my head:

   * Articles heavily crossposted are probably junk.

   * To lower a single inappropriate article, lower by `Message-ID'.

   * Particularly brilliant authors can be raised on a permanent basis.

   * Authors that repeatedly post off-charter for the group can safely
     be lowered out of existence.

   * Set the `mark' and `expunge' atoms to obliterate the nastiest
     articles completely.

   * Use expiring score entries to keep the size of the file down.  You
     should probably have a long expiry period, though, as some sites
     keep old articles for a long time.

   ... I wonder whether other newsreaders will support global score
files in the future.  _Snicker_.  Yup, any day now, newsreaders like
Blue Wave, xrn and 1stReader are bound to implement scoring.  Should we
start holding our breath yet?


File: gnus,  Node: Kill Files,  Next: Converting Kill Files,  Prev: Global Score Files,  Up: Scoring

7.13 Kill Files
===============

Gnus still supports those pesky old kill files.  In fact, the kill file
entries can now be expiring, which is something I wrote before Daniel
Quinlan thought of doing score files, so I've left the code in there.

   In short, kill processing is a lot slower (and I do mean _a lot_)
than score processing, so it might be a good idea to rewrite your kill
files into score files.

   Anyway, a kill file is a normal `emacs-lisp' file.  You can put any
forms into this file, which means that you can use kill files as some
sort of primitive hook function to be run on group entry, even though
that isn't a very good idea.

   Normal kill files look like this:

     (gnus-kill "From" "Lars Ingebrigtsen")
     (gnus-kill "Subject" "ding")
     (gnus-expunge "X")

   This will mark every article written by me as read, and remove the
marked articles from the summary buffer.  Very useful, you'll agree.

   Other programs use a totally different kill file syntax.  If Gnus
encounters what looks like a `rn' kill file, it will take a stab at
interpreting it.

   Two summary functions for editing a GNUS kill file:

`M-k'
     Edit this group's kill file (`gnus-summary-edit-local-kill').

`M-K'
     Edit the general kill file (`gnus-summary-edit-global-kill').

   Two group mode functions for editing the kill files:

`M-k'
     Edit this group's kill file (`gnus-group-edit-local-kill').

`M-K'
     Edit the general kill file (`gnus-group-edit-global-kill').

   Kill file variables:

`gnus-kill-file-name'
     A kill file for the group `soc.motss' is normally called
     `soc.motss.KILL'.  The suffix appended to the group name to get
     this file name is detailed by the `gnus-kill-file-name' variable.
     The "global" kill file (not in the score file sense of "global", of
     course) is just called `KILL'.

`gnus-kill-save-kill-file'
     If this variable is non-`nil', Gnus will save the kill file after
     processing, which is necessary if you use expiring kills.

`gnus-apply-kill-hook'
     A hook called to apply kill files to a group.  It is
     `(gnus-apply-kill-file)' by default.  If you want to ignore the
     kill file if you have a score file for the same group, you can set
     this hook to `(gnus-apply-kill-file-unless-scored)'.  If you don't
     want kill files to be processed, you should set this variable to
     `nil'.

`gnus-kill-file-mode-hook'
     A hook called in kill-file mode buffers.



File: gnus,  Node: Converting Kill Files,  Next: Advanced Scoring,  Prev: Kill Files,  Up: Scoring

7.14 Converting Kill Files
==========================

If you have loads of old kill files, you may want to convert them into
score files.  If they are "regular", you can use the
`gnus-kill-to-score.el' package; if not, you'll have to do it by hand.

   The kill to score conversion package isn't included in Emacs by
default.  You can fetch it from the contrib directory of the Gnus
distribution or from
`http://heim.ifi.uio.no/~larsi/ding-various/gnus-kill-to-score.el'.

   If your old kill files are very complex--if they contain more
non-`gnus-kill' forms than not, you'll have to convert them by hand.
Or just let them be as they are.  Gnus will still use them as before.


File: gnus,  Node: Advanced Scoring,  Next: Score Decays,  Prev: Converting Kill Files,  Up: Scoring

7.15 Advanced Scoring
=====================

Scoring on Subjects and From headers is nice enough, but what if you're
really interested in what a person has to say only when she's talking
about a particular subject?  Or what if you really don't want to read
what person A has to say when she's following up to person B, but want
to read what she says when she's following up to person C?

   By using advanced scoring rules you may create arbitrarily complex
scoring patterns.

* Menu:

* Advanced Scoring Syntax::     A definition.
* Advanced Scoring Examples::   What they look like.
* Advanced Scoring Tips::       Getting the most out of it.


File: gnus,  Node: Advanced Scoring Syntax,  Next: Advanced Scoring Examples,  Up: Advanced Scoring

7.15.1 Advanced Scoring Syntax
------------------------------

Ordinary scoring rules have a string as the first element in the rule.
Advanced scoring rules have a list as the first element.  The second
element is the score to be applied if the first element evaluated to a
non-`nil' value.

   These lists may consist of three logical operators, one redirection
operator, and various match operators.

   Logical operators:

`&'
`and'
     This logical operator will evaluate each of its arguments until it
     finds one that evaluates to `false', and then it'll stop.  If all
     arguments evaluate to `true' values, then this operator will return
     `true'.

`|'
`or'
     This logical operator will evaluate each of its arguments until it
     finds one that evaluates to `true'.  If no arguments are `true',
     then this operator will return `false'.

`!'
`not'
`'
     This logical operator only takes a single argument.  It returns the
     logical negation of the value of its argument.


   There is an "indirection operator" that will make its arguments
apply to the ancestors of the current article being scored.  For
instance, `1-' will make score rules apply to the parent of the current
article.  `2-' will make score rules apply to the grandparent of the
current article.  Alternatively, you can write `^^', where the number
of `^'s (carets) says how far back into the ancestry you want to go.

   Finally, we have the match operators.  These are the ones that do the
real work.  Match operators are header name strings followed by a match
and a match type.  A typical match operator looks like `("from" "Lars
Ingebrigtsen" s)'.  The header names are the same as when using simple
scoring, and the match types are also the same.


File: gnus,  Node: Advanced Scoring Examples,  Next: Advanced Scoring Tips,  Prev: Advanced Scoring Syntax,  Up: Advanced Scoring

7.15.2 Advanced Scoring Examples
--------------------------------

Please note that the following examples are score file rules.  To make
a complete score file from them, surround them with another pair of
parentheses.

   Let's say you want to increase the score of articles written by Lars
when he's talking about Gnus:

     ((&
       ("from" "Lars Ingebrigtsen")
       ("subject" "Gnus"))
      1000)

   Quite simple, huh?

   When he writes long articles, he sometimes has something nice to say:

     ((&
       ("from" "Lars Ingebrigtsen")
       (|
        ("subject" "Gnus")
        ("lines" 100 >)))
      1000)

   However, when he responds to things written by Reig Eigil Logge, you
really don't want to read what he's written:

     ((&
       ("from" "Lars Ingebrigtsen")
       (1- ("from" "Reig Eigil Logge")))
      -100000)

   Everybody that follows up Redmondo when he writes about disappearing
socks should have their scores raised, but only when they talk about
white socks.  However, when Lars talks about socks, it's usually not
very interesting:

     ((&
       (1-
        (&
         ("from" "redmondo@.*no" r)
         ("body" "disappearing.*socks" t)))
       (! ("from" "Lars Ingebrigtsen"))
       ("body" "white.*socks"))
      1000)

   Suppose you're reading a high volume group and you're only interested
in replies. The plan is to score down all articles that don't have
subject that begin with "Re:", "Fw:" or "Fwd:" and then score up all
parents of articles that have subjects that begin with reply marks.

     ((! ("subject" "re:\\|fwd?:" r))
       -200)
     ((1- ("subject" "re:\\|fwd?:" r))
       200)

   The possibilities are endless.


File: gnus,  Node: Advanced Scoring Tips,  Prev: Advanced Scoring Examples,  Up: Advanced Scoring

7.15.3 Advanced Scoring Tips
----------------------------

The `&' and `|' logical operators do short-circuit logic.  That is,
they stop processing their arguments when it's clear what the result of
the operation will be.  For instance, if one of the arguments of an `&'
evaluates to `false', there's no point in evaluating the rest of the
arguments.  This means that you should put slow matches (`body',
`header') last and quick matches (`from', `subject') first.

   The indirection arguments (`1-' and so on) will make their arguments
work on previous generations of the thread.  If you say something like:

     ...
     (1-
      (1-
       ("from" "lars")))
     ...

   Then that means "score on the from header of the grandparent of the
current article".  An indirection is quite fast, but it's better to say:

     (1-
      (&
       ("from" "Lars")
       ("subject" "Gnus")))

   than it is to say:

     (&
      (1- ("from" "Lars"))
      (1- ("subject" "Gnus")))


File: gnus,  Node: Score Decays,  Prev: Advanced Scoring,  Up: Scoring

7.16 Score Decays
=================

You may find that your scores have a tendency to grow without bounds,
especially if you're using adaptive scoring.  If scores get too big,
they lose all meaning--they simply max out and it's difficult to use
them in any sensible way.

   Gnus provides a mechanism for decaying scores to help with this
problem.  When score files are loaded and `gnus-decay-scores' is
non-`nil', Gnus will run the score files through the decaying mechanism
thereby lowering the scores of all non-permanent score rules.  If
`gnus-decay-scores' is a regexp, only score files matching this regexp
are treated.  E.g. you may set it to `\\.ADAPT\\'' if only _adaptive_
score files should be decayed.  The decay itself if performed by the
`gnus-decay-score-function' function, which is `gnus-decay-score' by
default.  Here's the definition of that function:

     (defun gnus-decay-score (score)
       "Decay SCORE according to `gnus-score-decay-constant'
     and `gnus-score-decay-scale'."
       (let ((n (- score
                   (* (if (< score 0) -1 1)
                      (min (abs score)
                           (max gnus-score-decay-constant
                                (* (abs score)
                                   gnus-score-decay-scale)))))))
         (if (and (featurep 'xemacs)
                  ;; XEmacs' floor can handle only the floating point
                  ;; number below the half of the maximum integer.
                  (> (abs n) (lsh -1 -2)))
             (string-to-number
              (car (split-string (number-to-string n) "\\.")))
           (floor n))))

   `gnus-score-decay-constant' is 3 by default and
`gnus-score-decay-scale' is 0.05.  This should cause the following:

  1. Scores between -3 and 3 will be set to 0 when this function is
     called.

  2. Scores with magnitudes between 3 and 60 will be shrunk by 3.

  3. Scores with magnitudes greater than 60 will be shrunk by 5% of the
     score.

   If you don't like this decay function, write your own.  It is called
with the score to be decayed as its only parameter, and it should return
the new score, which should be an integer.

   Gnus will try to decay scores once a day.  If you haven't run Gnus
for four days, Gnus will decay the scores four times, for instance.


File: gnus,  Node: Various,  Next: The End,  Prev: Scoring,  Up: Top

8 Various
*********

* Menu:

* Process/Prefix::              A convention used by many treatment commands.
* Interactive::                 Making Gnus ask you many questions.
* Symbolic Prefixes::           How to supply some Gnus functions with options.
* Formatting Variables::        You can specify what buffers should look like.
* Window Layout::               Configuring the Gnus buffer windows.
* Faces and Fonts::             How to change how faces look.
* Compilation::                 How to speed Gnus up.
* Mode Lines::                  Displaying information in the mode lines.
* Highlighting and Menus::      Making buffers look all nice and cozy.
* Buttons::                     Get tendinitis in ten easy steps!
* Daemons::                     Gnus can do things behind your back.
* NoCeM::                       How to avoid spam and other fatty foods.
* Undo::                        Some actions can be undone.
* Predicate Specifiers::        Specifying predicates.
* Moderation::                  What to do if you're a moderator.
* Fetching a Group::            Starting Gnus just to read a group.
* Image Enhancements::          Modern versions of Emacs/XEmacs can display images.
* Fuzzy Matching::              What's the big fuzz?
* Thwarting Email Spam::        Simple ways to avoid unsolicited commercial email.
* Spam Package::                A package for filtering and processing spam.
* The Gnus Registry::           A package for tracking messages by Message-ID.
* Other modes::                 Interaction with other modes.
* Various Various::             Things that are really various.


File: gnus,  Node: Process/Prefix,  Next: Interactive,  Up: Various

8.1 Process/Prefix
==================

Many functions, among them functions for moving, decoding and saving
articles, use what is known as the "Process/Prefix convention".

   This is a method for figuring out what articles the user wants the
command to be performed on.

   It goes like this:

   If the numeric prefix is N, perform the operation on the next N
articles, starting with the current one.  If the numeric prefix is
negative, perform the operation on the previous N articles, starting
with the current one.

   If `transient-mark-mode' in non-`nil' and the region is active, all
articles in the region will be worked upon.

   If there is no numeric prefix, but some articles are marked with the
process mark, perform the operation on the articles marked with the
process mark.

   If there is neither a numeric prefix nor any articles marked with the
process mark, just perform the operation on the current article.

   Quite simple, really, but it needs to be made clear so that surprises
are avoided.

   Commands that react to the process mark will push the current list of
process marked articles onto a stack and will then clear all process
marked articles.  You can restore the previous configuration with the
`M P y' command (*note Setting Process Marks::).

   One thing that seems to shock & horrify lots of people is that, for
instance, `3 d' does exactly the same as `d' `d' `d'.  Since each `d'
(which marks the current article as read) by default goes to the next
unread article after marking, this means that `3 d' will mark the next
three unread articles as read, no matter what the summary buffer looks
like.  Set `gnus-summary-goto-unread' to `nil' for a more
straightforward action.

   Many commands do not use the process/prefix convention.  All commands
that do explicitly say so in this manual.  To apply the process/prefix
convention to commands that do not use it, you can use the `M-&'
command.  For instance, to mark all the articles in the group as
expirable, you could say `M P b M-& E'.


File: gnus,  Node: Interactive,  Next: Symbolic Prefixes,  Prev: Process/Prefix,  Up: Various

8.2 Interactive
===============

`gnus-novice-user'
     If this variable is non-`nil', you are either a newcomer to the
     World of Usenet, or you are very cautious, which is a nice thing
     to be, really.  You will be given questions of the type "Are you
     sure you want to do this?" before doing anything dangerous.  This
     is `t' by default.

`gnus-expert-user'
     If this variable is non-`nil', you will seldom be asked any
     questions by Gnus.  It will simply assume you know what you're
     doing, no matter how strange.

`gnus-interactive-catchup'
     Require confirmation before catching up a group if non-`nil'.  It
     is `t' by default.

`gnus-interactive-exit'
     Require confirmation before exiting Gnus.  This variable is `t' by
     default.


File: gnus,  Node: Symbolic Prefixes,  Next: Formatting Variables,  Prev: Interactive,  Up: Various

8.3 Symbolic Prefixes
=====================

Quite a lot of Emacs commands react to the (numeric) prefix.  For
instance, `C-u 4 C-f' moves point four characters forward, and `C-u 9 0
0 I s s p' adds a permanent `Subject' substring score rule of 900 to
the current article.

   This is all nice and well, but what if you want to give a command
some additional information?  Well, what most commands do is interpret
the "raw" prefix in some special way.  `C-u 0 C-x C-s' means that one
doesn't want a backup file to be created when saving the current buffer,
for instance.  But what if you want to save without making a backup
file, and you want Emacs to flash lights and play a nice tune at the
same time?  You can't, and you're probably perfectly happy that way.

   I'm not, so I've added a second prefix--the "symbolic prefix".  The
prefix key is `M-i' (`gnus-symbolic-argument'), and the next character
typed in is the value.  You can stack as many `M-i' prefixes as you
want.  `M-i a C-M-u' means "feed the `C-M-u' command the symbolic
prefix `a'".  `M-i a M-i b C-M-u' means "feed the `C-M-u' command the
symbolic prefixes `a' and `b'".  You get the drift.

   Typing in symbolic prefixes to commands that don't accept them
doesn't hurt, but it doesn't do any good either.  Currently not many
Gnus functions make use of the symbolic prefix.

   If you're interested in how Gnus implements this, *note Extended
Interactive::.


File: gnus,  Node: Formatting Variables,  Next: Window Layout,  Prev: Symbolic Prefixes,  Up: Various

8.4 Formatting Variables
========================

Throughout this manual you've probably noticed lots of variables called
things like `gnus-group-line-format' and
`gnus-summary-mode-line-format'.  These control how Gnus is to output
lines in the various buffers.  There's quite a lot of them.
Fortunately, they all use the same syntax, so there's not that much to
be annoyed by.

   Here's an example format spec (from the group buffer): `%M%S%5y:
%(%g%)\n'.  We see that it is indeed extremely ugly, and that there are
lots of percentages everywhere.

* Menu:

* Formatting Basics::           A formatting variable is basically a format string.
* Mode Line Formatting::        Some rules about mode line formatting variables.
* Advanced Formatting::         Modifying output in various ways.
* User-Defined Specs::          Having Gnus call your own functions.
* Formatting Fonts::            Making the formatting look colorful and nice.
* Positioning Point::           Moving point to a position after an operation.
* Tabulation::                  Tabulating your output.
* Wide Characters::             Dealing with wide characters.

   Currently Gnus uses the following formatting variables:
`gnus-group-line-format', `gnus-summary-line-format',
`gnus-server-line-format', `gnus-topic-line-format',
`gnus-group-mode-line-format', `gnus-summary-mode-line-format',
`gnus-article-mode-line-format', `gnus-server-mode-line-format', and
`gnus-summary-pick-line-format'.

   All these format variables can also be arbitrary elisp forms.  In
that case, they will be `eval'ed to insert the required lines.

   Gnus includes a command to help you while creating your own format
specs.  `M-x gnus-update-format' will `eval' the current form, update
the spec in question and pop you to a buffer where you can examine the
resulting Lisp code to be run to generate the line.


File: gnus,  Node: Formatting Basics,  Next: Mode Line Formatting,  Up: Formatting Variables

8.4.1 Formatting Basics
-----------------------

Each `%' element will be replaced by some string or other when the
buffer in question is generated.  `%5y' means "insert the `y' spec, and
pad with spaces to get a 5-character field".

   As with normal C and Emacs Lisp formatting strings, the numerical
modifier between the `%' and the formatting type character will "pad"
the output so that it is always at least that long.  `%5y' will make
the field always (at least) five characters wide by padding with spaces
to the left.  If you say `%-5y', it will pad to the right instead.

   You may also wish to limit the length of the field to protect against
particularly wide values.  For that you can say `%4,6y', which means
that the field will never be more than 6 characters wide and never less
than 4 characters wide.

   Also Gnus supports some extended format specifications, such as
`%&user-date;'.


File: gnus,  Node: Mode Line Formatting,  Next: Advanced Formatting,  Prev: Formatting Basics,  Up: Formatting Variables

8.4.2 Mode Line Formatting
--------------------------

Mode line formatting variables (e.g., `gnus-summary-mode-line-format')
follow the same rules as other, buffer line oriented formatting
variables (*note Formatting Basics::) with the following two
differences:

  1. There must be no newline (`\n') at the end.

  2. The special `%%b' spec can be used to display the buffer name.
     Well, it's no spec at all, really--`%%' is just a way to quote `%'
     to allow it to pass through the formatting machinery unmangled, so
     that Emacs receives `%b', which is something the Emacs mode line
     display interprets to mean "show the buffer name".  For a full
     list of mode line specs Emacs understands, see the documentation
     of the `mode-line-format' variable.



File: gnus,  Node: Advanced Formatting,  Next: User-Defined Specs,  Prev: Mode Line Formatting,  Up: Formatting Variables

8.4.3 Advanced Formatting
-------------------------

It is frequently useful to post-process the fields in some way.
Padding, limiting, cutting off parts and suppressing certain values can
be achieved by using "tilde modifiers".  A typical tilde spec might
look like `%~(cut 3)~(ignore "0")y'.

   These are the valid modifiers:

`pad'
`pad-left'
     Pad the field to the left with spaces until it reaches the required
     length.

`pad-right'
     Pad the field to the right with spaces until it reaches the
     required length.

`max'
`max-left'
     Cut off characters from the left until it reaches the specified
     length.

`max-right'
     Cut off characters from the right until it reaches the specified
     length.

`cut'
`cut-left'
     Cut off the specified number of characters from the left.

`cut-right'
     Cut off the specified number of characters from the right.

`ignore'
     Return an empty string if the field is equal to the specified
     value.

`form'
     Use the specified form as the field value when the `@' spec is
     used.

     Here's an example:

          "~(form (current-time-string))@"


   Let's take an example.  The `%o' spec in the summary mode lines will
return a date in compact ISO8601 format--`19960809T230410'.  This is
quite a mouthful, so we want to shave off the century number and the
time, leaving us with a six-character date.  That would be `%~(cut-left
2)~(max-right 6)~(pad 6)o'.  (Cutting is done before maxing, and we
need the padding to ensure that the date is never less than 6
characters to make it look nice in columns.)

   Ignoring is done first; then cutting; then maxing; and then as the
very last operation, padding.

   If you use lots of these advanced thingies, you'll find that Gnus
gets quite slow.  This can be helped enormously by running `M-x
gnus-compile' when you are satisfied with the look of your lines.
*Note Compilation::.


File: gnus,  Node: User-Defined Specs,  Next: Formatting Fonts,  Prev: Advanced Formatting,  Up: Formatting Variables

8.4.4 User-Defined Specs
------------------------

All the specs allow for inserting user defined specifiers--`u'.  The
next character in the format string should be a letter.  Gnus will call
the function `gnus-user-format-function-'`X', where `X' is the letter
following `%u'.  The function will be passed a single parameter--what
the parameter means depends on what buffer it's being called from.  The
function should return a string, which will be inserted into the buffer
just like information from any other specifier.  This function may also
be called with dummy values, so it should protect against that.

   Also Gnus supports extended user-defined specs, such as `%u&foo;'.
Gnus will call the function `gnus-user-format-function-'`foo'.

   You can also use tilde modifiers (*note Advanced Formatting:: to
achieve much the same without defining new functions.  Here's an
example: `%~(form (count-lines (point-min) (point)))@'.  The form given
here will be evaluated to yield the current line number, and then
inserted.


File: gnus,  Node: Formatting Fonts,  Next: Positioning Point,  Prev: User-Defined Specs,  Up: Formatting Variables

8.4.5 Formatting Fonts
----------------------

There are specs for highlighting, and these are shared by all the format
variables.  Text inside the `%(' and `%)' specifiers will get the
special `mouse-face' property set, which means that it will be
highlighted (with `gnus-mouse-face') when you put the mouse pointer
over it.

   Text inside the `%{' and `%}' specifiers will have their normal
faces set using `gnus-face-0', which is `bold' by default.  If you say
`%1{', you'll get `gnus-face-1' instead, and so on.  Create as many
faces as you wish.  The same goes for the `mouse-face' specs--you can
say `%3(hello%)' to have `hello' mouse-highlighted with
`gnus-mouse-face-3'.

   Text inside the `%<<' and `%>>' specifiers will get the special
`balloon-help' property set to `gnus-balloon-face-0'.  If you say
`%1<<', you'll get `gnus-balloon-face-1' and so on.  The
`gnus-balloon-face-*' variables should be either strings or symbols
naming functions that return a string.  When the mouse passes over text
with this property set, a balloon window will appear and display the
string.  Please refer to *note Tooltips: (emacs)Tooltips, (in GNU
Emacs) or the doc string of `balloon-help-mode' (in XEmacs) for more
information on this.  (For technical reasons, the guillemets have been
approximated as `<<' and `>>' in this paragraph.)

   Here's an alternative recipe for the group buffer:

     ;; Create three face types.
     (setq gnus-face-1 'bold)
     (setq gnus-face-3 'italic)

     ;; We want the article count to be in
     ;; a bold and green face.  So we create
     ;; a new face called `my-green-bold'.
     (copy-face 'bold 'my-green-bold)
     ;; Set the color.
     (set-face-foreground 'my-green-bold "ForestGreen")
     (setq gnus-face-2 'my-green-bold)

     ;; Set the new & fancy format.
     (setq gnus-group-line-format
           "%M%S%3{%5y%}%2[:%] %(%1{%g%}%)\n")

   I'm sure you'll be able to use this scheme to create totally
unreadable and extremely vulgar displays.  Have fun!

   Note that the `%(' specs (and friends) do not make any sense on the
mode-line variables.


File: gnus,  Node: Positioning Point,  Next: Tabulation,  Prev: Formatting Fonts,  Up: Formatting Variables

8.4.6 Positioning Point
-----------------------

Gnus usually moves point to a pre-defined place on each line in most
buffers.  By default, point move to the first colon character on the
line.  You can customize this behavior in three different ways.

   You can move the colon character to somewhere else on the line.

   You can redefine the function that moves the point to the colon.  The
function is called `gnus-goto-colon'.

   But perhaps the most convenient way to deal with this, if you don't
want to have a colon in your line, is to use the `%*' specifier.  If you
put a `%*' somewhere in your format line definition, Gnus will place
point there.


File: gnus,  Node: Tabulation,  Next: Wide Characters,  Prev: Positioning Point,  Up: Formatting Variables

8.4.7 Tabulation
----------------

You can usually line up your displays by padding and cutting your
strings.  However, when combining various strings of different size, it
can often be more convenient to just output the strings, and then worry
about lining up the following text afterwards.

   To do that, Gnus supplies tabulator specs--`%='.  There are two
different types--"hard tabulators" and "soft tabulators".

   `%50=' will insert space characters to pad the line up to column 50.
If the text is already past column 50, nothing will be inserted.  This
is the soft tabulator.

   `%-50=' will insert space characters to pad the line up to column
50.  If the text is already past column 50, the excess text past column
50 will be removed.  This is the hard tabulator.


File: gnus,  Node: Wide Characters,  Prev: Tabulation,  Up: Formatting Variables

8.4.8 Wide Characters
---------------------

Fixed width fonts in most countries have characters of the same width.
Some countries, however, use Latin characters mixed with wider
characters--most notable East Asian countries.

   The problem is that when formatting, Gnus assumes that if a string
is 10 characters wide, it'll be 10 Latin characters wide on the screen.
In these countries, that's not true.

   To help fix this, you can set `gnus-use-correct-string-widths' to
`t'.  This makes buffer generation slower, but the results will be
prettier.  The default value under XEmacs is `t' but `nil' for Emacs.


File: gnus,  Node: Window Layout,  Next: Faces and Fonts,  Prev: Formatting Variables,  Up: Various

8.5 Window Layout
=================

No, there's nothing here about X, so be quiet.

   If `gnus-use-full-window' non-`nil', Gnus will delete all other
windows and occupy the entire Emacs screen by itself.  It is `t' by
default.

   Setting this variable to `nil' kinda works, but there are glitches.
Use at your own peril.

   `gnus-buffer-configuration' describes how much space each Gnus
buffer should be given.  Here's an excerpt of this variable:

     ((group (vertical 1.0 (group 1.0 point)
                           (if gnus-carpal (group-carpal 4))))
      (article (vertical 1.0 (summary 0.25 point)
                             (article 1.0))))

   This is an alist.  The "key" is a symbol that names some action or
other.  For instance, when displaying the group buffer, the window
configuration function will use `group' as the key.  A full list of
possible names is listed below.

   The "value" (i.e., the "split") says how much space each buffer
should occupy.  To take the `article' split as an example -

     (article (vertical 1.0 (summary 0.25 point)
                            (article 1.0)))

   This "split" says that the summary buffer should occupy 25% of upper
half of the screen, and that it is placed over the article buffer.  As
you may have noticed, 100% + 25% is actually 125% (yup, I saw y'all
reaching for that calculator there).  However, the special number `1.0'
is used to signal that this buffer should soak up all the rest of the
space available after the rest of the buffers have taken whatever they
need.  There should be only one buffer with the `1.0' size spec per
split.

   Point will be put in the buffer that has the optional third element
`point'.  In a `frame' split, the last subsplit having a leaf split
where the tag `frame-focus' is a member (i.e. is the third or fourth
element in the list, depending on whether the `point' tag is present)
gets focus.

   Here's a more complicated example:

     (article (vertical 1.0 (group 4)
                            (summary 0.25 point)
                            (if gnus-carpal (summary-carpal 4))
                            (article 1.0)))

   If the size spec is an integer instead of a floating point number,
then that number will be used to say how many lines a buffer should
occupy, not a percentage.

   If the "split" looks like something that can be `eval'ed (to be
precise--if the `car' of the split is a function or a subr), this split
will be `eval'ed.  If the result is non-`nil', it will be used as a
split.  This means that there will be three buffers if `gnus-carpal' is
`nil', and four buffers if `gnus-carpal' is non-`nil'.

   Not complicated enough for you?  Well, try this on for size:

     (article (horizontal 1.0
                  (vertical 0.5
                      (group 1.0)
                      (gnus-carpal 4))
                  (vertical 1.0
                      (summary 0.25 point)
                      (summary-carpal 4)
                      (article 1.0))))

   Whoops.  Two buffers with the mystery 100% tag.  And what's that
`horizontal' thingie?

   If the first element in one of the split is `horizontal', Gnus will
split the window horizontally, giving you two windows side-by-side.
Inside each of these strips you may carry on all you like in the normal
fashion.  The number following `horizontal' says what percentage of the
screen is to be given to this strip.

   For each split, there _must_ be one element that has the 100% tag.
The splitting is never accurate, and this buffer will eat any leftover
lines from the splits.

   To be slightly more formal, here's a definition of what a valid split
may look like:

     split      = frame | horizontal | vertical | buffer | form
     frame      = "(frame " size *split ")"
     horizontal = "(horizontal " size *split ")"
     vertical   = "(vertical " size *split ")"
     buffer     = "(" buf-name " " size *[ "point" ] *[ "frame-focus"] ")"
     size       = number | frame-params
     buf-name   = group | article | summary ...

   The limitations are that the `frame' split can only appear as the
top-level split.  FORM should be an Emacs Lisp form that should return
a valid split.  We see that each split is fully recursive, and may
contain any number of `vertical' and `horizontal' splits.

   Finding the right sizes can be a bit complicated.  No window may be
less than `gnus-window-min-height' (default 1) characters high, and all
windows must be at least `gnus-window-min-width' (default 1) characters
wide.  Gnus will try to enforce this before applying the splits.  If
you want to use the normal Emacs window width/height limit, you can
just set these two variables to `nil'.

   If you're not familiar with Emacs terminology, `horizontal' and
`vertical' splits may work the opposite way of what you'd expect.
Windows inside a `horizontal' split are shown side-by-side, and windows
within a `vertical' split are shown above each other.

   If you want to experiment with window placement, a good tip is to
call `gnus-configure-frame' directly with a split.  This is the function
that does all the real work when splitting buffers.  Below is a pretty
nonsensical configuration with 5 windows; two for the group buffer and
three for the article buffer.  (I said it was nonsensical.)  If you
`eval' the statement below, you can get an idea of how that would look
straight away, without going through the normal Gnus channels.  Play
with it until you're satisfied, and then use `gnus-add-configuration'
to add your new creation to the buffer configuration list.

     (gnus-configure-frame
      '(horizontal 1.0
         (vertical 10
           (group 1.0)
           (article 0.3 point))
         (vertical 1.0
           (article 1.0)
           (horizontal 4
             (group 1.0)
             (article 10)))))

   You might want to have several frames as well.  No prob--just use the
`frame' split:

     (gnus-configure-frame
      '(frame 1.0
              (vertical 1.0
                        (summary 0.25 point frame-focus)
                        (article 1.0))
              (vertical ((height . 5) (width . 15)
                         (user-position . t)
                         (left . -1) (top . 1))
                        (picon 1.0))))

   This split will result in the familiar summary/article window
configuration in the first (or "main") frame, while a small additional
frame will be created where picons will be shown.  As you can see,
instead of the normal `1.0' top-level spec, each additional split
should have a frame parameter alist as the size spec.  *Note Frame
Parameters: (elisp)Frame Parameters.  Under XEmacs, a frame property
list will be accepted, too--for instance, `(height 5 width 15 left -1
top 1)' is such a plist.  The list of all possible keys for
`gnus-buffer-configuration' can be found in its default value.

   Note that the `message' key is used for both `gnus-group-mail' and
`gnus-summary-mail-other-window'.  If it is desirable to distinguish
between the two, something like this might be used:

     (message (horizontal 1.0
                          (vertical 1.0 (message 1.0 point))
                          (vertical 0.24
                                    (if (buffer-live-p gnus-summary-buffer)
                                        '(summary 0.5))
                                    (group 1.0))))

   One common desire for a multiple frame split is to have a separate
frame for composing mail and news while leaving the original frame
intact.  To accomplish that, something like the following can be done:

     (message
       (frame 1.0
              (if (not (buffer-live-p gnus-summary-buffer))
                  (car (cdr (assoc 'group gnus-buffer-configuration)))
                (car (cdr (assoc 'summary gnus-buffer-configuration))))
              (vertical ((user-position . t) (top . 1) (left . 1)
                         (name . "Message"))
                        (message 1.0 point))))

   Since the `gnus-buffer-configuration' variable is so long and
complicated, there's a function you can use to ease changing the config
of a single setting: `gnus-add-configuration'.  If, for instance, you
want to change the `article' setting, you could say:

     (gnus-add-configuration
      '(article (vertical 1.0
                    (group 4)
                    (summary .25 point)
                    (article 1.0))))

   You'd typically stick these `gnus-add-configuration' calls in your
`~/.gnus.el' file or in some startup hook--they should be run after
Gnus has been loaded.

   If all windows mentioned in the configuration are already visible,
Gnus won't change the window configuration.  If you always want to
force the "right" window configuration, you can set
`gnus-always-force-window-configuration' to non-`nil'.

   If you're using tree displays (*note Tree Display::), and the tree
window is displayed vertically next to another window, you may also want
to fiddle with `gnus-tree-minimize-window' to avoid having the windows
resized.

8.5.1 Example Window Configurations
-----------------------------------

   * Narrow left hand side occupied by group buffer.  Right hand side
     split between summary buffer (top one-sixth) and article buffer
     (bottom).

          +---+---------+
          | G | Summary |
          | r +---------+
          | o |         |
          | u | Article |
          | p |         |
          +---+---------+

          (gnus-add-configuration
           '(article
             (horizontal 1.0
                         (vertical 25 (group 1.0))
                         (vertical 1.0
                                   (summary 0.16 point)
                                   (article 1.0)))))

          (gnus-add-configuration
           '(summary
             (horizontal 1.0
                         (vertical 25 (group 1.0))
                         (vertical 1.0 (summary 1.0 point)))))



File: gnus,  Node: Faces and Fonts,  Next: Compilation,  Prev: Window Layout,  Up: Various

8.6 Faces and Fonts
===================

Fiddling with fonts and faces used to be very difficult, but these days
it is very simple.  You simply say `M-x customize-face', pick out the
face you want to alter, and alter it via the standard Customize
interface.


File: gnus,  Node: Compilation,  Next: Mode Lines,  Prev: Faces and Fonts,  Up: Various

8.7 Compilation
===============

Remember all those line format specification variables?
`gnus-summary-line-format', `gnus-group-line-format', and so on.  Now,
Gnus will of course heed whatever these variables are, but,
unfortunately, changing them will mean a quite significant slow-down.
(The default values of these variables have byte-compiled functions
associated with them, while the user-generated versions do not, of
course.)

   To help with this, you can run `M-x gnus-compile' after you've
fiddled around with the variables and feel that you're (kind of)
satisfied.  This will result in the new specs being byte-compiled, and
you'll get top speed again.  Gnus will save these compiled specs in the
`.newsrc.eld' file.  (User-defined functions aren't compiled by this
function, though--you should compile them yourself by sticking them
into the `~/.gnus.el' file and byte-compiling that file.)


File: gnus,  Node: Mode Lines,  Next: Highlighting and Menus,  Prev: Compilation,  Up: Various

8.8 Mode Lines
==============

`gnus-updated-mode-lines' says what buffers should keep their mode
lines updated.  It is a list of symbols.  Supported symbols include
`group', `article', `summary', `server', `browse', and `tree'.  If the
corresponding symbol is present, Gnus will keep that mode line updated
with information that may be pertinent.  If this variable is `nil',
screen refresh may be quicker.

   By default, Gnus displays information on the current article in the
mode lines of the summary and article buffers.  The information Gnus
wishes to display (e.g. the subject of the article) is often longer
than the mode lines, and therefore have to be cut off at some point.
The `gnus-mode-non-string-length' variable says how long the other
elements on the line is (i.e., the non-info part).  If you put
additional elements on the mode line (e.g. a clock), you should modify
this variable:

     (add-hook 'display-time-hook
               (lambda () (setq gnus-mode-non-string-length
                                (+ 21
                                   (if line-number-mode 5 0)
                                   (if column-number-mode 4 0)
                                   (length display-time-string)))))

   If this variable is `nil' (which is the default), the mode line
strings won't be chopped off, and they won't be padded either.  Note
that the default is unlikely to be desirable, as even the percentage
complete in the buffer may be crowded off the mode line; the user should
configure this variable appropriately for her configuration.


File: gnus,  Node: Highlighting and Menus,  Next: Buttons,  Prev: Mode Lines,  Up: Various

8.9 Highlighting and Menus
==========================

The `gnus-visual' variable controls most of the Gnus-prettifying
aspects.  If `nil', Gnus won't attempt to create menus or use fancy
colors or fonts.  This will also inhibit loading the `gnus-vis.el' file.

   This variable can be a list of visual properties that are enabled.
The following elements are valid, and are all included by default:

`group-highlight'
     Do highlights in the group buffer.

`summary-highlight'
     Do highlights in the summary buffer.

`article-highlight'
     Do highlights in the article buffer.

`highlight'
     Turn on highlighting in all buffers.

`group-menu'
     Create menus in the group buffer.

`summary-menu'
     Create menus in the summary buffers.

`article-menu'
     Create menus in the article buffer.

`browse-menu'
     Create menus in the browse buffer.

`server-menu'
     Create menus in the server buffer.

`score-menu'
     Create menus in the score buffers.

`menu'
     Create menus in all buffers.

   So if you only want highlighting in the article buffer and menus in
all buffers, you could say something like:

     (setq gnus-visual '(article-highlight menu))

   If you want highlighting only and no menus whatsoever, you'd say:

     (setq gnus-visual '(highlight))

   If `gnus-visual' is `t', highlighting and menus will be used in all
Gnus buffers.

   Other general variables that influence the look of all buffers
include:

`gnus-mouse-face'
     This is the face (i.e., font) used for mouse highlighting in Gnus.
     No mouse highlights will be done if `gnus-visual' is `nil'.


   There are hooks associated with the creation of all the different
menus:

`gnus-article-menu-hook'
     Hook called after creating the article mode menu.

`gnus-group-menu-hook'
     Hook called after creating the group mode menu.

`gnus-summary-menu-hook'
     Hook called after creating the summary mode menu.

`gnus-server-menu-hook'
     Hook called after creating the server mode menu.

`gnus-browse-menu-hook'
     Hook called after creating the browse mode menu.

`gnus-score-menu-hook'
     Hook called after creating the score mode menu.



File: gnus,  Node: Buttons,  Next: Daemons,  Prev: Highlighting and Menus,  Up: Various

8.10 Buttons
============

Those new-fangled "mouse" contraptions is very popular with the young,
hep kids who don't want to learn the proper way to do things these
days.  Why, I remember way back in the summer of '89, when I was using
Emacs on a Tops 20 system.  Three hundred users on one single machine,
and every user was running Simula compilers.  Bah!

   Right.

   Well, you can make Gnus display bufferfuls of buttons you can click
to do anything by setting `gnus-carpal' to `t'.  Pretty simple, really.
Tell the chiropractor I sent you.

`gnus-carpal-mode-hook'
     Hook run in all carpal mode buffers.

`gnus-carpal-button-face'
     Face used on buttons.

`gnus-carpal-header-face'
     Face used on carpal buffer headers.

`gnus-carpal-group-buffer-buttons'
     Buttons in the group buffer.

`gnus-carpal-summary-buffer-buttons'
     Buttons in the summary buffer.

`gnus-carpal-server-buffer-buttons'
     Buttons in the server buffer.

`gnus-carpal-browse-buffer-buttons'
     Buttons in the browse buffer.

   All the `buttons' variables are lists.  The elements in these list
are either cons cells where the `car' contains a text to be displayed
and the `cdr' contains a function symbol, or a simple string.


File: gnus,  Node: Daemons,  Next: NoCeM,  Prev: Buttons,  Up: Various

8.11 Daemons
============

Gnus, being larger than any program ever written (allegedly), does lots
of strange stuff that you may wish to have done while you're not
present.  For instance, you may want it to check for new mail once in a
while.  Or you may want it to close down all connections to all servers
when you leave Emacs idle.  And stuff like that.

   Gnus will let you do stuff like that by defining various "handlers".
Each handler consists of three elements:  A FUNCTION, a TIME, and an
IDLE parameter.

   Here's an example of a handler that closes connections when Emacs has
been idle for thirty minutes:

     (gnus-demon-close-connections nil 30)

   Here's a handler that scans for PGP headers every hour when Emacs is
idle:

     (gnus-demon-scan-pgp 60 t)

   This TIME parameter and that IDLE parameter work together in a
strange, but wonderful fashion.  Basically, if IDLE is `nil', then the
function will be called every TIME minutes.

   If IDLE is `t', then the function will be called after TIME minutes
only if Emacs is idle.  So if Emacs is never idle, the function will
never be called.  But once Emacs goes idle, the function will be called
every TIME minutes.

   If IDLE is a number and TIME is a number, the function will be
called every TIME minutes only when Emacs has been idle for IDLE
minutes.

   If IDLE is a number and TIME is `nil', the function will be called
once every time Emacs has been idle for IDLE minutes.

   And if TIME is a string, it should look like `07:31', and the
function will then be called once every day somewhere near that time.
Modified by the IDLE parameter, of course.

   (When I say "minute" here, I really mean `gnus-demon-timestep'
seconds.  This is 60 by default.  If you change that variable, all the
timings in the handlers will be affected.)

   So, if you want to add a handler, you could put something like this
in your `~/.gnus.el' file:

     (gnus-demon-add-handler 'gnus-demon-close-connections 30 t)

   Some ready-made functions to do this have been created:
`gnus-demon-add-nocem', `gnus-demon-add-disconnection',
`gnus-demon-add-nntp-close-connection',
`gnus-demon-add-scan-timestamps', `gnus-demon-add-rescan', and
`gnus-demon-add-scanmail'.  Just put those functions in your
`~/.gnus.el' if you want those abilities.

   If you add handlers to `gnus-demon-handlers' directly, you should
run `gnus-demon-init' to make the changes take hold.  To cancel all
daemons, you can use the `gnus-demon-cancel' function.

   Note that adding daemons can be pretty naughty if you over do it.
Adding functions that scan all news and mail from all servers every two
seconds is a sure-fire way of getting booted off any respectable
system.  So behave.


File: gnus,  Node: NoCeM,  Next: Undo,  Prev: Daemons,  Up: Various

8.12 NoCeM
==========

"Spamming" is posting the same article lots and lots of times.
Spamming is bad.  Spamming is evil.

   Spamming is usually canceled within a day or so by various
anti-spamming agencies.  These agencies usually also send out "NoCeM"
messages.  NoCeM is pronounced "no see-'em", and means what the name
implies--these are messages that make the offending articles, like, go
away.

   What use are these NoCeM messages if the articles are canceled
anyway?  Some sites do not honor cancel messages and some sites just
honor cancels from a select few people.  Then you may wish to make use
of the NoCeM messages, which are distributed in the newsgroups
`news.lists.filters', `alt.nocem.misc', etc.

   Gnus can read and parse the messages in this group automatically, and
this will make spam disappear.

   There are some variables to customize, of course:

`gnus-use-nocem'
     Set this variable to `t' to set the ball rolling.  It is `nil' by
     default.

     You can also set this variable to a positive number as a group
     level.  In that case, Gnus scans NoCeM messages when checking new
     news if this value is not exceeding a group level that you specify
     as the prefix argument to some commands, e.g. `gnus',
     `gnus-group-get-new-news', etc.  Otherwise, Gnus does not scan
     NoCeM messages if you specify a group level that is smaller than
     this value to those commands.  For example, if you use 1 or 2 on
     the mail groups and the levels on the news groups remain the
     default, 3 is the best choice.

`gnus-nocem-groups'
     Gnus will look for NoCeM messages in the groups in this list.  The
     default is
          ("news.lists.filters" "alt.nocem.misc")

`gnus-nocem-issuers'
     There are many people issuing NoCeM messages.  This list says what
     people you want to listen to.  The default is:

          ("Adri Verhoef"
           "alba-nocem@albasani.net"
           "bleachbot@httrack.com"
           "news@arcor-online.net"
           "news@uni-berlin.de"
           "nocem@arcor.de"
           "pgpmoose@killfile.org"
           "xjsppl@gmx.de")

     Known despammers that you can put in this list are listed at
     `http://www.xs4all.nl/~rosalind/nocemreg/nocemreg.html'.

     You do not have to heed NoCeM messages from all these people--just
     the ones you want to listen to.  You also don't have to accept all
     NoCeM messages from the people you like.  Each NoCeM message has a
     "type" header that gives the message a (more or less, usually
     less) rigorous definition.  Common types are `spam', `spew', `mmf',
     `binary', and `troll'.  To specify this, you have to use `(ISSUER
     CONDITIONS ...)' elements in the list.  Each condition is either a
     string (which is a regexp that matches types you want to use) or a
     list on the form `(not STRING)', where STRING is a regexp that
     matches types you don't want to use.

     For instance, if you want all NoCeM messages from Chris Lewis
     except his `troll' messages, you'd say:

          ("clewis@ferret.ocunix.on.ca" ".*" (not "troll"))

     On the other hand, if you just want nothing but his `spam' and
     `spew' messages, you'd say:

          ("clewis@ferret.ocunix.on.ca" (not ".*") "spew" "spam")

     The specs are applied left-to-right.

`gnus-nocem-verifyer'
     This should be a function for verifying that the NoCeM issuer is
     who she says she is.  This variable defaults to
     `gnus-nocem-epg-verify' if EasyPG is available, otherwise defaults
     to `pgg-verify'.  The function should return non-`nil' if the
     verification is successful, otherwise (including the case the
     NoCeM message was not signed) should return `nil'.  If this is too
     slow and you don't care for verification (which may be dangerous),
     you can set this variable to `nil'.

     Formerly the default was `mc-verify', which is a Mailcrypt
     function.  While you can still use it, you can change it into
     `gnus-nocem-epg-verify' or `pgg-verify' running with GnuPG if you
     are willing to add the PGP public keys to GnuPG's keyring.

`gnus-nocem-directory'
     This is where Gnus will store its NoCeM cache files.  The default
     is
     `~/News/NoCeM/'.

`gnus-nocem-expiry-wait'
     The number of days before removing old NoCeM entries from the
     cache.  The default is 15.  If you make it shorter Gnus will be
     faster, but you might then see old spam.

`gnus-nocem-check-from'
     Non-`nil' means check for valid issuers in message bodies.
     Otherwise don't bother fetching articles unless their author
     matches a valid issuer; that is much faster if you are selective
     about the issuers.

`gnus-nocem-check-article-limit'
     If non-`nil', the maximum number of articles to check in any NoCeM
     group.  `nil' means no restriction.  NoCeM groups can be huge and
     very slow to process.


   Using NoCeM could potentially be a memory hog.  If you have many
living (i. e., subscribed or unsubscribed groups), your Emacs process
will grow big.  If this is a problem, you should kill off all (or most)
of your unsubscribed groups (*note Subscription Commands::).


File: gnus,  Node: Undo,  Next: Predicate Specifiers,  Prev: NoCeM,  Up: Various

8.13 Undo
=========

It is very useful to be able to undo actions one has done.  In normal
Emacs buffers, it's easy enough--you just push the `undo' button.  In
Gnus buffers, however, it isn't that simple.

   The things Gnus displays in its buffer is of no value whatsoever to
Gnus--it's all just data designed to look nice to the user.  Killing a
group in the group buffer with `C-k' makes the line disappear, but
that's just a side-effect of the real action--the removal of the group
in question from the internal Gnus structures.  Undoing something like
that can't be done by the normal Emacs `undo' function.

   Gnus tries to remedy this somewhat by keeping track of what the user
does and coming up with actions that would reverse the actions the user
takes.  When the user then presses the `undo' key, Gnus will run the
code to reverse the previous action, or the previous actions.  However,
not all actions are easily reversible, so Gnus currently offers a few
key functions to be undoable.  These include killing groups, yanking
groups, and changing the list of read articles of groups.  That's it,
really.  More functions may be added in the future, but each added
function means an increase in data to be stored, so Gnus will never be
totally undoable.

   The undoability is provided by the `gnus-undo-mode' minor mode.  It
is used if `gnus-use-undo' is non-`nil', which is the default.  The
`C-M-_' key performs the `gnus-undo' command, which should feel kinda
like the normal Emacs `undo' command.


File: gnus,  Node: Predicate Specifiers,  Next: Moderation,  Prev: Undo,  Up: Various

8.14 Predicate Specifiers
=========================

Some Gnus variables are "predicate specifiers".  This is a special form
that allows flexible specification of predicates without having to type
all that much.

   These specifiers are lists consisting of functions, symbols and
lists.

   Here's an example:

     (or gnus-article-unseen-p
         gnus-article-unread-p)

   The available symbols are `or', `and' and `not'.  The functions all
take one parameter.

   Internally, Gnus calls `gnus-make-predicate' on these specifiers to
create a function that can be called.  This input parameter to this
function will be passed along to all the functions in the predicate
specifier.


File: gnus,  Node: Moderation,  Next: Fetching a Group,  Prev: Predicate Specifiers,  Up: Various

8.15 Moderation
===============

If you are a moderator, you can use the `gnus-mdrtn.el' package.  It is
not included in the standard Gnus package.  Write a mail to
`larsi@gnus.org' and state what group you moderate, and you'll get a
copy.

   The moderation package is implemented as a minor mode for summary
buffers.  Put

     (add-hook 'gnus-summary-mode-hook 'gnus-moderate)

   in your `~/.gnus.el' file.

   If you are the moderator of `rec.zoofle', this is how it's supposed
to work:

  1. You split your incoming mail by matching on
     `Newsgroups:.*rec.zoofle', which will put all the to-be-posted
     articles in some mail group--for instance, `nnml:rec.zoofle'.

  2. You enter that group once in a while and post articles using the
     `e' (edit-and-post) or `s' (just send unedited) commands.

  3. If, while reading the `rec.zoofle' newsgroup, you happen upon some
     articles that weren't approved by you, you can cancel them with the
     `c' command.

   To use moderation mode in these two groups, say:

     (setq gnus-moderated-list
           "^nnml:rec.zoofle$\\|^rec.zoofle$")


File: gnus,  Node: Fetching a Group,  Next: Image Enhancements,  Prev: Moderation,  Up: Various

8.16 Fetching a Group
=====================

It is sometimes convenient to be able to just say "I want to read this
group and I don't care whether Gnus has been started or not".  This is
perhaps more useful for people who write code than for users, but the
command `gnus-fetch-group' provides this functionality in any case.  It
takes the group name as a parameter.


File: gnus,  Node: Image Enhancements,  Next: Fuzzy Matching,  Prev: Fetching a Group,  Up: Various

8.17 Image Enhancements
=======================

XEmacs, as well as Emacs 21(1) and up, are able to display pictures and
stuff, so Gnus has taken advantage of that.

* Menu:

* X-Face::                      Display a funky, teensy black-and-white image.
* Face::                        Display a funkier, teensier colored image.
* Smileys::                     Show all those happy faces the way they were meant to be shown.
* Picons::                      How to display pictures of what you're reading.
* XVarious::                    Other XEmacsy Gnusey variables.

   ---------- Footnotes ----------

   (1) Emacs 21 on MS Windows doesn't support images, Emacs 22 does.


File: gnus,  Node: X-Face,  Next: Face,  Up: Image Enhancements

8.17.1 X-Face
-------------

`X-Face' headers describe a 48x48 pixel black-and-white (1 bit depth)
image that's supposed to represent the author of the message.  It seems
to be supported by an ever-growing number of mail and news readers.

   Viewing an `X-Face' header either requires an Emacs that has
`compface' support (which most XEmacs versions have), or that you have
suitable conversion or display programs installed.  If your Emacs has
image support the default action is to display the face before the
`From' header.  If there's no native `X-Face' support, Gnus will try to
convert the `X-Face' header using external programs from the `pbmplus'
package and friends, see below.  For XEmacs it's faster if XEmacs has
been compiled with `X-Face' support.  The default action under Emacs
without image support is to fork off the `display' program.

   On a GNU/Linux system, the `display' program is included in the
ImageMagick package.  For external conversion programs look for packages
with names like `netpbm', `libgr-progs' and `compface'.  On Windows,
you may use the packages `netpbm' and `compface' from
`http://gnuwin32.sourceforge.net'.  You need to add the `bin' directory
to your `PATH' environment variable.

   The variable `gnus-article-x-face-command' controls which programs
are used to display the `X-Face' header.  If this variable is a string,
this string will be executed in a sub-shell.  If it is a function, this
function will be called with the face as the argument.  If
`gnus-article-x-face-too-ugly' (which is a regexp) matches the `From'
header, the face will not be shown.

   (Note: `x-face' is used in the variable/function names, not `xface').

Face and variable:

`gnus-x-face'
     Face to show X-Face.  The colors from this face are used as the
     foreground and background colors of the displayed X-Faces.  The
     default colors are black and white.

`gnus-face-properties-alist'
     Alist of image types and properties applied to Face (*note Face::)
     and X-Face images.  The default value is `((pbm . (:face
     gnus-x-face)) (png . nil))' for Emacs or `((xface . (:face
     gnus-x-face)))' for XEmacs.  Here are examples:

          ;; Specify the altitude of Face and X-Face images in the From header.
          (setq gnus-face-properties-alist
                '((pbm . (:face gnus-x-face :ascent 80))
                  (png . (:ascent 80))))

          ;; Show Face and X-Face images as pressed buttons.
          (setq gnus-face-properties-alist
                '((pbm . (:face gnus-x-face :relief -2))
                  (png . (:relief -2))))

     *note Image Descriptors: (elisp)Image Descriptors. for the valid
     properties for various image types.  Currently, `pbm' is used for
     X-Face images and `png' is used for Face images in Emacs.  Only
     the `:face' property is effective on the `xface' image type in
     XEmacs if it is built with the `libcompface' library.

   If you use posting styles, you can use an `x-face-file' entry in
`gnus-posting-styles', *Note Posting Styles::.  If you don't, Gnus
provides a few convenience functions and variables to allow easier
insertion of X-Face headers in outgoing messages.  You also need the
above mentioned ImageMagick, netpbm or other image conversion packages
(depending the values of the variables below) for these functions.

   `gnus-random-x-face' goes through all the `pbm' files in
`gnus-x-face-directory' and picks one at random, and then converts it
to the X-Face format by using the `gnus-convert-pbm-to-x-face-command'
shell command.  The `pbm' files should be 48x48 pixels big.  It returns
the X-Face header data as a string.

   `gnus-insert-random-x-face-header' calls `gnus-random-x-face' and
inserts a `X-Face' header with the randomly generated data.

   `gnus-x-face-from-file' takes a GIF file as the parameter, and then
converts the file to X-Face format by using the
`gnus-convert-image-to-x-face-command' shell command.

   Here's how you would typically use the first function.  Put something
like the following in your `~/.gnus.el' file:

     (setq message-required-news-headers
           (nconc message-required-news-headers
                  (list '(X-Face . gnus-random-x-face))))

   Using the last function would be something like this:

     (setq message-required-news-headers
           (nconc message-required-news-headers
                  (list '(X-Face . (lambda ()
                                     (gnus-x-face-from-file
                                      "~/My-face.gif"))))))


File: gnus,  Node: Face,  Next: Smileys,  Prev: X-Face,  Up: Image Enhancements

8.17.2 Face
-----------

`Face' headers are essentially a funkier version of `X-Face' ones. They
describe a 48x48 pixel colored image that's supposed to represent the
author of the message.

   The contents of a `Face' header must be a base64 encoded PNG image.
See `http://quimby.gnus.org/circus/face/' for the precise
specifications.

   The `gnus-face-properties-alist' variable affects the appearance of
displayed Face images.  *Note X-Face::.

   Viewing an `Face' header requires an Emacs that is able to display
PNG images.

   Gnus provides a few convenience functions and variables to allow
easier insertion of Face headers in outgoing messages.

   `gnus-convert-png-to-face' takes a 48x48 PNG image, no longer than
726 bytes long, and converts it to a face.

   `gnus-face-from-file' takes a JPEG file as the parameter, and then
converts the file to Face format by using the
`gnus-convert-image-to-face-command' shell command.

   Here's how you would typically use this function. Put something like
the following in your `~/.gnus.el' file:

     (setq message-required-news-headers
           (nconc message-required-news-headers
                  (list '(Face . (lambda ()
                                   (gnus-face-from-file "~/face.jpg"))))))


File: gnus,  Node: Smileys,  Next: Picons,  Prev: Face,  Up: Image Enhancements

8.17.3 Smileys
--------------

"Smiley" is a package separate from Gnus, but since Gnus is currently
the only package that uses Smiley, it is documented here.

   In short--to use Smiley in Gnus, put the following in your
`~/.gnus.el' file:

     (setq gnus-treat-display-smileys t)

   Smiley maps text smiley faces--`:-)', `8-)', `:-(' and the like--to
pictures and displays those instead of the text smiley faces.  The
conversion is controlled by a list of regexps that matches text and
maps that to file names.

   The alist used is specified by the `smiley-regexp-alist' variable.
The first item in each element is the regexp to be matched; the second
element is the regexp match group that is to be replaced by the
picture; and the third element is the name of the file to be displayed.

   The following variables customize the appearance of the smileys:

`smiley-style'
     Specifies the smiley style.  Predefined smiley styles include
     `low-color' (small 13x14 pixel, three-color images), `medium'
     (more colorful images, 16x16 pixel), and `grayscale' (grayscale
     images, 14x14 pixel).  The default depends on the height of the
     default face.

`smiley-data-directory'
     Where Smiley will look for smiley faces files.  You shouldn't set
     this variable anymore.  Customize `smiley-style' instead.

`gnus-smiley-file-types'
     List of suffixes on smiley file names to try.



File: gnus,  Node: Picons,  Next: XVarious,  Prev: Smileys,  Up: Image Enhancements

8.17.4 Picons
-------------

So...  You want to slow down your news reader even more!  This is a
good way to do so.  It's also a great way to impress people staring
over your shoulder as you read news.

   What are Picons?  To quote directly from the Picons Web site:

     "Picons" is short for "personal icons".  They're small,
     constrained images used to represent users and domains on the net,
     organized into databases so that the appropriate image for a given
     e-mail address can be found.  Besides users and domains, there are
     picon databases for Usenet newsgroups and weather forecasts.  The
     picons are in either monochrome `XBM' format or color `XPM' and
     `GIF' formats.

   For instructions on obtaining and installing the picons databases,
point your Web browser at
`http://www.cs.indiana.edu/picons/ftp/index.html'.

   If you are using Debian GNU/Linux, saying `apt-get install picons.*'
will install the picons where Gnus can find them.

   To enable displaying picons, simply make sure that
`gnus-picon-databases' points to the directory containing the Picons
databases.

   The variable `gnus-picon-style' controls how picons are displayed.
If `inline', the textual representation is replaced.  If `right',
picons are added right to the textual representation.

   The following variables offer control over where things are located.

`gnus-picon-databases'
     The location of the picons database.  This is a list of directories
     containing the `news', `domains', `users' (and so on)
     subdirectories.  Defaults to `("/usr/lib/picon"
     "/usr/local/faces")'.

`gnus-picon-news-directories'
     List of subdirectories to search in `gnus-picon-databases' for
     newsgroups faces.  `("news")' is the default.

`gnus-picon-user-directories'
     List of subdirectories to search in `gnus-picon-databases' for user
     faces.  `("users" "usenix" "local" "misc")' is the default.

`gnus-picon-domain-directories'
     List of subdirectories to search in `gnus-picon-databases' for
     domain name faces.  Defaults to `("domains")'.  Some people may
     want to add `"unknown"' to this list.

`gnus-picon-file-types'
     Ordered list of suffixes on picon file names to try.  Defaults to
     `("xpm" "gif" "xbm")' minus those not built-in your Emacs.



File: gnus,  Node: XVarious,  Prev: Picons,  Up: Image Enhancements

8.17.5 Various XEmacs Variables
-------------------------------

`gnus-xmas-glyph-directory'
     This is where Gnus will look for pictures.  Gnus will normally
     auto-detect this directory, but you may set it manually if you
     have an unusual directory structure.

`gnus-xmas-modeline-glyph'
     A glyph displayed in all Gnus mode lines.  It is a tiny gnu head by
     default.


8.17.5.1 Toolbar
................

`gnus-use-toolbar'
     This variable specifies the position to display the toolbar.  If
     `nil', don't display toolbars.  If it is non-`nil', it should be
     one of the symbols `default', `top', `bottom', `right', and
     `left'.  `default' means to use the default toolbar, the rest mean
     to display the toolbar on the place which those names show.  The
     default is `default'.

`gnus-toolbar-thickness'
     Cons of the height and the width specifying the thickness of a
     toolbar.  The height is used for the toolbar displayed on the top
     or the bottom, the width is used for the toolbar displayed on the
     right or the left.  The default is that of the default toolbar.

`gnus-group-toolbar'
     The toolbar in the group buffer.

`gnus-summary-toolbar'
     The toolbar in the summary buffer.

`gnus-summary-mail-toolbar'
     The toolbar in the summary buffer of mail groups.



File: gnus,  Node: Fuzzy Matching,  Next: Thwarting Email Spam,  Prev: Image Enhancements,  Up: Various

8.18 Fuzzy Matching
===================

Gnus provides "fuzzy matching" of `Subject' lines when doing things
like scoring, thread gathering and thread comparison.

   As opposed to regular expression matching, fuzzy matching is very
fuzzy.  It's so fuzzy that there's not even a definition of what
"fuzziness" means, and the implementation has changed over time.

   Basically, it tries to remove all noise from lines before comparing.
`Re: ', parenthetical remarks, white space, and so on, are filtered out
of the strings before comparing the results.  This often leads to
adequate results--even when faced with strings generated by text
manglers masquerading as newsreaders.


File: gnus,  Node: Thwarting Email Spam,  Next: Spam Package,  Prev: Fuzzy Matching,  Up: Various

8.19 Thwarting Email Spam
=========================

In these last days of the Usenet, commercial vultures are hanging about
and grepping through news like crazy to find email addresses they can
foist off their scams and products to.  As a reaction to this, many
people have started putting nonsense addresses into their `From' lines.
I think this is counterproductive--it makes it difficult for people to
send you legitimate mail in response to things you write, as well as
making it difficult to see who wrote what.  This rewriting may perhaps
be a bigger menace than the unsolicited commercial email itself in the
end.

   The biggest problem I have with email spam is that it comes in under
false pretenses.  I press `g' and Gnus merrily informs me that I have
10 new emails.  I say "Golly gee!  Happy is me!" and select the mail
group, only to find two pyramid schemes, seven advertisements ("New!
Miracle tonic for growing full, lustrous hair on your toes!")  and one
mail asking me to repent and find some god.

   This is annoying.  Here's what you can do about it.

* Menu:

* The problem of spam::         Some background, and some solutions
* Anti-Spam Basics::            Simple steps to reduce the amount of spam.
* SpamAssassin::                How to use external anti-spam tools.
* Hashcash::                    Reduce spam by burning CPU time.


File: gnus,  Node: The problem of spam,  Next: Anti-Spam Basics,  Up: Thwarting Email Spam

8.19.1 The problem of spam
--------------------------

First, some background on spam.

   If you have access to e-mail, you are familiar with spam (technically
termed UCE, Unsolicited Commercial E-mail).  Simply put, it exists
because e-mail delivery is very cheap compared to paper mail, so only a
very small percentage of people need to respond to an UCE to make it
worthwhile to the advertiser.  Ironically, one of the most common spams
is the one offering a database of e-mail addresses for further
spamming.  Senders of spam are usually called _spammers_, but terms
like _vermin_, _scum_, _sociopaths_, and _morons_ are in common use as
well.

   Spam comes from a wide variety of sources.  It is simply impossible
to dispose of all spam without discarding useful messages.  A good
example is the TMDA system, which requires senders unknown to you to
confirm themselves as legitimate senders before their e-mail can reach
you.  Without getting into the technical side of TMDA, a downside is
clearly that e-mail from legitimate sources may be discarded if those
sources can't or won't confirm themselves through the TMDA system.
Another problem with TMDA is that it requires its users to have a basic
understanding of e-mail delivery and processing.

   The simplest approach to filtering spam is filtering, at the mail
server or when you sort through incoming mail.  If you get 200 spam
messages per day from `random-address@vmadmin.com', you block
`vmadmin.com'.  If you get 200 messages about `VIAGRA', you discard all
messages with `VIAGRA' in the message.  If you get lots of spam from
Bulgaria, for example, you try to filter all mail from Bulgarian IPs.

   This, unfortunately, is a great way to discard legitimate e-mail.
The risks of blocking a whole country (Bulgaria, Norway, Nigeria, China,
etc.) or even a continent (Asia, Africa, Europe, etc.) from contacting
you should be obvious, so don't do it if you have the choice.

   In another instance, the very informative and useful RISKS digest has
been blocked by overzealous mail filters because it *contained* words
that were common in spam messages.  Nevertheless, in isolated cases,
with great care, direct filtering of mail can be useful.

   Another approach to filtering e-mail is the distributed spam
processing, for instance DCC implements such a system.  In essence, N
systems around the world agree that a machine X in Ghana, Estonia, or
California is sending out spam e-mail, and these N systems enter X or
the spam e-mail from X into a database.  The criteria for spam
detection vary--it may be the number of messages sent, the content of
the messages, and so on.  When a user of the distributed processing
system wants to find out if a message is spam, he consults one of those
N systems.

   Distributed spam processing works very well against spammers that
send a large number of messages at once, but it requires the user to
set up fairly complicated checks.  There are commercial and free
distributed spam processing systems.  Distributed spam processing has
its risks as well.  For instance legitimate e-mail senders have been
accused of sending spam, and their web sites and mailing lists have
been shut down for some time because of the incident.

   The statistical approach to spam filtering is also popular.  It is
based on a statistical analysis of previous spam messages.  Usually the
analysis is a simple word frequency count, with perhaps pairs of words
or 3-word combinations thrown into the mix.  Statistical analysis of
spam works very well in most of the cases, but it can classify
legitimate e-mail as spam in some cases.  It takes time to run the
analysis, the full message must be analyzed, and the user has to store
the database of spam analysis.  Statistical analysis on the server is
gaining popularity.  This has the advantage of letting the user Just
Read Mail, but has the disadvantage that it's harder to tell the server
that it has misclassified mail.

   Fighting spam is not easy, no matter what anyone says.  There is no
magic switch that will distinguish Viagra ads from Mom's e-mails.  Even
people are having a hard time telling spam apart from non-spam, because
spammers are actively looking to fool us into thinking they are Mom,
essentially.  Spamming is irritating, irresponsible, and idiotic
behavior from a bunch of people who think the world owes them a favor.
We hope the following sections will help you in fighting the spam
plague.


File: gnus,  Node: Anti-Spam Basics,  Next: SpamAssassin,  Prev: The problem of spam,  Up: Thwarting Email Spam

8.19.2 Anti-Spam Basics
-----------------------

One way of dealing with spam is having Gnus split out all spam into a
`spam' mail group (*note Splitting Mail::).

   First, pick one (1) valid mail address that you can be reached at,
and put it in your `From' header of all your news articles.  (I've
chosen `larsi@trym.ifi.uio.no', but for many addresses on the form
`larsi+usenet@ifi.uio.no' will be a better choice.  Ask your sysadmin
whether your sendmail installation accepts keywords in the local part
of the mail address.)

     (setq message-default-news-headers
           "From: Lars Magne Ingebrigtsen <larsi@trym.ifi.uio.no>\n")

   Then put the following split rule in `nnmail-split-fancy' (*note
Fancy Mail Splitting::):

     (...
      (to "larsi@trym.ifi.uio.no"
          (| ("subject" "re:.*" "misc")
             ("references" ".*@.*" "misc")
             "spam"))
      ...)

   This says that all mail to this address is suspect, but if it has a
`Subject' that starts with a `Re:' or has a `References' header, it's
probably ok.  All the rest goes to the `spam' group.  (This idea
probably comes from Tim Pierce.)

   In addition, many mail spammers talk directly to your SMTP server
and do not include your email address explicitly in the `To' header.
Why they do this is unknown--perhaps it's to thwart this thwarting
scheme?  In any case, this is trivial to deal with--you just put
anything not addressed to you in the `spam' group by ending your fancy
split rule in this way:

     (
      ...
      (to "larsi" "misc")
      "spam")

   In my experience, this will sort virtually everything into the right
group.  You still have to check the `spam' group from time to time to
check for legitimate mail, though.  If you feel like being a good net
citizen, you can even send off complaints to the proper authorities on
each unsolicited commercial email--at your leisure.

   This works for me.  It allows people an easy way to contact me (they
can just press `r' in the usual way), and I'm not bothered at all with
spam.  It's a win-win situation.  Forging `From' headers to point to
non-existent domains is yucky, in my opinion.

   Be careful with this approach.  Spammers are wise to it.


File: gnus,  Node: SpamAssassin,  Next: Hashcash,  Prev: Anti-Spam Basics,  Up: Thwarting Email Spam

8.19.3 SpamAssassin, Vipul's Razor, DCC, etc
--------------------------------------------

The days where the hints in the previous section were sufficient in
avoiding spam are coming to an end.  There are many tools out there
that claim to reduce the amount of spam you get.  This section could
easily become outdated fast, as new products replace old, but
fortunately most of these tools seem to have similar interfaces.  Even
though this section will use SpamAssassin as an example, it should be
easy to adapt it to most other tools.

   Note that this section does not involve the `spam.el' package, which
is discussed in the next section.  If you don't care for all the
features of `spam.el', you can make do with these simple recipes.

   If the tool you are using is not installed on the mail server, you
need to invoke it yourself.  Ideas on how to use the `:postscript' mail
source parameter (*note Mail Source Specifiers::) follow.

     (setq mail-sources
           '((file :prescript "formail -bs spamassassin < /var/mail/%u")
             (pop :user "jrl"
                  :server "pophost"
                  :postscript
                  "mv %t /tmp/foo; formail -bs spamc < /tmp/foo > %t")))

   Once you manage to process your incoming spool somehow, thus making
the mail contain e.g. a header indicating it is spam, you are ready to
filter it out.  Using normal split methods (*note Splitting Mail::):

     (setq nnmail-split-methods '(("spam"  "^X-Spam-Flag: YES")
                                  ...))

   Or using fancy split methods (*note Fancy Mail Splitting::):

     (setq nnmail-split-methods 'nnmail-split-fancy
           nnmail-split-fancy '(| ("X-Spam-Flag" "YES" "spam")
                                  ...))

   Some people might not like the idea of piping the mail through
various programs using a `:prescript' (if some program is buggy, you
might lose all mail).  If you are one of them, another solution is to
call the external tools during splitting.  Example fancy split method:

     (setq nnmail-split-fancy '(| (: kevin-spamassassin)
                                  ...))
     (defun kevin-spamassassin ()
       (save-excursion
         (save-restriction
           (widen)
           (if (eq 1 (call-process-region (point-min) (point-max)
                                          "spamc" nil nil nil "-c"))
               "spam"))))

   Note that with the nnimap back end, message bodies will not be
downloaded by default.  You need to set `nnimap-split-download-body' to
`t' to do that (*note Splitting in IMAP::).

   That is about it.  As some spam is likely to get through anyway, you
might want to have a nifty function to call when you happen to read
spam.  And here is the nifty function:

     (defun my-gnus-raze-spam ()
       "Submit SPAM to Vipul's Razor, then mark it as expirable."
       (interactive)
       (gnus-summary-save-in-pipe "razor-report -f -d" t)
       (gnus-summary-mark-as-expirable 1))


File: gnus,  Node: Hashcash,  Prev: SpamAssassin,  Up: Thwarting Email Spam

8.19.4 Hashcash
---------------

A novel technique to fight spam is to require senders to do something
costly and demonstrably unique for each message they send.  This has
the obvious drawback that you cannot rely on everyone in the world
using this technique, since it is not part of the Internet standards,
but it may be useful in smaller communities.

   While the tools in the previous section work well in practice, they
work only because the tools are constantly maintained and updated as
new form of spam appears.  This means that a small percentage of spam
will always get through.  It also means that somewhere, someone needs
to read lots of spam to update these tools.  Hashcash avoids that, but
instead prefers that everyone you contact through e-mail supports the
scheme.  You can view the two approaches as pragmatic vs dogmatic.  The
approaches have their own advantages and disadvantages, but as often in
the real world, a combination of them is stronger than either one of
them separately.

   The "something costly" is to burn CPU time, more specifically to
compute a hash collision up to a certain number of bits.  The resulting
hashcash cookie is inserted in a `X-Hashcash:' header.  For more
details, and for the external application `hashcash' you need to
install to use this feature, see `http://www.hashcash.org/'.  Even more
information can be found at `http://www.camram.org/'.

   If you wish to generate hashcash for each message you send, you can
customize `message-generate-hashcash' (*note Mail Headers:
(message)Mail Headers.), as in:

     (setq message-generate-hashcash t)

   You will need to set up some additional variables as well:

`hashcash-default-payment'
     This variable indicates the default number of bits the hash
     collision should consist of.  By default this is 20.  Suggested
     useful values include 17 to 29.

`hashcash-payment-alist'
     Some receivers may require you to spend burn more CPU time than the
     default.  This variable contains a list of `(ADDR AMOUNT)' cells,
     where ADDR is the receiver (email address or newsgroup) and AMOUNT
     is the number of bits in the collision that is needed.  It can
     also contain `(ADDR STRING AMOUNT)' cells, where the STRING is the
     string to use (normally the email address or newsgroup name is
     used).

`hashcash-path'
     Where the `hashcash' binary is installed.  This variable should be
     automatically set by `executable-find', but if it's `nil' (usually
     because the `hashcash' binary is not in your path) you'll get a
     warning when you check hashcash payments and an error when you
     generate hashcash payments.


   Gnus can verify hashcash cookies, although this can also be done by
hand customized mail filtering scripts.  To verify a hashcash cookie in
a message, use the `mail-check-payment' function in the `hashcash.el'
library.  You can also use the `spam.el' package with the
`spam-use-hashcash' back end to validate hashcash cookies in incoming
mail and filter mail accordingly (*note Anti-spam Hashcash Payments::).


File: gnus,  Node: Spam Package,  Next: The Gnus Registry,  Prev: Thwarting Email Spam,  Up: Various

8.20 Spam Package
=================

The Spam package provides Gnus with a centralized mechanism for
detecting and filtering spam.  It filters new mail, and processes
messages according to whether they are spam or ham.  ("Ham" is the name
used throughout this manual to indicate non-spam messages.)

* Menu:

* Spam Package Introduction::
* Filtering Incoming Mail::
* Detecting Spam in Groups::
* Spam and Ham Processors::
* Spam Package Configuration Examples::
* Spam Back Ends::
* Extending the Spam package::
* Spam Statistics Package::


File: gnus,  Node: Spam Package Introduction,  Next: Filtering Incoming Mail,  Up: Spam Package

8.20.1 Spam Package Introduction
--------------------------------

You must read this section to understand how the Spam package works.
Do not skip, speed-read, or glance through this section.

   Make sure you read the section on the `spam.el' sequence of events.
See *Note Extending the Spam package::.

   To use the Spam package, you *must* first run the function
`spam-initialize':

     (spam-initialize)

   This autoloads `spam.el' and installs the various hooks necessary to
let the Spam package do its job.  In order to make use of the Spam
package, you have to set up certain group parameters and variables,
which we will describe below.  All of the variables controlling the
Spam package can be found in the `spam' customization group.

   There are two "contact points" between the Spam package and the rest
of Gnus: checking new mail for spam, and leaving a group.

   Checking new mail for spam is done in one of two ways: while
splitting incoming mail, or when you enter a group.

   The first way, checking for spam while splitting incoming mail, is
suited to mail back ends such as `nnml' or `nnimap', where new mail
appears in a single spool file.  The Spam package processes incoming
mail, and sends mail considered to be spam to a designated "spam"
group.  *Note Filtering Incoming Mail::.

   The second way is suited to back ends such as `nntp', which have no
incoming mail spool, or back ends where the server is in charge of
splitting incoming mail.  In this case, when you enter a Gnus group,
the unseen or unread messages in that group are checked for spam.
Detected spam messages are marked as spam.  *Note Detecting Spam in
Groups::.

   In either case, you have to tell the Spam package what method to use
to detect spam messages.  There are several methods, or "spam back
ends" (not to be confused with Gnus back ends!) to choose from: spam
"blacklists" and "whitelists", dictionary-based filters, and so forth.
*Note Spam Back Ends::.

   In the Gnus summary buffer, messages that have been identified as
spam always appear with a `$' symbol.

   The Spam package divides Gnus groups into three categories: ham
groups, spam groups, and unclassified groups.  You should mark each of
the groups you subscribe to as either a ham group or a spam group,
using the `spam-contents' group parameter (*note Group Parameters::).
Spam groups have a special property: when you enter a spam group, all
unseen articles are marked as spam.  Thus, mail split into a spam group
is automatically marked as spam.

   Identifying spam messages is only half of the Spam package's job.
The second half comes into play whenever you exit a group buffer.  At
this point, the Spam package does several things:

   First, it calls "spam and ham processors" to process the articles
according to whether they are spam or ham.  There is a pair of spam and
ham processors associated with each spam back end, and what the
processors do depends on the back end.  At present, the main role of
spam and ham processors is for dictionary-based spam filters: they add
the contents of the messages in the group to the filter's dictionary,
to improve its ability to detect future spam.  The `spam-process' group
parameter specifies what spam processors to use.  *Note Spam and Ham
Processors::.

   If the spam filter failed to mark a spam message, you can mark it
yourself, so that the message is processed as spam when you exit the
group:

`M-d'
`M s x'
`S x'
     Mark current article as spam, showing it with the `$' mark
     (`gnus-summary-mark-as-spam').

Similarly, you can unmark an article if it has been erroneously marked
as spam.  *Note Setting Marks::.

   Normally, a ham message found in a non-ham group is not processed as
ham--the rationale is that it should be moved into a ham group for
further processing (see below).  However, you can force these articles
to be processed as ham by setting `spam-process-ham-in-spam-groups' and
`spam-process-ham-in-nonham-groups'.

   The second thing that the Spam package does when you exit a group is
to move ham articles out of spam groups, and spam articles out of ham
groups.  Ham in a spam group is moved to the group specified by the
variable `gnus-ham-process-destinations', or the group parameter
`ham-process-destination'.  Spam in a ham group is moved to the group
specified by the variable `gnus-spam-process-destinations', or the
group parameter `spam-process-destination'.  If these variables are not
set, the articles are left in their current group.  If an article
cannot be moved (e.g., with a read-only backend such as NNTP), it is
copied.

   If an article is moved to another group, it is processed again when
you visit the new group.  Normally, this is not a problem, but if you
want each article to be processed only once, load the
`gnus-registry.el' package and set the variable `spam-log-to-registry'
to `t'.  *Note Spam Package Configuration Examples::.

   Normally, spam groups ignore `gnus-spam-process-destinations'.
However, if you set `spam-move-spam-nonspam-groups-only' to `nil', spam
will also be moved out of spam groups, depending on the
`spam-process-destination' parameter.

   The final thing the Spam package does is to mark spam articles as
expired, which is usually the right thing to do.

   If all this seems confusing, don't worry.  Soon it will be as natural
as typing Lisp one-liners on a neural interface... err, sorry, that's
50 years in the future yet.  Just trust us, it's not so bad.


File: gnus,  Node: Filtering Incoming Mail,  Next: Detecting Spam in Groups,  Prev: Spam Package Introduction,  Up: Spam Package

8.20.2 Filtering Incoming Mail
------------------------------

To use the Spam package to filter incoming mail, you must first set up
fancy mail splitting.  *Note Fancy Mail Splitting::.  The Spam package
defines a special splitting function that you can add to your fancy
split variable (either `nnmail-split-fancy' or `nnimap-split-fancy',
depending on your mail back end):

     (: spam-split)

The `spam-split' function scans incoming mail according to your chosen
spam back end(s), and sends messages identified as spam to a spam
group.  By default, the spam group is a group named `spam', but you can
change this by customizing `spam-split-group'.  Make sure the contents
of `spam-split-group' are an unqualified group name.  For instance, in
an `nnimap' server `your-server', the value `spam' means
`nnimap+your-server:spam'.  The value `nnimap+server:spam' is therefore
wrong--it gives the group `nnimap+your-server:nnimap+server:spam'.

   `spam-split' does not modify the contents of messages in any way.

   Note for IMAP users: if you use the `spam-check-bogofilter',
`spam-check-ifile', and `spam-check-stat' spam back ends, you should
also set the variable `nnimap-split-download-body' to `t'.  These spam
back ends are most useful when they can "scan" the full message body.
By default, the nnimap back end only retrieves the message headers;
`nnimap-split-download-body' tells it to retrieve the message bodies as
well.  We don't set this by default because it will slow IMAP down, and
that is not an appropriate decision to make on behalf of the user.
*Note Splitting in IMAP::.

   You have to specify one or more spam back ends for `spam-split' to
use, by setting the `spam-use-*' variables.  *Note Spam Back Ends::.
Normally, `spam-split' simply uses all the spam back ends you enabled
in this way.  However, you can tell `spam-split' to use only some of
them.  Why this is useful?  Suppose you are using the
`spam-use-regex-headers' and `spam-use-blackholes' spam back ends, and
the following split rule:

      nnimap-split-fancy '(|
                           (any "ding" "ding")
                           (: spam-split)
                           ;; default mailbox
                           "mail")

The problem is that you want all ding messages to make it to the ding
folder.  But that will let obvious spam (for example, spam detected by
SpamAssassin, and `spam-use-regex-headers') through, when it's sent to
the ding list.  On the other hand, some messages to the ding list are
from a mail server in the blackhole list, so the invocation of
`spam-split' can't be before the ding rule.

   The solution is to let SpamAssassin headers supersede ding rules, and
perform the other `spam-split' rules (including a second invocation of
the regex-headers check) after the ding rule.  This is done by passing
a parameter to `spam-split':

     nnimap-split-fancy
           '(|
             ;; spam detected by `spam-use-regex-headers' goes to `regex-spam'
             (: spam-split "regex-spam" 'spam-use-regex-headers)
             (any "ding" "ding")
             ;; all other spam detected by spam-split goes to `spam-split-group'
             (: spam-split)
             ;; default mailbox
             "mail")

This lets you invoke specific `spam-split' checks depending on your
particular needs, and target the results of those checks to a
particular spam group.  You don't have to throw all mail into all the
spam tests.  Another reason why this is nice is that messages to
mailing lists you have rules for don't have to have resource-intensive
blackhole checks performed on them.  You could also specify different
spam checks for your nnmail split vs. your nnimap split.  Go crazy.

   You should set the `spam-use-*' variables for whatever spam back
ends you intend to use.  The reason is that when loading `spam.el',
some conditional loading is done depending on what `spam-use-xyz'
variables you have set.  *Note Spam Back Ends::.


File: gnus,  Node: Detecting Spam in Groups,  Next: Spam and Ham Processors,  Prev: Filtering Incoming Mail,  Up: Spam Package

8.20.3 Detecting Spam in Groups
-------------------------------

To detect spam when visiting a group, set the group's `spam-autodetect'
and `spam-autodetect-methods' group parameters.  These are accessible
with `G c' or `G p', as usual (*note Group Parameters::).

   You should set the `spam-use-*' variables for whatever spam back
ends you intend to use.  The reason is that when loading `spam.el',
some conditional loading is done depending on what `spam-use-xyz'
variables you have set.

   By default, only unseen articles are processed for spam.  You can
force Gnus to recheck all messages in the group by setting the variable
`spam-autodetect-recheck-messages' to `t'.

   If you use the `spam-autodetect' method of checking for spam, you
can specify different spam detection methods for different groups.  For
instance, the `ding' group may have `spam-use-BBDB' as the
autodetection method, while the `suspect' group may have the
`spam-use-blacklist' and `spam-use-bogofilter' methods enabled.  Unlike
with `spam-split', you don't have any control over the _sequence_ of
checks, but this is probably unimportant.


File: gnus,  Node: Spam and Ham Processors,  Next: Spam Package Configuration Examples,  Prev: Detecting Spam in Groups,  Up: Spam Package

8.20.4 Spam and Ham Processors
------------------------------

Spam and ham processors specify special actions to take when you exit a
group buffer.  Spam processors act on spam messages, and ham processors
on ham messages.  At present, the main role of these processors is to
update the dictionaries of dictionary-based spam back ends such as
Bogofilter (*note Bogofilter::) and the Spam Statistics package (*note
Spam Statistics Filtering::).

   The spam and ham processors that apply to each group are determined
by the group's`spam-process' group parameter.  If this group parameter
is not defined, they are determined by the variable
`gnus-spam-process-newsgroups'.

   Gnus learns from the spam you get.  You have to collect your spam in
one or more spam groups, and set or customize the variable
`spam-junk-mailgroups' as appropriate.  You can also declare groups to
contain spam by setting their group parameter `spam-contents' to
`gnus-group-spam-classification-spam', or by customizing the
corresponding variable `gnus-spam-newsgroup-contents'.  The
`spam-contents' group parameter and the `gnus-spam-newsgroup-contents'
variable can also be used to declare groups as _ham_ groups if you set
their classification to `gnus-group-spam-classification-ham'.  If
groups are not classified by means of `spam-junk-mailgroups',
`spam-contents', or `gnus-spam-newsgroup-contents', they are considered
_unclassified_.  All groups are unclassified by default.

   In spam groups, all messages are considered to be spam by default:
they get the `$' mark (`gnus-spam-mark') when you enter the group.  If
you have seen a message, had it marked as spam, then unmarked it, it
won't be marked as spam when you enter the group thereafter.  You can
disable that behavior, so all unread messages will get the `$' mark, if
you set the `spam-mark-only-unseen-as-spam' parameter to `nil'.  You
should remove the `$' mark when you are in the group summary buffer for
every message that is not spam after all.  To remove the `$' mark, you
can use `M-u' to "unread" the article, or `d' for declaring it read the
non-spam way.  When you leave a group, all spam-marked (`$') articles
are sent to a spam processor which will study them as spam samples.

   Messages may also be deleted in various other ways, and unless
`ham-marks' group parameter gets overridden below, marks `R' and `r'
for default read or explicit delete, marks `X' and `K' for automatic or
explicit kills, as well as mark `Y' for low scores, are all considered
to be associated with articles which are not spam.  This assumption
might be false, in particular if you use kill files or score files as
means for detecting genuine spam, you should then adjust the
`ham-marks' group parameter.

 -- Variable: ham-marks
     You can customize this group or topic parameter to be the list of
     marks you want to consider ham.  By default, the list contains the
     deleted, read, killed, kill-filed, and low-score marks (the idea is
     that these articles have been read, but are not spam).  It can be
     useful to also include the tick mark in the ham marks.  It is not
     recommended to make the unread mark a ham mark, because it normally
     indicates a lack of classification.  But you can do it, and we'll
     be happy for you.

 -- Variable: spam-marks
     You can customize this group or topic parameter to be the list of
     marks you want to consider spam.  By default, the list contains
     only the spam mark.  It is not recommended to change that, but you
     can if you really want to.

   When you leave _any_ group, regardless of its `spam-contents'
classification, all spam-marked articles are sent to a spam processor,
which will study these as spam samples.  If you explicit kill a lot,
you might sometimes end up with articles marked `K' which you never
saw, and which might accidentally contain spam.  Best is to make sure
that real spam is marked with `$', and nothing else.

   When you leave a _spam_ group, all spam-marked articles are marked
as expired after processing with the spam processor.  This is not done
for _unclassified_ or _ham_ groups.  Also, any *ham* articles in a spam
group will be moved to a location determined by either the
`ham-process-destination' group parameter or a match in the
`gnus-ham-process-destinations' variable, which is a list of regular
expressions matched with group names (it's easiest to customize this
variable with `M-x customize-variable <RET>
gnus-ham-process-destinations').  Each group name list is a standard
Lisp list, if you prefer to customize the variable manually.  If the
`ham-process-destination' parameter is not set, ham articles are left
in place.  If the `spam-mark-ham-unread-before-move-from-spam-group'
parameter is set, the ham articles are marked as unread before being
moved.

   If ham can not be moved--because of a read-only back end such as
NNTP, for example, it will be copied.

   Note that you can use multiples destinations per group or regular
expression!  This enables you to send your ham to a regular mail group
and to a _ham training_ group.

   When you leave a _ham_ group, all ham-marked articles are sent to a
ham processor, which will study these as non-spam samples.

   By default the variable `spam-process-ham-in-spam-groups' is `nil'.
Set it to `t' if you want ham found in spam groups to be processed.
Normally this is not done, you are expected instead to send your ham to
a ham group and process it there.

   By default the variable `spam-process-ham-in-nonham-groups' is
`nil'.  Set it to `t' if you want ham found in non-ham (spam or
unclassified) groups to be processed.  Normally this is not done, you
are expected instead to send your ham to a ham group and process it
there.

   When you leave a _ham_ or _unclassified_ group, all *spam* articles
are moved to a location determined by either the
`spam-process-destination' group parameter or a match in the
`gnus-spam-process-destinations' variable, which is a list of regular
expressions matched with group names (it's easiest to customize this
variable with `M-x customize-variable <RET>
gnus-spam-process-destinations').  Each group name list is a standard
Lisp list, if you prefer to customize the variable manually.  If the
`spam-process-destination' parameter is not set, the spam articles are
only expired.  The group name is fully qualified, meaning that if you
see `nntp:servername' before the group name in the group buffer then
you need it here as well.

   If spam can not be moved--because of a read-only back end such as
NNTP, for example, it will be copied.

   Note that you can use multiples destinations per group or regular
expression!  This enables you to send your spam to multiple _spam
training_ groups.

   The problem with processing ham and spam is that Gnus doesn't track
this processing by default.  Enable the `spam-log-to-registry' variable
so `spam.el' will use `gnus-registry.el' to track what articles have
been processed, and avoid processing articles multiple times.  Keep in
mind that if you limit the number of registry entries, this won't work
as well as it does without a limit.

   Set this variable if you want only unseen articles in spam groups to
be marked as spam.  By default, it is set.  If you set it to `nil',
unread articles will also be marked as spam.

   Set this variable if you want ham to be unmarked before it is moved
out of the spam group.  This is very useful when you use something like
the tick mark `!' to mark ham--the article will be placed in your
`ham-process-destination', unmarked as if it came fresh from the mail
server.

   When autodetecting spam, this variable tells `spam.el' whether only
unseen articles or all unread articles should be checked for spam.  It
is recommended that you leave it off.


File: gnus,  Node: Spam Package Configuration Examples,  Next: Spam Back Ends,  Prev: Spam and Ham Processors,  Up: Spam Package

8.20.5 Spam Package Configuration Examples
------------------------------------------

Ted's setup
...........

From Ted Zlatanov <tzz@lifelogs.com>.
     ;; for `gnus-registry-split-fancy-with-parent' and spam autodetection
     ;; see `gnus-registry.el' for more information
     (gnus-registry-initialize)
     (spam-initialize)

     (setq
      spam-log-to-registry t     ; for spam autodetection
      spam-use-BBDB t
      spam-use-regex-headers t   ; catch X-Spam-Flag (SpamAssassin)
      ;; all groups with `spam' in the name contain spam
      gnus-spam-newsgroup-contents
       '(("spam" gnus-group-spam-classification-spam))
      ;; see documentation for these
      spam-move-spam-nonspam-groups-only nil
      spam-mark-only-unseen-as-spam t
      spam-mark-ham-unread-before-move-from-spam-group t
      nnimap-split-rule 'nnimap-split-fancy
      ;; understand what this does before you copy it to your own setup!
      nnimap-split-fancy '(|
                           ;; trace references to parents and put in their group
                           (: gnus-registry-split-fancy-with-parent)
                           ;; this will catch server-side SpamAssassin tags
                           (: spam-split 'spam-use-regex-headers)
                           (any "ding" "ding")
                           ;; note that spam by default will go to `spam'
                           (: spam-split)
                           ;; default mailbox
                           "mail"))

     ;; my parameters, set with `G p'

     ;; all nnml groups, and all nnimap groups except
     ;; `nnimap+mail.lifelogs.com:train' and
     ;; `nnimap+mail.lifelogs.com:spam': any spam goes to nnimap training,
     ;; because it must have been detected manually

     ((spam-process-destination . "nnimap+mail.lifelogs.com:train"))

     ;; all NNTP groups
     ;; autodetect spam with the blacklist and ham with the BBDB
     ((spam-autodetect-methods spam-use-blacklist spam-use-BBDB)
     ;; send all spam to the training group
      (spam-process-destination . "nnimap+mail.lifelogs.com:train"))

     ;; only some NNTP groups, where I want to autodetect spam
     ((spam-autodetect . t))

     ;; my nnimap `nnimap+mail.lifelogs.com:spam' group

     ;; this is a spam group
     ((spam-contents gnus-group-spam-classification-spam)

      ;; any spam (which happens when I enter for all unseen messages,
      ;; because of the `gnus-spam-newsgroup-contents' setting above), goes to
      ;; `nnimap+mail.lifelogs.com:train' unless I mark it as ham

      (spam-process-destination "nnimap+mail.lifelogs.com:train")

      ;; any ham goes to my `nnimap+mail.lifelogs.com:mail' folder, but
      ;; also to my `nnimap+mail.lifelogs.com:trainham' folder for training

      (ham-process-destination "nnimap+mail.lifelogs.com:mail"
                               "nnimap+mail.lifelogs.com:trainham")
      ;; in this group, only `!' marks are ham
      (ham-marks
       (gnus-ticked-mark))
      ;; remembers senders in the blacklist on the way out--this is
      ;; definitely not needed, it just makes me feel better
      (spam-process (gnus-group-spam-exit-processor-blacklist)))

     ;; Later, on the IMAP server I use the `train' group for training
     ;; SpamAssassin to recognize spam, and the `trainham' group fora
     ;; recognizing ham--but Gnus has nothing to do with it.

Using `spam.el' on an IMAP server with a statistical filter on the server
.........................................................................

From Reiner Steib <reiner.steib@gmx.de>.

   My provider has set up bogofilter (in combination with DCC) on the
mail server (IMAP).  Recognized spam goes to `spam.detected', the rest
goes through the normal filter rules, i.e. to `some.folder' or to
`INBOX'.  Training on false positives or negatives is done by copying
or moving the article to `training.ham' or `training.spam'
respectively.  A cron job on the server feeds those to bogofilter with
the suitable ham or spam options and deletes them from the
`training.ham' and `training.spam' folders.

   With the following entries in `gnus-parameters', `spam.el' does most
of the job for me:

        ("nnimap:spam\\.detected"
         (gnus-article-sort-functions '(gnus-article-sort-by-chars))
         (ham-process-destination "nnimap:INBOX" "nnimap:training.ham")
         (spam-contents gnus-group-spam-classification-spam))
        ("nnimap:\\(INBOX\\|other-folders\\)"
         (spam-process-destination . "nnimap:training.spam")
         (spam-contents gnus-group-spam-classification-ham))

   * The Spam folder:

     In the folder `spam.detected', I have to check for false positives
     (i.e. legitimate mails, that were wrongly judged as spam by
     bogofilter or DCC).

     Because of the `gnus-group-spam-classification-spam' entry, all
     messages are marked as spam (with `$').  When I find a false
     positive, I mark the message with some other ham mark
     (`ham-marks', *note Spam and Ham Processors::).  On group exit,
     those messages are copied to both groups, `INBOX' (where I want to
     have the article) and `training.ham' (for training bogofilter) and
     deleted from the `spam.detected' folder.

     The `gnus-article-sort-by-chars' entry simplifies detection of
     false positives for me.  I receive lots of worms (sweN, ...), that
     all have a similar size.  Grouping them by size (i.e. chars) makes
     finding other false positives easier.  (Of course worms aren't spam
     (UCE, UBE) strictly speaking.  Anyhow, bogofilter is an excellent
     tool for filtering those unwanted mails for me.)

   * Ham folders:

     In my ham folders, I just hit `S x' (`gnus-summary-mark-as-spam')
     whenever I see an unrecognized spam mail (false negative).  On
     group exit, those messages are moved to `training.spam'.

Reporting spam articles in Gmane groups with `spam-report.el'
.............................................................

From Reiner Steib <reiner.steib@gmx.de>.

   With following entry in `gnus-parameters', `S x'
(`gnus-summary-mark-as-spam') marks articles in `gmane.*' groups as
spam and reports the to Gmane at group exit:

        ("^gmane\\."
         (spam-process (gnus-group-spam-exit-processor-report-gmane)))

   Additionally, I use `(setq spam-report-gmane-use-article-number nil)'
because I don't read the groups directly from news.gmane.org, but
through my local news server (leafnode).  I.e. the article numbers are
not the same as on news.gmane.org, thus `spam-report.el' has to check
the `X-Report-Spam' header to find the correct number.


File: gnus,  Node: Spam Back Ends,  Next: Extending the Spam package,  Prev: Spam Package Configuration Examples,  Up: Spam Package

8.20.6 Spam Back Ends
---------------------

The spam package offers a variety of back ends for detecting spam.
Each back end defines a set of methods for detecting spam (*note
Filtering Incoming Mail::, *note Detecting Spam in Groups::), and a
pair of spam and ham processors (*note Spam and Ham Processors::).

* Menu:

* Blacklists and Whitelists::
* BBDB Whitelists::
* Gmane Spam Reporting::
* Anti-spam Hashcash Payments::
* Blackholes::
* Regular Expressions Header Matching::
* Bogofilter::
* SpamAssassin back end::
* ifile spam filtering::
* Spam Statistics Filtering::
* SpamOracle::


File: gnus,  Node: Blacklists and Whitelists,  Next: BBDB Whitelists,  Up: Spam Back Ends

8.20.6.1 Blacklists and Whitelists
..................................

 -- Variable: spam-use-blacklist
     Set this variable to `t' if you want to use blacklists when
     splitting incoming mail.  Messages whose senders are in the
     blacklist will be sent to the `spam-split-group'.  This is an
     explicit filter, meaning that it acts only on mail senders
     _declared_ to be spammers.


 -- Variable: spam-use-whitelist
     Set this variable to `t' if you want to use whitelists when
     splitting incoming mail.  Messages whose senders are not in the
     whitelist will be sent to the next spam-split rule.  This is an
     explicit filter, meaning that unless someone is in the whitelist,
     their messages are not assumed to be spam or ham.


 -- Variable: spam-use-whitelist-exclusive
     Set this variable to `t' if you want to use whitelists as an
     implicit filter, meaning that every message will be considered spam
     unless the sender is in the whitelist.  Use with care.


 -- Variable: gnus-group-spam-exit-processor-blacklist
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameters or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is
     added to a group's `spam-process' parameter, the senders of
     spam-marked articles will be added to the blacklist.

     _WARNING_

     Instead of the obsolete
     `gnus-group-spam-exit-processor-blacklist', it is recommended that
     you use `(spam spam-use-blacklist)'.  Everything will work the
     same way, we promise.


 -- Variable: gnus-group-ham-exit-processor-whitelist
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameters or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is
     added to a group's `spam-process' parameter, the senders of
     ham-marked articles in _ham_ groups will be added to the whitelist.

     _WARNING_

     Instead of the obsolete `gnus-group-ham-exit-processor-whitelist',
     it is recommended that you use `(ham spam-use-whitelist)'.
     Everything will work the same way, we promise.


   Blacklists are lists of regular expressions matching addresses you
consider to be spam senders.  For instance, to block mail from any
sender at `vmadmin.com', you can put `vmadmin.com' in your blacklist.
You start out with an empty blacklist.  Blacklist entries use the Emacs
regular expression syntax.

   Conversely, whitelists tell Gnus what addresses are considered
legitimate.  All messages from whitelisted addresses are considered
non-spam.  Also see *note BBDB Whitelists::.  Whitelist entries use the
Emacs regular expression syntax.

   The blacklist and whitelist file locations can be customized with the
`spam-directory' variable (`~/News/spam' by default), or the
`spam-whitelist' and `spam-blacklist' variables directly.  The
whitelist and blacklist files will by default be in the
`spam-directory' directory, named `whitelist' and `blacklist'
respectively.


File: gnus,  Node: BBDB Whitelists,  Next: Gmane Spam Reporting,  Prev: Blacklists and Whitelists,  Up: Spam Back Ends

8.20.6.2 BBDB Whitelists
........................

 -- Variable: spam-use-BBDB
     Analogous to `spam-use-whitelist' (*note Blacklists and
     Whitelists::), but uses the BBDB as the source of whitelisted
     addresses, without regular expressions.  You must have the BBDB
     loaded for `spam-use-BBDB' to work properly.  Messages whose
     senders are not in the BBDB will be sent to the next spam-split
     rule.  This is an explicit filter, meaning that unless someone is
     in the BBDB, their messages are not assumed to be spam or ham.


 -- Variable: spam-use-BBDB-exclusive
     Set this variable to `t' if you want to use the BBDB as an
     implicit filter, meaning that every message will be considered spam
     unless the sender is in the BBDB.  Use with care.  Only sender
     addresses in the BBDB will be allowed through; all others will be
     classified as spammers.

     While `spam-use-BBDB-exclusive' _can_ be used as an alias for
     `spam-use-BBDB' as far as `spam.el' is concerned, it is _not_ a
     separate back end.  If you set `spam-use-BBDB-exclusive' to t,
     _all_ your BBDB splitting will be exclusive.


 -- Variable: gnus-group-ham-exit-processor-BBDB
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameters or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is
     added to a group's `spam-process' parameter, the senders of
     ham-marked articles in _ham_ groups will be added to the BBDB.

     _WARNING_

     Instead of the obsolete `gnus-group-ham-exit-processor-BBDB', it
     is recommended that you use `(ham spam-use-BBDB)'.  Everything
     will work the same way, we promise.



File: gnus,  Node: Gmane Spam Reporting,  Next: Anti-spam Hashcash Payments,  Prev: BBDB Whitelists,  Up: Spam Back Ends

8.20.6.3 Gmane Spam Reporting
.............................

 -- Variable: gnus-group-spam-exit-processor-report-gmane
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameters or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is
     added to a group's `spam-process' parameter, the spam-marked
     articles groups will be reported to the Gmane administrators via a
     HTTP request.

     Gmane can be found at `http://gmane.org'.

     _WARNING_

     Instead of the obsolete
     `gnus-group-spam-exit-processor-report-gmane', it is recommended
     that you use `(spam spam-use-gmane)'.  Everything will work the
     same way, we promise.


 -- Variable: spam-report-gmane-use-article-number
     This variable is `t' by default.  Set it to `nil' if you are
     running your own news server, for instance, and the local article
     numbers don't correspond to the Gmane article numbers.  When
     `spam-report-gmane-use-article-number' is `nil', `spam-report.el'
     will fetch the number from the article headers.


 -- Variable: spam-report-user-mail-address
     Mail address exposed in the User-Agent spam reports to Gmane.  It
     allows the Gmane administrators to contact you in case of
     misreports.  The default is `user-mail-address'.



File: gnus,  Node: Anti-spam Hashcash Payments,  Next: Blackholes,  Prev: Gmane Spam Reporting,  Up: Spam Back Ends

8.20.6.4 Anti-spam Hashcash Payments
....................................

 -- Variable: spam-use-hashcash
     Similar to `spam-use-whitelist' (*note Blacklists and
     Whitelists::), but uses hashcash tokens for whitelisting messages
     instead of the sender address.  Messages without a hashcash payment
     token will be sent to the next spam-split rule.  This is an
     explicit filter, meaning that unless a hashcash token is found,
     the messages are not assumed to be spam or ham.



File: gnus,  Node: Blackholes,  Next: Regular Expressions Header Matching,  Prev: Anti-spam Hashcash Payments,  Up: Spam Back Ends

8.20.6.5 Blackholes
...................

 -- Variable: spam-use-blackholes
     This option is disabled by default.  You can let Gnus consult the
     blackhole-type distributed spam processing systems (DCC, for
     instance) when you set this option.  The variable
     `spam-blackhole-servers' holds the list of blackhole servers Gnus
     will consult.  The current list is fairly comprehensive, but make
     sure to let us know if it contains outdated servers.

     The blackhole check uses the `dig.el' package, but you can tell
     `spam.el' to use `dns.el' instead for better performance if you
     set `spam-use-dig' to `nil'.  It is not recommended at this time
     to set `spam-use-dig' to `nil' despite the possible performance
     improvements, because some users may be unable to use it, but you
     can try it and see if it works for you.


 -- Variable: spam-blackhole-servers
     The list of servers to consult for blackhole checks.


 -- Variable: spam-blackhole-good-server-regex
     A regular expression for IPs that should not be checked against the
     blackhole server list.  When set to `nil', it has no effect.


 -- Variable: spam-use-dig
     Use the `dig.el' package instead of the `dns.el' package.  The
     default setting of `t' is recommended.


   Blackhole checks are done only on incoming mail.  There is no spam or
ham processor for blackholes.


File: gnus,  Node: Regular Expressions Header Matching,  Next: Bogofilter,  Prev: Blackholes,  Up: Spam Back Ends

8.20.6.6 Regular Expressions Header Matching
............................................

 -- Variable: spam-use-regex-headers
     This option is disabled by default.  You can let Gnus check the
     message headers against lists of regular expressions when you set
     this option.  The variables `spam-regex-headers-spam' and
     `spam-regex-headers-ham' hold the list of regular expressions.
     Gnus will check against the message headers to determine if the
     message is spam or ham, respectively.


 -- Variable: spam-regex-headers-spam
     The list of regular expressions that, when matched in the headers
     of the message, positively identify it as spam.


 -- Variable: spam-regex-headers-ham
     The list of regular expressions that, when matched in the headers
     of the message, positively identify it as ham.


   Regular expression header checks are done only on incoming mail.
There is no specific spam or ham processor for regular expressions.


File: gnus,  Node: Bogofilter,  Next: SpamAssassin back end,  Prev: Regular Expressions Header Matching,  Up: Spam Back Ends

8.20.6.7 Bogofilter
...................

 -- Variable: spam-use-bogofilter
     Set this variable if you want `spam-split' to use Eric Raymond's
     speedy Bogofilter.

     With a minimum of care for associating the `$' mark for spam
     articles only, Bogofilter training all gets fairly automatic.  You
     should do this until you get a few hundreds of articles in each
     category, spam or not.  The command `S t' in summary mode, either
     for debugging or for curiosity, shows the _spamicity_ score of the
     current article (between 0.0 and 1.0).

     Bogofilter determines if a message is spam based on a specific
     threshold.  That threshold can be customized, consult the
     Bogofilter documentation.

     If the `bogofilter' executable is not in your path, Bogofilter
     processing will be turned off.

     You should not enable this if you use
     `spam-use-bogofilter-headers'.


`M s t'
`S t'
     Get the Bogofilter spamicity score (`spam-bogofilter-score').

 -- Variable: spam-use-bogofilter-headers
     Set this variable if you want `spam-split' to use Eric Raymond's
     speedy Bogofilter, looking only at the message headers.  It works
     similarly to `spam-use-bogofilter', but the `X-Bogosity' header
     must be in the message already.  Normally you would do this with a
     procmail recipe or something similar; consult the Bogofilter
     installation documents for details.

     You should not enable this if you use `spam-use-bogofilter'.


 -- Variable: gnus-group-spam-exit-processor-bogofilter
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameters or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is
     added to a group's `spam-process' parameter, spam-marked articles
     will be added to the Bogofilter spam database.

     _WARNING_

     Instead of the obsolete
     `gnus-group-spam-exit-processor-bogofilter', it is recommended
     that you use `(spam spam-use-bogofilter)'.  Everything will work
     the same way, we promise.

 -- Variable: gnus-group-ham-exit-processor-bogofilter
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameters or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is
     added to a group's `spam-process' parameter, the ham-marked
     articles in _ham_ groups will be added to the Bogofilter database
     of non-spam messages.

     _WARNING_

     Instead of the obsolete
     `gnus-group-ham-exit-processor-bogofilter', it is recommended that
     you use `(ham spam-use-bogofilter)'.  Everything will work the
     same way, we promise.

 -- Variable: spam-bogofilter-database-directory
     This is the directory where Bogofilter will store its databases.
     It is not specified by default, so Bogofilter will use its own
     default database directory.


   The Bogofilter mail classifier is similar to `ifile' in intent and
purpose.  A ham and a spam processor are provided, plus the
`spam-use-bogofilter' and `spam-use-bogofilter-headers' variables to
indicate to spam-split that Bogofilter should either be used, or has
already been used on the article.  The 0.9.2.1 version of Bogofilter
was used to test this functionality.


File: gnus,  Node: SpamAssassin back end,  Next: ifile spam filtering,  Prev: Bogofilter,  Up: Spam Back Ends

8.20.6.8 SpamAssassin back end
..............................

 -- Variable: spam-use-spamassassin
     Set this variable if you want `spam-split' to use SpamAssassin.

     SpamAssassin assigns a score to each article based on a set of
     rules and tests, including a Bayesian filter.  The Bayesian filter
     can be trained by associating the `$' mark for spam articles.  The
     spam score can be viewed by using the command `S t' in summary
     mode.

     If you set this variable, each article will be processed by
     SpamAssassin when `spam-split' is called.  If your mail is
     preprocessed by SpamAssassin, and you want to just use the
     SpamAssassin headers, set `spam-use-spamassassin-headers' instead.

     You should not enable this if you use
     `spam-use-spamassassin-headers'.


 -- Variable: spam-use-spamassassin-headers
     Set this variable if your mail is preprocessed by SpamAssassin and
     want `spam-split' to split based on the SpamAssassin headers.

     You should not enable this if you use `spam-use-spamassassin'.


 -- Variable: spam-spamassassin-program
     This variable points to the SpamAssassin executable.  If you have
     `spamd' running, you can set this variable to the `spamc'
     executable for faster processing.  See the SpamAssassin
     documentation for more information on `spamd'/`spamc'.


   SpamAssassin is a powerful and flexible spam filter that uses a wide
variety of tests to identify spam.  A ham and a spam processors are
provided, plus the `spam-use-spamassassin' and
`spam-use-spamassassin-headers' variables to indicate to spam-split
that SpamAssassin should be either used, or has already been used on
the article.  The 2.63 version of SpamAssassin was used to test this
functionality.


File: gnus,  Node: ifile spam filtering,  Next: Spam Statistics Filtering,  Prev: SpamAssassin back end,  Up: Spam Back Ends

8.20.6.9 ifile spam filtering
.............................

 -- Variable: spam-use-ifile
     Enable this variable if you want `spam-split' to use `ifile', a
     statistical analyzer similar to Bogofilter.


 -- Variable: spam-ifile-all-categories
     Enable this variable if you want `spam-use-ifile' to give you all
     the ifile categories, not just spam/non-spam.  If you use this,
     make sure you train ifile as described in its documentation.


 -- Variable: spam-ifile-spam-category
     This is the category of spam messages as far as ifile is concerned.
     The actual string used is irrelevant, but you probably want to
     leave the default value of `spam'.

 -- Variable: spam-ifile-database
     This is the filename for the ifile database.  It is not specified
     by default, so ifile will use its own default database name.


   The ifile mail classifier is similar to Bogofilter in intent and
purpose.  A ham and a spam processor are provided, plus the
`spam-use-ifile' variable to indicate to spam-split that ifile should
be used.  The 1.2.1 version of ifile was used to test this
functionality.


File: gnus,  Node: Spam Statistics Filtering,  Next: SpamOracle,  Prev: ifile spam filtering,  Up: Spam Back Ends

8.20.6.10 Spam Statistics Filtering
...................................

This back end uses the Spam Statistics Emacs Lisp package to perform
statistics-based filtering (*note Spam Statistics Package::).  Before
using this, you may want to perform some additional steps to initialize
your Spam Statistics dictionary.  *Note Creating a spam-stat
dictionary::.

 -- Variable: spam-use-stat

 -- Variable: gnus-group-spam-exit-processor-stat
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameters or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is
     added to a group's `spam-process' parameter, the spam-marked
     articles will be added to the spam-stat database of spam messages.

     _WARNING_

     Instead of the obsolete `gnus-group-spam-exit-processor-stat', it
     is recommended that you use `(spam spam-use-stat)'.  Everything
     will work the same way, we promise.

 -- Variable: gnus-group-ham-exit-processor-stat
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameters or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is
     added to a group's `spam-process' parameter, the ham-marked
     articles in _ham_ groups will be added to the spam-stat database
     of non-spam messages.

     _WARNING_

     Instead of the obsolete `gnus-group-ham-exit-processor-stat', it
     is recommended that you use `(ham spam-use-stat)'.  Everything
     will work the same way, we promise.

   This enables `spam.el' to cooperate with `spam-stat.el'.
`spam-stat.el' provides an internal (Lisp-only) spam database, which
unlike ifile or Bogofilter does not require external programs.  A spam
and a ham processor, and the `spam-use-stat' variable for `spam-split'
are provided.


File: gnus,  Node: SpamOracle,  Prev: Spam Statistics Filtering,  Up: Spam Back Ends

8.20.6.11 Using SpamOracle with Gnus
....................................

An easy way to filter out spam is to use SpamOracle.  SpamOracle is an
statistical mail filtering tool written by Xavier Leroy and needs to be
installed separately.

   There are several ways to use SpamOracle with Gnus.  In all cases,
your mail is piped through SpamOracle in its _mark_ mode.  SpamOracle
will then enter an `X-Spam' header indicating whether it regards the
mail as a spam mail or not.

   One possibility is to run SpamOracle as a `:prescript' from the
*Note Mail Source Specifiers::, (*note SpamAssassin::).  This method has
the advantage that the user can see the _X-Spam_ headers.

   The easiest method is to make `spam.el' (*note Spam Package::) call
SpamOracle.

   To enable SpamOracle usage by `spam.el', set the variable
`spam-use-spamoracle' to `t' and configure the `nnmail-split-fancy' or
`nnimap-split-fancy'.  *Note Spam Package::.  In this example the
`INBOX' of an nnimap server is filtered using SpamOracle.  Mails
recognized as spam mails will be moved to `spam-split-group', `Junk' in
this case.  Ham messages stay in `INBOX':

     (setq spam-use-spamoracle t
           spam-split-group "Junk"
           nnimap-split-inbox '("INBOX")
           nnimap-split-rule 'nnimap-split-fancy
           nnimap-split-fancy '(| (: spam-split) "INBOX"))

 -- Variable: spam-use-spamoracle
     Set to `t' if you want Gnus to enable spam filtering using
     SpamOracle.

 -- Variable: spam-spamoracle-binary
     Gnus uses the SpamOracle binary called `spamoracle' found in the
     user's PATH.  Using the variable `spam-spamoracle-binary', this
     can be customized.

 -- Variable: spam-spamoracle-database
     By default, SpamOracle uses the file `~/.spamoracle.db' as a
     database to store its analysis.  This is controlled by the variable
     `spam-spamoracle-database' which defaults to `nil'.  That means
     the default SpamOracle database will be used.  In case you want
     your database to live somewhere special, set
     `spam-spamoracle-database' to this path.

   SpamOracle employs a statistical algorithm to determine whether a
message is spam or ham.  In order to get good results, meaning few
false hits or misses, SpamOracle needs training.  SpamOracle learns the
characteristics of your spam mails.  Using the _add_ mode (training
mode) one has to feed good (ham) and spam mails to SpamOracle.  This
can be done by pressing `|' in the Summary buffer and pipe the mail to
a SpamOracle process or using `spam.el''s spam- and ham-processors,
which is much more convenient.  For a detailed description of spam- and
ham-processors, *Note Spam Package::.

 -- Variable: gnus-group-spam-exit-processor-spamoracle
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameter or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is added
     to a group's `spam-process' parameter, spam-marked articles will be
     sent to SpamOracle as spam samples.

     _WARNING_

     Instead of the obsolete
     `gnus-group-spam-exit-processor-spamoracle', it is recommended
     that you use `(spam spam-use-spamoracle)'.  Everything will work
     the same way, we promise.

 -- Variable: gnus-group-ham-exit-processor-spamoracle
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameter or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is added
     to a group's `spam-process' parameter, the ham-marked articles in
     _ham_ groups will be sent to the SpamOracle as samples of ham
     messages.

     _WARNING_

     Instead of the obsolete
     `gnus-group-ham-exit-processor-spamoracle', it is recommended that
     you use `(ham spam-use-spamoracle)'.  Everything will work the
     same way, we promise.

   _Example:_ These are the Group Parameters of a group that has been
classified as a ham group, meaning that it should only contain ham
messages.
      ((spam-contents gnus-group-spam-classification-ham)
       (spam-process ((ham spam-use-spamoracle)
                      (spam spam-use-spamoracle))))
   For this group the `spam-use-spamoracle' is installed for both ham
and spam processing.  If the group contains spam message (e.g. because
SpamOracle has not had enough sample messages yet) and the user marks
some messages as spam messages, these messages will be processed by
SpamOracle.  The processor sends the messages to SpamOracle as new
samples for spam.


File: gnus,  Node: Extending the Spam package,  Next: Spam Statistics Package,  Prev: Spam Back Ends,  Up: Spam Package

8.20.7 Extending the Spam package
---------------------------------

Say you want to add a new back end called blackbox.  For filtering
incoming mail, provide the following:

  1. Code

          (defvar spam-use-blackbox nil
            "True if blackbox should be used.")

     Write `spam-check-blackbox' if Blackbox can check incoming mail.

     Write `spam-blackbox-register-routine' and
     `spam-blackbox-unregister-routine' using the bogofilter
     register/unregister routines as a start, or other
     restister/unregister routines more appropriate to Blackbox, if
     Blackbox can register/unregister spam and ham.

  2. Functionality

     The `spam-check-blackbox' function should return `nil' or
     `spam-split-group', observing the other conventions.  See the
     existing `spam-check-*' functions for examples of what you can do,
     and stick to the template unless you fully understand the reasons
     why you aren't.


   For processing spam and ham messages, provide the following:

  1. Code

     Note you don't have to provide a spam or a ham processor.  Only
     provide them if Blackbox supports spam or ham processing.

     Also, ham and spam processors are being phased out as single
     variables.  Instead the form `(spam spam-use-blackbox)' or `(ham
     spam-use-blackbox)' is favored.  For now, spam/ham processor
     variables are still around but they won't be for long.

          (defvar gnus-group-spam-exit-processor-blackbox "blackbox-spam"
            "The Blackbox summary exit spam processor.
          Only applicable to spam groups.")

          (defvar gnus-group-ham-exit-processor-blackbox "blackbox-ham"
            "The whitelist summary exit ham processor.
          Only applicable to non-spam (unclassified and ham) groups.")

  2. Gnus parameters

     Add
          (const :tag "Spam: Blackbox" (spam spam-use-blackbox))
          (const :tag "Ham: Blackbox"  (ham spam-use-blackbox))
     to the `spam-process' group parameter in `gnus.el'.  Make sure you
     do it twice, once for the parameter and once for the variable
     customization.

     Add
          (variable-item spam-use-blackbox)
     to the `spam-autodetect-methods' group parameter in `gnus.el' if
     Blackbox can check incoming mail for spam contents.

     Finally, use the appropriate `spam-install-*-backend' function in
     `spam.el'.  Here are the available functions.

       1. `spam-install-backend-alias'

          This function will simply install an alias for a back end
          that does everything like the original back end.  It is
          currently only used to make `spam-use-BBDB-exclusive' act
          like `spam-use-BBDB'.

       2. `spam-install-nocheck-backend'

          This function installs a back end that has no check function,
          but can register/unregister ham or spam.  The
          `spam-use-gmane' back end is such a back end.

       3. `spam-install-checkonly-backend'

          This function will install a back end that can only check
          incoming mail for spam contents.  It can't register or
          unregister messages.  `spam-use-blackholes' and
          `spam-use-hashcash' are such back ends.

       4. `spam-install-statistical-checkonly-backend'

          This function installs a statistical back end (one which
          requires the full body of a message to check it) that can
          only check incoming mail for contents.  `spam-use-regex-body'
          is such a filter.

       5. `spam-install-statistical-backend'

          This function install a statistical back end with incoming
          checks and registration/unregistration routines.
          `spam-use-bogofilter' is set up this way.

       6. `spam-install-backend'

          This is the most normal back end installation, where a back
          end that can check and register/unregister messages is set up
          without statistical abilities.  The `spam-use-BBDB' is such a
          back end.

       7. `spam-install-mover-backend'

          Mover back ends are internal to `spam.el' and specifically
          move articles around when the summary is exited.  You will
          very probably never install such a back end.



File: gnus,  Node: Spam Statistics Package,  Prev: Extending the Spam package,  Up: Spam Package

8.20.8 Spam Statistics Package
------------------------------

Paul Graham has written an excellent essay about spam filtering using
statistics: A Plan for Spam (http://www.paulgraham.com/spam.html).  In
it he describes the inherent deficiency of rule-based filtering as used
by SpamAssassin, for example: Somebody has to write the rules, and
everybody else has to install these rules.  You are always late.  It
would be much better, he argues, to filter mail based on whether it
somehow resembles spam or non-spam.  One way to measure this is word
distribution.  He then goes on to describe a solution that checks
whether a new mail resembles any of your other spam mails or not.

   The basic idea is this:  Create a two collections of your mail, one
with spam, one with non-spam.  Count how often each word appears in
either collection, weight this by the total number of mails in the
collections, and store this information in a dictionary.  For every
word in a new mail, determine its probability to belong to a spam or a
non-spam mail.  Use the 15 most conspicuous words, compute the total
probability of the mail being spam.  If this probability is higher than
a certain threshold, the mail is considered to be spam.

   The Spam Statistics package adds support to Gnus for this kind of
filtering.  It can be used as one of the back ends of the Spam package
(*note Spam Package::), or by itself.

   Before using the Spam Statistics package, you need to set it up.
First, you need two collections of your mail, one with spam, one with
non-spam.  Then you need to create a dictionary using these two
collections, and save it.  And last but not least, you need to use this
dictionary in your fancy mail splitting rules.

* Menu:

* Creating a spam-stat dictionary::
* Splitting mail using spam-stat::
* Low-level interface to the spam-stat dictionary::


File: gnus,  Node: Creating a spam-stat dictionary,  Next: Splitting mail using spam-stat,  Up: Spam Statistics Package

8.20.8.1 Creating a spam-stat dictionary
........................................

Before you can begin to filter spam based on statistics, you must
create these statistics based on two mail collections, one with spam,
one with non-spam.  These statistics are then stored in a dictionary
for later use.  In order for these statistics to be meaningful, you
need several hundred emails in both collections.

   Gnus currently supports only the nnml back end for automated
dictionary creation.  The nnml back end stores all mails in a
directory, one file per mail.  Use the following:

 -- Function: spam-stat-process-spam-directory
     Create spam statistics for every file in this directory.  Every
     file is treated as one spam mail.

 -- Function: spam-stat-process-non-spam-directory
     Create non-spam statistics for every file in this directory.  Every
     file is treated as one non-spam mail.

   Usually you would call `spam-stat-process-spam-directory' on a
directory such as `~/Mail/mail/spam' (this usually corresponds to the
group `nnml:mail.spam'), and you would call
`spam-stat-process-non-spam-directory' on a directory such as
`~/Mail/mail/misc' (this usually corresponds to the group
`nnml:mail.misc').

   When you are using IMAP, you won't have the mails available locally,
so that will not work.  One solution is to use the Gnus Agent to cache
the articles.  Then you can use directories such as
`"~/News/agent/nnimap/mail.yourisp.com/personal_spam"' for
`spam-stat-process-spam-directory'.  *Note Agent as Cache::.

 -- Variable: spam-stat
     This variable holds the hash-table with all the statistics--the
     dictionary we have been talking about.  For every word in either
     collection, this hash-table stores a vector describing how often
     the word appeared in spam and often it appeared in non-spam mails.

   If you want to regenerate the statistics from scratch, you need to
reset the dictionary.

 -- Function: spam-stat-reset
     Reset the `spam-stat' hash-table, deleting all the statistics.

   When you are done, you must save the dictionary.  The dictionary may
be rather large.  If you will not update the dictionary incrementally
(instead, you will recreate it once a month, for example), then you can
reduce the size of the dictionary by deleting all words that did not
appear often enough or that do not clearly belong to only spam or only
non-spam mails.

 -- Function: spam-stat-reduce-size
     Reduce the size of the dictionary.  Use this only if you do not
     want to update the dictionary incrementally.

 -- Function: spam-stat-save
     Save the dictionary.

 -- Variable: spam-stat-file
     The filename used to store the dictionary.  This defaults to
     `~/.spam-stat.el'.


File: gnus,  Node: Splitting mail using spam-stat,  Next: Low-level interface to the spam-stat dictionary,  Prev: Creating a spam-stat dictionary,  Up: Spam Statistics Package

8.20.8.2 Splitting mail using spam-stat
.......................................

This section describes how to use the Spam statistics _independently_
of the *Note Spam Package::.

   First, add the following to your `~/.gnus.el' file:

     (require 'spam-stat)
     (spam-stat-load)

   This will load the necessary Gnus code, and the dictionary you
created.

   Next, you need to adapt your fancy splitting rules:  You need to
determine how to use `spam-stat'.  The following examples are for the
nnml back end.  Using the nnimap back end works just as well.  Just use
`nnimap-split-fancy' instead of `nnmail-split-fancy'.

   In the simplest case, you only have two groups, `mail.misc' and
`mail.spam'.  The following expression says that mail is either spam or
it should go into `mail.misc'.  If it is spam, then
`spam-stat-split-fancy' will return `mail.spam'.

     (setq nnmail-split-fancy
           `(| (: spam-stat-split-fancy)
               "mail.misc"))

 -- Variable: spam-stat-split-fancy-spam-group
     The group to use for spam.  Default is `mail.spam'.

   If you also filter mail with specific subjects into other groups, use
the following expression.  Only mails not matching the regular
expression are considered potential spam.

     (setq nnmail-split-fancy
           `(| ("Subject" "\\bspam-stat\\b" "mail.emacs")
               (: spam-stat-split-fancy)
               "mail.misc"))

   If you want to filter for spam first, then you must be careful when
creating the dictionary.  Note that `spam-stat-split-fancy' must
consider both mails in `mail.emacs' and in `mail.misc' as non-spam,
therefore both should be in your collection of non-spam mails, when
creating the dictionary!

     (setq nnmail-split-fancy
           `(| (: spam-stat-split-fancy)
               ("Subject" "\\bspam-stat\\b" "mail.emacs")
               "mail.misc"))

   You can combine this with traditional filtering.  Here, we move all
HTML-only mails into the `mail.spam.filtered' group.  Note that since
`spam-stat-split-fancy' will never see them, the mails in
`mail.spam.filtered' should be neither in your collection of spam mails,
nor in your collection of non-spam mails, when creating the dictionary!

     (setq nnmail-split-fancy
           `(| ("Content-Type" "text/html" "mail.spam.filtered")
               (: spam-stat-split-fancy)
               ("Subject" "\\bspam-stat\\b" "mail.emacs")
               "mail.misc"))


File: gnus,  Node: Low-level interface to the spam-stat dictionary,  Prev: Splitting mail using spam-stat,  Up: Spam Statistics Package

8.20.8.3 Low-level interface to the spam-stat dictionary
........................................................

The main interface to using `spam-stat', are the following functions:

 -- Function: spam-stat-buffer-is-spam
     Called in a buffer, that buffer is considered to be a new spam
     mail.  Use this for new mail that has not been processed before.

 -- Function: spam-stat-buffer-is-no-spam
     Called in a buffer, that buffer is considered to be a new non-spam
     mail.  Use this for new mail that has not been processed before.

 -- Function: spam-stat-buffer-change-to-spam
     Called in a buffer, that buffer is no longer considered to be
     normal mail but spam.  Use this to change the status of a mail
     that has already been processed as non-spam.

 -- Function: spam-stat-buffer-change-to-non-spam
     Called in a buffer, that buffer is no longer considered to be spam
     but normal mail.  Use this to change the status of a mail that has
     already been processed as spam.

 -- Function: spam-stat-save
     Save the hash table to the file.  The filename used is stored in
     the variable `spam-stat-file'.

 -- Function: spam-stat-load
     Load the hash table from a file.  The filename used is stored in
     the variable `spam-stat-file'.

 -- Function: spam-stat-score-word
     Return the spam score for a word.

 -- Function: spam-stat-score-buffer
     Return the spam score for a buffer.

 -- Function: spam-stat-split-fancy
     Use this function for fancy mail splitting.  Add the rule `(:
     spam-stat-split-fancy)' to `nnmail-split-fancy'

   Make sure you load the dictionary before using it.  This requires the
following in your `~/.gnus.el' file:

     (require 'spam-stat)
     (spam-stat-load)

   Typical test will involve calls to the following functions:

     Reset: (setq spam-stat (make-hash-table :test 'equal))
     Learn spam: (spam-stat-process-spam-directory "~/Mail/mail/spam")
     Learn non-spam: (spam-stat-process-non-spam-directory "~/Mail/mail/misc")
     Save table: (spam-stat-save)
     File size: (nth 7 (file-attributes spam-stat-file))
     Number of words: (hash-table-count spam-stat)
     Test spam: (spam-stat-test-directory "~/Mail/mail/spam")
     Test non-spam: (spam-stat-test-directory "~/Mail/mail/misc")
     Reduce table size: (spam-stat-reduce-size)
     Save table: (spam-stat-save)
     File size: (nth 7 (file-attributes spam-stat-file))
     Number of words: (hash-table-count spam-stat)
     Test spam: (spam-stat-test-directory "~/Mail/mail/spam")
     Test non-spam: (spam-stat-test-directory "~/Mail/mail/misc")

   Here is how you would create your dictionary:

     Reset: (setq spam-stat (make-hash-table :test 'equal))
     Learn spam: (spam-stat-process-spam-directory "~/Mail/mail/spam")
     Learn non-spam: (spam-stat-process-non-spam-directory "~/Mail/mail/misc")
     Repeat for any other non-spam group you need...
     Reduce table size: (spam-stat-reduce-size)
     Save table: (spam-stat-save)


File: gnus,  Node: The Gnus Registry,  Next: Other modes,  Prev: Spam Package,  Up: Various

8.21 The Gnus Registry
======================

The Gnus registry is a package that tracks messages by their Message-ID
across all backends.  This allows Gnus users to do several cool things,
be the envy of the locals, get free haircuts, and be experts on world
issues.  Well, maybe not all of those, but the features are pretty cool.

   Although they will be explained in detail shortly, here's a quick
list of said features in case your attention span is...  never mind.

  1. Split messages to their parent

     This keeps discussions in the same group.  You can use the subject
     and the sender in addition to the Message-ID.  Several strategies
     are available.

  2. Store custom flags and keywords

     The registry can store custom flags and keywords for a message.
     For instance, you can mark a message "To-Do" this way and the flag
     will persist whether the message is in the nnimap, nnml, nnmaildir,
     etc. backends.

  3. Store arbitrary data

     Through a simple ELisp API, the registry can remember any data for
     a message.  A built-in inverse map, when activated, allows quick
     lookups of all messages matching a particular set of criteria.

* Menu:

* Setup::
* Fancy splitting to parent::
* Store custom flags and keywords::
* Store arbitrary data::


File: gnus,  Node: Setup,  Next: Fancy splitting to parent,  Up: The Gnus Registry

8.21.1 Setup
------------

Fortunately, setting up the Gnus registry is pretty easy:

     (setq gnus-registry-max-entries 2500
           gnus-registry-use-long-group-names t)

     (gnus-registry-initialize)

   This adds registry saves to Gnus newsrc saves (which happen on exit
and when you press `s' from the `*Group*' buffer.  It also adds
registry calls to article actions in Gnus (copy, move, etc.)  so it's
not easy to undo the initialization.  See `gnus-registry-initialize'
for the gory details.

   Here are other settings used by the author of the registry
(understand what they do before you copy them blindly).

     (setq
      gnus-registry-split-strategy 'majority
      gnus-registry-ignored-groups '(("nntp" t)
                                     ("nnrss" t)
                                     ("spam" t)
                                     ("train" t))
      gnus-registry-max-entries 500000
      gnus-registry-use-long-group-names t
      gnus-registry-track-extra '(sender subject))

   They say: keep a lot of messages around, use long group names, track
messages by sender and subject (not just parent Message-ID), and when
the registry splits incoming mail, use a majority rule to decide where
messages should go if there's more than one possibility.  In addition,
the registry should ignore messages in groups that match "nntp",
"nnrss", "spam", or "train."

   You are doubtless impressed by all this, but you ask: "I am a Gnus
user, I customize to live.  Give me more."  Here you go, these are the
general settings.

 -- Variable: gnus-registry-unfollowed-groups
     The groups that will not be followed by
     `gnus-registry-split-fancy-with-parent'.  They will still be
     remembered by the registry.  This is a list of regular expressions.

 -- Variable: gnus-registry-ignored-groups
     The groups that will not be remembered by the registry.  This is a
     list of regular expressions, also available through Group/Topic
     customization (so you can ignore or keep a specific group or a
     whole topic).

 -- Variable: gnus-registry-use-long-group-names
     Whether the registry will use long group names.  It's recommended
     to set this to `t', although everything works if you don't.  Future
     functionality will require it.

 -- Variable: gnus-registry-max-entries
     The number (an integer or `nil' for unlimited) of entries the
     registry will keep.

 -- Variable: gnus-registry-cache-file
     The file where the registry will be stored between Gnus sessions.


File: gnus,  Node: Fancy splitting to parent,  Next: Store custom flags and keywords,  Prev: Setup,  Up: The Gnus Registry

8.21.2 Fancy splitting to parent
--------------------------------

Simply put, this lets you put followup e-mail where it belongs.

   Every message has a Message-ID, which is unique, and the registry
remembers it.  When the message is moved or copied, the registry will
notice this and offer the new group as a choice to the splitting
strategy.

   When a followup is made, usually it mentions the original message's
Message-ID in the headers.  The registry knows this and uses that
mention to find the group where the original message lives.  You only
have to put a rule like this:

     (setq nnimap-my-split-fancy '(|

           ;; split to parent: you need this
           (: gnus-registry-split-fancy-with-parent)

           ;; other rules, as an example
           (: spam-split)
           ;; default mailbox
           "mail")

   in your fancy split setup.  In addition, you may want to customize
the following variables.

 -- Variable: gnus-registry-track-extra
     This is a list of symbols, so it's best to change it from the
     Customize interface.  By default it's `nil', but you may want to
     track `subject' and `sender' as well when splitting by parent.  It
     may work for you.  It can be annoying if your mail flow is large
     and people don't stick to the same groups.

 -- Variable: gnus-registry-split-strategy
     This is a symbol, so it's best to change it from the Customize
     interface.  By default it's `nil', but you may want to set it to
     `majority' or `first' to split by sender or subject based on the
     majority of matches or on the first found.


File: gnus,  Node: Store custom flags and keywords,  Next: Store arbitrary data,  Prev: Fancy splitting to parent,  Up: The Gnus Registry

8.21.3 Store custom flags and keywords
--------------------------------------

The registry lets you set custom flags and keywords per message.  You
can use the Gnus->Registry Marks menu or the `M M x' keyboard
shortcuts, where `x' is the first letter of the mark's name.

 -- Variable: gnus-registry-marks
     The custom marks that the registry can use.  You can modify the
     default list, if you like.  If you do, you'll have to exit Emacs
     before they take effect (you can also unload the registry and
     reload it or evaluate the specific macros you'll need, but you
     probably don't want to bother).  Use the Customize interface to
     modify the list.

     By default this list has the `Important', `Work', `Personal',
     `To-Do', and `Later' marks.  They all have keyboard shortcuts like
     `M M i' for Important, using the first letter.

 -- Function: gnus-registry-mark-article
     Call this function to mark an article with a custom registry mark.
     It will offer the available marks for completion.


File: gnus,  Node: Store arbitrary data,  Prev: Store custom flags and keywords,  Up: The Gnus Registry

8.21.4 Store arbitrary data
---------------------------

The registry has a simple API that uses a Message-ID as the key to
store arbitrary data (as long as it can be converted to a list for
storage).

 -- Function: gnus-registry-store-extra-entry (id key value)
     Store `value' in the extra data key `key' for message `id'.

 -- Function: gnus-registry-delete-extra-entry (id key)
     Delete the extra data key `key' for message `id'.

 -- Function: gnus-registry-fetch-extra (id key)
     Get the extra data key `key' for message `id'.

 -- Variable: gnus-registry-extra-entries-precious
     If any extra entries are precious, their presence will make the
     registry keep the whole entry forever, even if there are no groups
     for the Message-ID and if the size limit of the registry is
     reached.  By default this is just `(marks)' so the custom registry
     marks are precious.


File: gnus,  Node: Other modes,  Next: Various Various,  Prev: The Gnus Registry,  Up: Various

8.22 Interaction with other modes
=================================

8.22.1 Dired
------------

`gnus-dired-minor-mode' provides some useful functions for dired
buffers.  It is enabled with
     (add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode)

`C-c C-m C-a'
     Send dired's marked files as an attachment (`gnus-dired-attach').
     You will be prompted for a message buffer.

`C-c C-m C-l'
     Visit a file according to the appropriate mailcap entry
     (`gnus-dired-find-file-mailcap').  With prefix, open file in a new
     buffer.

`C-c C-m C-p'
     Print file according to the mailcap entry (`gnus-dired-print').  If
     there is no print command, print in a PostScript image.


File: gnus,  Node: Various Various,  Prev: Other modes,  Up: Various

8.23 Various Various
====================

`gnus-home-directory'
     All Gnus file and directory variables will be initialized from this
     variable, which defaults to `~/'.

`gnus-directory'
     Most Gnus storage file and directory variables will be initialized
     from this variable, which defaults to the `SAVEDIR' environment
     variable, or `~/News/' if that variable isn't set.

     Note that Gnus is mostly loaded when the `~/.gnus.el' file is read.
     This means that other directory variables that are initialized
     from this variable won't be set properly if you set this variable
     in `~/.gnus.el'.  Set this variable in `.emacs' instead.

`gnus-default-directory'
     Not related to the above variable at all--this variable says what
     the default directory of all Gnus buffers should be.  If you issue
     commands like `C-x C-f', the prompt you'll get starts in the
     current buffer's default directory.  If this variable is `nil'
     (which is the default), the default directory will be the default
     directory of the buffer you were in when you started Gnus.

`gnus-verbose'
     This variable is an integer between zero and ten.  The higher the
     value, the more messages will be displayed.  If this variable is
     zero, Gnus will never flash any messages, if it is seven (which is
     the default), most important messages will be shown, and if it is
     ten, Gnus won't ever shut up, but will flash so many messages it
     will make your head swim.

`gnus-verbose-backends'
     This variable works the same way as `gnus-verbose', but it applies
     to the Gnus back ends instead of Gnus proper.

`gnus-add-timestamp-to-message'
     This variable controls whether to add timestamps to messages that
     are controlled by `gnus-verbose' and `gnus-verbose-backends' and
     are issued.  The default value is `nil' which means never to add
     timestamp.  If it is `log', add timestamps to only the messages
     that go into the `*Messages*' buffer (in XEmacs, it is the
     ` *Message-Log*' buffer).  If it is neither `nil' nor `log', add
     timestamps not only to log messages but also to the ones displayed
     in the echo area.

`nnheader-max-head-length'
     When the back ends read straight heads of articles, they all try
     to read as little as possible.  This variable (default 8192)
     specifies the absolute max length the back ends will try to read
     before giving up on finding a separator line between the head and
     the body.  If this variable is `nil', there is no upper read
     bound.  If it is `t', the back ends won't try to read the articles
     piece by piece, but read the entire articles.  This makes sense
     with some versions of `ange-ftp' or `efs'.

`nnheader-head-chop-length'
     This variable (default 2048) says how big a piece of each article
     to read when doing the operation described above.

`nnheader-file-name-translation-alist'
     This is an alist that says how to translate characters in file
     names.  For instance, if `:' is invalid as a file character in
     file names on your system (you OS/2 user you), you could say
     something like:

          (setq nnheader-file-name-translation-alist
                '((?: . ?_)))

     In fact, this is the default value for this variable on OS/2 and MS
     Windows (phooey) systems.

`gnus-hidden-properties'
     This is a list of properties to use to hide "invisible" text.  It
     is `(invisible t intangible t)' by default on most systems, which
     makes invisible text invisible and intangible.

`gnus-parse-headers-hook'
     A hook called before parsing headers.  It can be used, for
     instance, to gather statistics on the headers fetched, or perhaps
     you'd like to prune some headers.  I don't see why you'd want
     that, though.

`gnus-shell-command-separator'
     String used to separate two shell commands.  The default is `;'.

`gnus-invalid-group-regexp'
     Regexp to match "invalid" group names when querying user for a
     group name.  The default value catches some *really* invalid group
     names who could possibly mess up Gnus internally (like allowing
     `:' in a group name, which is normally used to delimit method and
     group).

     IMAP users might want to allow `/' in group names though.

`gnus-safe-html-newsgroups'
     Groups in which links in html articles are considered all safe.
     The value may be a regexp matching those groups, a list of group
     names, or `nil'.  This overrides `mm-w3m-safe-url-regexp'.  The
     default value is `"\\`nnrss[+:]"'.  This is effective only when
     emacs-w3m renders html articles, i.e., in the case
     `mm-text-html-renderer' is set to `w3m'.  *Note Display
     Customization: (emacs-mime)Display Customization.



File: gnus,  Node: The End,  Next: Appendices,  Prev: Various,  Up: Top

9 The End
*********

Well, that's the manual--you can get on with your life now.  Keep in
touch.  Say hello to your cats from me.

   My *ghod*--I just can't stand goodbyes.  Sniffle.

   Ol' Charles Reznikoff said it pretty well, so I leave the floor to
him:

     *Te Deum*


     Not because of victories
     I sing,
     having none,
     but for the common sunshine,
     the breeze,
     the largess of the spring.


     Not for victory
     but for the day's work done
     as well as I was able;
     not for a seat upon the dais
     but at the common table.


File: gnus,  Node: Appendices,  Next: GNU Free Documentation License,  Prev: The End,  Up: Top

10 Appendices
*************

* Menu:

* XEmacs::                      Requirements for installing under XEmacs.
* History::                     How Gnus got where it is today.
* On Writing Manuals::          Why this is not a beginner's guide.
* Terminology::                 We use really difficult, like, words here.
* Customization::               Tailoring Gnus to your needs.
* Troubleshooting::             What you might try if things do not work.
* Gnus Reference Guide::        Rilly, rilly technical stuff.
* Emacs for Heathens::          A short introduction to Emacsian terms.
* Frequently Asked Questions::  The Gnus FAQ


File: gnus,  Node: XEmacs,  Next: History,  Up: Appendices

10.1 XEmacs
===========

XEmacs is distributed as a collection of packages.  You should install
whatever packages the Gnus XEmacs package requires.  The current
requirements are `gnus', `mail-lib', `xemacs-base', `eterm',
`sh-script', `net-utils', `os-utils', `dired', `mh-e', `sieve',
`ps-print', `W3', `pgg', `mailcrypt', `ecrypto', and `sasl'.



Local Variables:
coding: iso-8859-1
End:
