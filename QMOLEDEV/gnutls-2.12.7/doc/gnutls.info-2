This is gnutls.info, produced by makeinfo version 4.13 from gnutls.texi.

This manual is last updated 8 April 2011 for version 2.12.7 of GnuTLS.

Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
2010 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled "GNU Free Documentation License".

INFO-DIR-SECTION Software libraries
START-INFO-DIR-ENTRY
* GnuTLS: (gnutls).		GNU Transport Layer Security Library.
END-INFO-DIR-ENTRY

INFO-DIR-SECTION System Administration
START-INFO-DIR-ENTRY
* certtool: (gnutls)Invoking certtool.	Manipulate certificates and keys.
* gnutls-serv: (gnutls)Invoking gnutls-serv.	GnuTLS test server.
* gnutls-cli: (gnutls)Invoking gnutls-cli.	GnuTLS test client.
* gnutls-cli-debug: (gnutls)Invoking gnutls-cli-debug.	GnuTLS debug client.
* psktool: (gnutls)Invoking psktool.	Simple TLS-Pre-Shared-Keys manager.
* srptool: (gnutls)Invoking srptool.	Simple SRP password tool.
END-INFO-DIR-ENTRY


File: gnutls.info,  Node: X.509 certificate functions,  Next: GnuTLS-extra functions,  Prev: Core functions,  Up: Function reference

9.2 X.509 Certificate Functions
===============================

The following functions are to be used for X.509 certificate handling.
Their prototypes lie in `gnutls/x509.h'.

gnutls_pkcs12_bag_decrypt
-------------------------

 -- Function: int gnutls_pkcs12_bag_decrypt (gnutls_pkcs12_bag_t BAG,
          const char * PASS)
     BAG: The bag

     PASS: The password used for encryption, must be ASCII.

     This function will decrypt the given encrypted bag and return 0 on
     success.

     *Returns:* On success, `GNUTLS_E_SUCCESS' (zero) is returned,
     otherwise an error code is returned.

gnutls_pkcs12_bag_deinit
------------------------

 -- Function: void gnutls_pkcs12_bag_deinit (gnutls_pkcs12_bag_t BAG)
     BAG: The structure to be initialized

     This function will deinitialize a PKCS12 Bag structure.

gnutls_pkcs12_bag_encrypt
-------------------------

 -- Function: int gnutls_pkcs12_bag_encrypt (gnutls_pkcs12_bag_t BAG,
          const char * PASS, unsigned int FLAGS)
     BAG: The bag

     PASS: The password used for encryption, must be ASCII

     FLAGS: should be one of `gnutls_pkcs_encrypt_flags_t' elements
     bitwise or'd

     This function will encrypt the given bag.

     *Returns:* On success, `GNUTLS_E_SUCCESS' (zero) is returned,
     otherwise an error code is returned.

gnutls_pkcs12_bag_get_count
---------------------------

 -- Function: int gnutls_pkcs12_bag_get_count (gnutls_pkcs12_bag_t BAG)
     BAG: The bag

     This function will return the number of the elements withing the
     bag.

     *Returns:* Number of elements in bag, or an negative error code on
     error.

gnutls_pkcs12_bag_get_data
--------------------------

 -- Function: int gnutls_pkcs12_bag_get_data (gnutls_pkcs12_bag_t BAG,
          int INDX, gnutls_datum_t * DATA)
     BAG: The bag

     INDX: The element of the bag to get the data from

     DATA: where the bag's data will be. Should be treated as constant.

     This function will return the bag's data. The data is a constant
     that is stored into the bag.  Should not be accessed after the bag
     is deleted.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_pkcs12_bag_get_friendly_name
-----------------------------------

 -- Function: int gnutls_pkcs12_bag_get_friendly_name
          (gnutls_pkcs12_bag_t BAG, int INDX, char ** NAME)
     BAG: The bag

     INDX: The bag's element to add the id

     NAME: will hold a pointer to the name (to be treated as const)

     This function will return the friendly name, of the specified bag
     element.  The key ID is usually used to distinguish the local
     private key and the certificate pair.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value. or a negative value on error.

gnutls_pkcs12_bag_get_key_id
----------------------------

 -- Function: int gnutls_pkcs12_bag_get_key_id (gnutls_pkcs12_bag_t
          BAG, int INDX, gnutls_datum_t * ID)
     BAG: The bag

     INDX: The bag's element to add the id

     ID: where the ID will be copied (to be treated as const)

     This function will return the key ID, of the specified bag element.
     The key ID is usually used to distinguish the local private key and
     the certificate pair.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value. or a negative value on error.

gnutls_pkcs12_bag_get_type
--------------------------

 -- Function: gnutls_pkcs12_bag_type_t gnutls_pkcs12_bag_get_type
          (gnutls_pkcs12_bag_t BAG, int INDX)
     BAG: The bag

     INDX: The element of the bag to get the type

     This function will return the bag's type.

     *Returns:* One of the `gnutls_pkcs12_bag_type_t' enumerations.

gnutls_pkcs12_bag_init
----------------------

 -- Function: int gnutls_pkcs12_bag_init (gnutls_pkcs12_bag_t * BAG)
     BAG: The structure to be initialized

     This function will initialize a PKCS12 bag structure. PKCS12 Bags
     usually contain private keys, lists of X.509 Certificates and X.509
     Certificate revocation lists.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_pkcs12_bag_set_crl
-------------------------

 -- Function: int gnutls_pkcs12_bag_set_crl (gnutls_pkcs12_bag_t BAG,
          gnutls_x509_crl_t CRL)
     BAG: The bag

     CRL: the CRL to be copied.

     This function will insert the given CRL into the bag. This is just
     a wrapper over `gnutls_pkcs12_bag_set_data()'.

     *Returns:* the index of the added bag on success, or a negative
     value on failure.

gnutls_pkcs12_bag_set_crt
-------------------------

 -- Function: int gnutls_pkcs12_bag_set_crt (gnutls_pkcs12_bag_t BAG,
          gnutls_x509_crt_t CRT)
     BAG: The bag

     CRT: the certificate to be copied.

     This function will insert the given certificate into the bag. This
     is just a wrapper over `gnutls_pkcs12_bag_set_data()'.

     *Returns:* the index of the added bag on success, or a negative
     value on failure.

gnutls_pkcs12_bag_set_data
--------------------------

 -- Function: int gnutls_pkcs12_bag_set_data (gnutls_pkcs12_bag_t BAG,
          gnutls_pkcs12_bag_type_t TYPE, const gnutls_datum_t * DATA)
     BAG: The bag

     TYPE: The data's type

     DATA: the data to be copied.

     This function will insert the given data of the given type into
     the bag.

     *Returns:* the index of the added bag on success, or a negative
     value on error.

gnutls_pkcs12_bag_set_friendly_name
-----------------------------------

 -- Function: int gnutls_pkcs12_bag_set_friendly_name
          (gnutls_pkcs12_bag_t BAG, int INDX, const char * NAME)
     BAG: The bag

     INDX: The bag's element to add the id

     NAME: the name

     This function will add the given key friendly name, to the
     specified, by the index, bag element. The name will be encoded as
     a 'Friendly name' bag attribute, which is usually used to set a
     user name to the local private key and the certificate pair.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value. or a negative value on error.

gnutls_pkcs12_bag_set_key_id
----------------------------

 -- Function: int gnutls_pkcs12_bag_set_key_id (gnutls_pkcs12_bag_t
          BAG, int INDX, const gnutls_datum_t * ID)
     BAG: The bag

     INDX: The bag's element to add the id

     ID: the ID

     This function will add the given key ID, to the specified, by the
     index, bag element. The key ID will be encoded as a 'Local key
     identifier' bag attribute, which is usually used to distinguish
     the local private key and the certificate pair.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value. or a negative value on error.

gnutls_pkcs12_deinit
--------------------

 -- Function: void gnutls_pkcs12_deinit (gnutls_pkcs12_t PKCS12)
     PKCS12: The structure to be initialized

     This function will deinitialize a PKCS12 structure.

gnutls_pkcs12_export
--------------------

 -- Function: int gnutls_pkcs12_export (gnutls_pkcs12_t PKCS12,
          gnutls_x509_crt_fmt_t FORMAT, void * OUTPUT_DATA, size_t *
          OUTPUT_DATA_SIZE)
     PKCS12: Holds the pkcs12 structure

     FORMAT: the format of output params. One of PEM or DER.

     OUTPUT_DATA: will contain a structure PEM or DER encoded

     OUTPUT_DATA_SIZE: holds the size of output_data (and will be
     replaced by the actual size of parameters)

     This function will export the pkcs12 structure to DER or PEM
     format.

     If the buffer provided is not long enough to hold the output, then
     *output_data_size will be updated and GNUTLS_E_SHORT_MEMORY_BUFFER
     will be returned.

     If the structure is PEM encoded, it will have a header of "BEGIN
     PKCS12".

     *Return value:* In case of failure a negative value will be
     returned, and 0 on success.

gnutls_pkcs12_generate_mac
--------------------------

 -- Function: int gnutls_pkcs12_generate_mac (gnutls_pkcs12_t PKCS12,
          const char * PASS)
     PKCS12: should contain a gnutls_pkcs12_t structure

     PASS: The password for the MAC

     This function will generate a MAC for the PKCS12 structure.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_pkcs12_get_bag
---------------------

 -- Function: int gnutls_pkcs12_get_bag (gnutls_pkcs12_t PKCS12, int
          INDX, gnutls_pkcs12_bag_t BAG)
     PKCS12: should contain a gnutls_pkcs12_t structure

     INDX: contains the index of the bag to extract

     BAG: An initialized bag, where the contents of the bag will be
     copied

     This function will return a Bag from the PKCS12 structure.

     After the last Bag has been read
     `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE' will be returned.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_pkcs12_import
--------------------

 -- Function: int gnutls_pkcs12_import (gnutls_pkcs12_t PKCS12, const
          gnutls_datum_t * DATA, gnutls_x509_crt_fmt_t FORMAT, unsigned
          int FLAGS)
     PKCS12: The structure to store the parsed PKCS12.

     DATA: The DER or PEM encoded PKCS12.

     FORMAT: One of DER or PEM

     FLAGS: an ORed sequence of gnutls_privkey_pkcs8_flags

     This function will convert the given DER or PEM encoded PKCS12 to
     the native gnutls_pkcs12_t format. The output will be stored in
     'pkcs12'.

     If the PKCS12 is PEM encoded it should have a header of "PKCS12".

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_pkcs12_init
------------------

 -- Function: int gnutls_pkcs12_init (gnutls_pkcs12_t * PKCS12)
     PKCS12: The structure to be initialized

     This function will initialize a PKCS12 structure. PKCS12 structures
     usually contain lists of X.509 Certificates and X.509 Certificate
     revocation lists.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_pkcs12_set_bag
---------------------

 -- Function: int gnutls_pkcs12_set_bag (gnutls_pkcs12_t PKCS12,
          gnutls_pkcs12_bag_t BAG)
     PKCS12: should contain a gnutls_pkcs12_t structure

     BAG: An initialized bag

     This function will insert a Bag into the PKCS12 structure.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_pkcs12_verify_mac
------------------------

 -- Function: int gnutls_pkcs12_verify_mac (gnutls_pkcs12_t PKCS12,
          const char * PASS)
     PKCS12: should contain a gnutls_pkcs12_t structure

     PASS: The password for the MAC

     This function will verify the MAC for the PKCS12 structure.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_pkcs7_deinit
-------------------

 -- Function: void gnutls_pkcs7_deinit (gnutls_pkcs7_t PKCS7)
     PKCS7: The structure to be initialized

     This function will deinitialize a PKCS7 structure.

gnutls_pkcs7_delete_crl
-----------------------

 -- Function: int gnutls_pkcs7_delete_crl (gnutls_pkcs7_t PKCS7, int
          INDX)
     PKCS7: should contain a `gnutls_pkcs7_t' structure

     INDX: the index of the crl to delete

     This function will delete a crl from a PKCS7 or RFC2630 crl set.
     Index starts from 0. Returns 0 on success.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_pkcs7_delete_crt
-----------------------

 -- Function: int gnutls_pkcs7_delete_crt (gnutls_pkcs7_t PKCS7, int
          INDX)
     PKCS7: should contain a gnutls_pkcs7_t structure

     INDX: the index of the certificate to delete

     This function will delete a certificate from a PKCS7 or RFC2630
     certificate set.  Index starts from 0. Returns 0 on success.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_pkcs7_export
-------------------

 -- Function: int gnutls_pkcs7_export (gnutls_pkcs7_t PKCS7,
          gnutls_x509_crt_fmt_t FORMAT, void * OUTPUT_DATA, size_t *
          OUTPUT_DATA_SIZE)
     PKCS7: Holds the pkcs7 structure

     FORMAT: the format of output params. One of PEM or DER.

     OUTPUT_DATA: will contain a structure PEM or DER encoded

     OUTPUT_DATA_SIZE: holds the size of output_data (and will be
     replaced by the actual size of parameters)

     This function will export the pkcs7 structure to DER or PEM format.

     If the buffer provided is not long enough to hold the output, then
     *`output_data_size' is updated and `GNUTLS_E_SHORT_MEMORY_BUFFER'
     will be returned.

     If the structure is PEM encoded, it will have a header of "BEGIN
     PKCS7".

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_pkcs7_get_crl_count
--------------------------

 -- Function: int gnutls_pkcs7_get_crl_count (gnutls_pkcs7_t PKCS7)
     PKCS7: should contain a gnutls_pkcs7_t structure

     This function will return the number of certifcates in the PKCS7
     or RFC2630 crl set.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_pkcs7_get_crl_raw
------------------------

 -- Function: int gnutls_pkcs7_get_crl_raw (gnutls_pkcs7_t PKCS7, int
          INDX, void * CRL, size_t * CRL_SIZE)
     PKCS7: should contain a `gnutls_pkcs7_t' structure

     INDX: contains the index of the crl to extract

     CRL: the contents of the crl will be copied there (may be null)

     CRL_SIZE: should hold the size of the crl

     This function will return a crl of the PKCS7 or RFC2630 crl set.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.  If the provided buffer is not long enough,
     then `crl_size' is updated and `GNUTLS_E_SHORT_MEMORY_BUFFER' is
     returned.  After the last crl has been read
     `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE' will be returned.

gnutls_pkcs7_get_crt_count
--------------------------

 -- Function: int gnutls_pkcs7_get_crt_count (gnutls_pkcs7_t PKCS7)
     PKCS7: should contain a `gnutls_pkcs7_t' structure

     This function will return the number of certifcates in the PKCS7
     or RFC2630 certificate set.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_pkcs7_get_crt_raw
------------------------

 -- Function: int gnutls_pkcs7_get_crt_raw (gnutls_pkcs7_t PKCS7, int
          INDX, void * CERTIFICATE, size_t * CERTIFICATE_SIZE)
     PKCS7: should contain a gnutls_pkcs7_t structure

     INDX: contains the index of the certificate to extract

     CERTIFICATE: the contents of the certificate will be copied there
     (may be null)

     CERTIFICATE_SIZE: should hold the size of the certificate

     This function will return a certificate of the PKCS7 or RFC2630
     certificate set.

     After the last certificate has been read
     `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE' will be returned.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.  If the provided buffer is not long enough,
     then `certificate_size' is updated and
     `GNUTLS_E_SHORT_MEMORY_BUFFER' is returned.

gnutls_pkcs7_import
-------------------

 -- Function: int gnutls_pkcs7_import (gnutls_pkcs7_t PKCS7, const
          gnutls_datum_t * DATA, gnutls_x509_crt_fmt_t FORMAT)
     PKCS7: The structure to store the parsed PKCS7.

     DATA: The DER or PEM encoded PKCS7.

     FORMAT: One of DER or PEM

     This function will convert the given DER or PEM encoded PKCS7 to
     the native `gnutls_pkcs7_t' format.  The output will be stored in
     `pkcs7'.

     If the PKCS7 is PEM encoded it should have a header of "PKCS7".

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_pkcs7_init
-----------------

 -- Function: int gnutls_pkcs7_init (gnutls_pkcs7_t * PKCS7)
     PKCS7: The structure to be initialized

     This function will initialize a PKCS7 structure. PKCS7 structures
     usually contain lists of X.509 Certificates and X.509 Certificate
     revocation lists.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_pkcs7_set_crl_raw
------------------------

 -- Function: int gnutls_pkcs7_set_crl_raw (gnutls_pkcs7_t PKCS7, const
          gnutls_datum_t * CRL)
     PKCS7: should contain a `gnutls_pkcs7_t' structure

     CRL: the DER encoded crl to be added

     This function will add a crl to the PKCS7 or RFC2630 crl set.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_pkcs7_set_crl
--------------------

 -- Function: int gnutls_pkcs7_set_crl (gnutls_pkcs7_t PKCS7,
          gnutls_x509_crl_t CRL)
     PKCS7: should contain a `gnutls_pkcs7_t' structure

     CRL: the DER encoded crl to be added

     This function will add a parsed CRL to the PKCS7 or RFC2630 crl
     set.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_pkcs7_set_crt_raw
------------------------

 -- Function: int gnutls_pkcs7_set_crt_raw (gnutls_pkcs7_t PKCS7, const
          gnutls_datum_t * CRT)
     PKCS7: should contain a `gnutls_pkcs7_t' structure

     CRT: the DER encoded certificate to be added

     This function will add a certificate to the PKCS7 or RFC2630
     certificate set.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_pkcs7_set_crt
--------------------

 -- Function: int gnutls_pkcs7_set_crt (gnutls_pkcs7_t PKCS7,
          gnutls_x509_crt_t CRT)
     PKCS7: should contain a `gnutls_pkcs7_t' structure

     CRT: the certificate to be copied.

     This function will add a parsed certificate to the PKCS7 or
     RFC2630 certificate set.  This is a wrapper function over
     `gnutls_pkcs7_set_crt_raw()' .

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crl_check_issuer
----------------------------

 -- Function: int gnutls_x509_crl_check_issuer (gnutls_x509_crl_t CERT,
          gnutls_x509_crt_t ISSUER)
     ISSUER: is the certificate of a possible issuer

     This function will check if the given CRL was issued by the given
     issuer certificate.  It will return true (1) if the given CRL was
     issued by the given issuer, and false (0) if not.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crl_deinit
----------------------

 -- Function: void gnutls_x509_crl_deinit (gnutls_x509_crl_t CRL)
     CRL: The structure to be initialized

     This function will deinitialize a CRL structure.

gnutls_x509_crl_export
----------------------

 -- Function: int gnutls_x509_crl_export (gnutls_x509_crl_t CRL,
          gnutls_x509_crt_fmt_t FORMAT, void * OUTPUT_DATA, size_t *
          OUTPUT_DATA_SIZE)
     CRL: Holds the revocation list

     FORMAT: the format of output params. One of PEM or DER.

     OUTPUT_DATA: will contain a private key PEM or DER encoded

     OUTPUT_DATA_SIZE: holds the size of output_data (and will be
     replaced by the actual size of parameters)

     This function will export the revocation list to DER or PEM format.

     If the buffer provided is not long enough to hold the output, then
     `GNUTLS_E_SHORT_MEMORY_BUFFER' will be returned.

     If the structure is PEM encoded, it will have a header of "BEGIN
     X509 CRL".

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value. and a negative value on failure.

gnutls_x509_crl_get_authority_key_id
------------------------------------

 -- Function: int gnutls_x509_crl_get_authority_key_id
          (gnutls_x509_crl_t CRL, void * RET, size_t * RET_SIZE,
          unsigned int * CRITICAL)
     CRL: should contain a `gnutls_x509_crl_t' structure

     RET: The place where the identifier will be copied

     RET_SIZE: Holds the size of the result field.

     CRITICAL: will be non zero if the extension is marked as critical
     (may be null)

     This function will return the CRL authority's key identifier.  This
     is obtained by the X.509 Authority Key identifier extension field
     (2.5.29.35).  Note that this function only returns the
     keyIdentifier field of the extension.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative value in case of an error.

     *Since:* 2.8.0

gnutls_x509_crl_get_crt_count
-----------------------------

 -- Function: int gnutls_x509_crl_get_crt_count (gnutls_x509_crl_t CRL)
     CRL: should contain a `gnutls_x509_crl_t' structure

     This function will return the number of revoked certificates in the
     given CRL.

     *Returns:* number of certificates, a negative value on failure.

gnutls_x509_crl_get_crt_serial
------------------------------

 -- Function: int gnutls_x509_crl_get_crt_serial (gnutls_x509_crl_t
          CRL, int INDX, unsigned char * SERIAL, size_t * SERIAL_SIZE,
          time_t * T)
     CRL: should contain a `gnutls_x509_crl_t' structure

     INDX: the index of the certificate to extract (starting from 0)

     SERIAL: where the serial number will be copied

     SERIAL_SIZE: initially holds the size of serial

     T: if non null, will hold the time this certificate was revoked

     This function will retrieve the serial number of the specified, by
     the index, revoked certificate.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value. and a negative value on error.

gnutls_x509_crl_get_dn_oid
--------------------------

 -- Function: int gnutls_x509_crl_get_dn_oid (gnutls_x509_crl_t CRL,
          int INDX, void * OID, size_t * SIZEOF_OID)
     CRL: should contain a gnutls_x509_crl_t structure

     INDX: Specifies which DN OID to send. Use zero to get the first
     one.

     OID: a pointer to a structure to hold the name (may be null)

     SIZEOF_OID: initially holds the size of 'oid'

     This function will extract the requested OID of the name of the CRL
     issuer, specified by the given index.

     If oid is null then only the size will be filled.

     *Returns:* `GNUTLS_E_SHORT_MEMORY_BUFFER' if the provided buffer is
     not long enough, and in that case the sizeof_oid will be updated
     with the required size.  On success 0 is returned.

gnutls_x509_crl_get_extension_data
----------------------------------

 -- Function: int gnutls_x509_crl_get_extension_data (gnutls_x509_crl_t
          CRL, int INDX, void * DATA, size_t * SIZEOF_DATA)
     CRL: should contain a `gnutls_x509_crl_t' structure

     INDX: Specifies which extension OID to send. Use zero to get the
     first one.

     DATA: a pointer to a structure to hold the data (may be null)

     SIZEOF_DATA: initially holds the size of `oid'

     This function will return the requested extension data in the CRL.
     The extension data will be stored as a string in the provided
     buffer.

     Use `gnutls_x509_crl_get_extension_info()' to extract the OID and
     critical flag.  Use `gnutls_x509_crl_get_extension_info()' instead,
     if you want to get data indexed by the extension OID rather than
     sequence.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative value in case of an error.  If your have reached the last
     extension available `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE' will
     be returned.

     *Since:* 2.8.0

gnutls_x509_crl_get_extension_info
----------------------------------

 -- Function: int gnutls_x509_crl_get_extension_info (gnutls_x509_crl_t
          CRL, int INDX, void * OID, size_t * SIZEOF_OID, int *
          CRITICAL)
     CRL: should contain a `gnutls_x509_crl_t' structure

     INDX: Specifies which extension OID to send, use zero to get the
     first one.

     OID: a pointer to a structure to hold the OID

     SIZEOF_OID: initially holds the maximum size of `oid', on return
     holds actual size of `oid'.

     CRITICAL: output variable with critical flag, may be NULL.

     This function will return the requested extension OID in the CRL,
     and the critical flag for it.  The extension OID will be stored as
     a string in the provided buffer.  Use
     `gnutls_x509_crl_get_extension_data()' to extract the data.

     If the buffer provided is not long enough to hold the output, then
     *`sizeof_oid' is updated and `GNUTLS_E_SHORT_MEMORY_BUFFER' will be
     returned.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative value in case of an error.  If your have reached the last
     extension available `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE' will
     be returned.

     *Since:* 2.8.0

gnutls_x509_crl_get_extension_oid
---------------------------------

 -- Function: int gnutls_x509_crl_get_extension_oid (gnutls_x509_crl_t
          CRL, int INDX, void * OID, size_t * SIZEOF_OID)
     CRL: should contain a `gnutls_x509_crl_t' structure

     INDX: Specifies which extension OID to send, use zero to get the
     first one.

     OID: a pointer to a structure to hold the OID (may be null)

     SIZEOF_OID: initially holds the size of `oid'

     This function will return the requested extension OID in the CRL.
     The extension OID will be stored as a string in the provided
     buffer.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative value in case of an error.  If your have reached the last
     extension available `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE' will
     be returned.

     *Since:* 2.8.0

gnutls_x509_crl_get_issuer_dn_by_oid
------------------------------------

 -- Function: int gnutls_x509_crl_get_issuer_dn_by_oid
          (gnutls_x509_crl_t CRL, const char * OID, int INDX, unsigned
          int RAW_FLAG, void * BUF, size_t * SIZEOF_BUF)
     CRL: should contain a gnutls_x509_crl_t structure

     OID: holds an Object Identified in null terminated string

     INDX: In case multiple same OIDs exist in the RDN, this specifies
     which to send. Use zero to get the first one.

     RAW_FLAG: If non zero returns the raw DER data of the DN part.

     BUF: a pointer to a structure to hold the peer's name (may be null)

     SIZEOF_BUF: initially holds the size of `buf'

     This function will extract the part of the name of the CRL issuer
     specified by the given OID. The output will be encoded as described
     in RFC2253. The output string will be ASCII or UTF-8 encoded,
     depending on the certificate data.

     Some helper macros with popular OIDs can be found in gnutls/x509.h
     If raw flag is zero, this function will only return known OIDs as
     text. Other OIDs will be DER encoded, as described in RFC2253 - in
     hex format with a '\#' prefix.  You can check about known OIDs
     using `gnutls_x509_dn_oid_known()'.

     If buf is null then only the size will be filled.

     *Returns:* `GNUTLS_E_SHORT_MEMORY_BUFFER' if the provided buffer is
     not long enough, and in that case the sizeof_buf will be updated
     with the required size, and 0 on success.

gnutls_x509_crl_get_issuer_dn
-----------------------------

 -- Function: int gnutls_x509_crl_get_issuer_dn (const
          gnutls_x509_crl_t CRL, char * BUF, size_t * SIZEOF_BUF)
     CRL: should contain a gnutls_x509_crl_t structure

     BUF: a pointer to a structure to hold the peer's name (may be null)

     SIZEOF_BUF: initially holds the size of `buf'

     This function will copy the name of the CRL issuer in the provided
     buffer. The name will be in the form "C=xxxx,O=yyyy,CN=zzzz" as
     described in RFC2253. The output string will be ASCII or UTF-8
     encoded, depending on the certificate data.

     If buf is `NULL' then only the size will be filled.

     *Returns:* `GNUTLS_E_SHORT_MEMORY_BUFFER' if the provided buffer is
     not long enough, and in that case the sizeof_buf will be updated
     with the required size, and 0 on success.

gnutls_x509_crl_get_next_update
-------------------------------

 -- Function: time_t gnutls_x509_crl_get_next_update (gnutls_x509_crl_t
          CRL)
     CRL: should contain a `gnutls_x509_crl_t' structure

     This function will return the time the next CRL will be issued.
     This field is optional in a CRL so it might be normal to get an
     error instead.

     *Returns:* when the next CRL will be issued, or (time_t)-1 on
     error.

gnutls_x509_crl_get_number
--------------------------

 -- Function: int gnutls_x509_crl_get_number (gnutls_x509_crl_t CRL,
          void * RET, size_t * RET_SIZE, unsigned int * CRITICAL)
     CRL: should contain a `gnutls_x509_crl_t' structure

     RET: The place where the number will be copied

     RET_SIZE: Holds the size of the result field.

     CRITICAL: will be non zero if the extension is marked as critical
     (may be null)

     This function will return the CRL number extension.  This is
     obtained by the CRL Number extension field (2.5.29.20).

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative value in case of an error.

     *Since:* 2.8.0

gnutls_x509_crl_get_raw_issuer_dn
---------------------------------

 -- Function: int gnutls_x509_crl_get_raw_issuer_dn (gnutls_x509_crl_t
          CRL, gnutls_datum_t * DN)
     CRL: should contain a gnutls_x509_crl_t structure

     DN: will hold the starting point of the DN

     This function will return a pointer to the DER encoded DN structure
     and the length.

     *Returns:* a negative value on error, and zero on success.

     *Since:* 2.12.0

gnutls_x509_crl_get_signature_algorithm
---------------------------------------

 -- Function: int gnutls_x509_crl_get_signature_algorithm
          (gnutls_x509_crl_t CRL)
     CRL: should contain a `gnutls_x509_crl_t' structure

     This function will return a value of the `gnutls_sign_algorithm_t'
     enumeration that is the signature algorithm.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crl_get_signature
-----------------------------

 -- Function: int gnutls_x509_crl_get_signature (gnutls_x509_crl_t CRL,
          char * SIG, size_t * SIZEOF_SIG)
     CRL: should contain a gnutls_x509_crl_t structure

     SIG: a pointer where the signature part will be copied (may be
     null).

     SIZEOF_SIG: initially holds the size of `sig'

     This function will extract the signature field of a CRL.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value. and a negative value on error.

gnutls_x509_crl_get_this_update
-------------------------------

 -- Function: time_t gnutls_x509_crl_get_this_update (gnutls_x509_crl_t
          CRL)
     CRL: should contain a `gnutls_x509_crl_t' structure

     This function will return the time this CRL was issued.

     *Returns:* when the CRL was issued, or (time_t)-1 on error.

gnutls_x509_crl_get_version
---------------------------

 -- Function: int gnutls_x509_crl_get_version (gnutls_x509_crl_t CRL)
     CRL: should contain a `gnutls_x509_crl_t' structure

     This function will return the version of the specified CRL.

     *Returns:* The version number, or a negative value on error.

gnutls_x509_crl_import
----------------------

 -- Function: int gnutls_x509_crl_import (gnutls_x509_crl_t CRL, const
          gnutls_datum_t * DATA, gnutls_x509_crt_fmt_t FORMAT)
     CRL: The structure to store the parsed CRL.

     DATA: The DER or PEM encoded CRL.

     FORMAT: One of DER or PEM

     This function will convert the given DER or PEM encoded CRL to the
     native `gnutls_x509_crl_t' format. The output will be stored in
     'crl'.

     If the CRL is PEM encoded it should have a header of "X509 CRL".

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crl_init
--------------------

 -- Function: int gnutls_x509_crl_init (gnutls_x509_crl_t * CRL)
     CRL: The structure to be initialized

     This function will initialize a CRL structure. CRL stands for
     Certificate Revocation List. A revocation list usually contains
     lists of certificate serial numbers that have been revoked by an
     Authority. The revocation lists are always signed with the
     authority's private key.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crl_print
---------------------

 -- Function: int gnutls_x509_crl_print (gnutls_x509_crl_t CRL,
          gnutls_certificate_print_formats_t FORMAT, gnutls_datum_t *
          OUT)
     CRL: The structure to be printed

     FORMAT: Indicate the format to use

     OUT: Newly allocated datum with zero terminated string.

     This function will pretty print a X.509 certificate revocation
     list, suitable for display to a human.

     The output `out' needs to be deallocate using `gnutls_free()'.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crl_privkey_sign
----------------------------

 -- Function: int gnutls_x509_crl_privkey_sign (gnutls_x509_crl_t CRL,
          gnutls_x509_crt_t ISSUER, gnutls_privkey_t ISSUER_KEY,
          gnutls_digest_algorithm_t DIG, unsigned int FLAGS)
     CRL: should contain a gnutls_x509_crl_t structure

     ISSUER: is the certificate of the certificate issuer

     ISSUER_KEY: holds the issuer's private key

     DIG: The message digest to use. GNUTLS_DIG_SHA1 is the safe choice
     unless you know what you're doing.

     FLAGS: must be 0

     This function will sign the CRL with the issuer's private key, and
     will copy the issuer's information into the CRL.

     This must be the last step in a certificate CRL since all the
     previously set parameters are now signed.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crl_set_authority_key_id
------------------------------------

 -- Function: int gnutls_x509_crl_set_authority_key_id
          (gnutls_x509_crl_t CRL, const void * ID, size_t ID_SIZE)
     CRL: a CRL of type `gnutls_x509_crl_t'

     ID: The key ID

     ID_SIZE: Holds the size of the serial field.

     This function will set the CRL's authority key ID extension.  Only
     the keyIdentifier field can be set with this function.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

     *Since:* 2.8.0

gnutls_x509_crl_set_crt_serial
------------------------------

 -- Function: int gnutls_x509_crl_set_crt_serial (gnutls_x509_crl_t
          CRL, const void * SERIAL, size_t SERIAL_SIZE, time_t
          REVOCATION_TIME)
     CRL: should contain a gnutls_x509_crl_t structure

     SERIAL: The revoked certificate's serial number

     SERIAL_SIZE: Holds the size of the serial field.

     REVOCATION_TIME: The time this certificate was revoked

     This function will set a revoked certificate's serial number to
     the CRL.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crl_set_crt
-----------------------

 -- Function: int gnutls_x509_crl_set_crt (gnutls_x509_crl_t CRL,
          gnutls_x509_crt_t CRT, time_t REVOCATION_TIME)
     CRL: should contain a gnutls_x509_crl_t structure

     CRT: a certificate of type `gnutls_x509_crt_t' with the revoked
     certificate

     REVOCATION_TIME: The time this certificate was revoked

     This function will set a revoked certificate's serial number to
     the CRL.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crl_set_next_update
-------------------------------

 -- Function: int gnutls_x509_crl_set_next_update (gnutls_x509_crl_t
          CRL, time_t EXP_TIME)
     CRL: should contain a gnutls_x509_crl_t structure

     EXP_TIME: The actual time

     This function will set the time this CRL will be updated.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crl_set_number
--------------------------

 -- Function: int gnutls_x509_crl_set_number (gnutls_x509_crl_t CRL,
          const void * NR, size_t NR_SIZE)
     CRL: a CRL of type `gnutls_x509_crl_t'

     NR: The CRL number

     NR_SIZE: Holds the size of the nr field.

     This function will set the CRL's number extension.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

     *Since:* 2.8.0

gnutls_x509_crl_set_this_update
-------------------------------

 -- Function: int gnutls_x509_crl_set_this_update (gnutls_x509_crl_t
          CRL, time_t ACT_TIME)
     CRL: should contain a gnutls_x509_crl_t structure

     ACT_TIME: The actual time

     This function will set the time this CRL was issued.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crl_set_version
---------------------------

 -- Function: int gnutls_x509_crl_set_version (gnutls_x509_crl_t CRL,
          unsigned int VERSION)
     CRL: should contain a gnutls_x509_crl_t structure

     VERSION: holds the version number. For CRLv1 crls must be 1.

     This function will set the version of the CRL. This must be one
     for CRL version 1, and so on. The CRLs generated by gnutls should
     have a version number of 2.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crl_sign2
---------------------

 -- Function: int gnutls_x509_crl_sign2 (gnutls_x509_crl_t CRL,
          gnutls_x509_crt_t ISSUER, gnutls_x509_privkey_t ISSUER_KEY,
          gnutls_digest_algorithm_t DIG, unsigned int FLAGS)
     CRL: should contain a gnutls_x509_crl_t structure

     ISSUER: is the certificate of the certificate issuer

     ISSUER_KEY: holds the issuer's private key

     DIG: The message digest to use. GNUTLS_DIG_SHA1 is the safe choice
     unless you know what you're doing.

     FLAGS: must be 0

     This function will sign the CRL with the issuer's private key, and
     will copy the issuer's information into the CRL.

     This must be the last step in a certificate CRL since all the
     previously set parameters are now signed.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

     *Deprecated:* Use `gnutls_x509_crl_privkey_sign()' instead.

gnutls_x509_crl_sign
--------------------

 -- Function: int gnutls_x509_crl_sign (gnutls_x509_crl_t CRL,
          gnutls_x509_crt_t ISSUER, gnutls_x509_privkey_t ISSUER_KEY)
     CRL: should contain a gnutls_x509_crl_t structure

     ISSUER: is the certificate of the certificate issuer

     ISSUER_KEY: holds the issuer's private key

     This function is the same a `gnutls_x509_crl_sign2()' with no
     flags, and SHA1 as the hash algorithm.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

     *Deprecated:* Use `gnutls_x509_crl_privkey_sign()'.

gnutls_x509_crl_verify
----------------------

 -- Function: int gnutls_x509_crl_verify (gnutls_x509_crl_t CRL, const
          gnutls_x509_crt_t * CA_LIST, int CA_LIST_LENGTH, unsigned int
          FLAGS, unsigned int * VERIFY)
     CRL: is the crl to be verified

     CA_LIST: is a certificate list that is considered to be trusted one

     CA_LIST_LENGTH: holds the number of CA certificates in CA_list

     FLAGS: Flags that may be used to change the verification
     algorithm. Use OR of the gnutls_certificate_verify_flags
     enumerations.

     VERIFY: will hold the crl verification output.

     This function will try to verify the given crl and return its
     status.  See `gnutls_x509_crt_list_verify()' for a detailed
     description of return values.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crq_deinit
----------------------

 -- Function: void gnutls_x509_crq_deinit (gnutls_x509_crq_t CRQ)
     CRQ: The structure to be initialized

     This function will deinitialize a PKCS`10' certificate request
     structure.

gnutls_x509_crq_export
----------------------

 -- Function: int gnutls_x509_crq_export (gnutls_x509_crq_t CRQ,
          gnutls_x509_crt_fmt_t FORMAT, void * OUTPUT_DATA, size_t *
          OUTPUT_DATA_SIZE)
     CRQ: should contain a `gnutls_x509_crq_t' structure

     FORMAT: the format of output params. One of PEM or DER.

     OUTPUT_DATA: will contain a certificate request PEM or DER encoded

     OUTPUT_DATA_SIZE: holds the size of output_data (and will be
     replaced by the actual size of parameters)

     This function will export the certificate request to a PEM or DER
     encoded PKCS10 structure.

     If the buffer provided is not long enough to hold the output, then
     `GNUTLS_E_SHORT_MEMORY_BUFFER' will be returned and
     *`output_data_size' will be updated.

     If the structure is PEM encoded, it will have a header of "BEGIN
     NEW CERTIFICATE REQUEST".

     *Return value:* In case of failure a negative value will be
     returned, and 0 on success.

gnutls_x509_crq_get_attribute_by_oid
------------------------------------

 -- Function: int gnutls_x509_crq_get_attribute_by_oid
          (gnutls_x509_crq_t CRQ, const char * OID, int INDX, void *
          BUF, size_t * SIZEOF_BUF)
     CRQ: should contain a `gnutls_x509_crq_t' structure

     OID: holds an Object Identified in zero-terminated string

     INDX: In case multiple same OIDs exist in the attribute list, this
     specifies which to send, use zero to get the first one

     BUF: a pointer to a structure to hold the attribute data (may be
     `NULL')

     SIZEOF_BUF: initially holds the size of `buf'

     This function will return the attribute in the certificate request
     specified by the given Object ID.  The attribute will be DER
     encoded.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crq_get_attribute_data
----------------------------------

 -- Function: int gnutls_x509_crq_get_attribute_data (gnutls_x509_crq_t
          CRQ, int INDX, void * DATA, size_t * SIZEOF_DATA)
     CRQ: should contain a `gnutls_x509_crq_t' structure

     INDX: Specifies which attribute OID to send. Use zero to get the
     first one.

     DATA: a pointer to a structure to hold the data (may be null)

     SIZEOF_DATA: initially holds the size of `oid'

     This function will return the requested attribute data in the
     certificate request.  The attribute data will be stored as a
     string in the provided buffer.

     Use `gnutls_x509_crq_get_attribute_info()' to extract the OID.
     Use `gnutls_x509_crq_get_attribute_by_oid()' instead, if you want
     to get data indexed by the attribute OID rather than sequence.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative value in case of an error.  If your have reached the last
     extension available `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE' will
     be returned.

     *Since:* 2.8.0

gnutls_x509_crq_get_attribute_info
----------------------------------

 -- Function: int gnutls_x509_crq_get_attribute_info (gnutls_x509_crq_t
          CRQ, int INDX, void * OID, size_t * SIZEOF_OID)
     CRQ: should contain a `gnutls_x509_crq_t' structure

     INDX: Specifies which attribute OID to send. Use zero to get the
     first one.

     OID: a pointer to a structure to hold the OID

     SIZEOF_OID: initially holds the maximum size of `oid', on return
     holds actual size of `oid'.

     This function will return the requested attribute OID in the
     certificate, and the critical flag for it.  The attribute OID will
     be stored as a string in the provided buffer.  Use
     `gnutls_x509_crq_get_attribute_data()' to extract the data.

     If the buffer provided is not long enough to hold the output, then
     *`sizeof_oid' is updated and `GNUTLS_E_SHORT_MEMORY_BUFFER' will be
     returned.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative value in case of an error.  If your have reached the last
     extension available `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE' will
     be returned.

     *Since:* 2.8.0

gnutls_x509_crq_get_basic_constraints
-------------------------------------

 -- Function: int gnutls_x509_crq_get_basic_constraints
          (gnutls_x509_crq_t CRQ, unsigned int * CRITICAL, int * CA,
          int * PATHLEN)
     CRQ: should contain a `gnutls_x509_crq_t' structure

     CRITICAL: will be non zero if the extension is marked as critical

     CA: pointer to output integer indicating CA status, may be NULL,
     value is 1 if the certificate CA flag is set, 0 otherwise.

     PATHLEN: pointer to output integer indicating path length (may be
     NULL), non-negative values indicate a present pathLenConstraint
     field and the actual value, -1 indicate that the field is absent.

     This function will read the certificate's basic constraints, and
     return the certificates CA status.  It reads the basicConstraints
     X.509 extension (2.5.29.19).

     *Return value:* If the certificate is a CA a positive value will be
     returned, or zero if the certificate does not have CA flag set.  A
     negative value may be returned in case of errors.  If the
     certificate does not contain the basicConstraints extension
     `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE' will be returned.

     *Since:* 2.8.0

gnutls_x509_crq_get_challenge_password
--------------------------------------

 -- Function: int gnutls_x509_crq_get_challenge_password
          (gnutls_x509_crq_t CRQ, char * PASS, size_t * SIZEOF_PASS)
     CRQ: should contain a `gnutls_x509_crq_t' structure

     PASS: will hold a zero-terminated password string

     SIZEOF_PASS: Initially holds the size of `pass'.

     This function will return the challenge password in the request.
     The challenge password is intended to be used for requesting a
     revocation of the certificate.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crq_get_dn_by_oid
-----------------------------

 -- Function: int gnutls_x509_crq_get_dn_by_oid (gnutls_x509_crq_t CRQ,
          const char * OID, int INDX, unsigned int RAW_FLAG, void *
          BUF, size_t * SIZEOF_BUF)
     CRQ: should contain a gnutls_x509_crq_t structure

     OID: holds an Object Identified in null terminated string

     INDX: In case multiple same OIDs exist in the RDN, this specifies
     which to send. Use zero to get the first one.

     RAW_FLAG: If non zero returns the raw DER data of the DN part.

     BUF: a pointer to a structure to hold the name (may be `NULL')

     SIZEOF_BUF: initially holds the size of `buf'

     This function will extract the part of the name of the Certificate
     request subject, specified by the given OID. The output will be
     encoded as described in RFC2253. The output string will be ASCII
     or UTF-8 encoded, depending on the certificate data.

     Some helper macros with popular OIDs can be found in gnutls/x509.h
     If raw flag is zero, this function will only return known OIDs as
     text. Other OIDs will be DER encoded, as described in RFC2253 - in
     hex format with a '\#' prefix.  You can check about known OIDs
     using `gnutls_x509_dn_oid_known()'.

     *Returns:* `GNUTLS_E_SHORT_MEMORY_BUFFER' if the provided buffer is
     not long enough, and in that case the *`sizeof_buf' will be
     updated with the required size.  On success 0 is returned.

gnutls_x509_crq_get_dn_oid
--------------------------

 -- Function: int gnutls_x509_crq_get_dn_oid (gnutls_x509_crq_t CRQ,
          int INDX, void * OID, size_t * SIZEOF_OID)
     CRQ: should contain a gnutls_x509_crq_t structure

     INDX: Specifies which DN OID to send. Use zero to get the first
     one.

     OID: a pointer to a structure to hold the name (may be `NULL')

     SIZEOF_OID: initially holds the size of `oid'

     This function will extract the requested OID of the name of the
     certificate request subject, specified by the given index.

     *Returns:* `GNUTLS_E_SHORT_MEMORY_BUFFER' if the provided buffer is
     not long enough, and in that case the *`sizeof_oid' will be
     updated with the required size.  On success 0 is returned.

gnutls_x509_crq_get_dn
----------------------

 -- Function: int gnutls_x509_crq_get_dn (gnutls_x509_crq_t CRQ, char *
          BUF, size_t * SIZEOF_BUF)
     CRQ: should contain a `gnutls_x509_crq_t' structure

     BUF: a pointer to a structure to hold the name (may be `NULL')

     SIZEOF_BUF: initially holds the size of `buf'

     This function will copy the name of the Certificate request subject
     to the provided buffer.  The name will be in the form
     "C=xxxx,O=yyyy,CN=zzzz" as described in RFC 2253. The output string
     `buf' will be ASCII or UTF-8 encoded, depending on the certificate
     data.

     *Returns:* `GNUTLS_E_SHORT_MEMORY_BUFFER' if the provided buffer
     is not long enough, and in that case the *`sizeof_buf' will be
     updated with the required size.  On success 0 is returned.

gnutls_x509_crq_get_extension_by_oid
------------------------------------

 -- Function: int gnutls_x509_crq_get_extension_by_oid
          (gnutls_x509_crq_t CRQ, const char * OID, int INDX, void *
          BUF, size_t * SIZEOF_BUF, unsigned int * CRITICAL)
     CRQ: should contain a `gnutls_x509_crq_t' structure

     OID: holds an Object Identified in null terminated string

     INDX: In case multiple same OIDs exist in the extensions, this
     specifies which to send. Use zero to get the first one.

     BUF: a pointer to a structure to hold the name (may be null)

     SIZEOF_BUF: initially holds the size of `buf'

     CRITICAL: will be non zero if the extension is marked as critical

     This function will return the extension specified by the OID in
     the certificate.  The extensions will be returned as binary data
     DER encoded, in the provided buffer.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative value in case of an error.  If the certificate does not
     contain the specified extension
     `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE' will be returned.

     *Since:* 2.8.0

gnutls_x509_crq_get_extension_data
----------------------------------

 -- Function: int gnutls_x509_crq_get_extension_data (gnutls_x509_crq_t
          CRQ, int INDX, void * DATA, size_t * SIZEOF_DATA)
     CRQ: should contain a `gnutls_x509_crq_t' structure

     INDX: Specifies which extension OID to send. Use zero to get the
     first one.

     DATA: a pointer to a structure to hold the data (may be null)

     SIZEOF_DATA: initially holds the size of `oid'

     This function will return the requested extension data in the
     certificate.  The extension data will be stored as a string in the
     provided buffer.

     Use `gnutls_x509_crq_get_extension_info()' to extract the OID and
     critical flag.  Use `gnutls_x509_crq_get_extension_by_oid()'
     instead, if you want to get data indexed by the extension OID
     rather than sequence.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative value in case of an error.  If your have reached the last
     extension available `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE' will
     be returned.

     *Since:* 2.8.0

gnutls_x509_crq_get_extension_info
----------------------------------

 -- Function: int gnutls_x509_crq_get_extension_info (gnutls_x509_crq_t
          CRQ, int INDX, void * OID, size_t * SIZEOF_OID, int *
          CRITICAL)
     CRQ: should contain a `gnutls_x509_crq_t' structure

     INDX: Specifies which extension OID to send. Use zero to get the
     first one.

     OID: a pointer to a structure to hold the OID

     SIZEOF_OID: initially holds the maximum size of `oid', on return
     holds actual size of `oid'.

     CRITICAL: output variable with critical flag, may be NULL.

     This function will return the requested extension OID in the
     certificate, and the critical flag for it.  The extension OID will
     be stored as a string in the provided buffer.  Use
     `gnutls_x509_crq_get_extension_data()' to extract the data.

     If the buffer provided is not long enough to hold the output, then
     *`sizeof_oid' is updated and `GNUTLS_E_SHORT_MEMORY_BUFFER' will be
     returned.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative value in case of an error.  If your have reached the last
     extension available `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE' will
     be returned.

     *Since:* 2.8.0

gnutls_x509_crq_get_key_id
--------------------------

 -- Function: int gnutls_x509_crq_get_key_id (gnutls_x509_crq_t CRQ,
          unsigned int FLAGS, unsigned char * OUTPUT_DATA, size_t *
          OUTPUT_DATA_SIZE)
     CRQ: a certificate of type `gnutls_x509_crq_t'

     FLAGS: should be 0 for now

     OUTPUT_DATA: will contain the key ID

     OUTPUT_DATA_SIZE: holds the size of output_data (and will be
     replaced by the actual size of parameters)

     This function will return a unique ID the depends on the public key
     parameters.  This ID can be used in checking whether a certificate
     corresponds to the given private key.

     If the buffer provided is not long enough to hold the output, then
     *`output_data_size' is updated and GNUTLS_E_SHORT_MEMORY_BUFFER
     will be returned.  The output will normally be a SHA-1 hash output,
     which is 20 bytes.

     *Return value:* In case of failure a negative value will be
     returned, and 0 on success.

     *Since:* 2.8.0

gnutls_x509_crq_get_key_purpose_oid
-----------------------------------

 -- Function: int gnutls_x509_crq_get_key_purpose_oid
          (gnutls_x509_crq_t CRQ, int INDX, void * OID, size_t *
          SIZEOF_OID, unsigned int * CRITICAL)
     CRQ: should contain a `gnutls_x509_crq_t' structure

     INDX: This specifies which OID to return, use zero to get the
     first one

     OID: a pointer to a buffer to hold the OID (may be `NULL')

     SIZEOF_OID: initially holds the size of `oid'

     CRITICAL: output variable with critical flag, may be `NULL'.

     This function will extract the key purpose OIDs of the Certificate
     specified by the given index.  These are stored in the Extended Key
     Usage extension (2.5.29.37).  See the GNUTLS_KP_* definitions for
     human readable names.

     *Returns:* `GNUTLS_E_SHORT_MEMORY_BUFFER' if the provided buffer is
     not long enough, and in that case the *`sizeof_oid' will be
     updated with the required size.  On success 0 is returned.

     *Since:* 2.8.0

gnutls_x509_crq_get_key_rsa_raw
-------------------------------

 -- Function: int gnutls_x509_crq_get_key_rsa_raw (gnutls_x509_crq_t
          CRQ, gnutls_datum_t * M, gnutls_datum_t * E)
     CRQ: Holds the certificate

     M: will hold the modulus

     E: will hold the public exponent

     This function will export the RSA public key's parameters found in
     the given structure.  The new parameters will be allocated using
     `gnutls_malloc()' and will be stored in the appropriate datum.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

     *Since:* 2.8.0

gnutls_x509_crq_get_key_usage
-----------------------------

 -- Function: int gnutls_x509_crq_get_key_usage (gnutls_x509_crq_t CRQ,
          unsigned int * KEY_USAGE, unsigned int * CRITICAL)
     CRQ: should contain a `gnutls_x509_crq_t' structure

     KEY_USAGE: where the key usage bits will be stored

     CRITICAL: will be non zero if the extension is marked as critical

     This function will return certificate's key usage, by reading the
     keyUsage X.509 extension (2.5.29.15).  The key usage value will

     *ORed values of the:* `GNUTLS_KEY_DIGITAL_SIGNATURE',
     `GNUTLS_KEY_NON_REPUDIATION', `GNUTLS_KEY_KEY_ENCIPHERMENT',
     `GNUTLS_KEY_DATA_ENCIPHERMENT', `GNUTLS_KEY_KEY_AGREEMENT',
     `GNUTLS_KEY_KEY_CERT_SIGN', `GNUTLS_KEY_CRL_SIGN',
     `GNUTLS_KEY_ENCIPHER_ONLY', `GNUTLS_KEY_DECIPHER_ONLY'.

     *Returns:* the certificate key usage, or a negative value in case
     of parsing error.  If the certificate does not contain the keyUsage
     extension `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE' will be returned.

     *Since:* 2.8.0

gnutls_x509_crq_get_pk_algorithm
--------------------------------

 -- Function: int gnutls_x509_crq_get_pk_algorithm (gnutls_x509_crq_t
          CRQ, unsigned int * BITS)
     CRQ: should contain a `gnutls_x509_crq_t' structure

     BITS: if bits is non-`NULL' it will hold the size of the
     parameters' in bits

     This function will return the public key algorithm of a PKCS`10'
     certificate request.

     If bits is non-`NULL', it should have enough size to hold the
     parameters size in bits.  For RSA the bits returned is the modulus.
     For DSA the bits returned are of the public exponent.

     *Returns:* a member of the `gnutls_pk_algorithm_t' enumeration on
     success, or a negative value on error.

gnutls_x509_crq_get_subject_alt_name
------------------------------------

 -- Function: int gnutls_x509_crq_get_subject_alt_name
          (gnutls_x509_crq_t CRQ, unsigned int SEQ, void * RET, size_t
          * RET_SIZE, unsigned int * RET_TYPE, unsigned int * CRITICAL)
     CRQ: should contain a `gnutls_x509_crq_t' structure

     SEQ: specifies the sequence number of the alt name, 0 for the
     first one, 1 for the second etc.

     RET: is the place where the alternative name will be copied to

     RET_SIZE: holds the size of ret.

     RET_TYPE: holds the `gnutls_x509_subject_alt_name_t' name type

     CRITICAL: will be non zero if the extension is marked as critical
     (may be null)

     This function will return the alternative names, contained in the
     given certificate.  It is the same as
     `gnutls_x509_crq_get_subject_alt_name()' except for the fact that
     it will return the type of the alternative name in `ret_type' even
     if the function fails for some reason (i.e.  the buffer provided is
     not enough).

     *Returns:* the alternative subject name type on success, one of the
     enumerated `gnutls_x509_subject_alt_name_t'.  It will return
     `GNUTLS_E_SHORT_MEMORY_BUFFER' if `ret_size' is not large enough to
     hold the value.  In that case `ret_size' will be updated with the
     required size.  If the certificate request does not have an
     Alternative name with the specified sequence number then
     `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE' is returned.

     *Since:* 2.8.0

gnutls_x509_crq_get_subject_alt_othername_oid
---------------------------------------------

 -- Function: int gnutls_x509_crq_get_subject_alt_othername_oid
          (gnutls_x509_crq_t CRQ, unsigned int SEQ, void * RET, size_t
          * RET_SIZE)
     CRQ: should contain a `gnutls_x509_crq_t' structure

     SEQ: specifies the sequence number of the alt name (0 for the
     first one, 1 for the second etc.)

     RET: is the place where the otherName OID will be copied to

     RET_SIZE: holds the size of ret.

     This function will extract the type OID of an otherName Subject
     Alternative Name, contained in the given certificate, and return
     the type as an enumerated element.

     This function is only useful if
     `gnutls_x509_crq_get_subject_alt_name()' returned
     `GNUTLS_SAN_OTHERNAME'.

     *Returns:* the alternative subject name type on success, one of the
     enumerated gnutls_x509_subject_alt_name_t.  For supported OIDs, it
     will return one of the virtual (GNUTLS_SAN_OTHERNAME_*) types,
     e.g. `GNUTLS_SAN_OTHERNAME_XMPP', and `GNUTLS_SAN_OTHERNAME' for
     unknown OIDs.  It will return `GNUTLS_E_SHORT_MEMORY_BUFFER' if
     `ret_size' is not large enough to hold the value.  In that case
     `ret_size' will be updated with the required size.  If the
     certificate does not have an Alternative name with the specified
     sequence number and with the otherName type then
     `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE' is returned.

     *Since:* 2.8.0

gnutls_x509_crq_get_version
---------------------------

 -- Function: int gnutls_x509_crq_get_version (gnutls_x509_crq_t CRQ)
     CRQ: should contain a `gnutls_x509_crq_t' structure

     This function will return the version of the specified Certificate
     request.

     *Returns:* version of certificate request, or a negative value on
     error.

gnutls_x509_crq_import
----------------------

 -- Function: int gnutls_x509_crq_import (gnutls_x509_crq_t CRQ, const
          gnutls_datum_t * DATA, gnutls_x509_crt_fmt_t FORMAT)
     CRQ: The structure to store the parsed certificate request.

     DATA: The DER or PEM encoded certificate.

     FORMAT: One of DER or PEM

     This function will convert the given DER or PEM encoded certificate
     request to a `gnutls_x509_crq_t' structure.  The output will be
     stored in `crq'.

     If the Certificate is PEM encoded it should have a header of "NEW
     CERTIFICATE REQUEST".

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crq_init
--------------------

 -- Function: int gnutls_x509_crq_init (gnutls_x509_crq_t * CRQ)
     CRQ: The structure to be initialized

     This function will initialize a PKCS`10' certificate request
     structure.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crq_print
---------------------

 -- Function: int gnutls_x509_crq_print (gnutls_x509_crq_t CRQ,
          gnutls_certificate_print_formats_t FORMAT, gnutls_datum_t *
          OUT)
     CRQ: The structure to be printed

     FORMAT: Indicate the format to use

     OUT: Newly allocated datum with zero terminated string.

     This function will pretty print a certificate request, suitable for
     display to a human.

     The output `out' needs to be deallocate using `gnutls_free()'.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

     *Since:* 2.8.0

gnutls_x509_crq_privkey_sign
----------------------------

 -- Function: int gnutls_x509_crq_privkey_sign (gnutls_x509_crq_t CRQ,
          gnutls_privkey_t KEY, gnutls_digest_algorithm_t DIG, unsigned
          int FLAGS)
     CRQ: should contain a `gnutls_x509_crq_t' structure

     KEY: holds a private key

     DIG: The message digest to use, i.e., `GNUTLS_DIG_SHA1'

     FLAGS: must be 0

     This function will sign the certificate request with a private key.
     This must be the same key as the one used in
     `gnutls_x509_crt_set_key()' since a certificate request is self
     signed.

     This must be the last step in a certificate request generation
     since all the previously set parameters are now signed.

     *Returns:* `GNUTLS_E_SUCCESS' on success, otherwise an error.
     `GNUTLS_E_ASN1_VALUE_NOT_FOUND' is returned if you didn't set all
     information in the certificate request (e.g., the version using
     `gnutls_x509_crq_set_version()').

gnutls_x509_crq_set_attribute_by_oid
------------------------------------

 -- Function: int gnutls_x509_crq_set_attribute_by_oid
          (gnutls_x509_crq_t CRQ, const char * OID, void * BUF, size_t
          SIZEOF_BUF)
     CRQ: should contain a `gnutls_x509_crq_t' structure

     OID: holds an Object Identified in zero-terminated string

     BUF: a pointer to a structure that holds the attribute data

     SIZEOF_BUF: holds the size of `buf'

     This function will set the attribute in the certificate request
     specified by the given Object ID.  The attribute must be be DER
     encoded.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crq_set_basic_constraints
-------------------------------------

 -- Function: int gnutls_x509_crq_set_basic_constraints
          (gnutls_x509_crq_t CRQ, unsigned int CA, int
          PATHLENCONSTRAINT)
     CRQ: a certificate request of type `gnutls_x509_crq_t'

     CA: true(1) or false(0) depending on the Certificate authority
     status.

     PATHLENCONSTRAINT: non-negative values indicate maximum length of
     path, and negative values indicate that the pathLenConstraints
     field should not be present.

     This function will set the basicConstraints certificate extension.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

     *Since:* 2.8.0

gnutls_x509_crq_set_challenge_password
--------------------------------------

 -- Function: int gnutls_x509_crq_set_challenge_password
          (gnutls_x509_crq_t CRQ, const char * PASS)
     CRQ: should contain a `gnutls_x509_crq_t' structure

     PASS: holds a zero-terminated password

     This function will set a challenge password to be used when
     revoking the request.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crq_set_dn_by_oid
-----------------------------

 -- Function: int gnutls_x509_crq_set_dn_by_oid (gnutls_x509_crq_t CRQ,
          const char * OID, unsigned int RAW_FLAG, const void * DATA,
          unsigned int SIZEOF_DATA)
     CRQ: should contain a `gnutls_x509_crq_t' structure

     OID: holds an Object Identifier in a zero-terminated string

     RAW_FLAG: must be 0, or 1 if the data are DER encoded

     DATA: a pointer to the input data

     SIZEOF_DATA: holds the size of `data'

     This function will set the part of the name of the Certificate
     request subject, specified by the given OID.  The input string
     should be ASCII or UTF-8 encoded.

     Some helper macros with popular OIDs can be found in gnutls/x509.h
     With this function you can only set the known OIDs.  You can test
     for known OIDs using `gnutls_x509_dn_oid_known()'.  For OIDs that
     are not known (by gnutls) you should properly DER encode your
     data, and call this function with raw_flag set.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crq_set_key_purpose_oid
-----------------------------------

 -- Function: int gnutls_x509_crq_set_key_purpose_oid
          (gnutls_x509_crq_t CRQ, const void * OID, unsigned int
          CRITICAL)
     CRQ: a certificate of type `gnutls_x509_crq_t'

     OID: a pointer to a zero-terminated string that holds the OID

     CRITICAL: Whether this extension will be critical or not

     This function will set the key purpose OIDs of the Certificate.
     These are stored in the Extended Key Usage extension (2.5.29.37)
     See the GNUTLS_KP_* definitions for human readable names.

     Subsequent calls to this function will append OIDs to the OID list.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

     *Since:* 2.8.0

gnutls_x509_crq_set_key_rsa_raw
-------------------------------

 -- Function: int gnutls_x509_crq_set_key_rsa_raw (gnutls_x509_crq_t
          CRQ, const gnutls_datum_t * M, const gnutls_datum_t * E)
     CRQ: should contain a `gnutls_x509_crq_t' structure

     M: holds the modulus

     E: holds the public exponent

     This function will set the public parameters from the given private
     key to the request. Only RSA keys are currently supported.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

     *Since:* 2.6.0

gnutls_x509_crq_set_key_usage
-----------------------------

 -- Function: int gnutls_x509_crq_set_key_usage (gnutls_x509_crq_t CRQ,
          unsigned int USAGE)
     CRQ: a certificate request of type `gnutls_x509_crq_t'

     USAGE: an ORed sequence of the GNUTLS_KEY_* elements.

     This function will set the keyUsage certificate extension.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

     *Since:* 2.8.0

gnutls_x509_crq_set_key
-----------------------

 -- Function: int gnutls_x509_crq_set_key (gnutls_x509_crq_t CRQ,
          gnutls_x509_privkey_t KEY)
     CRQ: should contain a `gnutls_x509_crq_t' structure

     KEY: holds a private key

     This function will set the public parameters from the given private
     key to the request.  Only RSA keys are currently supported.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crq_set_subject_alt_name
------------------------------------

 -- Function: int gnutls_x509_crq_set_subject_alt_name
          (gnutls_x509_crq_t CRQ, gnutls_x509_subject_alt_name_t NT,
          const void * DATA, unsigned int DATA_SIZE, unsigned int FLAGS)
     CRQ: a certificate request of type `gnutls_x509_crq_t'

     NT: is one of the `gnutls_x509_subject_alt_name_t' enumerations

     DATA: The data to be set

     DATA_SIZE: The size of data to be set

     FLAGS: `GNUTLS_FSAN_SET' to clear previous data or
     `GNUTLS_FSAN_APPEND' to append.

     This function will set the subject alternative name certificate
     extension.  It can set the following types:

     &GNUTLS_SAN_DNSNAME: as a text string

     &GNUTLS_SAN_RFC822NAME: as a text string

     &GNUTLS_SAN_URI: as a text string

     &GNUTLS_SAN_IPADDRESS: as a binary IP address (4 or 16 bytes)

     Other values can be set as binary values with the proper DER
     encoding.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

     *Since:* 2.8.0

gnutls_x509_crq_set_version
---------------------------

 -- Function: int gnutls_x509_crq_set_version (gnutls_x509_crq_t CRQ,
          unsigned int VERSION)
     CRQ: should contain a `gnutls_x509_crq_t' structure

     VERSION: holds the version number, for v1 Requests must be 1

     This function will set the version of the certificate request.  For
     version 1 requests this must be one.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crq_sign2
---------------------

 -- Function: int gnutls_x509_crq_sign2 (gnutls_x509_crq_t CRQ,
          gnutls_x509_privkey_t KEY, gnutls_digest_algorithm_t DIG,
          unsigned int FLAGS)
     CRQ: should contain a `gnutls_x509_crq_t' structure

     KEY: holds a private key

     DIG: The message digest to use, i.e., `GNUTLS_DIG_SHA1'

     FLAGS: must be 0

     This function will sign the certificate request with a private key.
     This must be the same key as the one used in
     `gnutls_x509_crt_set_key()' since a certificate request is self
     signed.

     This must be the last step in a certificate request generation
     since all the previously set parameters are now signed.

     *Returns:* `GNUTLS_E_SUCCESS' on success, otherwise an error.
     `GNUTLS_E_ASN1_VALUE_NOT_FOUND' is returned if you didn't set all
     information in the certificate request (e.g., the version using
     `gnutls_x509_crq_set_version()').

     *Deprecated:* Use `gnutls_x509_crq_privkey_sign()' instead.

gnutls_x509_crq_sign
--------------------

 -- Function: int gnutls_x509_crq_sign (gnutls_x509_crq_t CRQ,
          gnutls_x509_privkey_t KEY)
     CRQ: should contain a `gnutls_x509_crq_t' structure

     KEY: holds a private key

     This function is the same a `gnutls_x509_crq_sign2()' with no
     flags, and SHA1 as the hash algorithm.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

     *Deprecated:* Use `gnutls_x509_crq_privkey_sign()' instead.

gnutls_x509_crq_verify
----------------------

 -- Function: int gnutls_x509_crq_verify (gnutls_x509_crq_t CRQ,
          unsigned int FLAGS)
     CRQ: is the crq to be verified

     FLAGS: Flags that may be used to change the verification
     algorithm. Use OR of the gnutls_certificate_verify_flags
     enumerations.

     This function will verify self signature in the certificate
     request and return its status.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned,
     `GNUTLS_E_PK_SIG_VERIFY_FAILED' if verification failed, otherwise
     a negative error value.

gnutls_x509_crt_check_hostname
------------------------------

 -- Function: int gnutls_x509_crt_check_hostname (gnutls_x509_crt_t
          CERT, const char * HOSTNAME)
     CERT: should contain an gnutls_x509_crt_t structure

     HOSTNAME: A null terminated string that contains a DNS name

     This function will check if the given certificate's subject matches
     the given hostname.  This is a basic implementation of the matching
     described in RFC2818 (HTTPS), which takes into account wildcards,
     and the DNSName/IPAddress subject alternative name PKIX extension.

     *Returns:* non zero for a successful match, and zero on failure.

gnutls_x509_crt_check_issuer
----------------------------

 -- Function: int gnutls_x509_crt_check_issuer (gnutls_x509_crt_t CERT,
          gnutls_x509_crt_t ISSUER)
     CERT: is the certificate to be checked

     ISSUER: is the certificate of a possible issuer

     This function will check if the given certificate was issued by the
     given issuer.

     *Returns:* It will return true (1) if the given certificate is
     issued by the given issuer, and false (0) if not.  A negative
     value is returned in case of an error.

gnutls_x509_crt_check_revocation
--------------------------------

 -- Function: int gnutls_x509_crt_check_revocation (gnutls_x509_crt_t
          CERT, const gnutls_x509_crl_t * CRL_LIST, int CRL_LIST_LENGTH)
     CERT: should contain a `gnutls_x509_crt_t' structure

     CRL_LIST: should contain a list of gnutls_x509_crl_t structures

     CRL_LIST_LENGTH: the length of the crl_list

     This function will return check if the given certificate is
     revoked.  It is assumed that the CRLs have been verified before.

     *Returns:* 0 if the certificate is NOT revoked, and 1 if it is.  A
     negative value is returned on error.

gnutls_x509_crt_cpy_crl_dist_points
-----------------------------------

 -- Function: int gnutls_x509_crt_cpy_crl_dist_points
          (gnutls_x509_crt_t DST, gnutls_x509_crt_t SRC)
     DST: a certificate of type `gnutls_x509_crt_t'

     SRC: the certificate where the dist points will be copied from

     This function will copy the CRL distribution points certificate
     extension, from the source to the destination certificate.  This
     may be useful to copy from a CA certificate to issued ones.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_deinit
----------------------

 -- Function: void gnutls_x509_crt_deinit (gnutls_x509_crt_t CERT)
     CERT: The structure to be deinitialized

     This function will deinitialize a certificate structure.

gnutls_x509_crt_export
----------------------

 -- Function: int gnutls_x509_crt_export (gnutls_x509_crt_t CERT,
          gnutls_x509_crt_fmt_t FORMAT, void * OUTPUT_DATA, size_t *
          OUTPUT_DATA_SIZE)
     CERT: Holds the certificate

     FORMAT: the format of output params. One of PEM or DER.

     OUTPUT_DATA: will contain a certificate PEM or DER encoded

     OUTPUT_DATA_SIZE: holds the size of output_data (and will be
     replaced by the actual size of parameters)

     This function will export the certificate to DER or PEM format.

     If the buffer provided is not long enough to hold the output, then
     *output_data_size is updated and GNUTLS_E_SHORT_MEMORY_BUFFER will
     be returned.

     If the structure is PEM encoded, it will have a header of "BEGIN
     CERTIFICATE".

     *Return value:* In case of failure a negative value will be
     returned, and 0 on success.

gnutls_x509_crt_get_activation_time
-----------------------------------

 -- Function: time_t gnutls_x509_crt_get_activation_time
          (gnutls_x509_crt_t CERT)
     CERT: should contain a `gnutls_x509_crt_t' structure

     This function will return the time this Certificate was or will be
     activated.

     *Returns:* activation time, or (time_t)-1 on error.

gnutls_x509_crt_get_authority_key_id
------------------------------------

 -- Function: int gnutls_x509_crt_get_authority_key_id
          (gnutls_x509_crt_t CERT, void * RET, size_t * RET_SIZE,
          unsigned int * CRITICAL)
     CERT: should contain a `gnutls_x509_crt_t' structure

     RET: The place where the identifier will be copied

     RET_SIZE: Holds the size of the result field.

     CRITICAL: will be non zero if the extension is marked as critical
     (may be null)

     This function will return the X.509v3 certificate authority's key
     identifier.  This is obtained by the X.509 Authority Key
     identifier extension field (2.5.29.35). Note that this function
     only returns the keyIdentifier field of the extension.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_get_basic_constraints
-------------------------------------

 -- Function: int gnutls_x509_crt_get_basic_constraints
          (gnutls_x509_crt_t CERT, unsigned int * CRITICAL, int * CA,
          int * PATHLEN)
     CERT: should contain a `gnutls_x509_crt_t' structure

     CRITICAL: will be non zero if the extension is marked as critical

     CA: pointer to output integer indicating CA status, may be NULL,
     value is 1 if the certificate CA flag is set, 0 otherwise.

     PATHLEN: pointer to output integer indicating path length (may be
     NULL), non-negative values indicate a present pathLenConstraint
     field and the actual value, -1 indicate that the field is absent.

     This function will read the certificate's basic constraints, and
     return the certificates CA status.  It reads the basicConstraints
     X.509 extension (2.5.29.19).

     *Return value:* If the certificate is a CA a positive value will be
     returned, or zero if the certificate does not have CA flag set.  A
     negative value may be returned in case of errors.  If the
     certificate does not contain the basicConstraints extension
     GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE will be returned.

gnutls_x509_crt_get_ca_status
-----------------------------

 -- Function: int gnutls_x509_crt_get_ca_status (gnutls_x509_crt_t
          CERT, unsigned int * CRITICAL)
     CERT: should contain a `gnutls_x509_crt_t' structure

     CRITICAL: will be non zero if the extension is marked as critical

     This function will return certificates CA status, by reading the
     basicConstraints X.509 extension (2.5.29.19). If the certificate is
     a CA a positive value will be returned, or zero if the certificate
     does not have CA flag set.

     Use `gnutls_x509_crt_get_basic_constraints()' if you want to read
     the pathLenConstraint field too.

     *Returns:* A negative value may be returned in case of parsing
     error.  If the certificate does not contain the basicConstraints
     extension `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE' will be returned.

gnutls_x509_crt_get_crl_dist_points
-----------------------------------

 -- Function: int gnutls_x509_crt_get_crl_dist_points
          (gnutls_x509_crt_t CERT, unsigned int SEQ, void * RET, size_t
          * RET_SIZE, unsigned int * REASON_FLAGS, unsigned int *
          CRITICAL)
     CERT: should contain a `gnutls_x509_crt_t' structure

     SEQ: specifies the sequence number of the distribution point (0
     for the first one, 1 for the second etc.)

     RET: is the place where the distribution point will be copied to

     RET_SIZE: holds the size of ret.

     REASON_FLAGS: Revocation reasons flags.

     CRITICAL: will be non zero if the extension is marked as critical
     (may be null)

     This function retrieves the CRL distribution points (2.5.29.31),
     contained in the given certificate in the X509v3 Certificate
     Extensions.

     `reason_flags' should be an ORed sequence of
     `GNUTLS_CRL_REASON_UNUSED', `GNUTLS_CRL_REASON_KEY_COMPROMISE',
     `GNUTLS_CRL_REASON_CA_COMPROMISE',
     `GNUTLS_CRL_REASON_AFFILIATION_CHANGED',
     `GNUTLS_CRL_REASON_SUPERSEEDED',
     `GNUTLS_CRL_REASON_CESSATION_OF_OPERATION',
     `GNUTLS_CRL_REASON_CERTIFICATE_HOLD',
     `GNUTLS_CRL_REASON_PRIVILEGE_WITHDRAWN',
     `GNUTLS_CRL_REASON_AA_COMPROMISE', or zero for all possible
     reasons.

     *Returns:* `GNUTLS_E_SHORT_MEMORY_BUFFER' and updates &`ret_size'
     if &`ret_size' is not enough to hold the distribution point, or the
     type of the distribution point if everything was ok. The type is
     one of the enumerated `gnutls_x509_subject_alt_name_t'.  If the
     certificate does not have an Alternative name with the specified
     sequence number then `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE' is
     returned.

gnutls_x509_crt_get_dn_by_oid
-----------------------------

 -- Function: int gnutls_x509_crt_get_dn_by_oid (gnutls_x509_crt_t
          CERT, const char * OID, int INDX, unsigned int RAW_FLAG, void
          * BUF, size_t * SIZEOF_BUF)
     CERT: should contain a `gnutls_x509_crt_t' structure

     OID: holds an Object Identified in null terminated string

     INDX: In case multiple same OIDs exist in the RDN, this specifies
     which to send. Use zero to get the first one.

     RAW_FLAG: If non zero returns the raw DER data of the DN part.

     BUF: a pointer where the DN part will be copied (may be null).

     SIZEOF_BUF: initially holds the size of `buf'

     This function will extract the part of the name of the Certificate
     subject specified by the given OID. The output, if the raw flag is
     not used, will be encoded as described in RFC2253. Thus a string
     that is ASCII or UTF-8 encoded, depending on the certificate data.

     Some helper macros with popular OIDs can be found in gnutls/x509.h
     If raw flag is zero, this function will only return known OIDs as
     text. Other OIDs will be DER encoded, as described in RFC2253 - in
     hex format with a '\#' prefix.  You can check about known OIDs
     using `gnutls_x509_dn_oid_known()'.

     If `buf' is null then only the size will be filled.

     *Returns:* `GNUTLS_E_SHORT_MEMORY_BUFFER' if the provided buffer is
     not long enough, and in that case the *sizeof_buf will be updated
     with the required size.  On success 0 is returned.

gnutls_x509_crt_get_dn_oid
--------------------------

 -- Function: int gnutls_x509_crt_get_dn_oid (gnutls_x509_crt_t CERT,
          int INDX, void * OID, size_t * SIZEOF_OID)
     CERT: should contain a `gnutls_x509_crt_t' structure

     INDX: This specifies which OID to return. Use zero to get the
     first one.

     OID: a pointer to a buffer to hold the OID (may be null)

     SIZEOF_OID: initially holds the size of `oid'

     This function will extract the OIDs of the name of the Certificate
     subject specified by the given index.

     If oid is null then only the size will be filled.

     *Returns:* `GNUTLS_E_SHORT_MEMORY_BUFFER' if the provided buffer is
     not long enough, and in that case the *sizeof_oid will be updated
     with the required size.  On success 0 is returned.

gnutls_x509_crt_get_dn
----------------------

 -- Function: int gnutls_x509_crt_get_dn (gnutls_x509_crt_t CERT, char
          * BUF, size_t * SIZEOF_BUF)
     CERT: should contain a `gnutls_x509_crt_t' structure

     BUF: a pointer to a structure to hold the name (may be null)

     SIZEOF_BUF: initially holds the size of `buf'

     This function will copy the name of the Certificate in the provided
     buffer. The name will be in the form "C=xxxx,O=yyyy,CN=zzzz" as
     described in RFC2253. The output string will be ASCII or UTF-8
     encoded, depending on the certificate data.

     If `buf' is null then only the size will be filled.

     *Returns:* `GNUTLS_E_SHORT_MEMORY_BUFFER' if the provided buffer
     is not long enough, and in that case the *sizeof_buf will be
     updated with the required size.  On success 0 is returned.

gnutls_x509_crt_get_expiration_time
-----------------------------------

 -- Function: time_t gnutls_x509_crt_get_expiration_time
          (gnutls_x509_crt_t CERT)
     CERT: should contain a `gnutls_x509_crt_t' structure

     This function will return the time this Certificate was or will be
     expired.

     *Returns:* expiration time, or (time_t)-1 on error.

gnutls_x509_crt_get_extension_by_oid
------------------------------------

 -- Function: int gnutls_x509_crt_get_extension_by_oid
          (gnutls_x509_crt_t CERT, const char * OID, int INDX, void *
          BUF, size_t * SIZEOF_BUF, unsigned int * CRITICAL)
     CERT: should contain a `gnutls_x509_crt_t' structure

     OID: holds an Object Identified in null terminated string

     INDX: In case multiple same OIDs exist in the extensions, this
     specifies which to send. Use zero to get the first one.

     BUF: a pointer to a structure to hold the name (may be null)

     SIZEOF_BUF: initially holds the size of `buf'

     CRITICAL: will be non zero if the extension is marked as critical

     This function will return the extension specified by the OID in the
     certificate.  The extensions will be returned as binary data DER
     encoded, in the provided buffer.

     *Returns:* On success, `GNUTLS_E_SUCCESS' (zero) is returned,
     otherwise an error code is returned. If the certificate does not
     contain the specified extension
     GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE will be returned.

gnutls_x509_crt_get_extension_data
----------------------------------

 -- Function: int gnutls_x509_crt_get_extension_data (gnutls_x509_crt_t
          CERT, int INDX, void * DATA, size_t * SIZEOF_DATA)
     CERT: should contain a `gnutls_x509_crt_t' structure

     INDX: Specifies which extension OID to send. Use zero to get the
     first one.

     DATA: a pointer to a structure to hold the data (may be null)

     SIZEOF_DATA: initially holds the size of `oid'

     This function will return the requested extension data in the
     certificate.  The extension data will be stored as a string in the
     provided buffer.

     Use `gnutls_x509_crt_get_extension_info()' to extract the OID and
     critical flag.  Use `gnutls_x509_crt_get_extension_by_oid()'
     instead, if you want to get data indexed by the extension OID
     rather than sequence.

     *Returns:* On success, `GNUTLS_E_SUCCESS' (zero) is returned,
     otherwise an error code is returned.  If you have reached the last
     extension available `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE' will
     be returned.

gnutls_x509_crt_get_extension_info
----------------------------------

 -- Function: int gnutls_x509_crt_get_extension_info (gnutls_x509_crt_t
          CERT, int INDX, void * OID, size_t * SIZEOF_OID, int *
          CRITICAL)
     CERT: should contain a `gnutls_x509_crt_t' structure

     INDX: Specifies which extension OID to send. Use zero to get the
     first one.

     OID: a pointer to a structure to hold the OID

     SIZEOF_OID: initially holds the maximum size of `oid', on return
     holds actual size of `oid'.

     CRITICAL: output variable with critical flag, may be NULL.

     This function will return the requested extension OID in the
     certificate, and the critical flag for it.  The extension OID will
     be stored as a string in the provided buffer.  Use
     `gnutls_x509_crt_get_extension_data()' to extract the data.

     If the buffer provided is not long enough to hold the output, then
     *`sizeof_oid' is updated and `GNUTLS_E_SHORT_MEMORY_BUFFER' will be
     returned.

     *Returns:* On success, `GNUTLS_E_SUCCESS' (zero) is returned,
     otherwise an error code is returned.  If you have reached the last
     extension available `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE' will
     be returned.

gnutls_x509_crt_get_extension_oid
---------------------------------

 -- Function: int gnutls_x509_crt_get_extension_oid (gnutls_x509_crt_t
          CERT, int INDX, void * OID, size_t * SIZEOF_OID)
     CERT: should contain a `gnutls_x509_crt_t' structure

     INDX: Specifies which extension OID to send. Use zero to get the
     first one.

     OID: a pointer to a structure to hold the OID (may be null)

     SIZEOF_OID: initially holds the size of `oid'

     This function will return the requested extension OID in the
     certificate.  The extension OID will be stored as a string in the
     provided buffer.

     *Returns:* On success, `GNUTLS_E_SUCCESS' (zero) is returned,
     otherwise an error code is returned.  If you have reached the last
     extension available `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE' will
     be returned.

gnutls_x509_crt_get_fingerprint
-------------------------------

 -- Function: int gnutls_x509_crt_get_fingerprint (gnutls_x509_crt_t
          CERT, gnutls_digest_algorithm_t ALGO, void * BUF, size_t *
          SIZEOF_BUF)
     CERT: should contain a `gnutls_x509_crt_t' structure

     ALGO: is a digest algorithm

     BUF: a pointer to a structure to hold the fingerprint (may be null)

     SIZEOF_BUF: initially holds the size of `buf'

     This function will calculate and copy the certificate's fingerprint
     in the provided buffer.

     If the buffer is null then only the size will be filled.

     *Returns:* `GNUTLS_E_SHORT_MEMORY_BUFFER' if the provided buffer is
     not long enough, and in that case the *sizeof_buf will be updated
     with the required size.  On success 0 is returned.

gnutls_x509_crt_get_issuer_alt_name2
------------------------------------

 -- Function: int gnutls_x509_crt_get_issuer_alt_name2
          (gnutls_x509_crt_t CERT, unsigned int SEQ, void * RET, size_t
          * RET_SIZE, unsigned int * RET_TYPE, unsigned int * CRITICAL)
     CERT: should contain a `gnutls_x509_crt_t' structure

     SEQ: specifies the sequence number of the alt name (0 for the
     first one, 1 for the second etc.)

     RET: is the place where the alternative name will be copied to

     RET_SIZE: holds the size of ret.

     RET_TYPE: holds the type of the alternative name (one of
     gnutls_x509_subject_alt_name_t).

     CRITICAL: will be non zero if the extension is marked as critical
     (may be null)

     This function will return the alternative names, contained in the
     given certificate. It is the same as
     `gnutls_x509_crt_get_issuer_alt_name()' except for the fact that it
     will return the type of the alternative name in `ret_type' even if
     the function fails for some reason (i.e.  the buffer provided is
     not enough).

     *Returns:* the alternative issuer name type on success, one of the
     enumerated `gnutls_x509_subject_alt_name_t'.  It will return
     `GNUTLS_E_SHORT_MEMORY_BUFFER' if `ret_size' is not large enough
     to hold the value.  In that case `ret_size' will be updated with
     the required size.  If the certificate does not have an
     Alternative name with the specified sequence number then
     `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE' is returned.

     *Since:* 2.10.0

gnutls_x509_crt_get_issuer_alt_name
-----------------------------------

 -- Function: int gnutls_x509_crt_get_issuer_alt_name
          (gnutls_x509_crt_t CERT, unsigned int SEQ, void * RET, size_t
          * RET_SIZE, unsigned int * CRITICAL)
     CERT: should contain a `gnutls_x509_crt_t' structure

     SEQ: specifies the sequence number of the alt name (0 for the
     first one, 1 for the second etc.)

     RET: is the place where the alternative name will be copied to

     RET_SIZE: holds the size of ret.

     CRITICAL: will be non zero if the extension is marked as critical
     (may be null)

     This function retrieves the Issuer Alternative Name (2.5.29.18),
     contained in the given certificate in the X509v3 Certificate
     Extensions.

     When the SAN type is otherName, it will extract the data in the
     otherName's value field, and `GNUTLS_SAN_OTHERNAME' is returned.
     You may use `gnutls_x509_crt_get_subject_alt_othername_oid()' to
     get the corresponding OID and the "virtual" SAN types (e.g.,
     `GNUTLS_SAN_OTHERNAME_XMPP').

     If an otherName OID is known, the data will be decoded.  Otherwise
     the returned data will be DER encoded, and you will have to decode
     it yourself.  Currently, only the RFC 3920 id-on-xmppAddr Issuer
     AltName is recognized.

     *Returns:* the alternative issuer name type on success, one of the
     enumerated `gnutls_x509_subject_alt_name_t'.  It will return
     `GNUTLS_E_SHORT_MEMORY_BUFFER' if `ret_size' is not large enough
     to hold the value.  In that case `ret_size' will be updated with
     the required size.  If the certificate does not have an
     Alternative name with the specified sequence number then
     `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE' is returned.

     *Since:* 2.10.0

gnutls_x509_crt_get_issuer_alt_othername_oid
--------------------------------------------

 -- Function: int gnutls_x509_crt_get_issuer_alt_othername_oid
          (gnutls_x509_crt_t CERT, unsigned int SEQ, void * RET, size_t
          * RET_SIZE)
     CERT: should contain a `gnutls_x509_crt_t' structure

     SEQ: specifies the sequence number of the alt name (0 for the
     first one, 1 for the second etc.)

     RET: is the place where the otherName OID will be copied to

     RET_SIZE: holds the size of ret.

     This function will extract the type OID of an otherName Subject
     Alternative Name, contained in the given certificate, and return
     the type as an enumerated element.

     This function is only useful if
     `gnutls_x509_crt_get_issuer_alt_name()' returned
     `GNUTLS_SAN_OTHERNAME'.

     *Returns:* the alternative issuer name type on success, one of the
     enumerated gnutls_x509_subject_alt_name_t.  For supported OIDs, it
     will return one of the virtual (GNUTLS_SAN_OTHERNAME_*) types,
     e.g. `GNUTLS_SAN_OTHERNAME_XMPP', and `GNUTLS_SAN_OTHERNAME' for
     unknown OIDs.  It will return `GNUTLS_E_SHORT_MEMORY_BUFFER' if
     `ret_size' is not large enough to hold the value.  In that case
     `ret_size' will be updated with the required size.  If the
     certificate does not have an Alternative name with the specified
     sequence number and with the otherName type then
     `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE' is returned.

     *Since:* 2.10.0

gnutls_x509_crt_get_issuer_dn_by_oid
------------------------------------

 -- Function: int gnutls_x509_crt_get_issuer_dn_by_oid
          (gnutls_x509_crt_t CERT, const char * OID, int INDX, unsigned
          int RAW_FLAG, void * BUF, size_t * SIZEOF_BUF)
     CERT: should contain a `gnutls_x509_crt_t' structure

     OID: holds an Object Identified in null terminated string

     INDX: In case multiple same OIDs exist in the RDN, this specifies
     which to send. Use zero to get the first one.

     RAW_FLAG: If non zero returns the raw DER data of the DN part.

     BUF: a pointer to a structure to hold the name (may be null)

     SIZEOF_BUF: initially holds the size of `buf'

     This function will extract the part of the name of the Certificate
     issuer specified by the given OID. The output, if the raw flag is
     not used, will be encoded as described in RFC2253. Thus a string
     that is ASCII or UTF-8 encoded, depending on the certificate data.

     Some helper macros with popular OIDs can be found in gnutls/x509.h
     If raw flag is zero, this function will only return known OIDs as
     text. Other OIDs will be DER encoded, as described in RFC2253 - in
     hex format with a '\#' prefix.  You can check about known OIDs
     using `gnutls_x509_dn_oid_known()'.

     If `buf' is null then only the size will be filled.

     *Returns:* GNUTLS_E_SHORT_MEMORY_BUFFER if the provided buffer is
     not long enough, and in that case the *sizeof_buf will be updated
     with the required size.  On success 0 is returned.

gnutls_x509_crt_get_issuer_dn_oid
---------------------------------

 -- Function: int gnutls_x509_crt_get_issuer_dn_oid (gnutls_x509_crt_t
          CERT, int INDX, void * OID, size_t * SIZEOF_OID)
     CERT: should contain a `gnutls_x509_crt_t' structure

     INDX: This specifies which OID to return. Use zero to get the
     first one.

     OID: a pointer to a buffer to hold the OID (may be null)

     SIZEOF_OID: initially holds the size of `oid'

     This function will extract the OIDs of the name of the Certificate
     issuer specified by the given index.

     If `oid' is null then only the size will be filled.

     *Returns:* GNUTLS_E_SHORT_MEMORY_BUFFER if the provided buffer is
     not long enough, and in that case the *sizeof_oid will be updated
     with the required size.  On success 0 is returned.

gnutls_x509_crt_get_issuer_dn
-----------------------------

 -- Function: int gnutls_x509_crt_get_issuer_dn (gnutls_x509_crt_t
          CERT, char * BUF, size_t * SIZEOF_BUF)
     CERT: should contain a `gnutls_x509_crt_t' structure

     BUF: a pointer to a structure to hold the name (may be null)

     SIZEOF_BUF: initially holds the size of `buf'

     This function will copy the name of the Certificate issuer in the
     provided buffer. The name will be in the form
     "C=xxxx,O=yyyy,CN=zzzz" as described in RFC2253. The output string
     will be ASCII or UTF-8 encoded, depending on the certificate data.

     If `buf' is null then only the size will be filled.

     *Returns:* GNUTLS_E_SHORT_MEMORY_BUFFER if the provided buffer is
     not long enough, and in that case the *sizeof_buf will be updated
     with the required size.  On success 0 is returned.

gnutls_x509_crt_get_issuer_unique_id
------------------------------------

 -- Function: int gnutls_x509_crt_get_issuer_unique_id
          (gnutls_x509_crt_t CRT, char * BUF, size_t * SIZEOF_BUF)
     CRT: Holds the certificate

     BUF: user allocated memory buffer, will hold the unique id

     SIZEOF_BUF: size of user allocated memory buffer (on input), will
     hold actual size of the unique ID on return.

     This function will extract the issuerUniqueID value (if present)
     for the given certificate.

     If the user allocated memory buffer is not large enough to hold the
     full subjectUniqueID, then a GNUTLS_E_SHORT_MEMORY_BUFFER error
     will be returned, and sizeof_buf will be set to the actual length.

     *Returns:* `GNUTLS_E_SUCCESS' on success, otherwise an error.

gnutls_x509_crt_get_issuer
--------------------------

 -- Function: int gnutls_x509_crt_get_issuer (gnutls_x509_crt_t CERT,
          gnutls_x509_dn_t * DN)
     CERT: should contain a `gnutls_x509_crt_t' structure

     DN: output variable with pointer to opaque DN

     Return the Certificate's Issuer DN as an opaque data type.  You may
     use `gnutls_x509_dn_get_rdn_ava()' to decode the DN.

     Note that `dn' should be treated as constant. Because points into
     the `cert' object, you may not deallocate `cert' and continue to
     access `dn'.

     *Returns:* Returns 0 on success, or an error code.

gnutls_x509_crt_get_key_id
--------------------------

 -- Function: int gnutls_x509_crt_get_key_id (gnutls_x509_crt_t CRT,
          unsigned int FLAGS, unsigned char * OUTPUT_DATA, size_t *
          OUTPUT_DATA_SIZE)
     CRT: Holds the certificate

     FLAGS: should be 0 for now

     OUTPUT_DATA: will contain the key ID

     OUTPUT_DATA_SIZE: holds the size of output_data (and will be
     replaced by the actual size of parameters)

     This function will return a unique ID the depends on the public
     key parameters. This ID can be used in checking whether a
     certificate corresponds to the given private key.

     If the buffer provided is not long enough to hold the output, then
     *output_data_size is updated and GNUTLS_E_SHORT_MEMORY_BUFFER will
     be returned.  The output will normally be a SHA-1 hash output,
     which is 20 bytes.

     *Return value:* In case of failure a negative value will be
     returned, and 0 on success.

gnutls_x509_crt_get_key_purpose_oid
-----------------------------------

 -- Function: int gnutls_x509_crt_get_key_purpose_oid
          (gnutls_x509_crt_t CERT, int INDX, void * OID, size_t *
          SIZEOF_OID, unsigned int * CRITICAL)
     CERT: should contain a `gnutls_x509_crt_t' structure

     INDX: This specifies which OID to return. Use zero to get the
     first one.

     OID: a pointer to a buffer to hold the OID (may be null)

     SIZEOF_OID: initially holds the size of `oid'

     CRITICAL: output flag to indicate criticality of extension

     This function will extract the key purpose OIDs of the Certificate
     specified by the given index.  These are stored in the Extended Key
     Usage extension (2.5.29.37) See the GNUTLS_KP_* definitions for
     human readable names.

     If `oid' is null then only the size will be filled.

     *Returns:* `GNUTLS_E_SHORT_MEMORY_BUFFER' if the provided buffer is
     not long enough, and in that case the *sizeof_oid will be updated
     with the required size.  On success 0 is returned.

gnutls_x509_crt_get_key_usage
-----------------------------

 -- Function: int gnutls_x509_crt_get_key_usage (gnutls_x509_crt_t
          CERT, unsigned int * KEY_USAGE, unsigned int * CRITICAL)
     CERT: should contain a `gnutls_x509_crt_t' structure

     KEY_USAGE: where the key usage bits will be stored

     CRITICAL: will be non zero if the extension is marked as critical

     This function will return certificate's key usage, by reading the
     keyUsage X.509 extension (2.5.29.15). The key usage value will ORed
     values of the: `GNUTLS_KEY_DIGITAL_SIGNATURE',
     `GNUTLS_KEY_NON_REPUDIATION', `GNUTLS_KEY_KEY_ENCIPHERMENT',
     `GNUTLS_KEY_DATA_ENCIPHERMENT', `GNUTLS_KEY_KEY_AGREEMENT',
     `GNUTLS_KEY_KEY_CERT_SIGN', `GNUTLS_KEY_CRL_SIGN',
     `GNUTLS_KEY_ENCIPHER_ONLY', `GNUTLS_KEY_DECIPHER_ONLY'.

     *Returns:* the certificate key usage, or a negative value in case
     of parsing error.  If the certificate does not contain the keyUsage
     extension `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE' will be returned.

gnutls_x509_crt_get_pk_algorithm
--------------------------------

 -- Function: int gnutls_x509_crt_get_pk_algorithm (gnutls_x509_crt_t
          CERT, unsigned int * BITS)
     CERT: should contain a `gnutls_x509_crt_t' structure

     BITS: if bits is non null it will hold the size of the parameters'
     in bits

     This function will return the public key algorithm of an X.509
     certificate.

     If bits is non null, it should have enough size to hold the
     parameters size in bits. For RSA the bits returned is the modulus.
     For DSA the bits returned are of the public exponent.

     *Returns:* a member of the `gnutls_pk_algorithm_t' enumeration on
     success, or a negative value on error.

gnutls_x509_crt_get_pk_dsa_raw
------------------------------

 -- Function: int gnutls_x509_crt_get_pk_dsa_raw (gnutls_x509_crt_t
          CRT, gnutls_datum_t * P, gnutls_datum_t * Q, gnutls_datum_t *
          G, gnutls_datum_t * Y)
     CRT: Holds the certificate

     P: will hold the p

     Q: will hold the q

     G: will hold the g

     Y: will hold the y

     This function will export the DSA public key's parameters found in
     the given certificate.  The new parameters will be allocated using
     `gnutls_malloc()' and will be stored in the appropriate datum.

     *Returns:* `GNUTLS_E_SUCCESS' on success, otherwise an error.

gnutls_x509_crt_get_pk_rsa_raw
------------------------------

 -- Function: int gnutls_x509_crt_get_pk_rsa_raw (gnutls_x509_crt_t
          CRT, gnutls_datum_t * M, gnutls_datum_t * E)
     CRT: Holds the certificate

     M: will hold the modulus

     E: will hold the public exponent

     This function will export the RSA public key's parameters found in
     the given structure.  The new parameters will be allocated using
     `gnutls_malloc()' and will be stored in the appropriate datum.

     *Returns:* `GNUTLS_E_SUCCESS' on success, otherwise an error.

gnutls_x509_crt_get_preferred_hash_algorithm
--------------------------------------------

 -- Function: int gnutls_x509_crt_get_preferred_hash_algorithm
          (gnutls_x509_crt_t CRT, gnutls_digest_algorithm_t * HASH,
          unsigned int * MAND)
     CRT: Holds the certificate

     HASH: The result of the call with the hash algorithm used for
     signature

     MAND: If non zero it means that the algorithm MUST use this hash.
     May be NULL.

     This function will read the certifcate and return the appropriate
     digest algorithm to use for signing with this certificate. Some
     certificates (i.e.  DSA might not be able to sign without the
     preferred algorithm).

     *Deprecated:* Please use
     `gnutls_pubkey_get_preferred_hash_algorithm()'.

     *Returns:* the 0 if the hash algorithm is found. A negative value
     is returned on error.

     *Since:* 2.11.0

gnutls_x509_crt_get_proxy
-------------------------

 -- Function: int gnutls_x509_crt_get_proxy (gnutls_x509_crt_t CERT,
          unsigned int * CRITICAL, int * PATHLEN, char **
          POLICYLANGUAGE, char ** POLICY, size_t * SIZEOF_POLICY)
     CERT: should contain a `gnutls_x509_crt_t' structure

     CRITICAL: will be non zero if the extension is marked as critical

     PATHLEN: pointer to output integer indicating path length (may be
     NULL), non-negative values indicate a present pCPathLenConstraint
     field and the actual value, -1 indicate that the field is absent.

     POLICYLANGUAGE: output variable with OID of policy language

     POLICY: output variable with policy data

     SIZEOF_POLICY: output variable size of policy data

     This function will get information from a proxy certificate.  It
     reads the ProxyCertInfo X.509 extension (1.3.6.1.5.5.7.1.14).

     *Returns:* On success, `GNUTLS_E_SUCCESS' (zero) is returned,
     otherwise an error code is returned.

gnutls_x509_crt_get_raw_dn
--------------------------

 -- Function: int gnutls_x509_crt_get_raw_dn (gnutls_x509_crt_t CERT,
          gnutls_datum_t * START)
     CERT: should contain a `gnutls_x509_crt_t' structure

     START: will hold the starting point of the DN

     This function will return a pointer to the DER encoded DN
     structure and the length.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value. or a negative value on error.

gnutls_x509_crt_get_raw_issuer_dn
---------------------------------

 -- Function: int gnutls_x509_crt_get_raw_issuer_dn (gnutls_x509_crt_t
          CERT, gnutls_datum_t * START)
     CERT: should contain a `gnutls_x509_crt_t' structure

     START: will hold the starting point of the DN

     This function will return a pointer to the DER encoded DN structure
     and the length.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.or a negative value on error.

gnutls_x509_crt_get_serial
--------------------------

 -- Function: int gnutls_x509_crt_get_serial (gnutls_x509_crt_t CERT,
          void * RESULT, size_t * RESULT_SIZE)
     CERT: should contain a `gnutls_x509_crt_t' structure

     RESULT: The place where the serial number will be copied

     RESULT_SIZE: Holds the size of the result field.

     This function will return the X.509 certificate's serial number.
     This is obtained by the X509 Certificate serialNumber field. Serial
     is not always a 32 or 64bit number. Some CAs use large serial
     numbers, thus it may be wise to handle it as something opaque.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_get_signature_algorithm
---------------------------------------

 -- Function: int gnutls_x509_crt_get_signature_algorithm
          (gnutls_x509_crt_t CERT)
     CERT: should contain a `gnutls_x509_crt_t' structure

     This function will return a value of the `gnutls_sign_algorithm_t'
     enumeration that is the signature algorithm that has been used to
     sign this certificate.

     *Returns:* a `gnutls_sign_algorithm_t' value, or a negative value
     on error.

gnutls_x509_crt_get_signature
-----------------------------

 -- Function: int gnutls_x509_crt_get_signature (gnutls_x509_crt_t
          CERT, char * SIG, size_t * SIZEOF_SIG)
     CERT: should contain a `gnutls_x509_crt_t' structure

     SIG: a pointer where the signature part will be copied (may be
     null).

     SIZEOF_SIG: initially holds the size of `sig'

     This function will extract the signature field of a certificate.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value. and a negative value on error.

gnutls_x509_crt_get_subject_alt_name2
-------------------------------------

 -- Function: int gnutls_x509_crt_get_subject_alt_name2
          (gnutls_x509_crt_t CERT, unsigned int SEQ, void * RET, size_t
          * RET_SIZE, unsigned int * RET_TYPE, unsigned int * CRITICAL)
     CERT: should contain a `gnutls_x509_crt_t' structure

     SEQ: specifies the sequence number of the alt name (0 for the
     first one, 1 for the second etc.)

     RET: is the place where the alternative name will be copied to

     RET_SIZE: holds the size of ret.

     RET_TYPE: holds the type of the alternative name (one of
     gnutls_x509_subject_alt_name_t).

     CRITICAL: will be non zero if the extension is marked as critical
     (may be null)

     This function will return the alternative names, contained in the
     given certificate. It is the same as
     `gnutls_x509_crt_get_subject_alt_name()' except for the fact that
     it will return the type of the alternative name in `ret_type' even
     if the function fails for some reason (i.e.  the buffer provided is
     not enough).

     *Returns:* the alternative subject name type on success, one of the
     enumerated `gnutls_x509_subject_alt_name_t'.  It will return
     `GNUTLS_E_SHORT_MEMORY_BUFFER' if `ret_size' is not large enough
     to hold the value.  In that case `ret_size' will be updated with
     the required size.  If the certificate does not have an
     Alternative name with the specified sequence number then
     `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE' is returned.

gnutls_x509_crt_get_subject_alt_name
------------------------------------

 -- Function: int gnutls_x509_crt_get_subject_alt_name
          (gnutls_x509_crt_t CERT, unsigned int SEQ, void * RET, size_t
          * RET_SIZE, unsigned int * CRITICAL)
     CERT: should contain a `gnutls_x509_crt_t' structure

     SEQ: specifies the sequence number of the alt name (0 for the
     first one, 1 for the second etc.)

     RET: is the place where the alternative name will be copied to

     RET_SIZE: holds the size of ret.

     CRITICAL: will be non zero if the extension is marked as critical
     (may be null)

     This function retrieves the Alternative Name (2.5.29.17), contained
     in the given certificate in the X509v3 Certificate Extensions.

     When the SAN type is otherName, it will extract the data in the
     otherName's value field, and `GNUTLS_SAN_OTHERNAME' is returned.
     You may use `gnutls_x509_crt_get_subject_alt_othername_oid()' to
     get the corresponding OID and the "virtual" SAN types (e.g.,
     `GNUTLS_SAN_OTHERNAME_XMPP').

     If an otherName OID is known, the data will be decoded.  Otherwise
     the returned data will be DER encoded, and you will have to decode
     it yourself.  Currently, only the RFC 3920 id-on-xmppAddr SAN is
     recognized.

     *Returns:* the alternative subject name type on success, one of the
     enumerated `gnutls_x509_subject_alt_name_t'.  It will return
     `GNUTLS_E_SHORT_MEMORY_BUFFER' if `ret_size' is not large enough to
     hold the value.  In that case `ret_size' will be updated with the
     required size.  If the certificate does not have an Alternative
     name with the specified sequence number then
     `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE' is returned.

gnutls_x509_crt_get_subject_alt_othername_oid
---------------------------------------------

 -- Function: int gnutls_x509_crt_get_subject_alt_othername_oid
          (gnutls_x509_crt_t CERT, unsigned int SEQ, void * RET, size_t
          * RET_SIZE)
     CERT: should contain a `gnutls_x509_crt_t' structure

     SEQ: specifies the sequence number of the alt name (0 for the
     first one, 1 for the second etc.)

     RET: is the place where the otherName OID will be copied to

     RET_SIZE: holds the size of ret.

     This function will extract the type OID of an otherName Subject
     Alternative Name, contained in the given certificate, and return
     the type as an enumerated element.

     This function is only useful if
     `gnutls_x509_crt_get_subject_alt_name()' returned
     `GNUTLS_SAN_OTHERNAME'.

     *Returns:* the alternative subject name type on success, one of the
     enumerated gnutls_x509_subject_alt_name_t.  For supported OIDs, it
     will return one of the virtual (GNUTLS_SAN_OTHERNAME_*) types,
     e.g. `GNUTLS_SAN_OTHERNAME_XMPP', and `GNUTLS_SAN_OTHERNAME' for
     unknown OIDs.  It will return `GNUTLS_E_SHORT_MEMORY_BUFFER' if
     `ret_size' is not large enough to hold the value.  In that case
     `ret_size' will be updated with the required size.  If the
     certificate does not have an Alternative name with the specified
     sequence number and with the otherName type then
     `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE' is returned.

gnutls_x509_crt_get_subject_key_id
----------------------------------

 -- Function: int gnutls_x509_crt_get_subject_key_id (gnutls_x509_crt_t
          CERT, void * RET, size_t * RET_SIZE, unsigned int * CRITICAL)
     CERT: should contain a `gnutls_x509_crt_t' structure

     RET: The place where the identifier will be copied

     RET_SIZE: Holds the size of the result field.

     CRITICAL: will be non zero if the extension is marked as critical
     (may be null)

     This function will return the X.509v3 certificate's subject key
     identifier.  This is obtained by the X.509 Subject Key identifier
     extension field (2.5.29.14).

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_get_subject_unique_id
-------------------------------------

 -- Function: int gnutls_x509_crt_get_subject_unique_id
          (gnutls_x509_crt_t CRT, char * BUF, size_t * SIZEOF_BUF)
     CRT: Holds the certificate

     BUF: user allocated memory buffer, will hold the unique id

     SIZEOF_BUF: size of user allocated memory buffer (on input), will
     hold actual size of the unique ID on return.

     This function will extract the subjectUniqueID value (if present)
     for the given certificate.

     If the user allocated memory buffer is not large enough to hold the
     full subjectUniqueID, then a GNUTLS_E_SHORT_MEMORY_BUFFER error
     will be returned, and sizeof_buf will be set to the actual length.

     *Returns:* `GNUTLS_E_SUCCESS' on success, otherwise an error.

gnutls_x509_crt_get_subject
---------------------------

 -- Function: int gnutls_x509_crt_get_subject (gnutls_x509_crt_t CERT,
          gnutls_x509_dn_t * DN)
     CERT: should contain a `gnutls_x509_crt_t' structure

     DN: output variable with pointer to opaque DN.

     Return the Certificate's Subject DN as an opaque data type.  You
     may use `gnutls_x509_dn_get_rdn_ava()' to decode the DN.

     Note that `dn' should be treated as constant. Because points into
     the `cert' object, you may not deallocate `cert' and continue to
     access `dn'.

     *Returns:* Returns 0 on success, or an error code.

gnutls_x509_crt_get_verify_algorithm
------------------------------------

 -- Function: int gnutls_x509_crt_get_verify_algorithm
          (gnutls_x509_crt_t CRT, const gnutls_datum_t * SIGNATURE,
          gnutls_digest_algorithm_t * HASH)
     CRT: Holds the certificate

     SIGNATURE: contains the signature

     HASH: The result of the call with the hash algorithm used for
     signature

     This function will read the certifcate and the signed data to
     determine the hash algorithm used to generate the signature.

     *Deprecated:* Use `gnutls_pubkey_get_verify_algorithm()' instead.

     *Returns:* the 0 if the hash algorithm is found. A negative value
     is returned on error.

     *Since:* 2.8.0

gnutls_x509_crt_get_version
---------------------------

 -- Function: int gnutls_x509_crt_get_version (gnutls_x509_crt_t CERT)
     CERT: should contain a `gnutls_x509_crt_t' structure

     This function will return the version of the specified Certificate.

     *Returns:* version of certificate, or a negative value on error.

gnutls_x509_crt_import
----------------------

 -- Function: int gnutls_x509_crt_import (gnutls_x509_crt_t CERT, const
          gnutls_datum_t * DATA, gnutls_x509_crt_fmt_t FORMAT)
     CERT: The structure to store the parsed certificate.

     DATA: The DER or PEM encoded certificate.

     FORMAT: One of DER or PEM

     This function will convert the given DER or PEM encoded Certificate
     to the native gnutls_x509_crt_t format. The output will be stored
     in `cert'.

     If the Certificate is PEM encoded it should have a header of "X509
     CERTIFICATE", or "CERTIFICATE".

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_init
--------------------

 -- Function: int gnutls_x509_crt_init (gnutls_x509_crt_t * CERT)
     CERT: The structure to be initialized

     This function will initialize an X.509 certificate structure.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_list_import
---------------------------

 -- Function: int gnutls_x509_crt_list_import (gnutls_x509_crt_t *
          CERTS, unsigned int * CERT_MAX, const gnutls_datum_t * DATA,
          gnutls_x509_crt_fmt_t FORMAT, unsigned int FLAGS)
     CERTS: The structures to store the parsed certificate. Must not be
     initialized.

     CERT_MAX: Initially must hold the maximum number of certs. It will
     be updated with the number of certs available.

     DATA: The PEM encoded certificate.

     FORMAT: One of DER or PEM.

     FLAGS: must be zero or an OR'd sequence of
     gnutls_certificate_import_flags.

     This function will convert the given PEM encoded certificate list
     to the native gnutls_x509_crt_t format. The output will be stored
     in `certs'.  They will be automatically initialized.

     If the Certificate is PEM encoded it should have a header of "X509
     CERTIFICATE", or "CERTIFICATE".

     *Returns:* the number of certificates read or a negative error
     value.

gnutls_x509_crt_list_verify
---------------------------

 -- Function: int gnutls_x509_crt_list_verify (const gnutls_x509_crt_t
          * CERT_LIST, int CERT_LIST_LENGTH, const gnutls_x509_crt_t *
          CA_LIST, int CA_LIST_LENGTH, const gnutls_x509_crl_t *
          CRL_LIST, int CRL_LIST_LENGTH, unsigned int FLAGS, unsigned
          int * VERIFY)
     CERT_LIST: is the certificate list to be verified

     CERT_LIST_LENGTH: holds the number of certificate in cert_list

     CA_LIST: is the CA list which will be used in verification

     CA_LIST_LENGTH: holds the number of CA certificate in CA_list

     CRL_LIST: holds a list of CRLs.

     CRL_LIST_LENGTH: the length of CRL list.

     FLAGS: Flags that may be used to change the verification
     algorithm. Use OR of the gnutls_certificate_verify_flags
     enumerations.

     VERIFY: will hold the certificate verification output.

     This function will try to verify the given certificate list and
     return its status.  If no flags are specified (0), this function
     will use the basicConstraints (2.5.29.19) PKIX extension. This
     means that only a certificate authority is allowed to sign a
     certificate.

     You must also check the peer's name in order to check if the
     verified certificate belongs to the actual peer.

     The certificate verification output will be put in `verify' and
     will be one or more of the gnutls_certificate_status_t enumerated
     elements bitwise or'd.  For a more detailed verification status use
     `gnutls_x509_crt_verify()' per list element.

     *GNUTLS_CERT_INVALID:* the certificate chain is not valid.

     *GNUTLS_CERT_REVOKED:* a certificate in the chain has been revoked.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_print
---------------------

 -- Function: int gnutls_x509_crt_print (gnutls_x509_crt_t CERT,
          gnutls_certificate_print_formats_t FORMAT, gnutls_datum_t *
          OUT)
     CERT: The structure to be printed

     FORMAT: Indicate the format to use

     OUT: Newly allocated datum with zero terminated string.

     This function will pretty print a X.509 certificate, suitable for
     display to a human.

     If the format is `GNUTLS_CRT_PRINT_FULL' then all fields of the
     certificate will be output, on multiple lines.  The
     `GNUTLS_CRT_PRINT_ONELINE' format will generate one line with some
     selected fields, which is useful for logging purposes.

     The output `out' needs to be deallocate using `gnutls_free()'.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_privkey_sign
----------------------------

 -- Function: int gnutls_x509_crt_privkey_sign (gnutls_x509_crt_t CRT,
          gnutls_x509_crt_t ISSUER, gnutls_privkey_t ISSUER_KEY,
          gnutls_digest_algorithm_t DIG, unsigned int FLAGS)
     CRT: a certificate of type `gnutls_x509_crt_t'

     ISSUER: is the certificate of the certificate issuer

     ISSUER_KEY: holds the issuer's private key

     DIG: The message digest to use, `GNUTLS_DIG_SHA1' is a safe choice

     FLAGS: must be 0

     This function will sign the certificate with the issuer's private
     key, and will copy the issuer's information into the certificate.

     This must be the last step in a certificate generation since all
     the previously set parameters are now signed.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_set_activation_time
-----------------------------------

 -- Function: int gnutls_x509_crt_set_activation_time
          (gnutls_x509_crt_t CERT, time_t ACT_TIME)
     CERT: a certificate of type `gnutls_x509_crt_t'

     ACT_TIME: The actual time

     This function will set the time this Certificate was or will be
     activated.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_set_authority_key_id
------------------------------------

 -- Function: int gnutls_x509_crt_set_authority_key_id
          (gnutls_x509_crt_t CERT, const void * ID, size_t ID_SIZE)
     CERT: a certificate of type `gnutls_x509_crt_t'

     ID: The key ID

     ID_SIZE: Holds the size of the serial field.

     This function will set the X.509 certificate's authority key ID
     extension.  Only the keyIdentifier field can be set with this
     function.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_set_basic_constraints
-------------------------------------

 -- Function: int gnutls_x509_crt_set_basic_constraints
          (gnutls_x509_crt_t CRT, unsigned int CA, int
          PATHLENCONSTRAINT)
     CRT: a certificate of type `gnutls_x509_crt_t'

     CA: true(1) or false(0). Depending on the Certificate authority
     status.

     PATHLENCONSTRAINT: non-negative values indicate maximum length of
     path, and negative values indicate that the pathLenConstraints
     field should not be present.

     This function will set the basicConstraints certificate extension.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_set_ca_status
-----------------------------

 -- Function: int gnutls_x509_crt_set_ca_status (gnutls_x509_crt_t CRT,
          unsigned int CA)
     CRT: a certificate of type `gnutls_x509_crt_t'

     CA: true(1) or false(0). Depending on the Certificate authority
     status.

     This function will set the basicConstraints certificate extension.
     Use `gnutls_x509_crt_set_basic_constraints()' if you want to
     control the pathLenConstraint field too.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_set_crl_dist_points2
------------------------------------

 -- Function: int gnutls_x509_crt_set_crl_dist_points2
          (gnutls_x509_crt_t CRT, gnutls_x509_subject_alt_name_t TYPE,
          const void * DATA, unsigned int DATA_SIZE, unsigned int
          REASON_FLAGS)
     CRT: a certificate of type `gnutls_x509_crt_t'

     TYPE: is one of the gnutls_x509_subject_alt_name_t enumerations

     DATA: The data to be set

     DATA_SIZE: The data size

     REASON_FLAGS: revocation reasons

     This function will set the CRL distribution points certificate
     extension.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

     *Since:* 2.6.0

gnutls_x509_crt_set_crl_dist_points
-----------------------------------

 -- Function: int gnutls_x509_crt_set_crl_dist_points
          (gnutls_x509_crt_t CRT, gnutls_x509_subject_alt_name_t TYPE,
          const void * DATA_STRING, unsigned int REASON_FLAGS)
     CRT: a certificate of type `gnutls_x509_crt_t'

     TYPE: is one of the gnutls_x509_subject_alt_name_t enumerations

     DATA_STRING: The data to be set

     REASON_FLAGS: revocation reasons

     This function will set the CRL distribution points certificate
     extension.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_set_crq_extensions
----------------------------------

 -- Function: int gnutls_x509_crt_set_crq_extensions (gnutls_x509_crt_t
          CRT, gnutls_x509_crq_t CRQ)
     CRT: a certificate of type `gnutls_x509_crt_t'

     CRQ: holds a certificate request

     This function will set extensions from the given request to the
     certificate.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

     *Since:* 2.8.0

gnutls_x509_crt_set_crq
-----------------------

 -- Function: int gnutls_x509_crt_set_crq (gnutls_x509_crt_t CRT,
          gnutls_x509_crq_t CRQ)
     CRT: a certificate of type `gnutls_x509_crt_t'

     CRQ: holds a certificate request

     This function will set the name and public parameters as well as
     the extensions from the given certificate request to the
     certificate.  Only RSA keys are currently supported.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_set_dn_by_oid
-----------------------------

 -- Function: int gnutls_x509_crt_set_dn_by_oid (gnutls_x509_crt_t CRT,
          const char * OID, unsigned int RAW_FLAG, const void * NAME,
          unsigned int SIZEOF_NAME)
     CRT: a certificate of type `gnutls_x509_crt_t'

     OID: holds an Object Identifier in a null terminated string

     RAW_FLAG: must be 0, or 1 if the data are DER encoded

     NAME: a pointer to the name

     SIZEOF_NAME: holds the size of `name'

     This function will set the part of the name of the Certificate
     subject, specified by the given OID. The input string should be
     ASCII or UTF-8 encoded.

     Some helper macros with popular OIDs can be found in gnutls/x509.h
     With this function you can only set the known OIDs. You can test
     for known OIDs using `gnutls_x509_dn_oid_known()'. For OIDs that
     are not known (by gnutls) you should properly DER encode your data,
     and call this function with `raw_flag' set.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_set_expiration_time
-----------------------------------

 -- Function: int gnutls_x509_crt_set_expiration_time
          (gnutls_x509_crt_t CERT, time_t EXP_TIME)
     CERT: a certificate of type `gnutls_x509_crt_t'

     EXP_TIME: The actual time

     This function will set the time this Certificate will expire.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_set_extension_by_oid
------------------------------------

 -- Function: int gnutls_x509_crt_set_extension_by_oid
          (gnutls_x509_crt_t CRT, const char * OID, const void * BUF,
          size_t SIZEOF_BUF, unsigned int CRITICAL)
     CRT: a certificate of type `gnutls_x509_crt_t'

     OID: holds an Object Identified in null terminated string

     BUF: a pointer to a DER encoded data

     SIZEOF_BUF: holds the size of `buf'

     CRITICAL: should be non zero if the extension is to be marked as
     critical

     This function will set an the extension, by the specified OID, in
     the certificate.  The extension data should be binary data DER
     encoded.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_set_issuer_dn_by_oid
------------------------------------

 -- Function: int gnutls_x509_crt_set_issuer_dn_by_oid
          (gnutls_x509_crt_t CRT, const char * OID, unsigned int
          RAW_FLAG, const void * NAME, unsigned int SIZEOF_NAME)
     CRT: a certificate of type `gnutls_x509_crt_t'

     OID: holds an Object Identifier in a null terminated string

     RAW_FLAG: must be 0, or 1 if the data are DER encoded

     NAME: a pointer to the name

     SIZEOF_NAME: holds the size of `name'

     This function will set the part of the name of the Certificate
     issuer, specified by the given OID.  The input string should be
     ASCII or UTF-8 encoded.

     Some helper macros with popular OIDs can be found in gnutls/x509.h
     With this function you can only set the known OIDs. You can test
     for known OIDs using `gnutls_x509_dn_oid_known()'. For OIDs that
     are not known (by gnutls) you should properly DER encode your data,
     and call this function with `raw_flag' set.

     Normally you do not need to call this function, since the signing
     operation will copy the signer's name as the issuer of the
     certificate.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_set_key_purpose_oid
-----------------------------------

 -- Function: int gnutls_x509_crt_set_key_purpose_oid
          (gnutls_x509_crt_t CERT, const void * OID, unsigned int
          CRITICAL)
     CERT: a certificate of type `gnutls_x509_crt_t'

     OID: a pointer to a null terminated string that holds the OID

     CRITICAL: Whether this extension will be critical or not

     This function will set the key purpose OIDs of the Certificate.
     These are stored in the Extended Key Usage extension (2.5.29.37)
     See the GNUTLS_KP_* definitions for human readable names.

     Subsequent calls to this function will append OIDs to the OID list.

     *Returns:* On success, `GNUTLS_E_SUCCESS' (zero) is returned,
     otherwise an error code is returned.

gnutls_x509_crt_set_key_usage
-----------------------------

 -- Function: int gnutls_x509_crt_set_key_usage (gnutls_x509_crt_t CRT,
          unsigned int USAGE)
     CRT: a certificate of type `gnutls_x509_crt_t'

     USAGE: an ORed sequence of the GNUTLS_KEY_* elements.

     This function will set the keyUsage certificate extension.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_set_key
-----------------------

 -- Function: int gnutls_x509_crt_set_key (gnutls_x509_crt_t CRT,
          gnutls_x509_privkey_t KEY)
     CRT: a certificate of type `gnutls_x509_crt_t'

     KEY: holds a private key

     This function will set the public parameters from the given
     private key to the certificate. Only RSA keys are currently
     supported.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_set_proxy_dn
----------------------------

 -- Function: int gnutls_x509_crt_set_proxy_dn (gnutls_x509_crt_t CRT,
          gnutls_x509_crt_t EECRT, unsigned int RAW_FLAG, const void *
          NAME, unsigned int SIZEOF_NAME)
     CRT: a gnutls_x509_crt_t structure with the new proxy cert

     EECRT: the end entity certificate that will be issuing the proxy

     RAW_FLAG: must be 0, or 1 if the CN is DER encoded

     NAME: a pointer to the CN name, may be NULL (but MUST then be
     added later)

     SIZEOF_NAME: holds the size of `name'

     This function will set the subject in `crt' to the end entity's
     `eecrt' subject name, and add a single Common Name component `name'
     of size `sizeof_name'.  This corresponds to the required proxy
     certificate naming style.  Note that if `name' is `NULL', you MUST
     set it later by using `gnutls_x509_crt_set_dn_by_oid()' or similar.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_set_proxy
-------------------------

 -- Function: int gnutls_x509_crt_set_proxy (gnutls_x509_crt_t CRT, int
          PATHLENCONSTRAINT, const char * POLICYLANGUAGE, const char *
          POLICY, size_t SIZEOF_POLICY)
     CRT: a certificate of type `gnutls_x509_crt_t'

     PATHLENCONSTRAINT: non-negative values indicate maximum length of
     path, and negative values indicate that the pathLenConstraints
     field should not be present.

     POLICYLANGUAGE: OID describing the language of `policy'.

     POLICY: opaque byte array with policy language, can be `NULL'

     SIZEOF_POLICY: size of `policy'.

     This function will set the proxyCertInfo extension.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_set_serial
--------------------------

 -- Function: int gnutls_x509_crt_set_serial (gnutls_x509_crt_t CERT,
          const void * SERIAL, size_t SERIAL_SIZE)
     CERT: a certificate of type `gnutls_x509_crt_t'

     SERIAL: The serial number

     SERIAL_SIZE: Holds the size of the serial field.

     This function will set the X.509 certificate's serial number.
     Serial is not always a 32 or 64bit number.  Some CAs use large
     serial numbers, thus it may be wise to handle it as something
     opaque.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_set_subject_alt_name
------------------------------------

 -- Function: int gnutls_x509_crt_set_subject_alt_name
          (gnutls_x509_crt_t CRT, gnutls_x509_subject_alt_name_t TYPE,
          const void * DATA, unsigned int DATA_SIZE, unsigned int FLAGS)
     CRT: a certificate of type `gnutls_x509_crt_t'

     TYPE: is one of the gnutls_x509_subject_alt_name_t enumerations

     DATA: The data to be set

     DATA_SIZE: The size of data to be set

     FLAGS: GNUTLS_FSAN_SET to clear previous data or
     GNUTLS_FSAN_APPEND to append.

     This function will set the subject alternative name certificate
     extension. It can set the following types:

     &GNUTLS_SAN_DNSNAME: as a text string

     &GNUTLS_SAN_RFC822NAME: as a text string

     &GNUTLS_SAN_URI: as a text string

     &GNUTLS_SAN_IPADDRESS: as a binary IP address (4 or 16 bytes)

     Other values can be set as binary values with the proper DER
     encoding.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

     *Since:* 2.6.0

gnutls_x509_crt_set_subject_alternative_name
--------------------------------------------

 -- Function: int gnutls_x509_crt_set_subject_alternative_name
          (gnutls_x509_crt_t CRT, gnutls_x509_subject_alt_name_t TYPE,
          const char * DATA_STRING)
     CRT: a certificate of type `gnutls_x509_crt_t'

     TYPE: is one of the gnutls_x509_subject_alt_name_t enumerations

     DATA_STRING: The data to be set, a zero terminated string

     This function will set the subject alternative name certificate
     extension. This function assumes that data can be expressed as a
     null terminated string.

     The name of the function is unfortunate since it is incosistent
     with `gnutls_x509_crt_get_subject_alt_name()'.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_set_subject_key_id
----------------------------------

 -- Function: int gnutls_x509_crt_set_subject_key_id (gnutls_x509_crt_t
          CERT, const void * ID, size_t ID_SIZE)
     CERT: a certificate of type `gnutls_x509_crt_t'

     ID: The key ID

     ID_SIZE: Holds the size of the serial field.

     This function will set the X.509 certificate's subject key ID
     extension.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_set_version
---------------------------

 -- Function: int gnutls_x509_crt_set_version (gnutls_x509_crt_t CRT,
          unsigned int VERSION)
     CRT: a certificate of type `gnutls_x509_crt_t'

     VERSION: holds the version number. For X.509v1 certificates must
     be 1.

     This function will set the version of the certificate.  This must
     be one for X.509 version 1, and so on.  Plain certificates without
     extensions must have version set to one.

     To create well-formed certificates, you must specify version 3 if
     you use any certificate extensions.  Extensions are created by
     functions such as `gnutls_x509_crt_set_subject_alt_name()' or
     `gnutls_x509_crt_set_key_usage()'.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_sign2
---------------------

 -- Function: int gnutls_x509_crt_sign2 (gnutls_x509_crt_t CRT,
          gnutls_x509_crt_t ISSUER, gnutls_x509_privkey_t ISSUER_KEY,
          gnutls_digest_algorithm_t DIG, unsigned int FLAGS)
     CRT: a certificate of type `gnutls_x509_crt_t'

     ISSUER: is the certificate of the certificate issuer

     ISSUER_KEY: holds the issuer's private key

     DIG: The message digest to use, `GNUTLS_DIG_SHA1' is a safe choice

     FLAGS: must be 0

     This function will sign the certificate with the issuer's private
     key, and will copy the issuer's information into the certificate.

     This must be the last step in a certificate generation since all
     the previously set parameters are now signed.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_sign
--------------------

 -- Function: int gnutls_x509_crt_sign (gnutls_x509_crt_t CRT,
          gnutls_x509_crt_t ISSUER, gnutls_x509_privkey_t ISSUER_KEY)
     CRT: a certificate of type `gnutls_x509_crt_t'

     ISSUER: is the certificate of the certificate issuer

     ISSUER_KEY: holds the issuer's private key

     This function is the same a `gnutls_x509_crt_sign2()' with no
     flags, and SHA1 as the hash algorithm.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_crt_verify_data
---------------------------

 -- Function: int gnutls_x509_crt_verify_data (gnutls_x509_crt_t CRT,
          unsigned int FLAGS, const gnutls_datum_t * DATA, const
          gnutls_datum_t * SIGNATURE)
     CRT: Holds the certificate

     FLAGS: should be 0 for now

     DATA: holds the data to be signed

     SIGNATURE: contains the signature

     This function will verify the given signed data, using the
     parameters from the certificate.

     Deprecated. Please use `gnutls_pubkey_verify_data()'.

     *Returns:* In case of a verification failure
     `GNUTLS_E_PK_SIG_VERIFY_FAILED' is returned, and a positive code
     on success.

gnutls_x509_crt_verify_hash
---------------------------

 -- Function: int gnutls_x509_crt_verify_hash (gnutls_x509_crt_t CRT,
          unsigned int FLAGS, const gnutls_datum_t * HASH, const
          gnutls_datum_t * SIGNATURE)
     CRT: Holds the certificate

     FLAGS: should be 0 for now

     HASH: holds the hash digest to be verified

     SIGNATURE: contains the signature

     This function will verify the given signed digest, using the
     parameters from the certificate.

     Deprecated. Please use `gnutls_pubkey_verify_data()'.

     *Returns:* In case of a verification failure
     `GNUTLS_E_PK_SIG_VERIFY_FAILED' is returned, and a positive code
     on success.

gnutls_x509_crt_verify
----------------------

 -- Function: int gnutls_x509_crt_verify (gnutls_x509_crt_t CERT, const
          gnutls_x509_crt_t * CA_LIST, int CA_LIST_LENGTH, unsigned int
          FLAGS, unsigned int * VERIFY)
     CERT: is the certificate to be verified

     CA_LIST: is one certificate that is considered to be trusted one

     CA_LIST_LENGTH: holds the number of CA certificate in CA_list

     FLAGS: Flags that may be used to change the verification
     algorithm. Use OR of the gnutls_certificate_verify_flags
     enumerations.

     VERIFY: will hold the certificate verification output.

     This function will try to verify the given certificate and return
     its status.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_dn_deinit
---------------------

 -- Function: void gnutls_x509_dn_deinit (gnutls_x509_dn_t DN)
     DN: a DN opaque object pointer.

     This function deallocates the DN object as returned by
     `gnutls_x509_dn_import()'.

     *Since:* 2.4.0

gnutls_x509_dn_export
---------------------

 -- Function: int gnutls_x509_dn_export (gnutls_x509_dn_t DN,
          gnutls_x509_crt_fmt_t FORMAT, void * OUTPUT_DATA, size_t *
          OUTPUT_DATA_SIZE)
     DN: Holds the opaque DN object

     FORMAT: the format of output params. One of PEM or DER.

     OUTPUT_DATA: will contain a DN PEM or DER encoded

     OUTPUT_DATA_SIZE: holds the size of output_data (and will be
     replaced by the actual size of parameters)

     This function will export the DN to DER or PEM format.

     If the buffer provided is not long enough to hold the output, then
     *`output_data_size' is updated and `GNUTLS_E_SHORT_MEMORY_BUFFER'
     will be returned.

     If the structure is PEM encoded, it will have a header of "BEGIN
     NAME".

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_dn_get_rdn_ava
--------------------------

 -- Function: int gnutls_x509_dn_get_rdn_ava (gnutls_x509_dn_t DN, int
          IRDN, int IAVA, gnutls_x509_ava_st * AVA)
     DN: input variable with opaque DN pointer

     IRDN: index of RDN

     IAVA: index of AVA.

     AVA: Pointer to structure which will hold output information.

     Get pointers to data within the DN.

     Note that `ava' will contain pointers into the `dn' structure, so
     you should not modify any data or deallocate it.  Note also that
     the DN in turn points into the original certificate structure, and
     thus you may not deallocate the certificate and continue to access
     `dn'.

     *Returns:* Returns 0 on success, or an error code.

gnutls_x509_dn_import
---------------------

 -- Function: int gnutls_x509_dn_import (gnutls_x509_dn_t DN, const
          gnutls_datum_t * DATA)
     DN: the structure that will hold the imported DN

     DATA: should contain a DER encoded RDN sequence

     This function parses an RDN sequence and stores the result to a
     `gnutls_x509_dn_t' structure. The structure must have been
     initialized with `gnutls_x509_dn_init()'. You may use
     `gnutls_x509_dn_get_rdn_ava()' to decode the DN.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

     *Since:* 2.4.0

gnutls_x509_dn_init
-------------------

 -- Function: int gnutls_x509_dn_init (gnutls_x509_dn_t * DN)
     DN: the object to be initialized

     This function initializes a `gnutls_x509_dn_t' structure.

     The object returned must be deallocated using
     `gnutls_x509_dn_deinit()'.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

     *Since:* 2.4.0

gnutls_x509_dn_oid_known
------------------------

 -- Function: int gnutls_x509_dn_oid_known (const char * OID)
     OID: holds an Object Identifier in a null terminated string

     This function will inform about known DN OIDs. This is useful since
     functions like `gnutls_x509_crt_set_dn_by_oid()' use the
     information on known OIDs to properly encode their input. Object
     Identifiers that are not known are not encoded by these functions,
     and their input is stored directly into the ASN.1 structure. In
     that case of unknown OIDs, you have the responsibility of DER
     encoding your data.

     *Returns:* 1 on known OIDs and 0 otherwise.

gnutls_x509_privkey_cpy
-----------------------

 -- Function: int gnutls_x509_privkey_cpy (gnutls_x509_privkey_t DST,
          gnutls_x509_privkey_t SRC)
     DST: The destination key, which should be initialized.

     SRC: The source key

     This function will copy a private key from source to destination
     key. Destination has to be initialized.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_privkey_deinit
--------------------------

 -- Function: void gnutls_x509_privkey_deinit (gnutls_x509_privkey_t
          KEY)
     KEY: The structure to be deinitialized

     This function will deinitialize a private key structure.

gnutls_x509_privkey_export_dsa_raw
----------------------------------

 -- Function: int gnutls_x509_privkey_export_dsa_raw
          (gnutls_x509_privkey_t KEY, gnutls_datum_t * P,
          gnutls_datum_t * Q, gnutls_datum_t * G, gnutls_datum_t * Y,
          gnutls_datum_t * X)
     KEY: a structure that holds the DSA parameters

     P: will hold the p

     Q: will hold the q

     G: will hold the g

     Y: will hold the y

     X: will hold the x

     This function will export the DSA private key's parameters found
     in the given structure. The new parameters will be allocated using
     `gnutls_malloc()' and will be stored in the appropriate datum.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_privkey_export_pkcs8
--------------------------------

 -- Function: int gnutls_x509_privkey_export_pkcs8
          (gnutls_x509_privkey_t KEY, gnutls_x509_crt_fmt_t FORMAT,
          const char * PASSWORD, unsigned int FLAGS, void *
          OUTPUT_DATA, size_t * OUTPUT_DATA_SIZE)
     KEY: Holds the key

     FORMAT: the format of output params. One of PEM or DER.

     PASSWORD: the password that will be used to encrypt the key.

     FLAGS: an ORed sequence of gnutls_pkcs_encrypt_flags_t

     OUTPUT_DATA: will contain a private key PEM or DER encoded

     OUTPUT_DATA_SIZE: holds the size of output_data (and will be
     replaced by the actual size of parameters)

     This function will export the private key to a PKCS8 structure.
     Both RSA and DSA keys can be exported. For DSA keys we use PKCS
     `11' definitions. If the flags do not specify the encryption
     cipher, then the default 3DES (PBES2) will be used.

     The `password' can be either ASCII or UTF-8 in the default PBES2
     encryption schemas, or ASCII for the PKCS12 schemas.

     If the buffer provided is not long enough to hold the output, then
     *output_data_size is updated and GNUTLS_E_SHORT_MEMORY_BUFFER will
     be returned.

     If the structure is PEM encoded, it will have a header of "BEGIN
     ENCRYPTED PRIVATE KEY" or "BEGIN PRIVATE KEY" if encryption is not
     used.

     *Return value:* In case of failure a negative value will be
     returned, and 0 on success.

gnutls_x509_privkey_export_rsa_raw2
-----------------------------------

 -- Function: int gnutls_x509_privkey_export_rsa_raw2
          (gnutls_x509_privkey_t KEY, gnutls_datum_t * M,
          gnutls_datum_t * E, gnutls_datum_t * D, gnutls_datum_t * P,
          gnutls_datum_t * Q, gnutls_datum_t * U, gnutls_datum_t * E1,
          gnutls_datum_t * E2)
     KEY: a structure that holds the rsa parameters

     M: will hold the modulus

     E: will hold the public exponent

     D: will hold the private exponent

     P: will hold the first prime (p)

     Q: will hold the second prime (q)

     U: will hold the coefficient

     E1: will hold e1 = d mod (p-1)

     E2: will hold e2 = d mod (q-1)

     This function will export the RSA private key's parameters found
     in the given structure. The new parameters will be allocated using
     `gnutls_malloc()' and will be stored in the appropriate datum.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_privkey_export_rsa_raw
----------------------------------

 -- Function: int gnutls_x509_privkey_export_rsa_raw
          (gnutls_x509_privkey_t KEY, gnutls_datum_t * M,
          gnutls_datum_t * E, gnutls_datum_t * D, gnutls_datum_t * P,
          gnutls_datum_t * Q, gnutls_datum_t * U)
     KEY: a structure that holds the rsa parameters

     M: will hold the modulus

     E: will hold the public exponent

     D: will hold the private exponent

     P: will hold the first prime (p)

     Q: will hold the second prime (q)

     U: will hold the coefficient

     This function will export the RSA private key's parameters found
     in the given structure. The new parameters will be allocated using
     `gnutls_malloc()' and will be stored in the appropriate datum.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_privkey_export
--------------------------

 -- Function: int gnutls_x509_privkey_export (gnutls_x509_privkey_t
          KEY, gnutls_x509_crt_fmt_t FORMAT, void * OUTPUT_DATA, size_t
          * OUTPUT_DATA_SIZE)
     KEY: Holds the key

     FORMAT: the format of output params. One of PEM or DER.

     OUTPUT_DATA: will contain a private key PEM or DER encoded

     OUTPUT_DATA_SIZE: holds the size of output_data (and will be
     replaced by the actual size of parameters)

     This function will export the private key to a PKCS1 structure for
     RSA keys, or an integer sequence for DSA keys.  The DSA keys are in
     the same format with the parameters used by openssl.

     If the buffer provided is not long enough to hold the output, then
     *`output_data_size' is updated and `GNUTLS_E_SHORT_MEMORY_BUFFER'
     will be returned.

     If the structure is PEM encoded, it will have a header of "BEGIN
     RSA PRIVATE KEY".

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_privkey_fix
-----------------------

 -- Function: int gnutls_x509_privkey_fix (gnutls_x509_privkey_t KEY)
     KEY: Holds the key

     This function will recalculate the secondary parameters in a key.
     In RSA keys, this can be the coefficient and exponent1,2.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_privkey_generate
----------------------------

 -- Function: int gnutls_x509_privkey_generate (gnutls_x509_privkey_t
          KEY, gnutls_pk_algorithm_t ALGO, unsigned int BITS, unsigned
          int FLAGS)
     KEY: should contain a `gnutls_x509_privkey_t' structure

     ALGO: is one of RSA or DSA.

     BITS: the size of the modulus

     FLAGS: unused for now.  Must be 0.

     This function will generate a random private key. Note that this
     function must be called on an empty private key.

     Do not set the number of bits directly, use
     `gnutls_sec_param_to_pk_bits()'.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_privkey_get_key_id
------------------------------

 -- Function: int gnutls_x509_privkey_get_key_id (gnutls_x509_privkey_t
          KEY, unsigned int FLAGS, unsigned char * OUTPUT_DATA, size_t
          * OUTPUT_DATA_SIZE)
     KEY: Holds the key

     FLAGS: should be 0 for now

     OUTPUT_DATA: will contain the key ID

     OUTPUT_DATA_SIZE: holds the size of output_data (and will be
     replaced by the actual size of parameters)

     This function will return a unique ID the depends on the public key
     parameters. This ID can be used in checking whether a certificate
     corresponds to the given key.

     If the buffer provided is not long enough to hold the output, then
     *`output_data_size' is updated and `GNUTLS_E_SHORT_MEMORY_BUFFER'
     will be returned.  The output will normally be a SHA-1 hash output,
     which is 20 bytes.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_privkey_get_pk_algorithm
------------------------------------

 -- Function: int gnutls_x509_privkey_get_pk_algorithm
          (gnutls_x509_privkey_t KEY)
     KEY: should contain a `gnutls_x509_privkey_t' structure

     This function will return the public key algorithm of a private
     key.

     *Returns:* a member of the `gnutls_pk_algorithm_t' enumeration on
     success, or a negative value on error.

gnutls_x509_privkey_import_dsa_raw
----------------------------------

 -- Function: int gnutls_x509_privkey_import_dsa_raw
          (gnutls_x509_privkey_t KEY, const gnutls_datum_t * P, const
          gnutls_datum_t * Q, const gnutls_datum_t * G, const
          gnutls_datum_t * Y, const gnutls_datum_t * X)
     KEY: The structure to store the parsed key

     P: holds the p

     Q: holds the q

     G: holds the g

     Y: holds the y

     X: holds the x

     This function will convert the given DSA raw parameters to the
     native `gnutls_x509_privkey_t' format.  The output will be stored
     in `key'.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_privkey_import_pkcs8
--------------------------------

 -- Function: int gnutls_x509_privkey_import_pkcs8
          (gnutls_x509_privkey_t KEY, const gnutls_datum_t * DATA,
          gnutls_x509_crt_fmt_t FORMAT, const char * PASSWORD, unsigned
          int FLAGS)
     KEY: The structure to store the parsed key

     DATA: The DER or PEM encoded key.

     FORMAT: One of DER or PEM

     PASSWORD: the password to decrypt the key (if it is encrypted).

     FLAGS: 0 if encrypted or GNUTLS_PKCS_PLAIN if not encrypted.

     This function will convert the given DER or PEM encoded PKCS8 2.0
     encrypted key to the native gnutls_x509_privkey_t format. The
     output will be stored in `key'.  Both RSA and DSA keys can be
     imported, and flags can only be used to indicate an unencrypted
     key.

     The `password' can be either ASCII or UTF-8 in the default PBES2
     encryption schemas, or ASCII for the PKCS12 schemas.

     If the Certificate is PEM encoded it should have a header of
     "ENCRYPTED PRIVATE KEY", or "PRIVATE KEY". You only need to
     specify the flags if the key is DER encoded, since in that case
     the encryption status cannot be auto-detected.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_privkey_import_rsa_raw2
-----------------------------------

 -- Function: int gnutls_x509_privkey_import_rsa_raw2
          (gnutls_x509_privkey_t KEY, const gnutls_datum_t * M, const
          gnutls_datum_t * E, const gnutls_datum_t * D, const
          gnutls_datum_t * P, const gnutls_datum_t * Q, const
          gnutls_datum_t * U, const gnutls_datum_t * E1, const
          gnutls_datum_t * E2)
     KEY: The structure to store the parsed key

     M: holds the modulus

     E: holds the public exponent

     D: holds the private exponent

     P: holds the first prime (p)

     Q: holds the second prime (q)

     U: holds the coefficient

     E1: holds e1 = d mod (p-1)

     E2: holds e2 = d mod (q-1)

     This function will convert the given RSA raw parameters to the
     native `gnutls_x509_privkey_t' format.  The output will be stored
     in `key'.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_privkey_import_rsa_raw
----------------------------------

 -- Function: int gnutls_x509_privkey_import_rsa_raw
          (gnutls_x509_privkey_t KEY, const gnutls_datum_t * M, const
          gnutls_datum_t * E, const gnutls_datum_t * D, const
          gnutls_datum_t * P, const gnutls_datum_t * Q, const
          gnutls_datum_t * U)
     KEY: The structure to store the parsed key

     M: holds the modulus

     E: holds the public exponent

     D: holds the private exponent

     P: holds the first prime (p)

     Q: holds the second prime (q)

     U: holds the coefficient

     This function will convert the given RSA raw parameters to the
     native `gnutls_x509_privkey_t' format.  The output will be stored
     in `key'.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_privkey_import
--------------------------

 -- Function: int gnutls_x509_privkey_import (gnutls_x509_privkey_t
          KEY, const gnutls_datum_t * DATA, gnutls_x509_crt_fmt_t
          FORMAT)
     KEY: The structure to store the parsed key

     DATA: The DER or PEM encoded certificate.

     FORMAT: One of DER or PEM

     This function will convert the given DER or PEM encoded key to the
     native `gnutls_x509_privkey_t' format. The output will be stored in
     `key' .

     If the key is PEM encoded it should have a header of "RSA PRIVATE
     KEY", or "DSA PRIVATE KEY".

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_privkey_init
------------------------

 -- Function: int gnutls_x509_privkey_init (gnutls_x509_privkey_t * KEY)
     KEY: The structure to be initialized

     This function will initialize an private key structure.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_x509_privkey_sec_param
-----------------------------

 -- Function: gnutls_sec_param_t gnutls_x509_privkey_sec_param
          (gnutls_x509_privkey_t KEY)
     KEY: a key structure

     This function will return the security parameter appropriate with
     this private key.

     *Returns:* On success, a valid security parameter is returned
     otherwise `GNUTLS_SEC_PARAM_UNKNOWN' is returned.

gnutls_x509_privkey_sign_data
-----------------------------

 -- Function: int gnutls_x509_privkey_sign_data (gnutls_x509_privkey_t
          KEY, gnutls_digest_algorithm_t DIGEST, unsigned int FLAGS,
          const gnutls_datum_t * DATA, void * SIGNATURE, size_t *
          SIGNATURE_SIZE)
     KEY: Holds the key

     DIGEST: should be MD5 or SHA1

     FLAGS: should be 0 for now

     DATA: holds the data to be signed

     SIGNATURE: will contain the signature

     SIGNATURE_SIZE: holds the size of signature (and will be replaced
     by the new size)

     This function will sign the given data using a signature algorithm
     supported by the private key. Signature algorithms are always used
     together with a hash functions.  Different hash functions may be
     used for the RSA algorithm, but only SHA-1 for the DSA keys.

     If the buffer provided is not long enough to hold the output, then
     *`signature_size' is updated and `GNUTLS_E_SHORT_MEMORY_BUFFER'
     will be returned.

     Use `gnutls_x509_crt_get_preferred_hash_algorithm()' to determine
     the hash algorithm.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

     *Deprecated:* Use `gnutls_privkey_sign_data()'.

gnutls_x509_privkey_sign_hash
-----------------------------

 -- Function: int gnutls_x509_privkey_sign_hash (gnutls_x509_privkey_t
          KEY, const gnutls_datum_t * HASH, gnutls_datum_t * SIGNATURE)
     KEY: Holds the key

     HASH: holds the data to be signed

     SIGNATURE: will contain newly allocated signature

     This function will sign the given hash using the private key. Do
     not use this function directly unless you know what it is. Typical
     signing requires the data to be hashed and stored in special
     formats (e.g. BER Digest-Info for RSA).

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

     *Deprecated in:* 2.12.0

gnutls_x509_privkey_verify_data
-------------------------------

 -- Function: int gnutls_x509_privkey_verify_data
          (gnutls_x509_privkey_t KEY, unsigned int FLAGS, const
          gnutls_datum_t * DATA, const gnutls_datum_t * SIGNATURE)
     KEY: Holds the key

     FLAGS: should be 0 for now

     DATA: holds the data to be signed

     SIGNATURE: contains the signature

     This function will verify the given signed data, using the
     parameters in the private key.

     *Returns:* In case of a verification failure
     `GNUTLS_E_PK_SIG_VERIFY_FAILED' is returned, and a positive code
     on success.

     *Deprecated:* Use `gnutls_pubkey_verify_data()'.

gnutls_x509_rdn_get_by_oid
--------------------------

 -- Function: int gnutls_x509_rdn_get_by_oid (const gnutls_datum_t *
          IDN, const char * OID, int INDX, unsigned int RAW_FLAG, void
          * BUF, size_t * SIZEOF_BUF)
     IDN: should contain a DER encoded RDN sequence

     OID: an Object Identifier

     INDX: In case multiple same OIDs exist in the RDN indicates which
     to send. Use 0 for the first one.

     RAW_FLAG: If non zero then the raw DER data are returned.

     BUF: a pointer to a structure to hold the peer's name

     SIZEOF_BUF: holds the size of `buf'

     This function will return the name of the given Object identifier,
     of the RDN sequence.  The name will be encoded using the rules
     from RFC2253.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, or
     `GNUTLS_E_SHORT_MEMORY_BUFFER' is returned and *`sizeof_buf' is
     updated if the provided buffer is not long enough, otherwise a
     negative error value.

gnutls_x509_rdn_get_oid
-----------------------

 -- Function: int gnutls_x509_rdn_get_oid (const gnutls_datum_t * IDN,
          int INDX, void * BUF, size_t * SIZEOF_BUF)
     IDN: should contain a DER encoded RDN sequence

     INDX: Indicates which OID to return. Use 0 for the first one.

     BUF: a pointer to a structure to hold the peer's name OID

     SIZEOF_BUF: holds the size of `buf'

     This function will return the specified Object identifier, of the
     RDN sequence.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, or
     `GNUTLS_E_SHORT_MEMORY_BUFFER' is returned and *`sizeof_buf' is
     updated if the provided buffer is not long enough, otherwise a
     negative error value.

     *Since:* 2.4.0

gnutls_x509_rdn_get
-------------------

 -- Function: int gnutls_x509_rdn_get (const gnutls_datum_t * IDN, char
          * BUF, size_t * SIZEOF_BUF)
     IDN: should contain a DER encoded RDN sequence

     BUF: a pointer to a structure to hold the peer's name

     SIZEOF_BUF: holds the size of `buf'

     This function will return the name of the given RDN sequence.  The
     name will be in the form "C=xxxx,O=yyyy,CN=zzzz" as described in
     RFC2253.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, or
     `GNUTLS_E_SHORT_MEMORY_BUFFER' is returned and *`sizeof_buf' is
     updated if the provided buffer is not long enough, otherwise a
     negative error value.


File: gnutls.info,  Node: GnuTLS-extra functions,  Next: OpenPGP functions,  Prev: X.509 certificate functions,  Up: Function reference

9.3 GnuTLS-extra Functions
==========================

These functions are only available in the GPLv3+ version of the library
called `gnutls-extra'. The prototypes for this library lie in
`gnutls/extra.h'.

gnutls_extra_check_version
--------------------------

 -- Function: const char * gnutls_extra_check_version (const char *
          REQ_VERSION)
     REQ_VERSION: version string to compare with, or `NULL'.

     Check GnuTLS Extra Library version.

     See `GNUTLS_EXTRA_VERSION' for a suitable `req_version' string.

     *Return value:* Check that the version of the library is at
     minimum the one given as a string in `req_version' and return the
     actual version string of the library; return `NULL' if the
     condition is not met.  If `NULL' is passed to this function no
     check is done and only the version string is returned.

gnutls_global_init_extra
------------------------

 -- Function: int gnutls_global_init_extra ( VOID)
     This function initializes the global state of gnutls-extra library
     to defaults.

     Note that `gnutls_global_init()' has to be called before this
     function.  If this function is not called then the gnutls-extra
     library will not be usable.

     This function is not thread safe, see the discussion for
     `gnutls_global_init()' on how to deal with that.

     *Returns:* On success, `GNUTLS_E_SUCCESS' (zero) is returned,
     otherwise an error code is returned.


File: gnutls.info,  Node: OpenPGP functions,  Next: TLS Inner Application (TLS/IA) functions,  Prev: GnuTLS-extra functions,  Up: Function reference

9.4 OpenPGP Functions
=====================

The following functions are to be used for OpenPGP certificate
handling.  Their prototypes lie in `gnutls/openpgp.h'.

gnutls_certificate_set_openpgp_key_file2
----------------------------------------

 -- Function: int gnutls_certificate_set_openpgp_key_file2
          (gnutls_certificate_credentials_t RES, const char * CERTFILE,
          const char * KEYFILE, const char * SUBKEY_ID,
          gnutls_openpgp_crt_fmt_t FORMAT)
     RES: the destination context to save the data.

     CERTFILE: the file that contains the public key.

     KEYFILE: the file that contains the secret key.

     SUBKEY_ID: a hex encoded subkey id

     FORMAT: the format of the keys

     This funtion is used to load OpenPGP keys into the GnuTLS
     credential structure. The file should contain at least one valid
     non encrypted subkey.

     The special keyword "auto" is also accepted as `subkey_id'.  In
     that case the `gnutls_openpgp_crt_get_auth_subkey()' will be used
     to retrieve the subkey.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

     *Since:* 2.4.0

gnutls_certificate_set_openpgp_key_file
---------------------------------------

 -- Function: int gnutls_certificate_set_openpgp_key_file
          (gnutls_certificate_credentials_t RES, const char * CERTFILE,
          const char * KEYFILE, gnutls_openpgp_crt_fmt_t FORMAT)
     RES: the destination context to save the data.

     CERTFILE: the file that contains the public key.

     KEYFILE: the file that contains the secret key.

     FORMAT: the format of the keys

     This funtion is used to load OpenPGP keys into the GnuTLS
     credentials structure. The file should contain at least one valid
     non encrypted subkey.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_certificate_set_openpgp_key_mem2
---------------------------------------

 -- Function: int gnutls_certificate_set_openpgp_key_mem2
          (gnutls_certificate_credentials_t RES, const gnutls_datum_t *
          CERT, const gnutls_datum_t * KEY, const char * SUBKEY_ID,
          gnutls_openpgp_crt_fmt_t FORMAT)
     RES: the destination context to save the data.

     CERT: the datum that contains the public key.

     KEY: the datum that contains the secret key.

     SUBKEY_ID: a hex encoded subkey id

     FORMAT: the format of the keys

     This funtion is used to load OpenPGP keys into the GnuTLS
     credentials structure. The datum should contain at least one valid
     non encrypted subkey.

     The special keyword "auto" is also accepted as `subkey_id'.  In
     that case the `gnutls_openpgp_crt_get_auth_subkey()' will be used
     to retrieve the subkey.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

     *Since:* 2.4.0

gnutls_certificate_set_openpgp_key_mem
--------------------------------------

 -- Function: int gnutls_certificate_set_openpgp_key_mem
          (gnutls_certificate_credentials_t RES, const gnutls_datum_t *
          CERT, const gnutls_datum_t * KEY, gnutls_openpgp_crt_fmt_t
          FORMAT)
     RES: the destination context to save the data.

     CERT: the datum that contains the public key.

     KEY: the datum that contains the secret key.

     FORMAT: the format of the keys

     This funtion is used to load OpenPGP keys into the GnuTLS
     credential structure. The datum should contain at least one valid
     non encrypted subkey.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_certificate_set_openpgp_keyring_file
-------------------------------------------

 -- Function: int gnutls_certificate_set_openpgp_keyring_file
          (gnutls_certificate_credentials_t C, const char * FILE,
          gnutls_openpgp_crt_fmt_t FORMAT)
     C: A certificate credentials structure

     FILE: filename of the keyring.

     FORMAT: format of keyring.

     The function is used to set keyrings that will be used internally
     by various OpenPGP functions. For example to find a key when it is
     needed for an operations. The keyring will also be used at the
     verification functions.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_certificate_set_openpgp_keyring_mem
------------------------------------------

 -- Function: int gnutls_certificate_set_openpgp_keyring_mem
          (gnutls_certificate_credentials_t C, const opaque * DATA,
          size_t DLEN, gnutls_openpgp_crt_fmt_t FORMAT)
     C: A certificate credentials structure

     DATA: buffer with keyring data.

     DLEN: length of data buffer.

     FORMAT: the format of the keyring

     The function is used to set keyrings that will be used internally
     by various OpenPGP functions. For example to find a key when it is
     needed for an operations. The keyring will also be used at the
     verification functions.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

gnutls_certificate_set_openpgp_key
----------------------------------

 -- Function: int gnutls_certificate_set_openpgp_key
          (gnutls_certificate_credentials_t RES, gnutls_openpgp_crt_t
          CRT, gnutls_openpgp_privkey_t PKEY)
     RES: is a `gnutls_certificate_credentials_t' structure.

     PKEY: is an openpgp private key

     This function sets a certificate/private key pair in the
     gnutls_certificate_credentials_t structure.  This function may be
     called more than once (in case multiple keys/certificates exist
     for the server).

     Note that this function requires that the preferred key ids have
     been set and be used. See
     `gnutls_openpgp_crt_set_preferred_key_id()'.  Otherwise the master
     key will be used.

     *Returns:* On success, `GNUTLS_E_SUCCESS' (zero) is returned,
     otherwise an error code is returned.

gnutls_openpgp_crt_check_hostname
---------------------------------

 -- Function: int gnutls_openpgp_crt_check_hostname
          (gnutls_openpgp_crt_t KEY, const char * HOSTNAME)
     KEY: should contain a `gnutls_openpgp_crt_t' structure

     HOSTNAME: A null terminated string that contains a DNS name

     This function will check if the given key's owner matches the
     given hostname. This is a basic implementation of the matching
     described in RFC2818 (HTTPS), which takes into account wildcards.

     *Returns:* `GNUTLS_E_SUCCESS' on success, or an error code.

gnutls_openpgp_crt_deinit
-------------------------

 -- Function: void gnutls_openpgp_crt_deinit (gnutls_openpgp_crt_t KEY)
     KEY: The structure to be initialized

     This function will deinitialize a key structure.

gnutls_openpgp_crt_export
-------------------------

 -- Function: int gnutls_openpgp_crt_export (gnutls_openpgp_crt_t KEY,
          gnutls_openpgp_crt_fmt_t FORMAT, void * OUTPUT_DATA, size_t *
          OUTPUT_DATA_SIZE)
     KEY: Holds the key.

     FORMAT: One of gnutls_openpgp_crt_fmt_t elements.

     OUTPUT_DATA: will contain the key base64 encoded or raw

     OUTPUT_DATA_SIZE: holds the size of output_data (and will be
     replaced by the actual size of parameters)

     This function will convert the given key to RAW or Base64 format.
     If the buffer provided is not long enough to hold the output, then
     `GNUTLS_E_SHORT_MEMORY_BUFFER' will be returned.

     *Returns:* `GNUTLS_E_SUCCESS' on success, or an error code.

gnutls_openpgp_crt_get_auth_subkey
----------------------------------

 -- Function: int gnutls_openpgp_crt_get_auth_subkey
          (gnutls_openpgp_crt_t CRT, gnutls_openpgp_keyid_t KEYID,
          unsigned int FLAG)
     CRT: the structure that contains the OpenPGP public key.

     KEYID: the struct to save the keyid.

     FLAG: Non zero indicates that a valid subkey is always returned.

     Returns the 64-bit keyID of the first valid OpenPGP subkey marked
     for authentication.  If flag is non zero and no authentication
     subkey exists, then a valid subkey will be returned even if it is
     not marked for authentication.  Returns the 64-bit keyID of the
     first valid OpenPGP subkey marked for authentication.  If flag is
     non zero and no authentication subkey exists, then a valid subkey
     will be returned even if it is not marked for authentication.

     *Returns:* `GNUTLS_E_SUCCESS' on success, or an error code.

gnutls_openpgp_crt_get_creation_time
------------------------------------

 -- Function: time_t gnutls_openpgp_crt_get_creation_time
          (gnutls_openpgp_crt_t KEY)
     KEY: the structure that contains the OpenPGP public key.

     Get key creation time.

     *Returns:* the timestamp when the OpenPGP key was created.

gnutls_openpgp_crt_get_expiration_time
--------------------------------------

 -- Function: time_t gnutls_openpgp_crt_get_expiration_time
          (gnutls_openpgp_crt_t KEY)
     KEY: the structure that contains the OpenPGP public key.

     Get key expiration time.  A value of '0' means that the key doesn't
     expire at all.

     *Returns:* the time when the OpenPGP key expires.

gnutls_openpgp_crt_get_fingerprint
----------------------------------

 -- Function: int gnutls_openpgp_crt_get_fingerprint
          (gnutls_openpgp_crt_t KEY, void * FPR, size_t * FPRLEN)
     KEY: the raw data that contains the OpenPGP public key.

     FPR: the buffer to save the fingerprint, must hold at least 20
     bytes.

     FPRLEN: the integer to save the length of the fingerprint.

     Get key fingerprint.  Depending on the algorithm, the fingerprint
     can be 16 or 20 bytes.

     *Returns:* On success, 0 is returned.  Otherwise, an error code.

gnutls_openpgp_crt_get_key_id
-----------------------------

 -- Function: int gnutls_openpgp_crt_get_key_id (gnutls_openpgp_crt_t
          KEY, gnutls_openpgp_keyid_t KEYID)
     KEY: the structure that contains the OpenPGP public key.

     KEYID: the buffer to save the keyid.

     Get key id string.

     *Returns:* the 64-bit keyID of the OpenPGP key.

     *Since:* 2.4.0

gnutls_openpgp_crt_get_key_usage
--------------------------------

 -- Function: int gnutls_openpgp_crt_get_key_usage
          (gnutls_openpgp_crt_t KEY, unsigned int * KEY_USAGE)
     KEY: should contain a gnutls_openpgp_crt_t structure

     KEY_USAGE: where the key usage bits will be stored

     This function will return certificate's key usage, by checking the
     key algorithm. The key usage value will ORed values of the:
     `GNUTLS_KEY_DIGITAL_SIGNATURE', `GNUTLS_KEY_KEY_ENCIPHERMENT'.

     *Returns:* `GNUTLS_E_SUCCESS' on success, or an error code.

gnutls_openpgp_crt_get_name
---------------------------

 -- Function: int gnutls_openpgp_crt_get_name (gnutls_openpgp_crt_t
          KEY, int IDX, char * BUF, size_t * SIZEOF_BUF)
     KEY: the structure that contains the OpenPGP public key.

     IDX: the index of the ID to extract

     BUF: a pointer to a structure to hold the name, may be `NULL' to
     only get the `sizeof_buf'.

     SIZEOF_BUF: holds the maximum size of `buf', on return hold the
     actual/required size of `buf'.

     Extracts the userID from the parsed OpenPGP key.

     *Returns:* `GNUTLS_E_SUCCESS' on success, and if the index of the
     ID does not exist `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE', or an
     error code.

gnutls_openpgp_crt_get_pk_algorithm
-----------------------------------

 -- Function: gnutls_pk_algorithm_t gnutls_openpgp_crt_get_pk_algorithm
          (gnutls_openpgp_crt_t KEY, unsigned int * BITS)
     KEY: is an OpenPGP key

     BITS: if bits is non null it will hold the size of the parameters'
     in bits

     This function will return the public key algorithm of an OpenPGP
     certificate.

     If bits is non null, it should have enough size to hold the
     parameters size in bits. For RSA the bits returned is the modulus.
     For DSA the bits returned are of the public exponent.

     *Returns:* a member of the `gnutls_pk_algorithm_t' enumeration on
     success, or GNUTLS_PK_UNKNOWN on error.

gnutls_openpgp_crt_get_pk_dsa_raw
---------------------------------

 -- Function: int gnutls_openpgp_crt_get_pk_dsa_raw
          (gnutls_openpgp_crt_t CRT, gnutls_datum_t * P, gnutls_datum_t
          * Q, gnutls_datum_t * G, gnutls_datum_t * Y)
     CRT: Holds the certificate

     P: will hold the p

     Q: will hold the q

     G: will hold the g

     Y: will hold the y

     This function will export the DSA public key's parameters found in
     the given certificate.  The new parameters will be allocated using
     `gnutls_malloc()' and will be stored in the appropriate datum.

     *Returns:* `GNUTLS_E_SUCCESS' on success, otherwise an error.

     *Since:* 2.4.0

gnutls_openpgp_crt_get_pk_rsa_raw
---------------------------------

 -- Function: int gnutls_openpgp_crt_get_pk_rsa_raw
          (gnutls_openpgp_crt_t CRT, gnutls_datum_t * M, gnutls_datum_t
          * E)
     CRT: Holds the certificate

     M: will hold the modulus

     E: will hold the public exponent

     This function will export the RSA public key's parameters found in
     the given structure.  The new parameters will be allocated using
     `gnutls_malloc()' and will be stored in the appropriate datum.

     *Returns:* `GNUTLS_E_SUCCESS' on success, otherwise an error.

     *Since:* 2.4.0

gnutls_openpgp_crt_get_preferred_key_id
---------------------------------------

 -- Function: int gnutls_openpgp_crt_get_preferred_key_id
          (gnutls_openpgp_crt_t KEY, gnutls_openpgp_keyid_t KEYID)
     KEY: the structure that contains the OpenPGP public key.

     KEYID: the struct to save the keyid.

     Get preferred key id.  If it hasn't been set it returns
     `GNUTLS_E_INVALID_REQUEST'.

     *Returns:* the 64-bit preferred keyID of the OpenPGP key.

gnutls_openpgp_crt_get_revoked_status
-------------------------------------

 -- Function: int gnutls_openpgp_crt_get_revoked_status
          (gnutls_openpgp_crt_t KEY)
     KEY: the structure that contains the OpenPGP public key.

     Get revocation status of key.

     *Returns:* true (1) if the key has been revoked, or false (0) if it
     has not.

     *Since:* 2.4.0

gnutls_openpgp_crt_get_subkey_count
-----------------------------------

 -- Function: int gnutls_openpgp_crt_get_subkey_count
          (gnutls_openpgp_crt_t KEY)
     KEY: is an OpenPGP key

     This function will return the number of subkeys present in the
     given OpenPGP certificate.

     *Returns:* the number of subkeys, or a negative value on error.

     *Since:* 2.4.0

gnutls_openpgp_crt_get_subkey_creation_time
-------------------------------------------

 -- Function: time_t gnutls_openpgp_crt_get_subkey_creation_time
          (gnutls_openpgp_crt_t KEY, unsigned int IDX)
     KEY: the structure that contains the OpenPGP public key.

     IDX: the subkey index

     Get subkey creation time.

     *Returns:* the timestamp when the OpenPGP sub-key was created.

     *Since:* 2.4.0

gnutls_openpgp_crt_get_subkey_expiration_time
---------------------------------------------

 -- Function: time_t gnutls_openpgp_crt_get_subkey_expiration_time
          (gnutls_openpgp_crt_t KEY, unsigned int IDX)
     KEY: the structure that contains the OpenPGP public key.

     IDX: the subkey index

     Get subkey expiration time.  A value of '0' means that the key
     doesn't expire at all.

     *Returns:* the time when the OpenPGP key expires.

     *Since:* 2.4.0

gnutls_openpgp_crt_get_subkey_fingerprint
-----------------------------------------

 -- Function: int gnutls_openpgp_crt_get_subkey_fingerprint
          (gnutls_openpgp_crt_t KEY, unsigned int IDX, void * FPR,
          size_t * FPRLEN)
     KEY: the raw data that contains the OpenPGP public key.

     IDX: the subkey index

     FPR: the buffer to save the fingerprint, must hold at least 20
     bytes.

     FPRLEN: the integer to save the length of the fingerprint.

     Get key fingerprint of a subkey.  Depending on the algorithm, the
     fingerprint can be 16 or 20 bytes.

     *Returns:* On success, 0 is returned.  Otherwise, an error code.

     *Since:* 2.4.0

gnutls_openpgp_crt_get_subkey_idx
---------------------------------

 -- Function: int gnutls_openpgp_crt_get_subkey_idx
          (gnutls_openpgp_crt_t KEY, const gnutls_openpgp_keyid_t KEYID)
     KEY: the structure that contains the OpenPGP public key.

     KEYID: the keyid.

     Get subkey's index.

     *Returns:* the index of the subkey or a negative error value.

     *Since:* 2.4.0

gnutls_openpgp_crt_get_subkey_id
--------------------------------

 -- Function: int gnutls_openpgp_crt_get_subkey_id
          (gnutls_openpgp_crt_t KEY, unsigned int IDX,
          gnutls_openpgp_keyid_t KEYID)
     KEY: the structure that contains the OpenPGP public key.

     IDX: the subkey index

     KEYID: the buffer to save the keyid.

     Get the subkey's key-id.

     *Returns:* the 64-bit keyID of the OpenPGP key.

gnutls_openpgp_crt_get_subkey_pk_algorithm
------------------------------------------

 -- Function: gnutls_pk_algorithm_t
gnutls_openpgp_crt_get_subkey_pk_algorithm (gnutls_openpgp_crt_t KEY,
          unsigned int IDX, unsigned int * BITS)
     KEY: is an OpenPGP key

     IDX: is the subkey index

     BITS: if bits is non null it will hold the size of the parameters'
     in bits

     This function will return the public key algorithm of a subkey of
     an OpenPGP certificate.

     If bits is non null, it should have enough size to hold the
     parameters size in bits.  For RSA the bits returned is the modulus.
     For DSA the bits returned are of the public exponent.

     *Returns:* a member of the `gnutls_pk_algorithm_t' enumeration on
     success, or GNUTLS_PK_UNKNOWN on error.

     *Since:* 2.4.0

gnutls_openpgp_crt_get_subkey_pk_dsa_raw
----------------------------------------

 -- Function: int gnutls_openpgp_crt_get_subkey_pk_dsa_raw
          (gnutls_openpgp_crt_t CRT, unsigned int IDX, gnutls_datum_t *
          P, gnutls_datum_t * Q, gnutls_datum_t * G, gnutls_datum_t * Y)
     CRT: Holds the certificate

     IDX: Is the subkey index

     P: will hold the p

     Q: will hold the q

     G: will hold the g

     Y: will hold the y

     This function will export the DSA public key's parameters found in
     the given certificate.  The new parameters will be allocated using
     `gnutls_malloc()' and will be stored in the appropriate datum.

     *Returns:* `GNUTLS_E_SUCCESS' on success, otherwise an error.

     *Since:* 2.4.0

gnutls_openpgp_crt_get_subkey_pk_rsa_raw
----------------------------------------

 -- Function: int gnutls_openpgp_crt_get_subkey_pk_rsa_raw
          (gnutls_openpgp_crt_t CRT, unsigned int IDX, gnutls_datum_t *
          M, gnutls_datum_t * E)
     CRT: Holds the certificate

     IDX: Is the subkey index

     M: will hold the modulus

     E: will hold the public exponent

     This function will export the RSA public key's parameters found in
     the given structure.  The new parameters will be allocated using
     `gnutls_malloc()' and will be stored in the appropriate datum.

     *Returns:* `GNUTLS_E_SUCCESS' on success, otherwise an error.

     *Since:* 2.4.0

gnutls_openpgp_crt_get_subkey_revoked_status
--------------------------------------------

 -- Function: int gnutls_openpgp_crt_get_subkey_revoked_status
          (gnutls_openpgp_crt_t KEY, unsigned int IDX)
     KEY: the structure that contains the OpenPGP public key.

     IDX: is the subkey index

     Get subkey revocation status.  A negative value indicates an error.

     *Returns:* true (1) if the key has been revoked, or false (0) if it
     has not.

     *Since:* 2.4.0

gnutls_openpgp_crt_get_subkey_usage
-----------------------------------

 -- Function: int gnutls_openpgp_crt_get_subkey_usage
          (gnutls_openpgp_crt_t KEY, unsigned int IDX, unsigned int *
          KEY_USAGE)
     KEY: should contain a gnutls_openpgp_crt_t structure

     IDX: the subkey index

     KEY_USAGE: where the key usage bits will be stored

     This function will return certificate's key usage, by checking the
     key algorithm.  The key usage value will ORed values of
     `GNUTLS_KEY_DIGITAL_SIGNATURE' or `GNUTLS_KEY_KEY_ENCIPHERMENT'.

     A negative value may be returned in case of parsing error.

     *Returns:* key usage value.

     *Since:* 2.4.0

gnutls_openpgp_crt_get_version
------------------------------

 -- Function: int gnutls_openpgp_crt_get_version (gnutls_openpgp_crt_t
          KEY)
     KEY: the structure that contains the OpenPGP public key.

     Extract the version of the OpenPGP key.

     *Returns:* the version number is returned, or a negative value on
     errors.

gnutls_openpgp_crt_import
-------------------------

 -- Function: int gnutls_openpgp_crt_import (gnutls_openpgp_crt_t KEY,
          const gnutls_datum_t * DATA, gnutls_openpgp_crt_fmt_t FORMAT)
     KEY: The structure to store the parsed key.

     DATA: The RAW or BASE64 encoded key.

     FORMAT: One of gnutls_openpgp_crt_fmt_t elements.

     This function will convert the given RAW or Base64 encoded key to
     the native `gnutls_openpgp_crt_t' format. The output will be stored
     in 'key'.

     *Returns:* `GNUTLS_E_SUCCESS' on success, or an error code.

gnutls_openpgp_crt_init
-----------------------

 -- Function: int gnutls_openpgp_crt_init (gnutls_openpgp_crt_t * KEY)
     KEY: The structure to be initialized

     This function will initialize an OpenPGP key structure.

     *Returns:* `GNUTLS_E_SUCCESS' on success, or an error code.

gnutls_openpgp_crt_print
------------------------

 -- Function: int gnutls_openpgp_crt_print (gnutls_openpgp_crt_t CERT,
          gnutls_certificate_print_formats_t FORMAT, gnutls_datum_t *
          OUT)
     CERT: The structure to be printed

     FORMAT: Indicate the format to use

     OUT: Newly allocated datum with zero terminated string.

     This function will pretty print an OpenPGP certificate, suitable
     for display to a human.

     The format should be zero for future compatibility.

     The output `out' needs to be deallocate using `gnutls_free()'.

     *Returns:* `GNUTLS_E_SUCCESS' on success, or an error code.

gnutls_openpgp_crt_set_preferred_key_id
---------------------------------------

 -- Function: int gnutls_openpgp_crt_set_preferred_key_id
          (gnutls_openpgp_crt_t KEY, const gnutls_openpgp_keyid_t KEYID)
     KEY: the structure that contains the OpenPGP public key.

     KEYID: the selected keyid

     This allows setting a preferred key id for the given certificate.
     This key will be used by functions that involve key handling.

     *Returns:* On success, `GNUTLS_E_SUCCESS' (zero) is returned,
     otherwise an error code is returned.

gnutls_openpgp_crt_verify_ring
------------------------------

 -- Function: int gnutls_openpgp_crt_verify_ring (gnutls_openpgp_crt_t
          KEY, gnutls_openpgp_keyring_t KEYRING, unsigned int FLAGS,
          unsigned int * VERIFY)
     KEY: the structure that holds the key.

     KEYRING: holds the keyring to check against

     FLAGS: unused (should be 0)

     VERIFY: will hold the certificate verification output.

     Verify all signatures in the key, using the given set of keys
     (keyring).

     The key verification output will be put in `verify' and will be one
     or more of the `gnutls_certificate_status_t' enumerated elements
     bitwise or'd.

     *Returns:* `GNUTLS_E_SUCCESS' on success, or an error code.

gnutls_openpgp_crt_verify_self
------------------------------

 -- Function: int gnutls_openpgp_crt_verify_self (gnutls_openpgp_crt_t
          KEY, unsigned int FLAGS, unsigned int * VERIFY)
     KEY: the structure that holds the key.

     FLAGS: unused (should be 0)

     VERIFY: will hold the key verification output.

     Verifies the self signature in the key.  The key verification
     output will be put in `verify' and will be one or more of the
     gnutls_certificate_status_t enumerated elements bitwise or'd.

     *Returns:* `GNUTLS_E_SUCCESS' on success, or an error code.

gnutls_openpgp_keyring_check_id
-------------------------------

 -- Function: int gnutls_openpgp_keyring_check_id
          (gnutls_openpgp_keyring_t RING, const gnutls_openpgp_keyid_t
          KEYID, unsigned int FLAGS)
     RING: holds the keyring to check against

     KEYID: will hold the keyid to check for.

     FLAGS: unused (should be 0)

     Check if a given key ID exists in the keyring.

     *Returns:* `GNUTLS_E_SUCCESS' on success (if keyid exists) and a
     negative error code on failure.

gnutls_openpgp_keyring_deinit
-----------------------------

 -- Function: void gnutls_openpgp_keyring_deinit
          (gnutls_openpgp_keyring_t KEYRING)
     KEYRING: The structure to be initialized

     This function will deinitialize a keyring structure.

gnutls_openpgp_keyring_get_crt_count
------------------------------------

 -- Function: int gnutls_openpgp_keyring_get_crt_count
          (gnutls_openpgp_keyring_t RING)
     RING: is an OpenPGP key ring

     This function will return the number of OpenPGP certificates
     present in the given keyring.

     *Returns:* the number of subkeys, or a negative value on error.

gnutls_openpgp_keyring_get_crt
------------------------------

 -- Function: int gnutls_openpgp_keyring_get_crt
          (gnutls_openpgp_keyring_t RING, unsigned int IDX,
          gnutls_openpgp_crt_t * CERT)
     RING: Holds the keyring.

     IDX: the index of the certificate to export

     CERT: An uninitialized `gnutls_openpgp_crt_t' structure

     This function will extract an OpenPGP certificate from the given
     keyring.  If the index given is out of range
     `GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE' will be returned. The
     returned structure needs to be deinited.

     *Returns:* `GNUTLS_E_SUCCESS' on success, or an error code.

gnutls_openpgp_keyring_import
-----------------------------

 -- Function: int gnutls_openpgp_keyring_import
          (gnutls_openpgp_keyring_t KEYRING, const gnutls_datum_t *
          DATA, gnutls_openpgp_crt_fmt_t FORMAT)
     KEYRING: The structure to store the parsed key.

     DATA: The RAW or BASE64 encoded keyring.

     FORMAT: One of `gnutls_openpgp_keyring_fmt' elements.

     This function will convert the given RAW or Base64 encoded keyring
     to the native `gnutls_openpgp_keyring_t' format.  The output will
     be stored in 'keyring'.

     *Returns:* `GNUTLS_E_SUCCESS' on success, or an error code.

gnutls_openpgp_keyring_init
---------------------------

 -- Function: int gnutls_openpgp_keyring_init (gnutls_openpgp_keyring_t
          * KEYRING)
     KEYRING: The structure to be initialized

     This function will initialize an keyring structure.

     *Returns:* `GNUTLS_E_SUCCESS' on success, or an error code.

gnutls_openpgp_privkey_deinit
-----------------------------

 -- Function: void gnutls_openpgp_privkey_deinit
          (gnutls_openpgp_privkey_t KEY)
     KEY: The structure to be initialized

     This function will deinitialize a key structure.

gnutls_openpgp_privkey_export_dsa_raw
-------------------------------------

 -- Function: int gnutls_openpgp_privkey_export_dsa_raw
          (gnutls_openpgp_privkey_t PKEY, gnutls_datum_t * P,
          gnutls_datum_t * Q, gnutls_datum_t * G, gnutls_datum_t * Y,
          gnutls_datum_t * X)
     PKEY: Holds the certificate

     P: will hold the p

     Q: will hold the q

     G: will hold the g

     Y: will hold the y

     X: will hold the x

     This function will export the DSA private key's parameters found in
     the given certificate.  The new parameters will be allocated using
     `gnutls_malloc()' and will be stored in the appropriate datum.

     *Returns:* `GNUTLS_E_SUCCESS' on success, otherwise an error.

     *Since:* 2.4.0

gnutls_openpgp_privkey_export_rsa_raw
-------------------------------------

 -- Function: int gnutls_openpgp_privkey_export_rsa_raw
          (gnutls_openpgp_privkey_t PKEY, gnutls_datum_t * M,
          gnutls_datum_t * E, gnutls_datum_t * D, gnutls_datum_t * P,
          gnutls_datum_t * Q, gnutls_datum_t * U)
     PKEY: Holds the certificate

     M: will hold the modulus

     E: will hold the public exponent

     D: will hold the private exponent

     P: will hold the first prime (p)

     Q: will hold the second prime (q)

     U: will hold the coefficient

     This function will export the RSA private key's parameters found in
     the given structure.  The new parameters will be allocated using
     `gnutls_malloc()' and will be stored in the appropriate datum.

     *Returns:* `GNUTLS_E_SUCCESS' on success, otherwise an error.

     *Since:* 2.4.0

gnutls_openpgp_privkey_export_subkey_dsa_raw
--------------------------------------------

 -- Function: int gnutls_openpgp_privkey_export_subkey_dsa_raw
          (gnutls_openpgp_privkey_t PKEY, unsigned int IDX,
          gnutls_datum_t * P, gnutls_datum_t * Q, gnutls_datum_t * G,
          gnutls_datum_t * Y, gnutls_datum_t * X)
     PKEY: Holds the certificate

     IDX: Is the subkey index

     P: will hold the p

     Q: will hold the q

     G: will hold the g

     Y: will hold the y

     X: will hold the x

     This function will export the DSA private key's parameters found
     in the given certificate.  The new parameters will be allocated
     using `gnutls_malloc()' and will be stored in the appropriate
     datum.

     *Returns:* `GNUTLS_E_SUCCESS' on success, otherwise an error.

     *Since:* 2.4.0

gnutls_openpgp_privkey_export_subkey_rsa_raw
--------------------------------------------

 -- Function: int gnutls_openpgp_privkey_export_subkey_rsa_raw
          (gnutls_openpgp_privkey_t PKEY, unsigned int IDX,
          gnutls_datum_t * M, gnutls_datum_t * E, gnutls_datum_t * D,
          gnutls_datum_t * P, gnutls_datum_t * Q, gnutls_datum_t * U)
     PKEY: Holds the certificate

     IDX: Is the subkey index

     M: will hold the modulus

     E: will hold the public exponent

     D: will hold the private exponent

     P: will hold the first prime (p)

     Q: will hold the second prime (q)

     U: will hold the coefficient

     This function will export the RSA private key's parameters found in
     the given structure.  The new parameters will be allocated using
     `gnutls_malloc()' and will be stored in the appropriate datum.

     *Returns:* `GNUTLS_E_SUCCESS' on success, otherwise an error.

     *Since:* 2.4.0

gnutls_openpgp_privkey_export
-----------------------------

 -- Function: int gnutls_openpgp_privkey_export
          (gnutls_openpgp_privkey_t KEY, gnutls_openpgp_crt_fmt_t
          FORMAT, const char * PASSWORD, unsigned int FLAGS, void *
          OUTPUT_DATA, size_t * OUTPUT_DATA_SIZE)
     KEY: Holds the key.

     FORMAT: One of gnutls_openpgp_crt_fmt_t elements.

     PASSWORD: the password that will be used to encrypt the key.
     (unused for now)

     FLAGS: zero for future compatibility

     OUTPUT_DATA: will contain the key base64 encoded or raw

     OUTPUT_DATA_SIZE: holds the size of output_data (and will be
     replaced by the actual size of parameters)

     This function will convert the given key to RAW or Base64 format.
     If the buffer provided is not long enough to hold the output, then
     GNUTLS_E_SHORT_MEMORY_BUFFER will be returned.

     *Returns:* `GNUTLS_E_SUCCESS' on success, or an error code.

     *Since:* 2.4.0

gnutls_openpgp_privkey_get_fingerprint
--------------------------------------

 -- Function: int gnutls_openpgp_privkey_get_fingerprint
          (gnutls_openpgp_privkey_t KEY, void * FPR, size_t * FPRLEN)
     KEY: the raw data that contains the OpenPGP secret key.

     FPR: the buffer to save the fingerprint, must hold at least 20
     bytes.

     FPRLEN: the integer to save the length of the fingerprint.

     Get the fingerprint of the OpenPGP key. Depends on the algorithm,
     the fingerprint can be 16 or 20 bytes.

     *Returns:* On success, 0 is returned, or an error code.

     *Since:* 2.4.0

gnutls_openpgp_privkey_get_key_id
---------------------------------

 -- Function: int gnutls_openpgp_privkey_get_key_id
          (gnutls_openpgp_privkey_t KEY, gnutls_openpgp_keyid_t KEYID)
     KEY: the structure that contains the OpenPGP secret key.

     KEYID: the buffer to save the keyid.

     Get key-id.

     *Returns:* the 64-bit keyID of the OpenPGP key.

     *Since:* 2.4.0

gnutls_openpgp_privkey_get_pk_algorithm
---------------------------------------

 -- Function: gnutls_pk_algorithm_t
gnutls_openpgp_privkey_get_pk_algorithm (gnutls_openpgp_privkey_t KEY,
          unsigned int * BITS)
     KEY: is an OpenPGP key

     BITS: if bits is non null it will hold the size of the parameters'
     in bits

     This function will return the public key algorithm of an OpenPGP
     certificate.

     If bits is non null, it should have enough size to hold the
     parameters size in bits. For RSA the bits returned is the modulus.
     For DSA the bits returned are of the public exponent.

     *Returns:* a member of the `gnutls_pk_algorithm_t' enumeration on
     success, or a negative value on error.

     *Since:* 2.4.0

gnutls_openpgp_privkey_get_preferred_key_id
-------------------------------------------

 -- Function: int gnutls_openpgp_privkey_get_preferred_key_id
          (gnutls_openpgp_privkey_t KEY, gnutls_openpgp_keyid_t KEYID)
     KEY: the structure that contains the OpenPGP public key.

     KEYID: the struct to save the keyid.

     Get the preferred key-id for the key.

     *Returns:* the 64-bit preferred keyID of the OpenPGP key, or if it
     hasn't been set it returns `GNUTLS_E_INVALID_REQUEST'.

gnutls_openpgp_privkey_get_revoked_status
-----------------------------------------

 -- Function: int gnutls_openpgp_privkey_get_revoked_status
          (gnutls_openpgp_privkey_t KEY)
     KEY: the structure that contains the OpenPGP private key.

     Get revocation status of key.

     *Returns:* true (1) if the key has been revoked, or false (0) if it
     has not, or a negative value indicates an error.

     *Since:* 2.4.0

gnutls_openpgp_privkey_get_subkey_count
---------------------------------------

 -- Function: int gnutls_openpgp_privkey_get_subkey_count
          (gnutls_openpgp_privkey_t KEY)
     KEY: is an OpenPGP key

     This function will return the number of subkeys present in the
     given OpenPGP certificate.

     *Returns:* the number of subkeys, or a negative value on error.

     *Since:* 2.4.0

gnutls_openpgp_privkey_get_subkey_creation_time
-----------------------------------------------

 -- Function: time_t gnutls_openpgp_privkey_get_subkey_creation_time
          (gnutls_openpgp_privkey_t KEY, unsigned int IDX)
     KEY: the structure that contains the OpenPGP private key.

     IDX: the subkey index

     Get subkey creation time.

     *Returns:* the timestamp when the OpenPGP key was created.

     *Since:* 2.4.0

gnutls_openpgp_privkey_get_subkey_expiration_time
-------------------------------------------------

 -- Function: time_t gnutls_openpgp_privkey_get_subkey_expiration_time
          (gnutls_openpgp_privkey_t KEY, unsigned int IDX)
     KEY: the structure that contains the OpenPGP private key.

     IDX: the subkey index

     Get subkey expiration time.  A value of '0' means that the key
     doesn't expire at all.

     *Returns:* the time when the OpenPGP key expires.

     *Since:* 2.4.0

gnutls_openpgp_privkey_get_subkey_fingerprint
---------------------------------------------

 -- Function: int gnutls_openpgp_privkey_get_subkey_fingerprint
          (gnutls_openpgp_privkey_t KEY, unsigned int IDX, void * FPR,
          size_t * FPRLEN)
     KEY: the raw data that contains the OpenPGP secret key.

     IDX: the subkey index

     FPR: the buffer to save the fingerprint, must hold at least 20
     bytes.

     FPRLEN: the integer to save the length of the fingerprint.

     Get the fingerprint of an OpenPGP subkey.  Depends on the
     algorithm, the fingerprint can be 16 or 20 bytes.

     *Returns:* On success, 0 is returned, or an error code.

     *Since:* 2.4.0

gnutls_openpgp_privkey_get_subkey_idx
-------------------------------------

 -- Function: int gnutls_openpgp_privkey_get_subkey_idx
          (gnutls_openpgp_privkey_t KEY, const gnutls_openpgp_keyid_t
          KEYID)
     KEY: the structure that contains the OpenPGP private key.

     KEYID: the keyid.

     Get index of subkey.

     *Returns:* the index of the subkey or a negative error value.

     *Since:* 2.4.0

gnutls_openpgp_privkey_get_subkey_id
------------------------------------

 -- Function: int gnutls_openpgp_privkey_get_subkey_id
          (gnutls_openpgp_privkey_t KEY, unsigned int IDX,
          gnutls_openpgp_keyid_t KEYID)
     KEY: the structure that contains the OpenPGP secret key.

     IDX: the subkey index

     KEYID: the buffer to save the keyid.

     Get the key-id for the subkey.

     *Returns:* the 64-bit keyID of the OpenPGP key.

     *Since:* 2.4.0

gnutls_openpgp_privkey_get_subkey_pk_algorithm
----------------------------------------------

 -- Function: gnutls_pk_algorithm_t
gnutls_openpgp_privkey_get_subkey_pk_algorithm
          (gnutls_openpgp_privkey_t KEY, unsigned int IDX, unsigned int
          * BITS)
     KEY: is an OpenPGP key

     IDX: is the subkey index

     BITS: if bits is non null it will hold the size of the parameters'
     in bits

     This function will return the public key algorithm of a subkey of
     an OpenPGP certificate.

     If bits is non null, it should have enough size to hold the
     parameters size in bits. For RSA the bits returned is the modulus.
     For DSA the bits returned are of the public exponent.

     *Returns:* a member of the `gnutls_pk_algorithm_t' enumeration on
     success, or a negative value on error.

     *Since:* 2.4.0

gnutls_openpgp_privkey_get_subkey_revoked_status
------------------------------------------------

 -- Function: int gnutls_openpgp_privkey_get_subkey_revoked_status
          (gnutls_openpgp_privkey_t KEY, unsigned int IDX)
     KEY: the structure that contains the OpenPGP private key.

     IDX: is the subkey index

     Get revocation status of key.

     *Returns:* true (1) if the key has been revoked, or false (0) if it
     has not, or a negative value indicates an error.

     *Since:* 2.4.0

gnutls_openpgp_privkey_import
-----------------------------

 -- Function: int gnutls_openpgp_privkey_import
          (gnutls_openpgp_privkey_t KEY, const gnutls_datum_t * DATA,
          gnutls_openpgp_crt_fmt_t FORMAT, const char * PASSWORD,
          unsigned int FLAGS)
     KEY: The structure to store the parsed key.

     DATA: The RAW or BASE64 encoded key.

     FORMAT: One of `gnutls_openpgp_crt_fmt_t' elements.

     PASSWORD: not used for now

     FLAGS: should be zero

     This function will convert the given RAW or Base64 encoded key to
     the native gnutls_openpgp_privkey_t format.  The output will be
     stored in 'key'.

     *Returns:* `GNUTLS_E_SUCCESS' on success, or an error code.

gnutls_openpgp_privkey_init
---------------------------

 -- Function: int gnutls_openpgp_privkey_init (gnutls_openpgp_privkey_t
          * KEY)
     KEY: The structure to be initialized

     This function will initialize an OpenPGP key structure.

     *Returns:* `GNUTLS_E_SUCCESS' on success, or an error code.

gnutls_openpgp_privkey_sec_param
--------------------------------

 -- Function: gnutls_sec_param_t gnutls_openpgp_privkey_sec_param
          (gnutls_openpgp_privkey_t KEY)
     KEY: a key structure

     This function will return the security parameter appropriate with
     this private key.

     *Returns:* On success, a valid security parameter is returned
     otherwise `GNUTLS_SEC_PARAM_UNKNOWN' is returned.

gnutls_openpgp_privkey_set_preferred_key_id
-------------------------------------------

 -- Function: int gnutls_openpgp_privkey_set_preferred_key_id
          (gnutls_openpgp_privkey_t KEY, const gnutls_openpgp_keyid_t
          KEYID)
     KEY: the structure that contains the OpenPGP public key.

     KEYID: the selected keyid

     This allows setting a preferred key id for the given certificate.
     This key will be used by functions that involve key handling.

     *Returns:* On success, 0 is returned, or an error code.

gnutls_openpgp_privkey_sign_hash
--------------------------------

 -- Function: int gnutls_openpgp_privkey_sign_hash
          (gnutls_openpgp_privkey_t KEY, const gnutls_datum_t * HASH,
          gnutls_datum_t * SIGNATURE)
     KEY: Holds the key

     HASH: holds the data to be signed

     SIGNATURE: will contain newly allocated signature

     This function will sign the given hash using the private key.  You
     should use `gnutls_openpgp_privkey_set_preferred_key_id()' before
     calling this function to set the subkey to use.

     *Returns:* On success, `GNUTLS_E_SUCCESS' is returned, otherwise a
     negative error value.

     *Deprecated:* Use `gnutls_privkey_sign_hash()' instead.

gnutls_openpgp_set_recv_key_function
------------------------------------

 -- Function: void gnutls_openpgp_set_recv_key_function
          (gnutls_session_t SESSION, gnutls_openpgp_recv_key_func FUNC)
     SESSION: a TLS session

     FUNC: the callback

     This funtion will set a key retrieval function for OpenPGP keys.
     This callback is only useful in server side, and will be used if
     the peer sent a key fingerprint instead of a full key.


File: gnutls.info,  Node: TLS Inner Application (TLS/IA) functions,  Next: Error codes and descriptions,  Prev: OpenPGP functions,  Up: Function reference

9.5 TLS Inner Application (TLS/IA) Functions
============================================

The following functions are used for TLS Inner Application (TLS/IA).
Their prototypes lie in `gnutls/extra.h'.  You need to link with
`libgnutls-extra' to be able to use these functions (*note GnuTLS-extra
functions::).

The typical control flow in an TLS/IA client (that would not require an
Application Phase for resumed sessions) would be similar to the
following:

     int client_avp (gnuls_session_t *session, void *ptr,
                     const char *last, size_t lastlen,
     		char **new, size_t *newlen)
     {
     ...
     }
     ...
     int main ()
     {
       gnutls_ia_client_credentials_t iacred;
     ...
       gnutls_init (&session, GNUTLS_CLIENT);
     ...
       /* Enable TLS/IA. */
       gnutls_ia_allocate_client_credentials(&iacred);
       gnutls_ia_set_client_avp_function(iacred, client_avp);
       gnutls_credentials_set (session, GNUTLS_CRD_IA, iacred);
     ...
       ret = gnutls_handshake (session);
       // Error handling...
     ...
       if (gnutls_ia_handshake_p (session))
         {
           ret = gnutls_ia_handshake (session);
           // Error handling...
     ...

See below for detailed descriptions of all the functions used above.

The function `client_avp' would have to be implemented by your
application.  The function is responsible for handling the AVP data.
See `gnutls_ia_set_client_avp_function' below for more information on
how that function should be implemented.

The control flow in a typical server is similar to the above, use
`gnutls_ia_server_credentials_t' instead of
`gnutls_ia_client_credentials_t', and replace the call to the client
functions with the corresponding server functions.

gnutls_ia_allocate_client_credentials
-------------------------------------

 -- Function: int gnutls_ia_allocate_client_credentials
          (gnutls_ia_client_credentials_t * SC)
     SC: is a pointer to a `gnutls_ia_server_credentials_t' structure.

     This structure is complex enough to manipulate directly thus this
     helper function is provided in order to allocate it.

     Adding this credential to a session will enable TLS/IA, and will
     require an Application Phase after the TLS handshake (if the server
     support TLS/IA).  Use `gnutls_ia_enable()' to toggle the TLS/IA
     mode.

     *Returns:* On success, `GNUTLS_E_SUCCESS' (0) is returned,
     otherwise an error code is returned.

gnutls_ia_allocate_server_credentials
-------------------------------------

 -- Function: int gnutls_ia_allocate_server_credentials
          (gnutls_ia_server_credentials_t * SC)
     SC: is a pointer to a `gnutls_ia_server_credentials_t' structure.

     This structure is complex enough to manipulate directly thus this
     helper function is provided in order to allocate it.

     Adding this credential to a session will enable TLS/IA, and will
     require an Application Phase after the TLS handshake (if the client
     support TLS/IA).  Use `gnutls_ia_enable()' to toggle the TLS/IA
     mode.

     *Returns:* On success, `GNUTLS_E_SUCCESS' (0) is returned,
     otherwise an error code is returned.

gnutls_ia_enable
----------------

 -- Function: void gnutls_ia_enable (gnutls_session_t SESSION, int
          ALLOW_SKIP_ON_RESUME)
     SESSION: is a `gnutls_session_t' structure.

     ALLOW_SKIP_ON_RESUME: non-zero if local party allows one to skip
     the TLS/IA application phases for a resumed session.

     Specify whether we must advertise support for the TLS/IA extension
     during the handshake.

     At the client side, we always advertise TLS/IA if gnutls_ia_enable
     was called before the handshake; at the server side, we also
     require that the client has advertised that it wants to run TLS/IA
     before including the advertisement, as required by the protocol.

     Similarly, at the client side we always advertise that we allow
     TLS/IA to be skipped for resumed sessions if `allow_skip_on_resume'
     is non-zero; at the server side, we also require that the session
     is indeed resumable and that the client has also advertised that it
     allows TLS/IA to be skipped for resumed sessions.

     After the TLS handshake, call `gnutls_ia_handshake_p()' to find out
     whether both parties agreed to do a TLS/IA handshake, before
     calling `gnutls_ia_handshake()' or one of the lower level
     gnutls_ia_* functions.

gnutls_ia_endphase_send
-----------------------

 -- Function: int gnutls_ia_endphase_send (gnutls_session_t SESSION,
          int FINAL_P)
     SESSION: is a `gnutls_session_t' structure.

     FINAL_P: Set iff this should signal the final phase.

     Send a TLS/IA end phase message.

     In the client, this should only be used to acknowledge an end phase
     message sent by the server.

     In the server, this can be called instead of `gnutls_ia_send()' if
     the server wishes to end an application phase.

     *Return value:* Return 0 on success, or an error code.

gnutls_ia_extract_inner_secret
------------------------------

 -- Function: void gnutls_ia_extract_inner_secret (gnutls_session_t
          SESSION, char * BUFFER)
     SESSION: is a `gnutls_session_t' structure.

     BUFFER: pre-allocated buffer to hold 48 bytes of inner secret.

     Copy the 48 bytes large inner secret into the specified buffer

     This function is typically used after the TLS/IA handshake has
     concluded.  The TLS/IA inner secret can be used as input to a PRF
     to derive session keys.  Do not use the inner secret directly as a
     session key, because for a resumed session that does not include an
     application phase, the inner secret will be identical to the inner
     secret in the original session.  It is important to include, for
     example, the client and server randomness when deriving a sesssion
     key from the inner secret.

gnutls_ia_free_client_credentials
---------------------------------

 -- Function: void gnutls_ia_free_client_credentials
          (gnutls_ia_client_credentials_t SC)
     SC: is a `gnutls_ia_client_credentials_t' structure.

     This structure is complex enough to manipulate directly thus this
     helper function is provided in order to free (deallocate) it.

gnutls_ia_free_server_credentials
---------------------------------

 -- Function: void gnutls_ia_free_server_credentials
          (gnutls_ia_server_credentials_t SC)
     SC: is a `gnutls_ia_server_credentials_t' structure.

     This structure is complex enough to manipulate directly thus this
     helper function is provided in order to free (deallocate) it.

gnutls_ia_generate_challenge
----------------------------

 -- Function: int gnutls_ia_generate_challenge (gnutls_session_t
          SESSION, size_t BUFFER_SIZE, char * BUFFER)
     SESSION: is a `gnutls_session_t' structure.

     BUFFER_SIZE: size of output buffer.

     BUFFER: pre-allocated buffer to contain `buffer_size' bytes of
     output.

     Generate an application challenge that the client cannot control or
     predict, based on the TLS/IA inner secret.

     *Return value:* Returns 0 on success, or an negative error code.

gnutls_ia_get_client_avp_ptr
----------------------------

 -- Function: void * gnutls_ia_get_client_avp_ptr
          (gnutls_ia_client_credentials_t CRED)
     CRED: is a `gnutls_ia_client_credentials_t' structure.

     Returns the pointer that will be provided to the TLS/IA callback
     function as the first argument.

     *Returns:* The client callback data pointer.

gnutls_ia_get_server_avp_ptr
----------------------------

 -- Function: void * gnutls_ia_get_server_avp_ptr
          (gnutls_ia_server_credentials_t CRED)
     CRED: is a `gnutls_ia_client_credentials_t' structure.

     Returns the pointer that will be provided to the TLS/IA callback
     function as the first argument.

     *Returns:* The server callback data pointer.

gnutls_ia_handshake_p
---------------------

 -- Function: int gnutls_ia_handshake_p (gnutls_session_t SESSION)
     SESSION: is a `gnutls_session_t' structure.

     Predicate to be used after `gnutls_handshake()' to decide whether
     to invoke `gnutls_ia_handshake()'.  Usable by both clients and
     servers.

     *Return value:* non-zero if TLS/IA handshake is expected, zero
     otherwise.

gnutls_ia_handshake
-------------------

 -- Function: int gnutls_ia_handshake (gnutls_session_t SESSION)
     SESSION: is a `gnutls_session_t' structure.

     Perform a TLS/IA handshake.  This should be called after
     `gnutls_handshake()' iff `gnutls_ia_handshake_p()'.

     *Returns:* On success, `GNUTLS_E_SUCCESS' (zero) is returned,
     otherwise an error code is returned.

gnutls_ia_permute_inner_secret
------------------------------

 -- Function: int gnutls_ia_permute_inner_secret (gnutls_session_t
          SESSION, size_t SESSION_KEYS_SIZE, const char * SESSION_KEYS)
     SESSION: is a `gnutls_session_t' structure.

     SESSION_KEYS_SIZE: Size of generated session keys (0 if none).

     SESSION_KEYS: Generated session keys, used to permute inner secret
     (NULL if none).

     Permute the inner secret using the generated session keys.

     This can be called in the TLS/IA AVP callback to mix any generated
     session keys with the TLS/IA inner secret.

     *Return value:* Return zero on success, or a negative error code.

gnutls_ia_recv
--------------

 -- Function: ssize_t gnutls_ia_recv (gnutls_session_t SESSION, char *
          DATA, size_t SIZEOFDATA)
     SESSION: is a `gnutls_session_t' structure.

     DATA: the buffer that the data will be read into, must hold >= 12
     bytes.

     SIZEOFDATA: the number of requested bytes, must be >= 12.

     Receive TLS/IA data.  This function has the similar semantics with
     `recv()'.  The only difference is that it accepts a GnuTLS session,
     and uses different error codes.

     If the server attempt to finish an application phase, this function
     will return `GNUTLS_E_WARNING_IA_IPHF_RECEIVED' or
     `GNUTLS_E_WARNING_IA_FPHF_RECEIVED'.  The caller should then invoke
     `gnutls_ia_verify_endphase()', and if it runs the client side, also
     send an endphase message of its own using gnutls_ia_endphase_send.

     If EINTR is returned by the internal push function (the default is
     `code'{`recv()'}) then GNUTLS_E_INTERRUPTED will be returned.  If
     GNUTLS_E_INTERRUPTED or GNUTLS_E_AGAIN is returned, you must call
     this function again, with the same parameters; alternatively you
     could provide a NULL pointer for data, and 0 for size.

     *Returns:* The number of bytes received.  A negative error code is
     returned in case of an error.  The
     `GNUTLS_E_WARNING_IA_IPHF_RECEIVED' and
     `GNUTLS_E_WARNING_IA_FPHF_RECEIVED' errors are returned when an
     application phase finished message has been sent by the server.

gnutls_ia_send
--------------

 -- Function: ssize_t gnutls_ia_send (gnutls_session_t SESSION, const
          char * DATA, size_t SIZEOFDATA)
     SESSION: is a `gnutls_session_t' structure.

     DATA: contains the data to send

     SIZEOFDATA: is the length of the data

     Send TLS/IA application payload data.  This function has the
     similar semantics with `send()'.  The only difference is that it
     accepts a GnuTLS session, and uses different error codes.

     The TLS/IA protocol is synchronous, so you cannot send more than
     one packet at a time.  The client always send the first packet.

     To finish an application phase in the server, use
     `gnutls_ia_endphase_send()'.  The client cannot end an application
     phase unilaterally; rather, a client is required to respond with an
     endphase of its own if gnutls_ia_recv indicates that the server has
     sent one.

     If the EINTR is returned by the internal push function (the default
     is `send()'} then `GNUTLS_E_INTERRUPTED' will be returned.  If
     `GNUTLS_E_INTERRUPTED' or `GNUTLS_E_AGAIN' is returned, you must
     call this function again, with the same parameters; alternatively
     you could provide a `NULL' pointer for data, and 0 for size.

     *Returns:* The number of bytes sent, or a negative error code.

gnutls_ia_set_client_avp_function
---------------------------------

 -- Function: void gnutls_ia_set_client_avp_function
          (gnutls_ia_client_credentials_t CRED, gnutls_ia_avp_func
          AVP_FUNC)
     CRED: is a `gnutls_ia_client_credentials_t' structure.

     AVP_FUNC: is the callback function

     Set the TLS/IA AVP callback handler used for the session.

     The AVP callback is called to process AVPs received from the
     server, and to get a new AVP to send to the server.

     The callback's function form is: int (*avp_func) (gnutls_session_t
     session, void *ptr, const char *last, size_t lastlen, char **next,
     size_t *nextlen);

     The `session' parameter is the `gnutls_session_t' structure
     corresponding to the current session.  The `ptr' parameter is the
     application hook pointer, set through
     `gnutls_ia_set_client_avp_ptr()'.  The AVP received from the server
     is present in `last' of `lastlen' size, which will be `NULL' on the
     first invocation.  The newly allocated output AVP to send to the
     server should be placed in *`next' of *`nextlen' size.

     The callback may invoke `gnutls_ia_permute_inner_secret()' to mix
     any generated session keys with the TLS/IA inner secret.

     Return 0 (`GNUTLS_IA_APPLICATION_PAYLOAD') on success, or a
     negative error code to abort the TLS/IA handshake.

     Note that the callback must use allocate the `next' parameter using
     `gnutls_malloc()', because it is released via `gnutls_free()' by
     the TLS/IA handshake function.

gnutls_ia_set_client_avp_ptr
----------------------------

 -- Function: void gnutls_ia_set_client_avp_ptr
          (gnutls_ia_client_credentials_t CRED, void * PTR)
     CRED: is a `gnutls_ia_client_credentials_t' structure.

     PTR: is the pointer

     Sets the pointer that will be provided to the TLS/IA callback
     function as the first argument.

gnutls_ia_set_server_avp_function
---------------------------------

 -- Function: void gnutls_ia_set_server_avp_function
          (gnutls_ia_server_credentials_t CRED, gnutls_ia_avp_func
          AVP_FUNC)
     CRED: is a `gnutls_ia_server_credentials_t' structure.

     Set the TLS/IA AVP callback handler used for the session.

     The callback's function form is: int (*avp_func) (gnutls_session_t
     session, void *ptr, const char *last, size_t lastlen, char **next,
     size_t *nextlen);

     The `session' parameter is the `gnutls_session_t' structure
     corresponding to the current session.  The `ptr' parameter is the
     application hook pointer, set through
     `gnutls_ia_set_server_avp_ptr()'.  The AVP received from the client
     is present in `last' of `lastlen' size.  The newly allocated output
     AVP to send to the client should be placed in *`next' of *`nextlen'
     size.

     The AVP callback is called to process incoming AVPs from the
     client, and to get a new AVP to send to the client.  It can also be
     used to instruct the TLS/IA handshake to do go into the
     Intermediate or Final phases.  It return a negative error code, or
     a `gnutls_ia_apptype_t' message type.

     The callback may invoke `gnutls_ia_permute_inner_secret()' to mix
     any generated session keys with the TLS/IA inner secret.

     Specifically, return `GNUTLS_IA_APPLICATION_PAYLOAD' (0) to send
     another AVP to the client, return
     `GNUTLS_IA_INTERMEDIATE_PHASE_FINISHED' (1) to indicate that an
     IntermediatePhaseFinished message should be sent, and return
     `GNUTLS_IA_FINAL_PHASE_FINISHED' (2) to indicate that an
     FinalPhaseFinished message should be sent.  In the last two cases,
     the contents of the `next' and `nextlen' parameter is not used.

     Note that the callback must use allocate the `next' parameter using
     `gnutls_malloc()', because it is released via `gnutls_free()' by
     the TLS/IA handshake function.

gnutls_ia_set_server_avp_ptr
----------------------------

 -- Function: void gnutls_ia_set_server_avp_ptr
          (gnutls_ia_server_credentials_t CRED, void * PTR)
     CRED: is a `gnutls_ia_client_credentials_t' structure.

     PTR: is the pointer

     Sets the pointer that will be provided to the TLS/IA callback
     function as the first argument.

gnutls_ia_verify_endphase
-------------------------

 -- Function: int gnutls_ia_verify_endphase (gnutls_session_t SESSION,
          const char * CHECKSUM)
     SESSION: is a `gnutls_session_t' structure.

     CHECKSUM: 12-byte checksum data, received from `gnutls_ia_recv()'.

     Verify TLS/IA end phase checksum data.  If verification fails, the
     `GNUTLS_A_INNER_APPLICATION_VERIFICATION' alert is sent to the
     other sie.

     This function is called when `gnutls_ia_recv()' return
     `GNUTLS_E_WARNING_IA_IPHF_RECEIVED' or
     `GNUTLS_E_WARNING_IA_FPHF_RECEIVED'.

     *Return value:* Return 0 on successful verification, or an error
     code.  If the checksum verification of the end phase message fails,
     `GNUTLS_E_IA_VERIFY_FAILED' is returned.


File: gnutls.info,  Node: Error codes and descriptions,  Prev: TLS Inner Application (TLS/IA) functions,  Up: Function reference

9.6 Error Codes and Descriptions
================================

The error codes used throughout the library are described below.  The
return code `GNUTLS_E_SUCCESS' indicate successful operation, and is
guaranteed to have the value 0, so you can use it in logical
expressions.

`GNUTLS_E_AGAIN:'
     Resource temporarily unavailable, try again.

`GNUTLS_E_ASN1_DER_ERROR:'
     ASN1 parser: Error in DER parsing.

`GNUTLS_E_ASN1_DER_OVERFLOW:'
     ASN1 parser: Overflow in DER parsing.

`GNUTLS_E_ASN1_ELEMENT_NOT_FOUND:'
     ASN1 parser: Element was not found.

`GNUTLS_E_ASN1_GENERIC_ERROR:'
     ASN1 parser: Generic parsing error.

`GNUTLS_E_ASN1_IDENTIFIER_NOT_FOUND:'
     ASN1 parser: Identifier was not found

`GNUTLS_E_ASN1_SYNTAX_ERROR:'
     ASN1 parser: Syntax error.

`GNUTLS_E_ASN1_TAG_ERROR:'
     ASN1 parser: Error in TAG.

`GNUTLS_E_ASN1_TAG_IMPLICIT:'
     ASN1 parser: error in implicit tag

`GNUTLS_E_ASN1_TYPE_ANY_ERROR:'
     ASN1 parser: Error in type 'ANY'.

`GNUTLS_E_ASN1_VALUE_NOT_FOUND:'
     ASN1 parser: Value was not found.

`GNUTLS_E_ASN1_VALUE_NOT_VALID:'
     ASN1 parser: Value is not valid.

`GNUTLS_E_BASE64_DECODING_ERROR:'
     Base64 decoding error.

`GNUTLS_E_BASE64_ENCODING_ERROR:'
     Base64 encoding error.

`GNUTLS_E_BASE64_UNEXPECTED_HEADER_ERROR:'
     Base64 unexpected header error.

`GNUTLS_E_CERTIFICATE_ERROR:'
     Error in the certificate.

`GNUTLS_E_CERTIFICATE_KEY_MISMATCH:'
     The certificate and the given key do not match.

`GNUTLS_E_CHANNEL_BINDING_NOT_AVAILABLE:'
     Channel binding data not available

`GNUTLS_E_COMPRESSION_FAILED:'
     Compression of the TLS record packet has failed.

`GNUTLS_E_CONSTRAINT_ERROR:'
     Some constraint limits were reached.

`GNUTLS_E_CRYPTODEV_DEVICE_ERROR:'
     Error opening /dev/crypto

`GNUTLS_E_CRYPTODEV_IOCTL_ERROR:'
     Error interfacing with /dev/crypto

`GNUTLS_E_CRYPTO_ALREADY_REGISTERED:'
     There is already a crypto algorithm with lower priority.

`GNUTLS_E_CRYPTO_INIT_FAILED:'
     The initialization of crypto backend has failed.

`GNUTLS_E_DB_ERROR:'
     Error in Database backend.

`GNUTLS_E_DECOMPRESSION_FAILED:'
     Decompression of the TLS record packet has failed.

`GNUTLS_E_DECRYPTION_FAILED:'
     Decryption has failed.

`GNUTLS_E_DH_PRIME_UNACCEPTABLE:'
     The Diffie-Hellman prime sent by the server is not acceptable (not
     long enough).

`GNUTLS_E_ENCRYPTION_FAILED:'
     Encryption has failed.

`GNUTLS_E_ERROR_IN_FINISHED_PACKET:'
     An error was encountered at the TLS Finished packet calculation.

`GNUTLS_E_EXPIRED:'
     The requested session has expired.

`GNUTLS_E_FATAL_ALERT_RECEIVED:'
     A TLS fatal alert has been received.

`GNUTLS_E_FILE_ERROR:'
     Error while reading file.

`GNUTLS_E_GOT_APPLICATION_DATA:'
     TLS Application data were received, while expecting handshake data.

`GNUTLS_E_HANDSHAKE_TOO_LARGE:'
     The handshake data size is too large (DoS?), check
     gnutls_handshake_set_max_packet_length().

`GNUTLS_E_HASH_FAILED:'
     Hashing has failed.

`GNUTLS_E_IA_VERIFY_FAILED:'
     Verifying TLS/IA phase checksum failed

`GNUTLS_E_ILLEGAL_SRP_USERNAME:'
     The SRP username supplied is illegal.

`GNUTLS_E_INCOMPATIBLE_GCRYPT_LIBRARY:'
     The gcrypt library version is too old.

`GNUTLS_E_INCOMPATIBLE_LIBTASN1_LIBRARY:'
     The tasn1 library version is too old.

`GNUTLS_E_INCOMPAT_DSA_KEY_WITH_TLS_PROTOCOL:'
     The given DSA key is incompatible with the selected TLS protocol.

`GNUTLS_E_INIT_LIBEXTRA:'
     The initialization of GnuTLS-extra has failed.

`GNUTLS_E_INSUFFICIENT_CREDENTIALS:'
     Insufficient credentials for that request.

`GNUTLS_E_INTERNAL_ERROR:'
     GnuTLS internal error.

`GNUTLS_E_INTERRUPTED:'
     Function was interrupted.

`GNUTLS_E_INVALID_PASSWORD:'
     The given password contains invalid characters.

`GNUTLS_E_INVALID_REQUEST:'
     The request is invalid.

`GNUTLS_E_INVALID_SESSION:'
     The specified session has been invalidated for some reason.

`GNUTLS_E_KEY_USAGE_VIOLATION:'
     Key usage violation in certificate has been detected.

`GNUTLS_E_LARGE_PACKET:'
     A large TLS record packet was received.

`GNUTLS_E_LIBRARY_VERSION_MISMATCH:'
     The GnuTLS library version does not match the GnuTLS-extra library
     version.

`GNUTLS_E_LOCKING_ERROR:'
     Thread locking error

`GNUTLS_E_LZO_INIT_FAILED:'
     The initialization of LZO has failed.

`GNUTLS_E_MAC_VERIFY_FAILED:'
     The Message Authentication Code verification failed.

`GNUTLS_E_MEMORY_ERROR:'
     Internal error in memory allocation.

`GNUTLS_E_MPI_PRINT_FAILED:'
     Could not export a large integer.

`GNUTLS_E_MPI_SCAN_FAILED:'
     The scanning of a large integer has failed.

`GNUTLS_E_NO_CERTIFICATE_FOUND:'
     The peer did not send any certificate.

`GNUTLS_E_NO_CIPHER_SUITES:'
     No supported cipher suites have been found.

`GNUTLS_E_NO_COMPRESSION_ALGORITHMS:'
     No supported compression algorithms have been found.

`GNUTLS_E_NO_TEMPORARY_DH_PARAMS:'
     No temporary DH parameters were found.

`GNUTLS_E_NO_TEMPORARY_RSA_PARAMS:'
     No temporary RSA parameters were found.

`GNUTLS_E_OPENPGP_FINGERPRINT_UNSUPPORTED:'
     The OpenPGP fingerprint is not supported.

`GNUTLS_E_OPENPGP_GETKEY_FAILED:'
     Could not get OpenPGP key.

`GNUTLS_E_OPENPGP_KEYRING_ERROR:'
     Error loading the keyring.

`GNUTLS_E_OPENPGP_PREFERRED_KEY_ERROR:'
     The OpenPGP key has not a preferred key set.

`GNUTLS_E_OPENPGP_SUBKEY_ERROR:'
     Could not find OpenPGP subkey.

`GNUTLS_E_OPENPGP_UID_REVOKED:'
     The OpenPGP User ID is revoked.

`GNUTLS_E_PARSING_ERROR:'
     Error in parsing.

`GNUTLS_E_PKCS11_ATTRIBUTE_ERROR:'
     PKCS #11 error in attribute

`GNUTLS_E_PKCS11_DATA_ERROR:'
     PKCS #11 error in data

`GNUTLS_E_PKCS11_DEVICE_ERROR:'
     PKCS #11 error in device

`GNUTLS_E_PKCS11_ERROR:'
     PKCS #11 error.

`GNUTLS_E_PKCS11_KEY_ERROR:'
     PKCS #11 error in key

`GNUTLS_E_PKCS11_LOAD_ERROR:'
     PKCS #11 initialization error.

`GNUTLS_E_PKCS11_PIN_ERROR:'
     PKCS #11 error in PIN.

`GNUTLS_E_PKCS11_PIN_EXPIRED:'
     PKCS #11 PIN expired

`GNUTLS_E_PKCS11_PIN_LOCKED:'
     PKCS #11 PIN locked

`GNUTLS_E_PKCS11_SESSION_ERROR:'
     PKCS #11 error in session

`GNUTLS_E_PKCS11_SIGNATURE_ERROR:'
     PKCS #11 error in signature

`GNUTLS_E_PKCS11_SLOT_ERROR:'
     PKCS #11 error in slot

`GNUTLS_E_PKCS11_TOKEN_ERROR:'
     PKCS #11 error in token

`GNUTLS_E_PKCS11_UNSUPPORTED_FEATURE_ERROR:'
     PKCS #11 unsupported feature

`GNUTLS_E_PKCS11_USER_ERROR:'
     PKCS #11 user error

`GNUTLS_E_PKCS1_WRONG_PAD:'
     Wrong padding in PKCS1 packet.

`GNUTLS_E_PK_DECRYPTION_FAILED:'
     Public key decryption has failed.

`GNUTLS_E_PK_ENCRYPTION_FAILED:'
     Public key encryption has failed.

`GNUTLS_E_PK_SIGN_FAILED:'
     Public key signing has failed.

`GNUTLS_E_PK_SIG_VERIFY_FAILED:'
     Public key signature verification has failed.

`GNUTLS_E_PULL_ERROR:'
     Error in the pull function.

`GNUTLS_E_PUSH_ERROR:'
     Error in the push function.

`GNUTLS_E_RANDOM_FAILED:'
     Failed to acquire random data.

`GNUTLS_E_RECEIVED_ILLEGAL_EXTENSION:'
     An illegal TLS extension was received.

`GNUTLS_E_RECEIVED_ILLEGAL_PARAMETER:'
     An illegal parameter has been received.

`GNUTLS_E_RECORD_LIMIT_REACHED:'
     The upper limit of record packet sequence numbers has been
     reached. Wow!

`GNUTLS_E_REHANDSHAKE:'
     Rehandshake was requested by the peer.

`GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE:'
     The requested data were not available.

`GNUTLS_E_SAFE_RENEGOTIATION_FAILED:'
     Safe renegotiation failed.

`GNUTLS_E_SHORT_MEMORY_BUFFER:'
     The given memory buffer is too short to hold parameters.

`GNUTLS_E_SRP_PWD_ERROR:'
     Error in password file.

`GNUTLS_E_SRP_PWD_PARSING_ERROR:'
     Parsing error in password file.

`GNUTLS_E_SUCCESS:'
     Success.

`GNUTLS_E_TOO_MANY_EMPTY_PACKETS:'
     Too many empty record packets have been received.

`GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET:'
     An unexpected TLS handshake packet was received.

`GNUTLS_E_UNEXPECTED_PACKET:'
     An unexpected TLS packet was received.

`GNUTLS_E_UNEXPECTED_PACKET_LENGTH:'
     A TLS packet with unexpected length was received.

`GNUTLS_E_UNKNOWN_ALGORITHM:'
     The specified algorithm or protocol is unknown.

`GNUTLS_E_UNKNOWN_CIPHER_SUITE:'
     Could not negotiate a supported cipher suite.

`GNUTLS_E_UNKNOWN_CIPHER_TYPE:'
     The cipher type is unsupported.

`GNUTLS_E_UNKNOWN_COMPRESSION_ALGORITHM:'
     Could not negotiate a supported compression method.

`GNUTLS_E_UNKNOWN_HASH_ALGORITHM:'
     The hash algorithm is unknown.

`GNUTLS_E_UNKNOWN_PKCS_BAG_TYPE:'
     The PKCS structure's bag type is unknown.

`GNUTLS_E_UNKNOWN_PKCS_CONTENT_TYPE:'
     The PKCS structure's content type is unknown.

`GNUTLS_E_UNKNOWN_PK_ALGORITHM:'
     An unknown public key algorithm was encountered.

`GNUTLS_E_UNKNOWN_SRP_USERNAME:'
     The SRP username supplied is unknown.

`GNUTLS_E_UNSAFE_RENEGOTIATION_DENIED:'
     Unsafe renegotiation denied.

`GNUTLS_E_UNSUPPORTED_CERTIFICATE_TYPE:'
     The certificate type is not supported.

`GNUTLS_E_UNSUPPORTED_SIGNATURE_ALGORITHM:'
     The signature algorithm is not supported.

`GNUTLS_E_UNSUPPORTED_VERSION_PACKET:'
     A record packet with illegal version was received.

`GNUTLS_E_UNWANTED_ALGORITHM:'
     An algorithm that is not enabled was negotiated.

`GNUTLS_E_WARNING_ALERT_RECEIVED:'
     A TLS warning alert has been received.

`GNUTLS_E_WARNING_IA_FPHF_RECEIVED:'
     Received a TLS/IA Final Phase Finished message

`GNUTLS_E_WARNING_IA_IPHF_RECEIVED:'
     Received a TLS/IA Intermediate Phase Finished message

`GNUTLS_E_X509_UNKNOWN_SAN:'
     Unknown Subject Alternative name in X.509 certificate.

`GNUTLS_E_X509_UNSUPPORTED_ATTRIBUTE:'
     The certificate has unsupported attributes.

`GNUTLS_E_X509_UNSUPPORTED_CRITICAL_EXTENSION:'
     Unsupported critical extension in X.509 certificate.

`GNUTLS_E_X509_UNSUPPORTED_OID:'
     The OID is not supported.



File: gnutls.info,  Node: All the supported ciphersuites in GnuTLS,  Next: Guile Bindings,  Prev: Function reference,  Up: Top

10 All the Supported Ciphersuites in GnuTLS
*******************************************

Available cipher suites:
TLS_ANON_DH_ARCFOUR_MD5                     0x00 0x18      SSL3.0
TLS_ANON_DH_3DES_EDE_CBC_SHA1               0x00 0x1b      SSL3.0
TLS_ANON_DH_AES_128_CBC_SHA1                0x00 0x34      SSL3.0
TLS_ANON_DH_AES_256_CBC_SHA1                0x00 0x3a      SSL3.0
TLS_ANON_DH_CAMELLIA_128_CBC_SHA1           0x00 0x46      TLS1.0
TLS_ANON_DH_CAMELLIA_256_CBC_SHA1           0x00 0x89      TLS1.0
TLS_ANON_DH_AES_128_CBC_SHA256              0x00 0x6c      TLS1.2
TLS_ANON_DH_AES_256_CBC_SHA256              0x00 0x6d      TLS1.2
TLS_PSK_SHA_ARCFOUR_SHA1                    0x00 0x8a      TLS1.0
TLS_PSK_SHA_3DES_EDE_CBC_SHA1               0x00 0x8b      TLS1.0
TLS_PSK_SHA_AES_128_CBC_SHA1                0x00 0x8c      TLS1.0
TLS_PSK_SHA_AES_256_CBC_SHA1                0x00 0x8d      TLS1.0
TLS_DHE_PSK_SHA_ARCFOUR_SHA1                0x00 0x8e      TLS1.0
TLS_DHE_PSK_SHA_3DES_EDE_CBC_SHA1           0x00 0x8f      TLS1.0
TLS_DHE_PSK_SHA_AES_128_CBC_SHA1            0x00 0x90      TLS1.0
TLS_DHE_PSK_SHA_AES_256_CBC_SHA1            0x00 0x91      TLS1.0
TLS_SRP_SHA_3DES_EDE_CBC_SHA1               0xc0 0x1a      TLS1.0
TLS_SRP_SHA_AES_128_CBC_SHA1                0xc0 0x1d      TLS1.0
TLS_SRP_SHA_AES_256_CBC_SHA1                0xc0 0x20      TLS1.0
TLS_SRP_SHA_DSS_3DES_EDE_CBC_SHA1           0xc0 0x1c      TLS1.0
TLS_SRP_SHA_RSA_3DES_EDE_CBC_SHA1           0xc0 0x1b      TLS1.0
TLS_SRP_SHA_DSS_AES_128_CBC_SHA1            0xc0 0x1f      TLS1.0
TLS_SRP_SHA_RSA_AES_128_CBC_SHA1            0xc0 0x1e      TLS1.0
TLS_SRP_SHA_DSS_AES_256_CBC_SHA1            0xc0 0x22      TLS1.0
TLS_SRP_SHA_RSA_AES_256_CBC_SHA1            0xc0 0x21      TLS1.0
TLS_DHE_DSS_ARCFOUR_SHA1                    0x00 0x66      TLS1.0
TLS_DHE_DSS_3DES_EDE_CBC_SHA1               0x00 0x13      SSL3.0
TLS_DHE_DSS_AES_128_CBC_SHA1                0x00 0x32      SSL3.0
TLS_DHE_DSS_AES_256_CBC_SHA1                0x00 0x38      SSL3.0
TLS_DHE_DSS_CAMELLIA_128_CBC_SHA1           0x00 0x44      TLS1.0
TLS_DHE_DSS_CAMELLIA_256_CBC_SHA1           0x00 0x87      TLS1.0
TLS_DHE_DSS_AES_128_CBC_SHA256              0x00 0x40      TLS1.2
TLS_DHE_DSS_AES_256_CBC_SHA256              0x00 0x6a      TLS1.2
TLS_DHE_RSA_3DES_EDE_CBC_SHA1               0x00 0x16      SSL3.0
TLS_DHE_RSA_AES_128_CBC_SHA1                0x00 0x33      SSL3.0
TLS_DHE_RSA_AES_256_CBC_SHA1                0x00 0x39      SSL3.0
TLS_DHE_RSA_CAMELLIA_128_CBC_SHA1           0x00 0x45      TLS1.0
TLS_DHE_RSA_CAMELLIA_256_CBC_SHA1           0x00 0x88      TLS1.0
TLS_DHE_RSA_AES_128_CBC_SHA256              0x00 0x67      TLS1.2
TLS_DHE_RSA_AES_256_CBC_SHA256              0x00 0x6b      TLS1.2
TLS_RSA_NULL_MD5                            0x00 0x01      SSL3.0
TLS_RSA_NULL_SHA1                           0x00 0x02      SSL3.0
TLS_RSA_NULL_SHA256                         0x00 0x3b      TLS1.2
TLS_RSA_EXPORT_ARCFOUR_40_MD5               0x00 0x03      SSL3.0
TLS_RSA_ARCFOUR_SHA1                        0x00 0x05      SSL3.0
TLS_RSA_ARCFOUR_MD5                         0x00 0x04      SSL3.0
TLS_RSA_3DES_EDE_CBC_SHA1                   0x00 0x0a      SSL3.0
TLS_RSA_AES_128_CBC_SHA1                    0x00 0x2f      SSL3.0
TLS_RSA_AES_256_CBC_SHA1                    0x00 0x35      SSL3.0
TLS_RSA_CAMELLIA_128_CBC_SHA1               0x00 0x41      TLS1.0
TLS_RSA_CAMELLIA_256_CBC_SHA1               0x00 0x84      TLS1.0
TLS_RSA_AES_128_CBC_SHA256                  0x00 0x3c      TLS1.2
TLS_RSA_AES_256_CBC_SHA256                  0x00 0x3d      TLS1.2

Available certificate types:
   * X.509

   * OPENPGP

Available protocols:
   * SSL3.0

   * TLS1.0

   * TLS1.1

   * TLS1.2

Available ciphers:
   * AES-256-CBC

   * AES-128-CBC

   * 3DES-CBC

   * DES-CBC

   * ARCFOUR-128

   * ARCFOUR-40

   * RC2-40

   * CAMELLIA-256-CBC

   * CAMELLIA-128-CBC

   * NULL

Available MAC algorithms:
   * SHA1

   * MD5

   * SHA256

   * SHA384

   * SHA512

   * MD2

   * RIPEMD160

   * MAC-NULL

Available key exchange methods:
   * ANON-DH

   * RSA

   * RSA-EXPORT

   * DHE-RSA

   * DHE-DSS

   * SRP-DSS

   * SRP-RSA

   * SRP

   * PSK

   * DHE-PSK

Available public key algorithms:
   * RSA

   * DSA

Available public key signature algorithms:
   * RSA-SHA1

   * RSA-SHA224

   * RSA-SHA256

   * RSA-SHA384

   * RSA-SHA512

   * RSA-RMD160

   * DSA-SHA1

   * DSA-SHA224

   * DSA-SHA256

   * RSA-MD5

   * RSA-MD2

Available compression methods:
   * DEFLATE

   * NULL

Some additional information regarding some of the algorithms:

`RSA'
     RSA is public key cryptosystem designed by Ronald Rivest, Adi
     Shamir and Leonard Adleman.  It can be used with any hash
     functions.

`DSA'
     DSA is the USA's Digital Signature Standard.  It uses only the
     SHA-1 hash algorithm.

`MD2'
     MD2 is a cryptographic hash algorithm designed by Ron Rivest.  It
     is optimized for 8-bit processors.  Outputs 128 bits of data.
     There are several known weaknesses of this algorithm and it should
     not be used.

`MD5'
     MD5 is a cryptographic hash algorithm designed by Ron Rivest.
     Outputs 128 bits of data.  It is considered to be broken.

`SHA-1'
     SHA is a cryptographic hash algorithm designed by NSA. Outputs 160
     bits of data.  It is also considered to be broken, though no
     practical attacks have been found.

`RMD160'
     RIPEMD is a cryptographic hash algorithm developed in the
     framework of the EU project RIPE.  Outputs 160 bits of data.



File: gnutls.info,  Node: Guile Bindings,  Next: Internal architecture of GnuTLS,  Prev: All the supported ciphersuites in GnuTLS,  Up: Top

11 Guile Bindings
*****************

This chapter describes the GNU Guile
(http://www.gnu.org/software/guile/) Scheme programming interface to
GnuTLS.  The reader is assumed to have basic knowledge of the protocol
and library.  Details missing from this chapter may be found in *note
the C API reference: Function reference.

At this stage, not all the C functions are available from Scheme, but a
large subset thereof is available.

* Menu:

* Guile Preparations::          Note on installation and environment.
* Guile API Conventions::       Naming conventions and other idiosyncrasies.
* Guile Examples::              Quick start.
* Guile Reference::             The Scheme GnuTLS programming interface.


File: gnutls.info,  Node: Guile Preparations,  Next: Guile API Conventions,  Up: Guile Bindings

11.1 Guile Preparations
=======================

The GnuTLS Guile bindings are by default installed under the GnuTLS
installation directory (e.g., typically
`/usr/local/share/guile/site/').  Normally Guile will not find the
module there without help.  You may experience something like this:

     $ guile
     guile> (use-modules (gnutls))
     <unnamed port>: no code for module (gnutls)
     guile>

There are two ways to solve this.  The first is to make sure that when
building GnuTLS, the Guile bindings will be installed in the same place
where Guile looks.  You may do this by using the
`--with-guile-site-dir' parameter as follows:

     $ ./configure --with-guile-site-dir=no

This will instruct GnuTLS to attempt to install the Guile bindings
where Guile will look for them.  It will use `guile-config info
pkgdatadir' to learn the path to use.

If Guile was installed into `/usr', you may also install GnuTLS using
the same prefix:

     $ ./configure --prefix=/usr

If you want to specify the path to install the Guile bindings you can
also specify the path directly:

     $ ./configure --with-guile-site-dir=/opt/guile/share/guile/site

The second solution requires some more work but may be easier to use if
you do not have system administrator rights to your machine.  You need
to instruct Guile so that it finds the GnuTLS Guile bindings.  Either
use the `GUILE_LOAD_PATH' environment variable as follows:

     $ GUILE_LOAD_PATH="/usr/local/share/guile/site:$GUILE_LOAD_PATH" guile
     guile> (use-modules (gnutls))
     guile>

Alternatively, you can modify Guile's `%load-path' variable (*note
Guile's run-time options: (guile)Build Config.).

At this point, you might get an error regarding `libguile-gnutls-v-0'
similar to:

     gnutls.scm:361:1: In procedure dynamic-link in expression (load-extension "libguile-gnutls-v-0" "scm_init_gnutls"):
     gnutls.scm:361:1: file: "libguile-gnutls-v-0", message: "libguile-gnutls-v-0.so: cannot open shared object file: No such file or directory"

In this case, you will need to modify the run-time linker path, for
example as follows:

     $ LD_LIBRARY_PATH=/usr/local/lib GUILE_LOAD_PATH=/usr/local/share/guile/site guile
     guile> (use-modules (gnutls))
     guile>

To check that you got the intended GnuTLS library version, you may
print the version number of the loaded library as follows:

     $ guile
     guile> (use-modules (gnutls))
     guile> (gnutls-version)
     "2.12.7"
     guile>


File: gnutls.info,  Node: Guile API Conventions,  Next: Guile Examples,  Prev: Guile Preparations,  Up: Guile Bindings

11.2 Guile API Conventions
==========================

This chapter details the conventions used by Guile API, as well as
specificities of the mapping of the C API to Scheme.

* Menu:

* Enumerates and Constants::      Representation of C-side constants.
* Procedure Names::               Naming conventions.
* Representation of Binary Data:: Binary data buffers.
* Input and Output::              Input and output.
* Exception Handling::            Exceptions.


File: gnutls.info,  Node: Enumerates and Constants,  Next: Procedure Names,  Up: Guile API Conventions

11.2.1 Enumerates and Constants
-------------------------------

Lots of enumerates and constants are used in the GnuTLS C API.  For
each C enumerate type, a disjoint Scheme type is used--thus, enumerate
values and constants are not represented by Scheme symbols nor by
integers.  This makes it impossible to use an enumerate value of the
wrong type on the Scheme side: such errors are automatically detected
by type-checking.

The enumerate values are bound to variables exported by the `(gnutls)'
and `(gnutls extra)' modules.  These variables are named according to
the following convention:

   * All variable names are lower-case; the underscore `_' character
     used in the C API is replaced by hyphen `-'.

   * All variable names are prepended by the name of the enumerate type
     and the slash `/' character.

   * In some cases, the variable name is made more explicit than the
     one of the C API, e.g., by avoid abbreviations.

Consider for instance this C-side enumerate:

     typedef enum
     {
       GNUTLS_CRD_CERTIFICATE = 1,
       GNUTLS_CRD_ANON,
       GNUTLS_CRD_SRP,
       GNUTLS_CRD_PSK,
       GNUTLS_CRD_IA
     } gnutls_credentials_type_t;

The corresponding Scheme values are bound to the following variables
exported by the `(gnutls)' module:

     credentials/certificate
     credentials/anonymous
     credentials/srp
     credentials/psk
     credentials/ia

Hopefully, most variable names can be deduced from this convention.

Scheme-side "enumerate" values can be compared using `eq?' (*note
equality predicates: (guile)Equality.).  Consider the following example:

     (let ((session (make-session connection-end/client)))

       ;;
       ;; ...
       ;;

       ;; Check the ciphering algorithm currently used by SESSION.
       (if (eq? cipher/arcfour (session-cipher session))
           (format #t "We're using the ARCFOUR algorithm")))

In addition, all enumerate values can be converted to a human-readable
string, in a type-specific way.  For instance, `(cipher->string
cipher/arcfour)' yields `"ARCFOUR 128"', while `(key-usage->string
key-usage/digital-signature)' yields `"digital-signature"'.  Note that
these strings may not be sufficient for use in a user interface since
they are fairly concise and not internationalized.


File: gnutls.info,  Node: Procedure Names,  Next: Representation of Binary Data,  Prev: Enumerates and Constants,  Up: Guile API Conventions

11.2.2 Procedure Names
----------------------

Unlike C functions in GnuTLS, the corresponding Scheme procedures are
named in a way that is close to natural English.  Abbreviations are
also avoided.  For instance, the Scheme procedure corresponding to
`gnutls_certificate_set_dh_params' is named
`set-certificate-credentials-dh-parameters!'.  The `gnutls_' prefix is
always omitted from variable names since a similar effect can be
achieved using Guile's nifty binding renaming facilities, should it be
needed (*note Using Guile Modules: (guile)Using Guile Modules.).

Often Scheme procedure names differ from C function names in a way that
makes it clearer what objects they operate on.  For example, the Scheme
procedure named `set-session-transport-port!' corresponds to
`gnutls_transport_set_ptr', making it clear that this procedure applies
to session.


File: gnutls.info,  Node: Representation of Binary Data,  Next: Input and Output,  Prev: Procedure Names,  Up: Guile API Conventions

11.2.3 Representation of Binary Data
------------------------------------

Many procedures operate on binary data.  For instance,
`pkcs3-import-dh-parameters' expects binary data as input and,
similarly, procedures like `pkcs1-export-rsa-parameters' return binary
data.

Binary data is represented on the Scheme side using SRFI-4 homogeneous
vectors (*note SRFI-4: (guile)SRFI-4.).  Although any type of
homogeneous vector may be used, `u8vector's (i.e., vectors of bytes)
are highly recommended.

As an example, generating and then exporting RSA parameters in the PEM
format can be done as follows:

     (let* ((rsa-params (make-rsa-parameters 1024))
            (raw-data
             (pkcs1-export-rsa-parameters rsa-params
                                          x509-certificate-format/pem)))
       (uniform-vector-write raw-data (open-output-file "some-file.pem")))

For an example of OpenPGP key import from a file, see *note Importing
OpenPGP Keys Guile Example::.


File: gnutls.info,  Node: Input and Output,  Next: Exception Handling,  Prev: Representation of Binary Data,  Up: Guile API Conventions

11.2.4 Input and Output
-----------------------

The underlying transport of a TLS session can be any Scheme
input/output port (*note Ports and File Descriptors: (guile)Ports and
File Descriptors.).  This has to be specified using
`set-session-transport-port!'.

However, for better performance, a raw file descriptor can be
specified, using `set-session-transport-fd!'.  For instance, if the
transport layer is a socket port over an OS-provided socket, you can
use the `port->fdes' or `fileno' procedure to obtain the underlying
file descriptor and pass it to `set-session-transport-fd!'  (*note
`port->fdes' and `fileno': (guile)Ports and File Descriptors.).  This
would work as follows:

     (let ((socket (socket PF_INET SOCK_STREAM 0))
           (session (make-session connection-end/client)))

       ;;
       ;; Establish a TCP connection...
       ;;

       ;; Use the file descriptor that underlies SOCKET.
       (set-session-transport-fd! session (fileno socket)))

Once a TLS session is established, data can be communicated through it
(i.e., _via_ the TLS record layer) using the port returned by
`session-record-port':

     (let ((session (make-session connection-end/client)))

       ;;
       ;; Initialize the various parameters of SESSION, set up
       ;; a network connection, etc...
       ;;

       (let ((i/o (session-record-port session)))
         (write "Hello peer!" i/o)
         (let ((greetings (read i/o)))

           ;; ...

           (bye session close-request/rdwr))))

A lower-level I/O API is provided by `record-send' and
`record-receive!' which take an SRFI-4 vector to represent the data
sent or received.  While it might improve performance, it is much less
convenient than the above and should rarely be needed.


File: gnutls.info,  Node: Exception Handling,  Prev: Input and Output,  Up: Guile API Conventions

11.2.5 Exception Handling
-------------------------

GnuTLS errors are implemented as Scheme exceptions (*note exceptions in
Guile: (guile)Exceptions.).  Each time a GnuTLS function returns an
error, an exception with key `gnutls-error' is raised.  The additional
arguments that are thrown include an error code and the name of the
GnuTLS procedure that raised the exception.  The error code is pretty
much like an enumerate value: it is one of the `error/' variables
exported by the `(gnutls)' module (*note Enumerates and Constants::).
Exceptions can be turned into error messages using the `error->string'
procedure.

The following examples illustrates how GnuTLS exceptions can be handled:

     (let ((session (make-session connection-end/server)))

       ;;
       ;; ...
       ;;

       (catch 'gnutls-error
         (lambda ()
           (handshake session))
         (lambda (key err function . currently-unused)
           (format (current-error-port)
                   "a GnuTLS error was raised by `~a': ~a~%"
                   function (error->string err)))))

Again, error values can be compared using `eq?':

         ;; `gnutls-error' handler.
         (lambda (key err function . currently-unused)
           (if (eq? err error/fatal-alert-received)
               (format (current-error-port)
                       "a fatal alert was caught!~%")
               (format (current-error-port)
                       "something bad happened: ~a~%"
                       (error->string err))))

Note that the `catch' handler is currently passed only 3 arguments but
future versions might provide it with additional arguments.  Thus, it
must be prepared to handle more than 3 arguments, as in this example.


File: gnutls.info,  Node: Guile Examples,  Next: Guile Reference,  Prev: Guile API Conventions,  Up: Guile Bindings

11.3 Guile Examples
===================

This chapter provides examples that illustrate common use cases.

* Menu:

* Anonymous Authentication Guile Example::    Simplest client and server.
* OpenPGP Authentication Guile Example::      Using OpenPGP-based authentication.
* Importing OpenPGP Keys Guile Example::      Importing keys from files.


File: gnutls.info,  Node: Anonymous Authentication Guile Example,  Next: OpenPGP Authentication Guile Example,  Up: Guile Examples

11.3.1 Anonymous Authentication Guile Example
---------------------------------------------

"Anonymous authentication" is very easy to use.  No certificates are
needed by the communicating parties.  Yet, it allows them to benefit
from end-to-end encryption and integrity checks.

The client-side code would look like this (assuming SOME-SOCKET is
bound to an open socket port):

     ;; Client-side.

     (let ((client (make-session connection-end/client)))
       ;; Use the default settings.
       (set-session-default-priority! client)

       ;; Don't use certificate-based authentication.
       (set-session-certificate-type-priority! client '())

       ;; Request the "anonymous Diffie-Hellman" key exchange method.
       (set-session-kx-priority! client (list kx/anon-dh))

       ;; Specify the underlying socket.
       (set-session-transport-fd! client (fileno some-socket))

       ;; Create anonymous credentials.
       (set-session-credentials! client
                                 (make-anonymous-client-credentials))

       ;; Perform the TLS handshake with the server.
       (handshake client)

       ;; Send data over the TLS record layer.
       (write "hello, world!" (session-record-port client))

       ;; Terminate the TLS session.
       (bye client close-request/rdwr))

The corresponding server would look like this (again, assuming
SOME-SOCKET is bound to a socket port):

     ;; Server-side.

     (let ((server (make-session connection-end/server)))
       (set-session-default-priority! server)
       (set-session-certificate-type-priority! server '())
       (set-session-kx-priority! server (list kx/anon-dh))

       ;; Specify the underlying transport socket.
       (set-session-transport-fd! server (fileno some-socket))

       ;; Create anonymous credentials.
       (let ((cred (make-anonymous-server-credentials))
             (dh-params (make-dh-parameters 1024)))
         ;; Note: DH parameter generation can take some time.
         (set-anonymous-server-dh-parameters! cred dh-params)
         (set-session-credentials! server cred))

       ;; Perform the TLS handshake with the client.
       (handshake server)

       ;; Receive data over the TLS record layer.
       (let ((message (read (session-record-port server))))
         (format #t "received the following message: ~a~%"
                 message)

         (bye server close-request/rdwr)))

This is it!


File: gnutls.info,  Node: OpenPGP Authentication Guile Example,  Next: Importing OpenPGP Keys Guile Example,  Prev: Anonymous Authentication Guile Example,  Up: Guile Examples

11.3.2 OpenPGP Authentication Guile Example
-------------------------------------------

GnuTLS allows users to authenticate using OpenPGP certificates.  The
relevant procedures are provided by the `(gnutls extra)' module.  Using
OpenPGP-based authentication is not more complicated than using
anonymous authentication.  It requires a bit of extra work, though, to
import the OpenPGP public and private key of the client/server.  Key
import is omitted here and is left as an exercise to the reader (*note
Importing OpenPGP Keys Guile Example::).

Assuming SOME-SOCKET is bound to an open socket port and PUB and SEC
are bound to the client's OpenPGP public and secret key, respectively,
client-side code would look like this:

     ;; Client-side.

     (define %certs (list certificate-type/openpgp))

     (let ((client (make-session connection-end/client))
           (cred   (make-certificate-credentials)))
       (set-session-default-priority! client)

       ;; Choose OpenPGP certificates.
       (set-session-certificate-type-priority! client %certs)

       ;; Prepare appropriate client credentials.
       (set-certificate-credentials-openpgp-keys! cred pub sec)
       (set-session-credentials! client cred)

       ;; Specify the underlying transport socket.
       (set-session-transport-fd! client (fileno some-socket))

       (handshake client)
       (write "hello, world!" (session-record-port client))
       (bye client close-request/rdwr))

Similarly, server-side code would be along these lines:

     ;; Server-side.

     (define %certs (list certificate-type/openpgp))

     (let ((server (make-session connection-end/server))
           (rsa    (make-rsa-parameters 1024))
           (dh     (make-dh-parameters 1024)))
       (set-session-default-priority! server)

       ;; Choose OpenPGP certificates.
       (set-session-certificate-type-priority! server %certs)

       (let ((cred (make-certificate-credentials)))
         ;; Prepare credentials with RSA and Diffie-Hellman parameters.
         (set-certificate-credentials-dh-parameters! cred dh)
         (set-certificate-credentials-rsa-export-parameters! cred rsa)
         (set-certificate-credentials-openpgp-keys! cred pub sec)
         (set-session-credentials! server cred))

       (set-session-transport-fd! server (fileno some-socket))

       (handshake server)
       (let ((msg (read (session-record-port server))))
         (format #t "received: ~a~%" msg)

         (bye server close-request/rdwr)))

In practice, generating RSA parameters (and Diffie-Hellman parameters)
can time a long time.  Thus, you may want to generate them once and
store them in a file for future re-use (*note
`pkcs1-export-rsa-parameters' and `pkcs1-import-rsa-parameters': Core
Interface.).


File: gnutls.info,  Node: Importing OpenPGP Keys Guile Example,  Prev: OpenPGP Authentication Guile Example,  Up: Guile Examples

11.3.3 Importing OpenPGP Keys Guile Example
-------------------------------------------

The following example provides a simple way of importing
"ASCII-armored" OpenPGP keys from files, using the
`import-openpgp-certificate' and `import-openpgp-private-key'
procedures provided by the `(gnutls extra)' module.

     (use-modules (srfi srfi-4)
                  (gnutls extra))

     (define (import-key-from-file import-proc file)
       ;; Import OpenPGP key from FILE using IMPORT-PROC.

       ;; Prepare a u8vector large enough to hold the raw
       ;; key contents.
       (let* ((size (stat:size (stat path)))
              (raw  (make-u8vector size)))

         ;; Fill in the u8vector with the contents of FILE.
         (uniform-vector-read! raw (open-input-file file))

         ;; Pass the u8vector to the import procedure.
         (import-proc raw openpgp-certificate-format/base64)))


     (define (import-public-key-from-file file)
       (import-key-from-file import-openpgp-certificate file))

     (define (import-private-key-from-file file)
       (import-key-from-file import-openpgp-private-key file))

The procedures `import-public-key-from-file' and
`import-private-key-from-file' can be passed a file name.  They return
an OpenPGP public key and private key object, respectively (*note
OpenPGP key objects: Extra Interface.).


File: gnutls.info,  Node: Guile Reference,  Prev: Guile Examples,  Up: Guile Bindings

11.4 Guile Reference
====================

This chapter documents GnuTLS Scheme procedures available to Guile
programmers.

* Menu:

* Core Interface::              Bindings for core GnuTLS.
* Extra Interface::             Bindings for GnuTLS-Extra.


File: gnutls.info,  Node: Core Interface,  Next: Extra Interface,  Up: Guile Reference

11.4.1 Core Interface
---------------------

This section lists the Scheme procedures exported by the `(gnutls)'
module (*note The Guile module system: (guile)The Guile module
system.).  This module is licenced under the GNU Lesser General Public
Licence, version 2.1 or later.

 -- Scheme Procedure: set-log-level! level
     Enable GnuTLS logging up to LEVEL (an integer).

 -- Scheme Procedure: set-log-procedure! proc
     Use PROC (a two-argument procedure) as the global GnuTLS log
     procedure.

 -- Scheme Procedure: x509-certificate-subject-alternative-name cert
          index
     Return two values: the alternative name type for CERT (i.e., one
     of the `x509-subject-alternative-name/' values) and the actual
     subject alternative name (a string) at INDEX. Both values are `#f'
     if no alternative name is available at INDEX.

 -- Scheme Procedure: x509-certificate-subject-key-id cert
     Return the subject key ID (a u8vector) for CERT.

 -- Scheme Procedure: x509-certificate-authority-key-id cert
     Return the key ID (a u8vector) of the X.509 certificate authority
     of CERT.

 -- Scheme Procedure: x509-certificate-key-id cert
     Return a statistically unique ID (a u8vector) for CERT that
     depends on its public key parameters.  This is normally a 20-byte
     SHA-1 hash.

 -- Scheme Procedure: x509-certificate-version cert
     Return the version of CERT.

 -- Scheme Procedure: x509-certificate-key-usage cert
     Return the key usage of CERT (i.e., a list of `key-usage/'
     values), or the empty list if CERT does not contain such
     information.

 -- Scheme Procedure: x509-certificate-public-key-algorithm cert
     Return two values: the public key algorithm (i.e., one of the
     `pk-algorithm/' values) of CERT and the number of bits used.

 -- Scheme Procedure: x509-certificate-signature-algorithm cert
     Return the signature algorithm used by CERT (i.e., one of the
     `sign-algorithm/' values).

 -- Scheme Procedure: x509-certificate-matches-hostname? cert hostname
     Return true if CERT matches HOSTNAME, a string denoting a DNS host
     name.  This is the basic implementation of RFC 2818
     (http://tools.ietf.org/html/rfc2818) (aka. HTTPS).

 -- Scheme Procedure: x509-certificate-issuer-dn-oid cert index
     Return the OID (a string) at INDEX from CERT's issuer DN.  Return
     `#f' if no OID is available at INDEX.

 -- Scheme Procedure: x509-certificate-dn-oid cert index
     Return OID (a string) at INDEX from CERT.  Return `#f' if no OID
     is available at INDEX.

 -- Scheme Procedure: x509-certificate-issuer-dn cert
     Return the distinguished name (DN) of X.509 certificate CERT.

 -- Scheme Procedure: x509-certificate-dn cert
     Return the distinguished name (DN) of X.509 certificate CERT.  The
     form of the DN is as described in RFC 2253
     (http://tools.ietf.org/html/rfc2253).

 -- Scheme Procedure: pkcs8-import-x509-private-key data format [pass
          [encrypted]]
     Return a new X.509 private key object resulting from the import of
     DATA (a uniform array) according to FORMAT.  Optionally, if PASS
     is not `#f', it should be a string denoting a passphrase.
     ENCRYPTED tells whether the private key is encrypted (`#t' by
     default).

 -- Scheme Procedure: import-x509-private-key data format
     Return a new X.509 private key object resulting from the import of
     DATA (a uniform array) according to FORMAT.

 -- Scheme Procedure: import-x509-certificate data format
     Return a new X.509 certificate object resulting from the import of
     DATA (a uniform array) according to FORMAT.

 -- Scheme Procedure: server-session-psk-username session
     Return the username associated with PSK server session SESSION.

 -- Scheme Procedure: set-psk-client-credentials! cred username key
          key-format
     Set the client credentials for CRED, a PSK client credentials
     object.

 -- Scheme Procedure: make-psk-client-credentials
     Return a new PSK client credentials object.

 -- Scheme Procedure: set-psk-server-credentials-file! cred file
     Use FILE as the password file for PSK server credentials CRED.

 -- Scheme Procedure: make-psk-server-credentials
     Return new PSK server credentials.

 -- Scheme Procedure: peer-certificate-status session
     Verify the peer certificate for SESSION and return a list of
     `certificate-status' values (such as
     `certificate-status/revoked'), or the empty list if the
     certificate is valid.

 -- Scheme Procedure: set-certificate-credentials-verify-flags! cred
          [flags...]
     Set the certificate verification flags to FLAGS, a series of
     `certificate-verify' values.

 -- Scheme Procedure: set-certificate-credentials-verify-limits! cred
          max-bits max-depth
     Set the verification limits of `peer-certificate-status' for
     certificate credentials CRED to MAX_BITS bits for an acceptable
     certificate and MAX_DEPTH as the maximum depth of a certificate
     chain.

 -- Scheme Procedure: set-certificate-credentials-x509-keys! cred certs
          privkey
     Have certificate credentials CRED use the X.509 certificates
     listed in CERTS and X.509 private key PRIVKEY.

 -- Scheme Procedure: set-certificate-credentials-x509-key-data! cred
          cert key format
     Use X.509 certificate CERT and private key KEY, both uniform
     arrays containing the X.509 certificate and key in format FORMAT,
     for certificate credentials CRED.

 -- Scheme Procedure: set-certificate-credentials-x509-crl-data! cred
          data format
     Use DATA (a uniform array) as the X.509 CRL (certificate
     revocation list) database for CRED.  On success, return the number
     of CRLs processed.

 -- Scheme Procedure: set-certificate-credentials-x509-trust-data! cred
          data format
     Use DATA (a uniform array) as the X.509 trust database for CRED.
     On success, return the number of certificates processed.

 -- Scheme Procedure: set-certificate-credentials-x509-crl-file! cred
          file format
     Use FILE as the X.509 CRL (certificate revocation list) file for
     certificate credentials CRED.  On success, return the number of
     CRLs processed.

 -- Scheme Procedure: set-certificate-credentials-x509-trust-file! cred
          file format
     Use FILE as the X.509 trust file for certificate credentials CRED.
     On success, return the number of certificates processed.

 -- Scheme Procedure: set-certificate-credentials-x509-key-files! cred
          cert-file key-file format
     Use FILE as the password file for PSK server credentials CRED.

 -- Scheme Procedure:
          set-certificate-credentials-rsa-export-parameters! cred
          rsa-params
     Use RSA parameters RSA_PARAMS for certificate credentials CRED.

 -- Scheme Procedure: set-certificate-credentials-dh-parameters! cred
          dh-params
     Use Diffie-Hellman parameters DH_PARAMS for certificate
     credentials CRED.

 -- Scheme Procedure: make-certificate-credentials
     Return new certificate credentials (i.e., for use with either
     X.509 or OpenPGP certificates.

 -- Scheme Procedure: pkcs1-export-rsa-parameters rsa-params format
     Export Diffie-Hellman parameters RSA_PARAMS in PKCS1 format
     according for FORMAT (an `x509-certificate-format' value).  Return
     a `u8vector' containing the result.

 -- Scheme Procedure: pkcs1-import-rsa-parameters array format
     Import Diffie-Hellman parameters in PKCS1 format (further
     specified by FORMAT, an `x509-certificate-format' value) from
     ARRAY (a homogeneous array) and return a new `rsa-params' object.

 -- Scheme Procedure: make-rsa-parameters bits
     Return new RSA parameters.

 -- Scheme Procedure: set-anonymous-server-dh-parameters! cred dh-params
     Set the Diffie-Hellman parameters of anonymous server credentials
     CRED.

 -- Scheme Procedure: make-anonymous-client-credentials
     Return anonymous client credentials.

 -- Scheme Procedure: make-anonymous-server-credentials
     Return anonymous server credentials.

 -- Scheme Procedure: set-session-dh-prime-bits! session bits
     Use BITS DH prime bits for SESSION.

 -- Scheme Procedure: pkcs3-export-dh-parameters dh-params format
     Export Diffie-Hellman parameters DH_PARAMS in PKCS3 format
     according for FORMAT (an `x509-certificate-format' value).  Return
     a `u8vector' containing the result.

 -- Scheme Procedure: pkcs3-import-dh-parameters array format
     Import Diffie-Hellman parameters in PKCS3 format (further
     specified by FORMAT, an `x509-certificate-format' value) from
     ARRAY (a homogeneous array) and return a new `dh-params' object.

 -- Scheme Procedure: make-dh-parameters bits
     Return new Diffie-Hellman parameters.

 -- Scheme Procedure: set-session-transport-port! session port
     Use PORT as the input/output port for SESSION.

 -- Scheme Procedure: set-session-transport-fd! session fd
     Use file descriptor FD as the underlying transport for SESSION.

 -- Scheme Procedure: session-record-port session
     Return a read-write port that may be used to communicate over
     SESSION.  All invocations of `session-port' on a given session
     return the same object (in the sense of `eq?').

 -- Scheme Procedure: record-receive! session array
     Receive data from SESSION into ARRAY, a uniform homogeneous array.
     Return the number of bytes actually received.

 -- Scheme Procedure: record-send session array
     Send the record constituted by ARRAY through SESSION.

 -- Scheme Procedure: set-session-credentials! session cred
     Use CRED as SESSION's credentials.

 -- Scheme Procedure: cipher-suite->string kx cipher mac
     Return the name of the given cipher suite.

 -- Scheme Procedure: set-session-default-export-priority! session
     Have SESSION use the default export priorities.

 -- Scheme Procedure: set-session-default-priority! session
     Have SESSION use the default priorities.

 -- Scheme Procedure: set-session-certificate-type-priority! session
          items
     Use ITEMS (a list) as the list of preferred certificate-type for
     SESSION.

 -- Scheme Procedure: set-session-protocol-priority! session items
     Use ITEMS (a list) as the list of preferred protocol for SESSION.

 -- Scheme Procedure: set-session-kx-priority! session items
     Use ITEMS (a list) as the list of preferred kx for SESSION.

 -- Scheme Procedure: set-session-compression-method-priority! session
          items
     Use ITEMS (a list) as the list of preferred compression-method for
     SESSION.

 -- Scheme Procedure: set-session-mac-priority! session items
     Use ITEMS (a list) as the list of preferred mac for SESSION.

 -- Scheme Procedure: set-session-cipher-priority! session items
     Use ITEMS (a list) as the list of preferred cipher for SESSION.

 -- Scheme Procedure: set-server-session-certificate-request! session
          request
     Tell how SESSION, a server-side session, should deal with
     certificate requests.  REQUEST should be either
     `certificate-request/request' or `certificate-request/require'.

 -- Scheme Procedure: session-our-certificate-chain session
     Return our certificate chain for SESSION (as sent to the peer) in
     raw format (a u8vector).  In the case of OpenPGP there is exactly
     one certificate.  Return the empty list if no certificate was used.

 -- Scheme Procedure: session-peer-certificate-chain session
     Return the a list of certificates in raw format (u8vectors) where
     the first one is the peer's certificate.  In the case of OpenPGP,
     there is always exactly one certificate.  In the case of X.509,
     subsequent certificates indicate form a certificate chain.  Return
     the empty list if no certificate was sent.

 -- Scheme Procedure: session-client-authentication-type session
     Return the client authentication type (a `credential-type' value)
     used in SESSION.

 -- Scheme Procedure: session-server-authentication-type session
     Return the server authentication type (a `credential-type' value)
     used in SESSION.

 -- Scheme Procedure: session-authentication-type session
     Return the authentication type (a `credential-type' value) used by
     SESSION.

 -- Scheme Procedure: session-protocol session
     Return the protocol used by SESSION.

 -- Scheme Procedure: session-certificate-type session
     Return SESSION's certificate type.

 -- Scheme Procedure: session-compression-method session
     Return SESSION's compression method.

 -- Scheme Procedure: session-mac session
     Return SESSION's MAC.

 -- Scheme Procedure: session-kx session
     Return SESSION's kx.

 -- Scheme Procedure: session-cipher session
     Return SESSION's cipher.

 -- Scheme Procedure: alert-send session level alert
     Send ALERT via SESSION.

 -- Scheme Procedure: alert-get session
     Get an aleter from SESSION.

 -- Scheme Procedure: rehandshake session
     Perform a re-handshaking for SESSION.

 -- Scheme Procedure: handshake session
     Perform a handshake for SESSION.

 -- Scheme Procedure: bye session how
     Close SESSION according to HOW.

 -- Scheme Procedure: make-session end
     Return a new session for connection end END, either
     `connection-end/server' or `connection-end/client'.

 -- Scheme Procedure: gnutls-version
     Return a string denoting the version number of the underlying
     GnuTLS library, e.g., `"1.7.2"'.

 -- Scheme Procedure: x509-private-key? obj
     Return true if OBJ is of type `x509-private-key'.

 -- Scheme Procedure: x509-certificate? obj
     Return true if OBJ is of type `x509-certificate'.

 -- Scheme Procedure: psk-client-credentials? obj
     Return true if OBJ is of type `psk-client-credentials'.

 -- Scheme Procedure: psk-server-credentials? obj
     Return true if OBJ is of type `psk-server-credentials'.

 -- Scheme Procedure: srp-client-credentials? obj
     Return true if OBJ is of type `srp-client-credentials'.

 -- Scheme Procedure: srp-server-credentials? obj
     Return true if OBJ is of type `srp-server-credentials'.

 -- Scheme Procedure: certificate-credentials? obj
     Return true if OBJ is of type `certificate-credentials'.

 -- Scheme Procedure: rsa-parameters? obj
     Return true if OBJ is of type `rsa-parameters'.

 -- Scheme Procedure: dh-parameters? obj
     Return true if OBJ is of type `dh-parameters'.

 -- Scheme Procedure: anonymous-server-credentials? obj
     Return true if OBJ is of type `anonymous-server-credentials'.

 -- Scheme Procedure: anonymous-client-credentials? obj
     Return true if OBJ is of type `anonymous-client-credentials'.

 -- Scheme Procedure: session? obj
     Return true if OBJ is of type `session'.

 -- Scheme Procedure: error->string enumval
     Return a string describing ENUMVAL, a `error' value.

 -- Scheme Procedure: certificate-verify->string enumval
     Return a string describing ENUMVAL, a `certificate-verify' value.

 -- Scheme Procedure: key-usage->string enumval
     Return a string describing ENUMVAL, a `key-usage' value.

 -- Scheme Procedure: psk-key-format->string enumval
     Return a string describing ENUMVAL, a `psk-key-format' value.

 -- Scheme Procedure: sign-algorithm->string enumval
     Return a string describing ENUMVAL, a `sign-algorithm' value.

 -- Scheme Procedure: pk-algorithm->string enumval
     Return a string describing ENUMVAL, a `pk-algorithm' value.

 -- Scheme Procedure: x509-subject-alternative-name->string enumval
     Return a string describing ENUMVAL, a
     `x509-subject-alternative-name' value.

 -- Scheme Procedure: x509-certificate-format->string enumval
     Return a string describing ENUMVAL, a `x509-certificate-format'
     value.

 -- Scheme Procedure: certificate-type->string enumval
     Return a string describing ENUMVAL, a `certificate-type' value.

 -- Scheme Procedure: protocol->string enumval
     Return a string describing ENUMVAL, a `protocol' value.

 -- Scheme Procedure: close-request->string enumval
     Return a string describing ENUMVAL, a `close-request' value.

 -- Scheme Procedure: certificate-request->string enumval
     Return a string describing ENUMVAL, a `certificate-request' value.

 -- Scheme Procedure: certificate-status->string enumval
     Return a string describing ENUMVAL, a `certificate-status' value.

 -- Scheme Procedure: handshake-description->string enumval
     Return a string describing ENUMVAL, a `handshake-description'
     value.

 -- Scheme Procedure: alert-description->string enumval
     Return a string describing ENUMVAL, a `alert-description' value.

 -- Scheme Procedure: alert-level->string enumval
     Return a string describing ENUMVAL, a `alert-level' value.

 -- Scheme Procedure: connection-end->string enumval
     Return a string describing ENUMVAL, a `connection-end' value.

 -- Scheme Procedure: compression-method->string enumval
     Return a string describing ENUMVAL, a `compression-method' value.

 -- Scheme Procedure: digest->string enumval
     Return a string describing ENUMVAL, a `digest' value.

 -- Scheme Procedure: mac->string enumval
     Return a string describing ENUMVAL, a `mac' value.

 -- Scheme Procedure: credentials->string enumval
     Return a string describing ENUMVAL, a `credentials' value.

 -- Scheme Procedure: params->string enumval
     Return a string describing ENUMVAL, a `params' value.

 -- Scheme Procedure: kx->string enumval
     Return a string describing ENUMVAL, a `kx' value.

 -- Scheme Procedure: cipher->string enumval
     Return a string describing ENUMVAL, a `cipher' value.


File: gnutls.info,  Node: Extra Interface,  Prev: Core Interface,  Up: Guile Reference

11.4.2 Extra Interface
----------------------

This section lists the Scheme procedures exported by the `(gnutls
extra)' module.  This module is licenced under the GNU General Public
Licence, version 3 or later.

 -- Scheme Procedure: set-certificate-credentials-openpgp-keys! cred
          pub sec
     Use certificate PUB and secret key SEC in certificate credentials
     CRED.

 -- Scheme Procedure: openpgp-keyring-contains-key-id? keyring id
     Return `#f' if key ID ID is in KEYRING, `#f' otherwise.

 -- Scheme Procedure: import-openpgp-keyring data format
     Import DATA (a u8vector) according to FORMAT and return the
     imported keyring.

 -- Scheme Procedure: openpgp-certificate-usage key
     Return a list of values denoting the key usage of KEY.

 -- Scheme Procedure: openpgp-certificate-version key
     Return the version of the OpenPGP message format (RFC2440) honored
     by KEY.

 -- Scheme Procedure: openpgp-certificate-algorithm key
     Return two values: the certificate algorithm used by KEY and the
     number of bits used.

 -- Scheme Procedure: openpgp-certificate-names key
     Return the list of names for KEY.

 -- Scheme Procedure: openpgp-certificate-name key index
     Return the INDEXth name of KEY.

 -- Scheme Procedure: openpgp-certificate-fingerprint key
     Return a new u8vector denoting the fingerprint of KEY.

 -- Scheme Procedure: openpgp-certificate-fingerprint! key fpr
     Store in FPR (a u8vector) the fingerprint of KEY.  Return the
     number of bytes stored in FPR.

 -- Scheme Procedure: openpgp-certificate-id! key id
     Store the ID (an 8 byte sequence) of certificate KEY in ID (a
     u8vector).

 -- Scheme Procedure: openpgp-certificate-id key
     Return the ID (an 8-element u8vector) of certificate KEY.

 -- Scheme Procedure: import-openpgp-private-key data format [pass]
     Return a new OpenPGP private key object resulting from the import
     of DATA (a uniform array) according to FORMAT.  Optionally, a
     passphrase may be provided.

 -- Scheme Procedure: import-openpgp-certificate data format
     Return a new OpenPGP certificate object resulting from the import
     of DATA (a uniform array) according to FORMAT.

 -- Scheme Procedure: openpgp-certificate-format->string enumval
     Return a string describing ENUMVAL, a `openpgp-certificate-format'
     value.

 -- Scheme Procedure: openpgp-keyring? obj
     Return true if OBJ is of type `openpgp-keyring'.

 -- Scheme Procedure: openpgp-private-key? obj
     Return true if OBJ is of type `openpgp-private-key'.

 -- Scheme Procedure: openpgp-certificate? obj
     Return true if OBJ is of type `openpgp-certificate'.


File: gnutls.info,  Node: Internal architecture of GnuTLS,  Next: Copying Information,  Prev: Guile Bindings,  Up: Top

12 Internal Architecture of GnuTLS
**********************************

This chapter is to give a brief description of the way GnuTLS works.
The focus is to give an idea to potential developers and those who want
to know what happens inside the black box.

* Menu:

* The TLS Protocol::
* TLS Handshake Protocol::
* TLS Authentication Methods::
* TLS Extension Handling::
* Certificate Handling::
* Cryptographic Backend::


File: gnutls.info,  Node: The TLS Protocol,  Next: TLS Handshake Protocol,  Up: Internal architecture of GnuTLS

12.1 The TLS Protocol
=====================

The main needs for the TLS protocol to be used are shown in the image
below.

 [image src="gnutls-client-server-use-case.png" ]

This is being accomplished by the following object diagram.  Note that
since GnuTLS is being developed in C object are just structures with
attributes. The operations listed are functions that require the first
parameter to be that object.   [image src="gnutls-objects.png" ]


File: gnutls.info,  Node: TLS Handshake Protocol,  Next: TLS Authentication Methods,  Prev: The TLS Protocol,  Up: Internal architecture of GnuTLS

12.2 TLS Handshake Protocol
===========================

The GnuTLS handshake protocol is implemented as a state machine that
waits for input or returns immediately when the non-blocking transport
layer functions are used. The main idea is shown in the following
figure.

 [image src="gnutls-handshake-state.png" ]

Also the way the input is processed varies per ciphersuite. Several
implementations of the internal handlers are available and *note
gnutls_handshake:: only multiplexes the input to the appropriate
handler. For example a PSK ciphersuite has a different implementation
of the `process_client_key_exchange' than a certificate ciphersuite.

 [image src="gnutls-handshake-sequence.png" ]


File: gnutls.info,  Node: TLS Authentication Methods,  Next: TLS Extension Handling,  Prev: TLS Handshake Protocol,  Up: Internal architecture of GnuTLS

12.3 TLS Authentication Methods
===============================

In GnuTLS authentication methods can be implemented quite easily.
Since the required changes to add a new authentication method affect
only the handshake protocol, a simple interface is used. An
authentication method needs only to implement the functions as seen in
the figure below.

 [image src="gnutls-mod_auth_st.png" ]

The functions that need to be implemented are the ones responsible for
interpreting the handshake protocol messages. It is common for such
functions to read data from one or more `credentials_t' structures(1)
and write data, such as certificates, usernames etc. to `auth_info_t'
structures.

Simple examples of existing authentication methods can be seen in
`auth_psk.c' for PSK ciphersuites and `auth_srp.c' for SRP
ciphersuites. After implementing these functions the structure holding
its pointers has to be registered in `gnutls_algorithms.c' in the
`_gnutls_kx_algorithms' structure.

---------- Footnotes ----------

(1) such as the `gnutls_certificate_credentials_t' structures


File: gnutls.info,  Node: TLS Extension Handling,  Next: Certificate Handling,  Prev: TLS Authentication Methods,  Up: Internal architecture of GnuTLS

12.4 TLS Extension Handling
===========================

As with authentication methods, the TLS extensions handlers can be
implemented using the following interface.

 [image src="gnutls-extensions_st.png" ]

Here there are two functions, one for receiving the extension data and
one for sending. These functions have to check internally whether they
operate in client or server side.

A simple example of an extension handler can be seen in `ext_srp.c'
After implementing these functions, together with the extension number
they handle, they have to be registered in `gnutls_extensions.c' in the
`_gnutls_extensions' structure.

12.4.1 Adding a New TLS Extension
---------------------------------

Adding support for a new TLS extension is done from time to time, and
the process to do so is not difficult.  Here are the steps you need to
follow if you wish to do this yourself.  For sake of discussion, let's
consider adding support for the hypothetical TLS extension `foobar'.

  1. Add `configure' option like `--enable-foobar' or
     `--disable-foobar'.

     This step is useful when the extension code is large and it might
     be desirable to disable the extension under some circumstances.
     Otherwise it can be safely skipped.

     Whether to chose enable or disable depends on whether you intend
     to make the extension be enabled by default.  Look at existing
     checks (i.e., SRP, authz) for how to model the code.  For example:

          AC_MSG_CHECKING([whether to disable foobar support])
          AC_ARG_ENABLE(foobar,
          	AS_HELP_STRING([--disable-foobar],
          		[disable foobar support]),
          	ac_enable_foobar=no)
          if test x$ac_enable_foobar != xno; then
           AC_MSG_RESULT(no)
           AC_DEFINE(ENABLE_FOOBAR, 1, [enable foobar])
          else
           ac_full=0
           AC_MSG_RESULT(yes)
          fi
          AM_CONDITIONAL(ENABLE_FOOBAR, test "$ac_enable_foobar" != "no")

     These lines should go in `lib/m4/hooks.m4'.

  2. Add IANA extension value to `extensions_t' in `gnutls_int.h'.

     A good name for the value would be GNUTLS_EXTENSION_FOOBAR.  Check
     with `http://www.iana.org/assignments/tls-extensiontype-values'
     for allocated values.  For experiments, you could pick a number but
     remember that some consider it a bad idea to deploy such modified
     version since it will lead to interoperability problems in the
     future when the IANA allocates that number to someone else, or
     when the foobar protocol is allocated another number.

  3. Add an entry to `_gnutls_extensions' in `gnutls_extensions.c'.

     A typical entry would be:

            int ret;

            /* ...
             */

          #if ENABLE_FOOBAR

            ret = _gnutls_ext_register (&foobar_ext);
            if (ret != GNUTLS_E_SUCCESS)
              return ret;
          #endif

     Most likely you'll need to add an `#include "ext_foobar.h"', that
     will contain something like like:
            extension_entry_st foobar_ext = {
              .name = "FOOBAR",
              .type = GNUTLS_EXTENSION_FOOBAR,
              .parse_type = GNUTLS_EXT_TLS,
              .recv_func = _foobar_recv_params,
              .send_func = _foobar_send_params,
              .pack_func = _foobar_pack,
              .unpack_func = _foobar_unpack,
              .deinit_func = NULL
            }

     The GNUTLS_EXTENSION_FOOBAR is the integer value you added to
     `gnutls_int.h' earlier.  In this structure you specify the
     functions to read the extension from the hello message, the
     function to send the reply to, and two more functions to pack and
     unpack from stored session data (e.g. when resumming a session).
     The `deinit' function will be called to deinitialize the
     extension's private parameters, if any.

     Note that the conditional `ENABLE_FOOBAR' definition should only be
     used if step 1 with the `configure' options has taken place.

  4. Add new files `ext_foobar.c' and `ext_foobar.h' that implement the
     extension.

     The functions you are responsible to add are those mentioned in the
     previous step.  As a starter, you could add this:

          int
          _foobar_recv_params (gnutls_session_t session,
                                      const opaque * data,
                                      size_t data_size)
          {
            return 0;
          }

          int
          _foobar_send_params (gnutls_session_t session,
                                      opaque * data,
                                      size_t _data_size)
          {
            return 0;
          }

          int
          _foobar_pack (extension_priv_data_t epriv, gnutls_buffer_st * ps)
          {
             /* Append the extension's internal state to buffer */
             return 0;
          }

          int
          _foobar_unpack (gnutls_buffer_st * ps, extension_priv_data_t * epriv)
          {
             /* Read the internal state from buffer */
             return 0;
          }

     The `_foobar_recv_params' function is responsible for parsing
     incoming extension data (both in the client and server).

     The `_foobar_send_params' function is responsible for sending
     extension data (both in the client and server).

     The `_foobar_pack' function is responsible for packing internal
     extension data to save them in the session storage.

     The `_foobar_unpack' function is responsible for restoring session
     data from the session storage.

     If you receive length fields that doesn't match, return
     `GNUTLS_E_UNEXPECTED_PACKET_LENGTH'.  If you receive invalid data,
     return `GNUTLS_E_RECEIVED_ILLEGAL_PARAMETER'.  You can use other
     error codes too.  Return 0 on success.

     The function could store some information in the `session'
     variable for later usage. That can be done using the functions
     `_gnutls_ext_set_session_data' and `_gnutls_ext_get_session_data'.
     You can check simple examples at `ext_max_record.c' and
     `ext_server_name.c' extensions.

     Recall that both the client and server both send and receives
     parameters, and your code most likely will need to do different
     things depending on which mode it is in.  It may be useful to make
     this distinction explicit in the code.  Thus, for example, a better
     template than above would be:

          int
          _gnutls_foobar_recv_params (gnutls_session_t session,
                                      const opaque * data,
                                      size_t data_size)
          {
            if (session->security_parameters.entity == GNUTLS_CLIENT)
              return foobar_recv_client (session, data, data_size);
            else
              return foobar_recv_server (session, data, data_size);
          }

          int
          _gnutls_foobar_send_params (gnutls_session_t session,
                                      opaque * data,
                                      size_t data_size)
          {
            if (session->security_parameters.entity == GNUTLS_CLIENT)
              return foobar_send_client (session, data, data_size);
            else
              return foobar_send_server (session, data, data_size);
          }

     The functions used would be declared as `static' functions, of the
     appropriate prototype, in the same file.

     When adding the files, you'll need to add them to `Makefile.am' as
     well, for example:

          if ENABLE_FOOBAR
          COBJECTS += ext_foobar.c
          HFILES += ext_foobar.h
          endif

  5. Add API functions to enable/disable the extension.

     Normally the client will have one API to request use of the
     extension, and setting some extension specific data.  The server
     will have one API to let the library know that it is willing to
     accept the extension, often this is implemented through a callback
     but it doesn't have to.

     The APIs need to be added to `includes/gnutls/gnutls.h' or
     `includes/gnutls/extra.h' as appropriate.  It is recommended that
     if you don't have a requirement to use the LGPLv2.1+ license for
     your extension, that you place your work under the GPLv3+ license
     and thus in the libgnutls-extra library.

     You can implement the API function in the `ext_foobar.c' file, or
     if that file ends up becoming rather larger, add a
     `gnutls_foobar.c' file.

     To make the API available in the shared library you need to add the
     symbol in `lib/libgnutls.map' or `libextra/libgnutls-extra.map' as
     appropriate, so that the symbol is exported properly.

     When writing GTK-DOC style documentation for your new APIs, don't
     forget to add `Since:' tags to indicate the GnuTLS version the API
     was introduced in.



File: gnutls.info,  Node: Certificate Handling,  Next: Cryptographic Backend,  Prev: TLS Extension Handling,  Up: Internal architecture of GnuTLS

12.5 Certificate Handling
=========================

What is provided by the certificate handling functions is summarized in
the following diagram.

 [image src="gnutls-certificate-user-use-case.png" ]


File: gnutls.info,  Node: Cryptographic Backend,  Prev: Certificate Handling,  Up: Internal architecture of GnuTLS

12.6 Cryptographic Backend
==========================

Today most new processors, either for embedded or desktop systems
include either instructions  intended to speed up cryptographic
operations, or a co-processor with cryptographic capabilities. Taking
advantage of those is a challenging task for every cryptographic
application or library. Unfortunately the cryptographic libraries that
GnuTLS is based on take no advantage of these properties. For this
reason GnuTLS handles this internally by following a layered approach
to accessing cryptographic operations as in the following figure.

 [image src="gnutls-crypto-layers.png" ]

The TLS layer uses a cryptographic provider layer, that will in turn
either use the default crypto provider - a crypto library, or use an
external crypto provider, if available.

12.6.1 Cryptographic Library layer
----------------------------------

The Cryptographic Library layer, can  currently be used either with
libgcrypt or libnettle, each of one has its advantages and some
disadvantages. Libgcrypt is a self-contained library, pretty broad in
scope that supports many algorithms. In some processors like VIA, it
will also use the available crypto instruction set hence providing
performance benefit comparing to plain software implementation.
Libnettle provides only software implementation of the basic algorithms
required in TLS, and is on average 30% faster that libgcrypt on almost
all algorithms. For this reason libnettle is library used by default in
GnuTLS.

12.6.2 External cryptography provider
-------------------------------------

Systems that include a cryptographic co-processor, typically come with
kernel drivers to utilize the operations from software. For this reason
GnuTLS provides a layer where each individual algorithm used can be
replaced by another implementation, i.e. the one provided by the
driver. The FreeBSD, OpenBSD and Linux kernels(1) include already a
number of hardware assisted implementations, and also provide an
interface to access them, called `/dev/crypto'.  GnuTLS will take
advantage of this interface if compiled with special options. That is
because in most systems where hardware-assisted cryptographic
operations are not available, using this interface might actually
reduce performance.

It is possible to override parts of crypto backend both at runtime and
compile time. Here we discuss the runtime possibility. The API
available for this functionality is in `gnutls/crypto.h' header file.

12.6.2.1 Override specific algorithms
.....................................

When an optimized implementation of a single algorithm is available,
say a hardware assisted version of AES-CBC then the following functions
can be used to register those algorithms.

   * *note gnutls_crypto_single_cipher_register2:: To register a cipher
     algorithm.

     *note gnutls_crypto_single_digest_register2:: To register a hash
     (digest) or MAC algorithm.


Those registration functions will only replace the specified algorithm
and leave the rest of subsystem intact.

12.6.2.2 Override parts of the backend
......................................

In some systems, such as embedded ones, it might be desirable to
override big parts of the cryptographic backend, or even all of them.
For this reason the following functions are provided.

   * *note gnutls_crypto_cipher_register2:: To override the
     cryptographic algorithms backend.

   * *note gnutls_crypto_digest_register2:: To override the digest
     algorithms backend.

   * *note gnutls_crypto_rnd_register2:: To override the random number
     generator backend.

   * *note gnutls_crypto_bigint_register2:: To override the big number
     number operations backend.

   * *note gnutls_crypto_pk_register2:: To override the public key
     encryption backend. This is tight to the big number operations so
     either both of them should be updated or care must be taken to use
     the same format.


If all of them are used then GnuTLS will no longer use libgcrypt.

---------- Footnotes ----------

(1) Check `http://home.gna.org/cryptodev-linux/' for the Linux kernel
implementation of `/dev/crypto'.


File: gnutls.info,  Node: Copying Information,  Next: Concept Index,  Prev: Internal architecture of GnuTLS,  Up: Top

Appendix A Copying Information
******************************

* Menu:

* GNU Free Documentation License::   License for copying this manual.
* GNU LGPL::                     License for copying the core GnuTLS library.
* GNU GPL::                      License for copying GnuTLS-extra and tools.

