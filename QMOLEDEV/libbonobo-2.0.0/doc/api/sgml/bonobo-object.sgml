<refentry id="libbonobo-bonobo-object">
<refmeta>
<refentrytitle>BonoboObject</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>LIBBONOBO Library</refmiscinfo>
</refmeta>

<refnamediv>
<refname>BonoboObject</refname><refpurpose>Base object for wrapping Bonobo::Unknown derived objects.</refpurpose>
</refnamediv>

<refsynopsisdiv><title>Synopsis</title>
<synopsis>



#define     <link linkend="BONOBO-OBJECT-TYPE-CAPS">BONOBO_OBJECT_TYPE</link>
#define     <link linkend="BONOBO-OBJREF-CAPS">BONOBO_OBJREF</link>                   (o)
void        (<link linkend="BonoboObjectPOAFn">*BonoboObjectPOAFn</link>)            (<link linkend="PortableServer-Servant">PortableServer_Servant</link> servant,
                                             <link linkend="CORBA-Environment">CORBA_Environment</link> *ev);
struct      <link linkend="BonoboObjectPrivate">BonoboObjectPrivate</link>;
typedef     <link linkend="BonoboObjectHeader">BonoboObjectHeader</link>;
#define     <link linkend="BONOBO-OBJECT-HEADER-SIZE-CAPS">BONOBO_OBJECT_HEADER_SIZE</link>
#define     <link linkend="BONOBO-OBJECT-SIGNATURE-CAPS">BONOBO_OBJECT_SIGNATURE</link>
#define     <link linkend="BONOBO-SERVANT-SIGNATURE-CAPS">BONOBO_SERVANT_SIGNATURE</link>
typedef     <link linkend="BonoboObject">BonoboObject</link>;
typedef     <link linkend="BonoboObjectClass">BonoboObjectClass</link>;
void        <link linkend="bonobo-object-add-interface">bonobo_object_add_interface</link>     (<link linkend="BonoboObject">BonoboObject</link> *object,
                                             <link linkend="BonoboObject">BonoboObject</link> *newobj);
<link linkend="BonoboObject">BonoboObject</link>* <link linkend="bonobo-object-query-local-interface">bonobo_object_query_local_interface</link>
                                            (<link linkend="BonoboObject">BonoboObject</link> *object,
                                             const char *repo_id);
<link linkend="Bonobo-Unknown">Bonobo_Unknown</link> <link linkend="bonobo-object-query-interface">bonobo_object_query_interface</link>
                                            (<link linkend="BonoboObject">BonoboObject</link> *object,
                                             const char *repo_id,
                                             <link linkend="CORBA-Environment">CORBA_Environment</link> *opt_ev);
<link linkend="Bonobo-Unknown">Bonobo_Unknown</link> <link linkend="bonobo-object-corba-objref">bonobo_object_corba_objref</link>   (<link linkend="BonoboObject">BonoboObject</link> *object);
<link linkend="Bonobo-Unknown">Bonobo_Unknown</link> <link linkend="bonobo-object-dup-ref">bonobo_object_dup_ref</link>        (<link linkend="Bonobo-Unknown">Bonobo_Unknown</link> object,
                                             <link linkend="CORBA-Environment">CORBA_Environment</link> *opt_ev);
<link linkend="Bonobo-Unknown">Bonobo_Unknown</link> <link linkend="bonobo-object-release-unref">bonobo_object_release_unref</link>  (<link linkend="Bonobo-Unknown">Bonobo_Unknown</link> object,
                                             <link linkend="CORBA-Environment">CORBA_Environment</link> *opt_ev);
<link linkend="gpointer">gpointer</link>    <link linkend="bonobo-object-ref">bonobo_object_ref</link>               (<link linkend="gpointer">gpointer</link> obj);
void        <link linkend="bonobo-object-idle-unref">bonobo_object_idle_unref</link>        (<link linkend="gpointer">gpointer</link> obj);
<link linkend="gpointer">gpointer</link>    <link linkend="bonobo-object-unref">bonobo_object_unref</link>             (<link linkend="gpointer">gpointer</link> obj);
void        <link linkend="bonobo-object-set-immortal">bonobo_object_set_immortal</link>      (<link linkend="BonoboObject">BonoboObject</link> *object,
                                             <link linkend="gboolean">gboolean</link> immortal);
<link linkend="gpointer">gpointer</link>    <link linkend="bonobo-object-trace-refs">bonobo_object_trace_refs</link>        (<link linkend="gpointer">gpointer</link> obj,
                                             const char *fn,
                                             int line,
                                             <link linkend="gboolean">gboolean</link> ref);
void        <link linkend="bonobo-object-dump-interfaces">bonobo_object_dump_interfaces</link>   (<link linkend="BonoboObject">BonoboObject</link> *object);
void        <link linkend="bonobo-object-check-env">bonobo_object_check_env</link>         (<link linkend="BonoboObject">BonoboObject</link> *object,
                                             <link linkend="CORBA-Object">CORBA_Object</link> corba_object,
                                             <link linkend="CORBA-Environment">CORBA_Environment</link> *ev);
#define     <link linkend="BONOBO-OBJECT-CHECK-CAPS">BONOBO_OBJECT_CHECK</link>             (o,c,e)
<link linkend="gboolean">gboolean</link>    <link linkend="bonobo-unknown-ping">bonobo_unknown_ping</link>             (<link linkend="Bonobo-Unknown">Bonobo_Unknown</link> object,
                                             <link linkend="CORBA-Environment">CORBA_Environment</link> *opt_ev);
void        <link linkend="bonobo-object-list-unref-all">bonobo_object_list_unref_all</link>    (<link linkend="GList">GList</link> **list);
void        <link linkend="bonobo-object-slist-unref-all">bonobo_object_slist_unref_all</link>   (<link linkend="GSList">GSList</link> **list);
<link linkend="BonoboObject">BonoboObject</link>* <link linkend="bonobo-object">bonobo_object</link>                 (<link linkend="gpointer">gpointer</link> p);
#define     <link linkend="bonobo-object-fast">bonobo_object_fast</link>              (o)
#define     <link linkend="bonobo-object-from-servant">bonobo_object_from_servant</link>      (s)
#define     <link linkend="bonobo-object-get-servant">bonobo_object_get_servant</link>       (o)
<link linkend="GType">GType</link>       <link linkend="bonobo-type-unique">bonobo_type_unique</link>              (<link linkend="GType">GType</link> parent_type,
                                             <link linkend="BonoboObjectPOAFn">BonoboObjectPOAFn</link> init_fn,
                                             <link linkend="BonoboObjectPOAFn">BonoboObjectPOAFn</link> fini_fn,
                                             int epv_struct_offset,
                                             const <link linkend="GTypeInfo">GTypeInfo</link> *info,
                                             const <link linkend="gchar">gchar</link> *type_name);
<link linkend="gboolean">gboolean</link>    <link linkend="bonobo-type-setup">bonobo_type_setup</link>               (<link linkend="GType">GType</link> type,
                                             <link linkend="BonoboObjectPOAFn">BonoboObjectPOAFn</link> init_fn,
                                             <link linkend="BonoboObjectPOAFn">BonoboObjectPOAFn</link> fini_fn,
                                             int epv_struct_offset);
#define     <link linkend="BONOBO-TYPE-FUNC-FULL-CAPS">BONOBO_TYPE_FUNC_FULL</link>           (class_name, corba_name, parent, prefix)
#define     <link linkend="BONOBO-TYPE-FUNC-CAPS">BONOBO_TYPE_FUNC</link>                (class_name, parent, prefix)

</synopsis>
</refsynopsisdiv>





<refsect1>
<title>Description</title>

<para>
  BonoboObject provides an easy to use way of writing CORBA servers. It
  drastically simplifies the issues of epv and vepv construction by
  automating these, and automatically instantiates a CORBA_Object on
  g_object_new. This removes clutter from construction time. For
  libbonobo-2.0, it strongly deprecates <link linkend="BonoboXObject">BonoboXObject</link>.
</para>

<para>
  Again if you are looking to implement a CORBA interface you want to 
see <link linkend="BonoboXObject">BonoboXObject</link>.
</para>

<para>
  The <classname>Bonobo::Unknown</classname> interface (wrapped by
  BonoboObject) is the foundation for the component system: it provides
  life cycle management for objects as well as service discovery.
</para>

<para>
  The Bonobo interfaces are all based on the
  <classname>Bonobo::Unknown</classname> interface.  This
  interface is very simple and provides two basic services:
  object lifetime management and object
  functionality-discovery.   This interface only contains three
  methods, here it is:

  <programlisting>
  module Bonobo {
      interface Unknown {
          void void <link linkend="ref">ref</link>();
          void void <link linkend="unref">unref</link>();
          Object query_interface (in string repoid);
      };
  };
  </programlisting>
</para>

<para>
  The <function><link linkend="ref">ref</link>()</function> and <function><link linkend="unref">unref</link>()</function>
  methods are used to control the lifetime of an object.  The
  <function>query_interface</function> method is used to discover
  optional functionality provided by the object implementation.
</para>

<para>
  The lifetime management is based on reference counting: when a
  component is initially launched, it starts life with a reference
  count of one.  This reference is held by the component invoker.
  Each time a reference is kept to this object (say, you store a
  copy of the object in an array), the reference count is
  incremented.  Every time a reference goes out of scope, the
  reference count needs to be decremented.  When the reference
  count reaches zero, the component knows that there are no
  outstanding references to it, and it is safe to shutdown.  At
  this point, the component shuts down.
</para>

<para>
  It is possible to ask an object which implements the
  <classname>Bonobo::Unknown</classname> interface if it supports
  other CORBA interfaces.  For example, it would be possible to
  ask an object whether it supports the
  "IDL:Bonobo/EmbeddablePrint:1.0" interface to find out if it is
  possible to print its contents.  If the return value from
  invoking the <function>query_interface</function> method on the
  interface is CORBA_OBJECT_NIL, then we know that the requested interface
  is not supported.  Otherwise, we can invoke
  IDL:Bonobo/EmbeddablePrint:1.0 methods on the returned CORBA
  Object.
</para>

<para>
  Clients of the <function>query_interface</function> method use
  it to discover dynamically if a component supports a given
  interface.  Sometimes the client code would require a specific
  interface to exist, but many times it is possible to operate in
  a "downgraded" mode.  You should design your code to be able to
  cope with the lack of interfaces in objects.  This will allow
  your program to deal with more components, and this also allows
  components to work in more situations.
</para>

<para>
  For example, a help browser can load an HTML renderer component and
  ask this component which sort of features are supported by it:
  <programlisting>
stop_animations (BrowserHTML html)
{
  BrowserControl control

  control = html->query_interface ("IDL:Browser/Control:1.0");
  if (control)
          control-><link linkend="stop-animations">stop_animations</link>();
}
  </programlisting>
</para>

<para>
  The return value of the query_interface invocation contains a
  reference to a CORBA object that is derived from the
  <classname>Bonobo::Unknown</classname> interface or
  CORBA_OBJECT_NIL if the interface is not supported by the
  object.  And this interface would have been already
  <function><link linkend="ref">ref</link>()</function>ed before it was returned.  It is up
  to the caller to call <function><link linkend="unref">unref</link>()</function> when they are
  done using the interface.
</para>

<para>
  BonoboObject implements the Bonobo::Unknown interface and exports the
  implementations of the methods in this class to simplify creating
  new objects that inherit from Bonobo::Unknown.  This base object
  provides default implementations for the ref, unref and
  query_interface methods.
</para>

<para>
  Other implementations reuse this implementation by listing on their
  VEPV tables the bonobo_object_epv entry point vector.
</para>

<para>
  The <classname>Bonobo::Unknown</classname> interface is inspired
  by the Microsoft COM <classname>IUnknown</classname> interface
  but it has been translated into the CORBA world.
</para>
</refsect1>

<refsect1>
<title>Details</title>
<refsect2>
<title><anchor id="BONOBO-OBJECT-TYPE-CAPS">BONOBO_OBJECT_TYPE</title>
<programlisting>#define BONOBO_OBJECT_TYPE        BONOBO_TYPE_OBJECT /* deprecated, you should use BONOBO_TYPE_OBJECT */
</programlisting>
<para>
Returns the <link linkend="GtkType">GtkType</link> for the BonoboObject object.
</para></refsect2>
<refsect2>
<title><anchor id="BONOBO-OBJREF-CAPS">BONOBO_OBJREF()</title>
<programlisting>#define BONOBO_OBJREF(o)          (bonobo_object_corba_objref(BONOBO_OBJECT(o)))
</programlisting>
<para>

</para><informaltable pgwide="1" frame="none" role="params">
<tgroup cols="2">
<colspec colwidth="2*">
<colspec colwidth="8*">
<tbody>
<row><entry align="right"><parameter>o</parameter>&nbsp;:</entry>
<entry>


</entry></row>
</tbody></tgroup></informaltable></refsect2>
<refsect2>
<title><anchor id="BonoboObjectPOAFn">BonoboObjectPOAFn ()</title>
<programlisting>void        (*BonoboObjectPOAFn)            (<link linkend="PortableServer-Servant">PortableServer_Servant</link> servant,
                                             <link linkend="CORBA-Environment">CORBA_Environment</link> *ev);</programlisting>
<para>

</para><informaltable pgwide="1" frame="none" role="params">
<tgroup cols="2">
<colspec colwidth="2*">
<colspec colwidth="8*">
<tbody>
<row><entry align="right"><parameter>servant</parameter>&nbsp;:</entry>
<entry>
</entry></row>
<row><entry align="right"><parameter>ev</parameter>&nbsp;:</entry>
<entry>


</entry></row>
</tbody></tgroup></informaltable></refsect2>
<refsect2>
<title><anchor id="BonoboObjectPrivate">struct BonoboObjectPrivate</title>
<programlisting>struct BonoboObjectPrivate;</programlisting>
<para>
   Private information kept by the BonoboObject.  This should not be
   used by BonoboObject users.
</para></refsect2>
<refsect2>
<title><anchor id="BonoboObjectHeader">BonoboObjectHeader</title>
<programlisting>typedef struct {
	GObject              base;             /* pointer + guint + pointer */
	BonoboObjectPrivate *priv;             /* pointer */
	guint                object_signature; /* guint   */
} BonoboObjectHeader;
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="BONOBO-OBJECT-HEADER-SIZE-CAPS">BONOBO_OBJECT_HEADER_SIZE</title>
<programlisting>#define BONOBO_OBJECT_HEADER_SIZE (sizeof (BonoboObjectHeader))
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="BONOBO-OBJECT-SIGNATURE-CAPS">BONOBO_OBJECT_SIGNATURE</title>
<programlisting>#define BONOBO_OBJECT_SIGNATURE   0xaef2
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="BONOBO-SERVANT-SIGNATURE-CAPS">BONOBO_SERVANT_SIGNATURE</title>
<programlisting>#define BONOBO_SERVANT_SIGNATURE  0x2fae
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="BonoboObject">BonoboObject</title>
<programlisting>typedef struct {
	/* A GObject and its signature of type BonoboObjectHeader */
	GObject              base;             /* pointer + guint + pointer */
	BonoboObjectPrivate *priv;             /* pointer */
	guint                object_signature; /* guint   */

	/* A Servant and its signature - same memory layout */
	POA_Bonobo_Unknown   servant;          /* pointer + pointer */
	guint                dummy;            /* guint   */
	Bonobo_Unknown       corba_objref;     /* pointer */
	guint                servant_signature;
} BonoboObject;
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="BonoboObjectClass">BonoboObjectClass</title>
<programlisting>typedef struct {
	GObjectClass parent_class;

	/* signals. */
	void         (*destroy)          (BonoboObject *object);
	void         (*system_exception) (BonoboObject *object,
					  CORBA_Object  cobject,
					  CORBA_Environment *ev);

	BonoboObjectPOAFn          poa_init_fn;
	BonoboObjectPOAFn          poa_fini_fn;

	POA_Bonobo_Unknown__vepv       *vepv;

	/* The offset of this class' additional epv */
	int                             epv_struct_offset;

	PortableServer_ServantBase__epv base_epv;
	POA_Bonobo_Unknown__epv         epv;
} BonoboObjectClass;
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="bonobo-object-add-interface">bonobo_object_add_interface ()</title>
<programlisting>void        bonobo_object_add_interface     (<link linkend="BonoboObject">BonoboObject</link> *object,
                                             <link linkend="BonoboObject">BonoboObject</link> *newobj);</programlisting>
<para>
Adds the interfaces supported by <parameter>newobj</parameter> to the list of interfaces
for <parameter>object</parameter>.  This function adds the interfaces supported by
<parameter>newobj</parameter> to the list of interfaces support by <parameter>object</parameter>. It should never
be used when the object has been exposed to the world. This is a firm
part of the contract.</para>
<para>

</para><informaltable pgwide="1" frame="none" role="params">
<tgroup cols="2">
<colspec colwidth="2*">
<colspec colwidth="8*">
<tbody>
<row><entry align="right"><parameter>object</parameter>&nbsp;:</entry>
<entry> The BonoboObject to which an interface is going to be added.
</entry></row>
<row><entry align="right"><parameter>newobj</parameter>&nbsp;:</entry>
<entry> The BonoboObject containing the new interface to be added.
</entry></row>
</tbody></tgroup></informaltable></refsect2>
<refsect2>
<title><anchor id="bonobo-object-query-local-interface">bonobo_object_query_local_interface ()</title>
<programlisting><link linkend="BonoboObject">BonoboObject</link>* bonobo_object_query_local_interface
                                            (<link linkend="BonoboObject">BonoboObject</link> *object,
                                             const char *repo_id);</programlisting>
<para>
</para>
<para>

</para><informaltable pgwide="1" frame="none" role="params">
<tgroup cols="2">
<colspec colwidth="2*">
<colspec colwidth="8*">
<tbody>
<row><entry align="right"><parameter>object</parameter>&nbsp;:</entry>
<entry> A <link linkend="BonoboObject">BonoboObject</link> which is the aggregate of multiple objects.
</entry></row>
<row><entry align="right"><parameter>repo_id</parameter>&nbsp;:</entry>
<entry> The id of the interface being queried.
</entry></row>
<row><entry align="right"><emphasis>Returns</emphasis> :</entry><entry> A <link linkend="BonoboObject">BonoboObject</link> for the requested interface.
</entry></row>
</tbody></tgroup></informaltable></refsect2>
<refsect2>
<title><anchor id="bonobo-object-query-interface">bonobo_object_query_interface ()</title>
<programlisting><link linkend="Bonobo-Unknown">Bonobo_Unknown</link> bonobo_object_query_interface
                                            (<link linkend="BonoboObject">BonoboObject</link> *object,
                                             const char *repo_id,
                                             <link linkend="CORBA-Environment">CORBA_Environment</link> *opt_ev);</programlisting>
<para>
</para>
<para>

</para><informaltable pgwide="1" frame="none" role="params">
<tgroup cols="2">
<colspec colwidth="2*">
<colspec colwidth="8*">
<tbody>
<row><entry align="right"><parameter>object</parameter>&nbsp;:</entry>
<entry> A BonoboObject to be queried for a given interface.
</entry></row>
<row><entry align="right"><parameter>repo_id</parameter>&nbsp;:</entry>
<entry> The name of the interface to be queried.
</entry></row>
<row><entry align="right"><parameter>opt_ev</parameter>&nbsp;:</entry>
<entry> optional exception environment
</entry></row>
<row><entry align="right"><emphasis>Returns</emphasis> :</entry><entry> The CORBA interface named <parameter>repo_id</parameter> for <parameter>object</parameter>.
</entry></row>
</tbody></tgroup></informaltable></refsect2>
<refsect2>
<title><anchor id="bonobo-object-corba-objref">bonobo_object_corba_objref ()</title>
<programlisting><link linkend="Bonobo-Unknown">Bonobo_Unknown</link> bonobo_object_corba_objref   (<link linkend="BonoboObject">BonoboObject</link> *object);</programlisting>
<para>
</para>
<para>

</para><informaltable pgwide="1" frame="none" role="params">
<tgroup cols="2">
<colspec colwidth="2*">
<colspec colwidth="8*">
<tbody>
<row><entry align="right"><parameter>object</parameter>&nbsp;:</entry>
<entry> A BonoboObject whose CORBA object is requested.
</entry></row>
<row><entry align="right"><emphasis>Returns</emphasis> :</entry><entry> The CORBA interface object for which <parameter>object</parameter> is a wrapper.
</entry></row>
</tbody></tgroup></informaltable></refsect2>
<refsect2>
<title><anchor id="bonobo-object-dup-ref">bonobo_object_dup_ref ()</title>
<programlisting><link linkend="Bonobo-Unknown">Bonobo_Unknown</link> bonobo_object_dup_ref        (<link linkend="Bonobo-Unknown">Bonobo_Unknown</link> object,
                                             <link linkend="CORBA-Environment">CORBA_Environment</link> *opt_ev);</programlisting>
<para>
This function returns a duplicated CORBA Object reference;
it also bumps the ref count on the object. This is ideal to
use in any method returning a Bonobo_Object in a CORBA impl.
If object is CORBA_OBJECT_NIL it is returned unaffected.</para>
<para>

</para><informaltable pgwide="1" frame="none" role="params">
<tgroup cols="2">
<colspec colwidth="2*">
<colspec colwidth="8*">
<tbody>
<row><entry align="right"><parameter>object</parameter>&nbsp;:</entry>
<entry> a Bonobo_Unknown corba object
</entry></row>
<row><entry align="right"><parameter>opt_ev</parameter>&nbsp;:</entry>
<entry> an optional exception environment
</entry></row>
<row><entry align="right"><emphasis>Returns</emphasis> :</entry><entry> duplicated &amp; ref'd corba object reference.
</entry></row>
</tbody></tgroup></informaltable></refsect2>
<refsect2>
<title><anchor id="bonobo-object-release-unref">bonobo_object_release_unref ()</title>
<programlisting><link linkend="Bonobo-Unknown">Bonobo_Unknown</link> bonobo_object_release_unref  (<link linkend="Bonobo-Unknown">Bonobo_Unknown</link> object,
                                             <link linkend="CORBA-Environment">CORBA_Environment</link> *opt_ev);</programlisting>
<para>
This function releases a CORBA Object reference;
it also decrements the ref count on the bonobo object.
This is the converse of bonobo_object_dup_ref. We
tolerate object == CORBA_OBJECT_NIL silently.</para>
<para>

</para><informaltable pgwide="1" frame="none" role="params">
<tgroup cols="2">
<colspec colwidth="2*">
<colspec colwidth="8*">
<tbody>
<row><entry align="right"><parameter>object</parameter>&nbsp;:</entry>
<entry> a Bonobo_Unknown corba object
</entry></row>
<row><entry align="right"><parameter>opt_ev</parameter>&nbsp;:</entry>
<entry> an optional exception environment
</entry></row>
<row><entry align="right"><emphasis>Returns</emphasis> :</entry><entry>
</entry></row>
</tbody></tgroup></informaltable></refsect2>
<refsect2>
<title><anchor id="bonobo-object-ref">bonobo_object_ref ()</title>
<programlisting><link linkend="gpointer">gpointer</link>    bonobo_object_ref               (<link linkend="gpointer">gpointer</link> obj);</programlisting>
<para>
Increments the reference count for the aggregate BonoboObject.</para>
<para>

</para><informaltable pgwide="1" frame="none" role="params">
<tgroup cols="2">
<colspec colwidth="2*">
<colspec colwidth="8*">
<tbody>
<row><entry align="right"><parameter>obj</parameter>&nbsp;:</entry>
<entry>
</entry></row>
<row><entry align="right"><emphasis>Returns</emphasis> :</entry><entry>
</entry></row>
</tbody></tgroup></informaltable></refsect2>
<refsect2>
<title><anchor id="bonobo-object-idle-unref">bonobo_object_idle_unref ()</title>
<programlisting>void        bonobo_object_idle_unref        (<link linkend="gpointer">gpointer</link> obj);</programlisting>
<para>

</para><informaltable pgwide="1" frame="none" role="params">
<tgroup cols="2">
<colspec colwidth="2*">
<colspec colwidth="8*">
<tbody>
<row><entry align="right"><parameter>obj</parameter>&nbsp;:</entry>
<entry>
</entry></row>
</tbody></tgroup></informaltable></refsect2>
<refsect2>
<title><anchor id="bonobo-object-unref">bonobo_object_unref ()</title>
<programlisting><link linkend="gpointer">gpointer</link>    bonobo_object_unref             (<link linkend="gpointer">gpointer</link> obj);</programlisting>
<para>
Decrements the reference count for the aggregate BonoboObject.</para>
<para>

</para><informaltable pgwide="1" frame="none" role="params">
<tgroup cols="2">
<colspec colwidth="2*">
<colspec colwidth="8*">
<tbody>
<row><entry align="right"><parameter>obj</parameter>&nbsp;:</entry>
<entry>
</entry></row>
<row><entry align="right"><emphasis>Returns</emphasis> :</entry><entry>
</entry></row>
</tbody></tgroup></informaltable></refsect2>
<refsect2>
<title><anchor id="bonobo-object-set-immortal">bonobo_object_set_immortal ()</title>
<programlisting>void        bonobo_object_set_immortal      (<link linkend="BonoboObject">BonoboObject</link> *object,
                                             <link linkend="gboolean">gboolean</link> immortal);</programlisting>
<para>

</para><informaltable pgwide="1" frame="none" role="params">
<tgroup cols="2">
<colspec colwidth="2*">
<colspec colwidth="8*">
<tbody>
<row><entry align="right"><parameter>object</parameter>&nbsp;:</entry>
<entry>
</entry></row>
<row><entry align="right"><parameter>immortal</parameter>&nbsp;:</entry>
<entry>


</entry></row>
</tbody></tgroup></informaltable></refsect2>
<refsect2>
<title><anchor id="bonobo-object-trace-refs">bonobo_object_trace_refs ()</title>
<programlisting><link linkend="gpointer">gpointer</link>    bonobo_object_trace_refs        (<link linkend="gpointer">gpointer</link> obj,
                                             const char *fn,
                                             int line,
                                             <link linkend="gboolean">gboolean</link> ref);</programlisting>
<para>

</para><informaltable pgwide="1" frame="none" role="params">
<tgroup cols="2">
<colspec colwidth="2*">
<colspec colwidth="8*">
<tbody>
<row><entry align="right"><parameter>obj</parameter>&nbsp;:</entry>
<entry>
</entry></row>
<row><entry align="right"><parameter>fn</parameter>&nbsp;:</entry>
<entry>
</entry></row>
<row><entry align="right"><parameter>line</parameter>&nbsp;:</entry>
<entry>
</entry></row>
<row><entry align="right"><parameter>ref</parameter>&nbsp;:</entry>
<entry>
</entry></row>
<row><entry align="right"><emphasis>Returns</emphasis> :</entry><entry>
</entry></row>
</tbody></tgroup></informaltable></refsect2>
<refsect2>
<title><anchor id="bonobo-object-dump-interfaces">bonobo_object_dump_interfaces ()</title>
<programlisting>void        bonobo_object_dump_interfaces   (<link linkend="BonoboObject">BonoboObject</link> *object);</programlisting>
<para>

</para><informaltable pgwide="1" frame="none" role="params">
<tgroup cols="2">
<colspec colwidth="2*">
<colspec colwidth="8*">
<tbody>
<row><entry align="right"><parameter>object</parameter>&nbsp;:</entry>
<entry>


</entry></row>
</tbody></tgroup></informaltable></refsect2>
<refsect2>
<title><anchor id="bonobo-object-check-env">bonobo_object_check_env ()</title>
<programlisting>void        bonobo_object_check_env         (<link linkend="BonoboObject">BonoboObject</link> *object,
                                             <link linkend="CORBA-Object">CORBA_Object</link> corba_object,
                                             <link linkend="CORBA-Environment">CORBA_Environment</link> *ev);</programlisting>
<para>
This routine verifies the <parameter>ev</parameter> environment for any fatal system
exceptions.  If a system exception occurs, the object raises a
"system_exception" signal.  The idea is that GObjects which are
used to wrap a CORBA interface can use this function to notify
the user if a fatal exception has occurred, causing the object
to become defunct.</para>
<para>

</para><informaltable pgwide="1" frame="none" role="params">
<tgroup cols="2">
<colspec colwidth="2*">
<colspec colwidth="8*">
<tbody>
<row><entry align="right"><parameter>object</parameter>&nbsp;:</entry>
<entry> The object on which we operate
</entry></row>
<row><entry align="right"><parameter>corba_object</parameter>&nbsp;:</entry>
<entry>
</entry></row>
<row><entry align="right"><parameter>ev</parameter>&nbsp;:</entry>
<entry> CORBA Environment to check
</entry></row>
</tbody></tgroup></informaltable></refsect2>
<refsect2>
<title><anchor id="BONOBO-OBJECT-CHECK-CAPS">BONOBO_OBJECT_CHECK()</title>
<programlisting>#define     BONOBO_OBJECT_CHECK(o,c,e)</programlisting>
<para>
   Checks if the exception in <parameter>e</parameter> needs to be signaled.  If so, then
   the proper exception signal is generated on the BonoboObject object
   <parameter>o</parameter> for the CORBA reference <parameter>c</parameter>.
</para><informaltable pgwide="1" frame="none" role="params">
<tgroup cols="2">
<colspec colwidth="2*">
<colspec colwidth="8*">
<tbody>
<row><entry align="right"><parameter>o</parameter>&nbsp;:</entry>
<entry>
</entry></row>
<row><entry align="right"><parameter>c</parameter>&nbsp;:</entry>
<entry>
</entry></row>
<row><entry align="right"><parameter>e</parameter>&nbsp;:</entry>
<entry>


</entry></row>
</tbody></tgroup></informaltable></refsect2>
<refsect2>
<title><anchor id="bonobo-unknown-ping">bonobo_unknown_ping ()</title>
<programlisting><link linkend="gboolean">gboolean</link>    bonobo_unknown_ping             (<link linkend="Bonobo-Unknown">Bonobo_Unknown</link> object,
                                             <link linkend="CORBA-Environment">CORBA_Environment</link> *opt_ev);</programlisting>
<para>
Pings the object <parameter>object</parameter> using the ref/unref methods from Bonobo::Unknown.
You can use this one to see if a remote object has gone away.</para>
<para>

</para><informaltable pgwide="1" frame="none" role="params">
<tgroup cols="2">
<colspec colwidth="2*">
<colspec colwidth="8*">
<tbody>
<row><entry align="right"><parameter>object</parameter>&nbsp;:</entry>
<entry> a CORBA object reference of type Bonobo::Unknown
</entry></row>
<row><entry align="right"><parameter>opt_ev</parameter>&nbsp;:</entry>
<entry> optional exception environment
</entry></row>
<row><entry align="right"><emphasis>Returns</emphasis> :</entry><entry> <literal>TRUE</literal> if the Bonobo::Unknown <parameter>object</parameter> is alive.
</entry></row>
</tbody></tgroup></informaltable></refsect2>
<refsect2>
<title><anchor id="bonobo-object-list-unref-all">bonobo_object_list_unref_all ()</title>
<programlisting>void        bonobo_object_list_unref_all    (<link linkend="GList">GList</link> **list);</programlisting>
<para>
This routine unrefs all valid objects in
the list and then removes them from <parameter>list</parameter> if
they have not already been so removed.</para>
<para>

</para><informaltable pgwide="1" frame="none" role="params">
<tgroup cols="2">
<colspec colwidth="2*">
<colspec colwidth="8*">
<tbody>
<row><entry align="right"><parameter>list</parameter>&nbsp;:</entry>
<entry> A list of BonoboObjects *s
</entry></row>
</tbody></tgroup></informaltable></refsect2>
<refsect2>
<title><anchor id="bonobo-object-slist-unref-all">bonobo_object_slist_unref_all ()</title>
<programlisting>void        bonobo_object_slist_unref_all   (<link linkend="GSList">GSList</link> **list);</programlisting>
<para>

</para><informaltable pgwide="1" frame="none" role="params">
<tgroup cols="2">
<colspec colwidth="2*">
<colspec colwidth="8*">
<tbody>
<row><entry align="right"><parameter>list</parameter>&nbsp;:</entry>
<entry>


</entry></row>
</tbody></tgroup></informaltable></refsect2>
<refsect2>
<title><anchor id="bonobo-object">bonobo_object ()</title>
<programlisting><link linkend="BonoboObject">BonoboObject</link>* bonobo_object                 (<link linkend="gpointer">gpointer</link> p);</programlisting>
<para>
This function can be passed a BonoboObject * or a
PortableServer_Servant, and it will return a BonoboObject *.</para>
<para>

</para><informaltable pgwide="1" frame="none" role="params">
<tgroup cols="2">
<colspec colwidth="2*">
<colspec colwidth="8*">
<tbody>
<row><entry align="right"><parameter>p</parameter>&nbsp;:</entry>
<entry> a pointer to something
</entry></row>
<row><entry align="right"><emphasis>Returns</emphasis> :</entry><entry> a BonoboObject or NULL on error.
</entry></row>
</tbody></tgroup></informaltable></refsect2>
<refsect2>
<title><anchor id="bonobo-object-fast">bonobo_object_fast()</title>
<programlisting>#define     bonobo_object_fast(o)</programlisting>
<para>

</para><informaltable pgwide="1" frame="none" role="params">
<tgroup cols="2">
<colspec colwidth="2*">
<colspec colwidth="8*">
<tbody>
<row><entry align="right"><parameter>o</parameter>&nbsp;:</entry>
<entry>


</entry></row>
</tbody></tgroup></informaltable></refsect2>
<refsect2>
<title><anchor id="bonobo-object-from-servant">bonobo_object_from_servant()</title>
<programlisting>#define       bonobo_object_from_servant(s) ((BonoboObject *)(((guchar *) (s)) - BONOBO_OBJECT_HEADER_SIZE))
</programlisting>
<para>

</para><informaltable pgwide="1" frame="none" role="params">
<tgroup cols="2">
<colspec colwidth="2*">
<colspec colwidth="8*">
<tbody>
<row><entry align="right"><parameter>s</parameter>&nbsp;:</entry>
<entry>
</entry></row>
<row><entry align="right"><emphasis>Returns</emphasis> :</entry><entry>
</entry></row>
</tbody></tgroup></informaltable></refsect2>
<refsect2>
<title><anchor id="bonobo-object-get-servant">bonobo_object_get_servant()</title>
<programlisting>#define       bonobo_object_get_servant(o)  ((PortableServer_Servant)((guchar *)(o) + BONOBO_OBJECT_HEADER_SIZE))
</programlisting>
<para>

</para><informaltable pgwide="1" frame="none" role="params">
<tgroup cols="2">
<colspec colwidth="2*">
<colspec colwidth="8*">
<tbody>
<row><entry align="right"><parameter>o</parameter>&nbsp;:</entry>
<entry>
</entry></row>
<row><entry align="right"><emphasis>Returns</emphasis> :</entry><entry>
</entry></row>
</tbody></tgroup></informaltable></refsect2>
<refsect2>
<title><anchor id="bonobo-type-unique">bonobo_type_unique ()</title>
<programlisting><link linkend="GType">GType</link>       bonobo_type_unique              (<link linkend="GType">GType</link> parent_type,
                                             <link linkend="BonoboObjectPOAFn">BonoboObjectPOAFn</link> init_fn,
                                             <link linkend="BonoboObjectPOAFn">BonoboObjectPOAFn</link> fini_fn,
                                             int epv_struct_offset,
                                             const <link linkend="GTypeInfo">GTypeInfo</link> *info,
                                             const <link linkend="gchar">gchar</link> *type_name);</programlisting>
<para>
This function is the main entry point for deriving bonobo
server interfaces.</para>
<para>

</para><informaltable pgwide="1" frame="none" role="params">
<tgroup cols="2">
<colspec colwidth="2*">
<colspec colwidth="8*">
<tbody>
<row><entry align="right"><parameter>parent_type</parameter>&nbsp;:</entry>
<entry> the parent GType
</entry></row>
<row><entry align="right"><parameter>init_fn</parameter>&nbsp;:</entry>
<entry> a POA initialization function
</entry></row>
<row><entry align="right"><parameter>fini_fn</parameter>&nbsp;:</entry>
<entry> a POA finialization function or NULL
</entry></row>
<row><entry align="right"><parameter>epv_struct_offset</parameter>&nbsp;:</entry>
<entry> the offset into the struct that the epv
commences at, or 0 if we are inheriting a plain GObject
from a BonoboObject, adding no new CORBA interfaces
</entry></row>
<row><entry align="right"><parameter>info</parameter>&nbsp;:</entry>
<entry> the standard GTypeInfo.
</entry></row>
<row><entry align="right"><parameter>type_name</parameter>&nbsp;:</entry>
<entry>
</entry></row>
<row><entry align="right"><emphasis>Returns</emphasis> :</entry><entry> the constructed GType.
</entry></row>
</tbody></tgroup></informaltable></refsect2>
<refsect2>
<title><anchor id="bonobo-type-setup">bonobo_type_setup ()</title>
<programlisting><link linkend="gboolean">gboolean</link>    bonobo_type_setup               (<link linkend="GType">GType</link> type,
                                             <link linkend="BonoboObjectPOAFn">BonoboObjectPOAFn</link> init_fn,
                                             <link linkend="BonoboObjectPOAFn">BonoboObjectPOAFn</link> fini_fn,
                                             int epv_struct_offset);</programlisting>
<para>
This function initializes a type derived from BonoboObject, such that
when you instantiate a new object of this type with g_type_new the
CORBA object will be correctly created and embedded.</para>
<para>

</para><informaltable pgwide="1" frame="none" role="params">
<tgroup cols="2">
<colspec colwidth="2*">
<colspec colwidth="8*">
<tbody>
<row><entry align="right"><parameter>type</parameter>&nbsp;:</entry>
<entry> The type to initialize
</entry></row>
<row><entry align="right"><parameter>init_fn</parameter>&nbsp;:</entry>
<entry> the POA_init function for the CORBA interface or NULL
</entry></row>
<row><entry align="right"><parameter>fini_fn</parameter>&nbsp;:</entry>
<entry> NULL or a custom POA free fn.
</entry></row>
<row><entry align="right"><parameter>epv_struct_offset</parameter>&nbsp;:</entry>
<entry> the offset in the class structure where the epv is or 0
</entry></row>
<row><entry align="right"><emphasis>Returns</emphasis> :</entry><entry> TRUE on success, FALSE on error.
</entry></row>
</tbody></tgroup></informaltable></refsect2>
<refsect2>
<title><anchor id="BONOBO-TYPE-FUNC-FULL-CAPS">BONOBO_TYPE_FUNC_FULL()</title>
<programlisting>#define     BONOBO_TYPE_FUNC_FULL(class_name, corba_name, parent, prefix)</programlisting>
<para>

</para><informaltable pgwide="1" frame="none" role="params">
<tgroup cols="2">
<colspec colwidth="2*">
<colspec colwidth="8*">
<tbody>
<row><entry align="right"><parameter>class_name</parameter>&nbsp;:</entry>
<entry>
</entry></row>
<row><entry align="right"><parameter>corba_name</parameter>&nbsp;:</entry>
<entry>
</entry></row>
<row><entry align="right"><parameter>parent</parameter>&nbsp;:</entry>
<entry>
</entry></row>
<row><entry align="right"><parameter>prefix</parameter>&nbsp;:</entry>
<entry>


</entry></row>
</tbody></tgroup></informaltable></refsect2>
<refsect2>
<title><anchor id="BONOBO-TYPE-FUNC-CAPS">BONOBO_TYPE_FUNC()</title>
<programlisting>#define     BONOBO_TYPE_FUNC(class_name, parent, prefix)</programlisting>
<para>

</para><informaltable pgwide="1" frame="none" role="params">
<tgroup cols="2">
<colspec colwidth="2*">
<colspec colwidth="8*">
<tbody>
<row><entry align="right"><parameter>class_name</parameter>&nbsp;:</entry>
<entry>
</entry></row>
<row><entry align="right"><parameter>parent</parameter>&nbsp;:</entry>
<entry>
</entry></row>
<row><entry align="right"><parameter>prefix</parameter>&nbsp;:</entry>
<entry>


</entry></row>
</tbody></tgroup></informaltable></refsect2>

</refsect1>



<refsect1>
<title>See Also</title>
<para>
<link linkend="GtkObject">GtkObject</link>
</para>
</refsect1>

</refentry>
