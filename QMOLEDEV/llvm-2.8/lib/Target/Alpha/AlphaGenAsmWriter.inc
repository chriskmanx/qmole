//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
void AlphaAsmPrinter::printInstruction(const MachineInstr *MI, raw_ostream &O) {
  static const unsigned OpInfo[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// PROLOG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    1U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    1073741835U,	// ADDLi
    1073741835U,	// ADDLr
    1073741841U,	// ADDQi
    1073741841U,	// ADDQr
    1073741847U,	// ADDS
    1073741856U,	// ADDT
    2214592553U,	// ADJUSTSTACKDOWN
    2214592564U,	// ADJUSTSTACKUP
    2281701437U,	// ALTENT
    1073741887U,	// ANDi
    1073741887U,	// ANDr
    1082130500U,	// BEQ
    1082130505U,	// BGE
    1082130510U,	// BGT
    1073741907U,	// BICi
    1073741907U,	// BICr
    1073741912U,	// BISi
    1073741912U,	// BISr
    1082130525U,	// BLBC
    1082130531U,	// BLBS
    1082130537U,	// BLE
    1082130542U,	// BLT
    1082130547U,	// BNE
    2214592632U,	// BR
    2348810368U,	// BSR
    0U,	// CAS32
    0U,	// CAS64
    1073741962U,	// CMOVEQi
    1073741962U,	// CMOVEQr
    1073741970U,	// CMOVGEi
    1073741970U,	// CMOVGEr
    1073741978U,	// CMOVGTi
    1073741978U,	// CMOVGTr
    1073741986U,	// CMOVLBCi
    1073741986U,	// CMOVLBCr
    1073741995U,	// CMOVLBSi
    1073741995U,	// CMOVLBSr
    1073742004U,	// CMOVLEi
    1073742004U,	// CMOVLEr
    1073742012U,	// CMOVLTi
    1073742012U,	// CMOVLTr
    1073742020U,	// CMOVNEi
    1073742020U,	// CMOVNEr
    1073742028U,	// CMPBGE
    1073742028U,	// CMPBGEi
    1073742036U,	// CMPEQ
    1073742036U,	// CMPEQi
    1073742043U,	// CMPLE
    1073742043U,	// CMPLEi
    1073742050U,	// CMPLT
    1073742050U,	// CMPLTi
    1073742057U,	// CMPTEQ
    1073742068U,	// CMPTLE
    1073742079U,	// CMPTLT
    1073742090U,	// CMPTUN
    1073742101U,	// CMPULE
    1073742101U,	// CMPULEi
    1073742109U,	// CMPULT
    1073742109U,	// CMPULTi
    2415919397U,	// COND_BRANCH_F
    2483028261U,	// COND_BRANCH_I
    1073742143U,	// CPYSES
    1073742143U,	// CPYSESt
    1073742143U,	// CPYSET
    1073742150U,	// CPYSNS
    1073742150U,	// CPYSNSt
    1073742150U,	// CPYSNT
    1073742150U,	// CPYSNTs
    1073742157U,	// CPYSS
    1073742157U,	// CPYSSt
    1073742157U,	// CPYST
    1073742157U,	// CPYSTs
    1476395347U,	// CTLZ
    1476395353U,	// CTPOP
    1476395360U,	// CTTZ
    1476395366U,	// CVTQS
    1476395377U,	// CVTQT
    1476395388U,	// CVTST
    1476395397U,	// CVTTQ
    1476395408U,	// CVTTS
    1073742235U,	// DIVS
    1073742244U,	// DIVT
    1073742253U,	// EQVi
    1073742253U,	// EQVr
    1073742258U,	// EXTBL
    1073742265U,	// EXTLL
    1073742272U,	// EXTWL
    1082130887U,	// FBEQ
    1082130893U,	// FBGE
    1082130899U,	// FBGT
    1082130905U,	// FBLE
    1082130911U,	// FBLT
    1082130917U,	// FBNE
    3221225963U,	// FCMOVEQS
    3221225963U,	// FCMOVEQT
    3221225972U,	// FCMOVGES
    3221225972U,	// FCMOVGET
    3221225981U,	// FCMOVGTS
    3221225981U,	// FCMOVGTT
    3221225990U,	// FCMOVLES
    3221225990U,	// FCMOVLET
    3221225999U,	// FCMOVLTS
    3221225999U,	// FCMOVLTT
    3221226008U,	// FCMOVNES
    3221226008U,	// FCMOVNET
    1476395553U,	// FTOIS
    1476395560U,	// FTOIT
    1476395567U,	// ITOFS
    1476395574U,	// ITOFT
    2617246269U,	// JMP
    583U,	// JSR
    2684355159U,	// JSR_COROUTINE
    614U,	// JSRs
    0U,	// LAS32
    0U,	// LAS64
    2768241270U,	// LDA
    2768241275U,	// LDAH
    2818572923U,	// LDAHg
    2776629883U,	// LDAHr
    2818572918U,	// LDAg
    2785018486U,	// LDAr
    2768241281U,	// LDBU
    2785018497U,	// LDBUr
    2768241287U,	// LDL
    2768241292U,	// LDL_L
    2785018503U,	// LDLr
    2768241299U,	// LDQ
    2768241304U,	// LDQ_L
    2793407123U,	// LDQl
    2785018515U,	// LDQr
    2768241311U,	// LDS
    2785018527U,	// LDSr
    2768241316U,	// LDT
    2785018532U,	// LDTr
    2768241321U,	// LDWU
    2785018537U,	// LDWUr
    687U,	// MB
    2885681842U,	// MEMLABEL
    1073742524U,	// MULLi
    1073742524U,	// MULLr
    1073742530U,	// MULQi
    1073742530U,	// MULQr
    1073742536U,	// MULS
    1073742545U,	// MULT
    1073742554U,	// ORNOTi
    1073742554U,	// ORNOTr
    2952790753U,	// PCLABEL
    747U,	// RETDAG
    747U,	// RETDAGp
    2214593275U,	// RPCC
    1073742593U,	// S4ADDLi
    1073742593U,	// S4ADDLr
    1073742601U,	// S4ADDQi
    1073742601U,	// S4ADDQr
    1073742609U,	// S4SUBLi
    1073742609U,	// S4SUBLr
    1073742617U,	// S4SUBQi
    1073742617U,	// S4SUBQr
    1073742625U,	// S8ADDLi
    1073742625U,	// S8ADDLr
    1073742633U,	// S8ADDQi
    1073742633U,	// S8ADDQr
    1073742641U,	// S8SUBLi
    1073742641U,	// S8SUBLr
    1073742649U,	// S8SUBQi
    1073742649U,	// S8SUBQr
    1476395841U,	// SEXTB
    1476395848U,	// SEXTW
    1073742671U,	// SLi
    1073742671U,	// SLr
    1476395860U,	// SQRTS
    1476395870U,	// SQRTT
    1073742696U,	// SRAi
    1073742696U,	// SRAr
    1073742701U,	// SRLi
    1073742701U,	// SRLr
    2768241522U,	// STB
    2785018738U,	// STBr
    2768241527U,	// STL
    1124074364U,	// STL_C
    2785018743U,	// STLr
    2768241539U,	// STQ
    1124074376U,	// STQ_C
    2785018755U,	// STQr
    2768241551U,	// STS
    2785018767U,	// STSr
    2768241556U,	// STT
    2785018772U,	// STTr
    2768241561U,	// STW
    2785018777U,	// STWr
    1073742750U,	// SUBLi
    1073742750U,	// SUBLr
    1073742756U,	// SUBQi
    1073742756U,	// SUBQr
    1073742762U,	// SUBS
    1073742771U,	// SUBT
    0U,	// SWAP32
    0U,	// SWAP64
    1073742780U,	// UMULHi
    1073742780U,	// UMULHr
    963U,	// WMB
    967U,	// WTF
    1073742796U,	// XORi
    1073742796U,	// XORr
    1073742801U,	// ZAPNOTi
    0U
  };

  const char *AsmStrs = 
    "DBG_VALUE\000addl \000addq \000adds/su \000addt/su \000; ADJDOWN \000; "
    "ADJUP \000$\000and \000beq \000bge \000bgt \000bic \000bis \000blbc \000"
    "blbs \000ble \000blt \000bne \000br $31,\000bsr $26,$\000cmoveq \000cmo"
    "vge \000cmovgt \000cmovlbc \000cmovlbs \000cmovle \000cmovlt \000cmovne"
    " \000cmpbge \000cmpeq \000cmple \000cmplt \000cmpteq/su \000cmptle/su \000"
    "cmptlt/su \000cmptun/su \000cmpule \000cmpult \000:comment COND_BRANCH "
    "imm:\000cpyse \000cpysn \000cpys \000CTLZ \000CTPOP \000CTTZ \000cvtqs/"
    "sui \000cvtqt/sui \000cvtst/s \000cvttq/svc \000cvtts/sui \000divs/su \000"
    "divt/su \000eqv \000EXTBL \000EXTLL \000EXTWL \000fbeq \000fbge \000fbg"
    "t \000fble \000fblt \000fbne \000fcmoveq \000fcmovge \000fcmovgt \000fc"
    "movle \000fcmovlt \000fcmovne \000ftois \000ftoit \000itofs \000itoft \000"
    "jmp $31,(\000jsr $26,($27),0\000jsr_coroutine \000jsr $23,($27),0\000ld"
    "a \000ldah \000ldbu \000ldl \000ldl_l \000ldq \000ldq_l \000lds \000ldt"
    " \000ldwu \000mb\000LSMARKER$\000mull \000mulq \000muls/su \000mult/su "
    "\000ornot \000PCMARKER_\000ret $31,($26),1\000rpcc \000s4addl \000s4add"
    "q \000s4subl \000s4subq \000s8addl \000s8addq \000s8subl \000s8subq \000"
    "sextb \000sextw \000sll \000sqrts/su \000sqrtt/su \000sra \000srl \000s"
    "tb \000stl \000stl_l \000stq \000stq_l \000sts \000stt \000stw \000subl"
    " \000subq \000subs/su \000subt/su \000umulh \000wmb\000#wtf\000xor \000"
    "zapnot \000";

  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 1023)-1;


  // Fragment 0 encoded into 2 bits for 4 unique commands.
  switch ((Bits >> 30) & 3) {
  default:   // unreachable.
  case 0:
    // DBG_VALUE, JSR, JSRs, MB, RETDAG, RETDAGp, WMB, WTF
    return;
    break;
  case 1:
    // ADDLi, ADDLr, ADDQi, ADDQr, ADDS, ADDT, ANDi, ANDr, BEQ, BGE, BGT, BIC...
    printOperand(MI, 1, O); 
    O << ','; 
    break;
  case 2:
    // ADJUSTSTACKDOWN, ADJUSTSTACKUP, ALTENT, BR, BSR, COND_BRANCH_F, COND_B...
    printOperand(MI, 0, O); 
    break;
  case 3:
    // FCMOVEQS, FCMOVEQT, FCMOVGES, FCMOVGET, FCMOVGTS, FCMOVGTT, FCMOVLES, ...
    printOperand(MI, 3, O); 
    O << ','; 
    printOperand(MI, 2, O); 
    O << ','; 
    printOperand(MI, 0, O); 
    return;
    break;
  }


  // Fragment 1 encoded into 4 bits for 13 unique commands.
  switch ((Bits >> 26) & 15) {
  default:   // unreachable.
  case 0:
    // ADDLi, ADDLr, ADDQi, ADDQr, ADDS, ADDT, ANDi, ANDr, BEQ, BGE, BGT, BIC...
    printOperand(MI, 2, O); 
    break;
  case 1:
    // ADJUSTSTACKDOWN, ADJUSTSTACKUP, BR, RPCC
    return;
    break;
  case 2:
    // ALTENT
    O << "..ng:\n"; 
    return;
    break;
  case 3:
    // BSR
    O << "..ng"; 
    return;
    break;
  case 4:
    // COND_BRANCH_F
    O << ", F8RC:"; 
    printOperand(MI, 1, O); 
    O << ", bb:"; 
    printOperand(MI, 2, O); 
    return;
    break;
  case 5:
    // COND_BRANCH_I
    O << ", GPRC:"; 
    printOperand(MI, 1, O); 
    O << ", bb:"; 
    printOperand(MI, 2, O); 
    return;
    break;
  case 6:
    // CTLZ, CTPOP, CTTZ, CVTQS, CVTQT, CVTST, CVTTQ, CVTTS, FTOIS, FTOIT, IT...
    printOperand(MI, 0, O); 
    return;
    break;
  case 7:
    // JMP
    O << "),0"; 
    return;
    break;
  case 8:
    // JSR_COROUTINE
    O << ",("; 
    printOperand(MI, 1, O); 
    O << "),"; 
    printOperand(MI, 2, O); 
    return;
    break;
  case 9:
    // LDA, LDAH, LDAHr, LDAr, LDBU, LDBUr, LDL, LDL_L, LDLr, LDQ, LDQ_L, LDQ...
    O << ','; 
    printOperand(MI, 1, O); 
    O << '('; 
    printOperand(MI, 2, O); 
    break;
  case 10:
    // LDAHg, LDAg
    O << ",0("; 
    printOperand(MI, 2, O); 
    O << ")\t\t!gpdisp!"; 
    printOperand(MI, 3, O); 
    return;
    break;
  case 11:
    // MEMLABEL
    O << '$'; 
    printOperand(MI, 1, O); 
    O << '$'; 
    printOperand(MI, 2, O); 
    O << '$'; 
    printOperand(MI, 3, O); 
    O << ':'; 
    return;
    break;
  case 12:
    // PCLABEL
    O << ":\n"; 
    return;
    break;
  }


  // Fragment 2 encoded into 3 bits for 7 unique commands.
  switch ((Bits >> 23) & 7) {
  default:   // unreachable.
  case 0:
    // ADDLi, ADDLr, ADDQi, ADDQr, ADDS, ADDT, ANDi, ANDr, BICi, BICr, BISi, ...
    O << ','; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 1:
    // BEQ, BGE, BGT, BLBC, BLBS, BLE, BLT, BNE, FBEQ, FBGE, FBGT, FBLE, FBLT...
    return;
    break;
  case 2:
    // LDA, LDAH, LDBU, LDL, LDL_L, LDQ, LDQ_L, LDS, LDT, LDWU, STB, STL, STQ...
    O << ')'; 
    return;
    break;
  case 3:
    // LDAHr
    O << ")\t\t!gprelhigh"; 
    return;
    break;
  case 4:
    // LDAr, LDBUr, LDLr, LDQr, LDSr, LDTr, LDWUr, STBr, STLr, STQr, STSr, ST...
    O << ")\t\t!gprellow"; 
    return;
    break;
  case 5:
    // LDQl
    O << ")\t\t!literal"; 
    return;
    break;
  case 6:
    // STL_C, STQ_C
    O << '('; 
    printOperand(MI, 3, O); 
    O << ')'; 
    return;
    break;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
const char *AlphaAsmPrinter::getRegisterName(unsigned RegNo) {
  assert(RegNo && RegNo < 65 && "Invalid register number!");

  static const unsigned RegAsmOffset[] = {
    0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 45, 50, 55, 
    60, 65, 70, 75, 80, 85, 90, 95, 100, 105, 110, 115, 120, 125, 
    130, 135, 140, 145, 150, 153, 156, 159, 162, 165, 168, 171, 174, 177, 
    180, 184, 188, 192, 196, 200, 204, 208, 212, 216, 220, 224, 228, 232, 
    236, 240, 244, 248, 252, 256, 260, 264, 0
  };

  const char *AsmStrs =
    "$f0\000$f1\000$f2\000$f3\000$f4\000$f5\000$f6\000$f7\000$f8\000$f9\000$"
    "f10\000$f11\000$f12\000$f13\000$f14\000$f15\000$f16\000$f17\000$f18\000"
    "$f19\000$f20\000$f21\000$f22\000$f23\000$f24\000$f25\000$f26\000$f27\000"
    "$f28\000$f29\000$f30\000$f31\000$0\000$1\000$2\000$3\000$4\000$5\000$6\000"
    "$7\000$8\000$9\000$10\000$11\000$12\000$13\000$14\000$15\000$16\000$17\000"
    "$18\000$19\000$20\000$21\000$22\000$23\000$24\000$25\000$26\000$27\000$"
    "28\000$29\000$30\000$31\000";
  return AsmStrs+RegAsmOffset[RegNo-1];
}


#ifdef GET_INSTRUCTION_NAME
#undef GET_INSTRUCTION_NAME

/// getInstructionName: This method is automatically generated by tblgen
/// from the instruction set description.  This returns the enum name of the
/// specified instruction.
const char *AlphaAsmPrinter::getInstructionName(unsigned Opcode) {
  assert(Opcode < 219 && "Invalid instruction number!");

  static const unsigned InstAsmOffset[] = {
    0, 4, 14, 27, 36, 45, 50, 65, 79, 92, 106, 123, 133, 146, 
    151, 157, 163, 169, 175, 180, 185, 201, 215, 222, 227, 232, 236, 240, 
    244, 249, 254, 259, 264, 269, 274, 278, 282, 286, 289, 293, 299, 305, 
    313, 321, 329, 337, 345, 353, 362, 371, 380, 389, 397, 405, 413, 421, 
    429, 437, 444, 452, 458, 465, 471, 478, 484, 491, 498, 505, 512, 519, 
    526, 534, 541, 549, 563, 577, 584, 592, 599, 606, 614, 621, 629, 635, 
    642, 648, 655, 660, 666, 671, 677, 683, 689, 695, 701, 706, 711, 716, 
    721, 727, 733, 739, 744, 749, 754, 759, 764, 769, 778, 787, 796, 805, 
    814, 823, 832, 841, 850, 859, 868, 877, 883, 889, 895, 901, 905, 909, 
    923, 928, 934, 940, 944, 949, 955, 961, 966, 971, 976, 982, 986, 992, 
    997, 1001, 1007, 1012, 1017, 1021, 1026, 1030, 1035, 1040, 1046, 1049, 1058, 1064, 
    1070, 1076, 1082, 1087, 1092, 1099, 1106, 1114, 1121, 1129, 1134, 1142, 1150, 1158, 
    1166, 1174, 1182, 1190, 1198, 1206, 1214, 1222, 1230, 1238, 1246, 1254, 1262, 1268, 
    1274, 1278, 1282, 1288, 1294, 1299, 1304, 1309, 1314, 1318, 1323, 1327, 1333, 1338, 
    1342, 1348, 1353, 1357, 1362, 1366, 1371, 1375, 1380, 1386, 1392, 1398, 1404, 1409, 
    1414, 1421, 1428, 1435, 1442, 1446, 1450, 1455, 1460, 0
  };

  const char *Strs =
    "PHI\000INLINEASM\000PROLOG_LABEL\000EH_LABEL\000GC_LABEL\000KILL\000EXT"
    "RACT_SUBREG\000INSERT_SUBREG\000IMPLICIT_DEF\000SUBREG_TO_REG\000COPY_T"
    "O_REGCLASS\000DBG_VALUE\000REG_SEQUENCE\000COPY\000ADDLi\000ADDLr\000AD"
    "DQi\000ADDQr\000ADDS\000ADDT\000ADJUSTSTACKDOWN\000ADJUSTSTACKUP\000ALT"
    "ENT\000ANDi\000ANDr\000BEQ\000BGE\000BGT\000BICi\000BICr\000BISi\000BIS"
    "r\000BLBC\000BLBS\000BLE\000BLT\000BNE\000BR\000BSR\000CAS32\000CAS64\000"
    "CMOVEQi\000CMOVEQr\000CMOVGEi\000CMOVGEr\000CMOVGTi\000CMOVGTr\000CMOVL"
    "BCi\000CMOVLBCr\000CMOVLBSi\000CMOVLBSr\000CMOVLEi\000CMOVLEr\000CMOVLT"
    "i\000CMOVLTr\000CMOVNEi\000CMOVNEr\000CMPBGE\000CMPBGEi\000CMPEQ\000CMP"
    "EQi\000CMPLE\000CMPLEi\000CMPLT\000CMPLTi\000CMPTEQ\000CMPTLE\000CMPTLT"
    "\000CMPTUN\000CMPULE\000CMPULEi\000CMPULT\000CMPULTi\000COND_BRANCH_F\000"
    "COND_BRANCH_I\000CPYSES\000CPYSESt\000CPYSET\000CPYSNS\000CPYSNSt\000CP"
    "YSNT\000CPYSNTs\000CPYSS\000CPYSSt\000CPYST\000CPYSTs\000CTLZ\000CTPOP\000"
    "CTTZ\000CVTQS\000CVTQT\000CVTST\000CVTTQ\000CVTTS\000DIVS\000DIVT\000EQ"
    "Vi\000EQVr\000EXTBL\000EXTLL\000EXTWL\000FBEQ\000FBGE\000FBGT\000FBLE\000"
    "FBLT\000FBNE\000FCMOVEQS\000FCMOVEQT\000FCMOVGES\000FCMOVGET\000FCMOVGT"
    "S\000FCMOVGTT\000FCMOVLES\000FCMOVLET\000FCMOVLTS\000FCMOVLTT\000FCMOVN"
    "ES\000FCMOVNET\000FTOIS\000FTOIT\000ITOFS\000ITOFT\000JMP\000JSR\000JSR"
    "_COROUTINE\000JSRs\000LAS32\000LAS64\000LDA\000LDAH\000LDAHg\000LDAHr\000"
    "LDAg\000LDAr\000LDBU\000LDBUr\000LDL\000LDL_L\000LDLr\000LDQ\000LDQ_L\000"
    "LDQl\000LDQr\000LDS\000LDSr\000LDT\000LDTr\000LDWU\000LDWUr\000MB\000ME"
    "MLABEL\000MULLi\000MULLr\000MULQi\000MULQr\000MULS\000MULT\000ORNOTi\000"
    "ORNOTr\000PCLABEL\000RETDAG\000RETDAGp\000RPCC\000S4ADDLi\000S4ADDLr\000"
    "S4ADDQi\000S4ADDQr\000S4SUBLi\000S4SUBLr\000S4SUBQi\000S4SUBQr\000S8ADD"
    "Li\000S8ADDLr\000S8ADDQi\000S8ADDQr\000S8SUBLi\000S8SUBLr\000S8SUBQi\000"
    "S8SUBQr\000SEXTB\000SEXTW\000SLi\000SLr\000SQRTS\000SQRTT\000SRAi\000SR"
    "Ar\000SRLi\000SRLr\000STB\000STBr\000STL\000STL_C\000STLr\000STQ\000STQ"
    "_C\000STQr\000STS\000STSr\000STT\000STTr\000STW\000STWr\000SUBLi\000SUB"
    "Lr\000SUBQi\000SUBQr\000SUBS\000SUBT\000SWAP32\000SWAP64\000UMULHi\000U"
    "MULHr\000WMB\000WTF\000XORi\000XORr\000ZAPNOTi\000";
  return Strs+InstAsmOffset[Opcode];
}

#endif
