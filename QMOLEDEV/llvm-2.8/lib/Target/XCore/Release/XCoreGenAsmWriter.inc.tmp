//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
void XCoreAsmPrinter::printInstruction(const MachineInstr *MI, raw_ostream &O) {
  static const unsigned OpInfo[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// PROLOG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    1U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    536870923U,	// ADD_2rus
    536870923U,	// ADD_3r
    1107296272U,	// ADJCALLSTACKDOWN
    1140850704U,	// ADJCALLSTACKUP
    553648145U,	// ANDNOT_2r
    536870937U,	// AND_3r
    536870942U,	// ASHR_l2rus
    536870942U,	// ASHR_l3r
    637534244U,	// BAU_1r
    541065257U,	// BITREV_l2r
    637534257U,	// BLA_1r
    637534262U,	// BL_lu10
    637534262U,	// BL_u10
    541065274U,	// BRBF_lru6
    541065274U,	// BRBF_ru6
    541065278U,	// BRBT_lru6
    541065278U,	// BRBT_ru6
    637534274U,	// BRBU_lu6
    637534274U,	// BRBU_u6
    541065274U,	// BRFF_lru6
    541065274U,	// BRFF_ru6
    541065278U,	// BRFT_lru6
    541065278U,	// BRFT_ru6
    637534274U,	// BRFU_lu6
    637534274U,	// BRFU_u6
    1744830534U,	// BR_JT
    1778384966U,	// BR_JT32
    541065291U,	// BYTEREV_l2r
    541065300U,	// CLZ_l2r
    536871001U,	// DIVS_l3r
    536871007U,	// DIVU_l3r
    637534309U,	// ECALLF_1r
    637534317U,	// ECALLT_1r
    637534325U,	// ENTSP_lu6
    637534325U,	// ENTSP_u6
    536871036U,	// EQ_2rus
    536871036U,	// EQ_3r
    637534336U,	// EXTSP_lu6
    637534336U,	// EXTSP_u6
    135U,	// GETID_0R
    537919635U,	// LADD_l5r
    545259673U,	// LD16S_3r
    545259680U,	// LD8U_3r
    549453990U,	// LDA16B_l3r
    545259686U,	// LDA16F_l3r
    637534381U,	// LDAP_lu10
    637534381U,	// LDAP_lu10_ba
    637534381U,	// LDAP_u10
    549454008U,	// LDAWB_l2rus
    549454008U,	// LDAWB_l3r
    2147483838U,	// LDAWCP_lu6
    2147483838U,	// LDAWCP_u6
    738197688U,	// LDAWDP_lru6
    738197688U,	// LDAWDP_ru6
    1308622864U,	// LDAWFI
    545259704U,	// LDAWF_l2rus
    545259704U,	// LDAWF_l3r
    805306552U,	// LDAWSP_lru6
    805306552U,	// LDAWSP_lru6_RRegs
    805306552U,	// LDAWSP_ru6
    805306552U,	// LDAWSP_ru6_RRegs
    541065420U,	// LDC_lru6
    541065420U,	// LDC_ru6
    537919697U,	// LDIV_l5r
    838861015U,	// LDWCP_lru6
    838861015U,	// LDWCP_ru6
    738197719U,	// LDWDP_lru6
    738197719U,	// LDWDP_ru6
    1409286160U,	// LDWFI
    805306583U,	// LDWSP_lru6
    805306583U,	// LDWSP_ru6
    545259735U,	// LDW_2rus
    545259735U,	// LDW_3r
    538443996U,	// LMUL_l6r
    536871138U,	// LSS_3r
    537919719U,	// LSUB_l5r
    536871149U,	// LSU_3r
    538968306U,	// MACCS_l4r
    538968313U,	// MACCU_l4r
    541065472U,	// MKMSK_2r
    541065472U,	// MKMSK_rus
    536871175U,	// MUL_l3r
    541065484U,	// NEG
    541065489U,	// NOT
    536871190U,	// OR_3r
    536871194U,	// REMS_l3r
    536871200U,	// REMU_l3r
    637534502U,	// RETSP_lu6
    637534502U,	// RETSP_u6
    1442840592U,	// SELECT_CC
    637534509U,	// SETSP_1r
    553648438U,	// SEXT_rus
    536871228U,	// SHL_2rus
    536871228U,	// SHL_3r
    536871233U,	// SHR_2rus
    536871233U,	// SHR_3r
    545259846U,	// ST16_l3r
    545259852U,	// ST8_l3r
    738197841U,	// STWDP_lru6
    738197841U,	// STWDP_ru6
    1476395024U,	// STWFI
    805306705U,	// STWSP_lru6
    805306705U,	// STWSP_ru6
    545259857U,	// STW_2rus
    545259857U,	// STW_3r
    536871254U,	// SUB_2rus
    536871254U,	// SUB_3r
    536871259U,	// XOR_l3r
    553648480U,	// ZEXT_rus
    0U
  };

  const char *AsmStrs = 
    "DBG_VALUE\000add \000\000andnot \000and \000ashr \000bau \000bitrev \000"
    "bla \000bl \000bf \000bt \000bu \000bru \000byterev \000clz \000divs \000"
    "divu \000ecallf \000ecallt \000entsp \000eq \000extsp \000get r11, id\000"
    "ladd \000ld16s \000ld8u \000lda16 \000ldap r11, \000ldaw \000ldaw r11, "
    "cp[\000ldc \000ldiv \000ldw \000lmul \000lss \000lsub \000lsu \000maccs"
    " \000maccu \000mkmsk \000mul \000neg \000not \000or \000rems \000remu \000"
    "retsp \000set sp, \000sext \000shl \000shr \000st16 \000st8 \000stw \000"
    "sub \000xor \000zext \000";

  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 511)-1;


  // Fragment 0 encoded into 3 bits for 5 unique commands.
  switch ((Bits >> 29) & 7) {
  default:   // unreachable.
  case 0:
    // DBG_VALUE, GETID_0R
    return;
    break;
  case 1:
    // ADD_2rus, ADD_3r, ANDNOT_2r, AND_3r, ASHR_l2rus, ASHR_l3r, BAU_1r, BIT...
    printOperand(MI, 0, O); 
    break;
  case 2:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, LDAWFI, LDWFI, SELECT_CC, STWFI
    PrintSpecial(MI, O, "comment"); 
    break;
  case 3:
    // BR_JT, BR_JT32
    printOperand(MI, 1, O); 
    O << "\n"; 
    break;
  case 4:
    // LDAWCP_lu6, LDAWCP_u6
    printMemOperand(MI, 0, O); 
    O << ']'; 
    return;
    break;
  }


  // Fragment 1 encoded into 4 bits for 13 unique commands.
  switch ((Bits >> 25) & 15) {
  default:   // unreachable.
  case 0:
    // ADD_2rus, ADD_3r, ANDNOT_2r, AND_3r, ASHR_l2rus, ASHR_l3r, BITREV_l2r,...
    O << ", "; 
    break;
  case 1:
    // ADJCALLSTACKDOWN
    O << " ADJCALLSTACKDOWN "; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 2:
    // ADJCALLSTACKUP
    O << " ADJCALLSTACKUP "; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 3:
    // BAU_1r, BLA_1r, BL_lu10, BL_u10, BRBU_lu6, BRBU_u6, BRFU_lu6, BRFU_u6,...
    return;
    break;
  case 4:
    // BR_JT
    printInlineJT(MI, 0, O); 
    return;
    break;
  case 5:
    // BR_JT32
    printInlineJT32(MI, 0, O); 
    return;
    break;
  case 6:
    // LDAWDP_lru6, LDAWDP_ru6, LDWDP_lru6, LDWDP_ru6, STWDP_lru6, STWDP_ru6
    O << ", dp["; 
    printMemOperand(MI, 1, O); 
    O << ']'; 
    return;
    break;
  case 7:
    // LDAWFI
    O << " LDAWFI "; 
    printOperand(MI, 0, O); 
    O << ", "; 
    printMemOperand(MI, 1, O); 
    return;
    break;
  case 8:
    // LDAWSP_lru6, LDAWSP_lru6_RRegs, LDAWSP_ru6, LDAWSP_ru6_RRegs, LDWSP_lr...
    O << ", sp["; 
    printOperand(MI, 1, O); 
    O << ']'; 
    return;
    break;
  case 9:
    // LDWCP_lru6, LDWCP_ru6
    O << ", cp["; 
    printOperand(MI, 1, O); 
    O << ']'; 
    return;
    break;
  case 10:
    // LDWFI
    O << " LDWFI "; 
    printOperand(MI, 0, O); 
    O << ", "; 
    printMemOperand(MI, 1, O); 
    return;
    break;
  case 11:
    // SELECT_CC
    O << " SELECT_CC PSEUDO!"; 
    return;
    break;
  case 12:
    // STWFI
    O << " STWFI "; 
    printOperand(MI, 0, O); 
    O << ", "; 
    printMemOperand(MI, 1, O); 
    return;
    break;
  }


  // Fragment 2 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 24) & 1) {
    // ANDNOT_2r, SEXT_rus, ZEXT_rus
    printOperand(MI, 2, O); 
    return;
  } else {
    // ADD_2rus, ADD_3r, AND_3r, ASHR_l2rus, ASHR_l3r, BITREV_l2r, BRBF_lru6,...
    printOperand(MI, 1, O); 
  }


  // Fragment 3 encoded into 2 bits for 4 unique commands.
  switch ((Bits >> 22) & 3) {
  default:   // unreachable.
  case 0:
    // ADD_2rus, ADD_3r, AND_3r, ASHR_l2rus, ASHR_l3r, DIVS_l3r, DIVU_l3r, EQ...
    O << ", "; 
    break;
  case 1:
    // BITREV_l2r, BRBF_lru6, BRBF_ru6, BRBT_lru6, BRBT_ru6, BRFF_lru6, BRFF_...
    return;
    break;
  case 2:
    // LD16S_3r, LD8U_3r, LDA16F_l3r, LDAWF_l2rus, LDAWF_l3r, LDW_2rus, LDW_3...
    O << '['; 
    printOperand(MI, 2, O); 
    O << ']'; 
    return;
    break;
  case 3:
    // LDA16B_l3r, LDAWB_l2rus, LDAWB_l3r
    O << "[-"; 
    printOperand(MI, 2, O); 
    O << ']'; 
    return;
    break;
  }


  // Fragment 4 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 21) & 1) {
    // MACCS_l4r, MACCU_l4r
    printOperand(MI, 4, O); 
    O << ", "; 
    printOperand(MI, 5, O); 
    return;
  } else {
    // ADD_2rus, ADD_3r, AND_3r, ASHR_l2rus, ASHR_l3r, DIVS_l3r, DIVU_l3r, EQ...
    printOperand(MI, 2, O); 
  }


  // Fragment 5 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 20) & 1) {
    // LADD_l5r, LDIV_l5r, LMUL_l6r, LSUB_l5r
    O << ", "; 
    printOperand(MI, 3, O); 
    O << ", "; 
    printOperand(MI, 4, O); 
  } else {
    // ADD_2rus, ADD_3r, AND_3r, ASHR_l2rus, ASHR_l3r, DIVS_l3r, DIVU_l3r, EQ...
    return;
  }


  // Fragment 6 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 19) & 1) {
    // LMUL_l6r
    O << ", "; 
    printOperand(MI, 5, O); 
    return;
  } else {
    // LADD_l5r, LDIV_l5r, LSUB_l5r
    return;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
const char *XCoreAsmPrinter::getRegisterName(unsigned RegNo) {
  assert(RegNo && RegNo < 17 && "Invalid register number!");

  static const unsigned RegAsmOffset[] = {
    0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 
    43, 47, 0
  };

  const char *AsmStrs =
    "cp\000dp\000lr\000r0\000r1\000r2\000r3\000r4\000r5\000r6\000r7\000r8\000"
    "r9\000r10\000r11\000sp\000";
  return AsmStrs+RegAsmOffset[RegNo-1];
}


#ifdef GET_INSTRUCTION_NAME
#undef GET_INSTRUCTION_NAME

/// getInstructionName: This method is automatically generated by tblgen
/// from the instruction set description.  This returns the enum name of the
/// specified instruction.
const char *XCoreAsmPrinter::getInstructionName(unsigned Opcode) {
  assert(Opcode < 123 && "Invalid instruction number!");

  static const unsigned InstAsmOffset[] = {
    0, 4, 14, 27, 36, 45, 50, 65, 79, 92, 106, 123, 133, 146, 
    151, 160, 167, 184, 199, 209, 216, 227, 236, 243, 254, 261, 269, 276, 
    286, 295, 305, 314, 323, 331, 341, 350, 360, 369, 378, 386, 392, 400, 
    412, 420, 429, 438, 448, 458, 468, 477, 485, 491, 501, 510, 519, 528, 
    537, 545, 556, 567, 577, 590, 599, 611, 621, 632, 642, 654, 665, 672, 
    684, 694, 706, 724, 735, 752, 761, 769, 778, 789, 799, 810, 820, 826, 
    837, 847, 856, 863, 872, 879, 888, 895, 905, 915, 924, 934, 942, 946, 
    950, 956, 965, 974, 984, 993, 1003, 1012, 1021, 1030, 1037, 1046, 1053, 1062, 
    1070, 1081, 1091, 1097, 1108, 1118, 1127, 1134, 1143, 1150, 1158, 0
  };

  const char *Strs =
    "PHI\000INLINEASM\000PROLOG_LABEL\000EH_LABEL\000GC_LABEL\000KILL\000EXT"
    "RACT_SUBREG\000INSERT_SUBREG\000IMPLICIT_DEF\000SUBREG_TO_REG\000COPY_T"
    "O_REGCLASS\000DBG_VALUE\000REG_SEQUENCE\000COPY\000ADD_2rus\000ADD_3r\000"
    "ADJCALLSTACKDOWN\000ADJCALLSTACKUP\000ANDNOT_2r\000AND_3r\000ASHR_l2rus"
    "\000ASHR_l3r\000BAU_1r\000BITREV_l2r\000BLA_1r\000BL_lu10\000BL_u10\000"
    "BRBF_lru6\000BRBF_ru6\000BRBT_lru6\000BRBT_ru6\000BRBU_lu6\000BRBU_u6\000"
    "BRFF_lru6\000BRFF_ru6\000BRFT_lru6\000BRFT_ru6\000BRFU_lu6\000BRFU_u6\000"
    "BR_JT\000BR_JT32\000BYTEREV_l2r\000CLZ_l2r\000DIVS_l3r\000DIVU_l3r\000E"
    "CALLF_1r\000ECALLT_1r\000ENTSP_lu6\000ENTSP_u6\000EQ_2rus\000EQ_3r\000E"
    "XTSP_lu6\000EXTSP_u6\000GETID_0R\000LADD_l5r\000LD16S_3r\000LD8U_3r\000"
    "LDA16B_l3r\000LDA16F_l3r\000LDAP_lu10\000LDAP_lu10_ba\000LDAP_u10\000LD"
    "AWB_l2rus\000LDAWB_l3r\000LDAWCP_lu6\000LDAWCP_u6\000LDAWDP_lru6\000LDA"
    "WDP_ru6\000LDAWFI\000LDAWF_l2rus\000LDAWF_l3r\000LDAWSP_lru6\000LDAWSP_"
    "lru6_RRegs\000LDAWSP_ru6\000LDAWSP_ru6_RRegs\000LDC_lru6\000LDC_ru6\000"
    "LDIV_l5r\000LDWCP_lru6\000LDWCP_ru6\000LDWDP_lru6\000LDWDP_ru6\000LDWFI"
    "\000LDWSP_lru6\000LDWSP_ru6\000LDW_2rus\000LDW_3r\000LMUL_l6r\000LSS_3r"
    "\000LSUB_l5r\000LSU_3r\000MACCS_l4r\000MACCU_l4r\000MKMSK_2r\000MKMSK_r"
    "us\000MUL_l3r\000NEG\000NOT\000OR_3r\000REMS_l3r\000REMU_l3r\000RETSP_l"
    "u6\000RETSP_u6\000SELECT_CC\000SETSP_1r\000SEXT_rus\000SHL_2rus\000SHL_"
    "3r\000SHR_2rus\000SHR_3r\000ST16_l3r\000ST8_l3r\000STWDP_lru6\000STWDP_"
    "ru6\000STWFI\000STWSP_lru6\000STWSP_ru6\000STW_2rus\000STW_3r\000SUB_2r"
    "us\000SUB_3r\000XOR_l3r\000ZEXT_rus\000";
  return Strs+InstAsmOffset[Opcode];
}

#endif
