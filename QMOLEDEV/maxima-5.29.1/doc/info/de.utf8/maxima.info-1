This is maxima.info, produced by makeinfo version 4.13 from
/home/robert/maxima/maxima-git/maxima-code/doc/info/de.utf8//include-maxima.de.texi.

Das ist ein Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Ein Computer Algebra System.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Top,  Next: Einführung in Maxima,  Prev: (dir),  Up: (dir)

Maxima Manual
*************

Maxima ist ein Computeralgebrasystem, das in Lisp programmiert ist.

Maxima basiert auf Macsyma, das am MIT (Massachusetts Institute of
Technology) in den Jahren 1968 bis 1982 als Teil des Projektes MAC
entwickelt wurde.  Das Department of Energy (DOE) erhielt im Jahr 1982
den Quellcode vom MIT; diese Version ist als DOE Macsyma bekannt.
Professor William F. Schelter von der University of Texas hat von 1982
bis zu seinem Tod im Jahr 2001 eine Kopie von DOE Macsyma gepflegt.  Im
Jahr 1998 erhielt Schelter vom Department of Energy die Erlaubnis, den
Quellcode von DOE Macsyma unter der GNU Public Lizenz zu
veröffentlichen.  Im Jahr 2000 initiierte Schelter das Maxima Projekt
bei SourceForge, um DOE Macsyma, heute Maxima genannt, weiter zu
entwickeln.


Dieses Dokument ist eine Übersetzung des englischen Maxima Manuals in
die deutsche Sprache.  Das Manual ist noch nicht vollständig übersetzt.
Damit keine Inhalte fehlen, sind die nicht übersetzten Teile in der
englischen Sprache eingefügt.  Dieses Manual ist nicht nur eine
Übersetzung, sondern auch der Versuch, die Inhalte neu zu organisieren
und zu überarbeiten.  Ziel ist, ein besser lesbares und
übersichtlicheres Manual zu erhalten.  Diese Arbeit soll auch in das
englische Original einfließen.  Die jeweils aktuelle Version des
Manuals ist unter `http://crategus.users.sourceforge.net/maxima.html'
verfügbar.

Dr. Dieter Kaiser, 14.02.2011


* Menu:


Maxima Grundlagen

* Einführung in Maxima::      Erste Beispiele mit Maxima.
* Programmfehler::              Programmfehler finden und berichten.
* Hilfe::                       Hilfe in einer Maxima-Sitzung erhalten.
* Kommandozeile::               Eingaben und Ausgaben der Konsole.
* Datentypen und Strukturen::   Ganze, rationale und Gleitkommazahlen,
                                Konstante, Zeichenketten, Listen und Arrays.
* Ausdrücke::                 Ausdrücke in Maxima.
* Operatoren::                  Operatoren in Maxima.
* Auswertung::                  Auswertung von Ausdrücken.
* Vereinfachung::               Vereinfachung von Ausdrücken.
* Mathematische Funktionen::    Mathematische Funktionen in Maxima.
* Maximas Datenbank::           Deklarationen, Kontexte, Fakten und
                                Eigenschaften.
* Grafische Darstellung::       2D and 3D grafische Ausgabe.
* Eingabe und Ausgabe::         Lesen und Schreiben von Dateien mit Maxima.


Spezifische Gebiete der Mathematik

* Mengen::                      Methoden für Mengen.
* Summen Produkte und Reihen::  Summen, Produkte, Taylorreihen und
                                Poissonreihen.
* Analysis::                    Grenzwerte, Differentiation, Integration,
                                Differentialgleichungen.
* Polynome::                    Polynome und rationale Funktionen.
* Gleichungen::                 Lösen von Gleichungen.
* Lineare Algebra::             Matrizen und Vektoren.
* Tensoren::                    (Englisch) Methoden der Tensorrechnung.
* Zahlentheorie::               Funktionen der Zahlentheorie.
* Spezielle Funktionen::        Spezielle Mathematische Funktionen.
* Fourier-Transformationen::    Fourier-Transformationen und Fourierreihen.


Fortgeschrittene Möglichkeiten und Programmierung

* Muster und Regeln::           Nutzerdefinierte Muster und Regeln
                                für die Vereinfachung.
* Funktionsdefinitionen::       Definition von Maxima-Funktionen.
* Laufzeitumgebung::            Anpassung der Maxima-Umgebung.
* Programmierung::              Maxima-Programme schreiben.
* Übersetzer::                Maxima-Programme übersetzen und kompilieren.
* Fehlersuche::                 Fehlersuche in Programmen.
* Verschiedenes::               Sonstige Funktionen und Variablen.


Zusätzliche Pakete (Englisch)

* abs_integrate::               Integrals for the functions abs, signum, ...
* affine::
* asympa::                      Asymptotic analysis package
* augmented_lagrangian::        augmented_lagrangian package.
* bernstein::                   Bernstein polynomials.
* bode::                        Bode gain and phase plots.
* cobyla::                      Nonlinear optimization with inequality
                                constraints.
* contrib_ode::                 Additional routines for ODEs
* Package descriptive::         Descriptive statistics.
* diag::                        Jordan matrices.
* Package distrib::             Probability distributions.
* draw::                        A Maxima-Gnuplot interface.
* drawdf::                      Direction fields with Gnuplot.
* dynamics::                    Graphics for dynamical systems and fractals.
* ezunits::                     Dimensional quantities.
* f90::                         Maxima to fortran translator.
* finance::                     Financial package.
* fractals::                    Fractals.
* ggf::                         Generating function of sequences.
* graphs::                      Graph theory package.
* grobner::                     Functions for working with Groebner bases.
* groups::                      Abstract algebra.
* impdiff::                     Implicit derivatives.
* interpol::                    Interpolation package.
* lapack::                      LAPACK functions for linear algebra.
* lbfgs::                       L-BFGS unconstrained minimization package.
* lindstedt::                   Lindstedt package.
* linearalgebra::               Functions for linear algebra.
* lsquares::                    Least squares.
* makeOrders::                  Polynomial utility.
* minpack::                     MINPACK functions for minimization and roots
* mnewton::                     Newton-Verfahren
* numericalio::                 Reading and writing files.
* opsubst::                     Substitutions utility.
* orthopoly::                   Orthogonal polynomials.
* plotdf::                      Direction fields plots.
* romberg::                     Romberg method for numerical integration.
* simplex::                     Linear programming.
* simplification::              Simplification rules and functions.
* solve_rec::                   Linear recurrences.
* stats::                       Statistical inference package.
* stirling::                    Stirling formula.
* stringproc::                  String processing.
* symmetries::
* to_poly_solve::               to_poly_solve package.
* unit::                        Units and dimensions package.
* zeilberger::                  Functions for hypergeometric summation.


Glossar
* Glossar::                     Erläuterung von Begriffen.


Index
* Index der Variablen und Funktionen::

Ausführliches Inhaltsverzeichnis

Einführung
* Einführung in Maxima::

Programmfehler
* Einführung in Programmfehler::
* Funktionen und Variablen für Programmfehler::

Hilfe
* Dokumentation::
* Funktionen und Variablen der Hilfe::

Kommandozeile
* Einführung in die Kommandozeile::
* Funktionen und Variablen der Eingabe::
* Funktionen und Variablen der Ausgabe::

Datentypen und Strukturen
* Zahlen::
* Zeichenketten::
* Funktionen und Variablen für Konstante::
* Listen::
* Arrays::
* Strukturen::

Ausdrücke
* Einführung in Ausdrücke::
* Substantive und Verben::
* Bezeichner::
* Funktionen und Variablen für Ausdrücke::

Operatoren
* Einführung in Operatoren::
* Arithmetische Operatoren::
* Relationale Operatoren::
* Logische Operatoren::
* Operatoren für Gleichungen::
* Zuweisungsoperatoren::
* Nutzerdefinierte Operatoren::

Auswertung
* Einführung in die Auswertung::
* Funktionen und Variablen für die Auswertung::

Vereinfachung
* Einführung in die Vereinfachung::
* Funktionen und Variablen für die Vereinfachung::

Mathematische Funktionen
* Funktionen für Zahlen::
* Funktionen für komplexe Zahlen::
* Funktionen der Kombinatorik::
* Wurzel-, Exponential- und Logarithmusfunktion::
* Winkelfunktionen::
* Einführung in Winkelfunktionen::
* Funktionen und Variablen für Winkelfunktionen::
* Hyperbelfunktionen::
* Einführung in Hyperbelfunktionen::
* Funktionen und Variablen für Hyperbelfunktionen::
* Zufallszahlen::

Maximas Datenbank
* Einführung in Maximas Datenbank::
* Funktionen und Variablen für Eigenschaften::
* Funktionen und Variablen für Fakten::
* Funktionen und Variablen für Aussagen::

Grafische Darstellung
* Einführung in die grafische Darstellung::
* Grafikformate::
* Funktionen und Variablen für die grafische Darstellung::
* Grafikoptionen::
* Gnuplot Optionen::
* Gnuplot_pipes Formatfunktionen::

Eingabe und Ausgabe
* Kommentare::
* Dateien::
* Funktionen und Variablen für die Eingabe und Ausgabe::
* Funktionen und Variablen für die TeX-Ausgabe::
* Funktionen und Variablen für die Fortran-Ausgabe::

Mengen
* Einführung in Mengen::
* Funktionen und Variablen für Mengen::

Summen, Produkte und Reihen
* Summen und Produkte::
* Einführung in Reihen::
* Funktionen und Variablen für Reihen::
* Poisson Reihen::
* Kettenbrüche::

Analysis
* Funktionen und Variablen für Grenzwerte::
* Funktionen und Variablen der Differentiation::
* Integration::
* Differentialgleichungen::

Polynome
* Einführung in Polynome::
* Funktionen und Variablen für Polynome::

Gleichungen
* Funktionen und Variablen für Gleichungen::

Lineare Algebra
* Einführung in die lineare Algebra::
* Nicht-kommutative Multiplikation::
* Vektoren::
* Eigenwerte::
* Funktionen und Variablen der linearen Algebra::

Tensoren
* Tensorpakete in Maxima::
* Paket itensor::
* Paket ctensor::
* Paket atensor::

Zahlentheorie
* Funktionen und Variablen der Zahlentheorie::

Spezielle Funktionen
* Einführung für spezielle Funktionen::
* Bessel-Funktionen und verwandte Funktionen::
* Gammafunktionen und verwandte Funktionen::
* Exponentielle Integrale::
* Fehlerfunktionen::
* Elliptische Funktionen und Integrale::
* Hypergeometrische Funktionen::
* Weitere spezielle Funktionen::

Fourier-Transformationen
* Einführung in die schnelle Fourier-Transformation::
* Funktionen und Variablen für die schnelle Fourier-Transformation::
* Einführung in Fourierreihen::
* Funktionen und Variablen für Fourierreihen::

Muster und Regeln
* Einführung in Muster und Regeln::
* Funktionen und Variablen für Muster und Regeln::

Funktionsdefinitionen
* Funktionen::
* Makros::
* Funktionen und Variablen für Funktionsdefinitionen::

Laufzeitumgebung
* Initialisierung von Maxima::
* Interrupts::
* Funktionen und Variablen der Laufzeitumgebung::

Programmierung
* Lisp und Maxima::
* Einführung in die Programmierung::
* Funktionen und Variablen der Programmierung::

Übersetzer
* Einführung in den Übersetzer::
* Funktionen und Variablen des Übersetzers::

Fehlersuche
* Quellcode-Debugger::
* Debugger-Kommandos::
* Funktionen und Variablen der Fehlersuche::

Verschiedenes
* Einführung in Verschiedenes::
* Share-Pakete::
* Funktionen und Variablen für Verschiedenes::

abs_integrate
* Introduction to abs_integrate::
* Functions and Variables for abs_integrate::

affine
* Introduction to Affine::
* Functions and Variables for Affine::

asympa
* Introduction to asympa::
* Functions and variables for asympa::

augmented_lagrangian
* Functions and Variables for augmented_lagrangian::

bernstein
* Functions and Variables for Bernstein::

bode
* Functions and Variables for bode::

cobyla
* Introduction to cobyla::
* Functions and Variables for cobyla::
* Examples for cobyla::

contrib_ode
* Introduction to contrib_ode::
* Functions and Variables for contrib_ode::
* Possible improvements to contrib_ode::
* Test cases for contrib_ode::
* References for contrib_ode::

Package descriptive
* Introduction to descriptive::
* Functions and Variables for data manipulation::
* Functions and Variables for descriptive statistics::
* Functions and Variables for specific multivariate descriptive statistics::
* Functions and Variables for statistical graphs::

diag
* Functions and Variables for diag::

Package distrib
* Introduction to distrib::
* Functions and Variables for continuous distributions::
* Functions and Variables for discrete distributions::

draw
* Introduction to draw::
* Functions and Variables for draw::
* Functions and Variables for pictures::
* Functions and Variables for worldmap::

drawdf
* Introduction to drawdf::
* Functions and Variables for drawdf::

dynamics
* Introduction to dynamics::
* Functions and Variables for dynamics::

ezunits
* Introduction to ezunits::
* Introduction to physical_constants::
* Functions and Variables for ezunits::

f90
* Functions and Variables for f90::

finance
* Introduction to finance::
* Functions and Variables for finance::

fractals
* Introduction to fractals::
* Definitions for IFS fractals::
* Definitions for complex fractals::
* Definitions for Koch snowflakes::
* Definitions for Peano maps::

ggf
* Functions and Variables for ggf::

graphs
* Introduction to graphs::
* Functions and Variables for graphs::

grobner
* Introduction to grobner::
* Functions and Variables for grobner::

groups
* Functions and Variables for Groups::

impdiff
* Functions and Variables for impdiff::

interpol
* Introduction to interpol::
* Functions and Variables for interpol::

lapack
* Introduction to lapack::
* Functions and Variables for lapack::

lbfgs
* Introduction to lbfgs::
* Functions and Variables for lbfgs::

lindstedt
* Functions and Variables for lindstedt::

linearalgebra
* Introduction to linearalgebra::
* Functions and Variables for linearalgebra::

lsquares
* Introduction to lsquares::
* Functions and Variables for lsquares::

makeOrders
* Functions and Variables for makeOrders::

mnewton
* Einführung in mnewton::
* Funktionen und Variablen für mnewton::

numericalio
* Introduction to numericalio::
* Functions and Variables for plain-text input and output::
* Functions and Variables for binary input and output::

opsubst
* Functions and Variables for opsubst::

orthopoly
* Introduction to orthogonal polynomials::
* Functions and Variables for orthogonal polynomials::

plotdf
* Introduction to plotdf::
* Functions and Variables for plotdf::

romberg
* Functions and Variables for romberg::

simplex
* Introduction to simplex::
* Functions and Variables for simplex::

simplification
* Introduction to simplification::
* Package absimp::
* Package facexp::
* Package functs::
* Package ineq::
* Package rducon::
* Package scifac::
* Package sqdnst::

solve_rec
* Introduction to solve_rec::
* Functions and Variables for solve_rec::

stats
* Introduction to stats::
* Functions and Variables for inference_result::
* Functions and Variables for stats::
* Functions and Variables for special distributions::

stirling
* Functions and Variables for stirling::

stringproc
* Introduction to string processing::
* Functions and Variables for input and output::
* Functions and Variables for characters::
* Functions and Variables for strings::

symmetries
* Introduction to Symmetries::
* Functions and Variables for Symmetries::

to_poly_solve
* Functions and Variables for to_poly_solve::

unit
* Introduction to Units::
* Functions and Variables for Units::

zeilberger
* Introduction to zeilberger::
* Functions and Variables for zeilberger::

Glossar
* Glossar::


File: maxima.info,  Node: Einführung in Maxima,  Next: Programmfehler,  Prev: Top,  Up: Top

1 Einführung in Maxima
**********************

Von einer Kommandozeile wird Maxima mit dem Kommando `maxima' gestartet.
Maxima zeigt die aktuelle Version an und gibt einen Prompt für die
Eingabe aus.  Ein Maxima-Kommando wird mit einem Semikolon `;'
abgeschlossen.  Eine Maxima-Sitzung wird mit dem Kommando `quit();'
beendet.  Es folgt ein Beispiel für eine Sitzung.

     [wfs@chromium]$ maxima
     Maxima 5.9.1 http://maxima.sourceforge.net
     Using Lisp CMU Common Lisp 19a
     Distributed under the GNU Public License. See the file COPYING.
     Dedicated to the memory of William Schelter.
     This is a development version of Maxima. The function bug_report()
     provides bug reporting information.
     (%i1) factor(10!);
                                 8  4  2
     (%o1)                      2  3  5  7
     (%i2) expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o2) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i3) factor (x^6 - 1);
                                   2            2
     (%o3)       (x - 1) (x + 1) (x  - x + 1) (x  + x + 1)
     (%i4) quit();
     [wfs@chromium]$

Maxima kann Hilfetexte anzeigen.  Das Kommando `describe(text)' zeigt
alle Inhalte an, die die Zeichenkette `text' enthalten.  Das
Fragezeichen `?'  (exakte Suche) und zwei Fragezeichen `??'  (ungenaue
Suche) sind abkürzende Schreibweisen für die Funktion `describe'.

     (%i1) ?? integrat

      0: Functions and Variables for Integration
      1: Introduction to Integration
      2: integrate (Functions and Variables for Integration)
      3: integrate_use_rootsof (Functions and Variables for Integration)
      4: integration_constant (Functions and Variables for Integration)
      5: integration_constant_counter (Functions and Variables for
         Integration)
     Enter space-separated numbers, `all' or `none': 4

      -- System variable: integration_constant
          Default value: `%c'

          When a constant of integration is introduced by indefinite
          integration of an equation, the name of the constant is
          constructed by concatenating `integration_constant' and
          `integration_constant_counter'.

          `integration_constant' may be assigned any symbol.

          Examples:

               (%i1) integrate (x^2 = 1, x);
                                          3
                                         x
               (%o1)                     -- = x + %c1
                                         3
               (%i2) integration_constant : 'k;
               (%o2)                           k
               (%i3) integrate (x^2 = 1, x);
                                           3
                                          x
               (%o3)                      -- = x + k2
                                          3


     (%o1)                                true

Das Ergebnis einer Rechnung wird mit dem Operator `:'  einer Variablen
zugewiesen.  Weiterhin speichert Maxima die Eingaben unter den Marken
`(%i)'  und die Ergebnisse unter den Marken `(%o)'  ab.  Die Marken
erhalten eine fortlaufende Nummerierung.  Mit diesen Marken kann auf
frühere Eingaben und Ergebnisse zurückgegriffen werden.  Auf das letzte
Ergebnis kann mit `%'  zurückgegriffen werden.

     (%i1) u: expand ((x + y)^6);
                6        5       2  4       3  3       4  2      5      6
     (%o1)     y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i2) diff(u,x);
                     5         4       2  3       3  2       4        5
     (%o2)        6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (%i3) factor(%o2);
                                                5
     (%o3)                             6 (y + x)
     (%i4) %/6;
                                               5
     (%o4)                              (y + x)

Maxima kennt numerische Konstanten wie die Kreiszahl `%pi'  oder die
imaginäre Einheit `%i'  und kann mit komplexen Zahlen rechnen.  Mit der
Funktion `rectform'  wird eine komplexe Zahl in die Standardform
gebracht, mit der Funktion `polarform'  wird eine komplexe Zahl in der
Polarform dargestellt.

     (%i1) cos(%pi);
     (%o1)                          - 1
     (%i2) exp(%i*%pi);
     (%o2)                          - 1
     (%i3) rectform((1+%i)/(1-%i));
     (%o3)                          %i
     (%i4) polarform((1+%i)/(1-%i));
                                   %i %pi
                                   ------
                                     2
     (%o4)                       %e

Maxima kann mit der Funktion `diff'  differenzieren und mit der Funktion
`integrate'  integrieren.

     (%i1) u: expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o1) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i2) diff (%, x);
              5         4       2  3       3  2       4        5
     (%o2) 6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (%i3) integrate (1/(1 + x^3), x);
                                       2 x - 1
                     2            atan(-------)
                log(x  - x + 1)        sqrt(3)    log(x + 1)
     (%o3)    - --------------- + ------------- + ----------
                       6             sqrt(3)          3

Mit den Funktionen `linsolve'  und `solve'  kann Maxima lineare
Gleichungssysteme und kubische Gleichungen lösen.

     (%i1) linsolve ([3*x + 4*y = 7, 2*x + a*y = 13], [x, y]);
                             7 a - 52        25
     (%o1)              [x = --------, y = -------]
                             3 a - 8       3 a - 8
     (%i2) solve (x^3 - 3*x^2 + 5*x = 15, x);
     (%o2)       [x = - sqrt(5) %i, x = sqrt(5) %i, x = 3]

Die Funktion `solve'  kann auch nichtlineare Gleichungssysteme lösen.
Wird eine Eingabe mit `$'  anstatt `;'  abgeschlossen, wird keine
Ausgabe erzeugt.

     (%i1) eq_1: x^2 + 3*x*y + y^2 = 0$
     (%i2) eq_2: 3*x + y = 1$
     (%i3) solve ([eq_1, eq_2]);
                   3 sqrt(5) + 7      sqrt(5) + 3
     (%o3) [[y = - -------------, x = -----------],
                         2                 2

                                    3 sqrt(5) - 7        sqrt(5) - 3
                               [y = -------------, x = - -----------]]
                                          2                   2

Mit den Funktionen `plot2d'  und `plot3d'  kann Maxima Funktionsgraphen
mit einer oder mehreren Funktionen zeichnen.

     (%i1) plot2d(sin(x)/x, [x, -20, 20])$

     (%i2) plot2d([atan(x), erf(x), tanh(x)], [x, -5, 5], [y, -1.5, 2])$

     (%i3) plot3d(sin(sqrt(x^2 + y^2))/sqrt(x^2 + y^2),
              [x, -12, 12], [y, -12, 12])$


File: maxima.info,  Node: Programmfehler,  Next: Hilfe,  Prev: Einführung in Maxima,  Up: Top

2 Programmfehler
****************

* Menu:

* Einführung in Programmfehler::
* Funktionen und Variablen für Programmfehler::


File: maxima.info,  Node: Einführung in Programmfehler,  Next: Funktionen und Variablen für Programmfehler,  Prev: Programmfehler,  Up: Programmfehler

2.1 Einführung in Programmfehler
================================

Maxima wird ständig weiterentwickelt.  Der Funktionsumfang wird
erweitert und Fehler, die bei einem Programm dieser Komplexität kaum zu
vermeiden sind, werden korrigiert.  Fehler können berichtet werden.
Werden ausreichend Informationen mitgeteilt, können die Entwickler
Maxima weiter verbessern.  Ein aktueller Link zur Webseite zum
Berichten von Fehlern sowie die notwendigen Informationen über die
Maxima-Installation werden mit der Funktion `bug_report'  angezeigt.
Um die Installation auf dem Rechner zu testen, kann die
Maxima-Testsuite mit der Funktion `run_testsuite'  ausgeführt werden.
Die folgende Übersicht zeigt die Funktionen und Variablen für das
Testen der Installation und das Berichten von Fehlern:

   run_testsuite     testsuite_files     bug_report     build_info


File: maxima.info,  Node: Funktionen und Variablen für Programmfehler,  Prev: Einführung in Programmfehler,  Up: Programmfehler

2.2 Funktionen und Variablen für Programmfehler
===============================================

 -- Funktion: run_testsuite ([<options>])
     Die Funktion `run_testsuite' führt die Maxima-Testsuite aus.
     Erfolgreiche Tests und Tests, die zwar nicht erfolgreich, aber als
     ein bekannter Fehler gekennzeichnet sind, geben die Meldung
     "passed".  `run_testsuite' akzeptiert die folgenden optionalen
     Schlüsselworte als Argumente:

    `display_all'
          Hat das Schlüsselwort `display_all' den Wert `true', werden
          alle Tests angezeigt.  Der Standardwert ist `false'.  In
          diesem Fall werden nur die Tests angezeigt, die fehlschlagen.

    `display_known_bugs'
          Hat das Schlüsselwort `display_known_bugs' den Wert `true',
          werden alle Tests angezeigt, die als fehlerhaft
          gekennzeichnet sind.  Der Standardwert ist `false'.

    `tests'
          Das Schlüsselwort `tests' erhält eine Liste mit den
          Testdateien, die ausgeführt werden sollen.  Eine Testdatei
          kann durch eine Zeichenkette oder ein Symbol angegeben
          werden.  Der Standard ist, dass alle Testdateien ausgeführt
          werden, die in der Optionsvariablen `testsuite_files'

          enthalten sind.

    `time'
          Hat das Schlüsselwort `time' den Wert `true', werden die
          Laufzeiten der einzelnen Testdateien angezeigt.  Hat `time'
          den Wert `all' und `display_all' den Wert `true', wird die
          Laufzeit jedes einzelnen Tests angezeigt.  Der Standardwert
          ist `false'.

     Das Ausführen einer Testdatei kann die Maxima-Umgebung ändern.
     Typischerweise führt eine Testdatei zuerst das Kommando
     `kill(all)' aus, um eine definierte Umgebung herzustellen, in der
     keine nutzerdefinierten Funktionen und Variablen vorhanden sind.
     Siehe auch die Funktion `kill'.

     Testdateien können auch von der Funktion `batch'  mit der Option
     `test' ausgeführt werden.  Siehe die Dokumentation der Funktion
     `batch' auch für ein Beispiel, wie eine Testdatei aufgebaut ist.

     `run_testsuite' hat den Rückgabewert `done'.

     Beispiele:

          (%i1) run_testsuite(tests = ["rtest1", rtest2]);
          Running tests in rtest1: 111/111 tests passed
          Running tests in rtest2: 66/66 tests passed

          No unexpected errors found out of 177 tests.
          Evaluation took:
            0.344 seconds of real time
            0.30402 seconds of total run time (0.30002 user, 0.00400 system)
            88.37% CPU
            581,206,031 processor cycles
            7,824,088 bytes consed

          (%o1)                         done

     Es werden zusätzlich alle Tests angezeigt.  Die Ausgabe wird hier
     nach dem zweiten Test abgekürzt.

          (%i2) run_testsuite(display_all=true, tests=["rtest1",rtest2]);
          Running tests in rtest1:
          ********************** Problem 1 ***************
          Input:
          (fmakunbound(f), kill(functions, values, arrays))

          Result:
          done

          ... Which was correct.

          ********************** Problem 2 ***************
          Input:
                       2
          f(x) := y + x

          Result:
                       2
          f(x) := y + x

          ... Which was correct.

          [...]

     Im folgenden Beispiel werden die Tests ausgegeben, von denen
     bekannt ist, dass sie fehlerhaft sind.  Dies sind die Tests mit
     den Nummern 76 und 78.

          (%i1) run_testsuite(display_known_bugs=true, tests=[rtest12]);
          Running tests in rtest12:
          ********************** Problem 76 ***************
          Input:
                     2
          letsimp(foo (x))

          Result:
                 2
          1 - bar (aa)

          This differed from the expected result:
                 2
          1 - bar (x)
          ********************** Problem 78 ***************
          Input:
                     4
          letsimp(foo (x))

          Result:
             4            2
          bar (aa) - 2 bar (aa) + 1

          This differed from the expected result:
                   2         4
          1 - 2 bar (x) + bar (x)

          76/78 tests passed

          The following 2 problems failed: (76 78)

          Error summary:
          Errors found in /usr/local/share/maxima/5.23post/tests/rtest12.mac,
          problems: (76 78)
          2 tests failed out of 78 total tests.
          Evaluation took:
            0.157 seconds of real time
            0.12801 seconds of total run time (0.12401 user, 0.00400 system)
            [Run times consist of 0.008 seconds GC time,
             and 0.121 seconds non-GC time.]
            81.53% CPU
            9 forms interpreted
            71 lambdas converted
            254,604,658 processor cycles
            6,145,064 bytes consed

          (%o0)                         done

 -- Optionsvariable: testsuite_files
     Die Optionsvariable `testsuite_files' enthält die Liste der
     Testdateien, die von `run_testsuite'  standardmäßig ausgeführt
     werden.  Wenn bekannt ist, dass einzelne Tests einer Testdatei
     fehlschlagen werden, dann wird anstatt dem Namen der Datei eine
     Liste eingefügt, die den Namen und die Nummern der fehlerhaften
     Tests enthält.  Das folgende Beispiel zeigt die Zuweisung einer
     neuen Liste und wie fehlerhafte Tests gekennzeichnet werden:

           testsuite_files : ["rtest13s", ["rtest14", 57, 63]]

     Die Einträge der Liste bedeuten, dass die Dateien "rtest13s" und
     "rtest14" von der Funktion `run_testsuite' ausgeführt werden
     sollen und das bekannt ist, dass die Tests mit den Nummern 57 und
     63 der Testdatei "rtest14" fehlschlagen werden.

 -- Funktion: bug_report ()
     Zeigt die Maxima- und Lisp-Version der Installation sowie einen
     Link zur Webseite des Maxima-Projekts.  Die Informationen zur
     Version werden auch von `build_info'  angezeigt.  Wenn ein
     Programmfehler berichtet wird, ist es hilfreich, die Maxima- und
     Lisp-Version in den Fehlerbericht aufzunehmen.  `bug_report' gibt
     eine leere Zeichenkette `""' zurück.

     Beispiel:

          (%i1) bug_report();
          The Maxima bug database is available at
              http://sourceforge.net/tracker/?atid=104933&group_id=4933
          Submit bug reports by following the 'Add new' link on that page.
          Please include the following information with your bug report:
          -------------------------------------------------------------
          Maxima version: 5.20post
          Maxima build date: 19:59 5/10/2010
          Host type: i686-pc-linux-gnu
          Lisp implementation type: SBCL
          Lisp implementation version: 1.0.29.11.debian
          -------------------------------------------------------------
          The above information is also reported by the function 'build_info'

 -- Funktion: build_info ()
     Zeigt die Maxima- und Lisp-Version der Installation.  `build_info'
     gibt eine leere Zeichenkette `""' zurück.

     Beispiel:

          (%i1) build_info();
          Maxima version: 5.20post
          Maxima build date: 19:59 5/10/2010
          Host type: i686-pc-linux-gnu
          Lisp implementation type: SBCL
          Lisp implementation version: 1.0.29.11.debian


File: maxima.info,  Node: Hilfe,  Next: Kommandozeile,  Prev: Programmfehler,  Up: Top

3 Hilfe
*******

* Menu:

* Dokumentation::
* Funktionen und Variablen der Hilfe::


File: maxima.info,  Node: Dokumentation,  Next: Funktionen und Variablen der Hilfe,  Prev: Hilfe,  Up: Hilfe

3.1 Dokumentation
=================

Die Maxima-Dokumentation ist in Texinfo geschrieben und wird in
verschiedenen Formaten zur Verfügung gestellt.  Von der
Maxima-Kommandozeile kann die Dokumentation mit den Kommandos `?',  `??'
oder `describe'  aufgerufen werden.  Weiterhin kann die Dokumentation
als GNU Infotext mit dem GNU Programm `info', in einem Browser oder als
PDF-Datei gelesen werden.  Sowohl unter Windows als auch unter Linux
kann die Dokumentation als Hilfedatei gelesen werden.


File: maxima.info,  Node: Funktionen und Variablen der Hilfe,  Prev: Dokumentation,  Up: Hilfe

3.2 Funktionen und Variablen der Hilfe
======================================

 -- Funktion: apropos (<string>)
     Gibt eine Liste der Maxima-Symbole zurück, die die Zeichenkette
     <string> im Namen enthalten.  Das Kommando `apropos("")' gibt eine
     Liste mit allen Maxima-Symbolen zurück.  Wenn `apropos' kein
     Maxima-Symbol finden kann, das die Zeichenkette <string> im Namen
     enthält, ist das Ergebnis eine leere Liste `[]'.

     Beispiel:

     Zeige alle Maxima-Symbole, die die Zeichenkette `"gamma"' im Namen
     enthalten:

          (%i1) apropos("gamma");
          (%o1) [%gamma, gamma, gammalim, gamma_expand, gamma_greek,
          gamma_incomplete, gamma_incomplete_generalized,
          gamma_incomplete_regularized, Gamma, log_gamma, makegamma,
          prefer_gamma_incomplete,
          gamma_incomplete_generalized_regularized]

 -- Funktion: demo (<filename>)
     Führt die Beispiele der Demo-Datei <filename> aus.  Das Argument
     <filename> kann ein Symbol oder eine Zeichenkette sein.  `demo'
     macht nach jeder Ausgabe eine Pause und wartet auf eine Eingabe.
     `demo' sucht in den Ordnern, die in der Optionsvariablen
     `file_search_demo'  enthalten sind, nach der Datei <filename>.
     Die Dateiendung <.dem> muss nicht angegeben werden.

     Siehe auch die Funktion `file_search'  für die Suche von Dateien
     und die Funktion `batch'  für den Aufbau einer Demo-Datei.
     Demo-Dateien können auch von der Funktion `batch' mit der Option
     `demo' ausgeführt werden.  `demo' wertet das Argument aus.  `demo'
     gibt den Namen der Demo-Datei zurück, die ausgeführt wird.

     Beispiel:

          (%i1) demo ("disol");
          batching /home/wfs/maxima/share/simplification/disol.dem
           At the _ prompt, type ';' followed by enter to get next demo
          (%i2)                      load(disol)
          _
          (%i3)           exp1 : a (e (g + f) + b (d + c))
          (%o3)               a (e (g + f) + b (d + c))
          _
          (%i4)                disolate(exp1, a, b, e)
          (%t4)                         d + c

          (%t5)                         g + f

          (%o5)                   a (%t5 e + %t4 b)
          _

 -- Funktion: describe (<topic>)
 -- Funktion: describe (<topic>, exact)
 -- Funktion: describe (<topic>, inexact)
     `describe(<topic>)' entspricht dem Kommando `describe(<topic>,
     exact)'.  Das Argument <topic> ist eine Zeichenkette oder ein
     Symbol.  Wenn <topic> ein Operator wie zum Beispiel `+', `*', `do'
     oder `if' ist, muss der Name des Operators als eine Zeichenkette
     angegeben werden.  Der Name des Operators `+' für die Addition ist
     zum Beispiel `"+"'.

     `describe(<topic>, exact)' findet Einträge, die mit <topic>
     übereinstimmen.  Bei der Suche nach einer Übereinstimmung werden
     Klein- und Großschreibung nicht voneinander unterschieden.
     `describe(<topic>, inexact)' findet Einträge, die <topic>
     enthalten.  Sind mehrere Einträge vorhanden, fragt Maxima, welcher
     der Einträge angezeigt werden soll.

     `? foo' (mit einem Leerzeichen zwischen `?' und `foo') entspricht
     `describe("foo", exact)' und `?? foo' entspricht `describe("foo",
     inexact)'.  In der Kurzschreibweise muss das Argument ein Symbol
     sein.  Siehe auch `?'  und `??'.

     `describe("", inexact)' gibt alle Themen aus, die in der
     Dokumentation enthalten sind.

     `describe' wertet das Argument nicht aus.  `describe' gibt `true'
     zurück, wenn Einträge gefunden wurden, ansonsten `false'.

     Beispiel:

     Im folgenden Beispiel werden die Einträge 2 und 3 ausgewählt (Die
     Ausgabe ist verkürzt wiedergeben).  Alle oder keiner der Einträge
     werden mit `all' oder `none' ausgewählt.  Die Eingabe kann mit `a'
     oder `n' abgekürzt werden.

          (%i1) ?? integrat
           0: Functions and Variables for Integration
           1: Introduction to Integration
           2: integrate (Functions and Variables for Integration)
           3: integrate_use_rootsof (Functions and Variables for Integration)
           4: integration_constant (Functions and Variables for Integration)
           5: integration_constant_counter (Functions and Variables for
              Integration)
          Enter space-separated numbers, `all' or `none': 2 3

           -- Function: integrate (<expr>, <x>)
           -- Function: integrate (<expr>, <x>, <a>, <b>)
               Attempts to symbolically compute the integral of <expr> with
               respect to <x>.  `integrate (<expr>, <x>)' is an indefinite
               integral, while `integrate (<expr>, <x>, <a>, <b>)' is a
               definite integral, with limits of integration <a> and <b>.
               [...]

           -- Option variable: integrate_use_rootsof
               Default value: `false'

               When `integrate_use_rootsof' is `true' and the denominator of
               a rational function cannot be factored, `integrate' returns
               the integral in a form which is a sum over the roots (not yet
               known) of the denominator.
               [...]

 -- Funktion: example (<topic>)
 -- Funktion: example ()
     Das Kommando `example(<topic>)' zeigt Beispiele für das Argument
     <topic>.  <topic> ist ein Symbol oder eine Zeichenkette.  Ist das
     Argument ein Operator, wie zum Beispiel `+', `*' oder `do', muss
     das Argument <topic> eine Zeichenkette sein.  Der Name des
     Operators `+' für die Addition ist zum Beispiel `"+"'.  Groß- und
     Kleinschreibung werden nicht unterschieden.

     `example()' zeigt eine Liste aller Themen, für die Beispiele
     vorhanden sind.

     Die Optionsvariable `manual_demo'  enthält den Namen der Datei,
     die die Beispiele enthält.  Der Standardwert ist `"manual.demo"'.

     `example' wertet das Argument nicht aus.  `example' gibt `done'
     zurück, außer wenn kein Argument angeben ist oder wenn kein
     Beispiel gefunden wurde.  In diesen Fällen wird eine Liste mit
     allen Themen ausgegeben, zu denen Beispiele vorhanden sind.

     Beispiele:

          (%i1) example(append);
          (%i2) append([x+y,0,-3.2],[2.5e+20,x])
          (%o2)             [y + x, 0, - 3.2, 2.5e+20, x]
          (%o2)                         done
          (%i3) example("lambda");

          (%i4) lambda([x,y,z],z^2+y^2+x^2)
                                              2    2    2
          (%o4)            lambda([x, y, z], z  + y  + x )
          (%i5) %(1,2,a)
                                        2
          (%o5)                        a  + 5
          (%i6) a+2+1
          (%o6)                         a + 3
          (%o6)                         done

 -- Optionsvariable: manual_demo
     Standardwert: `"manual.demo"'

     Die Optionsvariable `manual_demo' enthält den Namen der Datei, die
     die Beispiele für die Funktion `example' enthält.  Siehe `example'.



File: maxima.info,  Node: Kommandozeile,  Next: Datentypen und Strukturen,  Prev: Hilfe,  Up: Top

4 Kommandozeile
***************

* Menu:

* Einführung in die Kommandozeile::
* Funktionen und Variablen der Eingabe::
* Funktionen und Variablen der Ausgabe::


File: maxima.info,  Node: Einführung in die Kommandozeile,  Next: Funktionen und Variablen der Eingabe,  Prev: Kommandozeile,  Up: Kommandozeile

4.1 Einführung in die Kommandozeile
===================================

Konsole
-------

Für Maxima sind verschiedene Nutzeroberflächen erhältlich.  Oberflächen,
die je nach Betriebssystem bereits mit der Installation von Maxima zur
Verfügung stehen, sind wxMaxima, Xmaxima, Imaxima und die Konsole.

Die Konsole (oder das Terminal) arbeitet in einem Textmodus.  Für die
Ausgabe in einem grafischen Modus mit einer menügesteuerten Eingabe
müssen andere Nutzeroberflächen verwendet werden.

In dieser Dokumentation wird ausschließlich die Konsole eingesetzt, die
unter allen Betriebssystemen zur Verfügung steht.  Der Nutzer kann alle
Maxima-Funktionen in einer Konsole nutzen.  Im Textmodus der Konsole
werden die Ergebnisse in der Regel in einem 2D-Modus dargestellt.  Für
die Ausgabe von Funktionsgraphen werden von Maxima Hilfsprogramme wie
GNUPlot aufgerufen.

Eingabe, Auswertung, Vereinfachung und Ausgabe
----------------------------------------------

Jede Eingabe des Nutzers in einer Konsole bis zur Ausgabe eines
Ergebnisses auf der Konsole kann in vier Phasen eingeteilt werden:

  1. Von der Tastatur oder aus einer Datei wird ein Ausdruck eingelesen
     und vom Parser in eine interne Darstellung umgewandelt.  In dieser
     1. Phase werden inbesondere Operatoren wie "+", "/" oder "do"
     behandelt.

  2. Der vom Parser eingelesene Ausdruck wird von Maxima in der 2. Phase
     ausgewertet.  Dabei werden Variablen durch ihren Wert ersetzt und
     Funktionen wie die Substitution oder Integration eines Ausdrucks
     ausgeführt.  Das Ergebnis dieser Phase ist ein ausgewerteter
     Ausdruck.

  3. Der ausgewertete Ausdruck wird in der 3. Phase von Maxima
     vereinfacht.  Dabei werden Ausdrücke wie `a+a' zu `2*a' oder
     `sin(%pi/2)' zu `1' vereinfacht.

  4. Das Ergebnis ist ein ausgewerteter und vereinfachter Ausdruck.
     Zuletzt wird dieses Ergebnis in der 4. Phase für die Anzeige
     vorbereitet und auf der Konsole ausgegeben.

Der Nutzer kann auf jede einzelne Phase Einfluß nehmen.  Verschiedene
Kapitel der Dokumentation befassen sich mit diesen Möglichkeiten.  In
diesem Kapitel werden die Kommandos und Möglichkeiten zusammengestellt,
die sich mit der Eingabe und Ausgabe auf der Konsole befassen.  In
*note Auswertung:: wird beschrieben wie auf die Auswertung und in *note
Vereinfachung:: wie auf die Vereinfachung einer Eingabe Einfluss
genommen werden kann.

Marken
------

Maxima speichert alle Eingaben in den Marken `%i' und die Ausgaben in
den Marken `%o' ab.  Die Marken erhalten eine laufende Nummer.
Weiterhin erzeugen einige Funktionen Zwischenmarken `%t'.  Andere
Systemvariablen speichern das letzte Ergebnis oder die letzte Eingabe
ab.  Folgende Symbole bezeichnen Variablen und Funktionen für die
Verwaltung der Marken:

   __          _
   %           %%           %th
   inchar      linechar     outchar
   linenum     nolabels

Informationslisten
------------------

Maxima verwaltet Informationslisten.  Die verfügbaren
Informationslisten sind in der Systemvariablen `infolists'  enthalten.
In diesem Kapitel werden die Informationslisten `labels',  `values'  und
`myoptions'  erläutert.  Wird eine Optionsvariable vom Nutzer gesetzt,
kontrolliert die Optionsvariable `optionset'  die Ausgabe weiterer
Informationen.  Folgende Symbole bezeichnen Variablen und Funktionen für
Informationslisten und Optionsvariablen:

   infolists     labels        values
   myoptions     optionset

Weitere Informationslisten, die in anderen Kapiteln erläutert werden,
sind:

   functions      arrays         macros
   rules          aliases        dependencies
   gradefs        props          let_rule_packages
   structures     namespaces

Löschen und Rücksetzen
----------------------

Um eine Maxima-Umgebung herzustellen, in der keine Variablen oder
Funktionen definiert sind, oder um einzelne Zuweisungen, Eigenschaften
oder Definitionen zu entfernen, kennt Maxima die folgenden Funktionen:

   kill     reset     reset_verbosely

Weitere Kommandos der Kommandozeile
-----------------------------------

Mit den Symbolen `?'  und `??'  kann Dokumentation abgerufen werden.
Wird `?' einem Bezeichner als Präfix vorangestellt, wird der Bezeichner
als Lisp-Symbol interpretiert.  Mit weiteren Kommandos kann eine
Maxima-Sitzung beendet oder zu einer Lisp-Sitzung gewechselt werden.
Das Zeichen für die Eingabeaufforderung einer Unterbrechung kann
geändert werden.  Die Zeit für jede einzelne Berechnung kann angezeigt
werden und die Ergebnisse einer Sitzung können wiederholt ausgegeben
werden.  Maxima kennt hierfür die folgenden Symbole:

   ?            ??
   playback     prompt     showtime
   quit         to_lisp

Die Funktionen `read'  und `readonly'  geben Ausdrücke auf der Konsole
aus und lesen dann die Eingabe des Nutzers ein:

   read               readonly

Ausgabe auf der Konsole
-----------------------

Für die Ausgabe werden Ausdrücke von einer internen Darstellung in eine
externe Darstellung transformiert.  Zum Beispiel hat die Eingabe
`sqrt(x)' eine interne Darstellung, die dem Ausdruck `x^(1/2)'
entspricht.  Für die Ausgabe wird die interne Darstellung in einen
Ausdruck transformiert, die der Ausgabe `sqrt(x)' entspricht.  Dieses
Verhalten wird von der Optionsvariablen `sqrtdispflag'  kontrolliert.
Siehe *note Ausdrücke:: für Funktionen, die die interne und externe
Darstellung von Ausdrücken unterscheiden.

Folgende Optionsvariablen und Symbole kontrollieren die Ausgabe auf der
Konsole:

   %edispflag         absboxchar       display2d
   display_format_internal             exptdispflag
   expt               nexpt            ibase
   linel              lispdisp         negsumdispflag
   obase              pfeformat        powerdisp
   sqrtdispflag       stardisp         ttyoff

Mit folgenden Funktionen kann die Ausgabe auf der Konsole formatiert
werden:

   disp               display          dispterms
   grind              ldisp            ldisplay
   print


File: maxima.info,  Node: Funktionen und Variablen der Eingabe,  Next: Funktionen und Variablen der Ausgabe,  Prev: Einführung in die Kommandozeile,  Up: Kommandozeile

4.2 Funktionen und Variablen der Eingabe
========================================

 -- Operator: ;
     Mit dem Semikolon `;' wird die Eingabe eines Maxima-Ausdrucks auf
     der Konsole und in einer Datei abgeschlossen.  Es können mehrere
     Ausdrücke mit einem Semikolon als Abschluss auf einer Zeile
     eingegeben werden.  Siehe auch `$'.

     Beispiele:

          (%i1) a:10;
          (%o1)                          10
          (%i2) a+b;
          (%o2)                        b + 10
          (%i3) x:10; x+y;
          (%o3)                          10
          (%o4)                        y + 10

 -- Operator: $
     Das Dollarzeichen schließt wie das Semikolon die Eingabe eines
     Ausdruckes auf der Konsole und in einer Datei ab.  Im Unterschied
     zum Semikolon wird die Ausgabe des Ergebnisses unterdrückt.  Das
     Ergebnis wird jedoch weiterhin einer Ausgabemarke `%o'  zugewiesen
     und die Systemvariable `%'  enthält das Ergebnis.  Siehe auch `;'.

     Beispiele:

          (%i1) expand((a+b)^2)$

          (%i2) %;
                                    2            2
          (%o2)                    b  + 2 a b + a
          (%i3) a:10$ a+b$

          (%i5) %o3;
          (%o5)                          10
          (%i6) %o4;
          (%o6)                        b + 10

 -- Systemvariable: __
     Während einer laufenden Auswertung enthält die Systemvariable `__'
     den zuletzt vom Parser eingelesenen Ausdruck <expr>.  Der Ausdruck
     <expr> wird der Systemvariablen `__' vor der Auswertung und
     Vereinfachung zugewiesen.

     Die Systemvariable `__' wird von den Funktionen `batch'  und `load'
     erkannt.  Wird eine Datei mit der Funktion `batch' ausgeführt, hat
     `__' dieselbe Bedeutung wie bei der Eingabe in einer
     Kommandozeile.  Wird eine Datei mit dem Namen `filename' mit der
     Funktion `load' geladen, enthält `__' den Ausdruck
     `load(<filename>)'.  Das ist die letzte Eingabe in der
     Kommandozeile.

     Siehe auch die Systemvariablen `_'  und `%'.

     Beispiele:

          (%i1) print ("I was called as: ", __)$
          I was called as:  print(I was called as, __)

          (%i2) foo (__);
          (%o2)                     foo(foo(__))

          (%i3) g (x) := (print ("Current input expression =", __), 0)$
          (%i4) [aa : 1, bb : 2, cc : 3]$
          (%i5) (aa + bb + cc)/(dd + ee + g(x))$

                                      cc + bb + aa
          Current input expression = --------------
                                     g(x) + ee + dd

 -- Systemvariable: _
     Die Systemvariable `_' enthält den zuletzt eingegebenen Ausdruck
     <expr>.  Der Ausdruck <expr> wird der Systemvariablen `_' vor der
     Auswertung und Vereinfachung zugewiesen.

     Die Systemvariable `_' wird von den Funktionen `batch'  und `load'
     erkannt.  Wird eine Datei mit der Funktion `batch' ausgeführt, hat
     `_' dieselbe Bedeutung wie bei der Eingabe in einer Kommandozeile.
     Wird eine Datei mit der Funktion `load' geladen, enthält `_' das
     zuletzt in der Kommandozeile eingegebene Kommando.

     Siehe auch die Systemvariablen `__'  und `%'.

     Beispiele:

     Die Funktion `cabs'  wird ausgewertet und nicht vereinfacht.  Das
     Beispiel zeigt, dass die Systemvariable `_' den zuletzt
     eingelesenen Ausdruck vor der Auswertung enthält.

          (%i1) cabs(1+%i);
          (%o1)                        sqrt(2)
          (%i2) _;
          (%o2)                     cabs(%i + 1)

     Die Funktion `abs'  vereinfacht einen Ausdruck.  Wird der Inhalt
     der Systemvariablen `_' ausgegeben, wird das für die Ausgabe
     vereinfachte Ergebnis angezeigt.  Mit der Funktion `string'  wird
     der Inhalt der Systemvariablen `_' vor der Ausgabe in ein
     Zeichenkette umgewandelt, um den nicht vereinfachten Wert sichtbar
     zu machen.

          (%i3) abs(1+%i);
          (%o3)                        sqrt(2)
          (%i4) _;
          (%o4)                        sqrt(2)
          (%i5) abs(1+%i);
          (%o5)                        sqrt(2)
          (%i6) string(_);
          (%o6)                       abs(1+%i)

 -- Systemvariable: %
     Die Systemvariable `%' enthält das Ergebnis des zuletzt von Maxima
     ausgewerteten und vereinfachten Ausdrucks.  `%' enhält das letzte
     Ergebnis auch dann, wenn die Ausgabe des Ergebnisses durch
     Abschluss der Eingabe mit einem Dollarzeichen `$'  unterdrückt
     wurde.

     Die Systemvariable `%' wird von den Funktionen `batch'  und `load'
     erkannt.  Wird eine Datei mit der Funktion `batch' ausgeführt, hat
     `%' dieselbe Bedeutung wie bei der Eingabe in einer Kommandozeile.
     Wird eine Datei mit der Funktion `load' geladen, enthält `%' das
     letzte Ergebnis des Ausdrucks, der auf der Konsole eingegeben
     wurde.

     Siehe auch die Systemvariablen `_',  `__'  und `%th'.


 -- Systemvariable: %%
     In zusammengesetzten Ausdrücken, wie in Ausdrücken mit `block'
     oder `lambda'  oder in Ausdrücken der Gestalt `(<s_1>, ...,
     <s_n>)', enthält die Systemvariable `%%' das Ergebnis des
     vorhergehenden Ausdrucks.  Für den ersten Ausdruck oder außerhalb
     eines zusammengesetzten Ausdrucks ist `%%' nicht definiert.

     Die Systemvariable `%%' wird von `batch'  und `load'  erkannt und
     hat dieselbe Bedeutung wie bei der Eingabe in der Konsole.  Siehe
     auch die Systemvariable `%'  und die Funktion `%th'.

     Beispiele:

     Auf die im ersten Ausdruck berechnete Stammfunktion wird im
     zweiten Ausdruck mit `%%' Bezug genommen, um das Integral an der
     oberen und unteren Grenze auszuwerten.

          (%i1) block (integrate (x^5, x), ev (%%, x=2) - ev (%%, x=1));
                                         21
          (%o1)                          --
                                         2

     Ein zusammengesetzter Ausdruck kann weitere zusammengesetzte
     Ausdrücke enthalten.  `%%' enthält dabei jeweils das Ergebnis des
     letzten Ausdrucks.  Das folgende Beispiel hat das Ergebnis `7*a^n'.

          (%i3) block (block (a^n, %%*42), %%/6);
                                           n
          (%o3)                         7 a

     Der Wert der Systemvariablen `%%' kann nach einer Unterbrechung
     mit dem Kommando `break'  inspiziert werden.  In diesem Beispiel
     hat die Systemvariable `%%' den Wert 42.

          (%i4) block (a: 42, break ())$
          Entering a Maxima break point. Type 'exit;' to resume.
          _%%;
          42
          _

 -- Funktion: %th (<n>)
     Die Funktion `%th' liefert das n-te vorhergehende Ergebnis.  Dies
     ist dann nützlich, wenn wie in Batch-Dateien die absolute
     Zeilennummer der letzten Ausgabemarken nicht bekannt ist.

     Die Funktion `%th' wird von den Funktionen `batch'  und `load'
     erkannt.  Wird eine Datei mit `batch' ausgeführt, hat `%th'
     dieselbe Bedeutung wie bei der Eingabe in der Konsole.  Wird eine
     Datei mit der Funktion `load' geladen, enthält `%th' das letzte
     Ergebnis der Eingabe in der Konsole.

     Siehe auch `%'  und `%%'.

     Beispiel:

     Das Beispiel zeigt, wie die letzten 5 eingegebenen Werte mit der
     Funktion `%th' aufsummiert werden.

          (%i1) 1;2;3;4;5;
          (%o1)                           1
          (%o2)                           2
          (%o3)                           3
          (%o4)                           4
          (%o5)                           5
          (%i6) block (s: 0, for i:1 thru 5 do s: s + %th(i), s);
          (%o6)                          15

 -- Spezielles Symbol: ?
     Wird dem Namen einer Funktion oder Variablen ein `?' als Präfix
     vorangestellt, wird der Name als ein Lisp-Symbol interpretiert.
     Zum Beispiel bedeutet `?round' die Lisp-Funktion `ROUND'.  Siehe
     *note Lisp und Maxima:: für weitere Ausführungen zu diesem Thema.

     Die Eingabe `? word' ist eine Kurzschreibweise für das Kommando
     `describe("word")'.  Das Fragezeichen muss am Anfang einer
     Eingabezeile stehen, damit Maxima die Eingabe als eine Anfrage
     nach der Dokumentation interpretiert.  Siehe auch `describe'.


 -- Spezielles Symbol: ??
     Die Eingabe `?? word' ist eine Kurzschreibweise für das Kommando
     `describe("word", inexact)'.  Die Fragezeichen müssen am Anfang
     einer Eingabezeile stehen, damit Maxima die Eingabe als eine
     Anfrage nach der Dokumentation interpretiert.  Siehe auch
     `describe'.


 -- Optionsvariable: inchar
     Standardwert: `%i'

     Die Optionsvariable `inchar' enthält den Präfix der Eingabemarken.
     Maxima erzeugt die Eingabemarken automatisch aus dem Präfix
     `inchar' und der Zeilennummer `linenum'.

     Der Optionsvariablen `inchar' kann eine Zeichenkette oder ein
     Symbol zugewiesen werden, die auch mehr als ein Zeichen haben
     können.  Da Maxima intern nur das erste Zeichen berücksichtigt,
     sollten sich die Präfixe `inchar', `outchar' und `linechar' im
     ersten Zeichen voneinander unterscheiden.  Ansonsten funktionieren
     einige Kommandos wie zum Beispiel `kill(inlabels)' nicht wie
     erwartet.

     Siehe auch die Funktion und Systemvariable `labels'  sowie die
     Optionsvariablen `outchar'  und `linechar'.

     Beispiele:

          (%i1) inchar: "input";
          (%o1)                         input
          (input2) expand((a+b)^3);
                               3        2      2      3
          (%o2)               b  + 3 a b  + 3 a  b + a
          (input3)

 -- Systemvariable: infolists
     Die Systemvariable `infolists' enthält eine Liste der
     Informationslisten, die Maxima zur Verfügung stellt.  Diese sind:

    `labels'
          Enthält die Marken `%i', `%o' und `%t', denen bisher ein
          Ausdruck zugewiesen wurde.

    `values'
          Enthält die vom Nutzer mit den Operatoren `:'  oder `::'
          definierten Variablen.

    `functions'
          Enthält die vom Nutzer mit dem Operator `:='  oder der
          Funktion `define'  definierten Funktionen.

    `arrays'
          Enthält die mit den Operatoren `:', `::' oder `:=' definierten
          Arrays oder Array-Funktionen.

    `macros'
          Enthält die vom Nutzer mit dem Operator `::='  definierten
          Makros.

    `myoptions'
          Enthält die Optionsvariablen, die vom Nutzer bisher einen
          neuen Wert erhalten haben.

    `rules'
          Enthält die vom Nutzer mit den Funktionen `tellsimp',

          `tellsimpafter',  `defmatch'  oder `defrule'

          definierten Regeln.

    `aliases'
          Enthält die Symbole, die einen vom Nutzer definierten
          Alias-Namen mit der Funktion `alias'  erhalten haben.
          Weiterhin erzeugen die Funktionen `ordergreat'  und
          `orderless'  sowie eine Deklaration als `noun'  mit der
          Funktion `declare'  Alias-Namen, die in die Liste eingetragen
          werden.

    `dependencies'
          Enthält alle Symbole, für die mit den Funktionen `depends'
          oder `gradef'  eine Abhängigkeit definiert ist.

    `gradefs'
          Enthält die Funktionen, für die der Nutzer mit der Funktion
          `gradef'  eine Ableitung definiert hat.

    `props'
          Enthält die Symbole, die eine Eigenschaft mit der Funktion
          `declare'  erhalten haben.

    `let_rule_packages'
          Enthält die vom Nutzer definierten `let' -Regeln.


 -- Funktion: kill (<a_1>, ..., <a_n>)
 -- Funktion: kill (labels)
 -- Funktion: kill (inlabels, outlabels, linelabels)
 -- Funktion: kill (<n>)
 -- Funktion: kill ([<m>, <n>])
 -- Funktion: kill (values, functions, arrays, ...)
 -- Funktion: kill (all)
 -- Funktion: kill (allbut (<a_1>, ..., <a_n>))
     Die Funktion `kill' entfernt alle Zuweisungen (Werte, Funktionen,
     Arrays oder Regeln) und Eigenschaften von den Argumenten <a_1>,
     ..., <a_n>.  Ein Argument <a_k> kann ein Symbol oder ein einzelnes
     Array-Element sein.  Ist <a_k> ein einzelnes Array-Element,
     entfernt `kill' die Zuweisungen an dieses Element, ohne die
     anderen Elemente des Arrays zu beeinflussen.

     `kill' kennt verschiedene spezielle Argumente, die auch kombiniert
     werden können wie zum Beispiel `kill(inlabels, functions,
     allbut(foo, bar))'.

     `kill(labels)' entfernt alle Zuweisungen an Eingabe-, Ausgabe- und
     Zwischenmarken.  `kill(inlabels)' entfernt nur die Zuweisungen an
     Eingabemarken, die mit dem aktuellen Wert von `inchar'  beginnen.
     Entsprechend entfernt `kill(outlabels)' die Zuweisungen an die
     Ausgabemarken, die mit dem aktuellen Wert von `outchar'  beginnen
     und `kill(linelabels)' die Zuweisungen an die Zwischenmarken, die
     mit dem aktuellen Wert von `linechar'  beginnen.

     `kill(<n>)', wobei <n> eine ganze Zahl ist, entfernt die
     Zuweisungen an die <n> letzten Eingabe- und Ausgabemarken.
     `kill([<m>, <n>])' entfernt die Zuweisungen an die Eingabe- und
     Ausgabemarken mit den Nummern von <m> bis <n>.

     `kill(<infolist>)', wobei <infolist> eine Informationsliste wie zum
     Beispiel `values',  `functions'  oder `arrays'  ist, entfernt die
     Zuweisungen an allen Einträgen der Liste <infolist>.  Siehe auch
     `infolists'.

     `kill(all)' entfernt die Zuweisungen an die Einträge in sämtlichen
     Informationslisten.  `kill(all)' setzt keine Optionsvariablen auf
     ihre Standardwerte zurück.  Siehe die Funktion `reset',  um
     Optionsvariablen auf ihre Standwerte zurückzusetzen.

     `kill(allbut(<a_1>, ..., <a_n>))' entfernt alle Zuweisungen bis
     auf Zuweisungen an die Variablen <a_1>, ..., <a_n>.
     `kill(allbut(<infolist>))' entfernt alle Zuweisungen bis auf denen
     in der Informationsliste <infolist>.

     `kill(<symbol>)' entfernt sämtliche Zuweisungen und Eigenschaften
     des Symbols <symbol>.  Im Gegensatz dazu entfernen `remvalue',
     `remfunction',  `remarray'  und `remrule'  jeweils eine spezielle
     Eigenschaft eines Symbols.

     `kill' wertet die Argumente nicht aus.  Der Quote-Quote-Operator
     `''' kann die Auswertung erzwingen.  `kill' gibt immer `done'
     zurück.

 -- Funktion: labels (<symbol>)
 -- Systemvariable: labels
     Die Funktion `labels' gibt eine Liste der Eingabe-, Ausgabe- und
     Zwischenmarken zurück, die mit dem Argument <symbol> beginnen.
     Typischerweise ist <symbol> der Wert von `inchar',  `outchar'
     oder `linechar'.    Dabei kann das Prozentzeichen fortgelassen
     werden.  So haben zum Beispiel die Kommandos `labels(i)' und
     `labels(%i)' dasselbe Ergebnis.

     Wenn keine Marke mit <symbol> beginnt, gibt `labels' eine leere
     Liste zurück.

     Die Funktion `labels' wertet das Argument nicht aus.  Mit dem
     Quote-Quote-Operator  `''' kann die Auswertung erzwungen werden.
     Zum Beispiel gibt das Kommando `labels(''inchar)' die Marken
     zurück, die mit dem aktuellen Buchstaben für die Eingabemarken
     beginnen.

     Die Systemvariable `labels' ist eine Informationsliste, die die
     Eingabe-, Ausgabe- und Zwischenmarken enthält.  In der Liste sind
     auch die Marken enthalten, die vor einer Änderung von `inchar',
     `outchar' oder `linechar' erzeugt wurden.

     Standardmäßig zeigt Maxima das Ergebnis jeder Eingabe an, wobei dem
     Ergebnis eine Ausgabemarke hinzugefügt wird.  Die Anzeige der
     Ausgabe wird durch die Eingabe eines abschließenden `$'
     (Dollarzeichen) statt eines `;'  (Semikolon) unterdrückt.  Dabei
     wird eine Ausgabemarke erzeugt und das Ergebnis zugewiesen, jedoch
     nicht angezeigt.  Die Marke kann aber in der gleichen Art und
     Weise wie bei angezeigten Ausgabemarken referenziert werden.
     Siehe auch `%',  `%%'  und `%th'.

     Einige Funktionen erzeugen Zwischenmarken.  Die Optionsvariable
     `programmode'  kontrolliert, ob zum Beispiel `solve'  und einige
     andere Funktionen Zwischenmarken erzeugen, anstatt eine Liste von
     Ausdrücken zurückzugeben.  Andere Funktionen wie zum Beispiel
     `ldisplay'  erzeugen stets Zwischenmarken.

     Siehe auch `infolists'.


 -- Optionsvariable: linechar
     Standardwert: `%t'

     Die Optionsvariable `linechar' enthält den Präfix der
     Zwischenmarken.  Maxima generiert die Zwischenmarken automatisch
     aus `linechar'.

     Der Optionsvariablen `linechar' kann eine Zeichenkette oder ein
     Symbol zugewiesen werden, die auch mehr als ein Zeichen haben
     können.  Da Maxima intern nur das erste Zeichen berücksichtigt,
     sollten sich die Präfixe `inchar',  `outchar'  und `linechar' im
     ersten Zeichen voneinander unterscheiden.  Ansonsten funktionieren
     einige Kommandos wie `kill(inlabels)' nicht wie erwartet.

     Die Ausgabe von Zwischenmarken kann mit verschiedenen
     Optionsvariablen kontrolliert werden.  Siehe `programmode'  und
     `labels'.


 -- Systemvariable: linenum
     Enthält die Zeilennummer der aktuellen Ein- und Ausgabemarken.  Die
     Zeilennummer wird von Maxima automatisch erhöht.  Siehe auch
     `labels',  `inchar'  und `outchar'.


 -- Systemvariable: myoptions
     `myoptions' ist eine Informationsliste, die die Optionsvariablen
     enthält, die vom Nutzer während einer Sitzung geändert wurden.
     Die Variable verbleibt in der Liste, auch wenn sie wieder auf den
     Standardwert zurückgesetzt wird.

 -- Optionsvariable: nolabels
     Standardwert: `false'

     Hat `nolabels' den Wert `true', werden die Eingabe- und
     Ausgabemarken zwar angezeigt, ihnen werden aber keine Eingaben und
     Ergebnisse zugewiesen und sie werden nicht der Informationsliste
     `labels' hinzugefügt.  Andernfalls werden den Marken die Eingabe
     und die Ergebnisse zugewiesen und in die Informationsliste
     `labels' eingetragen.

     Zwischenmarken `%t' werden durch `nolabels' nicht beeinflusst.  Den
     Marken werden unabhängig vom Wert, den `nolabels' hat,
     Zwischenergebnisse zugewiesen und sie werden in die
     Informationsliste `labels' eingetragen.

     Siehe auch `labels'.


 -- Optionsvariable: optionset
     Standardwert: `false'

     Hat `optionset' den Wert `true', gibt Maxima eine Meldung aus, wenn
     einer Optionsvariablen ein Wert zugewiesen wird.

     Beispiel:

          (%i1) optionset:true;
          assignment: assigning to option optionset
          (%o1)                         true
          (%i2) gamma_expand:true;
          assignment: assigning to option gamma_expand
          (%o2)                         true

 -- Optionsvariable: outchar
     Standardwert: `%o'

     Die Optionsvariable `outchar' enthält den Präfix der Ausgabemarken.
     Maxima generiert die Ausgabemarken automatisch aus `outchar' und
     `linenum'.

     Der Optionsvariablen `outchar' kann eine Zeichenkette oder ein
     Symbol zugewiesen werden, die auch mehr als ein Zeichen haben
     können.  Da Maxima intern nur das erste Zeichen berücksichtigt,
     sollten sich die Präfixe `inchar',  `outchar' und `linechar'  im
     ersten Zeichen voneinander unterscheiden.  Ansonsten funktionieren
     einige Kommandos wie `kill(inlabels)' nicht wie erwartet.

     Siehe auch `labels'.

     Beispiele:

          (%i1) outchar: "output";
          (output1)                    output
          (%i2) expand((a+b)^3);
                               3        2      2      3
          (output2)           b  + 3 a b  + 3 a  b + a
          (%i3)

 -- Funktion: playback ()
 -- Funktion: playback (<n>)
 -- Funktion: playback ([<m>, <n>])
 -- Funktion: playback ([<m>])
 -- Funktion: playback (input)
 -- Funktion: playback (slow)
 -- Funktion: playback (time)
 -- Funktion: playback (grind)
     Zeigt Eingaben, Ergebnisse und Zwischenergebnisse an, ohne diese
     neu zu berechnen.  `playback' zeigt nur die Eingaben und
     Ergebnisse an, die Marken zugewiesen wurden.  Andere Ausgaben, wie
     zum Beispiel durch `print',  `describe'  oder Fehlermeldungen,
     werden nicht angezeigt.  Siehe auch `labels'.

     `playback()' zeigt sämtliche Eingaben und Ergebnisse an, die bis
     dahin erzeugt wurden.  Ein Ergebnis wird auch dann angezeigt, wenn
     die Ausgabe mit `$'  unterdrückt war.

     `playback(<n>)' zeigt die letzten <n> Ausdrücke an.  Jeder
     Eingabe-, Ausgabe- und Zwischenausdruck zählt dabei als ein
     Ausdruck.  `playback([<m>, <n>])' zeigt die Eingabe-, Ausgabe- und
     Zwischenausdrücke mit den Zahlen von <m> bis einschließlich <n>
     an.  `playback([<m>])' ist äquivalent zu `playback([<m>, <m>])'.
     Die Ausgabe ist ein Paar von Ein- und Ausgabeausdrücken.

     `playback(input)' zeigt sämtliche Eingabeausdrücke an, die bis
     dahin erzeugt wurden.

     `playback(slow)' macht nach jeder Ausgabe eine Pause und wartet
     auf eine Eingabe.  Dieses Verhalten ist vergleichbar mit der
     Funktion `demo'.

     `playback(time)' zeigt für jeden Ausdruck die für die Berechnung
     benötigte Zeit an.

     `playback(grind)' zeigt die Eingabeausdrücke in dem gleichen
     Format an, wie die Funktion `grind'.  Ausgabeausdrücke werden von
     der Option `grind' nicht beeinflusst.  Siehe auch `grind'.

     Die Argumente können kombiniert werden, wie zum Beispiel im
     folgenden Kommando `playback([5, 10], grind, time, slow)'.

     `playback' wertet die Argumente nicht aus.  `playback' gibt stets
     `done' zurück.

 -- Optionsvariable: prompt
     Standardwert: `_'

     Die Optionsvariable `prompt' enthält das Zeichen für die
     Eingabeaufforderung der Funktionen `demo'  und `playback'  sowie
     nach einer Unterbrechung, wie zum Beispiel durch das Kommando
     `break'.


 -- Funktion: quit ()
     Das Kommando `quit()' beendet eine Maxima-Sitzung.

     Mit der Tastatureingabe `control-c' oder `Strg-c' kann in der
     Konsole die Verarbeitung abgebrochen werden.  Standardmäßig wird
     die Maxima-Sitzung fortgesetzt.  Hat die globale Lisp-Variable
     `*debugger-hook*' den Wert `nil', wird der Lisp-Debugger gestartet.
     Siehe *note Fehlersuche::.

 -- Funktion: read (<expr_1>, ..., <expr_n>)
     Gibt die Ausdrücke <expr_1>, ... <expr_n> auf der Konsole aus,
     liest sodann einen Ausdruck von der Konsole ein und wertet diesen
     aus.  Die Eingabe des Ausdrucks wird mit den Zeichen `;'  oder `$'
     beendet.

     Siehe auch `readonly'.

     Beispiele:

          (%i1) foo: 42$
          (%i2) foo: read ("foo is", foo, " -- enter new value.")$
          foo is 42  -- enter new value.
          (a+b)^3;
          (%i3) foo;
                                               3
          (%o3)                         (b + a)

 -- Funktion: readonly (<expr_1>, ..., <expr_n>)
     Gibt die Ausdrücke <expr_1>, ... <expr_n> auf der Konsole aus,
     liest sodann einen Ausdruck von der Konsole ein und gibt den
     eingelesenen Ausdruck zurück ohne diesen auszuwerten.  Die Eingabe
     des Ausdrucks wird mit den Zeichen `;'  oder `$'  beendet.

     Siehe auch `read'.

     Beispiele:

          (%i1) aa: 7$
          (%i2) foo: readonly ("Enter an expression:");
          Enter an expression:
          2^aa;
                                            aa
          (%o2)                            2
          (%i3) foo: read ("Enter an expression:");
          Enter an expression:
          2^aa;
          (%o3)                            128

 -- Funktion: reset ()
     `reset()' setzt globale Maxima- und Lisp-Variablen und Optionen
     auf ihre Standardwerte zurück.  Maxima legt eine interne Liste mit
     den Standardwerten von globalen Variablen an.  Alle Variablen, die
     in dieser Liste enthalten sind, werden auf ihre Standardwerte
     zurückgesetzt.  Nicht alle globalen Variablen sind mit ihren
     Standwerten in diese Liste eingetragen.  Daher kann `reset' die
     Anfangswerte stets nur unvollständig wiederherstellen.

     `reset(<arg_1, ..., arg_n>)' setzt die Variablen <arg_1>, ...,
     <arg_n> auf ihren Standardwert zurück.

     `reset' gibt eine Liste mit den Variablen zurück, die auf ihren
     Standardwert zurückgesetzt wurden.  Ist die Liste leer, wurden
     keine Variablen zurückgesetzt.

     Siehe auch `reset_verbosely'.


 -- Funktion: reset_verbosely ()
 -- Funktion: reset_verbosely (<arg_1>, ..., <arg_n>)
     Entspricht der Funktion `reset'.  Im Unterschied zu `reset' wird zu
     jeder Variable, die zurückgesetzt wird, zusätzlich der Standardwert
     angezeigt.

     Siehe `reset'.


 -- Optionsvariable: showtime
     Standardwert: `false'

     Hat `showtime' den Wert `true', werden die interne Rechenzeit und
     die gesamte verstrichene Zeit zu jeder Ausgabe angezeigt.

     Die Rechenzeit wird unabhängig vom Wert der Optionsvariablen
     `showtime' nach jeder Auswertung eines Ausdruckes in den
     Ausgabemarken abgespeichert.  Daher können die Funktionen `time'
     und `playback'  die Rechenzeit auch dann anzeigen, wenn `showtime'
     den Wert `false' hat.

     Siehe auch `timer'.


 -- Funktion: to_lisp ()
     Wechselt zu einer Lisp-Sitzung.  `(to-maxima)' wechselt von der
     Lisp-Sitzung zurück in die Maxima-Sitzung.

     Beispiel:

     Definiere eine Funktion und wechsle zu Lisp.  Die Definition wird
     von der Eigenschaftsliste gelesen.  Dann wird die Definition der
     Funktion geholt, faktorisiert und in der Variablen `$result'
     gespeichert.  Die Variable kann nach der Rückkehr in Maxima
     genutzt werden.

          (%i1) f(x):=x^2+x;
                                            2
          (%o1)                    f(x) := x  + x
          (%i2) to_lisp();
          Type (to-maxima) to restart, ($quit) to quit Maxima.
          MAXIMA> (symbol-plist '$f)
          (MPROPS (NIL MEXPR ((LAMBDA) ((MLIST) $X)
                                       ((MPLUS) ((MEXPT) $X 2) $X))))
          MAXIMA> (setq $result ($factor (caddr (mget '$f 'mexpr))))
          ((MTIMES SIMP FACTORED) $X ((MPLUS SIMP IRREDUCIBLE) 1 $X))
          MAXIMA> (to-maxima)
          Returning to Maxima
          (%o2)                         true
          (%i3) result;
          (%o3)                       x (x + 1)

 -- Systemvariable: values
     Anfangswert: `[]'

     `values' ist eine Informationsliste, die die Variablen enthält,
     die vom Nutzer mit den Operatoren `:'  oder `::'  einen Wert
     erhalten haben.  Wird der Wert einer Variablen mit den Kommandos
     `kill',

     `remove'  oder `remvalue'  entfernt, wird die Variable von der
     Liste `values' entfernt.

     Siehe auch `functions'  für die Informationsliste mit den vom
     Nutzer definierten Funktionen sowie `infolists'.

     Beispiele:

          (%i1) [a:99, b::a-90, c:a-b, d, f(x):= x^2];
                                                     2
          (%o1)              [99, 9, 90, d, f(x) := x ]
          (%i2) values;
          (%o2)                       [a, b, c]
          (%i3) [kill(a), remove(b,value), remvalue(c)];
          (%o3)                   [done, done, [c]]
          (%i4) values;
          (%o4)                          []


File: maxima.info,  Node: Funktionen und Variablen der Ausgabe,  Prev: Funktionen und Variablen der Eingabe,  Up: Kommandozeile

4.3 Funktionen und Variablen der Ausgabe
========================================

 -- Optionsvariable: %edispflag
     Standardwert: `false'

     Hat `%edispflag' den Wert `true', zeigt Maxima die Exponentiation
     von `%e'  mit einem negativen Exponenten als Quotienten an.  Siehe
     auch die Optionsvariable `exptdispflag'.

     Beispiel:

          (%i1) %e^-10;
                                         - 10
          (%o1)                        %e
          (%i2) %edispflag:true$
          (%i3) %e^-10;
                                         1
          (%o3)                         ----
                                          10
                                        %e

 -- Optionsvariable: absboxchar
     Standardwert: `!'

     Die Optionsvariable `absboxchar' enthält das Zeichen, das von
     Maxima benutzt wird, um den Betrag eines Ausdruckes anzuzeigen,
     der mehr als eine Zeile benötigt.

     Beispiel:

          (%i1) abs((x^3+1));
                                      ! 3    !
          (%o1)                       !x  + 1!

 -- Funktion: disp (<expr_1>, <expr_2>, ...)
     Ist ähnlich wie die Funktion `display'.    Die Funktion `disp'
     zeigt jedoch keine Gleichungen sondern nur die Ergebnisse der
     Ausdrücke <expr_1>, <expr_2>, ... an.

     Siehe auch die Funktionen `ldisp',  `display'  und `print'.

     Beispiele:

          (%i1) b[1,2]:x-x^2$
          (%i2) x:123$
          (%i3) disp(x, b[1,2], sin(1.0));
                                         123

                                            2
                                       x - x

                                  .8414709848078965

          (%o3)                         done

 -- Funktion: display (<expr_1>, <expr_2>, ...)
     Die Variablen oder Ausdrücke <expr_i> werden als eine Gleichung
     ausgegeben.  Die linke Seite der Gleichung ist die Variable oder
     der Ausdruck <expr_i> und die rechte Seite der Wert der Variablen
     oder das Ergebnis des Ausdrucks.  Die Argumente können Variable,
     indizierte Variable oder Funktionen sein.

     Siehe auch die Funktionen `ldisplay',  `disp'  und `ldisp'.

     Beispiele:

          (%i1) b[1,2]:x-x^2$
          (%i2) x:123$
          (%i3) display(x, b[1,2], sin(1.0));
                                       x = 123

                                                2
                                   b     = x - x
                                    1, 2

                            sin(1.0) = .8414709848078965

          (%o3)                         done

 -- Optionsvariable: display2d
     Standardwert: `true'

     Hat `display2d' den Wert `false', werden Ausdrücke auf der Konsole
     linear und nicht zweidimensional angezeigt.

     Siehe auch die Optionsvariable `leftjust',  um Formeln linksbündig
     auszugeben.

     Beispiel:

          (%i1) x/(x^2+1);
                                         x
          (%o1)                        ------
                                        2
                                       x  + 1
          (%i2) display2d:false$
          (%i3) x/(x^2+1);
          (%o3) x/(x^2+1)

 -- Optionsvariable: display_format_internal
     Standardwert: `false'

     Hat `display_format_internal' den Wert `true', werden Ausdrücke
     für die Anzeige nicht in die externe Darstellung transformiert.
     Die Ausgabe erfolgt wie in der internen Darstellung.  Das
     entspricht der Rückgabe der Funktion `inpart'.

     Siehe die Funktion `dispform'  für Beispiele, die den Unterschied
     zwischen der internen und der externen Darstellung zeigen.

 -- Funktion: dispterms (<expr>)
     Der Ausdruck <expr> wird zeilenweise ausgegeben.  Auf der ersten
     Zeile wird der Operator des Ausdrucks <expr> ausgegeben.  Dann
     werden die Argumente des Operators zeilenweise ausgegeben.  Dies
     kann nützlich sein, wenn ein Ausdruck sehr lang ist.

     Beispiel:

          (%i1) dispterms(2*a*sin(x)+%e^x);

          +

          2 a sin(x)

            x
          %e

          (%o1)                         done

 -- Spezielles Symbol: expt (<a>, <b>)
 -- Spezielles Symbol: ncexpt (<a>, <b>)
     Ist ein Exponentialausdruck zu lang, um ihn als `<a>^<b>'
     anzuzeigen, wird stattdessen `expt(<a>, <b>)' angezeigt.
     Entsprechend wird statt `<a>^^<b>', `ncexpt(<a>, <b>)' angezeigt.
     `expt' und `ncexpt' sind keine Funktionen und erscheinen nur in
     der Ausgabe.

 -- Optionsvariable: exptdispflag
     Standardwert: `true'

     Hat die Optionsvariable `exptdispflag' den Wert `true', werden
     Ausdrücke mit einem negativen Exponenten als Quotient angezeigt.
     Siehe auch die Optionsvariable `%edispflag'.

     Beispiele:

          (%i1) exptdispflag:true;
          (%o1)                         true
          (%i2) 10^-x;
                                          1
          (%o2)                          ---
                                           x
                                         10
          (%i3) exptdispflag:false;
          (%o3)                         false
          (%i4) 10^-x;
                                          - x
          (%o4)                         10

 -- Funktion: grind (<expr>)
 -- Optionsvariable: grind
     Die Funktion `grind' gibt den Ausdruck <expr> auf der Konsole in
     einer Form aus, die für die Eingabe in Maxima geeignet ist.
     `grind' gibt `done' zurück.

     Ist <expr> der Name einer Funktion oder eines Makros, gibt `grind'
     die Definition der Funktion oder des Makros aus.

     Siehe auch die Funktion `string',  die einen Ausdruck als eine
     Zeichenkette zurückgibt.

     Hat die Optionsvariable `grind' den Wert `true', haben die
     Ergebnisse der Funktionen `stringout'  und `string' dasselbe
     Format wie die Funktion `grind'.  Ansonsten werden keine spezielle
     Formatierungen von diesen Funktionen vorgenommen.  Der
     Standardwert der Optionsvariablen `grind' ist `false'.

     `grind' kann auch ein Argument der Funktion `playback'  sein.  In
     diesem Fall gibt `playback' die Eingabe im gleichen Format wie die
     Funktion `grind' aus.

     `grind' wertet das Argument aus.

     Beispiele:

          (%i1) aa + 1729;
          (%o1)                       aa + 1729
          (%i2) grind (%);
          aa+1729$
          (%o2)                         done
          (%i3) [aa, 1729, aa + 1729];
          (%o3)                 [aa, 1729, aa + 1729]
          (%i4) grind (%);
          [aa,1729,aa+1729]$
          (%o4)                         done
          (%i5) matrix ([aa, 17], [29, bb]);
                                     [ aa  17 ]
          (%o5)                      [        ]
                                     [ 29  bb ]
          (%i6) grind (%);
          matrix([aa,17],[29,bb])$
          (%o6)                         done
          (%i7) set (aa, 17, 29, bb);
          (%o7)                   {17, 29, aa, bb}
          (%i8) grind (%);
          {17,29,aa,bb}$
          (%o8)                         done
          (%i9) exp (aa / (bb + 17)^29);
                                          aa
                                      -----------
                                               29
                                      (bb + 17)
          (%o9)                     %e
          (%i10) grind (%);
          %e^(aa/(bb+17)^29)$
          (%o10)                        done
          (%i11) expr: expand ((aa + bb)^10);
                   10           9        2   8         3   7         4   6
          (%o11) bb   + 10 aa bb  + 45 aa  bb  + 120 aa  bb  + 210 aa  bb
                   5   5         6   4         7   3        8   2
           + 252 aa  bb  + 210 aa  bb  + 120 aa  bb  + 45 aa  bb
                  9        10
           + 10 aa  bb + aa
          (%i12) grind (expr);
          bb^10+10*aa*bb^9+45*aa^2*bb^8+120*aa^3*bb^7+210*aa^4*bb^6
               +252*aa^5*bb^5+210*aa^6*bb^4+120*aa^7*bb^3+45*aa^8*bb^2
               +10*aa^9*bb+aa^10$
          (%o12)                        done
          (%i13) string (expr);
          (%o13) bb^10+10*aa*bb^9+45*aa^2*bb^8+120*aa^3*bb^7+210*aa^4*bb^6\
          +252*aa^5*bb^5+210*aa^6*bb^4+120*aa^7*bb^3+45*aa^8*bb^2+10*aa^9*\
          bb+aa^10

 -- Optionsvariable: ibase
     Standardwert: `10'

     `ibase' enthält die Basis der ganzen Zahlen, welche von Maxima
     eingelesen werden.

     `ibase' kann eine ganze Zahl zwischen 2 und einschließlich 36
     zugewiesen werden.  Ist `ibase' größer als 10, werden die Zahlen 0
     bis 9 und die Buchstaben A, B, C, ... für die Darstellung der Zahl
     in der Basis `ibase' herangezogen.  Große und kleine Buchstaben
     werden nicht unterschieden.  Die erste Stelle muss immer eine
     Ziffer sein, damit Maxima den eingelesenen Ausdruck als eine Zahl
     interpretiert.

     Gleitkommazahlen werden immer zur Basis 10 interpretiert.

     Siehe auch `obase'.

     Beispiele:

     `ibase' ist kleiner als 10.

          (%i1) ibase : 2 $
          (%i2) obase;
          (%o2)                          10
          (%i3) 1111111111111111;
          (%o3)                         65535

     `ibase' ist größer als 10.  Die erste Stelle muss eine Ziffer sein.

          (%i1) ibase : 16 $
          (%i2) obase;
          (%o2)                          10
          (%i3) 1000;
          (%o3)                         4096
          (%i4) abcd;
          (%o4)                         abcd
          (%i5) symbolp (abcd);
          (%o5)                         true
          (%i6) 0abcd;
          (%o6)                         43981
          (%i7) symbolp (0abcd);
          (%o7)                         false

     Wird eine ganze Zahl mit einem Dezimalpunkt beendet, wird die Zahl
     als Gleitkommazahl interpretiert.

          (%i1) ibase : 36 $
          (%i2) obase;
          (%o2)                          10
          (%i3) 1234;
          (%o3)                         49360
          (%i4) 1234.;
          (%o4)                         1234

 -- Funktion: ldisp (<expr_1>, ..., <expr_n>)
     Die Ausdrücke <expr_1>, ..., <expr_n> werden auf der Konsole
     ausgegeben.  Dabei wird jedem Ausdruck eine Zwischenmarke
     zugewiesen.  Die Liste der Zwischenmarken wird als Ergebnis
     zurückgegeben.

     Siehe auch die Funktionen `disp',  `display'  und `ldisplay'.

          (%i1) e: (a+b)^3;
                                             3
          (%o1)                       (b + a)
          (%i2) f: expand (e);
                               3        2      2      3
          (%o2)               b  + 3 a b  + 3 a  b + a
          (%i3) ldisp (e, f);
                                             3
          (%t3)                       (b + a)

                               3        2      2      3
          (%t4)               b  + 3 a b  + 3 a  b + a

          (%o4)                      [%t3, %t4]
          (%i4) %t3;
                                             3
          (%o4)                       (b + a)
          (%i5) %t4;
                               3        2      2      3
          (%o5)               b  + 3 a b  + 3 a  b + a

 -- Funktion: ldisplay (<expr_1>, ..., <expr_n>)
     Die Ausdrücke <expr_1>, ..., <expr_n> werden als eine Gleichung
     der Form `lhs = rhs' ausgegeben.  `lhs' ist eines der Argumente der
     Funktion `ldisplay' und `rhs' ist der Wert oder das Ergebnis des
     Argumentes.  Im Unterschied zur Funktion `display' wird jeder
     Gleichung eine Zwischenmarke zugewiesen, die als Liste
     zurückgegeben werden.

     Siehe auch `display',  `disp'  und `ldisp'.

     Beispiele:

          (%i1) e: (a+b)^3;
                                             3
          (%o1)                       (b + a)
          (%i2) f: expand (e);
                               3        2      2      3
          (%o2)               b  + 3 a b  + 3 a  b + a
          (%i3) ldisplay (e, f);
                                               3
          (%t3)                     e = (b + a)

                                 3        2      2      3
          (%t4)             f = b  + 3 a b  + 3 a  b + a

          (%o4)                      [%t3, %t4]
          (%i4) %t3;
                                               3
          (%o4)                     e = (b + a)
          (%i5) %t4;
                                 3        2      2      3
          (%o5)             f = b  + 3 a b  + 3 a  b + a

 -- Optionsvariable: leftjust
     Standardwert: `false'

     Hat die Optionsvariable `leftjust' den Wert `true', werden Formeln
     linksbündig und nicht zentriert ausgegeben.

     Siehe auch die Optionsvariable `display2d',  um zwischen der 1D-
     und 2D-Anzeige umzuschalten.

     Beispiel:

          (%i1) expand((x+1)^3);
                                  3      2
          (%o1)                  x  + 3 x  + 3 x + 1
          (%i2) leftjust:true$
          (%i3) expand((x+1)^3);
                 3      2
          (%o3) x  + 3 x  + 3 x + 1

 -- Optionsvariable: linel
     Standardwert: `79'

     Die Optionsvariable `linel' enthält die Anzahl der Zeichen einer
     Zeile der Ausgabe.  `linel' können beliebige positive ganze Zahlen
     zugewiesen werden, wobei sehr kleine oder große Werte unpraktisch
     sein können.  Text, der von internen Funktionen ausgegeben wird,
     wie Fehlermeldungen oder Ausgaben der Hilfe, werden von `linel'
     nicht beeinflusst.

 -- Optionsvariable: lispdisp
     Standardwert: `false'

     Hat die Optionsvariable `lispdisp' den Wert `true', werden
     Lisp-Symbole mit einem vorangestelltem Fragezeichen `?' angezeigt.

     Beispiele:

          (%i1) lispdisp: false$
          (%i2) ?foo + ?bar;
          (%o2)                       foo + bar
          (%i3) lispdisp: true$
          (%i4) ?foo + ?bar;
          (%o4)                      ?foo + ?bar

 -- Optionsvariable: negsumdispflag
     Standardwert: `true'

     Hat `negsumdispflag' den Wert `true', wird eine Differenz mit zwei
     Argumenten `x - y' als `x - y' und nicht als `-y + x' angezeigt.
     Hat `negsumdispflag' den Wert `false', wird die Differenz als `-y
     + x' angezeigt.

 -- Optionsvariable: obase
     Standardwert: `10'

     `obase' enthält die Basis für ganze Zahlen für die Ausgabe von
     Maxima.  `obase' kann eine ganze Zahl zwischen 2 und
     einschließlich 36 zugewiesen werden.  Ist `obase' größer als 10,
     werden die Zahlen 0 bis 9 und die Buchstaben A, B, C, ... für die
     Darstellung der Zahl in der Basis `obase' herangezogen.  Große und
     kleine Buchstaben werden nicht unterschieden.  Die erste Stelle
     ist immer eine Ziffer.

     Siehe auch `ibase'.

     Beispiele:

          (%i1) obase : 2;
          (%o1)                          10
          (%i2) 2^8 - 1;
          (%o10)                      11111111
          (%i3) obase : 8;
          (%o3)                          10
          (%i4) 8^8 - 1;
          (%o4)                       77777777
          (%i5) obase : 16;
          (%o5)                          10
          (%i6) 16^8 - 1;
          (%o6)                       0FFFFFFFF
          (%i7) obase : 36;
          (%o7)                          10
          (%i8) 36^8 - 1;
          (%o8)                       0ZZZZZZZZ

 -- Optionsvariable: pfeformat
     Standardwert: `false'

     Hat die Optionsvariable `pfeformat' den Wert `true', werden Brüche
     mit ganzen Zahlen auf einer Zeile mit dem Zeichen `/' dargestellt.
     Ist der Nenner eine ganze Zahl, wird dieser als `1/n' vor den
     Ausdruck gestellt.

     Beispiele:

          (%i1) pfeformat: false$
          (%i2) 2^16/7^3;
                                        65536
          (%o2)                         -----
                                         343
          (%i3) (a+b)/8;
                                        b + a
          (%o3)                         -----
                                          8
          (%i4) pfeformat: true$
          (%i5) 2^16/7^3;
          (%o5)                       65536/343
          (%i6) (a+b)/8;
          (%o6)                      1/8 (b + a)

 -- Optionsvariable: powerdisp
     Standardwert: `false'

     Hat `powerdisp' den Wert `true', werden die Terme einer Summe mit
     steigender Potenz angezeigt.  Der Standardwert ist `false' und die
     Terme werden mit fallender Potenz angezeigt.

     Beispiele:

          (%i1) powerdisp:true;
          (%o1)                         true
          (%i2) x^2+x^3+x^4;
                                     2    3    4
          (%o2)                     x  + x  + x
          (%i3) powerdisp:false;
          (%o3)                         false
          (%i4) x^2+x^3+x^4;
                                     4    3    2
          (%o4)                     x  + x  + x

 -- Funktion: print (<expr_1>, ..., <expr_n>)
     Wertet die Argumente <expr_1>, ..., <expr_n> nacheinander von links
     nach rechts aus und zeigt die Ergebnisse an.  `print' gibt das
     Ergebnis des letzten Arguments als Ergebnis zurück.  `print'
     erzeugt keine Zwischenmarken.

     Siehe auch `display',  `disp',  `ldisplay'  und `ldisp'.    Siehe
     `printfile',  um den Inhalt einer Datei anzuzeigen.

     Beispiele:

          (%i1) r: print ("(a+b)^3 is", expand ((a+b)^3), "log (a^10/b) is",
                radcan (log (a^10/b)))$
                      3        2      2      3
          (a+b)^3 is b  + 3 a b  + 3 a  b + a  log (a^10/b) is

                                                        10 log(a) - log(b)
          (%i2) r;
          (%o2)                  10 log(a) - log(b)
          (%i3) disp ("(a+b)^3 is", expand ((a+b)^3), "log (a^10/b) is",
                radcan (log (a^10/b)))$
                                     (a+b)^3 is

                               3        2      2      3
                              b  + 3 a b  + 3 a  b + a

                                   log (a^10/b) is

                                 10 log(a) - log(b)

 -- Optionsvariable: sqrtdispflag
     Standardwert: `true'

     Hat die Optionsvariable den Wert `false', wird die Wurzelfunktion
     als Exponentiation mit dem Exponenten `1/2' angezeigt.

 -- Optionsvariable: stardisp
     Standardwert: `false'

     Hat die Optionsvariable `stardisp' den Wert `true', wird die
     Multiplikation mit einem Stern `*' angezeigt.

 -- Optionsvariable: ttyoff
     Standardwert: `false'

     Hat die Optionsvariable `ttyoff' den Wert `true', werden Ergebnisse
     nicht angezeigt.  Die Ergebnisse werden weiter berechnet und sie
     werden Marken zugewiesen.  Siehe `labels'.

     Textausgaben von Funktionen, wie Fehlermeldungen und Ausgaben der
     Hilfe mit `describe'  werden nicht beeinflusst.


File: maxima.info,  Node: Datentypen und Strukturen,  Next: Ausdrücke,  Prev: Kommandozeile,  Up: Top

5 Datentypen und Strukturen
***************************

* Menu:

* Zahlen::
* Zeichenketten::
* Funktionen und Variablen für Konstante::
* Listen::
* Arrays::
* Strukturen::


File: maxima.info,  Node: Zahlen,  Next: Zeichenketten,  Prev: Datentypen und Strukturen,  Up: Datentypen und Strukturen

5.1 Zahlen
==========

* Menu:

* Einführung in Zahlen::
* Funktionen und Variablen für Zahlen::


File: maxima.info,  Node: Einführung in Zahlen,  Next: Funktionen und Variablen für Zahlen,  Prev: Zahlen,  Up: Zahlen

5.1.1 Einführung in Zahlen
--------------------------

Ganze und rationale Zahlen
--------------------------

Arithmetische Rechnungen mit ganzen oder rationalen Zahlen sind exakt.
Prinzipiell können die ganzen und rationalen Zahlen eine beliebige
Anzahl an Stellen haben.  Eine Obergrenze ist allein der zur Verfügung
stehende Speicherplatz.

     (%i1) 1/3+5/4+3;
                                    55
     (%o1)                          --
                                    12
     (%i2) 100!;
     (%o2) 9332621544394415268169923885626670049071596826438162146859\
     2963895217599993229915608941463976156518286253697920827223758251\
     185210916864000000000000000000000000
     (%i3) 100!/101!;
                                     1
     (%o3)                          ---
                                    101

Funktionen für ganze und rationale Zahlen:

   integerp       numberp       nonnegintegerp
   oddp           evenp
   ratnump        rationalize

Gleitkommazahlen
----------------

Maxima rechnet mit Gleitkommazahlen in doppelter Genauigkeit.
Weiterhin kann Maxima mit großen Gleitkommazahlen rechnen, die
prinzipiell eine beliebige Genauigkeit haben.

Gleitkommazahlen werden mit einem Dezimalpunkt eingegeben.  Der
Exponent kann mit "f", "e" oder "d" angegeben werden.  Intern rechnet
Maxima ausschließlich mit Gleitkommazahlen in doppelter Genauigkeit,
die immer mit "e" für den Exponenten angezeigt werden.  Große
Gleitkommazahlen werden mit dem Exponenten "b" bezeichnet.  Groß- und
Kleinschreibung werden bei der Schreibweise des Exponenten nicht
unterschieden.

     (%i1) [2.0,1f10,1,e10,1d10,1d300];
     (%o1)        [2.0, 1.e+10, 1, e10, 1.e+10, 1.e+300]
     (%i2) [2.0b0,1b10,1b300];
     (%o2)               [2.0b0, 1.0b10, 1.0b300]

Ist mindestens eine Zahl in einer Rechnung eine Gleitkommazahl, werden
die Argumente in Gleitkommazahlen umgewandelt und eine Gleitkommazahl
als Ergebnis zurückgegeben.  Dies wird auch für große Gleitkommazahlen
ausgeführt.

     (%i1) 2.0+1/2+3;
     (%o1)                                 5.5
     (%i2) 2.0b0+1/2+3;
     (%o2)                                5.5b0

Mit den Funktionen `float'  und `bfloat'  werden Zahlen in
Gleitkommazahlen und große Gleitkommazahlen umgewandelt:

     (%i1) float([2,1/2,1/3,2.0b0]);
     (%o1)          [2.0, 0.5, .3333333333333333, 2.0]
     (%i2) bfloat([2,1/2,1/3,2.0b0]);
     (%o2)     [2.0b0, 5.0b-1, 3.333333333333333b-1, 2.0b0]

Funktionen und Variablen für Gleitkommazahlen:

   float        floatnump
   bfloat       bfloatp       fpprec
   float2bf     bftorat       ratepsilon

   number_pbranch
   m1pbranch

Komplexe Zahlen
---------------

Maxima kennt keinen eigenen Typ für komplexe Zahlen.  Komplexe Zahlen
werden von Maxima intern als die Addition von Realteil und dem mit der
Imaginären Einheit `%i'  multiplizierten Imaginärteil dargestellt.  Zum
Beispiel sind die komplexen Zahlen `2 + 3*%i' und `2 - 3*%i' die
Wurzeln der Gleichung `x^2 - 4*x + 13 = 0'.

Maxima vereinfacht Produkte, Quotienten, Wurzeln und andere Ausdrücke
mit komplexen Zahlen nicht automatisch zu einer komplexen Zahl.  Um
Produkte mit komplexen Zahlen zu vereinfachen, kann der Ausdruck mit
der Funktion `expand'  expandiert werden.

Funktionen für komplexe Zahlen:

   realpart     imagpart      rectform     polarform
   cabs         carg          conjugate    csign


File: maxima.info,  Node: Funktionen und Variablen für Zahlen,  Prev: Einführung in Zahlen,  Up: Zahlen

5.1.2 Funktionen und Variablen für Zahlen
-----------------------------------------

 -- Funktion: bfloat (<expr>)
     Konvertiert alle Zahlen im Ausdruck <expr> in große
     Gleitkommazahlen.  Die Anzahl der Stellen wird durch die
     Optionsvariable `fpprec'  spezifiziert.

     Hat die Optionsvariable `float2bf'  den Wert `false', gibt Maxima
     eine Warnung aus, wenn eine Gleitkommazahl mit doppelter
     Genauigkeit in eine große Gleitkommazahl umgewandelt wird.

     Siehe auch die Funktion und den Auswertungsschalter `float'  sowie
     die Optionsvariable `numer'  für die Umwandlung von Zahlen in
     Gleitkommazahlen mit doppelter Genauigkeit.

     Beispiele:

          (%i1) bfloat([2, 3/2, 1.5]);
          (%o1)                 [2.0b0, 1.5b0, 1.5b0]
          (%i2) bfloat(sin(1/2));
          (%o2)                  4.79425538604203b-1
          (%i3) bfloat(%pi),fpprec:45;
          (%o3)    3.1415926535897932384626433832795028841971694b0

 -- Funktion: bfloatp (<number>)
     Gibt den Wert `true' zurück, wenn das Argument <number> eine große
     Gleitkommazahl ist, ansonsten den Wert `false'.

     Siehe auch die Funktionen `numberp',  `floatnump',

     `ratnump'  und `integerp'.

     Beispiele:

          (%i1) bfloatp(1.5b0);
          (%o1)                         true
          (%i2) a:bfloat(%e);
          (%o2)                  2.718281828459045b0
          (%i3) bfloatp(a);
          (%o3)                         true
          (%i4) bfloatp(1.5);
          (%o4)                         false

 -- Optionsvariable: bftorat
     Standardwert: `false'

     Die Optionsvariable `bftorat' kontrolliert die Umwandlung von
     großen Gleitkommazahlen in rationale Zahlen.  Hat `bftorat' den
     Wert `false', wird die Genauigkeit der Umwandlung von der
     Optionsvariablen `ratepsilon'  kontrolliert.  Hat dagegen
     `bftorat' den Wert `true', wird die große Gleitkommazahl exakt
     durch die rationale Zahl repräsentiert.

     Hinweis: `bftorat' hat keinen Einfluss auf die Umwandlung in
     rationale Zahlen mit der Funktion `rationalize'.

     Beispiel:

          (%i1) ratepsilon:1e-4;
          (%o1)                         1.e-4
          (%i2) rat(bfloat(11111/111111)), bftorat:false;
          `rat' replaced 9.99990999991B-2 by 1/10 = 1.0B-1
                                         1
          (%o2)/R/                       --
                                         10
          (%i3) rat(bfloat(11111/111111)), bftorat:true;
          `rat' replaced 9.99990999991B-2 by 11111/111111 = 9.99990999991B-2
                                       11111
          (%o3)/R/                     ------
                                       111111

 -- Optionsvariable: bftrunc
     Standardwert: `true'

     Hat die Optionsvariable `bftrunc' den Wert `true', werden bei der
     Ausgabe einer großen Gleitkommazahl nachfolgende Nullen nicht
     angezeigt.

     Beispiele:

          (%i1) bftrunc:true;
          (%o1)                         true
          (%i2) bfloat(1);
          (%o2)                         1.0b0
          (%i3) bftrunc:false;
          (%o3)                         false
          (%i4) bfloat(1);
          (%o4)                  1.000000000000000b0

 -- Funktion: evenp (<expr>)
     Ist das Argument <expr> eine gerade ganze Zahl, wird `true'
     zurückgegeben.  In allen anderen Fällen wird `false' zurückgegeben.

     `evenp' gibt für Symbole oder Ausdrücke immer den Wert `false'
     zurück, auch wenn das Symbol als gerade ganze Zahl deklariert ist
     oder der Ausdruck eine gerade ganze Zahl repräsentiert.  Siehe die
     Funktion `featurep',  um zu testen, ob ein Symbol oder Ausdruck
     eine gerade ganze Zahl repräsentiert.

     Beispiele:

          (%i1) evenp(2);
          (%o1)                         true
          (%i2) evenp(3);
          (%o2)                         false
          (%i3) declare(n, even);
          (%o3)                         done
          (%i4) evenp(n);
          (%o4)                         false
          (%i5) featurep(n, even);
          (%o5)                         true

 -- Funktion: float (<expr>)
 -- Optionsvariable: float
     Die Funktion `float' konvertiert ganze, rationale und große
     Gleitkommazahlen, die im Argument <expr> enthalten sind, in
     Gleitkommazahlen mit doppelter Genauigkeit.

     `float' ist auch eine Optionsvariable mit dem Standardwert `false'
     und ein Auswertungsschalter für die Funktion `ev'.    Erhält die
     Optionsvariable `float' den Wert `true', werden rationale und
     große Gleitkommazahlen sofort in Gleitkommazahlen umgewandelt.  Als
     Auswertungsschalter der Funktion `ev' hat `float' denselben Effekt,
     ohne dass die Optionsvariable `float' ihren Wert ändert.  Im
     Unterschied zur Funktion `float' werden durch das Setzen der
     Optionsvariablen oder bei Verwendung als Auswertungsschalter keine
     ganze Zahlen in Gleitkommazahlen umgewandelt.  Daher können die
     beiden Kommandos `ev(expr, float)' und `float(expr)' ein
     unterschiedliches Ergebnis haben.

     Siehe auch die Optionsvariable `numer'.

     Beispiele:

     In den ersten zwei Beispielen werden die Zahlen `1/2' und `1' in
     eine Gleitkommazahl umgewandelt.  Die Sinusfunktion vereinfacht
     sodann zu einem numerischen Wert.  Das Auswertungsschalter `float'
     wandelt ganze Zahlen nicht in eine Gleitkommazahl um.  Daher wird
     `sin(1)' nicht zu einem numerischen Wert vereinfacht.

          (%i1) float(sin(1/2));
          (%o1)                   0.479425538604203
          (%i2) float(sin(1));
          (%o2)                   .8414709848078965
          (%i3) sin(1/2),float;
          (%o3)                   0.479425538604203
          (%i4) sin(1),float;
          (%o4)                        sin(1)

 -- Optionsvariable: float2bf
     Standardwert: `true'

     Hat die Optionsvariable `float2bf' den Wert `false', wird eine
     Warnung ausgegeben, wenn eine Gleitkommazahl in eine große
     Gleitkommazahl umgewandelt wird, da die Umwandlung zu einem
     Verlust an Genauigkeit führen kann.

     Beispiele:

          (%i1) float2bf:true;
          (%o1)                         true
          (%i2) bfloat(1.5);
          (%o2)                         1.5b0
          (%i3) float2bf:false;
          (%o3)                         false
          (%i4) bfloat(1.5);
          bfloat: converting float 1.5 to bigfloat.
          (%o4)                         1.5b0

 -- Funktion: floatnump (<number>)
     Gibt den Wert `true' zurück, wenn das Argument <number> eine
     Gleitkommazahl ist.  Ansonsten wird `false' zurückgegeben.  Auch
     wenn <number> eine große Gleitkommazahl ist, ist das Ergebnis
     `false'.

     Siehe auch die Funktionen `numberp',  `bfloatp',

     `ratnump'  und `integerp'.

     Beispiele:

          (%i1) floatnump(1.5);
          (%o1)                         true
          (%i2) floatnump(1.5b0);
          (%o2)                         false

 -- Optionsvariable: fpprec
     Standardwert: 16

     `ffprec' ist die Zahl der Stellen für das Rechnen mit großen
     Gleitkommazahlen.  `ffprec' hat keinen Einfluß auf das Rechnen mit
     Gleitkommazahlen in doppelter Genauigkeit.  Siehe auch `bfloat'
     und `fpprintprec'.

     Beispiele:

          (%i1) fpprec:16;
          (%o1)                          16
          (%i2) bfloat(%pi);
          (%o2)                  3.141592653589793b0
          (%i3) fpprec:45;
          (%o3)                          45
          (%i4) bfloat(%pi);
          (%o4)    3.1415926535897932384626433832795028841971694b0
          (%i5) sin(1.5b0);
          (%o5)   9.97494986604054430941723371141487322706651426b-1

 -- Optionsvariable: fpprintprec
     Standardwert: 0

     `fpprintprec' ist die Anzahl der Stellen, die angezeigt werden,
     wenn eine Gleitkommazahl ausgegeben wird.

     Hat `fpprintprec' einen Wert zwischen 2 und 16, ist die Anzahl der
     angezeigten Stellen für einfache Gleitkommazahlen gleich dem Wert
     von `fpprintprec'.  Hat `fpprintprec' den Wert 0 oder ist größer
     als 16 werden 16 Stellen angezeigt.

     Hat für große Gleitkommazahlen `fpprintprec' einen Wert zwischen 2
     und `fpprec',  ist die Anzahl der angezeigten Stellen gleich
     `fpprintprec'.  Ist der Wert von `fpprintprec' gleich 0 oder
     größer als `fpprec' werden `fpprec' Stellen angezeigt.

     `fpprintprec' kann nicht den Wert 1 erhalten.

     Beispiele:

          (%i1) fpprec:16;
          (%o1)                          16
          (%i2) fpprintprec:5;
          (%o2)                           5
          (%i3) float(%pi);
          (%o3)                        3.1416
          (%i4) bfloat(%pi);
          (%o4)                       3.1415b0
          (%i5) fpprintprec:25;
          (%o5)                          25
          (%i6) bfloat(%pi);
          (%o6)                  3.141592653589793b0
          (%i7) bfloat(%pi);
          (%o7)                  3.141592653589793b0
          (%i8) fpprec:45;
          (%o8)                          45
          (%i9) bfloat(%pi);
          (%o9)             3.141592653589793238462643b0
          (%i10) fpprintprec:45;
          (%o10)                         45
          (%i11) bfloat(%pi);
          (%o11)   3.1415926535897932384626433832795028841971694b0

 -- Funktion: integerp (<number>)
     Hat den Rückgabewert `true', wenn das Argument <number> eine ganze
     Zahl ist.  In allen anderen Fällen gibt `integerp' den Wert `false'
     zurück.

     `integerp' gibt für Symbole oder Ausdrücke immer den Wert `false'
     zurück, auch wenn das Symbol als ganze Zahl deklariert ist oder
     der Ausdruck eine ganze Zahl repräsentiert.  Siehe die Funktion
     `featurep',  um zu testen, ob ein Symbol oder Ausdruck eine ganze
     Zahl repräsentiert.

     Beispiele:

          (%i1) integerp (1);
          (%o1)                         true
          (%i2) integerp (1.0);
          (%o2)                         false
          (%i3) integerp (%pi);
          (%o3)                         false
          (%i4) declare (n, integer)$
          (%i5) integerp (n);
          (%o5)                         false

 -- Optionsvariable: m1pbranch
     Standardwert: `false'

     Die Optionsvariable `m1pbranch' kontrolliert die Vereinfachung der
     Exponentiation von `-1' für den Fall, dass die Optionsvariable
     `domain'  den Wert `complex' hat.  Hat `m1pbranch' für diesen Fall
     den Wert `true', wird die Exponentiation von `-1' zu einem
     Ausdruck vereinfacht, der dem Hauptwert entspricht.  Die
     Auswirkung der Optionsvariable `m1pbranch' ist in der folgenden
     Tabelle gezeigt.

                        domain:real

          (-1)^(1/3):      -1
          (-1)^(1/4):   (-1)^(1/4)

                       domain:complex

          m1pbranch:false          m1pbranch:true
          (-1)^(1/3)               1/2+%i*sqrt(3)/2
          (-1)^(1/4)              sqrt(2)/2+%i*sqrt(2)/2

     Siehe auch die Optionsvariable `numer_pbranch'.


 -- Funktion: nonnegintegerp (<number>)
     Gibt den Wert `true' zurück, wenn `number' eine ganze positive Zahl
     oder Null ist.  Siehe auch `integerp'.

     Beispiele:

          (%i1) nonnegintegerp(2);
          (%o1)                         true
          (%i2) nonnegintegerp(-2);
          (%o2)                         false

 -- Funktion: numberp (<number>)
     Hat das Ergebnis `true', wenn <number> eine ganze, rationale, eine
     Gleitkommazahl oder eine große Gleitkommazahl ist.  Ansonsten ist
     das Ergebnis `false'.

     `numberp' gibt für ein Symbol immer das Ergebnis `false' zurück.
     Dies ist auch dann der Fall, wenn das Symbol eine numerische
     Konstante wie `%pi'  ist oder wenn das Symbol mit der Funktion
     `declare'  eine Eigenschaft wie `integer',  `real'  oder `complex'
     erhalten hat.

     Beispiele:

          (%i1) numberp (42);
          (%o1)                         true
          (%i2) numberp (-13/19);
          (%o2)                         true
          (%i3) numberp (3.14159);
          (%o3)                         true
          (%i4) numberp (-1729b-4);
          (%o4)                         true
          (%i5) map (numberp, [%e, %pi, %i, %phi, inf, minf]);
          (%o5)      [false, false, false, false, false, false]
          (%i6) declare(a,even, b,odd, c,integer, d,rational, e,real);
          (%o6)                         done
          (%i7) map (numberp, [a, b, c, d, e]);
          (%o7) [false, false, false, false, false]

 -- Optionsvariable: numer
     Standardwert: `false'

     Hat die Optionsvariable `numer' den Wert `true', werden rationale
     Zahlen und große Gleitkommazahlen in Gleitkommazahlen umgewandelt.
     Weiterhin werden Konstante wie zum Beispiel `%pi',  die einen
     numerischen Wert haben, durch diesen ersetzt.  Mathematische
     Funktionen mit numerischen Argumenten vereinfachen zu einer
     Gleitkommazahl.  Wird die Optionsvariable `numer' gesetzt, erhält
     die Optionsvariable `float'  denselben Wert.  Im Unterschied zur
     Optionsvariablen `float' vereinfachen auch mathematische
     Funktionen mit einem ganzzahligen Wert wie zum Beispiel `sin(1)'
     zu einem numerischen Wert.

     `numer' ist auch ein Auswertungsschalter der Funktion `ev'.    Der
     Auswertungsschalter hat die gleiche Funktionsweise wie die
     Optionsvariable, ohne dass die Optionsvariable ihren Wert ändert.

     Siehe auch `float'  und `%enumer'.

     Beispiele:

     Erhält `numer' den Wert `true', werden rationale Zahlen, Konstante
     mit einem numerischen Wert und mathematische Funktionen mit
     numerischen Argumenten zu einer Gleitkommazahl ausgewertet oder
     vereinfacht.

          (%i1) numer:false;
          (%o1)                         false
          (%i2) [1, 1/3, %pi, sin(1)];
                                     1
          (%o2)                  [1, -, %pi, sin(1)]
                                     3
          (%i3) numer:true;
          (%o3)                         true
          (%i4) [1, 1/3, %pi, sin(1)];
          (%o4) [1, .3333333333333333, 3.141592653589793,
                                                         .8414709848078965]

     `numer' ist auch ein Auswertungsschalter der Funktion `ev'.  Hier
     wird die Kurzschreibweise der Funktion `ev' verwendet.

          (%i1) [sqrt(2), sin(1), 1/(1+sqrt(3))];
                                                  1
          (%o1)            [sqrt(2), sin(1), -----------]
                                             sqrt(3) + 1

          (%i2) [sqrt(2), sin(1), 1/(1+sqrt(3))],numer;
          (%o2) [1.414213562373095, .8414709848078965, .3660254037844387]

 -- Optionsvariable: numer_pbranch
     Standardwert: `false'

     Die Optionsvariable `numer_pbranch' kontrolliert die Vereinfachung
     der Exponentiation einer negativen ganzen, rationalen oder
     Gleitkommazahl.  Hat `numer_pbranch' den Wert `true' und ist der
     Exponent eine Gleitkommazahl oder hat die Optionsvariable `numer'
     den Wert `true', dann berechnet Maxima den Hauptwert der
     Exponentiation.  Ansonsten wird ein vereinfachter Ausdruck, aber
     nicht numerischer Wert zurückgegeben.  Siehe auch die
     Optionsvariable `m1pbranch'.

     Beispiele:

          (%i1) (-2)^0.75;
          (%o1) (-2)^0.75

          (%i2) (-2)^0.75,numer_pbranch:true;
          (%o2) 1.189207115002721*%i-1.189207115002721

          (%i3) (-2)^(3/4);
          (%o3) (-1)^(3/4)*2^(3/4)

          (%i4) (-2)^(3/4),numer;
          (%o4) 1.681792830507429*(-1)^0.75

          (%i5) (-2)^(3/4),numer,numer_pbranch:true;
          (%o5) 1.189207115002721*%i-1.189207115002721

 -- Funktion: numerval (<x_1>, <val_1>, ..., <var_n>, <val_n>)
     Die Variablen <x_1>, ..., <x_n> erhalten die numerischen Werte
     <val_1>, ..., `val_n'.  Die numerischen Werte werden immer dann
     für die Variablen in Ausdrücke eingesetzt, wenn die Optionsvariable
     `numer'  den Wert `true' hat.  Siehe auch `ev'.

     Die Argumente <val_1>, ..., <val_n> können auch beliebige
     Ausdrücke sein, die wie numerische Werte für Variablen eingesetzt
     werden.

     Beispiele:

          (%i1) numerval(a, 123, b, x^2)$

          (%i2) [a, b];
          (%o2)                        [a, b]
          (%i3) numer:true;
          (%o3)                         true
          (%i4) [a, b];
                                             2
          (%o4)                       [123, x ]

 -- Funktion: oddp (<expr>)
     Gibt `true' zurück, wenn das Argument <expr> eine ungerade ganze
     Zahl ist.  In allen anderen Fällen wird `false' zurückgegeben.

     `oddp' gibt für Symbole oder Ausdrücke immer den Wert `false'
     zurück, auch wenn das Symbol als ungerade ganze Zahl deklariert
     ist oder der Ausdruck eine ungerade ganze Zahl repräsentiert.
     Siehe die Funktion `featurep',  um zu testen, ob ein Symbol oder
     Ausdruck eine ungerade ganze Zahl repräsentiert.

     Beispiele:

          (%i1) oddp(3);
          (%o1)                         true
          (%i2) oddp(2);
          (%o2)                         false
          (%i3) declare(n,odd);
          (%o3)                         done
          (%i4) oddp(n);
          (%o4)                         false
          (%i5) featurep(n,odd);
          (%o5)                         true

 -- Optionsvariable: ratepsilon
     Standardwert: `2.0e-15'

     Die Optionsvariable `ratepsilon' kontrolliert die Genauigkeit, mit
     der Gleitkommazahlen in rationale Zahlen umgewandelt werden, wenn
     die Optionsvariable `bftorat' den Wert `false' hat.  Für ein
     Beispiel siehe die Optionsvariable `bftorat'.


 -- Funktion: rationalize (<expr>)
     Konvertiert alle Gleitkommazahlen einschließlich großer
     Gleitkommazahlen, die in dem Ausdruck <expr> auftreten, in
     rationale Zahlen.

     Es mag überraschend sein, dass `rationalize(0.1)' nicht das
     Ergebnis `1/10' hat.  Dies ist nicht speziell für Maxima.  Ursache
     ist, dass die gebrochene Zahl `1/10' in der internen Darstellung
     als binäre Zahl keine endliche Darstellung hat.

     Siehe auch die Funktionen `float'  und `bfloat'  sowie die
     Auswertungsschalter `float'  und `numer',  um eine rationale Zahl
     in eine Gleitkommazahl umzuwandeln.

     Beispiele:

          (%i1) rationalize (0.5);
                                          1
          (%o1)                           -
                                          2
          (%i2) rationalize (0.1);
                                  3602879701896397
          (%o2)                   -----------------
                                  36028797018963968
          (%i3) fpprec : 5$
          (%i4) rationalize (0.1b0);
                                       209715
          (%o4)                        -------
                                       2097152
          (%i5) fpprec : 20$
          (%i6) rationalize (0.1b0);
                               236118324143482260685
          (%o6)                ----------------------
                               2361183241434822606848
          (%i7) rationalize (sin (0.1*x + 5.6));
                         3602879701896397 x   3152519739159347
          (%o7)      sin(------------------ + ----------------)
                         36028797018963968    562949953421312
          (%i8) float(%);
          (%o8)                          sin(0.1 x + 5.6)

 -- Funktion: ratnump (<number>)
     Gibt `true' zurück, wenn <number> eine ganze oder rationale Zahl
     ist.  In allen anderen Fällen ist das Ergebnis `false'.

     Siehe auch die Funktionen `numberp',  `integerp',

     `floatnump'  und `bfloatp'.

     Beispiele:

          (%i1) ratnump(1/2);
          (%o1)                         true
          (%i2) ratnump(3);
          (%o2)                         true
          (%i3) ratnump(3.0);
          (%o3)                         false


File: maxima.info,  Node: Zeichenketten,  Next: Funktionen und Variablen für Konstante,  Prev: Zahlen,  Up: Datentypen und Strukturen

5.2 Zeichenketten
=================

* Menu:

* Einführung in Zeichenketten::
* Funktionen und Variablen für Zeichenketten::


File: maxima.info,  Node: Einführung in Zeichenketten,  Next: Funktionen und Variablen für Zeichenketten,  Prev: Zeichenketten,  Up: Zeichenketten

5.2.1 Einführung in Zeichenketten
---------------------------------

Zeichenketten werden bei der Eingabe in Anführungszeichen gesetzt.  Sie
werden standardmäßig ohne Anführungszeichen ausgegeben.  Hat die
Optionsvariable `stringdisp'  den Wert `true', werden Zeichenketten mit
Anführungszeichen dargestellt.

Zeichenketten können jedes Zeichen einschließlich Tabulator-,
Zeilenvorschub- oder Wagenrücklauf-Zeichen enthalten.  Das
Anführungszeichen wird innerhalb einer Zeichenkette durch `\"' und der
Backslash durch `\\' dargestellt.  Ein Backslash am Ende einer
Eingabezeile erlaubt die Fortsetzung einer Zeichenkette in der nächsten
Zeile.  Maxima kennt keine weiteren Kombinationen mit einem Backslash.
Daher wird der Backslash an anderer Stelle ignoriert.  Maxima kennt
keine andere Möglichkeit, als spezielle Zeichen wie ein Tabulator-,
Zeilenvorschub- oder Wagenrücklaufzeichen in einer Zeichenkette
darzustellen.

Maxima hat keinen Typ für ein einzelnes Zeichen.  Einzelne Zeichen
werden daher als eine Zeichenkette mit einem Zeichen dargestellt.
Folgende Funktionen und Variablen arbeiten mit Zeichenketten:

   concat   sconcat   string   stringdisp

Das Zusatzpaket `stringproc' enthält eine umfangreiche Bibliothek an
Funktionen für Zeichenketten.  Siehe *note stringproc::.

Beispiele:

     (%i1) s_1 : "This is a string.";
     (%o1)               This is a string.
     (%i2) s_2 : "Embedded \"double quotes\" and backslash \\ characters.";
     (%o2) Embedded "double quotes" and backslash \ characters.
     (%i3) s_3 : "Embedded line termination
     in this string.";
     (%o3) Embedded line termination
     in this string.
     (%i4) s_4 : "Ignore the \
     line termination \
     characters in \
     this string.";
     (%o4) Ignore the line termination characters in this string.
     (%i5) stringdisp : false;
     (%o5)                         false
     (%i6) s_1;
     (%o6)                   This is a string.
     (%i7) stringdisp : true;
     (%o7)                         true
     (%i8) s_1;
     (%o8)                  "This is a string."


File: maxima.info,  Node: Funktionen und Variablen für Zeichenketten,  Prev: Einführung in Zeichenketten,  Up: Zeichenketten

5.2.2 Funktionen und Variablen für Zeichenketten
------------------------------------------------

 -- Funktion: concat (<arg_1>, <arg_2>, ...)
     Verkettet die Argumente <arg_1>, <arg_2>, ... zu einer Zeichenkette
     oder einem Symbol.  Die Argumente müssen sich zu einem Atom
     auswerten lassen.  Der Rückgabewert ist ein Symbol, wenn das erste
     Argument ein Symbol ist.  Ansonsten wird eine Zeichenkette
     zurückgegeben.

     `concat' wertet die Argumente aus.  Der Quote-Operator  `''
     verhindert die Auswertung.  Siehe auch die Funktion `sconcat'.

     Beispiele:

          (%i1) y: 7$
          (%i2) z: 88$
          (%i3) stringdisp:true$
          (%i4) concat(y, z/2);
          (%o4)                         "744"
          (%i5) concat('y, z/2);
          (%o5)                          y44

     Einem Symbol, das mit `concat' konstruiert wird, kann ein Wert
     zugewiesen werden und es kann in Ausdrücken auftreten.

          (%i6) a: concat ('y, z/2);
          (%o6)                          y44
          (%i7) a:: 123;
          (%o7)                          123
          (%i8) y44;
          (%o8)                          123
          (%i9) b^a;
                                         y44
          (%o9)                         b
          (%i10) %, numer;
                                          123
          (%o11)                         b

     `concat(1, 2)' gibt eine Zeichenkette als Ergebnis zurück.

          (%i12) concat (1, 2) + 3;
          (%o12)                       "12" + 3

 -- Funktion: sconcat (<arg_1>, <arg_2>, ...)
     Verkettet die Argumente <arg_1>, <arg_2>, ... zu einer
     Zeichenkette.  Im Unterschied zu der Funktion `concat'  müssen die
     Argumente nicht Atome sein.  Der Rückgabewert ist eine
     Zeichenkette.

     Beispiel:

          (%i1) sconcat ("xx[", 3, "]:", expand ((x+y)^3));
          (%o1)               xx[3]:y^3+3*x*y^2+3*x^2*y+x^3

 -- Funktion: string (<expr>)
     Konvertiert das Argument `expr' in eine lineare Darstellung, wie
     sie auch vom Parser von der Eingabe eingelesen wird.  Die Rückgabe
     von `string' ist eine Zeichenkette.  Diese kann nicht als Eingabe
     für eine Berechnung genutzt werden.

     Beispiele:

     Die hier verwendete Funktion `stringp'  ist im Paket `stringproc'

     definiert und wird automatisch geladen.

          (%i1) stringdisp:true;
          (%o1)                         true
          (%i2) string(expand((a+b)^2));
          (%o2)                    "b^2+2*a*b+a^2"
          (%i3) stringp(%);
          (%o3)                         true

 -- Optionsvariable: stringdisp
     Standardwert: `false'

     Hat `stringdisp' den Wert `true', werden Zeichenketten mit
     Anführungszeichen ausgegeben.  Ansonsten werden keine
     Anführungszeichen ausgegeben.

     Wird die Definition einer Funktion ausgegeben, werden enthaltene
     Zeichenketten unabhängig vom Wert der Optionsvariablen
     `stringdisp' immer mit Anführungszeichen ausgegeben.

     Beispiele:

          (%i1) stringdisp: false$
          (%i2) "This is an example string.";
          (%o2)              This is an example string.
          (%i3) foo () :=
                print ("This is a string in a function definition.");
          (%o3) foo() :=
                        print("This is a string in a function definition.")
          (%i4) stringdisp: true$
          (%i5) "This is an example string.";
          (%o5)             "This is an example string."


File: maxima.info,  Node: Funktionen und Variablen für Konstante,  Next: Listen,  Prev: Zeichenketten,  Up: Datentypen und Strukturen

5.3 Funktionen und Variablen für Konstante
==========================================

 -- Konstante: %e
     `%e' ist die Basis des natürlichen Logarithmus, auch Eulersche Zahl
     genannt.  Der numerische Wert der Konstanten als Gleitkommazahl
     mit doppelter Genauigkeit ist 2.718281828459045d0.

     Die Funktion `bfloat'  kann `%e' mit einer beliebigen Genauigkeit
     berechnen.

     Hat die Optionsvariable `numer'  den Wert `true', wird `%e' durch
     den numerischen Wert ersetzt, aber nicht, wenn `%e' die Basis der
     Exponentiation mit einem symbolischen Exponenten ist.  Hat
     zusätzlich die Optionsvariable `%enumer'  den Wert `true', dann
     wird `%e' in einem Ausdruck immer durch den numerischen Wert
     ersetzt.

     Beispiel:

     Berechnung von `%e' auf 48 Stellen.

          (%i1) fpprec: 48$
          (%i2) bfloat(%e);
          (%o2)  2.7182818284590452353602874713526624977572470937b0

     Die Wirkung der Optionsvariablen `numer' und `%enumer' auf das
     Ersetzen von `%e' durch den numerischen Wert.

          (%i1) %e, numer;
          (%o1)                   2.718281828459045
          (%i2) %e^x, numer;
                                           x
          (%o2)                          %e
          (%i3) %e^x, numer, %enumer;
                                                  x
          (%o3)                  2.718281828459045

     Im ersten Beispiel vereinfacht die Reihe zu `%e'.  Für die
     Vereinfachung der Reihe wird die Funktion `simplify_sum'  geladen.
     Im zweiten Beispiel ist `%e' der Grenzwert.

          (%i1) load(simplify_sum)$

          (%i2) sum(1/n!, n, 0, inf);
                                      inf
                                      ====
                                      \     1
          (%o2)                        >    --
                                      /     n!
                                      ====
                                      n = 0
          (%i3) simplify_sum(%);

          (%o3)                          %e

          (%i4) limit((1+x)^(1/x), x, 0);
          (%o4)                          %e

 -- Konstante: %i
     `%i' ist die imaginäre Einheit.

     Maxima kennt keinen eigenen Typ für komplexe Zahlen.  Komplexe
     Zahlen werden von Maxima intern als die Addition von Realteil und
     dem mit der imaginären Einheit `%i'  multiplizierten Imaginärteil
     dargestellt.  Zum Beispiel sind die komplexen Zahlen `2 + 3*%i'
     und `2 - 3*%i' die Wurzeln der Gleichung `x^2 - 4*x + 13 = 0'.
     Siehe auch das Kapitel Zahlen.

     Beispiele:

     Einige Beispiele für das Rechnen mit der imaginären Einheit.

          (%i1) sqrt(-1);
          (%o1)                          %i
          (%i2) %i^2;
          (%o2)                          - 1
          (%i3) exp(%i*%pi/2);
          (%o3)                          %i
          (%i4) sin(%i*x);
          (%o4)                      %i sinh(x)

 -- Konstante: false
     Repräsentiert den logischen Wert `falsch'.  `false' wird intern
     von Maxima durch die Lisp-Konstante `NIL' dargestellt.

     Siehe auch `true'  für den logischen Wert `wahr'.

 -- Konstante: %gamma
     Die Euler-Mascheroni-Konstante mit dem Wert `0.5772156649015329'
     als Gleitkommazahl in doppelter Genauigkeit.

     Die Funktion `bfloat'  kann `%gamma' mit einer beliebigen
     Genauigkeit berechnen.

     Hat die Optionsvariable `numer'  den Wert `true', wird die
     Konstante `%gamma' durch ihren numerischen Wert ersetzt.

     Beispiele:

     Numerische Werte für `%gamma'.

          (%i1) %gamma, numer;
          (%o1)                   .5772156649015329
          (%i2) bfloat(%gamma), fpprec: 48;
          (%o2)  5.7721566490153286060651209008240243104215933594b-1

     Bestimmte Integrale, die `%gamma' als Ergebnis haben.

          (%i1) -integrate(exp(-t)*log(t), t, 0, inf);
          (%o1)                        %gamma
          (%i2) -integrate(log(log(1/t)),t, 0,1);
          (%o2)                        %gamma

 -- Konstante: ind
     `ind' repräsentiert ein unbestimmtes Ergebnis.  Siehe auch `und'

     und die Funktion `limit'.

     Beispiel:

          (%i1) limit(sin(1/x), x, 0);
          (%o1)                          ind

 -- Konstante: inf
     `inf' repräsentiert einen positiven unendlich großen Wert.  Siehe
     auch `minf'  und `infinity'.

     Die unendlichen Größen, aber auch die unbestimmten Größen `ind'
     und `und',  eignen sich nicht für das arithmetische Rechnen.
     Diese Größen werden von Maxima in Rechnungen wie Symbole
     behandelt, was zu fehlerhaften Ergebnissen führt.  Daher sollten
     unendliche Größen nur im Zusammenhang mit Grenzwerten `limit',
     bestimmten Integralen `integrate'  oder Reihen `sum'  verwendet
     werden.

 -- Konstante: infinity
     `infinity' repräsentiert einen komplexen unendlichen Wert.  Siehe
     auch `inf'  und `minf'.

     Die unendlichen Größen, aber auch die unbestimmten Größen `ind'
     und `und',  eignen sich nicht für das arithmetische Rechnen.
     Diese Größen werden von Maxima in Rechnungen wie Symbole
     behandelt, was zu fehlerhaften Ergebnissen führt.  Daher sollten
     unendliche Größen nur im Zusammenhang mit Grenzwerten `limit',
     bestimmten Integralen `integrate'  oder Reihen `sum'  verwendet
     werden.

 -- Konstante: minf
     `minf' repräsentiert einen negativen unendlichen Wert.  Siehe auch
     `inf'  und `infinity'.

     Die unendlichen Größen, aber auch die unbestimmten Größen `ind'
     und `und',  eignen sich nicht für das arithmetische Rechnen.
     Diese Größen werden von Maxima in Rechnungen wie Symbole
     behandelt, was zu fehlerhaften Ergebnissen führt.  Daher sollten
     unendliche Größen nur im Zusammenhang mit Grenzwerten `limit',
     bestimmten Integralen `integrate'  oder Reihen `sum'  verwendet
     werden.

 -- Konstante: %phi
     `%phi' repräsentiert die Goldene Zahl (1 + sqrt(5))/2.  Der Wert
     als Gleitkommazahl in doppelter Genauigkeit ist
     1.618033988749895d0.

     Die Funktion `fibtophi'  drückt Fibonacci-Zahlen `fib(n)' durch die
     Goldene Zahl `%phi' aus.  Standardmäßig kennt Maxima keine
     algebraischen Eigenschaften der Konstanten `%phi'.  Mit den
     Eingaben `tellrat(%phi^2-%phi-1)' und `algebraic: true' kann die
     Funktion `ratsimp'  einige Vereinfachungen ausführen.

     Die Funktion `bfloat'  kann `%phi' mit einer beliebigen Genauigkeit
     berechnen.  Hat die Optionsvariable `numer'  den Wert `true', wird
     die Konstante `%phi' durch ihren numerischen Wert ersetzt.

     Beispiele:

     Numerische Werte für `%phi'.

          (%i1) %phi, numer;
          (%o1)                   1.618033988749895
          (%i2) bfloat(%phi), fpprec: 48;
          (%o2)  1.61803398874989484820458683436563811772030917981b0

     `fibtophi' drückt Fibonacci-Zahlen `fib(n)' durch `%phi' aus.

          (%i1) fibtophi (fib (n));
                                     n             n
                                 %phi  - (1 - %phi)
          (%o1)                  -------------------
                                     2 %phi - 1
          (%i2) fib (n-1) + fib (n) - fib (n+1);
          (%o2)          - fib(n + 1) + fib(n) + fib(n - 1)
          (%i3) fibtophi (%);
                      n + 1             n + 1       n             n
                  %phi      - (1 - %phi)        %phi  - (1 - %phi)
          (%o3) - --------------------------- + -------------------
                          2 %phi - 1                2 %phi - 1
                                                    n - 1             n - 1
                                                %phi      - (1 - %phi)
                                              + ---------------------------
                                                        2 %phi - 1
          (%i4) ratsimp (%);
          (%o4)                           0

     Mit den Eingaben `tellrat(%phi^2-%phi-1)' und `algebraic:true' kann
     die Funktion `ratsimp' einige Vereinfachungen für Ausdrücke
     ausführen, die `%phi' enthalten.

          (%i1) e : expand ((%phi^2 - %phi - 1) * (A + 1));
                           2                      2
          (%o1)        %phi  A - %phi A - A + %phi  - %phi - 1
          (%i2) ratsimp (e);
                            2                     2
          (%o2)        (%phi  - %phi - 1) A + %phi  - %phi - 1
          (%i3) tellrat (%phi^2 - %phi - 1);
                                      2
          (%o3)                  [%phi  - %phi - 1]
          (%i4) algebraic : true;
          (%o4)                         true
          (%i5) ratsimp (e);
          (%o5)                           0

 -- Konstante: %pi
     `%pi' repräsentiert die Kreiszahl.  Der numerische Wert als
     Gleitkommazahl in doppelter Genauigkeit ist `3.141592653589793d0'.

     Die Funktion `bfloat'  kann `%pi' mit einer beliebigen Genauigkeit
     berechnen.  Hat die Optionsvariable `numer'  den Wert `true', wird
     die Konstante `%pi' durch ihren numerischen Wert ersetzt.

     Beispiele:

     Numerische Werte für `%pi'.

          (%i1) %pi, numer;
          (%o1)                   3.141592653589793
          (%i2) bfloat(%pi), fpprec:48;
          (%o2)  3.14159265358979323846264338327950288419716939938b0

     Grenzwert und bestimmte Integrale, die `%pi' als Ergebnis haben.

          (%i1) 'limit(n!^2*(n+1)^(2*n^2+n)/(2*n^(2*n^2+3*n+1)),n,inf);
                                  2                     2
                             - 2 n  - 3 n - 1        2 n  + n   2
                   limit    n                 (n + 1)         n!
                   n -> inf
          (%o1)    ----------------------------------------------
                                         2
          (%i2) %, nouns;
          (%o2)                          %pi
          (%i3) 'integrate(4*sqrt(1-t^2),t,0,1);
                                   1
                                  /
                                  [            2
          (%o3)                 4 I  sqrt(1 - t ) dt
                                  ]
                                  /
                                   0
          (%i4) %, nouns;
          (%o4)                          %pi
          (%i5) 'integrate(2*exp(-t^2),t,0,inf);
                                     inf
                                    /         2
                                    [      - t
          (%o5)                   2 I    %e     dt
                                    ]
                                    /
                                     0
          (%i6) %, nouns;
          (%o6)                       sqrt(%pi)

 -- Konstante: true
     `true' repräsentiert den logischen Wert `wahr'.  Intern ist `true'
     als die Lisp-Konstante `T' implementiert.

     Siehe auch `false'  für den logischen Wert `falsch'.

 -- Konstante: und
     `und' repräsentiert ein nicht definiertes Ergebnis.  Siehe auch
     `ind'  und die Funktion `limit'.

     Beispiel:

          (%i1) limit (x*sin(x), x, inf);
          (%o1)                          und

 -- Konstante: zeroa
     `zeroa' repräsentiert eine positive unendlich kleine Zahl.  `zeroa'
     kann in Ausdrücken benutzt werden.  Die Funktion `limit'
     vereinfacht Ausdrücke, die infinitesimale Größen enthalten.

     Siehe auch `zerob'  und `limit'.

     Beispiele:

     `limit' vereinfacht Ausdrücke, die infinitesimale Größen enthalten.

          (%i1) limit(zeroa);
          (%o1)                           0
          (%i2) limit(x+zeroa);
          (%o2)                           x

 -- Konstante: zerob
     `zerob' repräsentiert eine negative unendlich kleine Zahl.  `zerob'
     kann in Ausdrücken benutzt werden.  Die Funktion `limit'
     vereinfacht Ausdrücke, die infinitesimale Größen enthalten.

     Siehe auch `zeroa'  und `limit'.



File: maxima.info,  Node: Listen,  Next: Arrays,  Prev: Funktionen und Variablen für Konstante,  Up: Datentypen und Strukturen

5.4 Listen
==========

* Menu:

* Einführung in Listen::
* Funktionen und Variablen für Listen::


File: maxima.info,  Node: Einführung in Listen,  Next: Funktionen und Variablen für Listen,  Prev: Listen,  Up: Listen

5.4.1 Einführung in Listen
--------------------------

Listen werden in Maxima mit eckigen Klammern eingegeben und angezeigt:

     [a, b, c, ...]

Die Elemente einer Liste können Zahlen, Symbole, Ausdrücke und auch
Listen sein, wodurch verschachtelte Listen entstehen:

     (%i1) [1, 1/2, a, a+b, sin(x), [log(y)^2, y]];
                      1                        2
     (%o1)        [1, -, a, b + a, sin(x), [log (y), y]]
                      2

Mit den Funktionen `makelist'  und `create_list'  können Listen aus
Ausdrücken generiert werden.  Die Funktion `copylist'  erzeugt eine
Kopie einer Liste.  Auf einzelne Elemente oder Teile von Listen kann
mit den Funktionen `first',  `rest'  oder `last'  zugegriffen werden.
Mit der Aussagefunktion `listp'  kann getestet werden, ob eine Liste
vorliegt.  Für das Arbeiten mit Listen kennt Maxima die folgenden
Funktionen:

   append        assoc     cons      copylist
   create_list   delete    eighth    endcons
   fifth         first     fourth    join
   last          length    listp     makelist
   member        ninth     pop       push
   rest          reverse   second    seventh
   sixth         sort      sublist   sublist_indices
   tenth         third

Da Maxima intern alle Ausdrücke als Listen darstellt, können viele der
oben aufgeführten Funktionen nicht nur auf Maxima-Listen, sondern auch
auf allgemeine Ausdrücke angewendet werden.  So wird zum Beispiel die
Addition der drei Symbole `a', `b', `c' von Maxima intern folgendermaßen
als eine Lisp-Liste dargestellt:

        ((MPLUS) $A $B $C)

Der Operator der Addition ist `MPLUS' und die Symbole `$A', `$B' und
`$C' sind die Argumente des Operators.  Alle Funktionen für Listen, die
nur auf die Argumente wirken, können auch auf allgemeine Ausdrücke
angewendet werden.  Im folgenden werden zum Beispiel die Funktionen
`first',  `last',  `cons'  und `delete'  auf eine Addition angewendet:

     (%i1) expr: a + b + c;
     (%o1)                       c + b + a
     (%i2) first(expr);
     (%o2)                           c
     (%i3) last(expr);
     (%o3)                           a
     (%i4) cons(2*x, expr);
     (%o4)                    2 x + c + b + a
     (%i5) delete(b, expr);
     (%o5)                         c + a

Weitere Beispiele für die Anwendung der Funktionen für Listen auf
allgemeine Ausdrücke sind bei den einzelnen Funktionen angegeben.  Eine
ausführliche Beschreibung der internen Darstellung von
Maxima-Ausdrücken ist in *note Ausdrücke:: enthalten.

Auf die einzelnen Elemente einer Liste kann direkt über einen Index
zugegriffen werden.  Bezeichnet der Index kein Element der Liste, gibt
Maxima eine Fehlermeldung aus.  Im Folgenden werden Beispiele gezeigt:

     (%i1) list : [a,b,c];
     (%o1)                       [a, b, c]
     (%i2) list[1];
     (%o2)                           a
     (%i3) list[2];
     (%o3)                           b
     (%i4) list[3];
     (%o4)                           c
     (%i5) list[1]: sin(x);
     (%o5)                        sin(x)
     (%i6) list[2]: cos(x);
     (%o6)                        cos(x)
     (%i7) list[3]: tan(x);
     (%o7)                        tan(x)
     (%i8) list;
     (%o8)               [sin(x), cos(x), tan(x)]

Listen können auch als Argument einer Funktion auftreten.  Hat die
Funktion die Eigenschaft `distribute_over',  dann wird die Funktion auf
die Elemente der Liste angewendet.  Dies funktioniert auch für
Funktionen mit mehreren Argumenten.

     (%i1) sin([x,y,z]);
     (%o1)               [sin(x), sin(y), sin(z)]
     (%i2) mod([x,y],3);
     (%o2)                [mod(x, 3), mod(y, 3)]
     (%i3) mod([x,y],[5,7]);
     (%o3)   [[mod(x, 5), mod(x, 7)], [mod(y, 5), mod(y, 7)]]


File: maxima.info,  Node: Funktionen und Variablen für Listen,  Prev: Einführung in Listen,  Up: Listen

5.4.2 Funktionen und Variablen für Listen
-----------------------------------------

 -- Operator: [
 -- Operator: ]
     Die Operatoren `[' und `]' markieren den Anfang und das Ende einer
     Liste.

     `[' und `]' schließen auch die Indizes von Symbolen, Arrays,
     Hash-Arrays oder Array-Funktionen ein.

     Beispiele:

          (%i1) x: [a, b, c];
          (%o1)                       [a, b, c]
          (%i2) x[3];
          (%o2)                           c
          (%i3) array (y, fixnum, 3);
          (%o3)                           y
          (%i4) y[2]: %pi;
          (%o4)                          %pi
          (%i5) y[2];
          (%o5)                          %pi
          (%i6) z['foo]: 'bar;
          (%o6)                          bar
          (%i7) z['foo];
          (%o7)                          bar
          (%i8) g[k] := 1/(k^2+1);
                                            1
          (%o8)                     g  := ------
                                     k     2
                                          k  + 1
          (%i9) g[10];
                                          1
          (%o9)                          ---
                                         101

 -- Funktion: append (<list_1>, ..., <list_n>)
     Gibt eine Liste mit den Elementen der Listen <list_1>, ...,
     <list_n> zurück.  Ist eines der Argumente <list_1>, ..., <list_n>
     keine Liste meldet Maxima einen Fehler.

     `append' kann auch für allgemeine Ausdrücke genutzt werden.  So
     hat zum Beispiel `append(f(a,b), f(c,d,e))' das Ergebnis
     `f(a,b,c,d,e)'.  In diesem Fall muss der Operator, der hier `f'
     ist, für beide Ausdrücke identisch sein, ansonsten meldet Maxima
     einen Fehler.

     Siehe auch die Funktionen `cons'  und `endcons',  um ein Element
     einer Liste hinzuzufügen.

     Beispiele:

     In den ersten Beispielen werden jeweils Listen mit verschiedenen
     Elementen zusammengefügt.  Im letzten Beispiel wird `append'
     genutzt, um zwei Additionen zusammenzusetzen.

          (%i1) append([a,b], [x,y,z], [1]);
          (%o1)                  [a, b, x, y, z, 1]
          (%i2) append([x+y, 0, -3.2], [2.5e+20, x]);
          (%o2)             [y + x, 0, - 3.2, 2.5e+20, x]
          (%i3) append([2*a+b], [x+y]);
          (%o3)                   [b + 2 a, y + x]
          (%i4) append(2*a+b, x+y);
          (%o4)                    y + x + b + 2 a

 -- Funktion: assoc (<key>, <list>, <default>)
 -- Funktion: assoc (<key>, <list>)
     Ist das Argument `list' eine Liste mit paarweisen Elementen der
     Form `[[key_1, value_1], [key_2, value_2], ...]', wobei <key_i> ein
     Schlüssel und <value_i> der dazugehörige Wert ist, dann gibt die
     Funktion `assoc' den zum Schlüssel <key> gehörenden Wert `value'
     zurück.  Wird der Schlüssel nicht gefunden, wird das Argument
     `default' zurückgegeben, wenn es vorhanden ist, oder der Wert
     `false'.

     Anstatt Paare `[key_i, value_i]' können auch allgemeine Ausdrücke
     in der Liste enthalten sein, die zwei Argumente haben.  Zum
     Beispiel sind Einträge der Form `x=1' oder `a^b' möglich.  Im
     ersten Fall ist `x' der Schlüssel und im zweiten Fall `a'.  Die
     Werte sind jeweils `1' und `b'.

     Beispiele:

          (%i1) l : [[info, 10], [warn, 20], [err, 30]];
          (%o1)          [[info, 10], [warn, 20], [err, 30]]
          (%i2) assoc(info, l);
          (%o2)                          10
          (%i3) assoc(warn, l);
          (%o3)                          20
          (%i4) assoc(err, l);
          (%o4)                          30
          (%i5) l : [x+y, a^(2*b), sin(x) = 0.5];
                                      2 b
          (%o5)              [y + x, a   , sin(x) = 0.5]
          (%i6) assoc(x, l);
          (%o6)                           y
          (%i7) assoc(y, l);
          (%o7)                         false
          (%i8) assoc(a, l);
          (%o8)                          2 b
          (%i9) assoc(sin(x), l);
          (%o9)                          0.5

 -- Funktion: cons (<expr>, <list>)
     Fügt den Ausdruck <expr> als erstes Element der Liste <list> hinzu.

     `cons' arbeitet auch mit allgemeinen Ausdrücken als Argument
     <list>.  In diesem Fall wird dem Hauptoperator des Arguments
     <list> der Ausdruck <expr> als erstes Argument hinzugefügt.

     Siehe auch die Funktion `endcons',  um ein Element an das Ende
     einer Liste anzuhängen sowie die Funktion `append',  um zwei Listen
     zusammenzufügen.

     Beispiele:

          (%i1) cons(x, [a, b, c]);
          (%o1)                     [x, a, b, c]
          (%i2) cons(x^2+1, [a, b, c]);
                                    2
          (%o2)                   [x  + 1, a, b, c]
          (%i3) cons(x^2+1, a+b+c);
                                  2
          (%o3)                  x  + c + b + a + 1
          (%i4) cons(x^2+1, f(a,b,c));
                                    2
          (%o4)                  f(x  + 1, a, b, c)

 -- Funktion: copylist (<list>)
     Gibt eine Kopie der Liste <list> zurück.

     Im Unterschied zur Funktion `copylist' wird mit dem
     Zuweisungsoperator `:'  keine Kopie, sondern eine Referenz auf das
     Original zugewiesen.  Das folgende Beispiel zeigt den Unterschied
     für den Fall, dass das Original modifiziert wird.

          (%i1) list : [x,y,z];
          (%o1)                       [x, y, z]
          (%i2) a: list;
          (%o2)                       [x, y, z]
          (%i3) b: copylist(list);
          (%o3)                       [x, y, z]
          (%i4) list[2]:99;
          (%o4)                          99
          (%i5) list;
          (%o5)                      [x, 99, z]
          (%i6) a;
          (%o6)                      [x, 99, z]
          (%i7) b;
          (%o7)                       [x, y, z]

 -- Funktion: create_list (<expr>, <x_1>, <list_1>, ..., <x_n>,
          <list_n>)
     Erzeugt eine Liste, indem der Ausdruck <expr> zunächst für die
     Variable <x_1> ausgewertet wird.  Der Variablen <x_1> werden für
     die Auswertung nacheinander die Werte der Liste <list_1>
     zugewiesen.  Dann wird der Ausdruck <expr> für die Variable <x_2>
     mit den Werten der Liste <list_2> ausgewertet u.s.w.  Die Anzahl
     der Elemente der Ergebnisliste ist das Produkt der Anzahl der
     Elemente der einzelnen Listen <list_i>.  Die Variablen <x_i>
     müssen Symbole sein, die nicht ausgewertet werden.  Die Elemente
     der Listen <list_i> werden vor der Iteration ausgewertet.

     Anstatt einer Liste <list_i> mit den Elementen für die Iteration
     kann auch eine untere und obere Grenze angegeben werden.  Die
     Grenzen können ganze Zahlen oder Gleitkommazahlen sowie Ausdrücke
     sein, die zu einer Zahl auswerten.  Die Schrittweite ist immer 1.
     Siehe auch das Beispiel weiter unten.

     Beispiele:

          (%i1) create_list(x^i, i, [1, 3, 7]);
                           3   7
          (%o1)       [x, x , x ]

     In diesem Beispiel wird für zwei Listen iteriert.

          (%i1) create_list([i, j], i, [a, b], j, [e, f, h]);
          (%o1) [[a, e], [a, f], [a, h], [b, e], [b, f], [b, h]]

     Anstatt einer Liste <list_i> können auch zwei Argumente übergeben
     werden, die jedes zu einer Nummer auswerten.  Diese Werte sind die
     untere und die obere Grenze für die Iteration.

          (%i1) create_list([i,j],i,[1,2,3],j,1,i);
          (%o1) [[1, 1], [2, 1], [2, 2], [3, 1], [3, 2], [3, 3]]

 -- Funktion: delete (<expr>, <list>)
 -- Funktion: delete (<expr>, <list>, <n>)
     `delete(<expr>, <list>)' entfernt aus der Liste <list> die
     Elemente, die gleich dem Ausdruck <expr> sind.  Mit dem Argument
     <n> kann die Anzahl der Elemente spezifiziert werden, die aus der
     Liste entfernt werden sollen.  `delete' gibt eine neue Liste
     zurück.  Das Argument <list> wird nicht modifiziert.

     Die Gleichheit wird mit dem Operator `='  geprüft.  Daher werden
     nur Ausdrücke als gleich erkannt, die syntaktisch übereinstimmen.
     Äquivalente Ausdrücke, die syntaktisch voneinander verschieden
     sind, werden nicht aus der Liste entfernt.  Zum Beispiel sind die
     Ausdrücke `x^2-1' und `(x+1)*(x-1)' äquivalent, aber syntaktisch
     verschieden.

     Das zweite Argument <list> kann auch ein allgemeiner Ausdruck
     sein.  In diesem Fall werden die Argumente des Hauptoperators als
     die Elemente einer Liste angenommen.

     Beispiele:

     Entferne Elemente einer Liste.

          (%i1) delete (y, [w, x, y, z, z, y, x, w]);
          (%o1)                  [w, x, z, z, x, w]

     Entferne Terme einer Summe.

          (%i1) delete (sin(x), x + sin(x) + y);
          (%o1)                         y + x

     Entferne Faktoren eines Produkts.

          (%i1) delete (u - x, (u - w)*(u - x)*(u - y)*(u - z));
          (%o1)                (u - w) (u - y) (u - z)

     Entferne Argumente einer Funktion.

          (%i1) delete (a, f(a, b, c, d, a));
          (%o1)                     f(b, c, d)

     Das Element `a' tritt mehrfach auf.  Es werden zwei Elemente
     entfernt.

          (%i1) delete (a, f(a, b, a, c, d, a), 2);
          (%o1)                    f(b, c, d, a)

     Die Gleichheit wird mit dem Operator `=' geprüft.

          (%i1) [is(equal (0, 0)), is(equal (0, 0.0)), is(equal (0, 0b0))];

          `rat' replaced 0.0 by 0/1 = 0.0
          `rat' replaced 0.0B0 by 0/1 = 0.0B0
          (%o1)                  [true, true, true]
          (%i2) [is (0 = 0), is (0 = 0.0), is (0 = 0b0)];
          (%o2)                 [true, false, false]
          (%i3) delete (0, [0, 0.0, 0b0]);
          (%o3)                     [0.0, 0.0b0]
          (%i4) is (equal ((x + y)*(x - y), x^2 - y^2));
          (%o4)                         true
          (%i5) is ((x + y)*(x - y) = x^2 - y^2);
          (%o5)                         false
          (%i6) delete ((x + y)*(x - y), [(x + y)*(x - y), x^2 - y^2]);
                                        2    2
          (%o6)                       [x  - y ]

 -- Funktion: endcons (<expr>, <list>)
     Fügt den Ausdruck <expr> als letztes Element der Liste <list>
     hinzu.

     `endcons' arbeitet auch mit allgemeinen Ausdrücken als Argument
     <list>.  In diesem Fall wird dem Hauptoperator des Arguments
     <list> der Ausdruck <expr> als letztes Argument hinzugefügt.

     Siehe auch die Funktion `cons',  um ein Element am Anfang einer
     Liste einzufügen sowie die Funktion `append',  um zwei Listen
     zusammenzufügen.

     Beispiele:

          (%i1) endcons(x, [a, b, c]);
          (%o1)                     [a, b, c, x]
          (%i2) endcons(x^2+1, [a, b, c]);
                                             2
          (%o2)                   [a, b, c, x  + 1]
          (%i3) endcons(x^2+1, a+b+c);
                                  2
          (%o3)                  x  + c + b + a + 1
          (%i4) endcons(x^2+1, f(a,b,c));
                                             2
          (%o4)                  f(a, b, c, x  + 1)

 -- Funktion: first (<list>)
     Gibt das erste Element der Liste <list> zurück.

     Das Argument <list> kann auch ein allgemeiner Ausdruck wie zum
     Beispiel der Term einer Summe, der Faktor eines Produktes oder die
     erste Spalte einer Matrix sein.  Die Funktion `first' und
     verwandte Funktionen wie `last'  oder `rest'  arbeiten mit der
     externen Darstellung eines Ausdrucks, wie sie in der Anzeige
     erscheint.  Dies kann mit der Optionsvariablen `inflag'
     kontrolliert werden.  Hat die Optionsvariable `inflag' den Wert
     `true', wird von diesen Funktionen die interne Darstellung
     betrachtet.

     Die Funktionen `second'  bis `tenth'  geben jeweils das 2. bis 10.
     Element zurück.

     Beispiele:

          (%i1) l: [a,b,c];
          (%o1)                       [a, b, c]
          (%i2) first(l);
          (%o2)                           a
          (%i3) first(x + y);
          (%o3)                           y
          (%i4) first(x * y);
          (%o4)                           x
          (%i5) first(f(x, y, z));
          (%o5)                           x

 -- Funktion: join (<list_1>, <list_2>)
     Erzeugt eine neue Liste aus den Elementen der Listen <list_1> und
     <list_2>, wobei die Elemente abwechselnd übernommen werden.  Das
     Ergebnis hat die Form `[<list_1>[1], <list_2>[1], <list_1>[2],
     <list_2>[2], ...]'.

     Haben die Listen verschiedene Längen, werden die zusätzlichen
     Elemente der längeren Liste ignoriert.

     Sind <list_1> oder <list_2> keine Listen, gibt Maxima einen Fehler
     aus.

     Beispiele:

          (%i1) L1: [a, sin(b), c!, d - 1];
          (%o1)                [a, sin(b), c!, d - 1]
          (%i2) join (L1, [1, 2, 3, 4]);
          (%o2)          [a, 1, sin(b), 2, c!, 3, d - 1, 4]
          (%i3) join (L1, [aa, bb, cc, dd, ee, ff]);
          (%o3)        [a, aa, sin(b), bb, c!, cc, d - 1, dd]

 -- Funktion: last (<list>)
     Gibt das letzte Element der Liste <list> zurück.

     Das Argument <list> kann auch ein allgemeiner Ausdruck sein.  Siehe
     `first'  für weitere Erläuterungen.

     Beispiele:

          (%i1) l: [a,b,c];
          (%o1)                       [a, b, c]
          (%i2) last(x + y);
          (%o2)                           x
          (%i3) last(x * y);
          (%o3)                           y
          (%i4) last(f(x, y, z));
          (%o4)                           z

 -- Funktion: length (<list>)
     Gibt die Anzahl der Elemente der Liste <list> zurück.

     Das Argument <list> kann auch ein allgemeiner Ausdruck sein.  Wie
     bei anderen Funktionen für Listen wird auch von der Funktion
     `length' die externe Darstellung eines Ausdrucks betrachtet, wie
     sie für die Ausgabe vorliegt.  Die Optionsvariable `inflag'  hat
     daher Einfluss auf das Ergebnis der Funktion `length'.

     Beispiele:

          (%i1) length([a, x^2, sin(x), y+3]);
          (%o1)                           4
          (%i2) length(a/(b*x));
          (%o2)                           2
          (%i3) length(a/(b*x)),inflag:true;
          (%o3)                           3

 -- Optionsvariable: listarith
     Standardwert: `true'

     Hat die Optionsvariable `listarith' den Wert `true', werden
     Rechenoperationen mit Matrizen und Listen elementweise ausgeführt.
     Das Ergebnis von Rechnungen mit Listen und Matrizen sind wieder
     Listen und Matrizen.  Hat die Optionsvariable `listarith' den Wert
     `false', wird die elementweise Ausführung der Rechenoperationen
     unterdrückt.

     Beispiele:

          (%i1) listarith: true;
          (%o1)                         true
          (%i2) 2 + [a, b, c];
          (%o2)                 [a + 2, b + 2, c + 2]
          (%i3) 2^[a, b, c];
                                      a   b   c
          (%o3)                     [2 , 2 , 2 ]
          (%i4) [1, 2, 3] + [a, b, c];
          (%o4)                 [a + 1, b + 2, c + 3]
          (%i5) listarith: false;
          (%o5)                         false
          (%i6) 2 + [a, b, c];
          (%o6)                     [a, b, c] + 2
          (%i7) 2^[a, b, c];
                                      [a, b, c]
          (%o7)                      2
          (%i8) [1, 2, 3] + [a, b, c];
          (%o8)                 [a, b, c] + [1, 2, 3]

 -- Funktion: listp (<expr>)
     Gibt `true' zurück, wenn <expr> eine Liste ist.  Ansonsten ist der
     Rückgabewert `false'.

 -- Funktion: makelist (<expr>, <i>, <i_0>, <i_1>)
 -- Funktion: makelist (<expr>, <x>, <list>)
     Erzeugt eine Liste, indem der Ausdruck <expr> für die Variable <i>
     ausgewertet wird.  Die Variable <i> nimmt nacheinander die Werte
     von <i_0> bis <i_1> an, wobei die Schrittweite 1 ist.  Alternativ
     kann eine Liste <list> als Argument übergeben werden.  In diesem
     Fall nimmt die Variable <i> nacheinander die Werte der Liste
     <list> an.

     Siehe auch die Funktion `create_list',  um eine Liste zu
     generieren.

     Beispiele:

          (%i1) makelist(concat(x, i), i, 1, 6);
          (%o1)               [x1, x2, x3, x4, x5, x6]
          (%i2) makelist(x = y, y, [a, b, c]);
          (%o2)                 [x = a, x = b, x = c]

 -- Funktion: member (<expr>, <list>)
     Gibt `true' zurück, wenn der Ausdruck <expr> gleich einem Element
     in der Liste <list> ist.  Die Gleichheit wird dem Operator `='
     festgestellt.

     Die Gleichheit wird mit dem Operator `='  geprüft.  Daher werden
     nur Ausdrücke als gleich erkannt, die syntaktisch übereinstimmen.
     Äquivalente Ausdrücke, die syntaktisch voneinander verschieden
     sind, werden nicht aus der Liste entfernt.  Zum Beispiel sind die
     Ausdrücke `x^2-1' und `(x+1)*(x-1)' äquivalent, aber syntaktisch
     verschieden.

     Das Argument <list> kann auch ein allgemeiner Ausdruck sein.
     Dabei werden die Argumente des Hauptoperators betrachtet.

     Siehe auch die Funktion `elementp'.

     Beispiele:

          (%i1) member (8, [8, 8.0, 8b0]);
          (%o1)                         true
          (%i2) member (8, [8.0, 8b0]);
          (%o2)                         false
          (%i3) member (b, [a, b, c]);
          (%o3)                         true
          (%i4) member (b, [[a, b], [b, c]]);
          (%o4)                         false
          (%i5) member ([b, c], [[a, b], [b, c]]);
          (%o5)                         true
          (%i6) F (1, 1/2, 1/4, 1/8);
                                         1  1  1
          (%o6)                     F(1, -, -, -)
                                         2  4  8
          (%i7) member (1/8, %);
          (%o7)                         true
          (%i8) member ("ab", ["aa", "ab", sin(1), a + b]);
          (%o8)                         true

 -- Funktion: pop (<list>)
     Die Funktion `pop' entfernt das erste Element der Liste <list> und
     gibt dieses Element zurück.  <list> muss ein Symbol sein, dem eine
     Liste zugewiesen wurde, und kann nicht selbst eine Liste sein.

     Ist dem Argument <list> keine Liste zugewiesen, gibt Maxima eine
     Fehlermeldung aus.

     Siehe auch die Funktion `push'  für Beispiele.

     Mit dem Kommando `load(basic)' wird die Funktion geladen.

 -- Funktion: push (<item>, <list>)
     Die Funktion `push' fügt das Argument <item> als erstes Element der
     Liste <list> hinzu und gibt die neue Liste zurück.  Das Argument
     <list> muss ein Symbol sein, dem eine Liste zugewiesen wurde, und
     kann nicht selbst eine Liste sein.  Das Argument <item> kann ein
     beliebiger Ausdruck sein.

     Ist dem Argument <list> keine Liste zugewiesen, gibt Maxima eine
     Fehlermeldung aus.

     Siehe auch die Funktion `pop',  um das erste Element einer Liste zu
     entfernen.

     Mit dem Kommando `load(basic)' wird die Funktion geladen.

     Beispiele:

          (%i1) ll:[];
          (%o1)                          []
          (%i2) push(x,ll);
          (%o2)                          [x]
          (%i3) push(x^2+y,ll);
                                           2
          (%o3)                      [y + x , x]
          (%i4) a:push("string",ll);
                                               2
          (%o4)                  [string, y + x , x]
          (%i5) pop(ll);
          (%o5)                        string
          (%i6) pop(ll);
                                            2
          (%o6)                        y + x
          (%i7) pop(ll);
          (%o7)                           x
          (%i8) ll;
          (%o8)                          []
          (%i9) a;
                                               2
          (%o9)                  [string, y + x , x]

 -- Funktion: rest (<list>, <n>)
 -- Funktion: rest (<list>)
     Entfernt das erste Element oder, wenn <n> eine positive ganze Zahl
     ist, die ersten <n> Elemente der Liste <list> und gibt den Rest
     der Liste als Ergebnis zurück.  Ist <n> eine negative Zahl, werden
     die letzten <n> Elemente von der Liste entfernt und der Rest als
     Ergebnis zurückgegeben.

     Das Argument <list> kann auch ein allgemeiner Ausdruck sein.

     Siehe auch die Funktionen `first'  und `last'.

     Beispiele:

          (%i1) rest([a,b,c]);
          (%o1)                        [b, c]
          (%i2) rest(a+b+c);
          (%o2)                         b + a

 -- Funktion: reverse (<list>)
     Kehrt die Anordnung der Elemente einer Liste <list> um und gibt die
     Ergebnisliste zurück.  Das Argument <list> kann auch ein
     allgemeiner Ausdruck sein.

     Beispiele:

          (%i1) reverse([a, b, c]);
          (%o1)                       [c, b, a]
          (%i2) reverse(sin(x)=2*x^2+1);
                                     2
          (%o2)                   2 x  + 1 = sin(x)

 -- Funktion: second (<list>)
 -- Funktion: third (<list>)
 -- Funktion: fourth (<list>)
 -- Funktion: fifth (<list>)
 -- Funktion: sixth (<list>)
 -- Funktion: seventh (<list>)
 -- Funktion: eighth (<list>)
 -- Funktion: ninth (<list>)
 -- Funktion: tenth (<list>)
     Die Funktionen `second' bis `tenth' geben das 2. bis 10. Element
     eines Ausdrucks oder einer Liste <list> zurück.  Siehe `first'.


 -- Funktion: sort (<L>, <P>)
 -- Funktion: sort (<L>)
     Sortiert eine Liste <L> und gibt die sortierte Liste zurück.  Das
     optionale Argument <P> ist eine Aussagefunktion mit zwei
     Argumenten, die eine Ordnung der Elemente definiert.  Die
     Aussagefunktion kann eine Funktion, ein binärer Operator oder ein
     Lambda-Ausdruck sein.  Wird kein Argument <P> angegeben, werden
     die Elemente der Liste mit der Aussagefunktion `orderlessp'
     geordnet.

     Die Aussagefunktion `orderlessp'  sortiert eine List aufsteigend.
     Mit der Aussagefunktion `ordergreatp'  kann die Liste absteigend
     sortiert werden.  Die Aussagefunktion `ordermagnitudep'  sortiert
     Maxima Zahlen, Konstante oder Ausdrücke, die zu einer Zahl oder
     Konstanten ausgewertet werden können, nach der Größe.  Mit dem
     Operator `<'  kann auch nach der Größe sortiert werden.  Im
     Unterschied zur Aussagefunktion `ordermagnitudep' ist die Ordnung
     nicht vollständig, wenn einzelne Elemente der Liste nicht
     vergleichbar unter dem Operator `<' sind.

     Beispiele:

          (%i1) sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9 * c,
                19 - 3 * x]);
                         5
          (%o1) [- 17, - -, 3, 7.55, 11, 2.9b1, b + a, 9 c, 19 - 3 x]
                         2
          (%i2) sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9*c, 19 - 3*x],
                ordergreatp);
                                                             5
          (%o2) [19 - 3 x, 9 c, b + a, 2.9b1, 11, 7.55, 3, - -, - 17]
                                                             2
          (%i3) sort ([%pi, 3, 4, %e, %gamma]);
          (%o3)                [3, 4, %e, %gamma, %pi]
          (%i4) sort ([%pi, 3, 4, %e, %gamma], "<");
          (%o4)                [%gamma, %e, 3, %pi, 4]
          (%i5) my_list: [[aa,hh,uu], [ee,cc], [zz,xx,mm,cc], [%pi,%e]];
          (%o5) [[aa, hh, uu], [ee, cc], [zz, xx, mm, cc], [%pi, %e]]
          (%i6) sort (my_list);
          (%o6) [[%pi, %e], [aa, hh, uu], [ee, cc], [zz, xx, mm, cc]]
          (%i7) sort (my_list, lambda ([a, b], orderlessp (reverse (a),
                reverse (b))));
          (%o7) [[%pi, %e], [ee, cc], [zz, xx, mm, cc], [aa, hh, uu]]

     Ordne Maxima Zahlen, Konstante und konstante Ausdrücke nach der
     Größe.  Alle anderen Elemente werden aufsteigend sortiert.

          (%i8) sort([%i,1+%i,2*x,minf,inf,%e,sin(1),0,1,2,3,1.0,1.0b0],
                     ordermagnitudep);
          (%o8) [minf, 0, sin(1), 1, 1.0, 1.0b0, 2, %e, 3, inf, %i,
                                                               %i + 1, 2 x]

 -- Funktion: sublist (<L>, <P>)
     Gibt die Elemente der Liste <L> als eine Liste zurück, für die die
     Aussagefunktion `P' das Ergebnis `true' hat.  `P' ist eine
     Funktion mit einem Argument wie zum Beispiel die Funktion
     `integerp'.    Siehe auch die Funktion `sublist_indices'.

     Beispiele:

          (%i1) L: [1, 2, 3, 4, 5, 6];
          (%o1)                  [1, 2, 3, 4, 5, 6]
          (%i2) sublist (L, evenp);
          (%o2)                       [2, 4, 6]

 -- Funktion: sublist_indices (<L>, <P>)
     Gibt die Indizes der Elemente der Liste <L> zurück, für die die
     Aussagefunktion `P' das Ergebnis `true' hat.  `P' ist eine
     Funktion mit einem Argument wie zum Beispiel die Funktion
     `integerp'.    Siehe auch die Funktion `sublist'.

     Beispiele:

          (%i1) sublist_indices ('[a, b, b, c, 1, 2, b, 3, b],
                                 lambda ([x], x='b));
          (%o1)                     [2, 3, 7, 9]
          (%i2) sublist_indices ('[a, b, b, c, 1, 2, b, 3, b], symbolp);
          (%o2)                  [1, 2, 3, 4, 7, 9]
          (%i3) sublist_indices ([1 > 0, 1 < 0, 2 < 1, 2 > 1, 2 > 0],
                                 identity);
          (%o3)                       [1, 4, 5]
          (%i4) assume (x < -1);
          (%o4)                       [x < - 1]
          (%i5) map (maybe, [x > 0, x < 0, x < -2]);
          (%o5)                [false, true, unknown]
          (%i6) sublist_indices ([x > 0, x < 0, x < -2], identity);
          (%o6)                          [2]

 -- Funktion: unique (<L>)
     Gibt eine Liste mit den Elementen der Liste <L> zurück, die sich
     voneinander unterscheiden.  Sind alle Elemente der Liste <L>
     verschieden, gibt `unique' eine Kopie der Liste <L> und nicht die
     Liste selbst zurück.  Ist <L> keine Liste, gibt `unique' den
     Ausdruck <L> zurück.

     Beispiel:

          (%i1) unique ([1, %pi, a + b, 2, 1, %e, %pi, a + b, [1]]);
          (%o1)              [1, 2, %e, %pi, [1], b + a]


File: maxima.info,  Node: Arrays,  Next: Strukturen,  Prev: Listen,  Up: Datentypen und Strukturen

5.5 Arrays
==========

* Menu:

* Einführung in Arrays::
* Funktionen und Variablen für Arrays::


File: maxima.info,  Node: Einführung in Arrays,  Next: Funktionen und Variablen für Arrays,  Prev: Arrays,  Up: Arrays

5.5.1 Einführung in Arrays
--------------------------

Am flexibelsten sind Arrays, die nicht deklariert werden, diese werden
auch Hashed-Arrays genannt und entstehen dadurch, dass einer
indizierten Variablen ein Wert zugewiesen wird.  Die Indizes brauchen
keine ganze Zahlen zu sein, es sind auch Symbole und Ausdrücke als
Index möglich.  Nicht-deklarierte Arrays wachsen dynamisch mit der
Zuweisung von Werten an die Elemente.  Im Folgenden wird ein
nicht-deklariertes Array `a' durch Zuweisung von Werten erzeugt.  Die
Elemente des Arrays werden mit der Funktion `listarray'

angezeigt.

     (%i1) a[1,2]: 99;
     (%o1)                          99
     (%i2) a[x,y]: x^y;
                                     y
     (%o2)                          x
     (%i3) listarray(a);
                                       y
     (%o3)                       [99, x ]

Von den nicht-deklarierten Arrays sind deklarierte Arrays zu
unterscheiden.  Diese haben bis zu 5 Dimensionen und können einen Typ
wie `fixnum' oder `flonum' erhalten.  Maxima unterscheidet zunächst
zwei verschiedene Arten von deklarierten Arrays.  Zum einen kann ein
Symbol mit der Funktion `array'  als ein deklariertes Array definiert
werden.  Eine andere Möglichkeit ist, mit der Funktion `make_array'
ein Lisp-Array zu deklarieren, dass einem Symbol zugewiesen wird.

Das erste Beispiel zeigt die Deklaration eines Symbols `a' als ein
Array.  Im zweiten Beispiel wird ein Lisp-Array erzeugt, das dem Symbol
`b' zugewiesen wird.

     (%i1) array(a, fixnum, 2, 2);
     (%o1)                           a
     (%i2) b: make_array(fixnum, 2, 2);
     (%o2)              {Array:  #2A((0 0) (0 0))}

Erhält die Optionsvariable `use_fast_arrays'  den Wert `true', werden
ausschließlich Lisp-Arrays erzeugt.  Im Folgenden wird auch von der
Funktion `array' ein Lisp-Array erzeugt, dass dem Symbol `c' zugewiesen
wird.  Die Implementation der Funktionalität der Funktion `array' ist
jedoch nicht vollständig, wenn Lisp-Arrays genutzt werden.  So kann in
diesem Beispiel nicht wie oben ein Array mit dem Typ `fixnum' definiert
werden.  Das ist ein Programmfehler.

     (%i3) use_fast_arrays: true;
     (%o3)                         true
     (%i4) array(c, 2, 2);
     (%o4)    #2A((NIL NIL NIL) (NIL NIL NIL) (NIL NIL NIL))
     (%i5) c;
     (%o5)    #2A((NIL NIL NIL) (NIL NIL NIL) (NIL NIL NIL))
     (%i6) array(c, fixnum, 2, 2);

     make_array: dimensions must be integers; found [fixnum + 1, 3, 3]
      -- an error. To debug this try: debugmode(true);

Maxima kennt weiterhin Array-Funktionen, die Funktionswerte speichern
können, und indizierte Funktionen.  Die hier beschriebenen Funktionen
können auch auf diese Arrays angewendet werden.  Siehe *note
Array-Funktionen:: für eine Beschreibung.

Weitere Ausführungen sind bei der Beschreibung der einzelnen Funktionen
zu finden.  Maxima kennt folgende Funktionen und Symbole für das
Arbeiten mit Arrays:

   array         arrayapply     arrayinfo
   arraymake     arrays         fillarray
   listarray     make_array     rearray
   remarray      subvar         subvarp
   use_fast_arrays


File: maxima.info,  Node: Funktionen und Variablen für Arrays,  Prev: Einführung in Arrays,  Up: Arrays

5.5.2 Funktionen und Variablen für Arrays
-----------------------------------------

 -- Funktion: array (<name>, <dim_1>, ..., <dim_n>)
 -- Funktion: array (<name>, <type>, <dim_1>, ..., <dim_n>)
 -- Funktion: array ([<name_1>, ..., <name_m>], <dim_1>, ..., <dim_n>)
 -- Funktion: array ([<name_1>, ..., <name_m>], <type>, <dim_1>, ...,
          <dim_n>)
     Erzeugt ein n-dimensionales Array.  Das Array kann bis zu 5
     Dimensionen haben.  Die Indizes der i-ten Dimension sind ganze
     Zahlen in einem Bereich von 0 bis einschließlich <dim_i>.

     `array(<name>, <dim_1>, ..., <dim_n>)' erzeugt ein Array, dessen
     Elemente einen beliebigen Typ haben und auch Symbole oder Ausdrücke
     sein können.

     `array(<name>, <type>, <dim_1>, ..., <dim_n>)' erzeugt ein Array
     mit Elementen, die vom Typ <type> sind.  Das Argument <type> kann
     `fixnum' für ganze Zahlen oder `flonum' für Gleitkommazahlen sein.

     `array([<name_1>, ..., <name_m>], <dim_1>, ..., <dim_n>)' erzeugt
     m Arrays, die alle die gleiche Dimension haben.  Wie oben kann
     weiterhin der Typ der Arrays durch Angabe des Argumentes <type> als
     `fixnum' oder `flonum' festgelegt werden.

     Mit der Funktion `array' können nicht-deklarierte Arrays in ein
     deklariertes Array umgewandelt werden.  Wenn das deklarierte einen
     Typ erhalten soll, müssen alle Elemente des nicht-deklarierten
     Arrays von diesem Typ sein.

     Siehe auch die Funktion `make_array',  um ein Lisp-Array zu
     erzeugen, sowie die Optionsvariable `use_fast_arrays'.

     Beispiele:

     Es werden zwei verschiedene Arrays definiert.  Im ersten Fall
     erhält das Array keinen Typ.  Elemente, denen noch kein Wert
     zugewiesen wurde, werden mit dem Symbol `#####' initialisiert.  Im
     zweiten Fall ist das Array vom Typ `fixnum'.  Jetzt wird das Array
     mit dem Wert `0' initialisiert.

          (%i1) array(a, 2, 2);
          (%o1)                           a
          (%i2) a[0,0]: 0; a[1,1]:11; a[2,2]:22;
          (%o2)                           0
          (%o3)                          11
          (%o4)                          22
          (%i5) listarray(a);
          (%o5) [0, #####, #####, #####, 11, #####, #####, #####, 22]
          (%i6) array(b, fixnum, 2, 2);
          (%o6)                           b
          (%i7) b[0,0]: 0; b[1,1]:11; b[2,2]:22;
          (%o7)                           0
          (%o8)                          11
          (%o9)                          22
          (%i10) listarray(b);
          (%o10)            [0, 0, 0, 0, 11, 0, 0, 0, 22]

     Ein nicht-deklariertes Array kann in ein deklariertes Array
     umgewandelt werden.

          (%i1) a[1,1]:11;
          (%o1)                          11
          (%i2) a[2,2]:22;
          (%o2)                          22
          (%i3) arrayinfo(a);
          (%o3)              [hashed, 2, [1, 1], [2, 2]]
          (%i4) array(a, fixnum, 2, 2);
          (%o4)                           a
          (%i5) arrayinfo(a);
          (%o5)                 [complete, 2, [2, 2]]

 -- Funktion: arrayapply (<A>, [<i_1>, ..., <i_n>])
     Wertet `<A>[<i_1>, ... , <i_n>]' aus, wobei <A> ein Array und
     <i_1>, ..., <i_n> die Indizes eines Array-Elementes sind.

     Siehe auch die Funktion `subvar',  die die gleiche Funktionalität
     hat, sowie die Funktion `arraymake',  die die Referenz auf das
     Array-Element nicht auswertet.

     Beispiele:

     Die Funktion `arrayapply' wertet die Referenz auf ein
     Array-Element aus.  Im Unterschied dazu wertet die Funktion
     `arraymake'  die Referenz nicht aus.  Die Funktion `subvar'  hat
     die gleiche Funktionalität wie `arrayapply'.

          (%i1) a[1,2]: 12;
          (%o1)                          12
          (%i2) a[x,y]: x^y;
                                          y
          (%o2)                          x
          (%i3) arrayapply(a, [1, 2]);
          (%o3)                          12
          (%i4) arrayapply(a, [x, y]);
                                          y
          (%o4)                          x
          (%i5) arraymake(a, [x,y]);
          (%o5)                         a
                                         x, y
          (%i6) subvar(a, x, y);
                                          y
          (%o6)                          x

 -- Funktion: arrayinfo (<A>)
     Gibt Informationen über das Array <A> zurück.  Das Argument <A>
     kann ein deklariertes oder ein nicht-deklariertes Array sowie eine
     Array-Funktion oder eine indizierte Funktion sein.

     Für ein deklarierte Array gibt `arrayinfo' eine Liste zurück, die
     `declared', die Zahl der Dimensionen und die Größe der Dimensionen
     enthält.  Die Elemente des Arrays werden von der Funktion
     `listarray'

     zurückgegeben.

     Für ein nicht-deklariertes Array (Hashed-Array) gibt `arrayinfo'
     eine Liste zurück, die `hashed', die Zahl der Indizes und die
     Indizes enthält, deren Elemente einen Wert haben.  Die Werte der
     Elemente werden mit der Funktion `listarray'  zurückgegeben.

     Für Array-Funktionen gibt `arrayinfo' eine Liste zurück, die
     `hashed' die Zahl der Indizes und die Indizes enthält, für die
     Funktionen im Array enthalten sind.  Die Funktionen werden mit der
     Funktion `listarray'  angezeigt.

     Für indizierte Funktionen gibt `arrayinfo' eine Liste zurück, die
     `hashed', die Zahl der Indizes und die Indizes enthält, für die
     Lambda-Ausdrücke vorhanden sind.  Die `lambda' -Ausdrücke werden
     von der Funktion `listarray'  angezeigt.

     Die Funktion `arrayinfo' kann auch für Lisp-Arrays angewendet
     werden, die mit der Funktion `make_array'  erzeugt werden.

     Beispiele:

     `arrayinfo' und `listarray' angewendet auf ein deklariertes Array.

          (%i1) array(aa, 2, 3);
          (%o1)                          aa
          (%i2) aa[2, 3] : %pi;
          (%o2)                          %pi
          (%i3) aa[1, 2] : %e;
          (%o3)                          %e
          (%i4) arrayinfo(aa);
          (%o4)                 [declared, 2, [2, 3]]
          (%i5) listarray(aa);
          (%o5) [#####, #####, #####, #####, #####, #####, %e, #####,
                                                  #####, #####, #####, %pi]

     `arrayinfo' und `listarray' angewendet auf ein nicht-deklariertes
     Array.

          (%i1) bb [FOO] : (a + b)^2;
                                             2
          (%o1)                       (b + a)
          (%i2) bb [BAR] : (c - d)^3;
                                             3
          (%o2)                       (c - d)
          (%i3) arrayinfo (bb);
          (%o3)               [hashed, 1, [BAR], [FOO]]
          (%i4) listarray (bb);
                                        3         2
          (%o4)                 [(c - d) , (b + a) ]

     `arrayinfo' und `listarray' angewendet auf eine Array-Funktion.

          (%i1) cc [x, y] := y / x;
                                               y
          (%o1)                      cc     := -
                                       x, y    x
          (%i2) cc [u, v];
                                          v
          (%o2)                           -
                                          u
          (%i3) cc [4, z];
                                          z
          (%o3)                           -
                                          4
          (%i4) arrayinfo (cc);
          (%o4)              [hashed, 2, [4, z], [u, v]]
          (%i5) listarray (cc);
                                        z  v
          (%o5)                        [-, -]
                                        4  u

     `arrayinfo' und `listarray' angewendet auf eine indizierte
     Funktion.

          (%i1) dd [x] (y) := y ^ x;
                                               x
          (%o1)                     dd (y) := y
                                      x
          (%i2) dd [a + b];
                                              b + a
          (%o2)                  lambda([y], y     )
          (%i3) dd [v - u];
                                              v - u
          (%o3)                  lambda([y], y     )
          (%i4) arrayinfo (dd);
          (%o4)             [hashed, 1, [b + a], [v - u]]
          (%i5) listarray (dd);
                                   b + a                v - u
          (%o5)      [lambda([y], y     ), lambda([y], y     )]

 -- Funktion: arraymake (<A>, [<i_1>, ..., <i_n>])
     Gibt den Ausdruck `<A>[<i_1>, ..., <i_n>]' zurück.  Das Ergebnis
     ist eine nicht ausgewertete Referenz auf ein Element des Arrays
     <A>.  `arraymake' ist vergleichbar mit der Funktion `funmake'.

     Ist das Array <A> ein Lisp-Array, wie es mit der Funktion
     `make_array'  erzeugt wird, dann gibt `arraymake' einen Lisp-Fehler
     zurück.  Das ist ein Programmfehler.

     Siehe auch die Funktionen `arrayapply'  und `subvar',  die die
     Referenz auswerten.

     Beispiele:

          (%i1) arraymake (A, [1]);
          (%o1)                          A
                                          1
          (%i2) arraymake (A, [k]);
          (%o2)                          A
                                          k
          (%i3) arraymake (A, [i, j, 3]);
          (%o3)                       A
                                       i, j, 3
          (%i4) array (A, fixnum, 10);
          (%o4)                           A
          (%i5) fillarray (A, makelist (i^2, i, 1, 11));
          (%o5)                           A
          (%i6) arraymake (A, [5]);
          (%o6)                          A
                                          5
          (%i7) ''%;
          (%o7)                          36
          (%i8) L : [a, b, c, d, e];
          (%o8)                    [a, b, c, d, e]
          (%i9) arraymake ('L, [n]);
          (%o9)                          L
                                          n
          (%i10) ''%, n = 3;
          (%o10)                          c
          (%i11) A2 : make_array (fixnum, 10);
          (%o11)          {Array:  #(0 0 0 0 0 0 0 0 0 0)}
          (%i12) fillarray (A2, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o12)          {Array:  #(1 2 3 4 5 6 7 8 9 10)}
          (%i13) arraymake ('A2, [8]);
          (%o13)                         A2
                                           8
          (%i14) ''%;
          (%o14)                          9

 -- Systemvariable: arrays
     Standardwert: `[]'

     `arrays' ist eine Informationsliste `infolists'  der vom Nutzer
     definierten Arrays.  Die Liste enthält deklarierte Arrays,
     nicht-deklarierte Arrays und Array-Funktionen, die der Nutzer mit
     dem Operator `:='  oder der Funktion `define'  definiert hat.
     Dagegen sind Arrays, die mit `make_array'  definiert sind, nicht
     in der Liste enthalten.

     Siehe auch die Funktion `array',  um ein Array zu definieren.

     Beispiele:

          (%i1) array (aa, 5, 7);
          (%o1)                          aa
          (%i2) bb [FOO] : (a + b)^2;
                                             2
          (%o2)                       (b + a)
          (%i3) cc [x] := x/100;
                                             x
          (%o3)                      cc  := ---
                                       x    100
          (%i4) dd : make_array ('any, 7);
          (%o4)       {Array:  #(NIL NIL NIL NIL NIL NIL NIL)}
          (%i5) arrays;
          (%o5)                     [aa, bb, cc]

 -- Funktion: fillarray (<A>, <B>)
     Füllt das Array <A> mit den Werten aus <B>.  Das Argument <B> ist
     eine Liste oder ein Array.

     Hat das Array <A> einen Typ, dann kann es nur mit Elementen gefüllt
     werden, die den gleichen Typ haben.

     Sind die Dimensionen von <A> und <B> verschieden, werden zunächst
     die Zeilen des Arrays <A> aufgefüllt.  Hat die Liste oder das
     Array <B> nicht genügend Elemente, um das Array <A> aufzufüllen,
     werden die restlichen Elemente mit dem letzten Wert von <B>
     aufgefüllt.  Überzählige Elemente in <B> werden ignoriert.

     `fillarray' gibt das erste Argument zurück.

     Siehe die Funktionen `array'  und `make_array',  um ein Array zu
     definieren.

     Beispiele:

     Erzeuge ein Array mit 9 Elementen und fülle es mit den Elementen
     einer Liste.

          (%i1) array (a1, fixnum, 8);
          (%o1)                          a1
          (%i2) listarray (a1);
          (%o2)              [0, 0, 0, 0, 0, 0, 0, 0, 0]
          (%i3) fillarray (a1, [1, 2, 3, 4, 5, 6, 7, 8, 9]);
          (%o3)                          a1
          (%i4) listarray (a1);
          (%o4)              [1, 2, 3, 4, 5, 6, 7, 8, 9]

     Sind zu wenige Elemente vorhanden, um das Array aufzufüllen, wird
     das Array mit dem letzten Element aufgefüllt.  Überzählige
     Elemente werden ignoriert.

          (%i1) a2 : make_array (fixnum, 8);
          (%o1)             {Array:  #(0 0 0 0 0 0 0 0)}
          (%i2) fillarray (a2, [1, 2, 3, 4, 5]);
          (%o2)             {Array:  #(1 2 3 4 5 5 5 5)}
          (%i3) fillarray (a2, [4]);
          (%o3)             {Array:  #(4 4 4 4 4 4 4 4)}
          (%i4) fillarray (a2, makelist (i, i, 1, 100));
          (%o4)             {Array:  #(1 2 3 4 5 6 7 8)}

     Arrays werden zeilenweise aufgefüllt.

          (%i1) a3 : make_array (fixnum, 2, 5);
          (%o1)        {Array:  #2A((0 0 0 0 0) (0 0 0 0 0))}
          (%i2) fillarray (a3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o2)        {Array:  #2A((1 2 3 4 5) (6 7 8 9 10))}
          (%i3) a4 : make_array (fixnum, 5, 2);
          (%o3)     {Array:  #2A((0 0) (0 0) (0 0) (0 0) (0 0))}
          (%i4) fillarray (a4, a3);
          (%o4)     {Array:  #2A((1 2) (3 4) (5 6) (7 8) (9 10))}

 -- Funktion: listarray (<A>)
     Gibt eine Liste mit den Elementen des Arrays <A> zurück.  Das
     Argument <A> kann ein deklariertes, nicht-deklariertes, eine
     Array-Funktion oder eine indizierte Funktion sein.

     Die Elemente werden zeilenweise ausgegeben.  Für nicht-deklarierte
     Arrays mit Indizes, die keine ganze Zahlen sind, wird die
     Sortierung von der Aussagefunktion `orderlessp'  bestimmt.

     Für nicht-deklarierte Arrays, Array-Funktionen und indizierte
     Funktionen werden die Elemente in der Reihenfolge wie von der
     Funktion `arrayinfo'  zurückgegeben.

     Elemente von deklarierten Arrays, denen noch kein Wert zugewiesen
     wurde und die keinen Typ haben, werden als `#####' zurückgegeben.
     Elemente von deklarierten Arrays mit einem Typ, geben den Wert 0
     für den Typ `fixnum' und 0.0 für den Typ `flonum' zurück.

     Ist das Argument <A> ein Lisp-Array, wie es von der Funktion
     `make_array'  erzeugt wird, generiert Maxima einen Lisp-Fehler.
     Das ist ein Programmfehler.

     Beispiele:

     Anwendung der Funktionen `listarray' und `arrayinfo'  für ein
     deklariertes Array.

          (%i1) array (aa, 2, 3);
          (%o1)                          aa
          (%i2) aa [2, 3] : %pi;
          (%o2)                          %pi
          (%i3) aa [1, 2] : %e;
          (%o3)                          %e
          (%i4) listarray (aa);
          (%o4) [#####, #####, #####, #####, #####, #####, %e, #####,
                                                  #####, #####, #####, %pi]
          (%i5) arrayinfo (aa);
          (%o5)                 [declared, 2, [2, 3]]

     Anwendung der Funktionen `listarray' und `arrayinfo'  für ein
     nicht-deklariertes Array.

          (%i1) bb [FOO] : (a + b)^2;
                                             2
          (%o1)                       (b + a)
          (%i2) bb [BAR] : (c - d)^3;
                                             3
          (%o2)                       (c - d)
          (%i3) listarray (bb);
                                        3         2
          (%o3)                 [(c - d) , (b + a) ]
          (%i4) arrayinfo (bb);
          (%o4)               [hashed, 1, [BAR], [FOO]]

     Anwendung der Funktionen `listarray' und `arrayinfo'  für eine
     Array-Funktion.

          (%i1) cc [x, y] := y / x;
                                               y
          (%o1)                      cc     := -
                                       x, y    x
          (%i2) cc [u, v];
                                          v
          (%o2)                           -
                                          u
          (%i3) cc [4, z];
                                          z
          (%o3)                           -
                                          4
          (%i4) listarray (cc);
                                        z  v
          (%o4)                        [-, -]
                                        4  u
          (%i5) arrayinfo (cc);
          (%o5)              [hashed, 2, [4, z], [u, v]]

     Anwendung der Funktionen `listarray' und `arrayinfo'  für ein
     indizierte Funktion.

          (%i1) dd [x] (y) := y ^ x;
                                               x
          (%o1)                     dd (y) := y
                                      x
          (%i2) dd [a + b];
                                              b + a
          (%o2)                  lambda([y], y     )
          (%i3) dd [v - u];
                                              v - u
          (%o3)                  lambda([y], y     )
          (%i4) listarray (dd);
                                   b + a                v - u
          (%o4)      [lambda([y], y     ), lambda([y], y     )]
          (%i5) arrayinfo (dd);
          (%o5)             [hashed, 1, [b + a], [v - u]]

 -- Funktion: make_array (<type>, <dim_1>, ..., <dim_n>)
     Gibt ein Lisp-Array zurück.  Das Argument <type> kann die Werte
     `any', `flonum', `fixnum' oder `hashed' haben.  Das Array hat i
     Dimensionen und der Index i läuft von 0 bis einschließlich
     <dim_i>-1.

     Die meisten Funktionen, die auf ein Array angewendet werden
     können, das mit der Funktion `array'  definiert wurde, können auch
     auf Lisp-Arrays angewendet werden.  Einige Funktionalitäten stehen
     jedoch nicht zur Verfügung.  Dies ist auf eine unzureichende
     Implementation der Lisp-Arrays zurückzuführen und kann als
     Programmfehler betrachtet werden.  Hinweise auf Einschränkungen
     sind bei den einzelnen Funktionen für Arrays zu finden.

     Erhält die Optionsvariable `use_fast_arrays'  den Wert `true',
     erzeugt Maxima ausschließlich Lisp-Arrays.  Dies trifft auch auf
     die Funktion `array'  zu.  Wie bereits oben erläutert, ist in
     diesem Fall jedoch mit einer eingeschränkten Funktionalität zu
     rechnen.

     Beispiele:

          (%i1) A1 : make_array (fixnum, 10);
          (%o1)           {Array:  #(0 0 0 0 0 0 0 0 0 0)}
          (%i2) A1 [8] : 1729;
          (%o2)                         1729
          (%i3) A1;
          (%o3)          {Array:  #(0 0 0 0 0 0 0 0 1729 0)}
          (%i4) A2 : make_array (flonum, 10);
          (%o4) {Array:  #(0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0)}
          (%i5) A2 [2] : 2.718281828;
          (%o5)                      2.718281828
          (%i6) A2;
          (%o6)
               {Array:  #(0.0 0.0 2.718281828 0.0 0.0 0.0 0.0 0.0 0.0 0.0)}
          (%i7) A3 : make_array (any, 10);
          (%o7) {Array:  #(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)}
          (%i8) A3 [4] : x - y - z;
          (%o8)                      - z - y + x
          (%i9) A3;
          (%o9) {Array:  #(NIL NIL NIL NIL ((MPLUS SIMP) $X ((MTIMES SIMP)\
           -1 $Y) ((MTIMES SIMP) -1 $Z))
            NIL NIL NIL NIL NIL)}
          (%i10) A4 : make_array (fixnum, 2, 3, 5);
          (%o10) {Array:  #3A(((0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0)) ((0 0 \
          0 0 0) (0 0 0 0 0) (0 0 0 0 0)))}
          (%i11) fillarray (A4, makelist (i, i, 1, 2*3*5));
          (%o11) {Array:  #3A(((1 2 3 4 5) (6 7 8 9 10) (11 12 13 14 15))
              ((16 17 18 19 20) (21 22 23 24 25) (26 27 28 29 30)))}
          (%i12) A4 [0, 2, 1];
          (%o12)                         12

 -- Funktion: rearray (<A>, <dim_1>, ..., <dim_n>)
     Die Funktion `rearray' erlaubt es, ein Array <A> zu vergrößern
     oder auch zu verkleinern.  Die Anzahl der Dimensionen <n> sowie
     der Typ eines Arrays können nicht geändert werden.

     Das neue Array wird zeilenweise mit den Werten des alten Arrays
     aufgefüllt.  Hat das alte Array nicht genügend Elemente werden die
     restlichen Elemente entsprechend dem Typ des Arrays mit `false',
     `0.0' oder `0' aufgefüllt.

     Siehe die Funktionen `array'  und `make_array',  um ein Array zu
     definieren.

     Beispiel:

     In diesem Beispiel wird das Array `A' verkleinert.  Der
     Rückgabewert von `rearray' ist ein internes Lisp-Array auch für
     den Fall, dass das Array selbst kein Lisp-Array ist.

          (%i1) array(A, fixnum, 2, 2);
          (%o1)                           A
          (%i2) listarray(A);
          (%o2)              [0, 0, 0, 0, 0, 0, 0, 0, 0]
          (%i3) rearray(A, 1, 1);
          (%o3)              {Array:  #2A((0 0) (0 0))}
          (%i4) listarray(A);
          (%o4)                     [0, 0, 0, 0]

 -- Funktion: remarray (<A_1>, ..., <A_n>)
 -- Funktion: remarray (all)
     Entfernt Arrays und Array-Funktionen.  Der vom Array belegte
     Speicher wird freigegeben.  Die Argumente können deklarierte und
     nicht-deklarierte Arrays sowie Array-Funktionen und indizierte
     Funktionen sein.

     `remarray(all)' entfernt alle Arrays, die in der Informationsliste
     `arrays'  enthalten sind.

     `remarray' gibt eine Liste der Arrays zurück, die entfernt wurden.
     `remarray' wertet die Argumente nicht aus.

 -- Funktion: subvar (<x>, <i_1>, <x_2>, ...)
     Wertet den indizierten Ausdruck `<x>[<i_1>, <i_2>, ...]' aus.
     `subvar' wertet die Argumente aus.

     Siehe die Funktion `arrayapply',  die dieselbe Funktionalität hat,
     und die Funktion `arraymake',  die eine Referenz auf das
     Array-Element zurückgibt, ohne diese auszuwerten.

     Beispiele:

          (%i1) x : foo $
          (%i2) i : 3 $
          (%i3) subvar (x, i);
          (%o3)                         foo
                                           3
          (%i4) foo : [aa, bb, cc, dd, ee]$
          (%i5) subvar (x, i);
          (%o5)                          cc
          (%i6) arraymake (x, [i]);
          (%o6)                         foo
                                           3
          (%i7) ''%;
          (%o7)                          cc

 -- Funktion: subvarp (<expr>)
     Gibt `true' zurück, wenn <expr> eine indizierte Variable wie zum
     Beispiel `a[i]' ist.

 -- Optionsvariable: use_fast_arrays
     Standardwert: `false'

     Erhält die Optionsvariable `use_fast_arrays'  den Wert `true',
     erzeugt Maxima ausschließlich Lisp-Arrays, wie sie auch von der
     Funktion `make_array'  erzeugt werden.  Dies trifft auch auf die
     Funktion `array'  zu.  Der Vorteil der Lisp-Arrays ist, dass diese
     effizienter sind.

     Die Implementation der Lisp-Arrays ist jedoch nicht vollständig
     ausgeführt, so dass es zu einer eingeschränkten Funktionalität
     kommt.  Dies ist ein Programmfehler.  Hinweise auf einzelne
     Einschränkungen sind bei den einzelnen Funktionen zu finden.

     Siehe die Funktion `make_array'  für weitere Ausführungen zu
     Lisp-Arrays.


File: maxima.info,  Node: Strukturen,  Prev: Arrays,  Up: Datentypen und Strukturen

5.6 Strukturen
==============

* Menu:

* Einführung in Strukturen::
* Funktionen und Variablen für Strukturen::


File: maxima.info,  Node: Einführung in Strukturen,  Next: Funktionen und Variablen für Strukturen,  Prev: Strukturen,  Up: Strukturen

5.6.1 Einführung in Strukturen
------------------------------

Maxima bietet eine einfache Möglichkeit, Daten in eine Struktur
zusammenzufassen.  Eine Struktur ist ein Ausdruck, in der die Argumente
mit ihren Feldnamen bezeichnet werden und die Struktur als Ganzes mit
dem Namen des Operators bezeichnet wird.  Der Wert eines Feldes kann
ein beliebiger Ausdruck sein.

Eine Struktur wird mit der Funktion `defstruct'  definiert.  Die
Informationsliste `structures'  enthält die vom Nutzer definierten
Strukturen.  Die Funktion `new'  generiert eine neue Instanz einer
Struktur.  Mit dem Operator `@'  wird auf die Felder einer Struktur
zugegriffen.  Mit dem Kommando `kill(<S>)' wird die Definition der
Struktur `S' gelöscht.  Mit dem Kommando `kill(<x>@<a>)' wird das Feld
<a> der Instanz <x> einer Struktur gelöscht.

In der 2D-Anzeige werden die Felder von Instanzen einer Struktur als
eine Gleichung angezeigt.  Die linke Seite der Gleichung ist der
Feldname und die rechte Seite der Gleichung ist der Wert des Feldes.
Die Gleichungen werden nur in der Anzeige gezeigt und werden nicht als
Teil der Struktur gespeichert.  In der 1D-Anzeige und bei der Ausgabe
mit der Funktion `grind'  werden nur die Werte der Felder ausgegeben.

Ein Feldname kann nicht als der Name einer Funktion verwendet werden.
Jedoch kann ein Feld einen Lambda-Ausdruck enthalten.  Auch können die
Felder nicht auf bestimmte Datentypen eingeschränkt werden.  Einem Feld
kann immer ein beliebiger Ausdruck zugewiesen werden.  Weiterhin sind
die Felder einer Struktur immer sichtbar.  Der Zugriff auf ein Feld
kann nicht eingeschränkt werden.


File: maxima.info,  Node: Funktionen und Variablen für Strukturen,  Prev: Einführung in Strukturen,  Up: Strukturen

5.6.2 Funktionen und Variablen für Strukturen
---------------------------------------------

 -- Systemvariable: structures
     `structures' ist eine Informationsliste, die die vom Benutzer mit
     der Funktion `defstruct'  definierten Strukturen enthält.

 -- Funktion: defstruct (<S>(<a_1>, ..., <a_n>))
 -- Funktion: defstruct (<S>(<a_1> = <v_1>, ..., <a_n> = <v_n>))
     Definiert eine Struktur, als eine Liste mit den Feldnamen <a_1>,
     ..., <a_n> und dem Namen <S> für die Struktur.  Eine Instanz einer
     Struktur ist ein Ausdruck mit dem Operator <S> und <n> Argumenten,
     die die Werte der Felder sind.  Mit dem Kommando `new(<S>' wird
     eine neue Instanz einer Struktur <S> generiert.  Siehe auch `new'.

     Mit einem Symbol <a> als Argument wird der Name eines Feldes
     bezeichnet.  Mit einer Gleichung `<a> = <v>' wird der Name des
     Feldes als <a> bezeichnet und ein Standardwert <v> definiert.  Der
     Standardwert <v> kann ein beliebiger Ausdruck sein.

     `defstruct' legt die Definition der Struktur <S> in der
     Informationsliste `structures'  ab.

     Mit dem Kommando `kill(<S>)' wird die Definition einer Struktur
     gelöscht und von der Informationsliste `structures' entfernt.

     Beispiele:

          (%i1) defstruct (foo (a, b, c));
          (%o1)                    [foo(a, b, c)]
          (%i2) structures;
          (%o2)                    [foo(a, b, c)]
          (%i3) new (foo);
          (%o3)                     foo(a, b, c)
          (%i4) defstruct (bar (v, w, x = 123, y = %pi));
          (%o4)             [bar(v, w, x = 123, y = %pi)]
          (%i5) structures;
          (%o5)      [foo(a, b, c), bar(v, w, x = 123, y = %pi)]
          (%i6) new (bar);
          (%o6)              bar(v, w, x = 123, y = %pi)
          (%i7) kill (foo);
          (%o7)                         done
          (%i8) structures;
          (%o8)             [bar(v, w, x = 123, y = %pi)]

 -- Funktion: new (<S>)
 -- Funktion: new (<S> (<v_1>, ..., <v_n>))
     `new' erzeugt eine neue Instanz einer Struktur.

     Das Kommando `new(<S>)' erzeugt eine neue Instanz der Struktur <S>,
     die mit der Funktion `defstruct'  definiert wurde.  Die Felder
     werden mit den Standardwerten belegt, wenn die Definition der
     Struktur Standardwerte enthält.  Ansonsten erhalten die Felder
     keine Werte.

     Das Kommando `new(<S>(<v_1>, ..., <v_n>))' erzeugt eine neue
     Instanz der Struktur <S>, wobei die Felder mit den Werten <v_1>,
     ..., <v_n> initialisiert werden.

     Beispiele:

          (%i1) defstruct (foo (w, x = %e, y = 42, z));
          (%o1)              [foo(w, x = %e, y = 42, z)]
          (%i2) new (foo);
          (%o2)               foo(w, x = %e, y = 42, z)
          (%i3) new (foo (1, 2, 4, 8));
          (%o3)            foo(w = 1, x = 2, y = 4, z = 8)

 -- Operator: @
     `@' ist der Operator für den Zugriff auf ein Feld einer Struktur.
     Der Ausdruck `<x>@<a>' bezeichnet das Feld <a> der Instanz <x>
     einer Struktur.  Der Feldname wird nicht ausgewertet.

     Hat das Feld <a> der Instanz <x> keinen Wert, wird der Ausdruck
     `<x>@<a>' zu sich selbst ausgewertet.

     `kill(<x>@<a>)' löscht den Wert des Feldes <a> der Instanz <x>
     einer Struktur.

     Beispiele:

          (%i1) defstruct (foo (x, y, z));
          (%o1)                    [foo(x, y, z)]
          (%i2) u : new (foo (123, a - b, %pi));
          (%o2)           foo(x = 123, y = a - b, z = %pi)
          (%i3) u@z;
          (%o3)                          %pi
          (%i4) u@z : %e;
          (%o4)                          %e
          (%i5) u;
          (%o5)            foo(x = 123, y = a - b, z = %e)
          (%i6) kill (u@z);
          (%o6)                         done
          (%i7) u;
          (%o7)              foo(x = 123, y = a - b, z)
          (%i8) u@z;
          (%o8)                          u@z

     Der Feldname wird nicht ausgewertet.

          (%i1) defstruct (bar (g, h));
          (%o1)                      [bar(g, h)]
          (%i2) x : new (bar);
          (%o2)                       bar(g, h)
          (%i3) x@h : 42;
          (%o3)                          42
          (%i4) h : 123;
          (%o4)                          123
          (%i5) x@h;
          (%o5)                          42
          (%i6) x@h : 19;
          (%o6)                          19
          (%i7) x;
          (%o7)                    bar(g, h = 19)
          (%i8) h;
          (%o8)                          123


File: maxima.info,  Node: Ausdrücke,  Next: Operatoren,  Prev: Datentypen und Strukturen,  Up: Top

6 Ausdrücke
***********

* Menu:

* Einführung in Ausdrücke::
* Substantive und Verben::
* Bezeichner::
* Funktionen und Variablen für Ausdrücke::


File: maxima.info,  Node: Einführung in Ausdrücke,  Next: Substantive und Verben,  Prev: Ausdrücke,  Up: Ausdrücke

6.1 Einführung in Ausdrücke
===========================

Alles in Maxima, bis auf wenige Ausnahmen, sind Ausdrücke.  Dazu gehören
mathematische Ausdrücke wie `sqrt(2*a+b)' oder Kommandos wie
`subst(a^2,b,sin(b+1)'.  Auch Maxima-Programme sind Ausdrücke.
Ausdrücke bestehen aus einem Atom oder einem Operator mit seinen
Argumenten.

Ein Atom kann ein Symbol, eine Zeichenkette, eine ganze Zahl oder eine
Gleitkommazahl sein.  Jeder Ausdruck, der nicht ein Atom ist, hat die
Darstellung `op(a_1, a_2, ..., a_n)'.  `op' ist der Operator und `a_1',
..., `a_n' sind die Argumente des Operators.  Die Argumente des
Operators können Atome oder wiederum Operatoren mit Argumenten sein.

Da Maxima in Lisp programmiert ist, wird ein Ausdruck intern als eine
Liste dargestellt, die die Gestalt `((op) a_1 a_2 ... a_n)' hat.  Die
arithmetischen Operatoren "+" und "*" haben zum Beispiel die interne
Darstellung:

     x+y+10  -> ((mplus) 10 $x $y)
     2*x*x   -> ((mtimes) 2 $x $y)
     2*(x+y) -> ((mtimes) 2 ((mplus) $x $y)

Mathematische Funktionen wie die trigonometrischen Funktionen oder die
Logarithmusfunktion werden von Maxima intern analog dargestellt:

     sin(x)          -> ((%sin) $x)
     log(y)          -> ((%log) $y)
     2*sin(x)+log(y) -> ((mplus) ((mtimes) 2 ((%sin) $x)) ((%log) $y))

Mehrere Ausdrücke können zusammengefaßt werden, indem die Ausdrücke
durch Kommata getrennt und mit runden Klammern umgeben werden.

     (%i1) x: 3$
     (%i2) (x: x+1, x: x^2);
     (%o2)                          16
     (%i3) (if (x > 17) then 2 else 4);
     (%o3)                           4
     (%i4) (if (x > 17) then x: 2 else y: 4, y+x);
     (%o4)                          20

Auch Programmschleifen sind in Maxima Ausdrücke.  Der Rückgabewert einer
Programmschleife ist `done'.

     (%i1) y: (x: 1, for i from 1 thru 10 do (x: x*i))$
     (%i2) y;
     (%o2)                         done

Um einen anderen Rückgabewert als `done' zu erhalten, kann zum Beispiel
der Wert der Variablen <x> nach dem Ende der Programmschleife ausgegeben
werden.

     (%i3) y: (x: 1, for i from 1 thru 10 do (x: x*i), x)$
     (%i4) y;
     (%o4)                        3628800

Es gibt eine Anzahl an reservierten Namen, die nicht als Variablennamen
verwendet werden sollten.  Ihre Verwendung kann möglicherweise
kryptische Fehlermeldungen erzeugen.  Dazu gehören zum Beispiel die
folgenden Namen:

   integrate            next           from                 diff
   in                   at             limit                sum
   for                  and            elseif               then
   else                 do             or                   if
   unless               product        while                thru
   step

Funktionen und Variablen um einen Teilausdruck zu isolieren:

   isolate     disolate  isolate_wrt_times   expisolate
   part        inpart    substpart           substinpart
   inflag      piece     partswitch
   pickapart

Funktionen und Variablen für Substantive und Verben:

   nounify   verbify     alias     aliases

Funktionen und Variablen, um zu prüfen, ob ein Teilausdruck enthalten
ist und um eine Liste der Variablen eines Ausdrucks zu erstellen:

   freeof       lfreeof
   listofvars   listconstvars    listdummyvars

Funktionen und Variablen für Operatoren und Argumente:

   args    op    operatorp

Funktionen und Variablen für Substitutionen in Ausdrücke:

   subst psubst sublis exptsubst opsubst

Funktionen und Variablen für die kanonische Ordnung der Argumente eines
Ausdrucks:

   ordergreat    orderless    unorder
   ordergreatp   orderlessp   ordermagnitudep

Weitere Funktionen und Variablen:

   nterms   optimize   optimprefix   partition


File: maxima.info,  Node: Substantive und Verben,  Next: Bezeichner,  Prev: Einführung in Ausdrücke,  Up: Ausdrücke

6.2 Substantive und Verben
==========================

Operatoren und Funktionen können als Substantiv oder Verb vorliegen.
Verben werden von Maxima ausgewertet.  Substantive, die in einem
Ausdruck auftreten, werden dagegen nicht ausgewertet, sondern
vereinfacht.  Die meisten mathematischen Funktionen sind Substantive.
Funktionen wie `limit',  `diff'  oder `integrate'  sind standardmäßig
Verben, die jedoch in ein Substantiv umgewandelt werden können.  Ein
Verb kann durch den Quote-Operator  `'' oder mit der Funktion `nounify'
in ein Substantiv umgewandelt werden.  Der Auswertungsschalter `nouns'
bewirkt, dass Substantive von der Funktion `ev'  ausgewertet werden.

In der internen Darstellung von Maxima erhalten Lisp-Symbole, die ein
Verb darstellen, ein führendes Dollarzeichen `$'.  Lisp-Symbole, die ein
Substantiv darstellen, erhalten ein führendes Prozentzeichen `%'.
Einige Substantive wie `'integrate' oder `'derivative' haben eine
spezielle Darstellung für die Ausgabe.  Standardmäßig werden jedoch
Substantive und Verben identisch dargestellt.  Hat die Optionsvariable
`noundisp'  den Wert `true', werden Substantive mit einem führenden
Hochkommata angezeigt.

Siehe auch `noun',  `nouns',  `nounify'  und `verbify'.

Beispiele:

     (%i1) foo (x) := x^2;
                                          2
     (%o1)                     foo(x) := x
     (%i2) foo (42);
     (%o2)                         1764
     (%i3) 'foo (42);
     (%o3)                        foo(42)
     (%i4) 'foo (42), nouns;
     (%o4)                         1764
     (%i5) declare (bar, noun);
     (%o5)                         done
     (%i6) bar (x) := x/17;
                                          x
     (%o6)                    ''bar(x) := --
                                          17
     (%i7) bar (52);
     (%o7)                        bar(52)
     (%i8) bar (52), nouns;
                                    52
     (%o8)                          --
                                    17
     (%i9) integrate (1/x, x, 1, 42);
     (%o9)                        log(42)
     (%i10) 'integrate (1/x, x, 1, 42);
                                  42
                                 /
                                 [   1
     (%o10)                      I   - dx
                                 ]   x
                                 /
                                  1
     (%i11) ev (%, nouns);
     (%o11)                       log(42)


File: maxima.info,  Node: Bezeichner,  Next: Funktionen und Variablen für Ausdrücke,  Prev: Substantive und Verben,  Up: Ausdrücke

6.3 Bezeichner
==============

Maxima Bezeichner bestehen aus den Buchstaben des Alphabets und den
Zahlzeichen 0 bis 9.  Sonderzeichen können in einem Bezeichner mit einem
vorangestellten Backslash `\' verwendet werden, zum Beispiel `a\&b'.

Ein Zahlzeichen kann der erste Buchstabe eines Bezeichners sein, wenn
ihm ein Backslash vorangestellt ist, zum Beispiel `\2and3'.
Zahlzeichen, die an anderen Stellen auftreten, muss kein Backslash
vorangestellt werden, zum Beispiel `is5'.

Sonderzeichen können mit der Funktion `declare'  als alphabetisch
erklärt werden.  In diesem Fall muss dem Sonderzeichen kein Backslash
vorangestellt werden, wenn es in einem Bezeichner genutzt wird.  Die
Zeichen `A' bis `Z', `a' bis `z' und `0' bis `9' sowie die Zeichen `%'
und `_' haben bereits die Eigenschaft alphabetisch.

Maxima unterscheidet Groß- und Kleinschreibung.  So werden von Maxima
`foo', `FOO' oder `Foo' unterschieden.  Ein Maxima-Bezeichner ist ein
Lisp-Symbol, dem ein Dollarzeichen `$' vorangestellt ist.
Lisp-Symbolen, die in Maxima verwendet werden sollen, ist ein
Fragezeichen `?' vorangestellt.  Siehe das Kapitel Lisp und Maxima  für
eine ausführlichere Beschreibung.

Beispiele:

     (%i1) %an_ordinary_identifier42;
     (%o1)               %an_ordinary_identifier42
     (%i2) embedded\ spaces\ in\ an\ identifier;
     (%o2)           embedded spaces in an identifier
     (%i3) symbolp (%);
     (%o3)                         true
     (%i4) [foo+bar, foo\+bar];
     (%o4)                 [foo + bar, foo+bar]
     (%i5) [1729, \1729];
     (%o5)                     [1729, 1729]
     (%i6) [symbolp (foo\+bar), symbolp (\1729)];
     (%o6)                     [true, true]
     (%i7) [is (foo\+bar = foo+bar), is (\1729 = 1729)];
     (%o7)                    [false, false]
     (%i8) baz\~quux;
     (%o8)                       baz~quux
     (%i9) declare ("~", alphabetic);
     (%o9)                         done
     (%i10) baz~quux;
     (%o10)                      baz~quux
     (%i11) [is (foo = FOO), is (FOO = Foo), is (Foo = foo)];
     (%o11)                [false, false, false]
     (%i12) :lisp (defvar *my-lisp-variable* '$foo)
     *MY-LISP-VARIABLE*
     (%i12) ?\*my\-lisp\-variable\*;
     (%o12)                         foo


File: maxima.info,  Node: Funktionen und Variablen für Ausdrücke,  Prev: Bezeichner,  Up: Ausdrücke

6.4 Funktionen und Variablen für Ausdrücke
==========================================

 -- Funktion: alias (<new_name_1>, <old_name_1>, ..., <new_name_n>,
          <old_name_n>)
     Die Funktion `alias' ermöglicht einen alternativen Alias-Namen für
     eine Maxima-Funktion, einer Variablen oder einem Array.  Der
     Funktion `alias' kann eine beliebige Anzahl von paarweisen Namen
     und Alias-Namen übergeben werden.

     `alias' gibt eine Liste mit den Symbolen zurück, denen ein
     Alias-Name zugewiesen werden konnte.  Wurde einem Symbol bereits
     derselbe Alias-Name gegeben, enthält die Liste den Wert `false'.
     Wird versucht einem Symbol, das bereits einen Alias-Namen hat,
     einen neuen Alias-Namen zu geben, bricht `alias' mit einer
     Fehlermeldung ab.

     Symbole, die einen Alias-Namen erhalten haben, werden in die
     Systemvariable `aliases' eingetragen.  Siehe die Systemvariable
     `aliases'.

     Die Funktionen `ordergreat'  und `orderless'  sowie die Deklaration
     eines Symbols als ein `noun'  mit der Funktion `declare'  erzeugen
     automatisch Alias-Namen, die in die Liste `aliases' eingetragen
     werden.

     Der Alias-Name kann mit der Funktion `kill'  entfernt werden.

     Beispiel:

          (%i1) alias(mysqrt,sqrt);
          (%o1)                        [sqrt]
          (%i2) aliases;
          (%o2)                        [sqrt]
          (%i3) mysqrt(4);
          (%o3)                           2
          (%i4) kill(mysqrt);
          (%o4)                         done
          (%i5) mysqrt(4);
          (%o5)                       mysqrt(4)
          (%i6) aliases;
          (%o6)                          []

 -- Systemvariable: aliases
     Anfangswert: `[]'

     Die Systemvariable `aliases' ist eine Informationsliste der
     Symbole, die einen vom Nutzer definierten Alias-Namen mit dem
     Kommando `alias' erhalten haben.  Weiterhin werden von den
     Funktionen `ordergreat'  und `orderless'  sowie bei der
     Deklaration eines Symbols als ein `noun'  mit der Funktion
     `declare'  Alias-Namen generiert, die in die Liste `aliases'
     eingetragen werden.

     Siehe auch die Funktion `alias'  für ein Beispiel.

 -- Schlüsselwort: allbut
     Das Schlüsselwort `allbut' wird bei `part'-Befehlen wie `part',
     `inpart',  `substpart',

     `substinpart',  `dpart'  und `lpart'  genutzt, um Indizes bei der
     Auswahl von Teilausdrücken auszuschließen.

     Das Schlüsselwort `allbut' kann auch zusammen mit dem Kommando
     `kill' verwendet werden.  `kill(allbut(<a_1>, <a_2>, ...))' hat
     denselben Effekt wie `kill(all)' mit der Ausnahme, dass die Symbole
     <a_1>, <a_2>, ... von `kill' ausgenommen werden.  Siehe die
     Funktion `kill'.

     Beispiele:

          (%i1) expr : e + d + c + b + a;
          (%o1)                   e + d + c + b + a
          (%i2) part (expr, [2, 5]);
          (%o2)                         d + a

          (%i3) expr : e + d + c + b + a;
          (%o3)                   e + d + c + b + a
          (%i4) part (expr, allbut (2, 5));
          (%o4)                       e + c + b

     Das Schlüsselwort `allbut' kann zusammen mit dem Kommando `kill'
     verwendet werden.

          (%i1) [aa : 11, bb : 22, cc : 33, dd : 44, ee : 55];
          (%o1)                 [11, 22, 33, 44, 55]
          (%i2) kill (allbut (cc, dd));
          (%o0)                         done
          (%i1) [aa, bb, cc, dd];
          (%o1)                   [aa, bb, 33, 44]

 -- Funktion: args (<expr>)
     Die Funktion `args' gibt eine Liste mit den Argumenten des
     Hauptoperators des Ausdrucks <expr> zurück.

     Die Anordnung der Argumente der Ergebnisliste wird von der
     Optionsvariablen `inflag' beeinflußt.  Hat `inflag' den Wert
     `true', ist die Anordnung entsprechend der internen Darstellung
     des Ausdrucks <expr>.  Ansonsten ist die Anordnung wie in der
     externen Darstellung für die Anzeige.  Siehe die Optionsvariable
     `inflag'.

     `args(<expr>)' ist äquivalent zu `substpart("[", <expr>, 0)'.
     Siehe auch `substpart'  und `op'.

     Beispiele:

          (%i1) args(gamma_incomplete(a,x));
          (%o1)                        [a, x]
          (%i2) args(x+y+z);
          (%o2)                       [z, y, x]
          (%i3) args(x+y+z),inflag:true;
          (%o3)                       [x, y, z]
          (%i4) args(x+2*a);
          (%o4)                       [x, 2 a]

 -- Funktion: atom (<expr>)
     Gibt den Wert `true' zurück, wenn das Argument <expr> ein Atom ist.
     Atome sind ganze Zahlen, Gleitkommazahlen, Zeichenketten und
     Symbole.  Siehe auch die Funktionen `symbolp'  und `listp'.

     Beispiele:

          (%i1) atom(5);
          (%o1)                         true
          (%i2) atom(5.0);
          (%o2)                         true
          (%i3) atom(5.0b0);
          (%o3)                         true
          (%i4) atom(1/2);
          (%o4)                         false
          (%i5) atom('a);
          (%o5)                         true
          (%i6) atom(2*x);
          (%o6)                         false
          (%i7) atom("string");
          (%o7)                         true

 -- Funktion: box (<expr>)
 -- Funktion: box (<expr>, <a>)
     Die Funktion `box(<expr>)' umschließt den Ausdruck <expr> in der
     Ausgabe mit einem Rahmen, wenn `display2d' den Wert `true' hat.
     Ansonsten ist der Rückgabewert ein Ausdruck mit `box' als Operator
     und <expr> als Argument.

     `box(<expr>, <a>)' umschließt <expr> mit einem Rahmen, der mit
     einer Marke <a> bezeichnet ist.  Ist die Marke länger als der
     Rahmen, werden Zeichen abgeschnitten.

     Die Funktion `box' wertet ihre Argumente aus.  Die eingerahmten
     Ausdrücke werden dagegen nicht mehr ausgewertet.

     Die Optionsvariable `boxchar'  enthält das Zeichen, das von den
     Funktionen `box' sowie `dpart'  und `lpart'  verwendet wird, um
     den Rahmen auszugeben.

     Beispiele:

          (%i1) box (a^2 + b^2);
                                      """""""""
                                      " 2    2"
          (%o1)                       "b  + a "
                                      """""""""
          (%i2) a : 1234;
          (%o2)                         1234
          (%i3) b : c - d;
          (%o3)                         c - d
          (%i4) box (a^2 + b^2);
                                """"""""""""""""""""
                                "       2          "
          (%o4)                 "(c - d)  + 1522756"
                                """"""""""""""""""""
          (%i5) box (a^2 + b^2, term_1);
                                term_1""""""""""""""
                                "       2          "
          (%o5)                 "(c - d)  + 1522756"
                                """"""""""""""""""""
          (%i6) 1729 - box (1729);
                                           """"""
          (%o6)                     1729 - "1729"
                                           """"""

 -- Optionsvariable: boxchar
     Standardwert: `"'

     Die Optionsvariable `boxchar' enthält das Zeichen, welches von den
     Funktionen `box'  sowie `dpart'  und `lpart'  genutzt wird, um
     einen Rahmen auszugeben.

     Die Rahmen werden immer mit dem aktuellen Wert von `boxchar'
     ausgegeben.  Das Zeichen `boxchar' wird nicht zusammen mit dem
     eingerahmten Ausdruck gespeichert.

 -- Funktion: collapse (<expr>)
 -- Funktion: collapse ([<expr_1>, <expr_2>, ...])
     Komprimiert einen Ausdruck <expr>, indem gemeinsame Teilausdrücke
     denselben Speicher nutzen.  `collapse' wird von der Funktion
     `optimize' aufgerufen.  `collapse' kann auch mit einer Liste
     aufgerufen werden, die mehrere Argumente enthält.

     Siehe auch die Funktion `optimize'.


 -- Funktion: dispform (<expr>)
 -- Funktion: dispform (<expr>, all)
     `dispform' formatiert den Ausdruck <expr> von der internen
     Darstellung in eine externe Darstellung, wie sie für die Anzeige
     des Ausdrucks benötigt wird.  Bei der Formatierung sind
     Optionsvariablen wie `dispflag'  und `powerdisp'  wirksam.

     Beispiele für die interne und externe Darstellung von Ausdrücken
     sind:

                    Interne Darstellung            Externe Darstellung
          ------------------------------------------------------------
          -x      : ((MTIMES) -1 $x)               ((MMINUS) $x)
          sqrt(x) : ((MEXPT) $x ((RAT) 1 2))       ((%SQRT) $X)
          a/b     : ((MTIMES) $A ((MEXPT) $B -1))  ((MQUOTIENT) $A $B)

     `dispform(<expr>)' gibt die externe Darstellung nur für den ersten
     Operator im Ausdruck zurück.  `dispform(<expr>, all)' gibt die
     externe Darstellung aller Operatoren im Ausdruck <expr> zurück.

     Siehe auch `part',  `inpart'  und `inflag'.

     Beispiel:

     Die Funktion `dispform' kann genutzt werden, um die Wurzelfunktion
     in einem Ausdruck zu substituieren.  Die Wurzelfunktion ist nur in
     der externen Darstellung eines Ausdruckes vorhanden:

          (%i1) expr: sqrt(5)/(5+sqrt(2));
                                       sqrt(5)
          (%o1)                      -----------
                                     sqrt(2) + 5
          (%i2) subst(f,sqrt,expr);
                                       sqrt(5)
          (%o2)                      -----------
                                     sqrt(2) + 5
          (%i3) subst(f,sqrt,dispform(expr));
                                        f(5)
          (%o3)                      -----------
                                     sqrt(2) + 5
          (%i4) subst(f,sqrt,dispform(expr,all));
                                        f(5)
          (%o4)                       --------
                                      f(2) + 5

 -- Funktion: disolate (<expr>, <x_1>, ..., <x_n>)
     Die Funktion `disolate' arbeitet ähnlich wie die Funktion
     `isolate'.  Teilausdrücke im Ausdruck <expr>, die die Variablen
     <x_1>, ..., <x_n> nicht enthalten, werden durch Zwischenmarken
     `%t1', `%t2', ... ersetzt.  Im Unterschied zu der Funktion
     `isolate' kann die Funktion `disolate' Teilausdrücke zu mehr als
     einer Variablen aus einem Ausdruck isolieren.

     Die Ersetzung von Teilausdrücken durch Zwischenmarken kann mit der
     Optionsvariable `isolate_wrt_times' kontrolliert werden.  Hat die
     Optionsvariable `isolate_wrt_times' den Wert `true', werden
     Ersetzungen in Produkten ausgeführt.  Der Standardwert ist `false'.
     Siehe `isolate_wrt_times'  für Beispiele.

     Die Optionsvariable `exptisolate'  hat im Unterschied zur Funktion
     `isolate' keinen Einfluss auf die Ersetzung von Teilausdrücken
     durch Zwischenmarken.

     `disolate' wird automatisch aus der Datei
     `share/simplification/disol.mac' geladen.  Das Kommando
     `demo(disol)$' zeigt Beispiele.

     Siehe auch die Funktion `isolate'.

     Beispiel:

          (%i1) expr:a*(e*(g+f)+b*(d+c));
          (%o1)               a (e (g + f) + b (d + c))
          (%i2) disolate(expr,a,b,e);
          (%t2)                         d + c

          (%t3)                         g + f

          (%o3)                   a (%t3 e + %t2 b)

 -- Funktion: dpart (<expr>, <n_1>, ..., <n_k>)
     Wählt wie die Funktion `part' einen Teilausdruck aus, gibt aber den
     vollständigen Ausdruck zurück, wobei der ausgewählte Teilausdruck
     eingerahmt ist.  Der Rahmen ist Teil des zurückgegebenen Ausdrucks.

     Siehe auch `part',  `inpart'  und `lpart'  sowie `box'.

     Beispiel:

          (%i1) dpart (x+y/z^2, 1, 2, 1);
                                       y
          (%o1)                       ---- + x
                                         2
                                      """
                                      "z"
                                      """

 -- Optionsvariable: exptisolate
     Standardwert: `false'

     Hat `exptisolate' den Wert `true', dann sucht die Funktion
     `isolate' auch in den Exponenten von Zahlen oder Symbolen nach
     Teilausdrücken zu einer Variablen.

     Siehe die Funktion `isolate'  für Beispiele.

 -- Optionsvariable: exptsubst
     Standardwert: `false'

     Die Optionsvariable `exptsubst' kontrolliert die Substitution von
     Ausdrücken mit der Exponentialfunktion durch die Funktionen `subst'
     und `psubst'.

     Beispiele:

          (%i1) subst(y,%e^x,%e^(a*x)),exptsubst:false;
                                          a x
          (%o1)                         %e
          (%i2) subst(y,%e^x,%e^(a*x)),exptsubst:true;
                                          a
          (%o2)                          y

 -- Funktion: freeof (<x>, <expr>)
 -- Funktion: freeof (<x_1>, ..., <x_n>, <expr>)
     `freeof(<x>, <expr>)' gibt das Ergebnis `true' zurück, wenn das
     Argument <x> nicht im Ausdruck <expr> enthalten ist.  Ansonsten ist
     der Rückgabewert `false'.

     `freeof(<x_1>, ..., <x_n>, <expr>)' gibt das Ergebnis `true'
     zurück, wenn keines der Argumente <x_1>, <x_2>, ...  im Ausdruck
     <expr> enthalten ist.

     Die Argumente <x_1>, ..., <x_n> können die Namen von Funktionen
     und Variablen sein, indizierte Namen, die Namen von Operatoren
     oder allgemeine Ausdrücke.  Die Funktion `freeof' wertet die
     Argumente aus.

     Bei der Prüfung, ob ein Teilausdruck <x> im Ausdruck <expr>
     enthalten ist, untersucht die Funktion `freeof' den Ausdruck
     <expr> in der vorliegenden Form (nach Auswertung und
     Vereinfachung) und versucht nicht herauszufinden, ob der
     Teilausdruck in einem äquivalenten Ausdruck enthälten wäre.

     `freeof' ignoriert Dummy-Variablen.  Dummy-Variablen sind
     Variablen, die außerhalb eines Ausdrucks nicht in Erscheinung
     treten.  Folgende Dummy-Variablen werden von `freeof' ignoriert:
     der Index einer Summe oder eines Produktes, die unabhängige
     Variable in einem Grenzwert, die Integrationsvariable eines
     bestimmten Integrals oder einer Laplacetransformation, formale
     Variablen in `at' - oder `lambda' -Ausdrücke, lokale Variablen
     eines Blocks oder einer `do' -Schleife.

     Das unbestimmte Integral ist nicht frei von der
     Integrationsvariablen.

     Beispiele:

     Argumente sind Namen von Funktionen, Variablen, indizierten
     Variablen, Operatoren und Ausdrücke.  `freeof(a, b, expr)' ist
     äquivalent zu `freeof(a, expr) and freeof(b, expr)'.

          (%i1) expr: z^3 * cos (a[1]) * b^(c+d);
                                           d + c  3
          (%o1)                   cos(a ) b      z
                                       1
          (%i2) freeof(z, expr);
          (%o2)                         false
          (%i3) freeof(cos, expr);
          (%o3)                         false
          (%i4) freeof(a[1], expr);
          (%o4)                         false
          (%i5) freeof(cos (a[1]), expr);
          (%o5)                         false
          (%i6) freeof(b^(c+d), expr);
          (%o6)                         false
          (%i7) freeof("^", expr);
          (%o7)                         false
          (%i8) freeof(w, sin, a[2], sin (a[2]), b*(c+d), expr);
          (%o8)                         true

     Die Funktion `freeof' wertet die Argumente aus.

          (%i1) expr: (a+b)^5$
          (%i2) c: a$
          (%i3) freeof(c, expr);
          (%o3)                         false

     `freeof' betrachtet keine äquivalenten Ausdrücke.  Vereinfachungen
     können einen äquivalenten Ausdruck liefern, der jedoch den
     Teilausdruck nicht mehr enthält.

          (%i1) expr: (a+b)^5$
          (%i2) expand(expr);
                    5        4       2  3       3  2      4      5
          (%o2)    b  + 5 a b  + 10 a  b  + 10 a  b  + 5 a  b + a
          (%i3) freeof(a+b, %);
          (%o3)                         true
          (%i4) freeof(a+b, expr);
          (%o4)                         false

     Die Exponentialfunktion `exp(x)' wird von Maxima sofort zu `%e^x'
     vereinfacht.  Der Name `exp' der Exponentialfunktion ist daher
     nicht in einem Ausdruck enthalten.

          (%i5) exp(x);
                                           x
          (%o5)                          %e
          (%i6) freeof(exp, exp (x));
          (%o6)                         true

     Eine Summe ist frei von dem Index und ein bestimmtes Integral ist
     frei von der Integrationsvariablen.  Ein unbestimmtes Integral ist
     nicht frei von der Integrationsvariablen.

          (%i1) freeof(i, 'sum (f(i), i, 0, n));
          (%o1)                         true
          (%i2) freeof(x, 'integrate (x^2, x, 0, 1));
          (%o2)                         true
          (%i3) freeof(x, 'integrate (x^2, x));
          (%o3)                         false

 -- Optionsvariable: inflag
     Standardwert: `false'

     Hat die Optionsvariable `inflag' den Wert `true', wird von
     Funktionen, die Teile eines Ausdrucks `expr' extrahieren, die
     interne Form des Ausdrucks `expr' betrachtet.

     Die Anordnung der Argumente der internen Darstellung unterscheidet
     sich zum Beispiel für die Addition von der externen Darstellung
     für die Anzeige.  Daher hat `first(x+y)' das Ergebnis `x', wenn
     `inflag' den Wert `true' hat, und `y', wenn `inflag' den Wert
     `false' hat.  Der Ausdruck `first(y+x)' gibt in beiden Fällen
     dasselbe Ergebnis.

     Hat `inflag' den Wert `true', entsprechen die Funktionen `part'
     und `substpart' den Funktionen `inpart' und `substinpart'.

     Folgende Funktionen werden von der Optionsvariablen `inflag'
     beeinflusst: `part',  `substpart',  `first',  `rest',

     `last',  `length',  die Konstruktion `for'  ...  `in', `map',
     `fullmap',  `maplist',

     `reveal',  `pickapart',  `args'  und `op'.


 -- Funktion: inpart (<expr>, <n_1>, ..., <n_k>)
     Die Funktion `inpart' ist ähnlich wie `part', arbeitet aber mit der
     internen Darstellung eines Ausdruckes und nicht mit der externen
     Darstellung für die Anzeige.  Da keine Formatierung vorgenommen
     wird, ist die Funktion `inpart' schneller als `part'.

     Immer dann, wenn sich die interne und die externe Darstellung
     eines Ausdrucks voneinander unterscheiden, haben die Funktionen
     `inpart' und `part' verschiedene Ergebnisse.  Dies trifft zu für
     die Anordnung der Argumente einer Addition, der Subtraktion und
     Division sowie zum Beispiel für die Wurzelfunktion.

     Ist das letzte Argument einer `part'-Funktion eine Liste mit
     Indizes, werden mehrere Teilausdrücke heraus gepickt.  So hat
     `inpart(x + y + z, [1, 3])' das Ergebnis `z+x'.

     Siehe auch `part',  `dpart'  und `lpart'.

     Beispiele:

          (%i1) x + y + w*z;
          (%o1)                      w z + y + x
          (%i2) inpart (%, 3, 2);
          (%o2)                           z
          (%i3) part (%th (2), 1, 2);
          (%o3)                           z
          (%i4) 'limit (f(x)^g(x+1), x, 0, minus);
                                            g(x + 1)
          (%o4)                 limit   f(x)
                                x -> 0-
          (%i5) inpart (%, 1, 2);
          (%o5)                       g(x + 1)

 -- Funktion: isolate (<expr>, <x>)
     Teilausdrücke im Ausdruck <expr>, die die Variable <x> nicht
     enthalten, werden durch Zwischenmarken `%t1', `%t2', ... ersetzt.
     Dies kann genutzt werden, um die weitere Auswertung und
     Vereinfachung dieser Teilausdrücke zu verhindern.  Die Ersetzung
     der Teilausdrücke kann durch eine Auswertung des Ausdrucks
     rückgängig gemacht werden.

     Die Ersetzung von Teilausdrücken kann mit den Optionsvariablen
     `exptisolate'  und `isolate_wrt_times'  kontrolliert werden.  Hat
     die Optionsvariable `exptisolate' den Wert `true', werden
     Ersetzungen auch für die Exponentiation ausgeführt.  Die Basis
     muss dabei eine Zahl oder ein Symbol wie `%e' sein.  Hat die
     Optionsvariable `isolate_wrt_times' den Wert `true', werden
     Ersetzungen in Produkten ausgeführt.  Siehe `isolate_wrt_times'
     für Beispiele.

     Die Ersetzung von Teilausdrücken für mehrere Variable kann mit der
     Funktion `disolate' ausgeführt werden.  Siehe `disolate'.

     Beispiele:

          (%i1) (b+a)^4*(x*((d+c)^2+2*x)+1);
                                 4                  2
          (%o1)           (b + a)  (x (2 x + (d + c) ) + 1)
          (%i2) isolate(%,x);

                                             2
          (%t2)                       (d + c)


                                             4
          (%t3)                       (b + a)

          (%o3)                %t3 (x (2 x + %t2) + 1)
          (%i4) ratexpand(%);
                                    2
          (%o4)              2 %t3 x  + %t2 %t3 x + %t3
          (%i5) ev(%);
                            4  2          4        2            4
          (%o5)    2 (b + a)  x  + (b + a)  (d + c)  x + (b + a)
          (%i6) (b+a)*(b+a+x)^2*%e^(b+a*x+x^2);
                                                 2
                                            2   x  + a x + b
          (%o6)          (b + a) (x + b + a)  %e
          (%i7) ev(isolate(%,x),exptisolate:true);

          (%t7)                         b + a


                                           b
          (%t8)                          %e

                                                  2
                                             2   x  + a x
          (%o8)             %t7 %t8 (x + %t7)  %e

 -- Optionsvariable: isolate_wrt_times
     Standardwert: `false'

     Hat die Optionsvariable `isolate_wrt_times' den Wert `true', führen
     die Funktionen `isolate' und `disolate' auch Ersetzungen in
     Produkten aus.

     Siehe auch die Funktionen `isolate'  und `disolate'.

     Beispiele:

          (%i1) isolate_wrt_times: true$
          (%i2) isolate (expand ((a+b+c)^2), c);

          (%t2)                          2 a


          (%t3)                          2 b


                                    2            2
          (%t4)                    b  + 2 a b + a

                               2
          (%o4)               c  + %t3 c + %t2 c + %t4
          (%i4) isolate_wrt_times: false$
          (%i5) isolate (expand ((a+b+c)^2), c);
                               2
          (%o5)               c  + 2 b c + 2 a c + %t4

 -- Optionsvariable: listconstvars
     Standardwert: `false'

     Hat die Optionsvariable `listconstvars' den Wert `true', werden
     Konstante wie `%e',  `%pi'  und Variablen, die als konstant
     deklariert sind, von der Funktion `listofvars'  in die
     Ergebnisliste aufgenommen.  Der Standardwert von `listconstvars'
     ist `false' und Konstante werden ignoriert.

 -- Optionsvariable: listdummyvars
     Standardwert: `true'

     Hat `listdummyvars' den Wert `false', werden die Dummy-Variablen
     eines Ausdrucks von der Funktion `listofvars'  ignoriert.
     Dummy-Variablen sind zum Beispiel der Index einer Summe, die
     Grenzwertvariable oder die Integrationsvariable eines bestimmten
     Integrals.

     Beispiele:

          (%i1) listdummyvars: true$
          (%i2) listofvars ('sum(f(i), i, 0, n));
          (%o2)                        [i, n]
          (%i3) listdummyvars: false$
          (%i4) listofvars ('sum(f(i), i, 0, n));
          (%o4)                          [n]

 -- Funktion: listofvars (<expr>)
     Die Funktion `listofvars' gibt eine Liste der Variablen zurück,
     die im Ausdruck <expr> enthalten sind.

     Hat die Optionsvariable `listconstvars'  den Wert `true', werden
     auch Konstante wie `%e',  `%pi'  und `%i'  sowie als konstant
     deklarierte Variable in die Liste aufgenommen.  Der Standardwert
     von `listconstvars' ist `false'.

     Siehe entsprechend die Optionsvariable `listdummyvars'  für
     Dummy-Variablen.

     Beispiel:

          (%i1) listofvars (f (x[1]+y) / g^(2+a));
          (%o1)                     [g, a, x , y]
                                            1

 -- Funktion: lfreeof (<list>, <expr>)
     Für jedes Element <m> der Liste <list> wird die Funktion `freeof'
     aufgerufen.  `lfreeof' hat den Rückgabewert `true', wenn keines
     der Elemente der Liste <list> im Ausdruck `expr' enthalten ist.
     Ansonsten ist der Rückgabewert `false'.

     Siehe auch die Funktion `freeof'.


 -- Funktion: lpart (<label>, <expr>, <n_1>, ..., <n_k>)
     Die Funktion `lpart' ist ähnlich zu `dpart', verwendet aber einen
     Rahmen, der mit einer Marke gekennzeichnet ist.

     Siehe auch `part',  `inpart'  und `dpart'.


 -- Eigenschaft: mainvar
     Die Deklaration einer Variablen als eine Hauptvariable mit der
     Funktion `declare'  ändert deren Anordnung in einem Ausdruck der
     kanonisch geordnet ist.  Hauptvariable sind bezüglich der
     Funktionen `ordergreatp'  und `orderlessp'  stets größer als alle
     anderen Symbole, Konstanten und Zahlen.

     Beispiel:

          (%i1) sort([9, 1, %pi, g, t, a]);
          (%o1)                 [1, 9, %pi, a, g, t]

          (%i2) declare(a, mainvar)$
          (%i3) sort([9, 1, %pi, g, t, a]);
          (%o3)                 [1, 9, %pi, g, t, a]

 -- Eigenschaft: noun
     `noun' ist eine der Optionen des Kommandos `declare' .  Wird eine
     Funktion als `noun' deklariert, wird diese als Substantivform
     behandelt und nicht ausgewertet.

     Ein Symbol `f', dass als `noun' deklariert wird, wird in die
     Informationsliste `aliases'  eingetragen und die Rückgabe der
     Funktion `properties'  enthält den Eintrag `noun'.

     Beispiel:

          (%i1) factor (12345678);
                                       2
          (%o1)                     2 3  47 14593
          (%i2) declare (factor, noun);
          (%o2)                         done
          (%i3) factor (12345678);
          (%o3)                   factor(12345678)
          (%i4) ''%, nouns;
                                       2
          (%o4)                     2 3  47 14593

 -- Optionsvariable: noundisp
     Standardwert: `false'

     Hat `noundisp' den Wert `true', werden Substantivformen mit einem
     vorangestelltem Hochkomma angezeigt.  Diese Optionsvariable hat
     immer den Wert `true', wenn die Definition von Funktionen
     angezeigt wird.

 -- Funktion: nounify (<f>)
     Die Funktion `nounify' gibt den Namen einer Funktion <f> in einer
     Substantivform zurück.  Der Name <f> ist ein Symbol oder eine
     Zeichenkette.

     Einige Funktionen geben eine Substantivform zurück, wenn die
     Funktion nicht ausgewertet werden kann.  Wird einem
     Funktionsaufruf wie zum Beispiel `'f(x)' oder `'(f(x))' ein
     Hochkomma vorangestellt, wird ebenfalls eine Substantivform
     zurückgegeben.

     Siehe auch die Funktion `verbify'.


 -- Funktion: nterms (<expr>)
     Die Funktion `nterms' gibt die Anzahl der Terme des Ausdrucks
     <expr> zurück, wobei der Ausdruck als vollständig expandiert
     angenommen wird, ohne dass Terme gekürzt oder zusammengefasst
     werden.

     Ausdrücke wie `sin(<expr>)', `sqrt(<expr>)' oder `exp(<expr>)'
     werden dabei als ein Term gezählt.

 -- Funktion: op (<expr>)
     Die Funktion `op' gibt den Hauptoperator des Ausdrucks <expr>
     zurück.  `op(<expr>)' ist äquivalent zu `part(<expr>, 0)'.

     Ist der Hauptoperator des Ausdrucks <expr> ein Operator wie "+",
     "*" oder "/" wird der Name des Operators als Zeichenkette
     zurückgegeben.  Andernfalls wird ein Symbol zurückgegeben.

     `op' beachtet den Wert der Optionsvariablen `inflag'.    `op'
     wertet die Argumente aus.  Siehe auch `args'.

     Beispiele:

          (%i1) stringdisp: true$
          (%i2) op (a * b * c);
          (%o2)                          "*"
          (%i3) op (a * b + c);
          (%o3)                          "+"
          (%i4) op ('sin (a + b));
          (%o4)                          sin
          (%i5) op (a!);
          (%o5)                          "!"
          (%i6) op (-a);
          (%o6)                          "-"
          (%i7) op ([a, b, c]);
          (%o7)                          "["
          (%i8) op ('(if a > b then c else d));
          (%o8)                         "if"
          (%i9) op ('foo (a));
          (%o9)                          foo
          (%i10) prefix (foo);
          (%o10)                        "foo"
          (%i11) op (foo a);
          (%o11)                        "foo"
          (%i12) op (F [x, y] (a, b, c));
          (%o12)                        F
                                         x, y
          (%i13) op (G [u, v, w]);
          (%o13)                          G

 -- Funktion: operatorp (<expr>, <op>)
 -- Funktion: operatorp (<expr>, [<op_1>, ..., <op_n>])
     Das Kommando `operatorp(<expr>, <op>)' gibt `true' zurück, wenn
     <op> der Hauptoperator des Ausdrucks <expr> ist.

     `operatorp(<expr>, [<op_1>, ..., <op_n>])' gibt `true' zurück,
     wenn einer der Operatoren <op_1>, ..., <op_n> der Hauptoperator
     des Ausdrucks <expr> ist.

 -- Optionsvariable: opsubst
     Hat die Optionsvariable `opsubst' den Wert `false', führt die
     Funktion `subst'  keine Substitution in einen Operator eines
     Ausdrucks aus.  Zum Beispiel hat `(opsubst: false, subst(x^2, r,
     r+r[0]))' das Ergebnis `x^2+r[0]'.

 -- Funktion: optimize (<expr>)
     Die Funktion `optimize' gibt einen Ausdruck zurück, der dasselbe
     Ergebnis und dieselben Seiteneffekte wie <expr> hat, der jedoch
     effizienter ausgewertet werden kann.  Im neuen Ausdruck wird die
     mehrfache Berechnung gleicher Teilausdrücke vermieden und gleiche
     Teilausdrücke werden zusammengefasst.

     Siehe auch die Funktion `collapse'.

     `example(optimize)' zeigt ein Beispiel.

 -- Optionsvariable: optimprefix
     Standardwert: `%'

     Die Optionsvariable `optimprefix' enthält den Präfix, der von der
     Funktion `optimize'  benutzt wird, um einen Teilausdruck zu
     benennen.

 -- Funktion: ordergreat (<v_1>, ..., <v_n>)
 -- Funktion: orderless (<v_1>, ..., <v_n>)
     Die Funktion `ordergreat' ändert die kanonische Anordnung der
     Symbole so, dass <v_1> > <v_2> > ... > <v_n>.  Weiterhin ist <v_n>
     kleiner als jedes andere Symbol, das nicht in der Liste enthalten
     ist.

     `orderless' ändert die kanonische Anordnung der Symbole so, dass
     <v_1> < <v_2> < ... < <v_n>.  Weiterhin ist <v_n> größer als jedes
     andere Symbol, das nicht in der Liste enthalten ist.

     Die durch `ordergreat' und `orderless' definierte Ordnung wird
     durch `unorder'  wieder aufgehoben.  `ordergreat' und `orderless'
     können jeweils nur einmal aufgerufen werden, solange nicht mit
     `unorder' zuvor die definierte Ordnung aufgehoben wird.

     Siehe auch `ordergreatp',  `orderlessp'  und `mainvar'.


 -- Funktion: ordergreatp (<expr_1>, <expr_2>)
 -- Funktion: orderlessp (<expr_1>, <expr_2>)
     Die Funktion `ordergreatp' gibt `true' zurück, wenn in der
     kanonischen Ordnung von Maxima <expr_1> größer als <expr_2> ist.
     Ansonsten ist das Ergebnis `false'.

     Die Funktion `orderlessp' gibt `true' zurück, wenn in der
     kanonischen Ordnung von Maxima <expr_1> kleiner als <expr_2> ist.
     Ansonsten ist das Ergebnis `false'.

     Alle Maxima-Atome und Ausdrücke sind vergleichbar unter
     `ordergreatp' und `orderlessp'.  Die kanonische Ordnung von Atomen
     ist folgendermaßen:

     Numerische Konstanten <
        deklarierte Konstanten <
        deklarierte Skalare <
        erstes Argument von `orderless' <
        weitere Argumente von `orderless' <
        letztes Argument von `orderless' <
        Variablen beginnend mit a, ... <
        Variablen beginnend mit Z <
        letzte Argument von `ordergreat' <
        weitere Argumente von `ordergreat' <
        erste Argument von `ordergreat' <
        deklarierte Hauptvariablen.

     Die Ordnung für Ausdrücke, die keine Atome sind, wird von der für
     Atome abgeleitet.  Für die Operatoren `"+"', `"*"' und `"^"' kann
     die Ordnung nicht einfach beschrieben werden.  Andere Operatoren,
     Funktionen und Ausdrücke werden angeordnet nach den Argumenten,
     dann nach den Namen.  Bei Ausdrücken mit Indizes wird der Name des
     Symbols als Operator und der Index als Argument betrachtet.

     Die kanonische Ordnung der Ausdrücke wird modifiziert durch die
     Funktionen `ordergreat'  und `orderless'  sowie der Deklarationen
     `mainvar',  `constant'  und `scalar'.

     Siehe auch `sort'.

     Beispiele:

     Ordne Symbole und Konstanten.  `%pi'  wird nicht nach dem
     numerischen Wert sortiert, sondern wie eine Konstante.

          (%i1) stringdisp : true;
          (%o1)                         true
          (%i2) sort ([%pi, 3b0, 3.0, x, X, "foo", 3, a, "bar", 4.0, 4b0]);
          (%o2) [3, 3.0, 4.0, 3.0b0, 4.0b0, %pi, "bar", "foo", a, x, X]

     Anwendung der Funktionen `ordergreat' und `orderless'.

          (%i1) sort ([M, H, K, T, E, W, G, A, P, J, S]);
          (%o1)           [A, E, G, H, J, K, M, P, S, T, W]
          (%i2) ordergreat (S, J);
          (%o2)                         done
          (%i3) orderless (M, H);
          (%o3)                         done
          (%i4) sort ([M, H, K, T, E, W, G, A, P, J, S]);
          (%o4)           [M, H, A, E, G, K, P, T, W, J, S]

     Anwendung der Deklarationen `mainvar', `constant' und `scalar'.

          (%i1) sort ([aa, foo, bar, bb, baz, quux, cc, dd, A1, B1, C1]);
          (%o1)   [aa, bar, baz, bb, cc, dd, foo, quux, A1, B1, C1]
          (%i2) declare (aa, mainvar);
          (%o2)                         done
          (%i3) declare ([baz, quux], constant);
          (%o3)                         done
          (%i4) declare ([A1, B1], scalar);
          (%o4)                         done
          (%i5) sort ([aa, foo, bar, bb, baz, quux, cc, dd, A1, B1, C1]);
          (%o5)   [baz, quux, A1, B1, bar, bb, cc, dd, foo, C1, aa]

     Ordne nicht atomare Ausdrücke.

          (%i1) sort ([f(1), f(2), f(2, 1), g(1), g(1, 2), g(n), f(n, 1)]);
          (%o1) [f(1), g(1), g(1, 2), f(2), f(2, 1), g(n), f(n, 1)]
          (%i2) sort ([foo(1), X[1], X[k], foo(k), 1, k]);
          (%o2)            [1, foo(1), X , k, foo(k), X ]
                                        1              k

 -- Funktion: ordermagnitudep (<expr_1>, <expr_2>)
     Ist eine Aussagefunktion, die das Ergebnis `true' hat, wenn die
     Argumente <expr_1> und <expr_2> Zahlen, Konstante oder konstante
     Ausdrücke repräsentieren und <expr_1> kleiner als <expr_2> ist.
     Sind die Argumente nicht der Größe nach vergleichbar, wird die
     Ordnung durch die Aussagefunktion `orderlessp'  bestimmt.

     Wird die Aussagefunktion `ordermagnitudep' als Argument der
     Funktion `sort'  verwendet, werden die Elemente einer Liste nach
     der Größe sortiert.

     Beispiele:

          (%i1) ordermagnitudep(1, 2);
          (%o1)                         true
          (%i2) ordermagnitudep(%e, %pi);
          (%o2)                         true
          (%i3) sort([%e, %pi, sin(1), 0, 1, 2, 3, 4]);
          (%o3)           [0, 1, 2, 3, 4, %e, %pi, sin(1)]
          (%i4) sort([%e, %pi, sin(1), 0, 1, 2, 3, 4], ordermagnitudep);
          (%o4)           [0, sin(1), 1, 2, %e, 3, %pi, 4]

 -- Funktion: part (<expr>, <n_1>, ..., <n_k>)
     Die Funktion `part' gibt einen Teilausdruck des Ausdrucks <expr>
     zurück.  Der Ausdruck <expr> wird zuvor in das Format für die
     Anzeige umgewandelt.

     Der Teilausdruck wird durch die Indizes <n_1>, ..., <n_k>
     ausgewählt.  Zuerst wird der Teilausdruck <n_1> ermittelt, von
     diesem der Teilausdruck <n_2>, u.s.w.  Der zum Index <n_k> zuletzt
     gewonnene Teilausdruck ist dann das Ergebnis.

     `part' kann auch verwendet werden, um ein Element einer Liste oder
     die Zeile einer Matrix zu erhalten.

     Das letzte Argument einer `part'-Funktion kann eine Liste mit
     Indizes sein.  In diesem Fall werden alle angegebenen
     Teilausdrücke als Ergebnis zurückgegeben.  Zum Beispiel hat das
     Kommando `part(x + y + z, [1, 3])' das Ergebnis `z+x'.

     Die Systemvariable `piece'  enthält den letzten Ausdruck, der bei
     der Verwendung einer `part'-Funktion ausgewählt wurde.

     Hat die Optionsvariable `partswitch'  den Wert `true', wird `end'
     zurückgegeben, wenn versucht wurde, einen Teilausdruck zu bilden,
     der nicht existiert, andernfalls wird eine Fehlermeldung
     ausgegeben.

     Siehe auch `inpart',  `substpart',  `substinpart',

     `dpart'  und `lpart'.

     Beispiele:

          (%i1) part(z+2*y+a,2);
          (%o1)                                 2 y
          (%i2) part(z+2*y+a,[1,3]);
          (%o2)                                z + a
          (%i3) part(z+2*y+a,2,1);
          (%o3)                                  2

     `example(part)' zeigt weitere Beispiele.

 -- Funktion: partition (<expr>, <var>)
     Die Funktion `partition' gibt eine Liste mit zwei Ausdrücken
     zurück.  Ist das Argument <expr> ein Produkt enthält das erste
     Element die Faktoren, die die Variable `var' enthalten, und das
     zweite Element enthält die übrigen Faktoren.  Entsprechend enthält
     das erste Element die Terme einer Summe oder die Elemente einer
     Liste, die die Variable <var> enthalten, und das zweite Elemente
     die verbleibende Terme der Summe oder Elemente der Liste.

          (%i1) partition (2*a*x*f(x), x);
          (%o1)                     [2 a, x f(x)]
          (%i2) partition (a+b, x);
          (%o2)                      [b + a, 0]
          (%i3) partition ([a, b, f(a), c], a);
          (%o3)                  [[b, c], [a, f(a)]]

 -- Optionsvariable: partswitch
     Standardwert: `false'

     Hat die Optionsvariable `partswitch' den Wert `true', wird `end'
     zurückgegeben, wenn versucht wird, einen Teilausdruck zu bilden,
     der nicht existiert, andernfalls wird eine Fehlermeldung
     ausgegeben.

 -- Funktion: pickapart (<expr>, <n>)
     Den Teilausdrücken in einer Tiefe <n> eines verschachtelten
     Ausdrucks werden Zwischenmarken zugewiesen.  <n> ist eine ganze
     positive Zahl.  Die Rückgabe von `pickapart' ist ein äquivalenter
     Ausdruck, der die Zwischenmarken enthält.

     Siehe auch `part',  `dpart',  `lpart',

     `inpart'  und `reveal'.

     Beispiele:

          (%i1) expr: (a+b)/2 + sin (x^2)/3 - log (1 + sqrt(x+1));
                                                    2
                                               sin(x )   b + a
          (%o1)       - log(sqrt(x + 1) + 1) + ------- + -----
                                                  3        2
          (%i2) pickapart (expr, 0);

                                                    2
                                               sin(x )   b + a
          (%t2)       - log(sqrt(x + 1) + 1) + ------- + -----
                                                  3        2

          (%o2)                          %t2
          (%i3) pickapart (expr, 1);

          (%t3)                - log(sqrt(x + 1) + 1)


                                            2
                                       sin(x )
          (%t4)                        -------
                                          3


                                        b + a
          (%t5)                         -----
                                          2

          (%o5)                    %t5 + %t4 + %t3
          (%i5) pickapart (expr, 2);

          (%t6)                 log(sqrt(x + 1) + 1)


                                            2
          (%t7)                        sin(x )


          (%t8)                         b + a

                                   %t8   %t7
          (%o8)                    --- + --- - %t6
                                    2     3
          (%i8) pickapart (expr, 3);

          (%t9)                    sqrt(x + 1) + 1


                                          2
          (%t10)                         x

                            b + a              sin(%t10)
          (%o10)            ----- - log(%t9) + ---------
                              2                    3
          (%i10) pickapart (expr, 4);

          (%t11)                     sqrt(x + 1)

                                2
                           sin(x )   b + a
          (%o11)           ------- + ----- - log(%t11 + 1)
                              3        2
          (%i11) pickapart (expr, 5);

          (%t12)                        x + 1

                             2
                        sin(x )   b + a
          (%o12)        ------- + ----- - log(sqrt(%t12) + 1)
                           3        2
          (%i12) pickapart (expr, 6);
                            2
                       sin(x )   b + a
          (%o12)       ------- + ----- - log(sqrt(x + 1) + 1)
                          3        2

 -- Systemvariable: piece
     Die Systemvariable `piece' enthält den letzten Ausdruck, der bei
     der Verwendung einer `part'-Funktion ausgewählt wurde.

     Siehe auch `part'  und `inpart'.


 -- Funktion: psubst (<list>, <expr>)
 -- Funktion: psubst (<a>, <b>, <expr>)
     `psubst(<a>, <b>, <expr>)' ist identisch mit `subst'.  Siehe
     `subst'.

     Im Unterschied zu `subst' führt die Funktion `psubst'
     Substitutionen parallel aus, wenn das erste Argument <list> eine
     Liste mit Gleichungen ist.

     Siehe auch die Funktion `sublis',  um Substitutionen parallel
     auszuführen.

     Beispiel:

     Das erste Beispiel zeigt die parallele Substitution mit `psubst'.
     Das zweite Beispiel zeigt das Ergebnis für die Funktion `subst'.
     In diesem Fall werden die Substitutionen nacheinander ausgeführt.

          (%i4) psubst ([a^2=b, b=a], sin(a^2) + sin(b));
          (%o4)                           sin(b) + sin(a)
          (%i5) subst ([a^2=b, b=a], sin(a^2) + sin(b));
          (%o5)                              2 sin(a)

 -- Funktion: rembox (<expr>, unlabelled)
 -- Funktion: rembox (<expr>, <label>)
 -- Funktion: rembox (<expr>)
     Die Funktion `rembox' entfernt Rahmen aus dem Ausdruck <expr>.
     `rembox(<expr>, unlabelled)' entfernt alle Rahmen, die keine Marke
     haben.  `rembox(<expr>, <label>)' entfernt nur Rahmen, die mit der
     Marke <label> gekennzeichnet sind.  `rembox(<expr>)' entfernt alle
     Rahmen.

     Rahmen werden mit den Funktionen `box',  `dpart'  und `lpart'
     einem Ausdruck hinzugefügt.

     Beispiele:

          (%i1) expr: (a*d - b*c)/h^2 + sin(%pi*x);
                                            a d - b c
          (%o1)                sin(%pi x) + ---------
                                                2
                                               h

          (%i2) dpart (dpart (expr, 1, 1), 2, 2);
                                  """""""    a d - b c
          (%o2)               sin("%pi x") + ---------
                                  """""""      """"
                                               " 2"
                                               "h "
                                               """"

          (%i3) expr2: lpart (BAR, lpart (FOO, %, 1), 2);
                            FOO"""""""""""   BAR""""""""
                            "    """"""" "   "a d - b c"
          (%o3)             "sin("%pi x")" + "---------"
                            "    """"""" "   "  """"   "
                            """"""""""""""   "  " 2"   "
                                             "  "h "   "
                                             "  """"   "
                                             """""""""""

          (%i4) rembox (expr2, unlabelled);
                                            BAR""""""""
                             FOO"""""""""   "a d - b c"
          (%o4)              "sin(%pi x)" + "---------"
                             """"""""""""   "    2    "
                                            "   h     "
                                            """""""""""
          (%i5) rembox (expr2, FOO);
                                            BAR""""""""
                                 """""""    "a d - b c"
          (%o5)              sin("%pi x") + "---------"
                                 """""""    "  """"   "
                                            "  " 2"   "
                                            "  "h "   "
                                            "  """"   "
                                            """""""""""
          (%i6) rembox (expr2, BAR);
                             FOO"""""""""""
                             "    """"""" "   a d - b c
          (%o6)              "sin("%pi x")" + ---------
                             "    """"""" "     """"
                             """"""""""""""     " 2"
                                                "h "
                                                """"
          (%i7) rembox (expr2);
                                            a d - b c
          (%o7)                sin(%pi x) + ---------
                                                2
                                               h

 -- Funktion: reveal (<expr>, <depth>)
     Ersetzt Teile des Ausdrucks <expr> in der ganzzahligen Tiefe
     <depth> durch eine beschreibende Zusammenfassung:

        * Summen und Differenzen werden durch `Sum(<n>)' ersetzt, wobei
          <n> die Anzahl der Terme der Summe oder Differenz ist.

        * Produkte werden durch `Product(<n>)' ersetzt, wobei <n> die
          Anzahl der Faktoren des Produktes ist.

        * Exponentiationen werden durch `Expt' ersetzt.

        * Quotienten werden durch `Quotient' ersetzt.

        * Die Negation wird durch `Negterm' ersetzt.

        * Listen werden durch `List(<n>)' ersetzt, wobei <n> die Anzahl
          der Elemente der Liste ist.

     Ist <depth> größer oder gleich der maximalen Tiefe des Ausdrucks
     <expr>, gibt `reveal' den Ausdruck <expr> unverändert zurück.

     `reveal' wertet die Argumente aus.  `reveal' gibt die
     Zusammenfassung zurück.

     Beispiele:

          (%i1) e: expand ((a - b)^2)/expand ((exp(a) + exp(b))^2);
                                    2            2
                                   b  - 2 a b + a
          (%o1)               -------------------------
                                  b + a     2 b     2 a
                              2 %e      + %e    + %e
          (%i2) reveal (e, 1);
          (%o2)                       Quotient
          (%i3) reveal (e, 2);
                                       Sum(3)
          (%o3)                        ------
                                       Sum(3)
          (%i4) reveal (e, 3);
                               Expt + Negterm + Expt
          (%o4)               ------------------------
                              Product(2) + Expt + Expt
          (%i5) reveal (e, 4);
                                 2                 2
                                b  - Product(3) + a
          (%o5)         ------------------------------------
                                   Product(2)     Product(2)
                        2 Expt + %e           + %e
          (%i6) reveal (e, 5);
                                   2            2
                                  b  - 2 a b + a
          (%o6)              --------------------------
                                 Sum(2)     2 b     2 a
                             2 %e       + %e    + %e
          (%i7) reveal (e, 6);
                                    2            2
                                   b  - 2 a b + a
          (%o7)               -------------------------
                                  b + a     2 b     2 a
                              2 %e      + %e    + %e

 -- Funktion: sublis (<list>, <expr>)
     Führt im Unterschied zu der Funktion `subst'  die Substitutionen
     der Liste <list> parallel und nicht nacheinander aus.

     Mit der Optionsvariablen `sublis_apply_lambda'  wird die
     Vereinfachung von Lamda-Ausdrücken kontrolliert, nachdem die
     Substitution ausgeführt wurde.

     Siehe auch die Funktion `psubst',  um parallele Substitutionen
     auszuführen.

     Beispiele:

          (%i1) sublis ([a=b, b=a], sin(a) + cos(b));
          (%o1)                    sin(b) + cos(a)

 -- Optionsvariable: sublis_apply_lambda
     Standardwert: `true'

     Kontrolliert, ob Lambda-Ausdrücke nach einer Substitution
     ausgewertet werden.  Hat `sublis_apply_lambda' den Wert `true'
     werden Lambda-Ausdrücke ausgewertet.  Ansonsten verbleiben diese
     nach der Substitution im Ausdruck.

 -- Option variable: subnumsimp
     Default value: `false'

     If `true' then the functions `subst'  and `psubst'  can substitute
     a subscripted variable `f[x]' with a number, when only the symbol
     `f' is given.

     See also `subst'.

          (%i1) subst(100,g,g[x]+2);

          subst: cannot substitute 100 for operator g in expression g
                                                                     x
           -- an error. To debug this try: debugmode(true);

          (%i2) subst(100,g,g[x]+2),subnumsimp:true;
          (%o2)                          102

 -- Funktion: subst (<a>, <b>, <c>)
     Substituiert <a> für <b> in den Ausdruck <c>.  Das Argument <b>
     muss ein Atom oder ein vollständiger Teilausdruck von <c> sein.
     Zum Beispiel ist `x+y+z' ein vollständiger Teilausdruck von
     `2*(x+y+z)/w', nicht aber `x+y'.  Hat <b> nicht diese Eigenschaft,
     dann können möglicherweise die Funktionen `substpart'  oder
     `ratsubst'  angewendet werden.

     Hat <b> die Form `e/f', kann `subst(a*f, e, c)' verwendet werden.
     Ist `b' von der Form `e^(1/f)', dann kann `subst(a^f, e, c)'
     verwendet werden.  Die Funktion `subst' erkennt auch den Ausdruck
     `x^y' in `x^-y', so dass `subst(a, sqrt(x), 1/sqrt(x))' das
     Ergebnis `1/a' hat.  <a> und <b> können auch die Namen von
     Operatoren oder Funktionen sein.  Soll die unabhängige Variable in
     Ausdrücken mit Ableitungen substituiert werden, sollte die Funktion
     `at'  verwendet werden.

     `subst' ist der Alias-Name für `substitute'.

     `subst(<eq_1>, <expr>)' und `subst([<eq_1>, ..., <eq_k>], <expr>)'
     sind weitere mögliche Formen.  <eq_i> sind Gleichungen, die
     angeben, welche Substitutionen auszuführen sind.  Für jede
     Gleichung wird die rechte Seite der Gleichung für die linke Seite
     in den Ausdruck <expr> substituiert.

     Hat die Optionsvariable `exptsubst'  den Wert `true', wird eine
     Substitution wie `y' für `%e^x' in einem Ausdruck der Form
     `%e^(a*x)' nicht ausgeführt.

     Hat die Optionsvariable `opsubst'  den Wert `false', führt die
     Funktion `subst' keine Substitution in einen Operator eines
     Ausdrucks aus.  Zum Beispiel hat `(opsubst: false, subst(x^2, r,
     r+r[0]))' das Ergebnis `x^2+r[0]'.

     Beispiele:

          (%i1) subst (a, x+y, x + (x+y)^2 + y);
                                              2
          (%o1)                      y + x + a
          (%i2) subst (-%i, %i, a + b*%i);
          (%o2)                       a - %i b

     Weitere Beispiele werden mit `example(subst)' angezeigt.

 -- Funktion: substinpart (<x>, <expr>, <n_1>, ..., <n_k>)
     Die Funktion `substinpart' ist vergleichbar mit `substpart'.

     `substinpart' wirkt jedoch auf die interne Darstellung des
     Ausdrucks <expr>.

     Beispiele:

          (%i1) x . 'diff (f(x), x, 2);
                                        2
                                       d
          (%o1)                   x . (--- (f(x)))
                                         2
                                       dx
          (%i2) substinpart (d^2, %, 2);
                                            2
          (%o2)                        x . d
          (%i3) substinpart (f1, f[1](x + 1), 0);
          (%o3)                       f1(x + 1)

 -- Funktion: substpart (<x>, <expr>, <n_1>, ..., <n_k>)
     Substituiert <x> für den Teilausdruck, der mit den restlichen
     Argumenten der Funktion `substpart' ausgewählt wird.  Es wird der
     neue Ausdruck <expr> zurückgegeben.  <x> kann auch der Name eines
     Operators sein, der für einen Operator im Ausdruck <expr>
     substituiert wird.  Zum Beispiel hat `substpart("+", a*b, 0)' das
     Ergebnis `b + a').

     Mit dem Wert `true' für die Optionsvariable `inflag',  verhält
     sich die Funktion `substpart' wie `substinpart'.

     Beispiele:

          (%i1) 1/(x^2 + 2);
                                         1
          (%o1)                        ------
                                        2
                                       x  + 2
          (%i2) substpart (3/2, %, 2, 1, 2);
                                         1
          (%o2)                       --------
                                       3/2
                                      x    + 2
          (%i3) a*x + f(b, y);
          (%o3)                     a x + f(b, y)
          (%i4) substpart ("+", %, 1, 0);
          (%o4)                    x + f(b, y) + a

 -- Funktion: symbolp (<expr>)
     Gibt `true' zurück, wenn <expr> ein Symbol ist, ansonsten `false'.
     Das Kommando `symbolp(x)' ist äquivalent zu `atom(x) and not
     numberp(x)'.

     Siehe auch Bezeichner.


 -- Funktion: unorder ()
     Löscht die Ordnung, die mit dem letzten Aufruf der Funktionen
     `ordergreat' oder `orderless' erzeugt wurde.

     Siehe auch `ordergreat'  und `orderless'.

     Beispiele:

          (%i1) unorder();
          (%o1)                          []
          (%i2) b*x + a^2;
                                             2
          (%o2)                       b x + a
          (%i3) ordergreat (a);
          (%o3)                         done
          (%i4) b*x + a^2;
           %th(1) - %th(3);
                                       2
          (%o4)                       a  + b x
          (%i5) unorder();
                                        2    2
          (%o5)                        a  - a

 -- Funktion: verbify (<f>)
     Gibt das Verb des Symbols <f> zurück.  Siehe auch das Kapitel
     Substantive und Verben,  sowie `noun'  und `nounify'.

     Beispiele:

          (%i1) verbify ('foo);
          (%o1)                          foo
          (%i2) :lisp $%
          $FOO
          (%i2) nounify (foo);
          (%o2)                          foo
          (%i3) :lisp $%
          %FOO


File: maxima.info,  Node: Operatoren,  Next: Auswertung,  Prev: Ausdrücke,  Up: Top

7 Operatoren
************

* Menu:

* Einführung in Operatoren::
* Arithmetische Operatoren::
* Relationale Operatoren::
* Logische Operatoren::
* Operatoren für Gleichungen::
* Zuweisungsoperatoren::
* Nutzerdefinierte Operatoren::


File: maxima.info,  Node: Einführung in Operatoren,  Next: Arithmetische Operatoren,  Prev: Operatoren,  Up: Operatoren

7.1 Einführung in Operatoren
============================

Maxima kennt die üblichen arithmetischen, relationalen und logischen
Operatoren der Mathematik.  Weiterhin kennt Maxima Operatoren für die
Zuweisung von Werten an Variablen und die Definition von Funktionen.
Die folgende Tabelle zeigt die in diesem Kapitel beschriebenen
Operatoren.  Angegeben sind der Name des Operators, der linksseitige
Vorrang `lbp' und der rechtsseitige Vorrang `rbp', der Typ des
Operators und ein Beispiel einschließlich der internen Darstellung, wie
sie vom Parser von der Eingabe gelesen wird.


Operator  lbp rbp  Typ     Beispiel

   +      100 134  nary     a+b      ((mplus) $A $B)
   -      100 134  prefix   -a       ((mminus) $A)
   *      120      nary     a*b      ((mtimes) $A $B)
   /      120 120  infix    a/b      ((mquotient) $A $B)
   ^      140 139  infix    a^b      ((mexpt) $A $B)
   **     140 139  infix    a**b     ((mexpt) $A $B)
   ^^     140 139  infix    a^^b     ((mncexpt) $A $B)
   .      130 129  infix    a.b      ((mnctimes) $A $B)

   <       80  80  infix    a<b      ((mlessp) $A $B)
   <=      80  80  infix    a<=b     ((mleqp) $A $B)
   >       80  80  infix    a>b      ((mqreaterp) $A $B)
   >=      80  80  infix    a>=b     ((mgeqp) $A $B)

   not         70  prefix   not a    ((mnot) $A)
   and     65      nary     a and b  ((mand) $A $B)
   or      60      nary     a or b   ((mor) $A $B)

   #       80  80  infix    a#b      ((mnotequal) $A $B)
   =       80  80  infix    a=b      ((mequal) $A $B)

   :      180  20  infix    a:b      ((msetq) $A $B)
   ::     180  20  infix    a::b     ((mset) $A $B)
   :=     180  20  infix    a:=b     ((mdefine) $A $B)
   ::=    180  20  infix    a::=b    ((mdefmacro) $A $B)

Mit dem Vorrang der Operatoren werden die bekannten Rechenregeln der
einzelnen Operatoren definiert.  So wird zum Beispiel ` a + b * c ' vom
Parser als ` a + (b * c) ' interpretiert, da der linksseitige Vorrang
der Multiplikation größer als der linksseitige Vorrang der Addition ist.

Maxima unterscheidet die folgenden Operatoren:

_Prefix_
     Prefix-Operatoren sind unäre Operatoren, die einen Operanden
     haben, der dem Operator nachfolgt.  Beispiele sind die Operatoren
     `-'  und `not'.

_Postfix_
     Postfix-Operatoren sind unäre Operatoren, die einen Operanden
     haben, der dem Operator vorangestellt ist.  Ein Beispiel ist der
     Operator `!'  für die Fakultät.

_Infix_
     Infix-Operatoren, sind binäre Operatoren, die zwei Operanden
     haben.  Der Operator steht zwischen diesen Operanden.  Hierzu
     zählen zum Beispiel der Operator für die Exponentiation `^'  oder
     der Operator für die Zuweisung `:'.

_N-ary_
     N-ary-Operatoren fassen eine beliebige Anzahl an Operanden zu
     einem Ausdruck zusammen.  Hierzu zählen die Multiplikation `*'
     oder die Addition `+'.

_Matchfix_
     Matchfix-Operatoren sind Begrenzungszeichen, die eine beliebige
     Anzahl an Operanden einschließen.  Ein Beispiel sind die
     Operatoren `['  und `]' , die eine Liste `[a, b, ...]' definieren.

_Nofix_
     Ein Nofix-Operator ist ein Operator, der keinen Operanden hat.
     Maxima kennt keinen internen Nofix-Operator.  Zum Beispiel kann
     mit `nofix(quit)' ein Nofix-Operator definiert werden.  Dann ist
     es möglich, Maxima allein mit `quit' anstatt dem Funktionsaufruf
     `quit()' zu beenden.

Maxima unterscheidet das Symbol eines Operators, wie zum Beispiel `+'
für die Addition, von dem Namen eines Operators, der eine Zeichenkette
ist.  Der Additionsoperator hat den Namen `"+"'.  Mit dem Namen des
Operators kann der Operator als eine Funktion eingegeben werden.  Im
folgenden wird ein Beispiel für den binären Infix-Operator der
Exponentiation gezeigt:

     (%i1) a^b;
                                     b
     (%o1)                          a
     (%i2) "^"(a,b);
                                     b
     (%o2)                          a

Der Name des Operators kann immer dann verwendet werden, wenn eine
Funktion als Argument benötigt wird.  Beispiele sind die Funktionen
`map',  `apply'  oder auch die Substitution mit `subst'.

     (%i3) apply("+", [a,b,c]);
     (%o3)                       c + b + a
     (%i4) map("^", [a,b,c],[1,2,3]);
                                     2   3
     (%o4)                      [a, b , c ]
     (%i5) subst("*"="+", 10*a*b*c);
     (%o5)                    c + b + a + 10

In *note Nutzerdefinierte Operatoren:: wird beschrieben, wie interne
Maxima-Operatoren umdefiniert oder neue Operatoren definiert werden.

Die obige Tabelle enthält nicht alle von Maxima definierten Operatoren.
Weitere Operatoren sind zum Beispiel `!' für die Fakultät, die
Operatoren `for', `do', `while', um eine Programmschleife zu
programmieren, oder `if', `then', `else', um eine Bedingung zu
definieren.


File: maxima.info,  Node: Arithmetische Operatoren,  Next: Relationale Operatoren,  Prev: Einführung in Operatoren,  Up: Operatoren

7.2 Arithmetische Operatoren
============================

 -- Operator: +
 -- Operator: -
 -- Operator: *
 -- Operator: /
 -- Operator: ^
     Sind die Operatoren der Addition, Multiplikation, Division und
     Exponentiation.  Wird der Name eines Operators in einem Ausdruck
     benötigt, können die Bezeichnungen `"+"', `"*"', `"/"' und `"^"'
     verwendet werden.

     In Ausdrücken wie `(+a)*(-a)' oder `exp(-a)' repräsentieren die
     Operatoren `+' und `-' die unäre Addition und Negation.  Die Namen
     der Operatoren sind `"+"' und `"-"'.

     Die Subtraktion `a - b' wird von Maxima intern als Addition `a +
     (- b)' dargestellt.  In der Ausgabe wird der Ausdruck `a + (- b)'
     als Subtraktion `a - b' angezeigt.

     Die Division `a / b' wird von Maxima intern als Multiplikation `a
     * b^(- 1)' dargestellt.  In der Ausgabe wird der Ausdruck `a *
     b^(- 1)' als Division `a / b' angezeigt.  Der Name des Operators
     für die Division ist `"/"'.

     Die Operatoren der Addition und Multiplikation sind kommutative
     N-ary-Operatoren.  Die Operatoren der  Division und Exponentiation
     sind nicht-kommutative binäre Operatoren.

     Maxima sortiert die Operanden eines kommutativen Operators und
     konstruiert eine kanonische Darstellung.  Maxima unterscheidet die
     interne Sortierung von der externen Sortierung für die Anzeige.
     Die interne Sortierung wird von der Aussagefunktion `orderlessp'
     bestimmt.  Die externe Sortierung für die Anzeige wird von der
     Aussagefunktion `ordergreatp'  festgelegt.  Ausnahme ist die
     Multiplikation.  Für diese sind die interne und die externe
     Sortierung identisch.

     Arithmetische Rechnungen mit Zahlen (ganzen Zahlen, rationale
     Zahlen, Gleitkommazahlen und großen Gleitkommazahlen) werden als
     eine Vereinfachung und nicht als Auswertung  ausgeführt.  Mit
     Ausnahme der Exponentiation werden alle arithmetischen Operationen
     mit Zahlen zu Zahlen vereinfacht.  Exponentiationen von Zahlen wie
     zum Beispiel `(1/3)^(1/2)' werden nicht notwendigerweise zu Zahlen
     vereinfacht.  In diesem Beispiel ist das Ergebnis der
     Vereinfachung `1/sqrt(3)'.

     Bei einer arithmetischen Rechnung kann es zur Umwandlung in
     Gleitkommazahlen kommen.  Ist eines der Argumente eine große
     Gleitkommazahl, so ist auch das Ergebnis eine große
     Gleitkommazahl.  Entsprechend ist das Ergebnis eine einfache
     Gleitkommazahl, sofern mindestens einer der Operanden eine einfache
     Gleitkommazahl ist.  Treten nur ganze oder rationale Zahlen auf,
     ist das Ergebnis wieder eine ganze oder rationale Zahl.

     Da arithmetische Rechnungen Vereinfachungen und keine Auswertungen
     sind, werden arithmetische Rechnungen auch dann ausgeführt, wenn
     die Auswertung des Ausdrucks zum Beispiel mit dem `Quote-Operator'
     `'' unterdrückt ist.

     Arithmetische Operatoren werden elementweise auf Listen
     angewendet, wenn die Optionsvariable `listarith'  den Wert `true'
     hat.  Auf Matrizen werden die arithmetischen Operatoren immer
     elementweise angewendet.  Ist einer der Operanden eine Liste oder
     Matrix und der andere Operand hat einen anderen Typ, dann wird
     dieses Argument mit jedem Element der Liste oder Matrix kombiniert.

     Beispiele:

     Addition und Multiplikation sind kommutative N-ary-Operatoren.
     Maxima sortiert die Operanden und konstruiert eine kanonische
     Darstellung.  Die Namen der Operatoren sind `"+"' und `"*"'.

          (%i1) c + g + d + a + b + e + f;
          (%o1)               g + f + e + d + c + b + a
          (%i2) [op (%), args (%)];
          (%o2)              [+, [g, f, e, d, c, b, a]]
          (%i3) c * g * d * a * b * e * f;
          (%o3)                     a b c d e f g
          (%i4) [op (%), args (%)];
          (%o4)              [*, [a, b, c, d, e, f, g]]
          (%i5) apply ("+", [a, 8, x, 2, 9, x, x, a]);
          (%o5)                    3 x + 2 a + 19
          (%i6) apply ("*", [a, 8, x, 2, 9, x, x, a]);
                                           2  3
          (%o6)                       144 a  x

     Division und Exponentiation sind nicht-kommutative binäre
     Operatoren.  Die Namen der Operatoren sind `"/"' und `"^"'.

          (%i1) [a / b, a ^ b];
                                        a   b
          (%o1)                        [-, a ]
                                        b
          (%i2) [map (op, %), map (args, %)];
          (%o2)              [[/, ^], [[a, b], [a, b]]]
          (%i3) [apply ("/", [a, b]), apply ("^", [a, b])];
                                        a   b
          (%o3)                        [-, a ]
                                        b

     Subtraktion und Division werden intern als Addition und
     Multiplikation dargestellt.

          (%i1) [inpart (a - b, 0), inpart (a - b, 1), inpart (a - b, 2)];
          (%o1)                      [+, a, - b]
          (%i2) [inpart (a / b, 0), inpart (a / b, 1), inpart (a / b, 2)];
                                             1
          (%o2)                       [*, a, -]
                                             b

     Sind die Operanden Zahlen, werden die Rechnungen ausgeführt.  Ist
     einer der Operanden eine Gleitkommazahl, ist das Ergebnis
     ebenfalls eine Gleitkommazahl.

          (%i1) 17 + b - (1/2)*29 + 11^(2/4);
                                                 5
          (%o1)                   b + sqrt(11) + -
                                                 2
          (%i2) [17 + 29, 17 + 29.0, 17 + 29b0];
          (%o2)                   [46, 46.0, 4.6b1]

     Arithmetische Rechnungen sind Vereinfachungen und keine Auswertung.

          (%i1) simp : false;
          (%o1)                         false
          (%i2) '(17 + 29*11/7 - 5^3);
                                        29 11    3
          (%o2)                    17 + ----- - 5
                                          7
          (%i3) simp : true;
          (%o3)                         true
          (%i4) '(17 + 29*11/7 - 5^3);
                                          437
          (%o4)                         - ---
                                           7

     Arithmetische Rechnungen werden elementweise für Listen und
     Matrizen ausgeführt.  Bei Listen wird dies mit der Optionsvariablen
     `listarith'  kontrolliert.

          (%i1) matrix ([a, x], [h, u]) - matrix ([1, 2], [3, 4]);
                                  [ a - 1  x - 2 ]
          (%o1)                   [              ]
                                  [ h - 3  u - 4 ]
          (%i2) 5 * matrix ([a, x], [h, u]);
                                    [ 5 a  5 x ]
          (%o2)                     [          ]
                                    [ 5 h  5 u ]
          (%i3) listarith : false;
          (%o3)                         false
          (%i4) [a, c, m, t] / [1, 7, 2, 9];
                                    [a, c, m, t]
          (%o4)                     ------------
                                    [1, 7, 2, 9]
          (%i5) [a, c, m, t] ^ x;
                                                x
          (%o5)                     [a, c, m, t]
          (%i6) listarith : true;
          (%o6)                         true
          (%i7) [a, c, m, t] / [1, 7, 2, 9];
                                        c  m  t
          (%o7)                     [a, -, -, -]
                                        7  2  9
          (%i8) [a, c, m, t] ^ x;
                                    x   x   x   x
          (%o8)                   [a , c , m , t ]

 -- Operator: **
     Ist eine alternative Schreibweise für den Operator `^' der
     Exponentiation.  In der Ausgabe wird entweder `^' angezeigt oder
     der Exponent hochgestellt.  Siehe den Operator der Exponentiation
     `^'.

     Die Funktion `fortran'  zeigt den Operator der Exponentiation
     immer als `**' an, unabhängig davon, ob `**' oder `^' eingegeben
     wird.

     Beispiele:

          (%i1) is (a**b = a^b);
          (%o1)                         true
          (%i2) x**y + x^z;
                                        z    y
          (%o2)                        x  + x
          (%i3) string (x**y + x^z);
          (%o3)                        x^z+x^y
          (%i4) fortran (x**y + x^z);
                x**z+x**y
          (%o4)                         done

 -- Operator: ^^
     Ist der Operator der nicht-kommutativen Exponentiation von
     Matrizen.  In der linearen Ausgabe wird der nicht-kommutative
     Operator als `^^' angezeigt.  In der zweidimensionalen Ausgabe
     wird der hochgestellte Exponent von spitzen Klammern `< >'
     eingeschlossen.

     Beispiele:

          (%i1) a . a . b . b . b + a * a * a * b * b;
                                  3  2    <2>    <3>
          (%o1)                  a  b  + a    . b
          (%i2) string (a . a . b . b . b + a * a * a * b * b);
          (%o2)                  a^3*b^2+a^^2 . b^^3

 -- Operator: .
     Ist der Operator der nicht-kommutativen Multiplikation von
     Matrizen.  Siehe für Erläuterungen *note Nicht-kommutative
     Multiplikation::.


File: maxima.info,  Node: Relationale Operatoren,  Next: Logische Operatoren,  Prev: Arithmetische Operatoren,  Up: Operatoren

7.3 Relationale Operatoren
==========================

 -- Operator: <
 -- Operator: <=
 -- Operator: >=
 -- Operator: >
     Die Symbole `<', `<=', `>=' und `>' sind die relationalen
     Operatoren "kleiner als", "kleiner als oder gleich", "größer als
     oder gleich" und "größer als".  Die Namen dieser Operatoren sind
     jeweils: `"<"', `"<="', `">="' und `">"'.  Diese können dort
     eingesetzt werden, wo der Name des Operators benötigt wird.

     Die relationalen Operatoren sind binäre Operatoren.  Ausdrücke wie
     `a < b < c' werden von Maxima nicht erkannt und generieren eine
     Fehlermeldung.

     Relationale Ausdrücke werden von den Funktionen `is'  und `maybe'
     sowie den Funktionen `if',  `while'  und `unless'  zu booleschen
     Werten ausgewertet.  Relationale Ausdrücke werden ansonsten nicht
     zu booleschen Werten ausgewertet oder vereinfacht.  Jedoch werden
     die Operanden eines booleschen Ausdruckes ausgewertet, wenn die
     Auswertung nicht mit dem `Quote-Operator'  `'' unterdrückt ist.

     Wenn ein relationaler Ausdruck mit den Funktionen `is' oder `if'
     nicht zu `true' oder `false' ausgewertet werden kann, wird das
     Verhalten der Funktionen von der Optionsvariablen `prederror'
     kontrolliert.  Hat `prederror' den Wert `true', wird von `is' und
     `if' ein Fehler erzeugt.  Hat `prederror' den Wert `false', hat
     `is' den Rückgabewert `unknown' und `if' gibt einen konditionalen
     Ausdruck zurück, der teilweise ausgewertet ist.

     Die Funktion `maybe' verhält sich immer so, als ob `prederror' den
     Wert `false' hat, und die Schleifenanweisungen `while' sowie
     `unless' verhalten sich immer so, als ob `prederror' den Wert
     `true' hat.

     Relationale Operatoren werden nicht auf die Elemente von Listen
     oder Matrizen sowie auf die beiden Seiten einer Gleichung
     angewendet.

     Siehe auch die Operatoren `='  und `#'  sowie die Funktionen
     `equal'  und `notequal'.

     Beispiele:

     Relationale Ausdrücke werden von einigen Funktionen zu booleschen
     Werten ausgewertet.

          (%i1) [x, y, z] : [123, 456, 789];
          (%o1)                    [123, 456, 789]
          (%i2) is (x < y);
          (%o2)                         true
          (%i3) maybe (y > z);
          (%o3)                         false
          (%i4) if x >= z then 1 else 0;
          (%o4)                           0
          (%i5) block ([S], S : 0, for i:1 while i <= 100 do S : S + i,
                       return (S));
          (%o5)                         5050

     Relationale Ausdrücke werden ansonsten nicht zu booleschen Werten
     ausgewertet oder vereinfacht, jedoch werden die Operanden eines
     relationalen Ausdruckes ausgewertet.

          (%i1) [x, y, z] : [123, 456, 789];
          (%o1)                    [123, 456, 789]
          (%i2) [x < y, y <= z, z >= y, y > z];
          (%o2)    [123 < 456, 456 <= 789, 789 >= 456, 456 > 789]
          (%i3) map (is, %);
          (%o3)               [true, true, true, false]


File: maxima.info,  Node: Logische Operatoren,  Next: Operatoren für Gleichungen,  Prev: Relationale Operatoren,  Up: Operatoren

7.4 Logische Operatoren
=======================

 -- Operator: and
     Ist der logische Operator der Konjunktion.  `and' ist ein
     N-ary-Operator.  Die Operanden sind boolesche Ausdrücke und das
     Ergebnis ist ein boolescher Wert.

     Der Operator `and' erzwingt die Auswertung aller oder einen Teil
     der Operanden.  Die Operanden werden in der Reihenfolge
     ausgewertet, in der sie auftreten.  `and' wertet nur so viele
     Operanden aus, wie nötig sind, um das Ergebnis des Ausdrucks zu
     bestimmen.  Hat irgendein Argument den Wert `false', ist das
     Ergebnis `false' und die weiteren Argumente werden nicht
     ausgewertet.

     Die Optionsvariable `prederror'  kontrolliert das Verhalten von
     `and' für den Fall, dass ein Operand nicht zu `true' oder `false'
     ausgewertet werden kann.  `and' gibt eine Fehlermeldung aus, wenn
     `prederror' den Wert `true' hat.  Andernfalls werden Operanden
     akzeptiert, die nicht zu `true' oder `false' ausgewertet werden
     können und das Ergebnis ist ein boolescher Ausdruck.

     `and' ist nicht kommutativ, da aufgrund von nicht ausgewerteten
     Operanden die Ausdrücke `a and b' und `b and a' ein
     unterschiedliches Ergebnis haben können.

     Beispiele:

          (%i1) n:2;
          (%o1)                           2
          (%i2) integerp(n) and evenp(n);
          (%o2)                         true
          (%i3) not(a=b) and 1=1 and integerp(2);
          (%o3)                         true
          (%i4) not(a=b) and 1=1 and oddp(2);
          (%o4)                         false
          (%i5) a and b;
          (%o5)                        a and b
          (%i6) prederror:true$
          (%i7) a and b;

          Unable to evaluate predicate a
           -- an error. To debug this try: debugmode(true);

     Da `and' nur so viele Operanden auswertet wie notwendig sind, um
     das Ergebnis festzustellen, führt der syntaktische Fehler im
     zweiten Operanden nicht zu einer Fehlermeldung, das das Ergebnis
     bereits mit dem ersten Operanden feststeht.

          (%i8) a=b and sin(2,2);
          (%o8)                         false

 -- Operator: or
     Ist der logische Operator der Disjunktion.  `or' ist ein
     N-ary-Operator.  Die Operanden sind boolesche Ausdrücke und das
     Ergebnis ist ein boolescher Wert.

     Der Operator `or' erzwingt die Auswertung aller oder einen Teil der
     Operanden.  Die Operanden werden in der Reihenfolge ausgewertet,
     in der sie auftreten.  `or' wertet nur so viele Operanden aus wie
     nötig sind, um das Ergebnis des Ausdrucks zu bestimmen.  Hat
     irgendein Operand den Wert `true', ist das Ergebnis `true' und die
     weiteren Operanden werden nicht ausgewertet.

     Die Optionsvariable `prederror'  kontrolliert das Verhalten von
     `or' für den Fall, dass ein Operand nicht zu `true' oder `false'
     ausgewertet werden kann.  `or' gibt eine Fehlermeldung, wenn
     `prederror' den Wert `true' hat.  Andernfalls werden Operanden
     akzeptiert, die nicht zu `true' oder `false' ausgewertet werden
     können und das Ergebnis ist ein boolescher Ausdruck.

     `or' ist nicht kommutativ, da aufgrund von nicht ausgewerteten
     Operanden die Ausdrücke `a or b' und `b or a' ein
     unterschiedliches Ergebnis haben können.

     Beispiele:

          (%i1) n:2;
          (%o1)                           2
          (%i2) oddp(n) or evenp(n);
          (%o2)                         true
          (%i3) a=b or not(1=1) or integerp(2);
          (%o3)                         true
          (%i4) a or b;
          (%o4)                        a or b
          (%i5) prederror:true$
          (%i6) a or b;

          Unable to evaluate predicate a
           -- an error. To debug this try: debugmode(true);

     Da `or' nur so viele Operanden auswertet wie notwendig sind, um das
     Ergebnis festzustellen, führt der syntaktische Fehler im zweiten
     Operanden nicht zu einer Fehlermeldung, da das Ergebnis bereits
     mit dem ersten Operanden feststeht.

          (%i7) integerp(2) or sin(2,2);
          (%o7)                         true

 -- Operator: not
     Ist die logische Negation.  `not' ist ein Prefix-Operator.  Der
     Operand ist ein boolescher Ausdruck und das Ergebnis ein
     boolescher Wert.

     Der Operator `not' erzwingt die Auswertung des Operanden.  Die
     Optionsvariable `prederror'  kontrolliert das Verhalten von `not'
     für den Fall, dass der Operand nicht zu `true' oder `false'
     ausgewertet werden kann.  `not' gibt eine Fehlermeldung, wenn
     `prederror' den Wert `true' hat.  Andernfalls wird ein Operand
     akzeptiert, der nicht zu `true' oder `false' ausgewertet werden
     kann, und das Ergebnis ist ein boolescher Ausdruck.

     Beispiele:

          (%i1) not integerp(2);
          (%o1)                         false
          (%i2) not (a=b);
          (%o2)                         true
          (%i3) not a;
          (%o3)                         not a
          (%i4) prederror:true$
          (%i5) not a;

          Unable to evaluate predicate a
           -- an error. To debug this try: debugmode(true);


File: maxima.info,  Node: Operatoren für Gleichungen,  Next: Zuweisungsoperatoren,  Prev: Logische Operatoren,  Up: Operatoren

7.5 Operatoren für Gleichungen
==============================

 -- Operator: #
     Ist der Operator für eine Ungleichung.  `#' ist ein Infix-Operator
     mit zwei Operanden.

     Mit dem Operator `#' wird eine Ungleichung `a # b' formuliert,
     wobei die Operanden `a' und `b' jeweils die linke und die rechte
     Seite der Ungleichung sind und beliebige Ausdrücke sein können.
     Die Operanden werden ausgewertet, nicht jedoch die Ungleichung
     selbst.

     Die Funktionen `is',  `maybe',  die logischen Operatoren `and',
     `or'  und `not'  sowie die Funktionen für die Definition von
     Programmanweisungen wie `if',  `while'  oder `unless'  erzwingen
     die Auswertung einer Ungleichung.

     Wegen der Regeln für die Auswertung von Aussagen und weil `not
     expr' die Auswertung des Argumentes `expr' bewirkt, ist der
     Ausdruck `not (a = b)' äquivalent zu `is(a # b)' und nicht zu `a #
     b'.

     Die Funktionen `rhs'  und `lhs'  geben die rechte und die linke
     Seite einer Gleichung oder Ungleichung zurück.

     Siehe auch den Operator `=',  um eine Gleichung zu formulieren,
     sowie die Funktionen `equal'  und `notequal'.

     Beispiele:

          (%i1) a = b;
          (%o1)                         a = b
          (%i2) is (a = b);
          (%o2)                         false
          (%i3) a # b;
          (%o3)                         a # b
          (%i4) not (a = b);
          (%o4)                         true
          (%i5) is (a # b);
          (%o5)                         true
          (%i6) is (not (a = b));
          (%o6)                         true

 -- Operator: =
     Ist der Operator für eine Gleichung.  `=' ist ein Infix-Operator
     mit zwei Operanden.

     Mit dem Operator `=' wird eine Gleichung `a = b' formuliert, wobei
     die Operanden `a' und `b' jeweils die linke und die rechte Seite
     der Gleichung sind und beliebige Ausdrücke sein können.  Die
     Operanden werden ausgewertet, nicht jedoch die Gleichung selbst.
     Nicht ausgewertete Gleichungen können als Argument von Funktionen
     wie zum Beispiel den Funktionen `solve',  `algsys'  oder `ev'
     auftreten.

     Die Funktion `is'  wertet eine Gleichung `=' zu einem booleschen
     Wert aus.  `is(a = b)' wertet die Gleichung `a = b' zum Wert `true'
     aus, wenn `a' und `b' identische Ausdrücke sind.  Das trifft zu,
     wenn `a' und `b' identische Atome sind oder wenn ihre Operatoren
     sowie die Operanden identisch sind.  In jedem anderen Fall ist das
     Ergebnis `false'.  Das Ergebnis der Auswertung ist nie `unkown'.
     Hat `is(a = b)' das Ergebnis `true', werden `a' und `b' als
     syntaktisch gleich bezeichnet.  Im Unterschied dazu gilt für
     äquivalente Ausdrücke, dass `is(equal(a, b))' den Wert `true' hat.
     Ausdrücke können äquivalent aber syntaktisch verschieden sein.

     Eine Ungleichung wird mit dem Operator `#'  formuliert.  Wie für
     den Operator `=' für eine Gleichung wird eine Ungleichung `a # b'
     nicht ausgewertet.  Eine Auswertung erfolgt mit `is(a # b)',
     welche die Werte `true' oder `false' als Ergebnis hat.

     Neben `is' werten auch die Operatoren `if',  `and',

     `or'  und `not'  Gleichungen mit dem Operator `=' oder
     Ungleichungen mit dem Operator `#' zu den Werten `true' oder
     `false' aus.

     Wegen der Regeln für die Auswertung von Aussagen und weil im
     Ausdruck `not expr' der Operand `expr' ausgewertet wird, ist `not
     a = b' äquivalent zu `is(a # b)' und nicht zu `a # b'.

     Die Funktionen `rhs'  und `lhs'  geben die rechte und die linke
     Seite einer Gleichung oder Ungleichung zurück.

     Siehe auch den Operator `#'  für Ungleichungen sowie die Funktionen
     `equal'  und `notequal'.

     Beispiele:

     Ein Ausdruck `a = b' repräsentiert eine nicht ausgewertete
     Gleichung.

          (%i1) eq_1 : a * x - 5 * y = 17;
          (%o1)                    a x - 5 y = 17
          (%i2) eq_2 : b * x + 3 * y = 29;
          (%o2)                    3 y + b x = 29
          (%i3) solve ([eq_1, eq_2], [x, y]);
                                  196         29 a - 17 b
          (%o3)          [[x = ---------, y = -----------]]
                               5 b + 3 a       5 b + 3 a
          (%i4) subst (%, [eq_1, eq_2]);
                   196 a     5 (29 a - 17 b)
          (%o4) [--------- - --------------- = 17,
                 5 b + 3 a      5 b + 3 a
                                            196 b     3 (29 a - 17 b)
                                          --------- + --------------- = 29]
                                          5 b + 3 a      5 b + 3 a
          (%i5) ratsimp (%);
          (%o5)                  [17 = 17, 29 = 29]

     `is(a = b)' wertet die Gleichung `a = b' zu `true' aus, wenn `a'
     und `b' syntaktisch gleich sind.  Ausdrücke können äquivalent
     sein, ohne syntaktisch gleich zu sein.

          (%i1) a : (x + 1) * (x - 1);
          (%o1)                    (x - 1) (x + 1)
          (%i2) b : x^2 - 1;
                                        2
          (%o2)                        x  - 1
          (%i3) [is (a = b), is (a # b)];
          (%o3)                     [false, true]
          (%i4) [is (equal (a, b)), is (notequal (a, b))];
          (%o4)                     [true, false]

     Einige Operatoren werten `=' und `#' zu `true' oder `false' aus.

          (%i1) if expand ((x + y)^2) = x^2 + 2 * x * y + y^2 then FOO else
                BAR;
          (%o1)                          FOO
          (%i2) eq_3 : 2 * x = 3 * x;
          (%o2)                       2 x = 3 x
          (%i3) eq_4 : exp (2) = %e^2;
                                        2     2
          (%o3)                       %e  = %e
          (%i4) [eq_3 and eq_4, eq_3 or eq_4, not eq_3];
          (%o4)                  [false, true, true]

     Da `not expr' die Auswertung des Ausdrucks `expr' bewirkt, ist
     `not (a = b)' äquivalent zu `is(a # b)'.

          (%i1) [2 * x # 3 * x, not (2 * x = 3 * x)];
          (%o1)                   [2 x # 3 x, true]
          (%i2) is (2 * x # 3 * x);
          (%o2)                         true


File: maxima.info,  Node: Zuweisungsoperatoren,  Next: Nutzerdefinierte Operatoren,  Prev: Operatoren für Gleichungen,  Up: Operatoren

7.6 Zuweisungsoperatoren
========================

 -- Operator: :
     Ist der Operator für die Zuweisung eines Wertes an eine Variable.

     Ist die linke Seite eine Variable (ohne Index), wertet der
     Operator `:' die rechte Seite aus und weist den Wert der Variablen
     auf der linken Seite zu.

     Ist die linke Seite ein Element einer Liste, Matrix oder ein
     deklariertes Maxima- oder Lisp-Array, wird die rechte Seite diesem
     Element zugewiesen.  Der Index muss ein existierendes Element
     bezeichnen.

     Ist die linke Seite ein Element eines nicht deklarierten Arrays,
     dann wird die rechte Seite diesem Element zugewiesen, falls dieses
     existiert.  Existiert das Element noch nicht, wird ein neues
     Element erzeugt.

     Ist die linke Seite eine Liste mit Variablen (ohne Index), muss
     die rechte Seite zu einer Liste auswerten.  Die Elemente der Liste
     auf der rechten Seite werden den Elementen auf der linken Seite
     parallel zugewiesen.

     Siehe auch `kill'  und `remvalue'  für die Aufhebung der Zuweisung
     eines Wertes an ein Symbol.

     Beispiele:

     Zuweisung an eine einfache Variable.

          (%i1) a;
          (%o1)                           a
          (%i2) a : 123;
          (%o2)                          123
          (%i3) a;
          (%o3)                          123

     Zuweisung an ein Element einer Liste.

          (%i1) b : [1, 2, 3];
          (%o1)                       [1, 2, 3]
          (%i2) b[3] : 456;
          (%o2)                          456
          (%i3) b;
          (%o3)                      [1, 2, 456]

     Die Zuweisung erzeugt ein nicht deklariertes Array.

          (%i1) c[99] : 789;
          (%o1)                          789
          (%i2) c[99];
          (%o2)                          789
          (%i3) c;
          (%o3)                           c
          (%i4) arrayinfo (c);
          (%o4)                   [hashed, 1, [99]]
          (%i5) listarray (c);
          (%o5)                         [789]

     Mehrfache Zuweisung.

          (%i1) [a, b, c] : [45, 67, 89];
          (%o1)                     [45, 67, 89]
          (%i2) a;
          (%o2)                          45
          (%i3) b;
          (%o3)                          67
          (%i4) c;
          (%o4)                          89

     Die mehrfache Zuweisung wird parallel ausgeführt.  Die Werte von
     `a' und `b' werden in diesem Beispiel ausgetauscht.

          (%i1) [a, b] : [33, 55];
          (%o1)                       [33, 55]
          (%i2) [a, b] : [b, a];
          (%o2)                       [55, 33]
          (%i3) a;
          (%o3)                          55
          (%i4) b;
          (%o4)                          33

 -- Operator: ::
     Ist der Operator für die Zuweisung eines Wertes an eine Variable.

     Der Operator `::' ist vergleichbar mit dem Operator `:'  mit dem
     Unterschied, dass `::' sowohl die rechte als auch die linke Seite
     auswertet.

     Beispiele:

          (%i1) x : 'foo;
          (%o1)                          foo
          (%i2) x :: 123;
          (%o2)                          123
          (%i3) foo;
          (%o3)                          123
          (%i4) x : '[a, b, c];
          (%o4)                       [a, b, c]
          (%i5) x :: [11, 22, 33];
          (%o5)                     [11, 22, 33]
          (%i6) a;
          (%o6)                          11
          (%i7) b;
          (%o7)                          22
          (%i8) c;
          (%o8)                          33

 -- Operator: ::=
     Ist der Operator für die Definition von Makro-Funktionen.

     Der Operator `::=' definiert eine Makro-Funktion, das ist eine
     Funktion, die ihre Argumente nicht auswertet.  Der Ausdruck, der
     die Makro-Funktion definiert, wird in dem Kontext ausgewertet, in
     dem das Makro aufgerufen wird.  Ansonsten verhält sich eine
     Makro-Funktion wie eine gewöhnliche Funktion.

     Die Funktion `macroexpand'  expandiert eine Makro-Funktion, ohne
     sie auszuwerten.  `macroexpand(foo(x))' dem `''%' folgt, ist
     äquivalent zu `foo(x)', wenn `foo' eine Makro-Funktion ist.

     Der Operator `::=' fügt den Namen der neuen Makro-Funktion der
     Informationsliste `macros'  hinzu.  Die Funktionen `kill',

     `remove'  und `remfunction'  heben die Zuweisung der
     Makro-Funktion an ein Symbol auf und entfernen die Makro-Funktion
     von der Informationsliste `macros'.

     Die Funktionen `fundef'  oder `dispfun'  geben die Definition einer
     Makro-Funktion zurück oder weisen die Makro-Funktion einer Marke
     zu.

     Makro-Funktionen enthalten häufig Ausdrücke mit den Funktionen
     `buildq'  und `splice'.    Mit diesen werden Ausdrücke konstruiert,
     die dann ausgewertet werden.

     Beispiele:

     Eine Makro-Funktion wertet ihre Argumente nicht aus.  Daher zeigt
     Beispiel (1) `y - z' und nicht den Wert von `y - z'.  Das Makro
     wird in dem Kontext ausgewertet, in dem das Makro aufgerufen wird.
     Dies zeigt (2).

          (%i1) x: %pi$

          (%i2) y: 1234$

          (%i3) z: 1729 * w$

          (%i4) printq1 (x) ::= block (print ("(1) x is equal to", x),
                '(print ("(2) x is equal to", x)))$

          (%i5) printq1 (y - z);
          (1) x is equal to y - z
          (2) x is equal to %pi
          (%o5)                                 %pi

     Eine gewöhnliche Funktion wertet ihre Argumente aus.  Daher zeigt
     (1) den Wert von `y - z'.  Der Rückgabewert wird nicht ausgewertet
     und gibt (2).  Mit `''%' wird die Auswertung erzwungen.

          (%i1) x: %pi$

          (%i2) y: 1234$

          (%i3) z: 1729 * w$

          (%i4) printe1 (x) := block (print ("(1) x is equal to", x),
                '(print ("(2) x is equal to", x)))$

          (%i5) printe1 (y - z);
          (1) x is equal to 1234 - 1729 w
          (%o5)                     print((2) x is equal to, x)
          (%i6) ''%;
          (2) x is equal to %pi
          (%o6)                                 %pi

     `macroexpand'  gibt die Expansion des Makros zurück.
     `macroexpand(foo(x))' dem `''%' folgt, ist äquivalent zu `foo(x)',
     wenn `foo' eine Makro-Funktion ist.

          (%i1) x: %pi$

          (%i2) y: 1234$

          (%i3) z: 1729 * w$

          (%i4) g (x) ::= buildq ([x], print ("x is equal to", x))$

          (%i5) macroexpand (g (y - z));
          (%o5)                     print(x is equal to, y - z)
          (%i6) ''%;
          x is equal to 1234 - 1729 w
          (%o6)                            1234 - 1729 w
          (%i7) g (y - z);
          x is equal to 1234 - 1729 w
          (%o7)                            1234 - 1729 w

 -- Operator: :=
     Ist der Operator für Funktionsdefinitionen.

     `<f>(<x_1>, ..., <x_n>)' := <expr> definiert eine Funktion mit dem
     Namen <f>, den Argumenten <x_1>, ..., <x_n> und der
     Funktionsdefinition <expr>.  Der Operator `:=' wertet die
     Funktionsdefinition nicht aus.  Die Auswertung kann mit dem
     Quote-Quote-Operator  `''' erzwungen werden.  Die definierte
     Funktion kann eine gewöhnliche Maxima-Funktion `f(x)' sein oder
     eine Array-Funktion `f[i](x)'.

     Ist das letzte oder das einzige Argument der Funktion <x_n> eine
     Liste mit einem Element, dann akzeptiert die mit `:=' definierte
     Funktion eine variable Anzahl an Argumenten.  Die Argumente werden
     zunächst nacheinander den Argumenten <x_1>, ..., <x_(n - 1)>
     zugewiesen.  Sind weitere Argumente vorhanden, werden diese <x_n>
     als Liste zugewiesen.

     Funktionsdefinitionen erscheinen im globalen Namensraum.  Wird
     eine Funktion `f' innerhalb einer Funktion `g' definiert, wird die
     Reichweite der Funktion nicht automatisch auf `g' beschränkt.
     Dagegen führt `local(f)' zu einer Definition, die nur innerhalb
     eines Blockes oder einem anderen zusammengesetzten Ausdrück
     erscheint.  Siehe auch `local'.

     Ist eines der Argumente ein Symbol auf das der Quote-Operator

     `'' angewendet wurde, wird dieses Argument nicht ausgewertet.
     Ansonsten werden alle Argumente ausgewertet.

     Siehe auch `define'  und `::='.

     Beispiele:

     `:=' wertet die Funktionsdefinition nie aus, außer wenn der
     Quote-Quote-Operator angewendet wird.

          (%i1) expr : cos(y) - sin(x);
          (%o1)                    cos(y) - sin(x)
          (%i2) F1 (x, y) := expr;
          (%o2)                   F1(x, y) := expr
          (%i3) F1 (a, b);
          (%o3)                    cos(y) - sin(x)
          (%i4) F2 (x, y) := ''expr;
          (%o4)              F2(x, y) := cos(y) - sin(x)
          (%i5) F2 (a, b);
          (%o5)                    cos(b) - sin(a)

     Mit dem Operator `:=' definierte Funktionen können eine gewöhnliche
     Maxima-Funktion oder eine Array-Funktion sein.

          (%i1) G1 (x, y) := x.y - y.x;
          (%o1)               G1(x, y) := x . y - y . x
          (%i2) G2 [x, y] := x.y - y.x;
          (%o2)                G2     := x . y - y . x
                                 x, y

     Ist das letzte oder einzige Argument <x_n> eine Liste mit einem
     Element, dann akzeptiert die Funktion eine variable Anzahl an
     Argumenten.

          (%i1) H ([L]) := apply ("+", L);
          (%o1)                H([L]) := apply("+", L)
          (%i2) H (a, b, c);
          (%o2)                       c + b + a

     `local'  erzeugt eine lokale Funktionsdefinition.

          (%i1) foo (x) := 1 - x;
          (%o1)                    foo(x) := 1 - x
          (%i2) foo (100);
          (%o2)                         - 99
          (%i3) block (local (foo), foo (x) := 2 * x, foo (100));
          (%o3)                          200
          (%i4) foo (100);
          (%o4)                         - 99



Local Variables:
coding: iso-8859-1
End:
