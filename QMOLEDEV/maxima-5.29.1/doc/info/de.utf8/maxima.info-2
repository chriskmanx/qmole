This is maxima.info, produced by makeinfo version 4.13 from
/home/robert/maxima/maxima-git/maxima-code/doc/info/de.utf8//include-maxima.de.texi.

Das ist ein Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Ein Computer Algebra System.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Nutzerdefinierte Operatoren,  Prev: Zuweisungsoperatoren,  Up: Operatoren

7.7 Nutzerdefinierte Operatoren
===============================

* Menu:

* Einführung in nutzerdefinierte Operatoren::
* Funktionen und Variablen für nutzerdefinierte Operatoren::


File: maxima.info,  Node: Einführung in nutzerdefinierte Operatoren,  Next: Funktionen und Variablen für nutzerdefinierte Operatoren,  Prev: Nutzerdefinierte Operatoren,  Up: Nutzerdefinierte Operatoren

7.7.1 Einführung in nutzerdefinierte Operatoren
-----------------------------------------------

Es ist möglich neue Operatoren zu definieren, vorhandene Operatoren zu
entfernen oder deren Eigenschaften zu ändern.  Jede Funktion kann als
ein Operator definiert werden, die Funktion kann, muss aber nicht
definiert sein.

Im Folgenden werden die Operatoren `dd' und `"<-"' definiert.  Nach der
Definition als Operatoren ist `dd a' gleichbedeutend mit `"dd"(a)' und
`a <- b' entspricht dem Funktionsaufruf `"<-"(a,b)'.  In diesem
Beispiel sind die Funktionen `"dd"' und `"<-"' nicht definiert.

     (%i1) prefix ("dd");
     (%o1)                          dd
     (%i2) dd a;
     (%o2)                         dd a
     (%i3) "dd" (a);
     (%o3)                         dd a
     (%i4) infix ("<-");
     (%o4)                          <-
     (%i5) a <- dd b;
     (%o5)                      a <- dd b
     (%i6) "<-" (a, "dd" (b));
     (%o6)                      a <- dd b

Maxima kennt die folgenden Funktionen, um Operatoren zu definieren:
`prefix', `postfix', `infix', `nary', `matchfix' und `nofix'.

Der Vorrang eines Operators <op> vor anderen Operatoren leitet sich aus
dem links- und rechtsseitigen Vorrang des Operators ab.  Sind die
links- und rechtsseitigen Vorränge von <op> beide größer als der links-
und rechtsseitige Vorrang eines anderen Operators, dann hat <op>
Vorrang vor diesem Operator.  Sind die Vorränge nicht beide größer oder
kleiner, werden weitere Regeln zur Bestimmung des Vorrangs herangezogen.

Maxima kennt die Wortart eines Operanden und des Ergebnisses eines
Operanden.  Wortart bedeutet hier, den Typ eines Operanden.  Maxima
kennt die drei Typen `expr', `clause' und `any'.  Diese stehen für einen
algebraischen Ausdruck, einen logischen Ausdruck und einen beliebigen
Ausdruck.  Mit Hilfe der für einen Operator definierten Wortart kann
der Parser beim Einlesen eines Ausdrucks Syntaxfehler feststellen.

Die Assoziativität eines Operators <op> hängt ab von seinem Vorrang.
Ein größerer linksseitiger Vorrang hat zur Folge, dass der Operator
<op> vor einem anderen Operator auf seiner linken Seite ausgewertet
wird.  Während ein größerer rechtsseitiger Vorrang zur Folge hat, dass
der Operator vor anderen Operatoren auf der rechten Seite ausgewertet
wird.  Daraus folgt, dass ein größerer linksseitiger Vorrang <lbp>
einen Operator <op> rechts-assoziativ und eine größerer rechtsseitiger
Vorrang <rbp> den Operator links-assoziativ macht.  Sind der links- und
rechtsseitige Vorrang gleich groß, ist der Operator <op>
links-assoziativ.

Mit den Befehlen `remove'  und `kill'  können Operatoreigenschaften von
einem Symbol entfernt werden.  `remove("<a>", op)' entfernt die
Operatoreigenschaften des Symbols <a>.  `kill("<a>")' entfernt alle
Eigenschaften einschließich der Operator-Eigenschaften des Symbols <a>.
In diesem Fall steht der Name des Symbols in Anführungszeichen.

     (%i1) infix ("##");
     (%o1)                          ##
     (%i2) "##" (a, b) := a^b;
                                          b
     (%o2)                     a ## b := a
     (%i3) 5 ## 3;
     (%o3)                          125
     (%i4) remove ("##", op);
     (%o4)                         done
     (%i5) 5 ## 3;
     Incorrect syntax: # is not a prefix operator
     5 ##
       ^
     (%i5) "##" (5, 3);
     (%o5)                          125
     (%i6) infix ("##");
     (%o6)                          ##
     (%i7) 5 ## 3;
     (%o7)                          125
     (%i8) kill ("##");
     (%o8)                         done
     (%i9) 5 ## 3;
     Incorrect syntax: # is not a prefix operator
     5 ##
       ^
     (%i9) "##" (5, 3);
     (%o9)                       ##(5, 3)


File: maxima.info,  Node: Funktionen und Variablen für nutzerdefinierte Operatoren,  Prev: Einführung in nutzerdefinierte Operatoren,  Up: Nutzerdefinierte Operatoren

7.7.2 Funktionen und Variablen für nutzerdefinierte Operatoren
--------------------------------------------------------------

 -- Funktion: infix (<op>)
 -- Funktion: infix (<op>, <lbp>, <rbp>)
 -- Funktion: infix (<op>, <lbp>, <rbp>, <lpos>, <rpos>, <pos>)
     Deklariert <op> als einen Infix-Operator.  Ein Infix-Operator hat
     eine Funktionsdefinition mit zwei Argumenten.  Der Infix-Operator
     steht zwischen den Operanden.  Zum Beispiel ist die Subtraktion `-'
     ein Infix-Operator.

     `infix(<op>)' deklariert <op> als einen Infix-Operator mit einem
     links- und rechtsseitigen Vorrang von jeweils 180.

     `infix(<op>, <lbp>, <rbp>)' deklariert <op> als einen
     Infix-Operator mit den angegebenen Werten für den links- und
     rechtsseitigen Vorrang.

     `infix(<op>, <lbp>, <rbp>, <lpos>, <rpos>, <pos>)' deklariert <op>
     als einen Infix-Operator mit den angegebenen Vorrängen sowie den
     Wortarten <lpos>, <rpos> und <pos> für den linken und den rechten
     Operanden sowie das Ergebnis des Operators.

     Beispiele:

     Sind die rechtsseitigen und linksseitigen Vorränge eines Operators
     <op> größer als die entsprechenden Vorränge eines anderen
     Operators, dann hat der Operator <op> Vorrang.

          (%i1) :lisp (get '$+ 'lbp)
          100
          (%i1) :lisp (get '$+ 'rbp)
          100
          (%i1) infix ("##", 101, 101);
          (%o1)                          ##
          (%i2) "##"(a, b) := sconcat("(", a, ",", b, ")");
          (%o2)       (a ## b) := sconcat("(", a, ",", b, ")")
          (%i3) 1 + a ## b + 2;
          (%o3)                       (a,b) + 3
          (%i4) infix ("##", 99, 99);
          (%o4)                          ##
          (%i5) 1 + a ## b + 2;
          (%o5)                       (a+1,b+2)

     Ein größerer linksseitige Vorrang <lbp> bewirkt, dass der Operator
     <op> rechts-assoziativ ist.  Ein größerer rechtsseitiger Vorrang
     macht dagegen den Operator <op> links-assoziativ.

          (%i1) infix ("##", 100, 99);
          (%o1)                          ##
          (%i2) "##"(a, b) := sconcat("(", a, ",", b, ")")$
          (%i3) foo ## bar ## baz;
          (%o3)                    (foo,(bar,baz))
          (%i4) infix ("##", 100, 101);
          (%o4)                          ##
          (%i5) foo ## bar ## baz;
          (%o5)                    ((foo,bar),baz)

     Maxima kann Syntaxfehler beim Einlesen eines Ausdrucks
     feststellen, wenn der eingelesene Operand nicht die für den
     Operator definierte Wortart hat.

          (%i1) infix ("##", 100, 99, expr, expr, expr);
          (%o1)                          ##
          (%i2) if x ## y then 1 else 0;
          Incorrect syntax: Found algebraic expression where
          logical expression expected
          if x ## y then
                       ^
          (%i2) infix ("##", 100, 99, expr, expr, clause);
          (%o2)                          ##
          (%i3) if x ## y then 1 else 0;
          (%o3)                if x ## y then 1 else 0

 -- Funktion: matchfix (<ldelimiter>, <rdelimiter>)
 -- Funktion: matchfix (<ldelimiter>, <rdelimiter>, <arg_pos>, <pos>)
     Deklariert einen Matchfix-Operator mit dem linksseitigen
     Begrenzungszeichen <ldelimiter> und dem rechtsseitigen
     Begrenzungszeichen <rdelimiter>.

     Ein Matchfix-Operator hat eine beliebige Anzahl an Argumenten, die
     zwischen dem linksseitigen und dem rechtsseitigen
     Begrenzungszeichen stehen.  Das Begrenzungszeichen kann eine
     beliebige Zeichenkette sein.  Einige Zeichen wie `%', `,', `$' und
     `;' können nicht als Begrenzungszeichen definiert werden.

     Ein linksseitiges Begrenzungszeichen kann nicht verschiedene
     rechtsseitige Begrenzungszeichen haben.

     Maxima-Operatoren können als Matchfix-Operatoren definiert werden,
     ohne dass sich die sonstigen Operatoreigenschaften ändern.  So
     kann zum Beispiel der Operator `+' als Matchfix-Operator definiert
     werden.

     `matchfix(<ldelimiter>, <rdelimiter>, <arg_pos>, <pos>)' definiert
     die Wortarten für die Argumente <arg_pos> und das Ergebnis <pos>
     sowie das linksseitige <ldelimiter> und rechtsseitige <rdelimiter>
     Begrenzungszeichen.

     Die zu einem Matchfix-Operator zugehörige Funktion kann jede
     nutzerdefinierte Funktion sein, die mit `:='  oder `define'
     definiert wird.  Die Definition der Funktion kann mit
     `dispfun(<ldelimiter>)' ausgegeben werden.

     Maxima kennt nur den Operator für Listen `[ ]' als
     Matchfix-Operator.  Klammern `( )' und Anführungszeichen `" "'
     arbeiten wie Matchfix-Operatoren, werden aber vom Parser nicht als
     Matchfix-Operatoren behandelt.

     `matchfix'  wertet die Argumente aus.  `matchfix' gibt das erste
     Argument <ldelimiter> als Ergebnis zurück.

     Beispiele:

     Begrenzungszeichen können eine beliebige Zeichenkette sein.

          (%i1) matchfix ("@@", "~");
          (%o1)                          @@
          (%i2) @@ a, b, c ~;
          (%o2)                      @@a, b, c~
          (%i3) matchfix (">>", "<<");
          (%o3)                          >>
          (%i4) >> a, b, c <<;
          (%o4)                      >>a, b, c<<
          (%i5) matchfix ("foo", "oof");
          (%o5)                          foo
          (%i6) foo a, b, c oof;
          (%o6)                     fooa, b, coof
          (%i7) >> w + foo x, y oof + z << / @@ p, q ~;
                               >>z + foox, yoof + w<<
          (%o7)                ----------------------
                                      @@p, q~

     Matchfix-Operatoren können für nutzerdefinierte Funktionen
     definiert werden.

          (%i1) matchfix ("!-", "-!");
          (%o1)                         "!-"
          (%i2) !- x, y -! := x/y - y/x;
                                              x   y
          (%o2)                   !-x, y-! := - - -
                                              y   x
          (%i3) define (!-x, y-!, x/y - y/x);
                                              x   y
          (%o3)                   !-x, y-! := - - -
                                              y   x
          (%i4) define ("!-" (x, y), x/y - y/x);
                                              x   y
          (%o4)                   !-x, y-! := - - -
                                              y   x
          (%i5) dispfun ("!-");
                                              x   y
          (%t5)                   !-x, y-! := - - -
                                              y   x

          (%o5)                         done
          (%i6) !-3, 5-!;
                                          16
          (%o6)                         - --
                                          15
          (%i7) "!-" (3, 5);
                                          16
          (%o7)                         - --
                                          15

 -- Funktion: nary (<op>)
 -- Funktion: nary (<op>, <bp>, <arg_pos>, <pos>)
     `nary(<op>)' definiert einen `N-ary'-Operator <op> mit einem
     linksseitigen Vorrang von 180.  Der rechtsseitige Vorrang wird
     nicht benötigt.

     `nary(<op>, <bp>, <arg_pos>, <pos>)' definiert einen
     `N-ary'-Operator <op> mit einem rechtsseitigen Vorrang von <bp> und
     der Wortart <arg_pos> für den Operanden und der Wortart <pos> fÃ¼r
     das Ergebnis.

     Ein `N-ary'-Operator ist ein Operator, der eine beliebige Anzahl an
     Argumenten haben kann.  Die Argumente werden durch den Operator
     voneinander getrennt, so ist zum Beispiel `+' ein `N-ary'-Operator
     und `A+B+C'.

     Im Unterschied zur Definition eines Operators kann eine Funktion
     `f' auch als `nary'  mit der Funktion `declare'  deklariert
     werden.  Die Deklaration hat Auswirkung auf die Vereinfachung der
     Funktion.  Zum Beispiel wird ein Ausdruck `j(j(a,b),j(c,d)' zu
     `j(a,b,c,d)' vereinfacht.

 -- Funktion: nofix (<op>)
 -- Funktion: nofix (<op>, <pos>)
     `nofix(<op>)' definiert den Operator <op> als einen Nofix-Operator.

     `nofix(<op>, <pos>)' definiert einen Nofix-Operator mit der
     Wortart <pos> für das Ergebnis.

     Nofix-Operatoren sind Operatoren, die kein Argument haben.  Tritt
     ein solcher Operator allein auf, wird die dazugehörige Funktion
     ausgewertet.  Zum Beispiel beendet die Funktion `quit()' eine
     Maxima-Sitzung.  Wird diese Funktion mit `nofix("quit")' als ein
     Nofix-Operator definiert, genügt die Eingabe von `quit', um eine
     Maxima-Sitzung zu beenden.

 -- Funktion: postfix (<op>)
 -- Funktion: postfix (<op>, <lbp>, <lpos>, <pos>)
     `postfix (<op>)' definiert einen Postfix-Operator <op>.

     `postfix (<op>, <lbp>, <lpos>, <pos>)' definiert einen
     Postfix-Operator <op> mit einem linksseitigem Vorrang von <lbp>
     sowie den Wortarten <lpos> für den Operanden und <pos> für das
     Ergebnis.

     Ein Postfix-Operator hat einen Operanden, der dem Operator
     vorangestellt ist.  Ein Beispiel ist der `!'-Operator mit `3!'.
     Die Funktion `postfix("x")' erweitert die Maxima-Syntax um den
     Postfix-Operator `x'.

 -- Funktion: prefix (<op>)
 -- Funktion: prefix (<op>, <rbp>, <rpos>, <pos>)
     `prefix (<op>)' definiert einen Prefix-Operator <op>.

     `prefix (<op>, <lbp>, <lpos>, <pos>)' definiert einen
     Prefix-Operator <op> mit einem rechtsseitigem Vorrang von <rbp>
     sowie den Wortarten <rpos> für den Operanden und <pos> für das
     Ergebnis.

     Ein Prefix-Operator hat einen Operanden, der dem Operator
     nachfolgt.  Mit `prefix("x")' wird die Maxima-Syntax um einen
     Prefix-Operator `x' erweitert.


File: maxima.info,  Node: Auswertung,  Next: Vereinfachung,  Prev: Operatoren,  Up: Top

8 Auswertung
************

* Menu:

* Einführung in die Auswertung::
* Funktionen und Variablen für die Auswertung::


File: maxima.info,  Node: Einführung in die Auswertung,  Next: Funktionen und Variablen für die Auswertung,  Prev: Auswertung,  Up: Auswertung

8.1 Einführung in die Auswertung
================================

In *note Einführung in die Kommandozeile:: sind die vier Phasen der
Eingabe, Auswertung, Vereinfachung und Ausgabe erläutert, die jede
Eingabe des Nutzers bis zur Ausgabe auf der Konsole durchläuft.

Jede Eingabe eines Ausdrucks <expr> wird von Maxima ausgewertet.
Symbole, die keinen Wert haben, und Zahlen werden zu sich selbst
ausgewertet.  Symbole, die einen Wert haben, werden durch ihren Wert
ersetzt.

Beispiele:

Im ersten Beispiel werden Symbole und Zahlen zu sich selbst
ausgewertet.  Im zweiten Beispiel erhält die Variable `a' den Wert `2'.
In den folgenden Ausdrücken wird die Variable `a' ausgewertet und durch
ihren Wert ersetzt.

     (%i1) [a, b, 2, 1/2, 1.0];
                                       1
     (%o1)                   [a, b, 2, -, 1.0]
                                       2
     (%i2) a:2$

     (%i3) [a, sin(a), a^2];
     (%o3)                    [2, sin(2), 4]

Maxima unterscheidet Funktionen in einer Verbform von Funktionen in
einer Substantivform.  Funktionen in einer Verbform werden ausgewertet,
indem die Funktion auf die ausgewerteten Argumente angewendet wird.  Im
Gegensatz dazu werden Funktionen in einer Substantivform nicht auf die
Argumente angewendet, jedoch werden die Argumente weiterhin
ausgewertet.  Funktionen können in beiden Formen auftreten.  Typische
Beispiele sind die Differentiation mit der Funktion `diff'  oder die
Integration mit der Funktion `integrate'.

Siehe zum diesem Thema auch *note Substantive und Verben::.

Beispiele:

Die Variable `a' erhält einen Wert.  Im ersten Fall liegt die Funktion
`diff' in ihrer Verbform vor.  Die Auswertung bewirkt, dass die Funktion
auf die Argumente `a*x^2' und <x> angewendet wird.  Im zweiten Fall
liegt die Funktion `diff' in ihrer Substantivform vor.  Dies wird hier
durch den `Quote-Operator'  `'' bewirkt.  Jetzt wird die Funktion nicht
angewendet.  Das Ergebnis ist ein symbolischer Ausdruck für die
Ableitung.  Da auch in diesem Fall die Argumente ausgewertet werden,
wird auch hier der Wert `1/2' für die Variable `a' eingesetzt.

     (%i1) a:1/2;
                                     1
     (%o1)                           -
                                     2
     (%i2) diff(a*x^2, x);
     (%o2)                           x
     (%i3) 'diff(a*x^2, x);
                                       2
                                  d   x
     (%o3)                        -- (--)
                                  dx  2

Nicht alle Maxima-Funktionen werten die Argumente aus.  Die
Dokumentation der Funktionen gibt häufig einen Hinweis darauf, ob die
Argumente ausgewertet werden oder nicht.

Beispiel:

Die Funktion `properties'  wertet das Argument nicht aus.  Dies ist für
den Nutzer praktisch, da ansonsten die Auswertung einer Variablen `a',
die einen Wert hat, explizit mit dem Quote-Operator `'' unterdrückt
werden müsste, um die Eigenschaften des Symbols `'a' anzuzeigen.  Im
ersten Fall ist das Ergebnis eine leere Liste.  Das Symbol `a' hat
keine Eigenschaften.  Im zweiten Fall erhält die Variable `a' einen
Wert.  Die Funktion `properties' wertet ihr Argument nicht aus und `a'
wird nicht durch den Wert `2' ersetzt.  Die Funktion `properties' zeigt
weiterhin die Eigenschaften des Symbols `'a' an.

     (%i1) properties(a);
     (%o1)                          []
     (%i2) a:2$

     (%i3) properties(a);
     (%o3)                        [value]

Die Auswertung von Symbolen, Funktionen und Ausdrücken kann mit dem
Quote-Operator  `'' und dem Quote-Quote-Operator

`''' kontrolliert werden.  Der Quote-Operator unterdrückt die
Auswertung.  Dagegen erzwingt der Quote-Quote-Operator die Auswertung.

Mit der Funktion `ev'  wird ein Ausdruck in einer definierten Umgebung
ausgewertet, in der Optionsvariablen für die Auswertung einen
bestimmten Wert erhalten oder Auswertungsschalter `evflag'  und
Auswertungsfunktionen `evfun'  angewendet werden.


File: maxima.info,  Node: Funktionen und Variablen für die Auswertung,  Prev: Einführung in die Auswertung,  Up: Auswertung

8.2 Funktionen und Variablen für die Auswertung
===============================================

 -- Operator: '
     Der Quote-Operator `'' unterdrückt die Auswertung eines Symbols
     oder Ausdrucks.  Auf eine Funktion angewendet, unterdrückt der
     Quote-Operator die Auswertung der Funktion.  Die Auswertung der
     Argumente der Funktion wird nicht unterdrückt.  Das Ergebnis ist
     die Substantivform der Funktion.

     Wird der Quote-Operator auf einen eingeklammerten Ausdruck
     angewendet, wird die Auswertung aller Symbole und Funktionen
     innerhalb der Klammern unterdrückt.  `'(f(x))' bedeutet, dass der
     Ausdruck `f(x)' nicht ausgewertet werden soll.  `'f(x)' bedeutet,
     dass die Substantivform von `f' auf das ausgewertete Argument <x>
     angewendet wird.

     Der Quote-Operator unterdrückt die Auswertung, aber nicht die
     Vereinfachung von Ausdrücken.

     Substantivformen werden mit einem Hochkomma angezeigt, wenn die
     Optionsvariable `noundisp'  den Wert `true' hat.

     Siehe auch den Quote-Quote-Operator  `''' und den
     Auswertungsschalter `nouns'.

     Beispiele:

     Auf ein Symbol angewendet, unterdrückt der Quote-Operator die
     Auswertung des Symbols.

          (%i1) aa: 1024;
          (%o1)                         1024
          (%i2) aa^2;
          (%o2)                        1048576
          (%i3) 'aa^2;
                                           2
          (%o3)                          aa
          (%i4) ''%;
          (%o4)                        1048576

     Auf eine Funktion angewendet, unterdrückt der Quote-Operator die
     Auswertung der Funktion.  Das Ergebnis ist die Substantivform der
     Funktion.

          (%i1) x0: 5;
          (%o1)                           5
          (%i2) x1: 7;
          (%o2)                           7
          (%i3) integrate (x^2, x, x0, x1);
                                         218
          (%o3)                          ---
                                          3
          (%i4) 'integrate (x^2, x, x0, x1);
                                       7
                                      /
                                      [   2
          (%o4)                       I  x  dx
                                      ]
                                      /
                                       5
          (%i5) %, nouns;
                                         218
          (%o5)                          ---
                                          3

     Wird der Quote-Operator auf einen eingeklammerten Ausdruck
     angewendet, wird die Auswertung aller Symbole und Funktionen
     innerhalb der Klammern unterdrückt.

          (%i1) aa: 1024;
          (%o1)                         1024
          (%i2) bb: 19;
          (%o2)                          19
          (%i3) sqrt(aa) + bb;
          (%o3)                          51
          (%i4) '(sqrt(aa) + bb);
          (%o4)                     bb + sqrt(aa)
          (%i5) ''%;
          (%o5)                          51

     Der Quote-Operator unterdrückt nicht die Vereinfachung von
     Ausdrücken.

          (%i1) sin (17 * %pi) + cos (17 * %pi);
          (%o1)                          - 1
          (%i2) '(sin (17 * %pi) + cos (17 * %pi));
          (%o2)                          - 1

     Gleitkommarechnungen sind eine Vereinfachung und keine Auswertung.
     Daher kann die Berechnung von `sin(1.0)' nicht mit dem
     Quote-Operator unterdrückt werden.

          (%i1) sin(1.0);
          (%o1)                          .8414709848078965
          (%i2) '(sin(1.0));
          (%o2)                          .8414709848078965

 -- Operator: "
     Der Quote-Quote-Operator `''' (zwei Hochkommata) modifiziert die
     Auswertung von Ausdrücken, die von der Eingabe gelesen werden.

     Wird der Quote-Quote-Operator auf einen allgemeinen Ausdruck <expr>
     angewendet, wird der Ausdruck <expr> durch seinen Wert ersetzt.

     Wird der Quote-Quote-Operator auf den Operator eines Ausdruckes
     angewendet, ändert sich der Operator, wenn er in seiner
     Substantivform vorliegt, in die Verbform.

     Der Quote-Quote-Operator wird vom Parser, der die Eingabe liest,
     sofort angewendet und nicht im eingelesen Ausdruck gespeichert.
     Daher kann die Auswertung des Quote-Quote-Operators nicht durch
     einen weiteren Quote-Operator verhindert werden.  Der
     Quote-Quote-Operator führt zur Auswertung von Ausdrücken, deren
     Auswertung unterdrückt ist.  Das ist der Fall für
     Funktionsdefinitionen, Lambda-Ausdrücke und Ausdrücke, deren
     Auswertung durch den Quote-Operator verhindert wurde.

     Der Quote-Quote-Operator wird von den Befehlen `batch'  und `load'
     erkannt.

     Siehe auch den Quote-Operator  `'' und den Auswertungsschalter
     `nouns'.

     Beispiele:

     Wird der Quote-Quote-Operator auf einen Ausdruck <expr>
     angewendet, wird der Wert von <expr> in den Ausdruck eingesetzt.

          (%i1) expand ((a + b)^3);
                               3        2      2      3
          (%o1)               b  + 3 a b  + 3 a  b + a
          (%i2) [_, ''_];
                                   3    3        2      2      3
          (%o2)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
          (%i3) [%i1, ''%i1];
                                   3    3        2      2      3
          (%o3)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
          (%i4) [aa : cc, bb : dd, cc : 17, dd : 29];
          (%o4)                   [cc, dd, 17, 29]
          (%i5) foo_1 (x) := aa - bb * x;
          (%o5)                 foo_1(x) := aa - bb x
          (%i6) foo_1 (10);
          (%o6)                      cc - 10 dd
          (%i7) ''%;
          (%o7)                         - 273
          (%i8) ''(foo_1 (10));
          (%o8)                         - 273
          (%i9) foo_2 (x) := ''aa - ''bb * x;
          (%o9)                 foo_2(x) := cc - dd x
          (%i10) foo_2 (10);
          (%o10)                        - 273
          (%i11) [x0 : x1, x1 : x2, x2 : x3];
          (%o11)                    [x1, x2, x3]
          (%i12) x0;
          (%o12)                         x1
          (%i13) ''x0;
          (%o13)                         x2
          (%i14) '' ''x0;
          (%o14)                         x3

     Wird der Quote-Quote-Operator auf den Operator in einem Ausdruck
     angewendet, ändert sich der Operator von seiner Substantivform in
     die Verbform.

          (%i1) declare (foo, noun);
          (%o1)                         done
          (%i2) foo (x) := x - 1729;
          (%o2)                 ''foo(x) := x - 1729
          (%i3) foo (100);
          (%o3)                       foo(100)
          (%i4) ''foo (100);
          (%o4)                        - 1629

     Der Quote-Quote-Operator wird vom Parser sofort auf den
     eingelesenen Ausdruck angewendet und ist nicht Teil eines
     Maxima-Ausdrucks.

          (%i1) [aa : bb, cc : dd, bb : 1234, dd : 5678];
          (%o1)                 [bb, dd, 1234, 5678]
          (%i2) aa + cc;
          (%o2)                        dd + bb
          (%i3) display (_, op (_), args (_));
                                     _ = cc + aa

                                   op(cc + aa) = +

                              args(cc + aa) = [cc, aa]

          (%o3)                         done
          (%i4) ''(aa + cc);
          (%o4)                         6912
          (%i5) display (_, op (_), args (_));
                                     _ = dd + bb

                                   op(dd + bb) = +

                              args(dd + bb) = [dd, bb]
          (%o5)                         done

     Der Quote-Quote-Operator bewirkt die Auswertung von Ausdrücken,
     deren Auswertung unterdrückt ist wie in Funktionsdefinitionen,
     Lambda-Ausdrücken und Ausdrücken, auf die der Quote-Operator
     angewendet wurde.

          (%i1) foo_1a (x) := ''(integrate (log (x), x));
          (%o1)               foo_1a(x) := x log(x) - x
          (%i2) foo_1b (x) := integrate (log (x), x);
          (%o2)           foo_1b(x) := integrate(log(x), x)
          (%i3) dispfun (foo_1a, foo_1b);
          (%t3)               foo_1a(x) := x log(x) - x

          (%t4)           foo_1b(x) := integrate(log(x), x)

          (%o4)                      [%t3, %t4]
          (%i5) integrate (log (x), x);
          (%o5)                     x log(x) - x
          (%i6) foo_2a (x) := ''%;
          (%o6)               foo_2a(x) := x log(x) - x
          (%i7) foo_2b (x) := %;
          (%o7)                    foo_2b(x) := %
          (%i8) dispfun (foo_2a, foo_2b);
          (%t8)               foo_2a(x) := x log(x) - x

          (%t9)                    foo_2b(x) := %

          (%o9)                      [%t8, %t9]
          (%i10) F : lambda ([u], diff (sin (u), u));
          (%o10)            lambda([u], diff(sin(u), u))
          (%i11) G : lambda ([u], ''(diff (sin (u), u)));
          (%o11)                 lambda([u], cos(u))
          (%i12) '(sum (a[k], k, 1, 3) + sum (b[k], k, 1, 3));
          (%o12)         sum(b , k, 1, 3) + sum(a , k, 1, 3)
                              k                  k
          (%i13) '(''(sum (a[k], k, 1, 3)) + ''(sum (b[k], k, 1, 3)));
          (%o13)             b  + a  + b  + a  + b  + a
                              3    3    2    2    1    1

 -- Funktion: ev (<expr>, <arg_1>, ..., <arg_n>)
     Wertet den Ausdruck <expr> in einer Umgebung aus, die durch die
     Argumente <arg_1>, ..., <arg_n> spezifiziert wird.  Die Argumente
     sind Optionsvariablen (Boolesche Variablen), Zuweisungen,
     Gleichungen und Funktionen.  `ev' gibt das Ergebnis der Auswertung
     zurück.

     Die Auswertung wird in den folgenden Schritten durchgeführt:

       1. Zuerst wird die Umgebung gesetzt.  Dazu werden die Argumente
          <arg_1>, ..., <arg_n> ausgewertet.  Folgende Argumente sind
          möglich:

             * `simp' bewirkt, dass der Ausdruck <expr> vereinfacht
               wird.  Der Wert der Optionsvariablen `simp'  wird dabei
               ignoriert.  Der Ausdruck wird also auch dann
               vereinfacht, wenn die Optionsvariable <simp> den Wert
               `false' hat.

             * `noeval' unterdrückt die Auswertungphase der Funktion
               `ev' (siehe Schritt (4) unten).  Dies ist nützlich im
               Zusammenhang mit anderen Schaltern und um einen Ausdruck
               <expr> erneuert zu vereinfachen, ohne dass dieser
               ausgewertet wird.

             * `nouns' bewirkt die Auswertung von Substantivformen.
               Solche Substantivformen sind typischerweise nicht
               ausgewertete Funktionen wie `'integrate' oder `'diff',
               die im Ausdruck <expr> enthalten sind.

             * `expand' bewirkt die Expansion des Ausdruckes <expr>.
               Siehe die Funktion `expand'.

             * `expand'(<m>, <n>) bewirkt die Expansion des Ausdruckes
               <expr>, wobei den Optionsvariablen `maxposex'  und
               `maxnegex'  die Werte der Argumente <m> und <n>
               zugewiesen werden.  Siehe die Funktion `expand'.

             * `detout' bewirkt, dass bei der Berechnung von Inversen
               von Matrizen, die im Ausdruck <expr> enthalten sind,
               Determinanten den Matrizen vorangestellt und nicht
               elementweise in die Matrize hereinmultipliziert werden.

             * `diff' bewirkt, dass alle Ableitungen ausgeführt werden,
               die im Ausdruck <expr> enthalten sind.

             * `derivlist(<x>, <y>, <z>, ...)' bewirkt, dass die
               Ableitungen bezüglich der angegebenen Variablen <x>,
               <y>, <z>, ...  ausgeführt werden.

             * `risch' bewirkt das Integrale im Ausdruck <expr> mit dem
               Risch-Algorithmus berechnet werden.  Siehe `risch'.
               Wird der Schalter `nouns'  benutzt, wird der
               Standardalgorithmus für Integrale verwendet.

             * `float' bewirkt, dass rationale Zahlen in
               Gleitkommazahlen konvertiert werden.

             * `numer' bewirkt, dass mathematische Funktionen mit
               numerischen Argumenten ein Ergebnis in Gleitkommazahlen
               liefern.  Variablen in `expr', denen numerische Werte
               zugewiesen wurden, werden durch diese ersetzt.  Der
               Schalter `float'  wird zusätzlich wirksam.

             * `pred' bewirkt, dass Aussagen zu `true' oder `false'
               ausgewertet werden.

             * `eval' bewirkt eine zusätzliche Auswertung des Ausdrucks
               <expr>.  (Siehe Schritt (5) unten).  `eval' kann
               mehrfach angewendet werden.  Jedes Auftreten von `eval'
               führt zu einer weiteren Auswertung.

             * `A', wobei `A' ein Symbol ist, das als ein
               Auswertungsschalter `evflag'  definiert ist.  Während
               der Auswertung des Ausdrucks <expr> erhält `A' den Wert
               `true'.

             * `V: expression' (oder alternativ `V=expression')
               bewirkt, dass `V' während der Auswertung des Ausdrucks
               <expr> den Wert `expression' erhält.  `V' kann auch eine
               Optionsvariable sein, die für die Auswertung den Wert
               `expression' erhält.  Wenn mehr als ein Argument der
               Funktion `ev' übergeben wird, wird die Zuweisung der
               Werte parallel ausgeführt.  Wenn `V' kein Atom ist, wird
               anstatt einer Zuweisung eine Substitution ausgeführt.

             * `F', wobei `F' der Name einer Funktion ist, die als eine
               Auswertungsfunktion (siehe `evfun' ) definiert wurde.
               `F' bewirkt, dass die Auswertungsfunktion auf den
               Ausdruck <expr> angewendet wird.

             * Jeder andere Funktionsname (zum Beispiel `sum') bewirkt,
               dass jedes Auftreten dieser Funktion im Ausdruck <expr>
               ausgewertet wird.

             * Zusätzlich kann für die Auswertung von <expr> eine
               lokale Funktion `F(x) := expression' definiert werden.

             * Wird ein Symbol, eine indizierte Variable oder ein
               indizierter Ausdruck, der oben nicht genannt wurde, als
               Argument übergeben, wird das Argument ausgewertet.  Wenn
               das Ergebnis eine Gleichung oder eine Zuweisung ist,
               werden die entsprechenden Zuweisungen und Substitutionen
               ausgeführt.  Wenn das Ergebnis eine Liste ist, werden
               die Elemente der Liste als zusätzliche Argumente von
               `ev' betrachtet.  Dies erlaubt, das eine Liste mit
               Gleichungen (zum Beispiel `[%t1, %t2]', wobei `%t1' und
               `%t2' Gleichungen sind) wie sie zum Beispiel von der
               Funktion `solve'  erzeugt wird, als Argument verwendet
               werden kann.

          Die Argumente der Funktion `ev' können in einer beliebigen
          Reihenfolge übergeben werden.  Ausgenommen sind Gleichungen
          mit Substitutionen, die nacheinander von links nach rechts
          ausgewertet werden, sowie Auswertungsfunktionen, die
          verkettet werden.  So wird zum Beispiel `ev(<expr>, ratsimp,
          realpart)' zu `realpart(ratsimp(<expr>))'.

          Die Schalter `simp',  `numer',  `float'  und `detout'  sind
          auch Optionsvariablen, die lokal in einem Block oder global
          gesetzt werden können.

          Ist <expr> ein kanonischer rationaler Ausdruck (CRE =
          canonical rational expression), ist auch das Ergebnis der
          Funktion `ev' ein CRE-Ausdruck, falls nicht die beiden
          Schalter `float' und `numer' den Wert `true' haben.

       2. Während des Schritts (1) wird eine Liste der nicht
          indizierten Variablen erstellt, die auf der linken Seite von
          Gleichungen auftreten.  Die Gleichungen können dabei entweder
          als Argument oder als Wert eines Argumentes vorliegen.
          Variablen, die nicht in dieser Liste enthalten sind, werden
          durch ihre globalen Werte ersetzt.  Davon ausgenommen sind
          Variablen, die eine Array-Funktion repräsentieren.  Ist zum
          Beispiel <expr> eine Marke wie `%i2' im Beispiel unten oder
          das letzte Ergebnis `%', so wird in diesem Schritt der
          globale Wert dieser Marke eingesetzt und die Bearbeitung
          durch `ev' fortgesetzt.

       3. Wenn in den Argumenten Substitutionen aufgeführt sind, werden
          diese nun ausgeführt.

       4. Der resultierende Ausdruck wird erneut ausgewertet, außer
          wenn `noeval' unter den Argumente ist, und vereinfacht.  Die
          Funktionsaufrufe in <expr> werden erst ausgeführt, wenn die
          enthaltenden Variablen ausgewertet sind.  Dadurch verhält
          sich `ev(F(x))' wie `F(ev(x))'.

       5. Für jedes Auftreten des Schalters `eval' in den Argumenten
          werden die Schritte (3) und (4) wiederholt.

     Anstatt der Anwendung der Funktion `ev' können alternativ der
     Ausdruck und die Argumente durch Kommata getrennt eingegeben
     werden:

          <expr>, <arg_1>, ..., <arg_n>

     Diese Kurzschreibweise ist jedoch als Teil eines anderen
     Ausdrucks, zum Beispiel in Funktionen oder Blöcken nicht gestattet.

     Beispiele:

          (%i1) sin(x) + cos(y) + (w+1)^2 + 'diff (sin(w), w);
                                               d                    2
          (%o1)              cos(y) + sin(x) + -- (sin(w)) + (w + 1)
                                               dw
          (%i2) ev (%, numer, expand, diff, x=2, y=1);
                                         2
          (%o2)                cos(w) + w  + 2 w + 2.449599732693821

     Im folgenden Beispiel werden die Zuweisungen parallel
     durchgeführt.  Es wird die Kurzschreibweise der Funktion `ev'
     angewendet.

          (%i3) programmode: false;
          (%o3)                                false
          (%i4) x+y, x: a+y, y: 2;
          (%o4)                              y + a + 2
          (%i5) 2*x - 3*y = 3$
          (%i6) -3*x + 2*y = -4$
          (%i7) solve ([%o5, %o6]);
          Solution

                                                    1
          (%t7)                               y = - -
                                                    5

                                                   6
          (%t8)                                x = -
                                                   5
          (%o8)                            [[%t7, %t8]]
          (%i8) %o6, %o8;
          (%o8)                              - 4 = - 4
          (%i9) x + 1/x > gamma (1/2);
                                             1
          (%o9)                          x + - > sqrt(%pi)
                                             x
          (%i10) %, numer, x=1/2;
          (%o10)                      2.5 > 1.772453850905516
          (%i11) %, pred;
          (%o11)                               true

 -- Auswertungsschalter: eval
     Als Argument des Kommandos `ev(expr, eval)' bewirkt `eval' eine
     zusätzliche Auswertung des Ausdrucks `expr'.

     `eval' kann mehrfach auftreten.  Jedes Auftreten führt zu einer
     zusätzlichen Auswertung.

     Siehe auch die Funktion `ev'  sowie die Auswertungsschalter
     `noeval'  und `infeval'

     Beispiele:

          (%i1) [a:b,b:c,c:d,d:e];
          (%o1)                            [b, c, d, e]
          (%i2) a;
          (%o2)                                  b
          (%i3) ev(a);
          (%o3)                                  c
          (%i4) ev(a),eval;
          (%o4)                                  e
          (%i5) a,eval,eval;
          (%o5)                                  e

 -- Eigenschaft: evflag
     Wenn ein Symbol <x> die Eigenschaft eines Auswertungsschalters
     besitzt, sind die Ausdrücke `ev(<expr>, <x>)' und `<expr>, <x>'
     äquivalent zu `ev(<expr>, <x> = true)'.  Während der Auswertung
     von <expr> erhält also <x> den Wert `true'.

     Mit `declare(<x>, evflag)' wird der Variablen <x> die
     `evflag'-Eigenschaft gegeben.  Siehe auch die Funktion `declare'.
      Mit `kill'  oder `remove'  kann diese Eigenschaft wieder entfernt
     werden.  Siehe auch `properties'  für die Anzeige von
     Eigenschaften.

     Folgende Optionsvariablen haben bereits die `evflag'-Eigenschaft:

        algebraic           cauchysum       demoivre
        dotscrules          %emode          %enumer
        exponentialize      exptisolate     factorflag
        float               halfangles      infeval
        isolate_wrt_times   keepfloat       letrat
        listarith           logabs          logarc
        logexpand           lognegint
        m1pbranch           numer_pbranch   programmode
        radexpand           ratalgdenom     ratfac
        ratmx               ratsimpexpons   simp
        simpproduct         simpsum         sumexpand
        trigexpand

     Beispiele:

          (%i1) sin (1/2);
                                           1
          (%o1)                        sin(-)
                                           2
          (%i2) sin (1/2), float;
          (%o2)                   0.479425538604203
          (%i3) sin (1/2), float=true;
          (%o3)                   0.479425538604203
          (%i4) simp : false;
          (%o4)                         false
          (%i5) 1 + 1;
          (%o5)                         1 + 1
          (%i6) 1 + 1, simp;
          (%o6)                           2
          (%i7) simp : true;
          (%o7)                         true
          (%i8) sum (1/k^2, k, 1, inf);
                                      inf
                                      ====
                                      \     1
          (%o8)                        >    --
                                      /      2
                                      ====  k
                                      k = 1
          (%i9) sum (1/k^2, k, 1, inf), simpsum;
                                           2
                                        %pi
          (%o9)                         ----
                                         6
          (%i10) declare (aa, evflag);
          (%o10)                        done
          (%i11) if aa = true then YES else NO;
          (%o11)                         NO
          (%i12) if aa = true then YES else NO, aa;
          (%o12)                         YES

 -- Eigenschaft: evfun
     Wenn eine Funktion <F> die Eigenschaft `evfun' besitzt, sind die
     Ausdrücke `ev(<expr>, <F>)' und `<expr>, <F>'  äquivalent zu
     `<F>(ev(<expr>))'.

     Zwei oder mehr `evfun'-Funktionen <F>, <G>, ... werden in der
     aufgeführten Reihenfolge auf den Ausdruck <expr> angewendet.

     Mit `declare(<F>, evfun)' wird der Funktion <F> die
     `evfun'-Eigenschaft gegeben.  Siehe auch die Funktion `declare'.

     Mit `kill'  oder `remove'  kann diese Eigenschaft wieder entfernt
     werden.  Siehe auch `properties'  für die Anzeige von
     Eigenschaften.

     Funktionen, die bereits die `evfun'-Eigenschaft besitzen, sind:

        bfloat          factor       fullratsimp
        logcontract     polarform    radcan
        ratexpand       ratsimp      rectform
        rootscontract   trigexpand   trigreduce

     Beispiele:

          (%i1) x^3 - 1;
                                        3
          (%o1)                        x  - 1
          (%i2) x^3 - 1, factor;
                                          2
          (%o2)                 (x - 1) (x  + x + 1)
          (%i3) factor (x^3 - 1);
                                          2
          (%o3)                 (x - 1) (x  + x + 1)
          (%i4) cos(4 * x) / sin(x)^4;
                                      cos(4 x)
          (%o4)                       --------
                                         4
                                      sin (x)
          (%i5) cos(4 * x) / sin(x)^4, trigexpand;
                           4           2       2         4
                        sin (x) - 6 cos (x) sin (x) + cos (x)
          (%o5)         -------------------------------------
                                          4
                                       sin (x)
          (%i6) cos(4 * x) / sin(x)^4, trigexpand, ratexpand;
                                     2         4
                                6 cos (x)   cos (x)
          (%o6)               - --------- + ------- + 1
                                    2          4
                                 sin (x)    sin (x)
          (%i7) ratexpand (trigexpand (cos(4 * x) / sin(x)^4));
                                     2         4
                                6 cos (x)   cos (x)
          (%o7)               - --------- + ------- + 1
                                    2          4
                                 sin (x)    sin (x)
          (%i8) declare ([F, G], evfun);
          (%o8)                         done
          (%i9) (aa : bb, bb : cc, cc : dd);
          (%o9)                          dd
          (%i10) aa;
          (%o10)                         bb
          (%i11) aa, F;
          (%o11)                        F(cc)
          (%i12) F (aa);
          (%o12)                        F(bb)
          (%i13) F (ev (aa));
          (%o13)                        F(cc)
          (%i14) aa, F, G;
          (%o14)                      G(F(cc))
          (%i15) G (F (ev (aa)));
          (%o15)                      G(F(cc))

 -- Optionsvariable: infeval
     Standardwert: `false'

     `infeval' bewirkt, dass die Funktion `ev'  die Auswertung eines
     Ausdrucks solange wiederholt, bis dieser sich nicht mehr ändert.
     Um zu verhindern, dass eine Variable in diesem Modus durch die
     Auswertung verschwindet, kann zum Beispiel für eine Variable `x'
     der Ausdruck `x='x' als Argument von `ev' einfügt werden.
     Ausdrücke wie `ev(x, x=x+1, infeval)' führen in diesem Modus zu
     Endlosschleifen.

     Siehe auch die Auswertungsschalter `noeval'  und `eval'.


 -- Auswertungsschalter: noeval
     `noeval' unterdrückt die Auswertungsphase der Funktion `ev'.

     Der Schalter kann im Zusammenhang mit anderen Auswertungsschaltern
     genutzt werden, um einen Ausdruck erneut zu vereinfachen, ohne
     diesen auszuwerten.

     Siehe auch die Optionsvariable `infeval'  und den
     Auswertungsschalter `eval'.


 -- Auswertungsschalter: nouns
     `nouns' ist ein Auswertungsschalter.  Wird dieser Schalter als
     eine Option der Funktion `ev'  genutzt, werden alle
     Substantivformen, die in dem Ausdruck enthalten sind, in
     Verbformen umgewandelt und ausgewertet.

     Siehe auch die Eigenschaft `noun'  und die Funktionen `nounify'
     und `verbify'.


 -- Auswertungsschalter: pred
     Wird `pred' als ein Argument der Funktion `ev' eingesetzt, werden
     Aussagen zu `true' oder `false' ausgewertet.  Siehe die Funktion
     `ev'.

     Beispiel:

          (%i1) 1 < 2;
          (%o1)                                1 < 2
          (%i2) 1 < 2,pred;
          (%o2)                                true


File: maxima.info,  Node: Vereinfachung,  Next: Mathematische Funktionen,  Prev: Auswertung,  Up: Top

9 Vereinfachung
***************

* Menu:

* Einführung in die Vereinfachung::
* Funktionen und Variablen für die Vereinfachung::


File: maxima.info,  Node: Einführung in die Vereinfachung,  Next: Funktionen und Variablen für die Vereinfachung,  Prev: Vereinfachung,  Up: Vereinfachung

9.1 Einführung in die Vereinfachung
===================================

Nach der Auswertung einer Eingabe, die in *note Auswertung::
beschrieben ist, schließt sich die Vereinfachung eines Ausdrucks an.
Mathematische Funktionen mit denen symbolisch gerechnet werden kann,
werden nicht ausgewertet, sondern vereinfacht.  Mathematische
Funktionen werden intern von Maxima in einer Substantivform
dargestellt.  Auch Ausdrücke mit den arithmetischen Operatoren werden
vereinfacht.  Numerische Rechnungen wie die Addition oder Multiplikation
sind daher keine Auswertung, sondern eine Vereinfachung.  Die
Auswertung eines Ausdrucks kann mit dem `Quote-Operator'  `''
unterdrückt werden.  Entsprechend kann die Vereinfachung eines
Ausdrucks mit der Optionsvariablen `simp'  kontrolliert werden.

Beispiele:

Im ersten Beispiel wird die Auswertung mit dem Quote-Operator
unterdrückt.  Das Ergebnis ist eine Substantivform für die Ableitung.
Im zweiten Beispiel ist die Vereinfachung unterdrückt.  Die Ableitung
wird ausgeführt, da es sich um eine Auswertung handelt.  Das Ergebnis
wird jedoch nicht zu `2*x' vereinfacht.

     (%i1) 'diff(x*x,x);
                                  d    2
     (%o1)                        -- (x )
                                  dx
     (%i2) simp:false;
     (%o2)                         false
     (%i3) diff(x*x,x);
     (%o3)                       1 x + 1 x

Für jede mathematischen Funktion oder Operator hat Maxima intern eine
eigene Routine, die für die Vereinfachung aufgerufen wird, sobald die
Funktion oder der Operator in einem Ausdruck auftritt.  Diese Routinen
implementieren Symmetrieeigenschaften, spezielle Funktionswerte oder
andere Eigenschaften und Regeln.  Mit einer Vielzahl von
Optionsvariablen kann Einfluss auf die Vereinfachung der Funktionen und
Operatoren genommen werden.

Beispiel:

Die Vereinfachung der Exponentialfunktion `exp'  wird von den folgenden
Optionsvariablen kontrolliert: `%enumer',  `%emode',

`%e_to_numlog',  `radexpand',  `logsimp',  und `demoivre'.    Im ersten
Beispiel wird der Ausdruck mit der Exponentialfunktion nicht
vereinfacht.  Im zweiten Beispiel vereinfacht Maxima ein Argument
`%i*%pi/2'.

     (%i1) exp(x+%i*%pi/2), %emode:false;
                                     %i %pi
                                 x + ------
                                       2
     (%o1)                     %e
     (%i2) exp(x+%i*%pi/2), %emode:true;
                                       x
     (%o2)                        %i %e

Zusätzlich zu der Vereinfachung von einzelnen mathematischen Funktionen
und Operatoren, die automatisch von Maxima ausgeführt werden, kennt
Maxima Funktionen wie `expand'  oder `radcan',  die auf Ausdrücke
angewendet werden, um spezielle Vereinfachungen vorzunehmen.

Beispiel:

     (%i1) (log(x+x^2)-log(x))^a/log(1+x)^(a/2);
                                2               a
                          (log(x  + x) - log(x))
     (%o1)                -----------------------
                                         a/2
                               log(x + 1)
     (%i2) radcan(%);
                                         a/2
     (%o2)                     log(x + 1)

Einem Operator oder einer Funktion können Eigenschaften wie linear oder
symmetrisch gegeben werden.  Maxima berücksichtigt diese Eigenschaften
bei der Vereinfachung eines Ausdrucks.  Zum Beispiel wird mit dem
Kommando `declare(f, oddfun)' eine Funktion als ungerade definiert.
Maxima vereinfacht dann jedes Auftreten eines Ausdrucks `f(-x)' zu
`-f(x)'.  Entsprechend vereinfacht Maxima `f(-x)' zu `f(x)', wenn die
Funktion als gerade definiert wurde.

Die folgenden Eigenschaften sind in der Liste `opproperties'  enthalten
und kontrollieren die Vereinfachung von Funktionen und Operatoren:

   additive        lassociative     oddfun
   antisymmetric   linear           outative
   commutative     multiplicative   rassociative
   evenfun         nary             symmetric

Darüber hinaus haben auch die Fakten und die Eigenschaften des aktuellen
Kontextes Einfluss auf die Vereinfachung von Ausdrücken.  Siehe dazu die
Ausführungen in *note Maximas Datenbank::.

Beispiel:

Die Sinusfunktion vereinfacht für ein ganzzahliges Vielfaches von `%pi'
zum Wert `0'.  Erhält das Symbol `n' die Eigenschaft `integer', wird
die Sinusfunktion entsprechend vereinfacht.

     (%i1) sin(n*%pi);
     (%o1)                      sin(%pi n)
     (%i2) declare(n, integer);
     (%o2)                         done
     (%i3) sin(n*%pi);
     (%o3)                           0

Führen alle oben genannten Möglichkeiten nicht zu dem gewünschten
Ergebnis, kann der Nutzer Maxima um weitere Regeln für die Vereinfachung
erweitern.  Diese Möglichkeiten werden in *note Muster und Regeln::
erläutert.


File: maxima.info,  Node: Funktionen und Variablen für die Vereinfachung,  Prev: Einführung in die Vereinfachung,  Up: Vereinfachung

9.2 Funktionen und Variablen für die Vereinfachung
==================================================

 -- Eigenschaft: additive
     `declare(f, additive)' deklariert eine Funktion `f' als additiv.
     Hat die Funktion `f' ein Argument, dann wird `f(x + y)' zu `f(x) +
     f(y)' vereinfacht.

     Ist `f' eine Funktion mit zwei oder mehr Argumenten, ist die
     Additivität für das erste Argument definiert.  Zum Beispiel wird
     `f(x + y,a + b)' zu `f(y, b + a) + f(x, b + a)' vereinfacht.

     Siehe die Funktion `declare'.

     Beispiel:

          (%i1) F3 (a + b + c);
          (%o1)                     F3(c + b + a)
          (%i2) declare (F3, additive);
          (%o2)                         done
          (%i3) F3 (a + b + c);
          (%o3)                 F3(c) + F3(b) + F3(a)

 -- Eigenschaft: antisymmetric
     `declare(f, antisymmetric)' deklariert die Funktion `f' als
     antisymmetrisch.  Zum Beispiel wird `f(y, x)' zu `- f(x, y)'
     vereinfacht.

     Siehe auch die Eigenschaft `symmetric'  und die Funktion `declare'.

     Beispiel:

          (%i1) S (b, a);
          (%o1)                        S(b, a)
          (%i2) declare (T, antisymmetric);
          (%o2)                         done
          (%i3) T (b, a);
          (%o3)                       - T(a, b)
          (%i4) T (a, c, e, d, b);
          (%o4)                   T(a, b, c, d, e)

 -- Funktion: combine (<expr>)
     Terme einer rationalen Funktion, die denselben Nenner haben, werden
     zusammengefasst.

     Beispiel:

          (%i1) x^2/(1+x)+2*x/(1+x);
                                      2
                                     x       2 x
          (%o1)                     ----- + -----
                                    x + 1   x + 1
          (%i2) combine(%);
                                       2
                                      x  + 2 x
          (%o2)                       --------
                                       x + 1

 -- Eigenschaft: commutative
     `declare(f, commutative)' deklariert die Funktion `f' als
     kommutativ.  Zum Beispiel wird `f(x, z, y)' zu `f(x, y, z)'
     vereinfacht.  Dies hat denselben Effekt wie die Deklaration
     `symmetric'.

     Siehe auch die Funktion `declare'.


 -- Funktion: demoivre (<expr>)
 -- Optionsvariable: demoivre
     Die Funktion `demoivre(expr)' konvertiert den Ausdruck <expr>, ohne
     die Optionsvariable `demoivre' zu setzen.

     Hat die Optionsvariable `demoivre' den Wert `true', werden komplexe
     Exponentialfunktionen in äquivalente Kreisfunktionen umgewandelt.
     `exp(a + b*%i)' wird zu `%e^a*(cos(b)+%i*sin(b))' vereinfacht,
     wenn `b' frei von der imaginären Einheit `%i' ist.  `a' und `b'
     werden nicht expandiert.

     Der Standardwert von `demoivre' ist `false'.

     Siehe auch die Funktion `exponentialize',  um trigonometrische und
     hyperbolische Funktionen in eine Exponentialform zu konvertieren.
     `demoivre' und `exponentialize' können nicht gleichzeitig den Wert
     `true' haben.

 -- Funktion: distrib (<expr>)
     Summen werden ausmultipliziert.  Im Unterschied zu der Funktion
     `expand'  wird `distrib' nur auf der obersten Ebene eines
     Ausdruckes angewendet und ist daher schneller als `expand'.  Im
     Unterschied zu der Funktion `multthru'  werden die Summen der
     obersten Ebenen vollständig ausmultipliziert.

     Beispiele:

          (%i1) distrib ((a+b) * (c+d));
          (%o1)                 b d + a d + b c + a c
          (%i2) multthru ((a+b) * (c+d));
          (%o2)                 (b + a) d + (b + a) c
          (%i3) distrib (1/((a+b) * (c+d)));
                                          1
          (%o3)                    ---------------
                                   (b + a) (d + c)
          (%i4) expand (1/((a+b) * (c+d)), 1, 0);
                                          1
          (%o4)                 ---------------------
                                b d + a d + b c + a c

 -- Optionsvariable: distribute_over
     Standardwert: `true'

     Die Optionsvariable `distribute_over' kontrolliert die Anwendung
     von Funktionen auf Listen, Matrizen oder Gleichungen.  Diese
     Eigenschaft wird nicht angewendet, wenn `distribute_over' den Wert
     `false' hat.

     Beispiele:

     Die Funktion `sin'  wird auf eine Liste angewendet.

          (%i1) sin([x,1,1.0]);
          (%o1)                 [sin(x), sin(1), .8414709848078965]

     Die Funktion `mod'  hat zwei Argumente, die auf Listen angewendet
     werden kann.  Die Funktion kann auch auf verschachtelte Listen
     angewendet werden.

          (%i2) mod([x,11,2*a],10);
          (%o2)                    [mod(x, 10), 1, 2 mod(a, 5)]
          (%i3) mod([[x,y,z],11,2*a],10);
          (%o3)       [[mod(x, 10), mod(y, 10), mod(z, 10)], 1, 2 mod(a, 5)]

     Anwendung der Funktion `floor'  auf eine Matrix und eine Gleichung.

          (%i4) floor(matrix([a,b],[c,d]));
                                      [ floor(a)  floor(b) ]
          (%o4)                       [                    ]
                                      [ floor(c)  floor(d) ]
          (%i5) floor(a=b);
          (%o5)                         floor(a) = floor(b)

     Funktionen mit mehreren Argumenten können auf Listen für eines der
     Argumente oder alle Argumente angewendet werden.

          (%i6) expintegral_e([1,2],[x,y]);
          (%o6) [[expintegral_e(1, x), expintegral_e(1, y)],
                 [expintegral_e(2, x), expintegral_e(2, y)]]

 -- Optionsvariable: domain
     Standardwert: `real'

     Hat `domain' den Wert `complex', wird `sqrt(x^2)' nicht zu
     `abs(x)' vereinfacht.

 -- Eigenschaft: evenfun
 -- Eigenschaft: oddfun
     Erhält eine Funktion oder ein Operator mit der Funktion `declare'
     die Eigenschaft `evenfun' oder `oddfun' wird die Funktion oder der
     Operator von Maxima als gerade und ungerade interpretiert.  Diese
     Eigenschaft wird bei der Vereinfachung von Ausdrücken von Maxima
     angewendet.

     Beispiele:

          (%i1) o (- x) + o (x);
          (%o1)                     o(x) + o(- x)
          (%i2) declare (o, oddfun);
          (%o2)                         done
          (%i3) o (- x) + o (x);
          (%o3)                           0
          (%i4) e (- x) - e (x);
          (%o4)                     e(- x) - e(x)
          (%i5) declare (e, evenfun);
          (%o5)                         done
          (%i6) e (- x) - e (x);
          (%o6)                           0

 -- Funktion: expand (<expr>)
 -- Funktion: expand (<expr>, <p>, <n>)
     Expandiert den Ausdruck <expr>.  Produkte von Summen und Potenzen
     von Summen werden ausmultipliziert.  Die Nenner von rationalen
     Ausdrücken, die Summen sind, werden in ihre Terme aufgespalten.
     Produkte (kommutative und nicht-kommutative) werden in Summen
     herein multipliziert.

     Für Polynome ist es besser, die Funktion `ratexpand'  zu
     verwenden, welche für diesen Fall einen effizienteren Algorithmus
     hat.

     `maxnegex'  und `maxposex'  kontrollieren den maximalen negativen
     und positiven Exponenten, für die ein Ausdruck expandiert wird.

     `expand(<expr>, <p>, <n>)' expandiert <expr>, wobei `maxposex' den
     Wert <p> und `maxnegex' den Wert <n> erhalten.

     `expon'  ist der größte negative Exponent, für den ein Ausdruck
     automatisch expandiert wird.  Hat zum Beispiel `expon' den Wert 4,
     wird `(x+1)^(-5)' nicht automatisch expandiert.

     `expop'  ist der größte positive Exponent, für den ein Ausdruck
     automatisch expandiert wird.  So wird `(x+1)^3' dann automatisch
     expandiert, wenn `expop' größer oder gleich 3 ist.  Soll `(x+1)^n'
     mit der Funktion `expand' expandiert werden, weil `n' größer als
     `expop' ist, dann ist dies nur möglich, wenn `n' kleiner als
     `maxposex' ist.

     `expand(expr,0,0)' bewirkt eine erneuerte vollständige
     Vereinfachung des Ausdrucks <expr>.  Der Ausdruck wird nicht
     erneuert ausgewertet.  Im Unterschied zum Kommando `ev(expr,
     noeval)' wird eine spezielle Darstellung (zum Beispiel eine
     CRE-Form) nicht entfernt.  Siehe auch `ev'.

     Das `expand'-Flag wird mit `ev' verwendet, um einen Ausdruck zu
     expandieren.

     Die Datei `simplification/facexp.mac' enthält weitere Funktionen
     wie `facsum',  `factorfacsum'  und `collectterms'  und Variablen
     wie `nextlayerfactor'  und `facsum_combine' , um Ausdrücke zu
     vereinfachen.  Diese Funktionen werden automatisch geladen und
     erlauben spezielle Expansionen von Ausdrücken.  Eine kurze
     Beschreibung ist in der Datei `simplification/facexp.usg'
     enthalten.  Eine Demo kann mit `demo(facexp)' ausgeführt werden.

     Beispiele:

          (%i1) expr:(x+1)^2*(y+1)^3;
                                         2        3
          (%o1)                   (x + 1)  (y + 1)
          (%i2) expand(expr);
                 2  3        3    3      2  2        2      2      2
          (%o2) x  y  + 2 x y  + y  + 3 x  y  + 6 x y  + 3 y  + 3 x  y
                                                                2
                                               + 6 x y + 3 y + x  + 2 x + 1
          (%i3) expand(expr,2);
                         2        3              3          3
          (%o3)         x  (y + 1)  + 2 x (y + 1)  + (y + 1)
          (%i4) expr:(x+1)^-2*(y+1)^3;
                                             3
                                      (y + 1)
          (%o4)                       --------
                                             2
                                      (x + 1)
          (%i5) expand(expr);
                      3               2
                     y             3 y            3 y             1
          (%o5) ------------ + ------------ + ------------ + ------------
                 2              2              2              2
                x  + 2 x + 1   x  + 2 x + 1   x  + 2 x + 1   x  + 2 x + 1
          (%i6) expand(expr, 2, 2);
                                             3
                                      (y + 1)
          (%o6)                     ------------
                                     2
                                    x  + 2 x + 1

     Vereinfache einen Ausdruck erneut:

          (%i7) expr:(1+x)^2*sin(x);
                                          2
          (%o7)                    (x + 1)  sin(x)
          (%i8) exponentialize:true;
          (%o8)                         true
          (%i9) expand(expr, 0, 0);
                                      2    %i x     - %i x
                            %i (x + 1)  (%e     - %e      )
          (%o9)           - -------------------------------
                                           2

 -- Funktion: expandwrt (<expr>, <x_1>, ..., <x_n>)
     Expandiert den Ausdruck `expr' in Bezug auf die Variablen <x_1>,
     ..., <x_n>.  Alle Produkte, die die Variablen enthalten, werden
     ausmultipliziert.  Das Ergebnis ist frei von Produkten von Summen,
     die nicht frei von den Variablen sind.  <x_1>, ..., <x_n> können
     Variable, Operatoren oder Ausdrücke sein.

     Standardmäßig wird der Nenner eines rationalen Ausdrucks nicht
     expandiert.  Dies kann mit der Optionsvariablen `expandwrt_denom'
     kontrolliert werden.

     Die Funktion wird automatisch aus der Datei
     `simplification/stopex.mac' geladen.

 -- Optionsvariable: expandwrt_denom
     Standardwert: `false'

     `expandwrt_denom' kontrolliert die Behandlung von rationalen
     Ausdrücken durch die Funktion `expandwrt'.  Ist der Wert `true',
     werden der Zähler und der Nenner eines rationalen Ausdrucks
     expandiert.  Ist der Wert `false', wird allein der Zähler
     expandiert.

 -- Funktion: expandwrt_factored (<expr>, <x_1>, ..., <x_n>)
     Ist vergleichbar mit der Funktion `expandwrt' , behandelt aber
     Ausdrücke verschieden, die Produkte enthalten.
     `expandwrt_factored' expandiert nur die Faktoren im Ausdruck
     `expr', die die Variablen <x_1>, ..., <x_n> enthalten.

 -- Optionsvariable: expon
     Standardwert: 0

     `expon' ist der größte negative Exponent für den ein Ausdruck
     automatisch expandiert wird.  Hat zum Beispiel `expon' den Wert 4,
     wird `(x+1)^(-5)' nicht automatisch expandiert.  Siehe auch
     `expop'.


 -- Funktion: exponentialize (<expr>)
 -- Optionsvariable: exponentialize
     Die Funktion `exponentialize' konvertiert trigonometrische und
     hyperbolische Funktion die in dem Ausdruck <expr> auftreten in
     Exponentialfunktionen, ohne dass die Optionsvariable
     `exponentialize' gesetzt wird.

     Hat die Optionsvariable `exponentialize' den Wert `true', werden
     trigonometrische und hyperbolischen Funktionen in eine
     Exponentialform konvertiert.  Der Standardwert ist `false'.

     `demoivre'  konvertiert komplexe Exponentialfunktionen in
     trigonometrische und hyperbolische Funktionen.  `exponentialize'
     und `demoivre' können nicht gleichzeitig den Wert `true' haben.

 -- Optionsvariable: expop
     Standardwert: 0

     `expop' ist der größte positive Exponent, für den ein Ausdruck
     automatisch expandiert wird.  So wird `(x+1)^3' dann automatisch
     expandiert, wenn `expop' größer oder gleich 3 ist.  Soll `(x+1)^n'
     mit der Funktion `expand'  expandiert werden, weil `n' größer als
     `expop' ist, dann ist dies nur möglich, wenn `n' kleiner als
     `maxposex'  ist.  Siehe auch `expon'.


 -- Eigenschaft: lassociative
     `declare(f, lassociative)' deklariert `f' als eine
     links-assoziative Funktion.  Zum Beispiel wird `f (f (a,b), f (c,
     d))' zu `f (f (f (a, b), c), d)' vereinfacht.

     Siehe auch die Eigenschaft `rassociative'  und die Funktion
     `declare'.


 -- Eigenschaft: linear
     `declare(f, linear)' deklariert die Funktion `f' als linear.

     Hat die Funktion `f' ein Argument, dann wird `f(x + y)' zu `f(x) +
     f(y)' und `f(a*x)' zu `a*f(x)' vereinfacht.

     Ist `f' eine Funktion mit zwei oder mehr Argumenten, ist die
     Linearität für das erste Argument definiert.  Zum Beispiel wird
     `f(a*x + b, x)' zu `a f(x, x) + f(1, x) b' vereinfacht.

     `linear' ist äquivalent zu `additive'  und `outative'.    Siehe
     auch `opproperties'  und die Funktion `declare'.

     Beispiel:

          (%i1) 'sum (F(k) + G(k), k, 1, inf);
                                 inf
                                 ====
                                 \
          (%o1)                   >    (G(k) + F(k))
                                 /
                                 ====
                                 k = 1
          (%i2) declare (nounify (sum), linear);
          (%o2)                         done
          (%i3) 'sum (F(k) + G(k), k, 1, inf);
                               inf          inf
                               ====         ====
                               \            \
          (%o3)                 >    G(k) +  >    F(k)
                               /            /
                               ====         ====
                               k = 1        k = 1

 -- Optionsvariable: maxnegex
     Standardwert: 1000

     `maxnegex' ist der größte negative Exponent, der von der Funktion
     `expand'  exandieren wird.  Siehe auch `maxposex'.


 -- Optionsvariable: maxposex
     Standardwert: 1000

     `maxposex' ist der größte positive Exponent, der von der Funktion
     `expand'  expandiert wird.  Siehe auch `maxnegex'.


 -- Eigenschaft: multiplicative
     `declare(f, multiplicative)' deklariert die Funktion `f' als
     multiplikativ.

     Hat die Funktion `f' ein Argument, dann wird `f(x*y)' zu
     `f(x)*f(y)' vereinfacht.

     Ist `f' eine Funktion mit zwei oder mehr Argumenten, ist die
     Multiplikativität für das erste Argument definiert.  Zum Beispiel
     wird `f(a*x + b, x)' zu `f(g(x), x)*f(h(x), x)' vereinfacht.

     Diese Vereinfachung werden nicht für Ausdrücke der Form
     `product(x[i], i, m, n)' ausgeführt.

     Siehe auch die Funktion `declare'.

     Beispiel:

          (%i1) F2 (a * b * c);
          (%o1)                       F2(a b c)
          (%i2) declare (F2, multiplicative);
          (%o2)                         done
          (%i3) F2 (a * b * c);
          (%o3)                   F2(a) F2(b) F2(c)

 -- Funktion: multthru (<expr>)
 -- Funktion: multthru (<expr_1>, <expr_2>)
     Multipliziert einen oder mehrere Faktoren in eine Summe herein.
     `multthru' expandiert keine Potenzen von Summen.  `multthru' ist
     die effizienteste Methode, um Produkte von Summen
     auszumultiplizieren.  Da Maxima intern die Division als ein
     Produkt darstellt, kann `multthru' auch angewendet werden, um
     einen Nenner in eine Summe hereinzumultiplizieren.

     `multthru(<expr_1>, <expr_2>)' multipliziert jeden Term des
     Ausdrucks <expr_2> mit <expr_1>.  Der Ausdruck <expr_2> kann dabei
     eine Summe oder eine Gleichung sein.

     Siehe auch die Funktionen `expand'  und `function_distrib'.

          (%i1) x/(x-y)^2 - 1/(x-y) - f(x)/(x-y)^3;
                                1        x         f(x)
          (%o1)             - ----- + -------- - --------
                              x - y          2          3
                                      (x - y)    (x - y)
          (%i2) multthru ((x-y)^3, %);
                                     2
          (%o2)             - (x - y)  + x (x - y) - f(x)
          (%i3) ratexpand (%);
                                     2
          (%o3)                   - y  + x y - f(x)
          (%i4) ((a+b)^10*s^2 + 2*a*b*s + (a*b)^2)/(a*b*s^2);
                                  10  2              2  2
                           (b + a)   s  + 2 a b s + a  b
          (%o4)            ------------------------------
                                            2
                                       a b s
          (%i5) multthru (%);  /* note that this does not expand (b+a)^10 */
                                                  10
                                 2   a b   (b + a)
          (%o5)                  - + --- + ---------
                                 s    2       a b
                                     s
          (%i6) multthru (a.(b+c.(d+e)+f));
          (%o6)            a . f + a . c . (e + d) + a . b
          (%i7) expand (a.(b+c.(d+e)+f));
          (%o7)         a . f + a . c . e + a . c . d + a . b

 -- Eigenschaft: nary
     Erhält eine Funktion oder ein Operator mit der Funktion `declare'
     die Eigenschaft `nary', werden verschachtelte Anwendungen der
     Funktion oder des Operators wie zum Beispiel `foo(x, foo(y, z))'
     zu `foo(x, y, z)' vereinfacht.  Die Deklaration als `nary'
     unterscheidet sich von der Funktion `nary'.  Während der
     Funktionsaufruf einen neuen Operator definiert, wirkt sich die
     Deklaration nur auf die Vereinfachung aus.

     Beispiel:

          (%i1) H (H (a, b), H (c, H (d, e)));
          (%o1)               H(H(a, b), H(c, H(d, e)))
          (%i2) declare (H, nary);
          (%o2)                         done
          (%i3) H (H (a, b), H (c, H (d, e)));
          (%o3)                   H(a, b, c, d, e)

 -- Optionsvariable: negdistrib
     Standardwert: `true'

     Hat `negdistrib' den Wert `true', wird die Zahl -1 in eine Summe
     hereinmultipliziert.  Zum Beispiel wird `-(x + y)' zu `- y - x'
     vereinfacht.  `true' ist der Standardwert von `negdistrib'.

     Erhält `negdistrib' den Wert `false' wird `-(x + y)' nicht
     vereinfacht.  `negdistrib' sollte sehr umsichtig und nur in
     speziellen Fällen für lokale Vereinfachungen genutzt werden.

 -- Systemvariable: opproperties
     `opproperties' ist eine Liste mit den Eigenschaften, die eine
     Funktion oder ein Operator erhalten kann und die die Vereinfachung
     der Funktionen und Operatoren kontrollieren.  Diese Eigenschaften
     erhalten die Funktionen und Operatoren mit der Funktion `declare'.
      Es gibt weitere Eigenschaften, die Funktionen, Operatoren und
     Variablen erhalten können.  Die Systemvariable `features'  enthält
     eine vollständige Liste der Eigenschaften, die in Maximas
     Datenbank eingetragen werden.  Darüberhinaus können mit der
     Funktion `declare' noch Eigenschaften definiert werden, die in der
     Lisp-Eigenschaftsliste eingetragen werden.

     Die folgenden Eigenschaften sind in der Liste `opproperties'
     enthalten und kontrollieren die Vereinfachung von Funktionen und
     Operatoren:

        linear          additive        multiplicative
        outative        commutative     symmetric
        antisymmetric   nary            lassociativ
        rassociative    evenfun         oddfun

 -- Eigenschaft: outative
     `declare(f, outative)' deklariert eine Funktion `f' als outative.
     Hat der Operator oder die Funktion Argumente mit konstanten
     Faktoren, so werden diese konstanten Faktoren herausgezogen.

     Hat die Funktion `f' ein Argument, dann wird `f(a*x)' zu `a*f(x)'
     vereinfacht, wenn `a' ein konstanter Faktor ist.

     Ist `f' eine Funktion mit zwei oder mehr Argumenten, ist die
     Outativität für das erste Argument definiert.  Zum Beispiel wird
     `f(a*g(x), x)' zu `a*f(g(x),x)' vereinfacht, wenn `a' ein
     konstanter Faktor ist.

     Die Funktionen `sum',  `integrate'  und `limit'  haben die
     Eigenschaft `outative'.  Siehe auch die Funktion `declare'.

     Beispiel:

          (%i1) F1 (100 * x);
          (%o1)                       F1(100 x)
          (%i2) declare (F1, outative);
          (%o2)                         done
          (%i3) F1 (100 * x);
          (%o3)                       100 F1(x)
          (%i4) declare (zz, constant);
          (%o4)                         done
          (%i5) F1 (zz * y);
          (%o5)                       zz F1(y)

 -- Funktion: radcan (<expr>)
     Die Funktion `radcan' vereinfacht Ausdrücke, die die
     Logarithmusfunktion, Exponentialfunktionen und Wurzeln enthalten.

     Beispiele:

          (%i1) radcan((log(x+x^2)-log(x))^a/log(1+x)^(a/2));
                                                     a/2
          (%o1)                            log(x + 1)

          (%i2) radcan((log(1+2*a^x+a^(2*x))/log(1+a^x)));
          (%o2)                                  2

          (%i3) radcan((%e^x-1)/(1+%e^(x/2)));
                                               x/2
          (%o3)                              %e    - 1

 -- Optionsvariable: radexpand
     Standardwert: `true'

     `radexpand' kontrolliert die Vereinfachung von Wurzeln.

     Hat `radexpand' den Wert `all', werden die nten-Wurzeln der
     Faktoren eines Produktes, die eine n-te Potenz sind, aus der
     Wurzel herausgezogen.  Zum Beispiel vereinfacht `sqrt(16*x^2' zu
     `4*x'.

     Inbesondere vereinfacht der Ausdruck `sqrt(x^2)' folgendermaßen:

        * Hat `radexpand' den Wert `all' oder wurde `assume(x>0)'
          ausgeführt, dann vereinfacht `sqrt(x^2)' zu `x'.

        * Hat `radexpand' den Wert `true' und `domain'  ist `real',
          dann vereinfacht `sqrt(x^2)' zu `abs(x)'.

        * Hat `radexpand' den Wert `false' oder hat `radexpand' den Wert
          `true' und `domain'  ist `complex', dann wird `sqrt(x^2)'
          nicht vereinfacht.

 -- Eigenschaft: rassociative
     `declare(f, rassociative)' deklariert die Funktion `f' als
     rechts-assioziativ.  Zum Beispiel wird `f(f(a, b), f(c, d))' zu
     `f(a, f(b, f(c, d)))' vereinfacht.

     Siehe auch die Eigenschaft `lassociative'  und die Funktion
     `declare'.


 -- Funktion: scsimp (<expr>, <rule_1>, ..., <rule_n>)
     Sequential Comparative Simplification (Methode nach Stoute).

     `scsimp' versucht den Ausdruck <expr> mit Hilfe der Regeln
     <rule_1>, ..., <rule_n> zu vereinfachen.  Die Regeln werden
     nacheinander solange angewendet, bis sich der Ausdruck nicht
     weiter vereinfacht.  Führt keine der Regeln zu einem Erfolg, wird
     der ursprüngliche Ausdruck zurückgegeben.

     `example(scsimp)' zeigt einige Beispiele.

 -- Optionsvariable: simp
     Standardwert: `true'

     `simp' kontrolliert die Vereinfachung von Ausdrücken.  Der
     Standardwert von `simp' ist `true' und Ausdrücke werden
     vereinfacht.  `simp' ist auch ein Auswertungsschalter für die
     Funktion `ev'.

     Wird `simp' als ein Auswertungschalter mit dem Wert `false'
     genutzt, dann wird die Vereinfachung nur während der
     Auswertungsphase unterdrückt.  `simp' kann nicht die Vereinfachung
     unterdrücken, die sich der Auswertung anschließt.

     Beispiele:

     Die Vereinfachung wird ausgeschaltet.  Der Ausdruck `sin(1.0)'
     wird nicht zu einem numerischen Wert vereinfacht.  Der
     Auswertungsschalter `simp' schaltet die Vereinfachung ein.

          (%i1) simp:false;
          (%o1)                                false
          (%i2) sin(1.0);
          (%o2)                              sin(1.0)
          (%i3) sin(1.0),simp;
          (%o3)                          .8414709848078965

     Die Vereinfachung wird wieder eingeschaltet.  Der
     Auswertungsschalter `simp' kann die Vereinfachung nicht
     vollständig unterdrücken.  In der Ausgabe ist der Ausdruck
     vereinfacht, aber die Variable `x' enthält einen nicht
     vereinfachten Ausdruck, da die Zuweisung noch während der
     Auswertungsphase des Ausdrucks vorgenommen wurde.

          (%i4) simp:true;
          (%o4)                                true
          (%i5) x:sin(1.0),simp:false;
          (%o5)                          .8414709848078965
          (%i6) :lisp $X
          ((%SIN) 1.0)

 -- Eigenschaft: symmetric
     `declare(f, symmetric)' deklariert die Funktion `f' als
     symmetrisch.  Zum Beispiel wird `f(x, z, y)' zu `f(x, y, z)'
     vereinfacht.

     `commutative'  entspricht `symmetric'  Siehe auch die Funktion
     `declare'.

     Beispiel:

          (%i1) S (b, a);
          (%o1)                        S(b, a)
          (%i2) declare (S, symmetric);
          (%o2)                         done
          (%i3) S (b, a);
          (%o3)                        S(a, b)
          (%i4) S (a, c, e, d, b);
          (%o4)                   S(a, b, c, d, e)

 -- Funktion: xthru (<expr>)
     Die Terme einer Summe des Ausdrucks <expr> werden so
     zusammengefasst, dass sie einen gemeinsamen Nenner haben.
     Produkte und Potenzen von Summen werden dabei nicht expandiert.
     Gemeinsame Faktoren im Zähler und Nenner werden gekürzt.

     Es kann vorteilhaft sein, vor dem Ausführen von `ratsimp'
     zunächst mit `xthru' die gemeinsamen Faktoren eines rationalen
     Ausdrucks zu kürzen.

     Siehe auch die Funktion `combine'.

     Beispiele:

          (%i1) ((x+2)^20 - 2*y)/(x+y)^20 + (x+y)^(-19) - x/(x+y)^20;
                                          20
                           1       (x + 2)   - 2 y       x
          (%o1)        --------- + --------------- - ---------
                              19             20             20
                       (y + x)        (y + x)        (y + x)
          (%i2) xthru (%);
                                           20
                                    (x + 2)   - y
          (%o2)                     -------------
                                             20
                                      (y + x)


File: maxima.info,  Node: Mathematische Funktionen,  Next: Maximas Datenbank,  Prev: Vereinfachung,  Up: Top

10 Mathematische Funktionen
***************************

* Menu:

* Funktionen für Zahlen::
* Funktionen für komplexe Zahlen::
* Funktionen der Kombinatorik::
* Wurzel-, Exponential- und Logarithmusfunktion::
* Winkelfunktionen::
* Hyperbelfunktionen::
* Zufallszahlen::


File: maxima.info,  Node: Funktionen für Zahlen,  Next: Funktionen für komplexe Zahlen,  Prev: Mathematische Funktionen,  Up: Mathematische Funktionen

10.1 Funktionen für Zahlen
==========================

 -- Funktion: abs (<z>)
     Die Funktion `abs' ist die Betragsfunktion und für das numerische
     und symbolische Rechnen geeignet.  Ist das Argument <z> eine
     reelle oder komplexe Zahl wird der Betrag berechnet.  Wenn möglich
     werden allgemeine Ausdrücke mit der Betragsfunktion vereinfacht.
     Maxima kann Ausdrücke mit der Betragsfunktion integrieren und
     ableiten sowie Grenzwerte von Ausdrücken mit der Betragsfunktion
     ermitteln.  Das Paket `abs_integrate'  erweitert Maximas
     Möglichkeiten, Integrale mit der Betragsfunktion zu lösen.

     Die Betragsfunktion wird automatisch auf die Elemente von Listen
     und Matrizen sowie auf die beiden Seiten von Gleichungen
     angewendet.  Siehe `distribute_over'.

     Siehe die Funktion `cabs',  um den Betrag eines komplexen Ausdrucks
     oder einer Funktion zu berechnen.

     Beispiele:

     Berechnung des Betrages für reelle und komplexen Zahlen sowie
     numerische Konstanten und unendliche Größen.  Das erste Beispiel
     zeigt, wie die Betragsfunktion von Maxima auf die Elemente einer
     Liste angewendet wird.

          (%i1) abs([-4, 0, 1, 1+%i]);
          (%o1)                  [4, 0, 1, sqrt(2)]

          (%i2) abs((1+%i)*(1-%i));
          (%o2)                           2
          (%i3) abs(%e+%i);
                                          2
          (%o3)                    sqrt(%e  + 1)
          (%i4) abs([inf, infinity, minf]);
          (%o4)                   [inf, inf, inf]

     Vereinfachung von Ausdrücken mit der Betragsfunktion.

          (%i5) abs(x^2);
                                          2
          (%o5)                          x
          (%i6) abs(x^3);
                                       2
          (%o6)                       x  abs(x)

          (%i7) abs(abs(x));
          (%o7)                       abs(x)
          (%i8) abs(conjugate(x));
          (%o8)                       abs(x)

     Ableitung und Integrale mit der Betragsfunktion.  Wird das Paket
     abs_integrate  geladen, können weitere Integrale mit der
     Betragsfunktion gelöst werden.  Das letzte Beispiel zeigt die
     Laplacetransformation der Betragsfunktion.  Siehe `laplace'.

          (%i9) diff(x*abs(x),x),expand;
          (%o9)                       2 abs(x)

          (%i10) integrate(abs(x),x);
                                       x abs(x)
          (%o10)                       --------
                                          2

          (%i11) integrate(x*abs(x),x);
                                     /
                                     [
          (%o11)                     I x abs(x) dx
                                     ]
                                     /

          (%i12) load(abs_integrate)$
          (%i13) integrate(x*abs(x),x);
                                2           3
                               x  abs(x)   x  signum(x)
          (%o13)               --------- - ------------
                                   2            6

          (%i14) integrate(abs(x),x,-2,%pi);
                                         2
                                      %pi
          (%o14)                      ---- + 2
                                       2

          (%i15) laplace(abs(x),x,s);
                                         1
          (%o15)                         --
                                          2
                                         s

 -- Funktion: ceiling (<x>)
     Die Funktion `ceiling' ist für das numerische und symbolische
     Rechnen geeignet.

     Ist das Argument <x> eine reelle Zahl, gibt `ceiling' die kleinste
     ganze Zahl zurück, die größer oder gleich <x> ist.

     Die Funktion `ceiling' gibt auch dann einen numerischen Wert
     zurück, wenn das Argument ein konstanter Ausdruck ist, wie zum
     Beispiel `1+%e', der zu einer reellen Zahl ausgewertet werden
     kann.  In diesem Fall wird der konstante Ausdruck in eine große
     Gleitkommazahl umgewandelt, auf die die Funktion `ceiling'
     angewendet wird.  Aufgrund von Rundungsfehlern bei der Umwandlung
     in Gleitkommazahlen kann es zu Fehlern bei der Berechnung von
     `ceiling' kommen.  Um diese zu minimieren, wird die Anzahl der
     Stellen `fpprec'  für die Berechnung von `ceiling' um drei Stellen
     erhöht.

     Ist das Argument <expr> der Funktion ein komplexer Ausdruck, wird
     eine Substantivform zurückgegeben.

     Wenn möglich werden Ausdrücke mit der Funktion `ceiling' von Maxima
     vereinfacht.  Maxima kennt insbesondere Vereinfachungen für den
     Fall, dass das Argument der Funktion `ceiling' ein Ausdruck mit
     den Funktionen `floor'  oder `round'  ist.  Weiterhin werden für
     die Vereinfachung die Aussagen und Fakten der aktiven Kontexte
     herangezogen.  Siehe *note Funktionen und Variablen für Fakten::.

     `ceiling' wird automatisch auf die Elemente von Listen und Matrizen
     sowie auf die beiden Seiten von Gleichungen angewendet.  Siehe
     `distribute_over'.

     Siehe auch die Funktionen `floor'  und `round'.

     Beispiele:

          (%i1) ceiling(ceiling(x));
          (%o1)                      ceiling(x)
          (%i2) ceiling(floor(x));
          (%o2)                       floor(x)
          (%i3) declare (n, integer)$
          (%i4) ceiling([n, abs(n), max (n, 6)]);
          (%o4)               [n, abs(n), max(6, n)]
          (%i5) assume (x > 0, x < 1)$
          (%i6) ceiling (x);
          (%o6)                           1

     Sind die Werte einer Funktion eine Teilmenge der ganzen Zahlen,
     kann diese als `integervalued'  deklariert werden.  Die Funktionen
     `ceiling' und `floor'  können diese Information nutzen, um
     Ausdrücke zu vereinfachen.

          (%i1) declare (f, integervalued)$
          (%i2) floor (f(x));
          (%o2)                         f(x)
          (%i3) ceiling (f(x) - 1);
          (%o3)                       f(x) - 1

     Maxima kennt das Integral der Funktion `ceiling'.

          (%i1) integrate(ceiling(x),x);
                         (- ceiling(x) + 2 x + 1) ceiling(x)
          (%o1)          -----------------------------------
                                          2

 -- Funktion: entier (<x>)
     `entier' ist eine andere Bezeichnung für die Funktion `floor'.
     Siehe `floor'.


 -- Funktion: floor (<x>)
     Die Funktion `floor' ist für das numerische und symbolische Rechnen
     geeignet.

     Ist das Argument <x> eine reelle Zahl, gibt `floor' die größte
     ganze Zahl zurück, die kleiner oder gleich <x> ist.

     Die Funktion `floor' gibt auch dann einen numerischen Wert zurück,
     wenn das Argument ein konstanter Ausdruck ist, wie zum Beispiel
     `1+%e', der zu einer reellen Zahl ausgewertet werden kann.  In
     diesem Fall wird der konstante Ausdruck in eine große
     Gleitkommazahl umgewandelt, auf die die Funktion `floor'
     angewendet wird.  Aufgrund von Rundungsfehlern bei der Umwandlung
     in Gleitkommazahlen kann es zu Fehlern bei der Berechnung von
     `floor' kommen.  Um diese zu minimieren, wird die Anzahl der
     Stellen `fpprec'  für die Berechnung von `floor' um drei Stellen
     erhöht.

     Ist das Argument <x> der Funktion ein komplexer Ausdruck, wird eine
     Substantivform zurückgegeben.

     Wenn möglich werden Ausdrücke mit der Funktion `floor' von Maxima
     vereinfacht.  Maxima kennt insbesondere Vereinfachungen für den
     Fall, dass das Argument der Funktion `floor' ein Ausdruck mit den
     Funktionen `ceiling'  oder `round'  ist.  Weiterhin werden für die
     Vereinfachung die Aussagen und Fakten der aktiven Kontexte
     herangezogen.  Siehe *note Funktionen und Variablen für Fakten::.

     `floor' wird automatisch auf die Elemente von Listen und Matrizen
     sowie auf die beiden Seiten von Gleichungen angewendet.  Siehe
     `distribute_over'.

     Siehe auch die Funktionen `ceiling'  und `round'.

     Beispiele:

          (%i1) floor(ceiling(x));
          (%o1)                      ceiling(x)
          (%i2) floor(floor(x));
          (%o2)                       floor(x)
          (%i3) declare(n, integer);
          (%o3)                         done
          (%i4) floor([n, abs(n), min (n, 6)]);
          (%o4)                [n, abs(n), min(6, n)]
          (%i5) assume(x>0, x<1)$
          (%i6) floor(x);
          (%o6)                           0

     Sind die Werte einer Funktion eine Teilmenge der ganzen Zahlen,
     kann diese als `integervalued'  deklariert werden.  Die Funktionen
     `ceiling'  und `floor' können diese Information nutzen, um
     Ausdrücke zu vereinfachen.

          (%i1) declare (f, integervalued)$
          (%i2) floor(f(x));
          (%o2)                         f(x)
          (%i3) ceiling(f(x) - 1);
          (%o3)                       f(x) - 1

     Maxima kennt das Integral der Funktion `floor'.

          (%i6) integrate(floor(x),x);
                           (- floor(x) + 2 x - 1) floor(x)
          (%o6)            -------------------------------
                                          2

 -- Funktion: fix (<x>)
     `fix' ist eine andere Bezeichnung für die Funktion `floor'.  Siehe
     `floor'.


 -- Funktion: lmax (<L>)
     Ist das Argument <L> eine Liste oder Menge, wird die Funktion `max'
     auf die Elemente der Liste oder Menge angewendet und das Ergebnis
     zurückgegeben.  Ist <L> keine Liste oder Menge, signalisiert
     Maxima einen Fehler.

     Beispiel:

          (%i1) L:[1+%e, %pi, 3];
          (%o1)                   [%e + 1, %pi, 3]
          (%i1) lmax(L);
          (%o1)                        %e + 1

 -- Funktion: lmin (<L>)
     Ist das Argument <L> eine Liste oder Menge, wird die Funktion `min'
     auf die Elemente der Liste oder Menge angewendet und das Ergebnis
     zurückgegeben.  Ist <L> keine Liste oder Menge, signalisiert
     Maxima einen Fehler.

     Beispiel:

          (%i1) L:[1+%e, %pi, 3];
          (%o1)                   [%e + 1, %pi, 3]
          (%i2) lmin(L);
          (%o2)                           3

 -- Funktion: max (<x_1>, ..., <x_n>)
     Sind alle Argumente <x_1>, ..., <x_n> Zahlen oder konstante
     Ausdrücke wie zum Beispiel `1+%e' oder `sin(1)', dann wird der
     größte Zahlenwert zurückgegeben.  Sind symbolische Variablen oder
     allgemeine Ausdrücke unter den Argumenten, gibt Maxima einen
     vereinfachten Ausdruck zurück.  Die unendliche Größen `inf'  und
     `minf'

     können als Argument auftreten.

     Die Vereinfachung der Funktion `max' kann kontrolliert werden, in
     dem mit der Funktion `put'  dem Symbol `trylevel' zu der
     Eigenschaft `maxmin' ein Wert zwischen 1 bis 3 gegeben wird.
     Folgende Werte können mit der Funktion `put' gesetzt werden:

    `put(trylevel, 1, maxmin)'
          `trylevel' hat den Wert 1.  Das ist der Standardwert.  Maxima
          führt keine besonderen Vereinfachungen aus.

    `put(trylevel, 2, maxmin)'
          Maxima wendet die Vereinfachung `max(e,-e) --> |e|' an.

    `put(trylevel, 3, maxima)'
          Maxima wendet die Vereinfachung `max(e,-e) --> |e|' an und
          versucht Ausdrücke zu eliminieren, die zwischen zwei anderen
          Argumenten liegen.  So wird zum Beispiel `max(x, 2*x, 3*x)'
          zu `max(x, 3*x)' vereinfacht.

     Mit dem Kommando `get(trylevel, maxmin)' wird der aktuelle Wert für
     das Symbol `trylevel' angezeigt.  Siehe die Funktion `get'.

     `max' berücksichtigt bei der Vereinfachung von Ausdrücken die
     Aussagen und Fakten der aktiven Kontexte.  Siehe das Kapitel *note
     Funktionen und Variablen für Fakten::.

     Beispiele:

          (%i1) max(1.6, 3/2, 1);
          (%o1)                          1.6
          (%i2) max(1.5b0,1.5,3/2);
                                          3
          (%o2)                           -
                                          2
          (%i3) max(%e,%pi,1,2,3);
          (%o3)                          %pi
          (%i4) max(1+%e,%pi,1,2,3);
          (%o4)                        %e + 1
          (%i5) max(minf,inf);
          (%o5)                          inf
          (%i6) assume(a>b);
          (%o6)                        [a > b]
          (%i7) max(a,b);
          (%o7)                           a

 -- Funktion: min (<x_1>, ..., <x_n>)
     Sind alle Argumente <x_1>, ..., <x_n> Zahlen oder konstante
     Ausdrücke wie zum Beispiel `1+%e' oder `sin(1)', dann wird der
     kleinste Zahlenwert zurückgegeben.  Sind symbolische Variablen oder
     allgemeine Ausdrücke unter den Argumenten, gibt Maxima einen
     vereinfachten Ausdruck zurück.  Die unendliche Größen `inf'  und
     `minf'

     können als Argument auftreten.

     Die Vereinfachung der Funktion `min' kann kontrolliert werden, in
     dem mit der Funktion `put'  dem Symbol `trylevel' zu der
     Eigenschaft `maxmin' ein Wert zwischen 1 bis 3 gegeben wird.
     Folgende Werte können mit der Funktion `put' gesetzt werden:

    `put(trylevel, 1, maxmin)'
          `trylevel' hat den Wert 1.  Das ist der Standardwert.  Maxima
          führt keine besonderen Vereinfachungen aus.

    `put(trylevel, 2, maxmin)'
          Maxima wendet die Vereinfachung `min(e,-e) --> |e|' an.

    `put(trylevel, 3, maxima)'
          Maxima wendet die Vereinfachung `min(e,-e) --> |e|' an und
          versucht Ausdrücke zu eliminieren, die zwischen zwei anderen
          Argumenten liegen.  So wird zum Beispiel `min(x, 2*x, 3*x)'
          zu `min(x, 3*x)' vereinfacht.

     Mit dem Kommando `get(trylevel, maxmin)' wird der aktuelle Wert für
     das Symbol `trylevel' angezeigt.  Siehe die Funktion `get'.

     `min' berücksichtigt bei der Vereinfachung von Ausdrücken die
     Aussagen und Fakten der aktiven Kontexte.  Siehe das Kapitel
     Funktionen und Variablen für Fakten.

     Beispiele:

          (%i1) min(1.6, 3/2, 1);
          (%o1)                           1
          (%i2) min(1.5b0,1.5,3/2);
                                          3
          (%o2)                           -
                                          2
          (%i3) min(%e,%pi,3);
          (%o3)                          %e
          (%i4) min(1+%e,%pi,3);
          (%o4)                           3
          (%i5) min(minf,inf);
          (%o5)                         minf
          (%i6) assume(a>b);
          (%o6)                        [a > b]
          (%i7) min(a,b);
          (%o7)                           b

 -- Funktion: round (<x>)
     Die Funktion `round' ist für das numerische und symbolische Rechnen
     geeignet.

     Ist das Argument <x> eine reelle Zahl, gibt `round' die am
     nächsten liegende ganze Zahl zurück.  Vielfache von 1/2 werden auf
     die nächste gerade ganze Zahl gerundet.

     Die Funktion `round' gibt auch dann einen numerischen Wert zurück,
     wenn das Argument ein konstanter Ausdruck ist, wie zum Beispiel
     `1+%e', der zu einer reellen Zahl ausgewertet werden kann.  In
     diesem Fall wird der konstante Ausdruck in eine große
     Gleitkommazahl umgewandelt, auf die die Funktion `round'
     angewendet wird.  Aufgrund von Rundungsfehlern bei der Umwandlung
     in Gleitkommazahlen kann es zu Fehlern bei der Berechnung von
     `round' kommen.  Um diese zu minimieren, wird die Anzahl der
     Stellen `fpprec'  für die Berechnung von `round' um drei Stellen
     erhöht.

     Ist das Argument <x> der Funktion ein komplexer Ausdruck, wird eine
     Substantivform zurückgegeben.

     Wenn möglich werden Ausdrücke mit der Funktion `round' von Maxima
     vereinfacht.  Maxima kennt insbesondere Vereinfachungen für den
     Fall, dass das Argument der Funktion `round' ein Ausdruck mit den
     Funktionen `ceiling'  oder `floor'  ist.  Weiterhin werden für die
     Vereinfachung die Aussagen und Fakten der aktiven Kontexte
     herangezogen.  Siehe *note Funktionen und Variablen für Fakten::.

     `round' wird automatisch auf die Elemente von Listen und Matrizen
     sowie auf die beiden Seiten von Gleichungen angewendet.  Siehe
     `distribute_over'.

     Siehe auch die Funktionen `ceiling'  und `floor'.

     Beispiele:

          (%i1) round(floor(x));
          (%o1)                       floor(x)
          (%i2) round(round(x));
          (%o2)                       round(x)
          (%i3) declare(n, integer);
          (%o3)                         done
          (%i4) round([n, abs(n), min(n,6)]);
          (%o4)                [n, abs(n), min(6, n)]

     Sind die Werte einer Funktion eine Teilmenge der ganzen Zahlen,
     kann diese als `integervalued'  deklariert werden.  Die Funktion
     `round' kann diese Information nutzen, um Ausdrücke zu
     vereinfachen.

          (%i1) declare(f, integervalued);
          (%o1)                         done
          (%i2) round(f(x));
          (%o2)                         f(x)
          (%i3) round(f(x) - 1);
          (%o3)                       f(x) - 1

 -- Funktion: signum (<z>)
     Die Signumfunktion `signum' ist für das numerische und symbolische
     Rechnen geeignet.  Ist das Argument <z> eine Zahl, ist das
     Ergebnis 0, 1 oder -1, wenn die Zahl Null, positiv oder negativ
     ist.  Das Argument kann auch ein konstanter Ausdruck wie `%pi'
     oder `1+%e' sein.  Ist das Argument <z> eine komplexe Zahl,
     vereinfacht die der Ausdruck `signum(z)' zu `z/abs(z)'.

     Ist das Argument <z> keine Zahl oder kein konstanter Ausdruck,
     versucht Maxima den Ausdruck zu vereinfachen.  Maxima kann die
     Funktion `signum' differenzieren.  Wird das Paket abs_integrate
     geladen, kann Maxima Integrale mit der Funktion `signum' lösen.

     `signum' wird automatisch auf die Elemente von Listen und Matrizen
     sowie auf die beiden Seiten von Gleichungen angewendet.  Siehe
     `distribute_over'.

     Beispiele:

     Ergebnisse für verschiedene Zahlen und konstante Ausdrücke.  Die
     Beispiele zeigen, dass das Ergebnis der Signumfunktion den Typ der
     Zahl erhält.  Die unendlichen Größen `minf'  und `inf'  können als
     Argument auftreten.

          (%i1) signum([-1.5, 0, 0.0, 1.5, 1.5b0, %e, sin(1), cos(4)]);
          (%o1)        [- 1.0, 0, 0.0, 1.0, 1.0b0, 1, 1, - 1]
          (%i2) signum(1+%i);
                                    %i         1
          (%o2)                   ------- + -------
                                  sqrt(2)   sqrt(2)
          (%i3) signum([minf,inf]);
          (%o3)                      [- 1, 1]

     Vereinfachungen der Signumfunktion.

          (%i3) signum(x*y);
          (%o3)                  signum(x) signum(y)
          (%i4) signum(-x);
          (%o4)                      - signum(x)

     Wird das Paket abs_integrate  geladen, kann Maxima Integrale mit
     der Signumfunktion lösen.  Ausdrücke mit der Signumfunktion können
     differenziert werden.

          (%i5) load(abs_integrate)$

          (%i6) integrate(signum(x),x);
          (%o6)                        abs(x)

          (%i7) integrate(sin(x)*signum(x),x);
          (%o7)               (1 - cos(x)) signum(x)

          (%i7) diff(%,x);
          (%o7)                  signum(x) sin(x)


File: maxima.info,  Node: Funktionen für komplexe Zahlen,  Next: Funktionen der Kombinatorik,  Prev: Funktionen für Zahlen,  Up: Mathematische Funktionen

10.2 Funktionen für komplexe Zahlen
===================================

 -- Funktion: cabs (<expr>)
     Berechnet den Betrag eines komplexen Ausdrucks <expr>.  Im
     Unterschied zu der Funktion `abs',  zerlegt die Funktion `cabs'
     einen komplexen Ausdruck immer in einen Realteil und Imaginärteil,
     um den komplexen Betrag zu berechnen.  Sind <x> und <y> zwei
     reelle Variablen oder Ausdrücke, berechnet die Funktion `cabs' den
     Betrag des komplexen Ausdrucks `x + %i*y' als:
                                     2    2
                               sqrt(y  + x )

     Die Funktion `cabs' nutzt Symmetrieeigenschaften und implementierte
     Eigenschaften komplexer Funktionen, um den Betrag eines Ausdrucks
     zu berechnen.  Sind solche Eigenschaften für eine Funktion
     vorhanden, können diese mit der Funktion `properties'  angezeigt
     werden.  Eigenschaften, die das Ergebnis der Funktion `cabs'
     bestimmen, sind: `mirror symmetry', `conjugate function' und
     `complex characteristic'.

     `cabs' ist eine Verbfunktion, die nicht für das symbolische Rechnen
     geeignet ist.  Für das symbolische Rechnen wie der Integration
     oder der Ableitung von Ausdrücken mit der Betragsfunktion muss die
     Funktion `abs' verwendet werden.

     Das Ergebnis der Funktion `cabs' kann die Betragsfunktion `abs'
     und den Arkustangens `atan2'  enthalten.

     `cabs' wird automatisch auf die Elemente von Listen und Matrizen
     sowie auf die beiden Seiten von Gleichungen angewendet.

     Siehe auch die Funktionen `rectform',  `realpart',

     `imagpart',  `carg',  `conjugate',  und `polarform'  für das
     Rechnen mit komplexen Zahlen.

     Beispiele:

     Zwei Beispiele mit der Wurzelfunktion `sqrt'  und der Sinusfunktion
     `sin'.

          (%i1) cabs(sqrt(1+%i*x));
                                       2     1/4
          (%o1)                      (x  + 1)
          (%i2) cabs(sin(x+%i*y));
                              2        2         2        2
          (%o2)       sqrt(cos (x) sinh (y) + sin (x) cosh (y))

     Die Funktion `erf'  hat Spiegelsymmetrie, die hier für die
     Berechnung des komplexen Betrages angewendet wird.

          (%i3) cabs(erf(x+%i*y));
                                                    2
                     (erf(%i y + x) - erf(%i y - x))
          (%o3) sqrt(--------------------------------
                                    4
                                                                         2
                                          (erf(%i y + x) + erf(%i y - x))
                                        - --------------------------------)
                                                         4

     Maxima kennt komplexe Eigenschaften der Besselfunktionen, um den
     komplexen Betrag zu vereinfachen.  Dies ist ein Beispiel für die
     Besselfunktion `bessel_j'.

          (%i4) cabs(bessel_j(1,%i));
          (%o4)                 abs(bessel_j(1, %i))

 -- Funktion: carg (<expr>)
     Gibt das komplexe Argument des Ausdrucks <expr> zurück.  Das
     komplexe Argument ist ein Winkel `theta' im Intervall `(-%pi,
     %pi)' derart, dass <expr> = `r exp (theta %i)' gilt, wobei `r' den
     Betrag des komplexen Ausdrucks <expr> bezeichnet.  Das ist die
     Polarform des Ausdrucks, wie sie auch von der Funktion `polarform'
     zurückgegeben wird.  Der Betrag des komplexen Ausdrucks kann mit
     der Funktion `cabs'  berechnet werden.

     Das Ergebnis der Funktion `carg' kann die Funktion `atan2'
     enthalten.

     `carg' wird automatisch auf die Elemente von Listen und Matrizen
     sowie auf die beiden Seiten von Gleichungen angewendet.  Siehe
     `distribute_over'.

     Die Funktion `carg' ist eine Verbfunktion, mit der nicht symbolisch
     gerechnet werden kann.

     Siehe auch die Funktionen `rectform',  `realpart'  und `imagpart'
     sowie die Funktionen `cabs'  und `conjugate'.

     Beispiele:

          (%i1) carg (1);
          (%o1)                           0
          (%i2) carg (1 + %i);
                                         %pi
          (%o2)                          ---
                                          4
          (%i3) carg (exp (%i));
          (%o3)                           1

          (%i4) carg (exp (3/2 * %pi * %i));
                                          %pi
          (%o4)                         - ---
                                           2
          (%i5) carg(exp(x+%i*y));
          (%o5)                atan2(sin(y), cos(y))

          (%i6) carg(sqrt(x+%i*y));
                                    atan2(y, x)
          (%o6)                     -----------
                                         2
          (%i7) carg(sqrt(1+%i*y));
                                      atan(y)
          (%o7)                       -------
                                         2

 -- Funktion: conjugate (<expr>)
     Gibt den konjugiert komplexen Wert des Ausdrucks <expr> zurück.
     Sind <x> und <y> reelle Variablen oder Ausdrücke, dann hat der
     Ausdruck `x + %i*y' das Ergebnis `x - %i*y'.  Die Funktion
     `conjugate' ist für numerische und symbolische Rechnungen geeignet.

     Maxima kennt Regeln, um den konjugierten Wert für Summen, Produkte
     und Quotienten von komplexen Ausdrücken zu vereinfachen.
     Weiterhin kennt Maxima Symmetrieeigenschaften und komplexe
     Eigenschaften von Funktionen, um den konjugierten Wert mit diesen
     Funktionen zu vereinfachen.  Sind solche Eigenschaften für eine
     Funktion vorhanden, können diese mit der Funktion `properties'
     angezeigt werden.  Eigenschaften, die das Ergebnis der Funktion
     `conjugate' bestimmen, sind: `mirror symmetry', `conjugate
     function' und `complex characteristic'.

     `conjugate' wird automatisch auf die Elemente von Listen und
     Matrizen sowie auf die beiden Seiten von Gleichungen angewendet.
     Siehe `distribute_over'.

     Für das Rechnen mit komplexen Ausdrücken siehe auch die Funktionen
     `cabs'  und `carg'  sowie `rectform'  und `polarform'.

     Beispiele:

     Beispiele mit reellen, imaginären und komplexen Variablen.

          (%i1) declare ([x, y], real, [z1, z2], complex, j, imaginary);
          (%o1)                         done
          (%i2) conjugate(x + %i*y);
          (%o2)                       x - %i y
          (%i3) conjugate(z1*z2);
          (%o3)              conjugate(z1) conjugate(z2)
          (%i4) conjugate(j/z2);
                                           j
          (%o4)                    - -------------
                                     conjugate(z2)

     Im Folgenden nutzt Maxima Symmetrieeigenschaften, um den
     konjugiert komplexen Wert der Funktionen `gamma'  und `sin'  zu
     berechnen.  Die Logarithmusfunktion `log'  hat Spiegelsymmetrie,
     wenn das Argument einen positiven Realteil hat.

          (%i5) conjugate(gamma(x+%i*y));
          (%o5)                    gamma(x - %i y)
          (%i6) conjugate(sin(x+%i*y));
          (%o6)                    - sin(%i y - x)
          (%i7) conjugate(log(x+%i*y));
          (%o7)               conjugate(log(%i y + x))
          (%i8) conjugate(log(1+%i*y));
          (%o8)                     log(1 - %i y)

 -- Funktion: imagpart (<expr>)
     Gibt den Imaginärteil des Ausrucks <expr> zurück.  Intern berechnet
     Maxima den Imaginärteil mit der Funktion `rectform',  die einen
     Ausdruck in den Realteil und in den Imaginärteil zerlegt.  Daher
     treffen die Ausführungen zu `rectform' auch auf die Funktion
     `imagpart' zu.

     Wie die Funktion `rectform' ist auch die Funktion `imagpart' eine
     Verbfunktion, mit der nicht symbolisch gerechnet werden kann.

     `imagpart' wird automatisch auf die Elemente von Listen und
     Matrizen sowie auf die beiden Seiten von Gleichungen angewendet.
     Siehe `distribute_over'.

     Mit der Funktion `realpart'  wird der Realteil eines Ausdrucks
     berechnet.

     Siehe auch die Funktionen `cabs',  `carg'  und `conjugate'  für
     das Rechnen mit komplexen Zahlen.  Mit der Funktion `polarform'
     kann ein komplexer Ausdruck in die Polarform gebracht werden.

     Beispiele:

     Für weitere Erläuterungen dieser Beispiele siehe auch die Funktion
     `rectform'.

          (%i1) imagpart((2-%i)/(1-%i));
                                          1
          (%o1)                           -
                                          2
          (%i2) imagpart(sin(x+%i*y));
          (%o2)                    cos(x) sinh(y)
          (%i3) imagpart(gamma(x+%i*y));
                       %i (gamma(x - %i y) - gamma(%i y + x))
          (%o3)        --------------------------------------
                                         2
          (%i4) imagpart(bessel_j(1,%i));
          (%o4)                    bessel_j(1, %i)

 -- Funktion: polarform (<expr>)
     Gibt den Ausdruck <expr> in der Polarform `r %e^(%i theta)' zurück.
     `r' ist der Betrag des komplexen Ausdrucks, wie er auch mit der
     Funktion `cabs'  berechnet werden kann.  `theta' ist das Argument
     des komplexen Ausdrucks, das mit der Funktion `carg'  berechnet
     werden kann.

     Maxima kennt komplexe Eigenschaften von Funktionen, die bei der
     Berechnung der Polarform angewendet werden.  Siehe die Funktion
     `cabs'  für weitere Erläuterungen.

     Wenn mit komplexen Ausdrücken in der Polarform gerechnet werden
     soll, ist es hilfreich die Optionsvariable `%emode'  auf den Wert
     `false' zu setzen.  Damit wird verhindert, dass Maxima komplexe
     Ausdrücke mit der Exponentialfunktion `exp'  automatisch in die
     Standardform vereinfacht.

     `polarform' wird automatisch auf die Elemente von Listen und
     Matrizen sowie auf die beiden Seiten von Gleichungen angewendet.
     Siehe `distribute_over'.

     Die Funktion `polarform' ist eine Verbfunktion, mit der nicht
     symbolisch gerechnet werden kann.

     Siehe auch die Funktionen `cabs',  `carg'  und `conjugate'  für
     das Rechnen mit komplexen Zahlen.  Mit der Funktion `rectform'
     kann ein komplexer Ausdruck in die Standardform gebracht werden.

     Beispiele:

     Die allgemeine Polarform eines komplexen Ausdrucks.  Die Variablen
     <x> und <y> werden von Maxima als reell angenommen.

          (%i1) polarform(x+%i*y);
                                 2    2    %i atan2(y, x)
          (%o1)            sqrt(y  + x ) %e

     Die Polarform einer komplexen Zahl und eines Ausdrucks mit einer
     reellen Variablen <x>.

          (%i2) polarform(4/5+3*%i/5);
                                     %i atan(3/4)
          (%o2)                    %e
          (%i3) polarform(sqrt(1+%i*x));
                                            %i atan(x)
                                            ----------
                                2     1/4       2
          (%o3)               (x  + 1)    %e

     Wenn in der Polarform gerechnet werden soll, ist es hilfreich die
     Optionsvariable `%emode'  auf den Wert `false' zu setzen.  Damit
     wird verhindert, dass Maxima komplexe Ausdrücke mit der
     Exponentialfunktion `exp'  automatisch in eine Standardform
     vereinfacht.

          (%i4) z:polarform(1+%i);
                                            %i %pi
                                            ------
                                              4
          (%o4)                   sqrt(2) %e
          (%i5) z^3;
                               3/2    %i         1
          (%o5)               2    (------- - -------)
                                    sqrt(2)   sqrt(2)
          (%i6) %emode:false;
          (%o6)                         false
          (%i7) z^3;
                                          3 %i %pi
                                          --------
                                    3/2      4
          (%o7)                    2    %e

 -- Funktion: realpart (<expr>)
     Gibt den Realteil des Ausdrucks <expr> zurück.  Intern berechnet
     Maxima den Realteil mit der Funktion `rectform',  die einen
     Ausdruck in den Realteil und in den Imaginärteil zerlegt.  Daher
     treffen die Ausführungen zu `rectform' auch auf die Funktion
     `realpart' zu.

     Wie die Funktion `rectform' ist auch die Funktion `realpart' eine
     Verbfunktion, mit der nicht symbolisch gerechnet werden kann.

     `realpart' wird automatisch auf die Elemente von Listen und
     Matrizen sowie auf die beiden Seiten von Gleichungen angewendet.
     Siehe `distribute_over'.

     Mit der Funktion `imagpart'  wird der Imaginärteil eines Ausdrucks
     berechnet.

     Siehe auch die Funktionen `cabs',  `carg'  und `conjugate'  für
     das Rechnen mit komplexen Zahlen.  Mit der Funktion `polarform'
     kann ein komplexer Ausdruck in die Polarform gebracht werden.

     Beispiele:

     Für weitere Erläuterungen dieser Beispiele siehe auch die Funktion
     `rectform'.

          (%i1) realpart((2-%i)/(1-%i));
                                          3
          (%o1)                           -
                                          2
          (%i2) realpart(sin(x+%i*y));
          (%o2)                    sin(x) cosh(y)
          (%i3) realpart(gamma(x+%i*y));
                          gamma(%i y + x) + gamma(x - %i y)
          (%o3)           ---------------------------------
                                          2
          (%i4) realpart(bessel_j(1,%i));
          (%o4)                           0

 -- Funktion: rectform (<expr>)
     Zerlegt den Ausdruck <expr> in den Realteil `a' und den
     Imaginärteil `b' und gibt den komplexen Ausdruck in der
     Standardform `a + b %i' zurück.

     Die Funktion `rectform' nutzt Symmetrieeigenschaften und
     implementierte Eigenschaften komplexer Funktionen, um den Realteil
     und Imaginärteil eines komplexen Ausdrucks zu berechnen.  Sind
     solche Eigenschaften für eine Funktion vorhanden, können diese mit
     der Funktion `properties'  angezeigt werden.  Eigenschaften, die
     das Ergebnis der Funktion `rectform' bestimmen, sind: `mirror
     symmetry', `conjugate function' und `complex characteristic'.

     `rectform' ist eine Verbfunktion, die nicht für das symbolische
     Rechnen geeignet ist.

     `rectform' wird automatisch auf die Elemente von Listen und
     Matrizen sowie auf die beiden Seiten von Gleichungen angewendet.
     Siehe `distribute_over'.

     Die Funktionen `realpart'  und `imagpart'  geben jeweils allein den
     Realteil und den Imaginärteil eines Ausdrucks zurück.  Um einen
     Ausdruck in die Polarform zu bringen, kann die Funktion `polarform'
     verwendet werden.

     Siehe auch die Funktionen `cabs',  `carg'  und `conjugate'  für
     das Rechnen mit komplexen Zahlen.

     Beispiele:

     Zerlegung eines komplexen Ausdrucks und der Sinusfunktion `sin'
     in den Realteil und Imaginärteil.  Maxima kennt komplexe
     Eigenschaften der trigonometrischen Funktionen, um den Realteil
     und den Imaginärteil zu bestimmen.

          (%i1) rectform((2-%i)/(1-%i));
                                       %i   3
          (%o1)                        -- + -
                                       2    2
          (%i2) rectform(sin(x+%i*y));
          (%o2)          %i cos(x) sinh(y) + sin(x) cosh(y)

     Bei der Zerlegung in einen Realteil und einen Imaginärteil nutzt
     Maxima die Spiegelsymmetrie der Gammfunktion `gamma'.    Die
     Eigenschaft der Spiegelsymmetrie wird mit der Funktion `properties'
     angezeigt, der Eintrag lautet `mirror symmetry'.

          (%i3) properties(gamma);
          (%o3)    [mirror symmetry, noun, rule, gradef, transfun]

          (%i4) rectform(gamma(x+%i*y));
                gamma(%i y + x) + gamma(x - %i y)
          (%o4) ---------------------------------
                                2
                                          gamma(x - %i y) - gamma(%i y + x)
                                        - ---------------------------------
                                                          2

     Maxima kennt komplexe Eigenschaften der Besselfunktionen.  Die
     Besselfunktion `bessel_j'  ist für eine ganzzahlige Ordnung und
     einem imaginären Argument rein imaginär.

          (%i5) rectform(bessel_j(1,%i));
          (%o5)                  %i bessel_j(1, %i)


File: maxima.info,  Node: Funktionen der Kombinatorik,  Next: Wurzel-, Exponential- und Logarithmusfunktion,  Prev: Funktionen für komplexe Zahlen,  Up: Mathematische Funktionen

10.3 Funktionen der Kombinatorik
================================

 -- Operator: !!
     Ist der Operator der doppelten Fakultät.

     Für eine positive ganze Zahl `n', wird `n!!' zu dem Produkt `n
     (n-2) (n-4) (n-6) ... (n - 2 (k-1))' vereinfacht, wobei `k' gleich
     `floor(n/2)' ist und `floor'  die größte ganze Zahl als Ergebnis
     hat, die kleiner oder gleich `n/2' ist.

     Für ein Argument `n', das keine ganze positive Zahl ist, gibt `n!!'
     die Substantivform `genfact(n, n/2,2)' zurück.  Siehe die Funktion
     `genfact'.

     Die Verallgemeinerung der doppelten Fakultät für reelle und
     komplexe Zahlen ist als die Funktion `double_factorial'
     implementiert.

     Beispiele:

          (%i1) [0!!, 1!!, 2!!, 3!!, 4!!, 5!!, 6!!, 7!!, 8!!];
          (%o1)           [1, 1, 2, 3, 8, 15, 48, 105, 384]
          (%i2) 1.5!!;
          (%o2)                  genfact(1.5, 0, 2)
          (%i3) x!!;
                                             x
          (%o3)                   genfact(x, -, 2)
                                             2

 -- Funktion: binomial (<x>, <y>)
     Ist der Binominialkoeffizient, der definiert ist als
                                            x!
                       binomial(x, y) = -----------
                                        (x - y)! y!

     Die Funktion `binomial' ist für das numerische und symbolische
     Rechnen geeignet.

     Sind die Argumente <x> oder <y> ganze Zahlen, wird der
     Binominialkoeffizient zu einer ganzen Zahl vereinfacht.  Sind die
     Argumente <x> und <y> reelle oder komplexe Gleitkommazahlen, wird
     der Binominialkoeffizient mit der entsprechenden verallgemeinerten
     Fakultät berechnet.  Siehe auch `factorial'  und `gamma'.

     Ist das Argument <y> oder die Differenz <x-y> eine ganz Zahl, wird
     der Binominialkoeffizient zu einem Polynom vereinfacht.

     Mit den Funktionen `makefact'  oder `makegamma'  werden
     Binominialkoeffizienten in einem Ausdruck durch äquivalente
     Ausdrücke mit der Fakultät oder der Gammafunktion ersetzt.

     Maxima kennt die Ableitung des Binominialkoeffizienten nach den
     Argumenten <x> und <y>.

     Beispiele:

          (%i1) binomial(11, 7);
          (%o1)                          330
          (%i2) binomial(%i, 1.5);
          (%o2)       .3693753994635863 %i - .7573400496142132
          (%i3) binomial(x, 3);
                                  (x - 2) (x - 1) x
          (%o3)                   -----------------
                                          6
          (%i4) binomial(x+3, 3);
                               (x + 1) (x + 2) (x + 3)
          (%o4)                -----------------------
                                          6
          (%i5) makefact(binomial(x,y));
                                         x!
          (%o5)                      -----------
                                     (x - y)! y!

          (%i6) diff(binomial(x,y), y);
          (%o6)  - binomial(x, y) (psi (y + 1) - psi (- y + x + 1))
                                      0             0

 -- Funktion: double_factorial (z)
     Ist die doppelte Fakultät, die allgemein definiert ist als
                         2  1/4 (1 - cos(z %pi))  z/2       z
                       (---)                     2    gamma(- + 1)
                        %pi                                 2

     Die Funktion `double_factorial' ist für das numerische und
     symbolische Rechnen geeignet.  Ist das Argument <z> eine ganze
     Zahl, eine Gleitkommazahl, eine große Gleitkommazahl oder eine
     komplexe Gleitkommazahl, dann wird ein numerisches Ergebnis
     berechnet.  Für eine positive ganze Zahl ist das Ergebnis gleich
     dem Ergebnis des Operators der doppelten Fakultät `!!' .  Für
     rationale Zahlen ist das Ergebnis eine Substantivform.

     Für negative gerade ganze Zahlen ist die Funktion
     `double_factorial' nicht definiert.

     Hat die Optionsvariable `factorial_expand'  den Wert `true',
     vereinfacht Maxima `double_factorial' für das Argument `n-1' und
     für Argumente `n+2*k', wobei `k' eine ganze Zahl ist.

     Maxima kennt die Ableitung der Funktion `double_factorial'.

     `double_factorial' wird automatisch auf die Elemente von Listen und
     Matrizen sowie auf die beiden Seiten von Gleichungen angewendet.
     Siehe `distribute_over'.

     Beispiele:

     Numerische Ergebnisse für ganze Zahlen, Gleitkommazahlen und
     komplexen Gleitkommazahlen.

          (%i1) double_factorial([-3, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o1) [- 1, 1, 1, 1, 2, 3, 8, 15, 48, 105, 384, 945, 3840]

          (%i2) double_factorial([1.5, 1.5b0, 0.5+%i, 0.5b0+%i]);
          (%o2) [1.380662681753386, 1.380662681753387b0,
          .4186422526242637 - .7218816624466643 %i,
          4.186422526242633b-1 - 7.218816624466641b-1 %i]

     Vereinfachungen, wenn die Optionsvariable `factorial_expand'  den
     Wert `true' hat.

          (%i3) factorial_expand:true;
          (%o3)                         true
          (%i4) double_factorial(n-1);
                                         n!
          (%o4)                  -------------------
                                 double_factorial(n)
          (%i5) double_factorial(n+4);
          (%o5)          (n + 2) (n + 4) double_factorial(n)
          (%i6) double_factorial(n-4);
                                 double_factorial(n)
          (%o6)                  -------------------
                                      (n - 2) n

     Die Ableitung der Funktion `double_factorial'.

          (%i7) diff(double_factorial(x), x);
                                               2
                                      %pi log(---) sin(%pi x)
                                              %pi                    x
          (%o7) (double_factorial(x) (----------------------- + psi (- + 1)
                                                 2                 0 2
                                                               + log(2)))/2

 -- Funktion: factcomb (<expr>)
     Fasst Faktoren mit Fakultäten im Ausdruck <expr> zusammen.  Zum
     Beispiel wird `(n+1)*n!' zu `(n+1)!' zusammengefasst.

     Hat die Optionsvariable `sumsplitfact'  den Wert `false', wird nach
     der Vereinfachung mit `factcomb' die Funktion `minfactorial'  auf
     den Ausdruck <expr> angewendet.

     Beispiele:

          (%i1) expr: ((n+1)*n!)/(n+2)!;
                                     (n + 1) n!
          (%o1)                      ----------
                                      (n + 2)!
          (%i2) factcomb(expr);
                                      (n + 1)!
          (%o2)                       --------
                                      (n + 2)!
          (%i3) factcomb(expr), sumsplitfact:false;
                                          1
          (%o3)                         -----
                                        n + 2

 -- Funktion: factorial (<z>)
 -- Operator: !
     Die Funktion `factorial' ist für das numerische und symbolische
     Rechnen der Fakultät geeignet.  Der Operator der Fakultät `!', ist
     identisch mit der Funktion `factorial'.

     Für eine ganze Zahl `n', vereinfacht `n!' zum Produkt der ganzen
     Zahlen von 1 bis einschließlich `n'.  `0!' vereinfacht zu 1.  Für
     reelle und komplexe Gleitkommazahlen wird `z!' mit der
     Verallgemeinerung `gamma(z+1)' berechnet.  Siehe die Funktion
     `gamma'.    Für eine halbzahlige rationale Zahl `n/2', vereinfacht
     `(n/2)!' zu einem rationalen Faktor multipliziert mit `sqrt(%pi)'.

     Die Optionsvariable `factlim'  enthält die größte Zahl, für die
     die Fakultät einer ganzen Zahl numerisch berechnet wird.  Ist das
     Argument der Fakultät eine rationale Zahl, wird von Maxima die
     Funktion `gamma'  für die numerische Berechnung aufgerufen.  In
     diesem Fall ist `gammalim - 1' der größte Nenner, für den die
     Fakultät vereinfacht wird.  Siehe `gammalim'.

     Hat die Optionsvariable `factorial_expand'  den Wert `true', wird
     die Fakultät von Argumenten der Form `(n+k)!' oder `(n-k)!'
     vereinfacht, wobei `k' eine ganze Zahl ist.

     Mit den Funktionen `minfactorial'  und `factcomb'  können
     Fakultäten in Ausdrücken vereinfacht werden.

     Die Funktion `makegamma'  ersetzt Fakultäten in einem Ausdruck
     durch die Gammafunktion `gamma'.    Umgekehrt ersetzt die Funktion
     `makefact'  Binomialkoeffizienten und die Gammafunktion in einem
     Ausdruck durch Fakultäten.

     Maxima kennt die Ableitung der Fakultät und die Grenzwerte der
     Fakultät für spezielle Werte wie negative ganze Zahlen.

     Siehe auch die Gammfunktion `gamma'  und den Binomialkoeffizienten
     `binomial'.

     Beispiele:

     Die Fakultät einer ganzen Zahl wird zu einer exakten Zahl
     vereinfacht, wenn das Argument nicht größer als `factlim' ist.
     Die Fakultät für reelle und komplexe Zahlen wird als
     Gleitkommazahl berechnet.

          (%i1) factlim:10;
          (%o1)                          10
          (%i2) [0!, (7/2)!, 8!, 20!];
                               105 sqrt(%pi)
          (%o2)            [1, -------------, 40320, 20!]
                                    16
          (%i3) [4.77!, (1.0+%i)!];
          (%o3) [81.44668037931197, .3430658398165451 %i
                                                       + .6529654964201663]
          (%i4) [2.86b0!, (1.0b0+%i)!];
          (%o4) [5.046635586910012b0, 3.430658398165454b-1 %i
                                                    + 6.529654964201667b-1]

     Die Fakultät von numerischen Konstanten oder eines konstanten
     Ausdrucks wird numerisch berechnet, wenn die Konstante oder der
     Ausdruck zu einer Zahl ausgewertet werden kann.

          (%i1) [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
          (%o1)      [(%i + 1)!, %pi!, %e!, (sin(1) + cos(1))!]
          (%i2) ev (%, numer, %enumer);
          (%o2) [.3430658398165451 %i + .6529654964201663,
                   7.188082728976031, 4.260820476357003, 1.227580202486819]

     Fakultäten werden vereinfacht und nicht ausgewertet.  Daher wird
     die Fakultät auch dann berechnet, wenn die Auswertung mit dem
     Quote-Operator  `'' unterdrückt ist.

          (%i1) '([0!, (7/2)!, 4.77!, 8!, 20!]);
                      105 sqrt(%pi)
          (%o1)   [1, -------------, 81.44668037931197, 40320, 20!]
                           16

     Maxima kennt die Ableitung der Fakultät.

          (%i1) diff(x!, x);
          (%o1)                    x! psi (x + 1)
                                         0

     Die Optionsvariable `factorial_expand' kontrolliert die Expansion
     und Vereinfachung von Ausdrücken, die die Fakultät enthalten.

          (%i1) (n+1)!/n!,factorial_expand:true;
          (%o1)                         n + 1

 -- Optionsvariable: factlim
     Standardwert: 100000

     Die Optionsvariable `factlim' spezifiziert die größte ganze Zahl,
     für die die Fakultät einer ganzen Zahl numerisch berechnet wird.
     Hat `factlim' den Wert -1, wird die Fakultät für jede ganze Zahl
     berechnet.  Siehe die Funktion `factorial'.


 -- Optionsvariable: factorial_expand
     Standardwert: `false'

     Die Optionsvariable `factorial_expand' kontrolliert die
     Vereinfachung von Ausdrücken wie `(n+k)!' oder `(n-k)!', wobei `k'
     eine ganze Zahl ist.  Siehe `factorial'  für ein Beispiel.

     Siehe auch die Funktionen `minfactorial'  und `factcomb'  für die
     Vereinfachung von Ausdrücken mit der Fakultät.

 -- Funktion: genfact (<x>, <y>, <z>)
     Gibt die verallgemeinerte Fakultät zurück, die als `x (x-z) (x - 2
     z) ... (x - (y - 1) z)' definiert ist.  Ist <x> eine ganze Zahl,
     dann entspricht `genfact(x, x, 1)' der Fakultät `x!' und
     `genfact(x, x/2, 2)' der doppelten Fakultät `x!!'.  Siehe auch die
     Funktionen `factorial'  und `double_factorial'  sowie die
     Operatoren `!'  und `!!'.


 -- Funktion: minfactorial (<expr>)
     Die Funktion `minfactorial' vereinfacht Fakultäten `factorial'  in
     dem Ausdruck <epxr>, die sich um eine ganze Zahl voneinander
     unterscheiden.  Siehe auch die Funktion `factcomb',  um Fakultäten
     zusammenzufassen, sowie die Optionsvariable `factorial_expand'.

          (%i1) n!/(n+2)!;
                                         n!
          (%o1)                       --------
                                      (n + 2)!
          (%i2) minfactorial (%);
                                          1
          (%o2)                    ---------------
                                   (n + 1) (n + 2)

 -- Optionsvariable: sumsplitfact
     Standardwert: `true'

     Hat die Optionsvariable `sumsplitfact' den Wert `false', wird von
     der Funktion `factcomb' nach der Zusammenfassung von Fakultäten die
     Funktion `minfactorial'  angewendet.  Siehe die Funktion `factcomb'
     für ein Beispiel.


File: maxima.info,  Node: Wurzel-, Exponential- und Logarithmusfunktion,  Next: Winkelfunktionen,  Prev: Funktionen der Kombinatorik,  Up: Mathematische Funktionen

10.4 Wurzel-, Exponential- und Logarithmusfunktion
==================================================

 -- Optionsvariable: %e_to_numlog
     Standardwert: `false'

     Hat die Optionsvariable `%e_to_numlog' den Wert `true', wird ein
     Ausdruck mit der Exponentialfunktion `exp'  der Form
     `%e^(r*log(x))' zu `x^r' vereinfacht, wenn `r' eine rationale Zahl
     ist.  Ist `r' eine ganze Zahl, wird die Vereinfachung von der
     Optionsvariablen `logsimp'  kontrolliert.

     Beispiel:

          (%i1) exp(1/2*log(x));
                                        log(x)
                                        ------
                                          2
          (%o1)                       %e
          (%i2) exp(1/2*log(x)), %e_to_numlog:true;
          (%o2)                        sqrt(x)

 -- Optionsvariable: %emode
     Standardwert: `true'

     Die Optionsvariable `%emode' kontrolliert die Vereinfachung von
     Ausdrücken mit der Exponentialfunktion `exp'  der Form `%e^(%pi %i
     x)'.

     Ist das Argument <x> eine ganze Zahl oder eine rationale Zahl, die
     ein Vielfaches von 1/2, 1/3, 1/4 oder 1/6 ist, dann wird der
     Ausdruck `%e^(%pi %i x)' zu einer reellen oder komplexen Zahl
     vereinfacht.  Für Gleitkommazahlen wird diese Vereinfachung dann
     ausgeführt, wenn diese eine ganze Zahl oder halbzahlige rationale
     Zahl repräsentieren.

     Eine Summe im Exponenten wie zum Beispiel `%e^(%pi *%i (x+n))',
     wobei <n> eine der oben genannten Zahlen und <x> ein allgemeiner
     Ausdruck ist, wird vereinfacht, indem der Faktor `%^(%pi %i n)'
     entsprechend vereinfacht wird.

     Hat `%emode' den Wert `false', werden keine speziellen
     Vereinfachungen für den Ausdruck `%e^(%pi %i x)' vorgenommen.

     Beispiele:

          (%i1) exp([2*%pi*%i, 1/2*%pi*%i, 0.5*%pi*%i, 0.5b0*%pi*%i]);
          (%o1)               [1, %i, 1.0 %i, 1.0b0 %i]

          (%i2) exp([1/3*%pi*%i, 1/4*%pi*%i, 1/6*%pi*%i]);
                   sqrt(3) %i   1    %i         1     %i   sqrt(3)
          (%o2)   [---------- + -, ------- + -------, -- + -------]
                       2        2  sqrt(2)   sqrt(2)  2       2

          (%i3) exp((1/3+x)*%pi*%i);
                              sqrt(3) %i   1    %i %pi x
          (%o3)              (---------- + -) %e
                                  2        2

 -- Optionsvariable: %enumer
     Standardwert: `false'

     Hat `%enumer' den Wert `true', wird die Konstante `%e' immer dann
     durch ihren nummerischen Wert ersetzt, wenn die Optionsvariable
     `numer'  den Wert `true' hat.

     Hat `%enumer' den Wert `false', wird die Konstante `%e' nur dann
     durch ihren nummerischen Wert ersetzt, wenn der Exponent von
     `%e^x' zu einer Gleitkommazahl ausgewertet wird.

     Siehe auch `ev'  und `numer'.

     Beispiel:

          (%i1) %enumer:true;
          (%o1)                         true
          (%i2) exp(x);
                                           x
          (%o2)                          %e
          (%i3) exp(x),numer;
                                                  x
          (%o3)                  2.718281828459045

 -- Funktion: exp (<z>)
     Ist die Exponentialfunktion.  Die Exponentialfunktion `exp' wird
     von Maxima sofort zu `%e^<z>' vereinfacht und tritt in
     vereinfachten Ausdrücken nicht auf.  Maxima vereinfacht die
     Exponentialfunktion daher wie die allgemeine Exponentiation `^'.
     Darüberhinaus kennt Maxima spezielle Regeln für die Vereinfachung
     der Exponentialfunktion.

     Ist das Argument <z> der Exponentialfunktion eine ganze oder
     rationale Zahl wird ein vereinfachter Ausdruck zurückgegeben.  Ist
     das Argument <z> eine reelle oder komplexe Gleitkommazahl wird ein
     numerisches Ergebnis berechnet.

     Folgende Optionsvariablen kontrollieren die Vereinfachung der
     Exponentialfunktion:

    `%enumer'
          Hat die Optionsvariable `%enumer'  den Wert `true',
          vereinfacht Maxima die Eulersche Zahl `%e'  immer dann zu
          ihrem numerischen Wert, wenn die Optionsvariable `numer'
          auch den Wert `true' hat.

    `%emode'
          Hat die Optionsvariable `%emode'  den Wert `true', wendet
          Maxima Regeln an, um Ausdrücke der Form `%e^(x*%i*%pi)' zu
          vereinfachen.  Der Standardwert von `%emode' ist `true'.
          Wenn mit komplexen Zahlen in der Polarform gerechnet wird,
          kann es hilfreich sein, die Optionsvariable `%emode' auf den
          Wert `false' zu setzen.

    `%e_to_numlog'
          Hat die Optionsvariable `%e_to_numlog'  den Wert `true',
          vereinfacht Maxima einen Ausdruck `%e^(r*log(x)' zu `x^r',
          wobei <r> eine rationale Zahl ist.  Ist <r> eine ganze Zahl
          wird diese Vereinfachung von der Optionsvariablen `logsimp'
          kontrolliert.  Für reelle oder komplexe Gleitkommazahlen wird
          diese Vereinfachung nicht ausgeführt.

    `radexpand'
          Die Optionsvariable `radexpand'  kontrolliert die
          Vereinfachung von Ausdrücken der Form `(%e^a)^b'.  Ist <a>
          ein reelles Argument vereinfacht Maxima immer zu einem
          Ausdruck `%e^(a*b)'.  Ist <a> ein komplexes Argument, wird
          die Vereinfachung `%e^(a*b)' dann ausgeführt, wenn die
          Optionsvariable `radexpand' den Wert `all' hat.

    `logsimp'
          Die Optionsvariable `logsimp'  kontrolliert die Vereinfachung
          der Exponentialfunktion für den Fall, dass im Argument <expr>
          die Logarithmusfunktion `log'  auftritt.  Hat die `logsimp'
          den Wert `true', wird ein Ausdruck `%e^(n*log(x)' zu `x^n'
          vereinfacht, wenn <n> eine ganze Zahl ist.  Mit der
          Optionsvariablen `%e_to_numlog'  wird diese Vereinfachung für
          eine rationale Zahl <n> kontrolliert.

    `demoivre'
          Ist eine Optionsvariable und eine Funktion, die auch als
          Auswertungsschalter `evflag'  definiert ist.  Hat die
          Optionsvariable `demoivre'  den Wert `true', wird ein
          Ausdruck `%e^(x + %i y)' zu `%e^x (cos(y) + %i sin(y))'
          vereinfacht.  Siehe auch die Optionsvariable `exponentialize'.


     Maxima kennt viele spezielle unbestimmte und bestimmte Integrale
     mit der Exponentialfunktion.

 -- Funktion: log (<z>)
     Ist der natürliche Logarithmus zur Basis e.  Die
     Logarithmusfunktion ist für das numerische und symbolische Rechnen
     geeignet.

     Maxima hat keine vordefinierte Logarithmusfunktion zur Basis 10
     oder anderen Basen.  Eine einfache Definition ist zum Beispiel
     `log10(x) := log(x)/log(10)'.  Mit dem Kommando `load(log10)' kann
     ein Paket geladen werden, dass eine dekadische Logarithmusfunktion
     `log10' definiert.

     Ist das Argument <z> der Logarithmusfunktion eine ganze oder
     rationale Zahl wird ein vereinfachter Ausdruck zurückgegeben.  Ist
     das Argument <z> eine reelle oder komplexe Gleitkommazahl wird ein
     numerisches Ergebnis berechnet.

     Die folgenden Optionsvariablen kontrollieren die Vereinfachung und
     Auswertung der Logarithmusfunktion:

    `logexpand'
          Hat die Optionsvariable `logexpand' den Wert `true', dann wird
          `log(a^b)' zu `b*log(a)' vereinfacht.  Hat `logexpand' den
          Wert `all', wird zusätzlich `log(a*b)' zu `log(a)+log(b)'
          vereinfacht.  Mit den Wert `super' vereinfacht Maxima
          weiterhin `log(a/b)' zu `log(a)-log(b)', wobei `a/b' eine
          rationale Zahl ist.  `log(1/b' wird für eine ganze Zahl `b'
          immer vereinfacht.  Hat die Optionsvariable `logexpand' den
          Wert `false' werden alle obigen Vereinfachungen ausgeschaltet.

    `logsimp'
          Hat die Optionsvariable `logsimp' den Wert `false', werden
          Exponentialfunktionen `exp',  die Logarithmusfunktionen im
          Exponenten enthalten, nicht vereinfacht.

    `lognegint'
          Hat die Optionsvariable `lognegint' den Wert `true', wird
          `log(-n)' zu `log(n)+%i*%pi' für positive `n' vereinfacht.

    `%e_to_numlog'
          Hat die Optionsvariable `%e_to_numlog' den Wert `true', wird
          ein Ausdruck `%e^(r*log(x))' zu `x^r' vereinfacht.  Dabei
          sind `r' eine rationale Zahl und `x' ein beliebiger Ausdruck.
          Die Funktion `radcan' führt diese Vereinfachung ebenfalls aus.

     Die Logarithmusfunktion wird automatisch auf die Elemente von
     Listen und Matrizen sowie auf die beiden Seiten von Gleichungen
     angewendet.  Siehe `distribute_over'.

     Beispiele:

     Verschiedene Beispiele mit der Logarithmusfunktion.

          (%i1) log(%e);
          (%o1)                           1
          (%i2) log(100.0);
          (%o2)                   4.605170185988092
          (%i3) log(2.5+%i);
          (%o3)       .3805063771123649 %i + .9905007344332917
          (%i4) taylor(log(1+x),x,0,5);
                                 2    3    4    5
                                x    x    x    x
          (%o4)/T/          x - -- + -- - -- + -- + . . .
                                2    3    4    5
          (%i5) rectform(log(x+%i*y));
                                 2    2
                            log(y  + x )
          (%o5)             ------------ + %i atan2(y, x)
                                 2
          (%i6) limit(log(x),x,0,plus);
          (%o6)                         minf
          (%i7) integrate(log(z)^n,z);
                                                              - n - 1
          (%o7) - gamma_incomplete(n + 1, - log(z)) (- log(z))
                                                                      n + 1
                                                                log(z)
          (%i8) laplace(log(t),t,s);
                                  - log(s) - %gamma
          (%o8)                   -----------------
                                          s
          (%i9) depends(y,x);
          (%o9)                        [y(x)]
          (%i10) ode2(diff(y,x)+log(y)+1,y,x);
                      - 1
          (%o10)    %e    expintegral_e(1, - log(y) - 1) = x + %c

 -- Optionsvariable: logabs
     Standardwert: `false'

     Treten bei der unbestimmten Integration Logarithmusfunktionen im
     Ergebnis auf, so wird der Betrag der Argumente der
     Logarithmusfunktionen gebildet, wenn die Optionsvariable `logabs'
     den Wert `true' hat.

     Beispiele:

          (%i1) logabs:true;
          (%o1)                         true
          (%i2) integrate(1/x,x);
          (%o2)                      log(abs(x))
          (%i3) integrate(1/(1+x^3),x);
                                                             2 x - 1
                      ! 2        !                      atan(-------)
                  log(!x  - x + 1!)   log(abs(x + 1))        sqrt(3)
          (%o3) - ----------------- + --------------- + -------------
                          6                  3             sqrt(3)

 -- Funktion: logarc (<expr>)
 -- Optionsvariable: logarc
     Hat die Optionsvariable `logarc' den Wert `true', werden inverse
     Winkel- und Hyperbelfunktionen durch Logarithmusfunktionen
     ersetzt.  Der Standardwert von `logarc' ist `false'.

     Die Funktion `logarc(<expr>)' führt diese Ersetzung aus, ohne dass
     die Optionsvariable `logarc' gesetzt wird.

     Beispiele:

          (%i1) logarc(asin(x));
                                               2
          (%o1)             - %i log(sqrt(1 - x ) + %i x)
          (%i2) logarc:true;
          (%o2)                         true
          (%i3) asin(x);
                                               2
          (%o3)             - %i log(sqrt(1 - x ) + %i x)

 -- Optionsvariable: logconcoeffp
     Standardwert: `false'

     Der Optionsvariablen `logconcoeffp' kann eine Aussagefunktion mit
     einem Argument zugewiesen werden, die kontrolliert, welche
     Koeffizienten von der Funktion `logcontract'  zusammengezogen
     werden.  Sollen zum Beispiel Wurzeln generiert werden, kann
     folgende Aussagefunktion definiert werden:

          logconcoeffp:'logconfun$
          logconfun(m) := featurep(m,integer) or ratnump(m)$

     Das Kommando `logcontract(1/2*log(x))' liefert nun das Ergebnis
     `log(sqrt(x))'.

 -- Funktion: logcontract (<expr>)
     Der Ausdruck <expr> wird rekursiv nach Ausdrücken der Form
     `a1*log(b1) + a2*log(b2) + c' durchsucht.  Diese werden zu
     `log(ratsimp(b1^a1 * b2^a2)) + c' transformiert.

          (%i1) 2*(a*log(x) + 2*a*log(y))$
          (%i2) logcontract(%);
                                           2  4
          (%o2)                     a log(x  y )

     Wird die Variable <n> mit dem Kommando `declare(n, integer)' als
     eine ganze Zahl deklariert, dann wird  `logcontract(2*a*n*log(x))'
     zu `a*log(x^(2*n))' vereinfacht.  Die Koeffizienten, die
     zusammengezogen werden, sind in diesem Fall die Zahl 2 und die
     Variable <n>, welche die folgende Aussage erfüllen
     `featurep(coeff, integer)'.  Der Nutzer kann kontrollieren, welche
     Koeffizienten zusammengezogen werden.  Dazu wird der
     Optionsvariablen `logconcoeffp'  eine Aussagefunktion mit einem
     Argument zugewiesen.  Sollen zum Beispiel Wurzeln generiert
     werden, kann folgende Definition verwendet: `logconcoeffp:
     'logconfun$ logconfun(m) := featurep(m,integer) or ratnump(m)$'.
     Dann hat das Kommando `logcontract(1/2*log(x))' das Ergebnis
     `log(sqrt(x))'.

 -- Optionsvariable: logexpand
     Standardwert: `true'

     Die Optionsvariable `logexpand' kontrolliert die Vereinfachung der
     Logarithmusfunktion `log'.

     Hat `logexpand' den Wert `true', wird `log(a^b)' zu `b*log(a)'
     vereinfacht.  Hat `logexpand' den Wert `all', wird zusätzlich
     `log(a*b)' zu `log(a)+log(b)' vereinfacht.  Mit dem Wert `super'
     vereinfacht Maxima weiterhin `log(a/b)' zu `log(a)-log(b)', wobei
     `a/b' eine rationale Zahl ist.  `log(1/b' wird für eine ganze Zahl
     `b' immer vereinfacht.  Hat die Optionsvariable `logexpand' den
     Wert `false' werden alle obigen Vereinfachungen ausgeschaltet.

 -- Optionsvariable: lognegint
     Standardwert: `false'

     Hat die Optionsvariable `lognegint' den Wert `true', wird
     `log(-n)' zu `log(n)+%i*%pi' für positive `n' vereinfacht.

 -- Optionsvariable: logsimp
     Standardwert: `true'

     Hat die Optionsvariable `logsimp' den Wert `false', werden
     Exponentialfunktionen `exp',  die Logarithmusfunktionen im
     Exponenten enthalten, nicht vereinfacht.

 -- Funktion: plog (<x>)
     Gibt den Hauptwert des komplexen natürlichen Logarithmus im
     Intervall `-%pi' < `carg(<x>)' <= `+%pi' zurück.

 -- Optionsvariable: rootsconmode
     Standardwert: `true'

     `rootsconmode' kontrolliert das Verhalten der Funktion
     `rootscontract'.  Siehe die Funktion `rootscontract'  für Details.

 -- Funktion: rootscontract (<expr>)
     Konvertiert Produkte von Wurzeln in Wurzeln von Produkten.  Zum
     Beispiel hat `rootscontract(sqrt(x)*y^(3/2))' das Ergebnis
     `sqrt(x*y^3)'.

     Hat die Optionsvariable `radexpand'  den Wert `true' und die
     Optionsvariable `domain'  den Wert `real', das sind die
     Standardwerte, wird `abs(x)' zu `sqrt(x^2)' vereinfacht.  Zum
     Beispiel hat `rootscontract(abs(x) * sqrt(y))' das Ergebnis
     `sqrt(x^2*y)'.

     Die Optionsvariable `rootsconmode'  kontrolliert das Ergebnis
     folgendermaßen:

          Problem             Wert             Ergebnis
                              rootsconmode     rootscontract

          x^(1/2)*y^(3/2)     false            sqrt(x*y^3)
          x^(1/2)*y^(1/4)     false            sqrt(x)*y^(1/4)
          x^(1/2)*y^(1/4)     true             sqrt(x*sqrt(y))
          x^(1/2)*y^(1/3)     true             sqrt(x)*y^(1/3)
          x^(1/2)*y^(1/4)     all              (x^2*y)^(1/4)
          x^(1/2)*y^(1/3)     all              (x^3*y^2)^(1/6)

     Hat `rootsconmode' den Wert `false', kontrahiert `rootscontract'
     nur Faktoren mit rationalen Exponenten, die den gleichen Nenner
     haben.  Hat `rootsconmode' den Wert `all', wird das kleinste
     gemeinsame Vielfache des Nenners der Faktoren verwendet, um die
     Faktoren zusammenzufassen.

     Ähnlich wie bei der Funktion `logcontract'  werden von
     `rootscontract' die Argumente unter der Wurzel mit der Funktion
     `ratsimp'  vereinfacht.

     Beispiele:

          (%i1) rootsconmode: false$
          (%i2) rootscontract (x^(1/2)*y^(3/2));
                                             3
          (%o2)                      sqrt(x y )
          (%i3) rootscontract (x^(1/2)*y^(1/4));
                                             1/4
          (%o3)                     sqrt(x) y
          (%i4) rootsconmode: true$
          (%i5) rootscontract (x^(1/2)*y^(1/4));
          (%o5)                    sqrt(x sqrt(y))
          (%i6) rootscontract (x^(1/2)*y^(1/3));
                                             1/3
          (%o6)                     sqrt(x) y
          (%i7) rootsconmode: all$
          (%i8) rootscontract (x^(1/2)*y^(1/4));
                                        2   1/4
          (%o8)                       (x  y)
          (%i9) rootscontract (x^(1/2)*y^(1/3));
                                       3  2 1/6
          (%o9)                      (x  y )
          (%i10) rootsconmode: false$
          (%i11) rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
                              *sqrt(sqrt(1 + x) - sqrt(x)));
          (%o11)                          1
          (%i12) rootsconmode: true$
          (%i13) rootscontract (sqrt(5+sqrt(5)) - 5^(1/4)*sqrt(1+sqrt(5)));
          (%o13)                          0

 -- Funktion: sqrt (<z>)
     Ist die Wurzelfunktion.  Die Wurzelfunktion wird von Maxima sofort
     zu `<x>^(1/2)' vereinfacht und tritt in Ausdrücken nicht auf.

     Die Wurzelfunktion ist für das numerische und symbolische Rechnen
     geeignet.  Ist das Argument <z> der Wurzelfunktion eine
     Gleitkommazahl, wird ein numerisches Ergebnis zurückgegeben.  Für
     ganze und rationale Zahlen wird die Wurzelfunktion vereinfacht.
     Die numerische Berechnung kann mit den Optionsvariablen und
     Auswertungsschaltern `numer'  und `float'  kontrolliert werden.

     Hat die Optionsvariable `radexpand'  den Wert `true', werden die
     n-ten Wurzeln von Faktoren unter einer Wurzel aus der Wurzel
     herausgezogen.  So wird zum Beispiel `sqrt(16*x^2)' nur dann zu
     `4*x' vereinfacht, wenn `radexpand' den Wert `true' hat.

     Siehe auch die Funktionen `rootscontract'  und `sqrtdenest'  für
     die Vereinfachung von Ausdrücken, die die Wurzelfunktion enthalten.

     Beispiele:

     Verschiedene Beispiele mit der Wurzelfunktion.

          (%i1) sqrt(4);
          (%o1)                           2
          (%i2) sqrt(24);
          (%o2)                       2 sqrt(6)
          (%i3) sqrt(2.0);
          (%o3)                   1.414213562373095
          (%i4) taylor(sqrt(1+x),x,0,5);
                                 2    3      4      5
                            x   x    x    5 x    7 x
          (%o4)/T/      1 + - - -- + -- - ---- + ---- + . . .
                            2   8    16   128    256
          (%i5) rectform(sqrt(x+%i*y));
                     2    2 1/4     atan2(y, x)
          (%o5) %i (y  + x )    sin(-----------)
                                         2
                                                2    2 1/4     atan2(y, x)
                                            + (y  + x )    cos(-----------)
                                                                    2
          (%i6) integrate(sqrt(t)*(t+1)^-2,t,0,1);
                                       %pi - 2
          (%o6)                        -------
                                          4


File: maxima.info,  Node: Winkelfunktionen,  Next: Hyperbelfunktionen,  Prev: Wurzel-, Exponential- und Logarithmusfunktion,  Up: Mathematische Funktionen

10.5 Winkelfunktionen
=====================

* Menu:

* Einführung in Winkelfunktionen::
* Funktionen und Variablen für Winkelfunktionen::


File: maxima.info,  Node: Einführung in Winkelfunktionen,  Next: Funktionen und Variablen für Winkelfunktionen,  Prev: Winkelfunktionen,  Up: Winkelfunktionen

10.5.1 Einführung in Winkelfunktionen
-------------------------------------

Maxima kennt viele Winkel- und Hyperbelfunktionen.  Nicht alle
Identitäten für Winkel- und Hyperbelfunktionen sind programmiert, aber
es ist möglich weitere Identitäten mit der Fähigkeit der Erkennung von
Mustern hinzuzufügen.

Maxima kennt die folgenden Winkel- und Hyperbelfunktionen sowie deren
Inverse:

     sin       cos       tan
     sec       csc       cot
     asin      acos      atan
     asec      acsc      acot
     sinh      cosh      tanh
     sech      csch      coth
     asinh     acosh     atanh
     asech     acsch     acoth


File: maxima.info,  Node: Funktionen und Variablen für Winkelfunktionen,  Prev: Einführung in Winkelfunktionen,  Up: Winkelfunktionen

10.5.2 Funktionen und Variablen für Winkelfunktionen
----------------------------------------------------

 -- Funktion: asin (<z>)
 -- Funktion: acos (<z>)
 -- Funktion: atan (<z>)
 -- Funktion: acot (<z>)
 -- Funktion: acsc (<z>)
 -- Funktion: asec (<z>)
     Die inversen Winkelfunktionen: Arkussinus, Arkuskosinus,
     Arkustangens, Arkuskotangens, Arkuskosekans und Arkussekans.

     Die inversen Winkelfunktionen sind für das numerische und
     symbolische Rechnen geeignet.  Die inversen Winkelfunktionen
     können für reelle und komplexe Gleitkommazahlen in doppelter und
     in beliebiger Genauigkeit berechnet werden.  Ist das Argument eine
     ganze oder rationale Zahl, werden die inversen Winkelfunktionen
     nicht numerisch berechnet, sondern vereinfacht.  Die numerische
     Berechnung kann mit den Optionsvariablen und Auswertungsschaltern
     `numer'  und `float'  erzwungen werden.

     Die inversen Winkelfunktionen sind bis auf die Funktionen `acos'
     und `asec' als ungerade definiert.  Die Funktionen `acos' und
     `asec' vereinfachen für ein negatives Argument `-x' zu
     `%pi-acos(x)' und `%pi-asec(x)'.  Für die inversen Winkelfunktion
     `asin', `acos' und `atan' ist die Spiegelsymmetrie für den Fall
     implementiert, dass das komplexe Argument `x+%i*y' einen Realteil
     `abs(x)<1' hat.

     Ist das Argument <z> eine Matrix, eine Liste oder eine Gleichung
     werden die inversen Winkelfunktionen auf die Elemente der Matrix,
     der Liste oder auf die beiden Seiten der Gleichung angewendet.
     Dieses Verhalten wird von der Optionsvariablen `distribute_over'
     kontrolliert.

     Inverse Winkelfunktionen können für das symbolische Rechnen
     verwendet werden.  Maxima kann Ausdrücke mit inversen
     Winkelfunktionen differenzieren und integrieren, Grenzwerte
     bestimmen sowie Gleichungen mit inversen Winkelfunktionen lösen.

     Das Argument der inversen Winkelfunktionen kann eine Taylorreihe
     sein.  In diesem Fall wird die Taylorreihenentwicklung für die
     inverse Winkelfunktion vollständig ausgeführt.

     Die folgenden Optionsvariablen kontrollieren die Vereinfachung der
     inversen Winkelfunktionen:

    `distribute_over'
          Hat die Optionsvariable `distribute_over'  den Wert `true'
          und ist das Argument der inversen Winkelfunktion eine Matrix,
          Liste oder Gleichung wird die Funktion auf die Elemente oder
          beiden Seiten der Gleichung angewendet.  Der Standardwert ist
          `true'.

    `%piargs'
          Hat die Optionsvariable `%piargs'  den Wert `true', werden die
          inversen Winkelfunktionen für spezielle Werte als Argument
          vereinfacht.  Der Standardwert ist `true'.

    `%iargs'
          Hat die Optionsvariable `%iargs'  den Wert `true' und ist das
          Argument der inversen Winkelfunktion ein Vielfaches der
          imaginären Einheit `%i' werden die inversen Winkelfunktionen
          zu inversen Hyperbelfunktionen vereinfacht.  Der Standardwert
          ist `true'.

    `triginverses'
          Hat die Optionsvariable `triginverses'  den Wert `all' und
          ist das Argument die entsprechende Winkelfunktion
          vereinfachen die inversen Winkelfunktionen, zum Beispiel
          vereinfacht `asin(sin(x))' zu `x'.  Der Standardwert ist
          `true' und die Vereinfachung wird nicht vorgenommen.

    `logarc'
          Hat die Optionsvariable `logarc'  den Wert `true', werden
          inverse Winkelfunktionen durch Logarithmusfunktionen ersetzt.
          Der Standardwert von `logarc' ist `false'.

 -- Funktion: atan2 (<y>, <x>)
     Ist der Arkustangens mit zwei Argumenten, der in Maxima wie folgt
     definiert ist:

          atan(y/x)           x>0
          atan(y/x) + %pi     x<0 und y>=0
          atan(y/x) - %pi     x<0 und y<0
            %pi / 2           x=0 und y>0
          - %pi / 2           x=0 und y<0
          nicht definiert     x=0 und y=0

     Mit der obigen Definition ist der Wertebereich des Arkustangens
     `-%pi < atan2(y,x) <= %pi'.  Alternativ kann der Arkustangens mit
     zwei Argumenten definiert werden als

                                   %i y + x
          atan2(y, x) = - %i log(-------------)
                                       2    2
                                 sqrt(y  + x )

     Der Arkustangens ist für das symbolische und numerische Rechnen
     geeignet.  Für reelle Argumente <x> und <y> deren Vorzeichen
     bestimmt werden kann, vereinfacht Maxima den Arkustangens wie oben
     in der Definition angegeben.  Sind beide Argumente
     Gleitkommazahlen wird ein numerisches Ergebnis berechnet.  Die
     numerische Berechnung für komplexe Gleitkommazahlen ist nicht
     implementiert.  Weiterhin kennt Maxima die speziellen Werte, wenn
     eines der Argumente <x> oder <y> unendlich ist.  `atan2(x, x)' und
     `atan2(x, -x)' werden von Maxima vereinfacht, wenn Maxima das
     Vorzeichen von <x> ermitteln kann.

     Die Vereinfachung des Arkustangens wird weiterhin von den folgenden
     Optionsvariablen kontrolliert:

    `distribute_over'
          Hat die Optionsvariable `distribute_over'  den Wert `true'
          und ist das Argument des Arkustangens eine Matrix, Liste oder
          Gleichung wird die Funktion auf die Elemente oder beiden
          Seiten der Gleichung angewendet.  Der Standardwert ist `true'.

    `trigsign'
          Hat die Optionsvariable `trigsign'  den Wert `true',
          vereinfacht Maxima `atan2(-y, x)' zu `- atan2(y, x)'.  Der
          Standardwert ist `true'.

    `logarc'
          Hat die Optionsvariable `logarc'  den Wert `true', wird der
          Arkustangens durch einen Ausdruck mit der
          Logarithmusfunktionen ersetzt.  Der Standardwert von `logarc'
          ist `false'.

     Maxima kann Ausdrücke mit dem Arkustangens ableiten und
     integrieren sowie die Grenzwerte von Ausdrücken mit dem
     Arkustangens ermitteln.

     Beispiele:

          (%i1) atan2([-1, 1],[-1, 0, 1]);
                        3 %pi    %pi    %pi    3 %pi  %pi  %pi
          (%o1)     [[- -----, - ---, - ---], [-----, ---, ---]]
                          4       2      4       4     2    4
          (%i2) atan2(1,[-0.5, 0.5]);
          (%o2)         [2.034443935795703, 1.10714871779409]
          (%i3) assume(a>0)$

          (%i4) atan2(2*a, -2*a);
                                        3 %pi
          (%o4)                         -----
                                          4
          (%i5) diff(atan2(y,x), x);
                                           y
          (%o5)                       - -------
                                         2    2
                                        y  + x
          (%i6) integrate(atan2(y,x), x);
                                    2    2
                             y log(y  + x )          y
          (%o6)              -------------- + x atan(-)
                                   2                 x

 -- Funktion: sin (<z>)
 -- Funktion: cos (<z>)
 -- Funktion: tan (<z>)
 -- Funktion: cot (<z>)
 -- Funktion: csc (<z>)
 -- Funktion: sec (<z>)
     Die Winkelfunktionen: Sinus, Kosinus, Tangens, Kotangens, Kosekans
     und Sekans.

     Die Winkelfunktionen sind für das numerische und symbolische
     Rechnen geeignet.  Die Winkelfunktionen können für reelle und
     komplexe Gleitkommazahlen in doppelter und in beliebiger
     Genauigkeit berechnet werden.  Ist das Argument eine ganze oder
     rationale Zahl, werden die Winkelfunktionen nicht numerisch
     berechnet, sondern vereinfacht.  Die numerische Berechnung kann
     mit den Optionsvariablen und Auswertungsschaltern `numer'  und
     `float'

     erzwungen werden.

     Die Winkelfunktionen sind gerade oder ungerade und haben
     Spiegelsymmetrie.  Maxima wendet diese Symmetrieeigenschaften
     automatisch bei der Vereinfachung von Ausdrücken mit
     Winkelfunktionen an.

     Ist das Argument <z> eine Matrix, eine Liste oder eine Gleichung
     werden die Winkelfunktionen auf die Elemente der Matrix, der Liste
     oder auf die beiden Seiten der Gleichung angewendet.  Dieses
     Verhalten wird von der Optionsvariablen `distribute_over'
     kontrolliert.

     Winkelfunktionen können für das symbolische Rechnen verwendet
     werden.  Maxima kann Ausdrücke mit Winkelfunktionen differenzieren
     und integrieren, Grenzwerte bestimmen sowie Gleichungen und
     Differentialgleichungen mit Winkelfunktionen lösen.

     Das Argument der Winkelfunktionen kann eine Taylorreihe sein.  In
     diesem Fall wird die Taylorreihenentwicklung für die
     Winkelfunktion vollständig ausgeführt.

     Die folgenden Optionsvariablen kontrollieren die Vereinfachung der
     Winkelfunktionen:

    `distribute_over'
          Hat die Optionsvariable `distribute_over'  den Wert `true'
          und ist das Argument der Winkelfunktion eine Matrix, Liste
          oder Gleichung wird die Funktion auf die Elemente oder beiden
          Seiten der Gleichung angewendet.  Der Standardwert ist `true'.

    `%piargs'
          Hat die Optionsvariable `%piargs'  den Wert `true', werden die
          Winkelfunktionen für ganzzahlige und halbzahlige Vielfache
          der Konstanten `%pi' zu speziellen Werten vereinfacht.  Der
          Standardwert ist `true'.

    `%iargs'
          Hat die Optionsvariable `%iargs'  den Wert `true' und ist das
          Argument der Winkelfunktion ein Vielfaches der imaginären
          Einheit `%i' werden die Winkelfunktionen zu
          Hyperbelfunktionen vereinfacht.  Der Standardwert ist `true'.

    `trigsign'
          Hat die Optionsvariable `trigsign'  den Wert `true', werden
          die gerade oder ungerade Symmetrie der Winkelfunktionen bei
          der Vereinfachung angewendet.  Der Standardwert ist `true'.

    `triginverses'
          Hat die Optionsvariable `triginverses'  den Wert `true' und
          ist das Argument eine inverse Winkelfunktion vereinfachen die
          Winkelfunktionen zu einem einfachen algebraischen Ausdruck,
          zum Beispiel vereinfacht `sin(acos(x))' zu `sqrt(1-x^2)'.
          Der Standardwert ist `true'.

    `trigexpand'
          Hat die Optionsvariable `trigexpand'  den Wert `true', dann
          werden die Winkelfunktionen für ein Argument expandiert, das
          eine Summe oder ein Produkt mit einer ganzen Zahl ist.  Der
          Standardwert ist `false'.

    `exponentialize'
          Hat die Optionsvariable `exponentialize'  den Wert `true',
          dann werden die Winkelfunktionen in eine Exponentialform
          transformiert.  Der Standardwert ist `false'.

    `halfangles'
          Hat die Optionsvariable `halfangles'  den Wert `true', dann
          werden die Winkelfunktionen für halbzahlige Argumente zu
          einem äquivalenten Ausdruck transformiert.  Der Standardwert
          ist `false'.

     Beispiele:

     Im Folgenden werden Beispiele für die Sinusfunktion gezeigt.
     Numerische Berechnungen für Gleitkommazahlen:

          (%i1) sin(1+%i);
          (%o1)                      sin(%i + 1)
          (%i2) sin(1.0+%i);
          (%o2)       .6349639147847361 %i + 1.298457581415977
          (%i3) sin(1.0b0+%i);
          (%o3)     6.349639147847361b-1 %i + 1.298457581415977b0
          (%i4) sin(1.0b0),fpprec:45;
          (%o4)   8.41470984807896506652502321630298999622563061b-1

     Einige Vereinfachungen der Sinusfunktionen:

          (%i5) sin(%i*(x+y));
          (%o5)                    %i sinh(y + x)
          (%i6) sin(%pi/3);
                                       sqrt(3)
          (%o6)                        -------
                                          2
          (%i2) sin(x+y),trigexpand:true;
          (%o2)             cos(x) sin(y) + sin(x) cos(y)
          (%i3) sin(2*x+y),trigexpand:true;
                     2         2
          (%o3)  (cos (x) - sin (x)) sin(y) + 2 cos(x) sin(x) cos(y)

     Grenzwerte, Ableitungen und Integrale mit der Sinusfunktion:

          (%i4) limit(sin(x)/x,x,0);
          (%o4)                          1
          (%i5) diff(sin(sqrt(x))/x,x);
                            cos(sqrt(x))   sin(sqrt(x))
          (%o5)             ------------ - ------------
                                  3/2            2
                               2 x              x
          (%i6) integrate(sin(x^3),x);
          (%o6)
                                   1      3                     1        3
                  gamma_incomplete(-, %i x ) + gamma_incomplete(-, - %i x )
                                   3                            3
                - ---------------------------------------------------------
                                             12

     Reihenentwicklung der Sinusfunktion:

          (%i7) taylor(sin(x),x,0,3);
                                        3
                                       x
          (%o7)/T/                 x - -- + . . .
                                       6

 -- Optionsvariable: %piargs
     Standardwert: `true'

     Hat `%piargs' den Wert `true', werden Winkel- und
     Hyperbelfunktionen sowie deren Inverse zu algebraischen Konstanten
     vereinfacht, wenn das Argument ein ganzzahliges Vielfaches der
     folgenden Konstanten ist: `%pi', `%pi/2', `%pi/3', `%pi/4' oder
     `%pi/6'.

     Maxima kennt weiterhin einige Identitäten, wenn die Konstante `%pi'
     mit einer Variablen multipliziert wird, die als ganzzahlig
     deklariert wurde.

     Beispiele:

          (%i1) %piargs : false$
          (%i2) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                          %pi       %pi
          (%o2)            [sin(%pi), sin(---), sin(---)]
                                           2         3
          (%i3) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                                %pi       %pi       %pi
          (%o3)            [sin(---), sin(---), sin(---)]
                                 4         5         6
          (%i4) %piargs : true$
          (%i5) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                          sqrt(3)
          (%o5)                    [0, 1, -------]
                                             2
          (%i6) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                                   1         %pi   1
          (%o6)                [-------, sin(---), -]
                                sqrt(2)       5    2
          (%i7) [cos (%pi/3), cos (10*%pi/3), tan (10*%pi/3),
                 cos (sqrt(2)*%pi/3)];
                          1    1               sqrt(2) %pi
          (%o7)          [-, - -, sqrt(3), cos(-----------)]
                          2    2                    3

     Weitere Identitäten werden angewendet, wenn `%pi' und `%pi/2' mit
     einer ganzzahligen Variable multipliziert werden.

          (%i1) declare (n, integer, m, even)$
          (%i2) [sin (%pi * n), cos (%pi * m), sin (%pi/2 * m),
                 cos (%pi/2 * m)];
                                                m/2
          (%o2)                  [0, 1, 0, (- 1)   ]

 -- Optionsvariable: %iargs
     Standardwert: `true'

     Hat `%iargs' den Wert `true', werden Winkelfunktionen zu
     Hyperbelfunktionen vereinfacht, wenn das Argument ein Vielfaches
     der imaginären Einheit `%i' ist.

     Die Vereinfachung zu Hyperbelfunktionen wird auch dann ausgeführt,
     wenn das Argument offensichtlich reell ist.

     Beispiele:

          (%i1) %iargs : false$
          (%i2) [sin (%i * x), cos (%i * x), tan (%i * x)];
          (%o2)           [sin(%i x), cos(%i x), tan(%i x)]
          (%i3) %iargs : true$
          (%i4) [sin (%i * x), cos (%i * x), tan (%i * x)];
          (%o4)           [%i sinh(x), cosh(x), %i tanh(x)]

     Auch wenn das Argument offensichtlich reell ist, wird zu einer
     Hyperbelfunktion vereinfacht.

          (%i1) declare (x, imaginary)$
          (%i2) [featurep (x, imaginary), featurep (x, real)];
          (%o2)                     [true, false]
          (%i3) sin (%i * x);
          (%o3)                      %i sinh(x)

 -- Optionsvariable: halfangles
     Standardwert: `false'

     Hat `halfangles' den Wert `true', werden Winkel- und
     Hyperbelfunktionen mit halbzahligen Argumenten `<expr>/2'
     vereinfacht.

     Für ein reelles Argument <x> im Intervall `0 < x < 2*%pi'
     vereinfacht der Sinus für ein halbzahliges Argument zu einer
     einfachen Formel:

                                   sqrt(1 - cos(x))
                                   ----------------
                                       sqrt(2)

     Ein komplizierter Faktor wird gebraucht, damit die Formel korrekt
     ist für ein komplexes Argument <z>:

                realpart(z)
          floor(-----------)
                   2 %pi
     (- 1)                   (1 - unit_step(- imagpart(z))

                                 realpart(z)            realpart(z)
                           floor(-----------) - ceiling(-----------)
                                    2 %pi                  2 %pi
                     ((- 1)                                          + 1))

     Maxima kennt diesen Faktor und ähnliche Faktoren für die Sinus,
     Kosinus, Sinus Hyperbolicus und Kosinus Hyperbolicus Funktionen.
     Für spezielle Argumente z dieser Funktionen vereinfachen diese
     Funktionen entsprechend.

     Beispiele:

          (%i1) halfangles:false;
          (%o1)                                false
          (%i2) sin(x/2);
                                                  x
          (%o2)                               sin(-)
                                                  2
          (%i3) halfangles:true;
          (%o3)                                true
          (%i4) sin(x/2);
                                                              x
                                                      floor(-----)
                                                            2 %pi
                                sqrt(1 - cos(x)) (- 1)
          (%o4)                 ----------------------------------
                                             sqrt(2)
          (%i5) assume(x>0, x<2*%pi)$
          (%i6) sin(x/2);
                                         sqrt(1 - cos(x))
          (%o6)                          ----------------
                                             sqrt(2)

 -- Paket: ntrig
     Das Paket `ntrig' enthält Regeln, um Winkelfunktionen zu
     vereinfachen, die Argumente der Form `<f>(<n> %pi/10)' haben.  <f>
     ist eine der Funktionen `sin', `cos', `tan', `csc', `sec' oder
     `cot'.

     Das Kommando `load(ntrig)' lädt das Paket.  Die Vereinfachungen
     werden dann von Maxima automatisch ausgeführt.

 -- Funktion: trigexpand (<expr>)
     Die Funktion `trigexpand' expandiert Winkel- und
     Hyperbelfunktionen im Ausdruck <expr>, die Summen und Vielfache
     von Winkeln als Argument haben.  Die besten Ergebnisse werden
     erzielt, wenn der Ausdruck <expr> zunächst expandiert wird.

     Folgende Schalter kontrollieren `trigexpand':

    `trigexpand'
          Wenn `true', werden Sinus- und Kosinusfunktionen expandiert.

    `halfangles'
          Wenn `true', werden Vereinfachungen für halbzahlige Argumente
          angewendet.

    `trigexpandplus'
          Wenn `true', werden Winkelfunktionen, die eine Summe als
          Argument haben, wie zum Beispiel `sin(x+y)', vereinfacht.

    `trigexpandtimes'
          Wenn `true',  werden Winkelfunktionen, die ein Produkt als
          Argument haben, wie zum Beispiel `sin(2 x)', vereinfacht.

     Beispiele:

          (%i1) x+sin(3*x)/sin(x),trigexpand=true,expand;
                                   2           2
          (%o1)               - sin (x) + 3 cos (x) + x
          (%i2) trigexpand(sin(10*x+y));
          (%o2)          cos(10 x) sin(y) + sin(10 x) cos(y)

 -- Optionsvariable: trigexpandplus
     Standardwert: `true'

     `trigexpandplus' kontrolliert die Vereinfachung von
     Winkelfunktionen mit der Funktion `trigexpand'  für den Fall, dass
     Winkelfunktionen mit Summen als Argumente auftreten.  Hat
     `trigexpandplus' den Wert `true', werden zum Beispiel
     Winkelfunktionen wie `sin(x+y)' vereinfacht.

 -- Optionsvariable: trigexpandtimes
     Standardwert: `true'

     `trigexpandtimes' kontrolliert die Vereinfachung von
     Winkelfunktionen mit der Funktion `trigexpand'  für den Fall, dass
     Winkelfunktionen mit Produkten als Argumente auftreten.  Hat
     `trigexpandtimes' den Wert `true', werden zum Beispiel
     Winkelfunktionen wie `sin(2 x)' vereinfacht.

 -- Optionsvariable: triginverses
     Standardwert: `true'

     Kontrolliert die Vereinfachung, wenn das Argument einer
     Winkelfunktion oder Hyperbelfunktion eine der inversen Funktion
     ist.

     Hat `triginverses' den Wert `all', vereinfachen beide Ausdrücke
     `atan(tan(<x>))' und `tan(atan(<x>))' zum Wert <x>.

     Hat `triginverses' den Wert `all', wird `<arcfun>(<fun>(<x>))'
     nicht vereinfacht.

     Hat `triginverses' den Wert `false', werden `<arcfun>(<fun>(<x>))'
     und `<fun>(<arcfun>(<x>))' nicht vereinfacht.

 -- Funktion: trigreduce (<expr>, <x>)
 -- Funktion: trigreduce (<expr>)
     Produkte und Potenzen von Winkelfunktionen und den
     Hyperbelfunktionen mit dem Argument <x> werden zu Funktionen
     vereinfacht, die Vielfache von <x> enthalten.  `trigreduce'
     versucht auch, Sinus- und Kosinusfunktionen in einem Nenner zu
     eliminieren.  Wird keine Variable <x> angegeben, werden alle
     Variablen im Ausdruck `expr' betrachtet.

     Siehe auch `poissimp'.

          (%i1) trigreduce(-sin(x)^2+3*cos(x)^2+x);
                         cos(2 x)      cos(2 x)   1        1
          (%o1)          -------- + 3 (-------- + -) + x - -
                            2             2       2        2

 -- Optionsvariable: trigsign
     Standardwert: `true'

     Hat `trigsign' den Wert `true', werden Winkelfunktionen mit einem
     negativem Argument vereinfacht.  Zum Beispiel vereinfacht in
     diesem Fall `sin(-x)' zu `-sin(x)'.

 -- Funktion: trigsimp (<expr>)
     Wendet die Identitäten `sin(x)^2 + cos(x)^2 = 1' und `cosh(x)^2 -
     sinh(x)^2 = 1' an, um Ausdrücke, die Funktionen wie `tan', `sec',
     usw. enthalten, zu Ausdrücken mit den Funktionen `sin', `cos',
     `sinh', `cosh' zu vereinfachen.

     Die Anwendung von Funktionen wie `trigreduce',  `ratsimp'  und
     `radcan'  kann den Ausdruck weiter vereinfachen.

     Das Kommando `demo(trgsmp)' zeigt einige Beispiele.

 -- Funktion: trigrat (<expr>)
     Gives a canonical simplifyed quasilinear form of a trigonometrical
     expression; <expr> is a rational fraction of several `sin', `cos'
     or `tan', the arguments of them are linear forms in some variables
     (or kernels) and `%pi/<n>' (<n> integer) with integer coefficients.
     The result is a simplified fraction with numerator and denominator
     linear in `sin' and `cos'.  Thus `trigrat' linearize always when
     it is possible.

          (%i1) trigrat(sin(3*a)/sin(a+%pi/3));
          (%o1)            sqrt(3) sin(2 a) + cos(2 a) - 1

     The following example is taken from Davenport, Siret, and
     Tournier, Calcul Formel, Masson (or in English, Addison-Wesley),
     section 1.5.5, Morley theorem.

          (%i1) c : %pi/3 - a - b$
          (%i2) bc : sin(a)*sin(3*c)/sin(a+b);
                                                    %pi
                            sin(a) sin(3 (- b - a + ---))
                                                     3
          (%o2)             -----------------------------
                                     sin(b + a)
          (%i3) ba : bc, c=a, a=c;
                                                   %pi
                              sin(3 a) sin(b + a - ---)
                                                    3
          (%o3)               -------------------------
                                            %pi
                                    sin(a - ---)
                                             3
          (%i4) ac2 : ba^2 + bc^2 - 2*bc*ba*cos(b);
                   2         2         %pi
                sin (3 a) sin (b + a - ---)
                                        3
          (%o4) ---------------------------
                          2     %pi
                       sin (a - ---)
                                 3
                                                 %pi
           - (2 sin(a) sin(3 a) sin(3 (- b - a + ---)) cos(b)
                                                  3
                       %pi            %pi
           sin(b + a - ---))/(sin(a - ---) sin(b + a))
                        3              3
                2       2              %pi
             sin (a) sin (3 (- b - a + ---))
                                        3
           + -------------------------------
                          2
                       sin (b + a)
          (%i5) trigrat (ac2);
          (%o5) - (sqrt(3) sin(4 b + 4 a) - cos(4 b + 4 a)
           - 2 sqrt(3) sin(4 b + 2 a) + 2 cos(4 b + 2 a)
           - 2 sqrt(3) sin(2 b + 4 a) + 2 cos(2 b + 4 a)
           + 4 sqrt(3) sin(2 b + 2 a) - 8 cos(2 b + 2 a) - 4 cos(2 b - 2 a)
           + sqrt(3) sin(4 b) - cos(4 b) - 2 sqrt(3) sin(2 b) + 10 cos(2 b)
           + sqrt(3) sin(4 a) - cos(4 a) - 2 sqrt(3) sin(2 a) + 10 cos(2 a)
           - 9)/4


File: maxima.info,  Node: Hyperbelfunktionen,  Next: Zufallszahlen,  Prev: Winkelfunktionen,  Up: Mathematische Funktionen

10.6 Hyperbelfunktionen
=======================

* Menu:

* Einführung in Hyperbelfunktionen::
* Funktionen und Variablen für Hyperbelfunktionen::


File: maxima.info,  Node: Einführung in Hyperbelfunktionen,  Next: Funktionen und Variablen für Hyperbelfunktionen,  Prev: Hyperbelfunktionen,  Up: Hyperbelfunktionen

10.6.1 Einführung in Hyperbelfunktionen
---------------------------------------


File: maxima.info,  Node: Funktionen und Variablen für Hyperbelfunktionen,  Prev: Einführung in Hyperbelfunktionen,  Up: Hyperbelfunktionen

10.6.2 Funktionen und Variablen für Hyperbelfunktionen
------------------------------------------------------

 -- Funktion: asinh (<x>)
 -- Funktion: acosh (<x>)
 -- Funktion: atanh (<x>)
 -- Funktion: acoth (<x>)
 -- Funktion: acsch (<x>)
 -- Funktion: asech (<x>)
     Die inversen Hyperbelfunktionen: Areasinus Hyperbolicus,
     Areakosinus Hyperbolicus, Areatangens Hyperbolicus, Areakotangens
     Hyperbolicus, Areakosekans Hyperbolicus, Areasekans Hyperbolicus.

 -- Funktion: sinh (<x>)
 -- Funktion: cosh (<x>)
 -- Funktion: tanh (<x>)
 -- Funktion: coth (<x>)
 -- Funktion: csch (<x>)
 -- Funktion: sech (<x>)
     Die Hyperbelfunktionen: Sinus Hyperbolicus, Kosinus Hyperbolicus,
     Tangens Hyperbolicus, Kotangens Hyperbolicus, Kosekans
     Hyperbolicus, Sekans Hyperbolicus.


File: maxima.info,  Node: Zufallszahlen,  Prev: Hyperbelfunktionen,  Up: Mathematische Funktionen

10.7 Zufallszahlen
==================

 -- Funktion: make_random_state (<n>)
 -- Funktion: make_random_state (<s>)
 -- Funktion: make_random_state (true)
 -- Funktion: make_random_state (false)
     Ein Zufallszustand repräsentiert den Zustand des
     Zufallszahlengenerators.  Der Zustand enthält 627 32-Bit Worte.

     `make_random_state(<n>)' gibt einen neuen Zufallszustand zurück,
     der aus einer ganzen Zahl <n> modulo 2^32 erzeugt wird.  <n> kann
     eine negative Zahl sein.

     `make_random_state(<s>)' gibt eine Kopie des Zufallszutandes <s>
     zurück.

     `make_random_state(true)' gibt einen neuen Zufallszustand zurück,
     der aus der aktuellen Systemzeit des Computers erzeugt wird.

     `make_random_state(false)' gibt eine Kopie des aktuellen Zustands
     des Zufallszahlengenerators zurück.

 -- Funktion: set_random_state (<s>)
     Kopiert <s> in den Zufallszustand des Zufallszahlengenerators.

     `set_random_state' gibt immer `done' zurück.

 -- Funktion: random (<x>)
     Erzeugt eine Pseudo-Zufallszahl.  Ist <x> eine ganze Zahl, gibt
     `random(<x>)' eine ganze Zahl im Intervall 0 bis einschließlich
     `<x>-1' zurück.  Ist <x> eine Gleitkommazahl, gibt `random(<x>)'
     eine positive Gleitkommazahl zurück, die kleiner als <x> ist.
     `random' gibt eine Fehlermeldung, wenn <x> weder eine ganze Zahl
     noch eine Gleitkommazahl ist oder wenn <x> eine negative Zahl ist.

     Die Funktionen `make_random_state' und `set_random_state' verwalten
     den Zustand des Zufallszahlengenerators.

     Der Maxima-Zufallszahlengenerator ist eine Implementation des
     Mersenne twister MT 19937.

     Beispiele:

          (%i1) s1: make_random_state (654321)$
          (%i2) set_random_state (s1);
          (%o2)                         done
          (%i3) random (1000);
          (%o3)                          768
          (%i4) random (9573684);
          (%o4)                        7657880
          (%i5) random (2^75);
          (%o5)                11804491615036831636390
          (%i6) s2: make_random_state (false)$
          (%i7) random (1.0);
          (%o7)                   .2310127244107132
          (%i8) random (10.0);
          (%o8)                   4.394553645870825
          (%i9) random (100.0);
          (%o9)                   32.28666704056853
          (%i10) set_random_state (s2);
          (%o10)                        done
          (%i11) random (1.0);
          (%o11)                  .2310127244107132
          (%i12) random (10.0);
          (%o12)                  4.394553645870825
          (%i13) random (100.0);
          (%o13)                  32.28666704056853


File: maxima.info,  Node: Maximas Datenbank,  Next: Grafische Darstellung,  Prev: Mathematische Funktionen,  Up: Top

11 Maximas Datenbank
********************

* Menu:

* Einführung in Maximas Datenbank::
* Funktionen und Variablen für Eigenschaften::
* Funktionen und Variablen für Fakten::
* Funktionen und Variablen für Aussagen::


File: maxima.info,  Node: Einführung in Maximas Datenbank,  Next: Funktionen und Variablen für Eigenschaften,  Prev: Maximas Datenbank,  Up: Maximas Datenbank

11.1 Einführung in Maximas Datenbank
====================================

Eigenschaften
-------------

Variablen und Funktionen können mit der Funktion `declare'
Eigenschaften zugewiesen werden.  Diese Eigenschaften werden in eine
Datenbank abgelegt oder in eine von Lisp bereitgestellte
Eigenschaftsliste eingetragen.  Mit der Funktion `featurep'  kann
geprüft werden, ob ein Symbol eine bestimmte Eigenschaft hat und mit
der Funktion `properties'  können alle Eigenschaften eines Symbols
angezeigt werden.  Die Funktion `remove'

löscht Eigenschaften aus der Datenbank oder von der Eigenschaftsliste.
Wird mit der Funktion `kill'  ein Symbol entfernt, werden auch die
zugewiesenen Eigenschaften gelöscht.

Weiterhin können mit den Funktionen `put'  und `qput'  beliebige vom
Nutzer vorgesehene Eigenschaften in die Eigenschaftsliste zu einem
Symbol abgelegt werden.  Mit der Funktion `get'  werden die
Eigenschaften von der Eigenschaftsliste gelesen und mit der Funktion
`rem'  gelöscht.

Variablen können die folgenden Eigenschaften erhalten, die in die
Datenbank eingetragen werden.

   constant
   integer        noninteger
   even           odd
   rational       irrational
   real           imaginary      complex

Funktionen können die folgenden Eigenschaften erhalten, die in die
Datenbank eingetragen werden.

   increasing     decreasing
   posfun         integervalued

Die folgenden Eigenschaften können für Funktionen definiert werden und
wirken sich auf die Vereinfachung dieser Funktionen aus.  Diese
Eigenschaften werden in *note Vereinfachung:: beschrieben.

   linear         additive       multiplicative
   outative       commutative    symmetric
   antisymmetric  nary           lassociativ
   rassociative   evenfun        oddfun

Weitere Eigenschaften, die Variablen und Funktionen erhalten können, und
die in die Lisp-Eigenschaftsliste des Symbols abgelegt werden, sind.

   bindtest       feature        alphabetic
   scalar         nonscalar      nonarray

Kontexte
--------

Maxima verwaltet Kontexte, um Eigenschaften von Variablen und
Funktionen sowie Fakten abzulegen.  Fakten werden mit der Funktion
`assume'  definiert und in dem aktuellen Kontext abgelegt.  Mit
`assume(a>10)' erhält Maxima zum Beispiel die Information, dass die
Variable `a' größer als `10' ist.  Mit der Funktion `forget'  werden
Fakten aus der Datenbank entfernt.  Fragt Maxima den Nutzer nach
Eigenschaften von Variablen, werden die Antworten in einem Kontext
abgelegt.

Ein Kontext hat einen Namen, mit dem auf diesen Bezug genommen werden
kann.  Nach dem Starten von Maxima hat der aktuelle Kontext den Namen
`initial'.  Es kann eine beliebige Anzahl weiterer Kontexte definiert
werden.  Diese können hierarchisch voneinander abhängen.  So ist der
Kontext `initial' ein Unterkontext zum Kontext `global'.  Die Fakten in
einem übergeordneten Kontext sind in dem Unterkontext immer präsent.
Der Kontext `global' enthält zum Beispiel Fakten, die von Maxima
initialisiert werden, und zusätzlich zu den Fakten des Kontextes
`initial' aktiv sind.

Kontexte können eine beliege Anzahl an Fakten aufnehmen.  Sie können
mit der Funktion `deactivate'  deaktiviert werden, ohne dass die Fakten
verloren gehen und später mit der Funktion `activate'  aktiviert
werden, wodurch die Fakten für Aussagefunktionen wieder zur Verfügung
stehen.


File: maxima.info,  Node: Funktionen und Variablen für Eigenschaften,  Next: Funktionen und Variablen für Fakten,  Prev: Einführung in Maximas Datenbank,  Up: Maximas Datenbank

11.2 Funktionen und Variablen für Eigenschaften
===============================================

 -- Eigenschaft: alphabetic
     Das Kommando `declare(string, alphabetic)' deklariert die Zeichen
     der Zeichenkette <string> als alphabetisch.  Das Argument <string>
     muss eine Zeichenkette sein.  Zeichen, die als alphabetisch
     deklariert sind, können in Maxima-Bezeichnern verwendet werden.
     Siehe auch *note Bezeichner::.

     Beispiele:

     Die Zeichen `"~"', `"@"' und ``' als alphabetisch erklärt.

          (%i1) xx\~yy\`\@ : 1729;
          (%o1)                         1729
          (%i2) declare ("~`@", alphabetic);
          (%o2)                         done
          (%i3) xx~yy`@ + @yy`xx + `xx@@yy~;
          (%o3)               `xx@@yy~ + @yy`xx + 1729
          (%i4) listofvars (%);
          (%o4)                  [@yy`xx, `xx@@yy~]

 -- Eigenschaft: bindtest
     Hat ein Symbol <x> die Eigenschaft `bindtest' und wird es
     ausgewertet, ohne das dem Symbol bisher ein Wert zugewiesen wurde,
     signalisiert Maxima einen Fehler.  Siehe auch die Funktion
     `declare'.

     Beispiel:

          (%i1) aa + bb;
          (%o1)                        bb + aa
          (%i2) declare (aa, bindtest);
          (%o2)                         done
          (%i3) aa + bb;
          aa unbound variable
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) aa : 1234;
          (%o4)                         1234
          (%i5) aa + bb;
          (%o5)                       bb + 1234

 -- Eigenschaft: constant
     Das Kommando `declare(<a>, constant)' deklariert ein Symbol <a>
     als konstant.  Die Funktion `constantp'  hat für dieses Symbol
     dann das Ergebnis `true'.  Die Deklaration als eine Konstante
     verhindert nicht, dass dem Symbol ein Wert zugewiesen werden kann.
     Siehe `declare'  und `constantp'.

     Beispiel:

          (%i1) declare(c, constant);
          (%o1)                         done
          (%i2) constantp(c);
          (%o2)                         true
          (%i3) c : x;
          (%o3)                           x
          (%i4) constantp(c);
          (%o4)                         false

 -- Funktion: constantp (<expr>)
     Gibt für einen konstanten Ausdruck <expr> den Wert `true' zurück,
     andernfalls `false'.

     Ein Ausdruck wird von Maxima als ein konstanter Ausdruck erkannt,
     wenn seine Argumente Zahlen sind (einschließlich von Zahlen in
     einer CRE-Darstellung), symbolische Konstanten wie `%pi', `%e' und
     `%i', Variablen, die einen konstanten Wert haben, Variablen, die
     mit `declare' als konstant deklariert sind, oder Funktionen, deren
     Argumente konstant sind.

     Die Funktion `constantp' wertet das Argument aus.

     Siehe auch die Eigenschaft `constant'.

     Beispiele:

          (%i1) constantp (7 * sin(2));
          (%o1)                                true
          (%i2) constantp (rat (17/29));
          (%o2)                                true
          (%i3) constantp (%pi * sin(%e));
          (%o3)                                true
          (%i4) constantp (exp (x));
          (%o4)                                false
          (%i5) declare (x, constant);
          (%o5)                                done
          (%i6) constantp (exp (x));
          (%o6)                                true
          (%i7) constantp (foo (x) + bar (%e) + baz (2));
          (%o7)                                false
          (%i8)

 -- Funktion: declare (<a_1>, <p_1>, <a_2>, <p_2>, ...)
     Weist dem Symbol <a_i> die Eigenschaft <p_i> zu.  Die Argumente
     <a_i> und <p_i> können Listen sein.  Ist <a_i> eine Liste, dann
     erhält jedes Symbol der Liste die Eigenschaft <p_i>.  Ist umgekehrt
     <p_i> eine Liste mit Eigenschaften, dann erhält das Symbol <a_i>
     diese Eigenschaften.  Entsprechend erhalten alle Symbole einer
     Liste <a_i> die Eigenschaften einer Liste <p_i>.

     Die Funktion `declare' wertet die Argumente nicht aus.  `declare'
     gibt stets `done' als Ergebnis zurück.

     Hat ein Symbol <sym> die Eigenschaft <prop> mit der Funktion
     `declare' erhalten, dann hat das Kommando `featurep(<sym>,
     <prop>)' das Ergebnis `true'.  Mit der Funktion `properties'
     können alle Eigenschaften eines Symbols angezeigt werden.

     Mit der Funktion `declare' können Symbole die folgenden
     Eigenschaften erhalten:

    `additive'
          Hat eine Funktion `f' die Eigenschaft `additive', wird ein
          Ausdruck der Form `f(x + y + z + ...)' zu `f(x) + f(y) + f(z)
          + ...' vereinfacht.  Siehe `additive'.

    `alphabetic'
          <a_i> ist eine Zeichenkette, deren Zeichen als alphabetische
          Zeichen deklariert werden.  Die Zeichen können dann in
          Maxima-Bezeichnern verwendet werden.  Siehe `alphabetic'  für
          Beispiele.

    `antisymmetric, commutative, symmetric'
          <a_i> wird als eine symmetrische, antisymmetrische oder
          kommutative Funktion interpretiert.  Die Eigenschaften
          `commutative' und `symmetric' sind äquivalent.  Siehe
          `antisymmetric',  `commutative'  und `symmetric'.

    `bindtest'
          Hat ein Symbol die Eigenschaft `bindtest' und wird es
          ausgewertet, ohne das dem Symbol bisher ein Wert zugewiesen
          wurde, signalisiert Maxima einen Fehler.  Siehe `bindtest'
          für Beispiele.

    `constant'
          Hat ein Symbol die Eigenschaft `constant', wird es von Maxima
          als eine Konstante interpretiert.  Siehe auch `constant'.

    `even, odd'
          Erhält eine Variable die Eigenschaft `even' oder `odd', wird
          sie als gerade oder ungerade interpretiert.

    `evenfun, oddfun'
          Erhält eine Funktion oder ein Operator die Eigenschaft
          `evenfun' oder `oddfun' wird die Funktion oder der Operator
          von Maxima als gerade und ungerade interpretiert.  Diese
          Eigenschaft wird bei der Vereinfachung von Ausdrücken von
          Maxima angewendet.  Siehe `evenfun'  und `oddfun'.

    `evflag'
          Deklariert die Variable `a_i' als einen Auswertungsschalter.
          Während der Auswertung eines Ausdrucks mit der Funktion `ev',
          erhält der Auswertungsschalter `a_i' den Wert `true'.  Siehe
          `evflag'  für Beispiele.

    `evfun'
          Deklariert eine Funktion <a_i> als eine Auswertungsfunktion.
          Tritt die Funktion <a_i> als Argument der Funktion `ev' auf,
          so wird die Funktion auf den Ausdruck angewendet.  Siehe
          `evfun'  für Beispiele.

    `feature'
          <a_i> wird als eine Eigenschaft `feature' interpretiert.
          Andere Symbole können dann diese vom Nutzer definierte
          Eigenschaft erhalten.  Siehe `feature'.

    `increasing, decreasing'
          Erhält eine Funktion die Eigenschaft `decreasing' oder
          `increasing', wird die Funktion als eine monoton steigende
          oder fallende Funktion interpretiert.  Siehe `decreasing'
          und `increasing'.

    `integer, noninteger'
          <a_i> wird als eine ganzzahlige oder nicht-ganzzahlige
          Variable interpretiert.  Siehe `integer'  und `noninteger'.

    `integervalued'
          Erhält eine Funktion die Eigenschaft `integervalued', nimmt
          Maxima für Vereinfachungen an, dass die Funktionen einen
          ganzzahligen Wertebereich hat.  Für ein Beispiel siehe
          `integervalued'.

    `lassociative, rassociative'
          <a_i> wird als eine rechts- oder links-assoziative Funktion
          interpretiert.  Siehe `lassociative'  und `rassociative'.

    `linear'
          Entspricht der Deklaration einer Funktion als `outative' und
          `additive'.  Siehe auch `linear'.

    `mainvar'
          Wird eine Variable als <mainvar> deklariert, wird sie als eine
          "Hauptvariable" interpretiert.  Eine Hauptvariable wird vor
          allen Konstanten und Variablen in einer kanonischen Ordnung
          eines Maxima-Ausdrückes angeordnet.  Die Anordnung wird durch
          die Funktion `ordergreatp' bestimmt.  Siehe auch `mainvar'.

    `multiplicative'
          Hat eine Funktion `f' die Eigenschaft `multiplicative', werden
          Ausdrücke der Form `<a_i>(x * y * z * ...)' zu `<a_i>(x) *
          <a_i>(y) * <a_i>(z) * ...' vereinfacht.  Die Vereinfachung
          wird nur für das erste Argument der Funktion <f> ausgeführt.
          Siehe `multiplicative'.

    `nary'
          Erhält eine Funktion oder ein Operator die Eigenschaft
          `nary', wird die Funktion oder der Operator bei der
          Vereinfachung als Nary-Funktion oder Nary-Operator
          interpretiert.  Verschachtelte Ausdrücke wie `foo(x, foo(y,
          z))' werden zum Beispiel zu `foo(x, y, z)' vereinfacht.  Die
          Deklaration `nary' unterscheidet sich von der Funktion `nary'.
          Während der Funktionsaufruf einen neuen Operator definiert,
          wirkt sich die Deklaration nur auf die Vereinfachung aus.
          Siehe auch `nary'.

    `nonarray'
          Hat ein Symbol <a_i> die Eigenschaft `nonarray', wird es
          nicht als ein Array interpretiert, wenn das Symbol einen
          Index erhält.  Diese Deklaration verhindert die mehrfache
          Auswertung, wenn <a_i> als indizierte Variable genutzt wird.
          Siehe  `nonarray'.

    `nonscalar'
          <a_i> wird als eine nicht-skalare Variable interpretiert.
          Ein Symbol wird also als ein Vektor oder eine Matrix
          deklariert.  Siehe `nonscalar'.

    `noun'
          <a_i> wird als Substantivform interpretiert.  Abhängig vom
          Kontext wird <a_i> durch `'<a_i>' oder `nounify(<a_i>)'
          ersetzt.  Siehe auch `noun'.   für ein Beispiel.

    `outative'
          Ausdrücke mit der Funktion <a_i> werden so vereinfacht, dass
          konstante Faktoren aus dem Argument herausgezogen werden.
          Hat die Funktion <a_i> ein Argument, wird ein Faktor dann als
          konstant angesehen, wenn er ein Symbol oder eine deklarierte
          Konstante ist.  Hat die Funktion <a_i> zwei oder mehr
          Argumente, wird ein Faktor dann als konstant angesehen, wenn
          das zweite Argument ein Symbol und der Faktor unabhängig vom
          zweiten Argument ist.  Siehe auch `outative'.

    `posfun'
          <a_i> wird als eine Funktion interpretiert, die nur positive
          Werte hat.  Siehe `posfun'.

    `rational, irrational'
          <a_i> wird als eine rationale oder irrationale Zahl
          interpretiert.  Siehe `rational'  und `irrational'.

    `real, imaginary, complex'
          <a_i> wird als eine reelle, imaginäre oder komplexe Zahl
          interpretiert.  Siehe `real',  `imaginary'  und `complex'.

    `scalar'
          <a_i> wird als skalare Variable interpretiert.  Siehe
          `scalar'.


 -- Eigenschaft: decreasing
 -- Eigenschaft: increasing
     Erhält eine Funktion mit der Funktion `declare'  die Eigenschaft
     `decreasing' oder `increasing' wird die Funktion als eine steigende
     oder fallende Funktion interpretiert.

     Beispiel:

          (%i1) assume(a > b);
          (%o1)                        [a > b]
          (%i2) is(f(a) > f(b));
          (%o2)                        unknown
          (%i3) declare(f, increasing);
          (%o3)                         done
          (%i4) is(f(a) > f(b));
          (%o4)                         true

 -- Eigenschaften: even
 -- Eigenschaften: odd
     Hat eine Variable mit der Funktion `declare'  die Eigenschaft
     `even' oder `odd' erhalten, wird sie von Maxima als gerade oder
     ungerade ganze Zahl interpretiert.  Diese Eigenschaften werden
     jedoch nicht von den Funktionen `evenp',  `oddp'  oder `integerp'
     erkannt.

     Siehe auch die Funktion `askinteger'.

     Beispiele:

          (%i1) declare(n, even);
          (%o1)                         done
          (%i2) askinteger(n, even);
          (%o2)                          yes
          (%i3) askinteger(n);
          (%o3)                          yes
          (%i4) evenp(n);
          (%o4)                         false

 -- Eigenschaft: feature
     `feature' ist eine Eigenschaft, die ein Symbol <sym> mit der
     Funktion `declare' erhalten kann.  In diesem Fall ist das Symbol
     <sym> selbst eine Eigenschaft, so dass das Kommando `declare(x,
     sym)' einem Symbol <x> die vom Nutzer definierte Eigenschaft `sym'
     gibt.

     Maxima unterscheidet Systemeigenschaften und mathematische
     Eigenschaften, die Symbole und Ausdrücke haben können.  Für
     Systemeigenschaften siehe die Funktion `status'.    Für
     mathematische Eigenschaften siehe die Funktionen `declare'  und
     `featurep'.

     Beispiel:

          (%i1) declare (FOO, feature);
          (%o1)                         done
          (%i2) declare (x, FOO);
          (%o2)                         done
          (%i3) featurep (x, FOO);
          (%o3)                         true

 -- Funktion: featurep (<a>, <p>)
     Stellt fest, ob das Symbol oder der Ausdruck <a> die Eigenschaft
     <p> hat.  Maxima nutzt die Fakten der aktiven Kontexte und die
     definierten Eigenschaften für Symbole und Funktionen.

     `featurep' gibt sowohl für den Fall `false' zurück, dass das
     Argument <a> nicht die Eigenschaft <p> hat, als auch für den Fall,
     dass Maxima dies nicht anhand der bekannten Fakten und
     Eigenschaften entscheiden kann.

     `featurep' wertet die Argumente aus.

     Siehe auch `declare'  und `featurep'.  .

     Beispiele:

          (%i1) declare (j, even)$
          (%i2) featurep (j, integer);
          (%o2)                           true

 -- Systemvariable: features
     Maxima kennt spezielle mathematische Eigenschaften von Funktionen
     und Variablen.

     `declare(<x>)', <foo> gibt der Funktion oder Variablen <x> die
     Eigenschaft <foo>.

     `declare(<foo>, feature)' deklariert die neue Eigenschaft <foo>.
     Zum  Beispiel deklariert `declare([red, green, blue], feature)'
     die drei neuen Eigenschaften `red', `green' und `blue'.

     `featurep(<x>, <foo>)' hat die Rückgabe `true', wenn <x> die
     Eigenschaft <foo> hat.  Ansonsten wird `false' zurückgegeben.

     Die Informationsliste `features' enthält eine Liste der
     Eigenschaften, die Funktionen und Variablen erhalten können und
     die in die Datenbank eingetragen werden:

        integer         noninteger       even
        odd             rational         irrational
        real            imaginary        complex
        analytic        increasing       decreasing
        oddfun          evenfun          posfun
        commutative     lassociative     rassociative
        symmetric       antisymmetric

     Hinzu kommen die vom Nutzer definierten Eigenschaften.

     `features' ist eine Liste der mathematischen Eigenschaften.  Es
     gibt weitere Eigenschaften.  Siehe `declare'  und `status'.


 -- Funktion: get (<a>, <i>)
     Gibt die Eigenschaft <i> des Symbols <a> zurück.  Hat das Symbol
     <a> nicht die Eigenschaft <i>, wird `false' zurückgegeben.

     `get' wertet die Argumente aus.

     Beispiele:

          (%i1) put (%e, 'transcendental, 'type);
          (%o1)                    transcendental
          (%i2) put (%pi, 'transcendental, 'type)$
          (%i3) put (%i, 'algebraic, 'type)$
          (%i4) typeof (expr) := block ([q],
                  if numberp (expr)
                  then return ('algebraic),
                  if not atom (expr)
                  then return (maplist ('typeof, expr)),
                  q: get (expr, 'type),
                  if q=false
                  then errcatch (error(expr,"is not numeric.")) else q)$
          (%i5) typeof (2*%e + x*%pi);
          x is not numeric.
          (%o5)  [[transcendental, []], [algebraic, transcendental]]
          (%i6) typeof (2*%e + %pi);
          (%o6)     [transcendental, [algebraic, transcendental]]

 -- Eigenschaften: integer
 -- Eigenschaften: noninteger
     Hat eine Variable mit der Funktion `declare'  die Eigenschaft
     `integer' oder `noninteger' erhalten, wird sie von Maxima als eine
     ganze Zahl oder als nicht-ganze Zahl interpretiert.  Siehe auch
     `askinteger'.

     Beispiele:

          (%i1) declare(n, integer, x, noninteger);
          (%o1)                         done
          (%i2) askinteger(n);
          (%o2)                          yes
          (%i3) askinteger(x);
          (%o3)                          no

 -- Eigenschaft: integervalued
     Erhält eine Funktion mit `declare'  die Eigenschaft
     `integervalued', nimmt Maxima für Vereinfachungen an, dass der
     Wertebereich der Funktion ganzzahlig ist.

     Beispiel:

          (%i1) exp(%i)^f(x);
                                        %i f(x)
          (%o1)                      (%e  )
          (%i2) declare(f, integervalued);
          (%o2)                         done
          (%i3) exp(%i)^f(x);
                                        %i f(x)
          (%o3)                       %e

 -- Eigenschaft: nonarray
     `declare(a, nonarray)' gibt dem Symbol <a> die Eigenschaft nicht
     ein Array zu sein.  Dies verhindert die mehrfache Auswertung, wenn
     das Symbol <a> als indizierte Variable genutzt wird.

     Beispiel:

          (%i1) a:'b$ b:'c$ c:'d$

          (%i4) a[x];
          (%o4)                          d
                                          x
          (%i5) declare(a, nonarray);
          (%o5)                         done
          (%i6) a[x];
          (%o6)                          a
                                          x

 -- Eigenschaft: nonscalar
     Hat ein Symbol die Eigenschaft `nonscalar', verhält es sich wie
     eine Matrix oder Liste bei nicht-kommutativen Rechenoperationen.

 -- Funktion: nonscalarp (<expr>)
     Gibt `true' zurück, wenn der Ausdruck <expr> kein Skalar ist.  Der
     Ausdruck enthält dann Matrizen, Listen oder Symbole, die als
     `nonscalar' deklariert wurden.

 -- Eigenschaft: posfun
     `declare(f, posfun)' deklariert die Funktion `f' als eine Funktion,
     die nur positive Werte annimmt.  `is(f(x) > 0)' gibt dann `true'
     zurück.

 -- Funktion: printprops (<a>, <i>)
 -- Funktion: printprops ([<a_1>, ..., <a_n>], <i>)
 -- Funktion: printprops (all, <i>)
     Zeigt die zum Kennzeichen <i> zugeordnete Eigenschaft des Atoms
     <a> an.  <i> kann einer der Werte `gradef', `atvalue', `atomgrad'
     oder `matchdeclare' sein.  <a> kann sowohl eine Liste von Atomen,
     als auch das Atom `all' sein.  In diesem Fall werden alle Atome
     angezeigt, die eine Eigenschaft zum Kennzeichen <i> haben.

     Beispiel:

          (%i1) gradef(f(x), 2*g(x));
          (%o1)                         f(x)
          (%i2) printprops(f,gradef);
                                 d
                                 -- (f(x)) = 2 g(x)
                                 dx

          (%o2)                         done

 -- Funktion: properties (<a>)
     Gibt eine Liste mit den Eigenschaften zurück, die das Symbol <a>
     von Maxima oder dem Nutzer erhalten hat.  Die Rückgabe kann jede
     Eigenschaft enthalten, die mit der Funktion `declare'  einem
     Symbol zugewiesen ist.  Diese Eigenschaften sind:

        linear         additive       multiplicative
        outative       commutative    symmetric
        antisymmetric  nary           lassociativ
        rassociative   evenfun        oddfun
        bindtest       feature        alphabetic
        scalar         nonscalar      nonarray
        constant       integer        noninteger
        even           odd            rational
        irrational     real           imaginary
        complex        increasing     decreasing
        posfun         integervalued

     Die folgenden Einträge beschreiben Eigenschaften, die Variablen
     haben können:

    `value'
          Der Variable ist mit dem Operatoren `:'  oder `::'  ein Wert
          zugewiesen.

    `system value'
          Die Variable ist eine Optionsvariable oder Systemvariable,
          die von Maxima definiert ist.

    `numer'
          Die Variable hat einen numerischen Wert auf der
          Eigenschaftsliste, der mit der Funktion `numerval'
          zugewiesen ist.

    `assign property'
          Die Variable hat eine eine Funktion auf der
          Eigenschaftsliste, die die Zuweisung eines Wertes
          kontrolliert.

     Einträge, die die Eigenschaften von Funktionen beschreiben:

    `function'
          Eine mit dem Operator `:='  oder der Funktion `define'
          definierte Nutzerfunktion.

    `macro'
          Eine mit dem Operator `::='  definierte Makrofunktion.

    `system function'
          Ein interne Maxima-Funktion.

    `special evaluation form'
          Eine Maxima-Spezialform, die die Argumente nicht auswertet.

    `transfun'
          Wird eine Nutzerfunktion mit `translate'  übersetzt oder mit
          der Funktion `compile'  kompiliert, erhält sie die
          Eigenschaft `transfun'.  Interne Maxima-Funktionen, die mit
          dem Lisp-Makro `defmfun' definiert werden, haben ebenfalls
          diese Eigenschaft.

    `deftaylor'
          Für die Funktion ist eine Taylorreihenentwicklung definiert.

    `gradef'
          Die Funktion hat eine Ableitung.

    `integral'
          Die Funktion hat eine Stammfunktion.

    `distribute over bags'
          Ist das Argument der Funktion eine Liste, Matrix oder
          Gleichung so wird die Funktion auf die Elemente oder beide
          Seiten der Gleichung angewendet.

    `limit function'
          Es existiert eine Funktion für die Behandlung spezieller
          Grenzwerte.

    `conjugate function'
          Es existiert eine Funktion, um die konjugiert komplexe
          Funktion für spezielle Wertebereiche zu ermitteln.

    `mirror symmetry'
          Die Funktion hat die Eigenschaft der Spiegelsymmetrie.

    `complex characteristic'
          Es existiert eine Funktion, um den Realteil und den
          Imaginärteil der Funktion für spezielle Wertebereiche zu
          ermitteln.

    `user autoload function'
          Die Funktion wird automatisch beim ersten Aufruf aus einer
          Datei geladen.  Der Nutzer kann mit dem Funktion
          `setup_autoload'  eine solche Funktion definieren.

     Weitere Eigenschaften, die Symbole erhalten können:

    `operator'
          Das Symbol ist ein Maxima-Operator oder ein nutzerdefinierte
          Operator.

    `rule'
          Die Funktion oder der Operator haben eine Regel für die
          Vereinfachung.

    `alias'

    `database info'
          Das Symbol hat Einträge in Maximas Datenbank.

    `hashed array, declared array, complete array'
          Ein Hashed-Array, ein deklariertes Array oder ein Array
          dessen Elemente einen bestimmten Typ haben.

    `array function'
          Eine Array-Funktion die mit dem Operator `:='  definiert ist.

    `atvalue'
          Dem Symbol ist mit der Funktion `atvalue'  ein Wert an einer
          Stelle zugewiesen.

    `atomgrad'
          Für das Symbol ist mit der Funktion `gradef'  eine Ableitung
          definiert.

    `dependency'
          Für das Symbol ist eine Abhängigkeit mit der Funktion
          `depends'

          definiert.

    `matchdeclare'
          Das Symbol ist eine mit `matchdeclare'  definierte
          Mustervariable, der eine Aussagefunktion zugeordnet ist.

    `modedeclare'
          Für das Symbol ist mit der Funktion `mode_declare'  ein Typ
          definiert.

    `user properties'

    `context'
          Das Symbol bezeichnet einen Kontext.

    `activecontext'
          Das Symbol bezeichnet einen aktiven Kontextes.

 -- Systemvariable: props
     Standardwert: `[]'

     `props' ist eine Liste der Symbole, die vom Nutzer eine Eigenschaft
     erhalten haben, die in die Lisp-Eigenschaftsliste des Symbols
     eingetragen wird.  Neben den Funktionen `put'  und `qput',  mit
     denen der Nutzer direkt eine Eigenschaft zu einem Symbol in die
     Lisp-Eigenschaftsliste eintragen kann, legen auch
     Maxima-Funktionen Eigenschaften zu Symbolen in der
     Eigenschaftsliste ab und tragen diese Symbole in die
     Systemvariable `props' ein.  Zu diesen Funktionen gehören zum
     Beispiel `declare',

     `numerval',  `matchdeclare',  `mode_declare',

     `gradef'  oder `setup_autoload'.

     Nach dem Start von Maxima sollte die Systemvariable `props' keine
     Symbole enthalten.  Das ist jedoch nicht der Fall und kann als ein
     Fehler betrachtet werden, der in Zukunft zu beheben ist.

 -- Funktion: propvars (<prop>)
     Gibt eine Liste mit den Atomen zurück, die in der Informationsliste
     `props' eingetragen sind und die die Eigenschaft <prop> haben.  Zum
     Beispiel gibt `propvars(atvalue)' eine Liste der Atome zurück, die
     die Eigenschaft `atvalue' haben.

 -- Funktion: put (<atom>, <value>, <indicator>)
     Weist den Wert <value> der Eigenschaft <indicator> des Atoms <atom>
     zu.  <indicator> kann eine beliebige Eigenschaft sein und
     beschränkt sich nicht auf die vom System definierten
     Eigenschaften.  `put' wertet die Argumente aus.  `put' gibt
     <value> zurück.

     Beispiele:

          (%i1) put (foo, (a+b)^5, expr);
                                             5
          (%o1)                       (b + a)
          (%i2) put (foo, "Hello", str);
          (%o2)                         Hello
          (%i3) properties (foo);
          (%o3)            [[user properties, str, expr]]
          (%i4) get (foo, expr);
                                             5
          (%o4)                       (b + a)
          (%i5) get (foo, str);
          (%o5)                         Hello

 -- Funktion: qput (<atom>, <value>, <indicator>)
     Entspricht der Funktion `put' mit dem Unterschied, dass `qput' die
     Argumente nicht auswertet.

     Beispiele:

          (%i1) foo: aa$
          (%i2) bar: bb$
          (%i3) baz: cc$
          (%i4) put (foo, bar, baz);
          (%o4)                          bb
          (%i5) properties (aa);
          (%o5)                [[user properties, cc]]
          (%i6) get (aa, cc);
          (%o6)                          bb
          (%i7) qput (foo, bar, baz);
          (%o7)                          bar
          (%i8) properties (foo);
          (%o8)            [value, [user properties, baz]]
          (%i9) get ('foo, 'baz);
          (%o9)                          bar

 -- Eigenschaft: rational
 -- Eigenschaft: irrational
     Hat eine Variable mit der Funktion `declare'  die Eigenschaft
     `rational' oder `irrational' erhalten, wird sie von Maxima als eine
     rationale Zahl oder als eine nicht rationale Zahl interpretiert.

 -- Eigenschaft: real
 -- Eigenschaft: imaginary
 -- Eigenschaft: complex
     Hat eine Variable mit der Funktion `declare'  die Eigenschaft
     `real', `imaginary' oder `complex' erhalten, wird sie von Maxima
     als eine reelle Zahl, imaginäre Zahl oder als eine komplexe Zahl
     interpretiert.

 -- Funktion: rem (<atom>, <indicator>)
     Entfernt die Eigenschaft <indicator> vom Atom <atom>.

 -- Funktion: remove (<a_1>, <p_1>, ..., <a_n>, <p_n>)
 -- Funktion: remove ([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)
 -- Funktion: remove ("<a>", operator)
 -- Funktion: remove (<a>, transfun)
 -- Funktion: remove (all, <p>)
     Entfernt Eigenschaften von Atomen.

     `remove(<a_1>, <p_1>, ..., <a_n>, <p_n>)' entfernt die Eigenschaft
     `p_k' von dem Atom `a_k'.

     `remove([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)' entfernt
     die Eigenschaften <p_1>, ..., <p_n> von den Atomen <a_1>, ...,
     <a_m>.  Es können mehrere Paare an Listen angegeben werden.

     `remove(all, <p>)' entfernt die Eigenschaft <p> von allen Atomen,
     die diese Eigenschaft aufweisen.

     Die zu entfernenden Eigenschaften können vom System definierte
     Eigenschaften wie `function', `macro', `mode_declare' oder
     nutzerdefinierte Eigenschaften sein.

     `remove("<a>", operator)' oder `remove("<a>", op)' entfernen vom
     Atom <a> die Operatoreigenschaften, die mit den Funktionen
     `prefix',  `infix',  `nary',  `postfix',

     `matchfix'  oder `nofix'  definiert wurden.  Die Namen von
     Operatoren müssen als eine Zeichenkette angegeben werden.

     `remove' gibt immer `done' zurück.

 -- Eigenschaft: scalar
     Hat ein Symbol die Eigenschaft `scalar', verhält es sich wie ein
     Skalar bei nicht-kommutativen Rechenoperationen.

 -- Funktion: scalarp (<expr>)
     Gibt `true' zurück, wenn der Ausdruck <expr> eine Zahl, Konstante,
     ein als Skalar definiertes Symbol oder ein aus diesen Objekten
     zusammengesetzter Ausdruck ist.  Der Ausdruck darf jedoch keine
     Liste oder eine Matrix sein.


File: maxima.info,  Node: Funktionen und Variablen für Fakten,  Next: Funktionen und Variablen für Aussagen,  Prev: Funktionen und Variablen für Eigenschaften,  Up: Maximas Datenbank

11.3 Funktionen und Variablen für Fakten
========================================

 -- Funktion: activate (<context_1>, ..., <context_n>)
     Das Kommando `activate(<context>)' aktiviert den Kontext <context>.
     Der Funktion `activate' können mehrere Kontexte <context_1>, ...,
     <context_n> übergeben werden.  Nur die Aussagen und Fakten eines
     aktiven Kontextes stehen für die Auswertung von Aussagen zur
     Verfügung.

     Maxima gibt `done' zurück, wenn der Kontext erfolgreich aktiviert
     werden konnte oder wenn der Kontext bereits aktiv ist.  Wird
     versucht einen nicht existierenden Kontext zu aktivieren, gibt
     Maxima eine Fehlermeldung aus.

     Das Kommando `facts()' gibt die Fakten und Aussagen des aktuellen
     Kontextes aus.  Die Aussagen und Fakten anderer Kontexte können
     zwar aktiv sein, sind aber in der Rückgabe von `facts' nicht
     enthalten.  Um die Aussagen und Fakten eines anderen als des
     aktuellen Kontexts auszugeben, kann das Kommando
     `facts(<context>)' ausgeführt werden.

     Die Systemvariable `activecontexts'  enthält eine Liste der aktiven
     Kontexte.  Siehe auch die Systemvariable `contexts'  für eine Liste
     aller Kontexte, die Maxima kennt.

 -- Systemvariable: activecontexts
     Standardwert: `[]'

     Die Systemvariable `activecontexts' enthält eine Liste der
     Kontexte, die mit der Funktion `activate' aktiviert wurden.
     Unterkontexte sind aktiv, ohne dass die Funktion `activate'
     aufgerufen werden muss und sind nicht in der Liste
     `activecontexts' enthalten.  Siehe auch die Funktion `activate'
     für die Aktivierung eines Kontextes und die Systemvariable
     `contexts'  für eine Liste aller vorhandenen Kontexte.

 -- Funktion: askinteger (<expr>, integer)
 -- Funktion: askinteger (<expr>)
 -- Funktion: askinteger (<expr>, even)
 -- Funktion: askinteger (<expr>, odd)
     Das Kommando `askinteger(<expr>, integer)' versucht anhand der
     Aussagen und Fakten der aktiven Kontexte zu entscheiden, ob <expr>
     eine ganze Zahl repräsentiert.  Kann `askinteger' die Frage nicht
     entscheiden, fragt Maxima den Nutzer.  Die Antwort wird dem
     aktuellen Kontext hinzugefügt.  `askinteger(<expr>)' ist
     äquivalent zu `askinteger(<expr>, integer)'.

     `askinteger(<expr>, even)' und `askinteger(<expr>, odd)' versuchen
     zu entscheiden, ob <expr> eine gerade oder ungerade ganze Zahl
     repräsentiert.  Kann Maxima dies nicht entscheiden, wird der
     Nutzer gefragt.  Die Antwort wird dem aktuellen Kontext
     hinzugefügt.

     Beispiele:

          (%i1) askinteger(n,integer);
          Is n an integer?
          yes;
          (%o1)                          yes
          (%i2) askinteger(e,even);
          Is e an even number?
          yes;
          (%o2)                          yes
          (%i3) facts();
          (%o3)           [kind(n, integer), kind(e, even)]
          (%i4) declare(f,integervalued);
          (%o4)                         done
          (%i5) askinteger(f(x));
          (%o5)                          yes

 -- Funktion: asksign (<expr>)
     Die Funktion `asksign' versucht zu entscheiden, ob der Ausdruck
     <expr> einen positiven, negativen oder den Wert Null
     repräsentiert.  Kann Maxima dies nicht feststellen, wird der
     Nutzer nach weiteren Informationen gefragt, um die Frage zu
     entscheiden.  Die Antworten des Nutzers werden für die laufende
     Auswertung dem aktuellen Kontext hinzugefügt.  Der Rückgabewert der
     Funktion `asksign' ist `pos', `neg' oder `zero' für einen
     positiven, negativen oder den Wert Null.

 -- Funktion: assume (<pred_1>, ..., <pred_n>)
     Fügt die Aussagen <pred_1>, ..., <pred_n> dem aktuellen Kontext
     hinzu.  Eine inkonsistente oder redundante Aussage wird dem
     Kontext nicht hinzugefügt.  `assume' gibt eine Liste mit den
     Aussagen zurück, die dem Kontext hinzugefügt wurden, oder die
     Symbole `redunant' und `inconsistent'.

     Die Aussagen <pred_1>, ..., <pred_n> können nur Ausdrücke mit den
     relationalen Operatoren `"<"', `"<="', `equal', `notequal', `">="'
     und `">"' sein.  Aussagen können nicht die Operatoren `"="' für
     Gleichungen oder `"#"' für Ungleichungen enthalten.  Auch können
     keine Aussagefunktionen wie `integerp' verwendet werden.

     Zusammengesetzte Aussagen mit dem Operator `and' der Form
     `<pred_1> and ... and <pred_n>' sind möglich, nicht dagegen
     Aussagen mit dem Operator `or' der Form `<pred_1> or ... or
     <pred_n>'.  Ein Ausdruck mit dem Operator `not' der Form
     `not(<pred_k>)' ist dann möglich, wenn <pred_k> eine relationale
     Aussage ist.  Aussagen der Form `not (<pred_1> and <pred_2>)' und
     `not (<pred_1> or <pred_2>)' sind dagegen nicht möglich.

     Der Folgerungsmechanismus von Maxima ist nicht sehr stark.  Viele
     Schlußfolgerungen können von Maxima nicht abgeleitet werden.  Dies
     ist eine bekannte Schwäche von Maxima.

     `assume' behandelt keine Aussagen mit komplexen Zahlen.  Enthält
     eine Aussage eine komplexe Zahl, gibt `assume' den Wert
     `inconsistent' oder `redunant' zurück.

     `assume' wertet die Argumente aus.

     Siehe auch `is',  `facts',  `forget',

     `context'  und `declare'.

     Beispiele:

          (%i1) assume (xx > 0, yy < -1, zz >= 0);
          (%o1)              [xx > 0, yy < - 1, zz >= 0]
          (%i2) assume (aa < bb and bb < cc);
          (%o2)                  [bb > aa, cc > bb]
          (%i3) facts ();
          (%o3)     [xx > 0, - 1 > yy, zz >= 0, bb > aa, cc > bb]
          (%i4) is (xx > yy);
          (%o4)                         true
          (%i5) is (yy < -yy);
          (%o5)                         true
          (%i6) is (sinh (bb - aa) > 0);
          (%o6)                         true
          (%i7) forget (bb > aa);
          (%o7)                       [bb > aa]
          (%i8) prederror : false;
          (%o8)                         false
          (%i9) is (sinh (bb - aa) > 0);
          (%o9)                        unknown
          (%i10) is (bb^2 < cc^2);
          (%o10)                       unknown

 -- Optionsvariable: assumescalar
     Standardwert: `true'

     Die Optionsvariable `assumescalar' kontrolliert, wie ein Ausdruck
     von den arithmetischen Operatoren `"+"', `"*"', `"^"', `"."' und
     `"^^"' behandelt wird, wenn Maxima nicht ermitteln kann, ob der
     Ausdruck ein Skalar oder Nicht-Skalar ist.  `assumescalar' hat
     drei mögliche Werte:

    `false'
          Unbekannte Ausdrücke werden als ein Nicht-Skalar behandelt.

    `true'
          Unbekannte Ausdrücke werden als ein Skalar für die
          kommutativen arithmetischen Operatoren `"+"', `"*"' und `"^"'
          behandelt.

    `all'
          Unbekannte Ausdrücke werden für alle arithmetischen
          Operatoren als ein Skalar behandelt.

     Es ist besser Variablen als ein Skalar oder Nicht-Skalar mit der
     Funktion `declare'  zu deklarieren, anstatt die Vereinfachung mit
     der Optionsvariablen `assumescalar' zu kontrollieren.  Siehe auch
     die Eigenschaften `scalar'  und `nonscalar'  sowie die Funktionen
     `scalarp'  und `nonscalarp'.

     Beispiele:

     Maxima kann nicht ermitteln, ob das Symbol `x' ein Skalar oder ein
     Nicht-Skalar ist.

          (%i1) scalarp(x);
          (%o1)                         false
          (%i2) nonscalarp(x);
          (%o2)                         false

     Hat `assumescalar' den Wert `true', behandelt Maxima das Symbol
     `x' als einen Skalar für die kommutative Multiplikation.

          (%i3) x * [a,b,c], assumescalar:false;
          (%o3)                      x [a, b, c]
          (%i4) x * [a,b,c], assumescalar:true;
          (%o4)                    [a x, b x, c x]

     Für die nicht kommutative Multiplikation behandelt Maxima das
     Symbol `x' dann als einen Skalar, wenn `assumescalar' den Wert
     `all' hat.

          (%i5) x . [a,b,c], assumescalar:false;
          (%o5)                     x . [a, b, c]
          (%i6) x . [a,b,c], assumescalar:true;
          (%o6)                     x . [a, b, c]
          (%i7) x . [a,b,c], assumescalar:all;
          (%o7)                 [x . a, x . b, x . c]

 -- Optionsvariable: assume_pos
     Standardwert: `false'

     Die Optionsvariable `assume_pos' kontrolliert das Ergebnis der
     Funktionen `sign'  und `asksign',  für den Fall, dass Maxima das
     Vorzeichen einer Variablen oder indizierten Variablen nicht aus
     den aktiven Kontexten ermitteln kann.  Hat `assume_pos' den Wert
     `true', dann wird für Variable oder indizierte Variable, immer das
     Ergebnis `pos' ermittelt, wenn die Optionsvariable
     `assume_pos_pred' den Standardwert `false' hat und das Vorzeichen
     nicht aus den aktiven Kontexten ermittelt werden kann.

     Die Optionsvariable `assume_pos_pred'  hat den Standardwert
     `false'.  In diesem Fall werden von Maxima Variablen und
     indizierte Variablen als positiv angenommen, wenn `assume_pos' den
     Wert `true' hat.  Der Optionsvariablen `assume_pos_pred'  kann
     eine Aussagefunktion mit einem Argument zugewiesen werden.  Hat
     die Aussagefunktion für ein Argument <expr> das Ergebnis `true',
     wird das Argument als positiv angenommen, wenn die Optionsvariable
     `assume_pos' den Wert `true' hat und Maxima das Vorzeichen nicht
     aus den aktiven Kontexten ermitteln kann.

     Die Funktionen `sign' und `asksign' versuchen das Vorzeichen eines
     Ausdrucks anhand der Vorzeichen der Argumente zu ermitteln.  Sind
     zum Beispiel `a' und `b' beide positiv, dann wird für den Ausdruck
     `a+b' ein positives Vorzeichen ermittelt.  Auch wenn die
     Vorzeichen der Variablen `a' und `b' nicht bekannt sind, hat daher
     `asksign(a+b)' das Ergebnis `pos', wenn `assume_pos' den Wert
     `true' hat, da in diesem Fall die Variablen als positiv angenommen
     werden.

     Es gibt jedoch keine Möglichkeit, alle Ausdrücke grundsätzlich als
     positiv zu erklären.  Selbst wenn der Optionsvariablen
     `assume_pos_pred' eine Aussagefunktion zugewiesen wird, die alle
     Ausdrücke als positiv erklärt, werden Differenzen `a-b' oder das
     Vorzeichen der Logarithmusfunktion `log(a)' nicht als positiv
     ermittelt.  Die Fragen der Funktion `asksign' an den Nutzer können
     daher nie vollständig mit dem Mechanismus der Optionsvariablen
     `assume_pos' unterdrückt werden.

     Siehe für weitere Beispiele die Optionsvariable `assume_pos_pred'.

     Beispiele:

     Das Vorzeichen der Variablen `x' ist nicht bekannt.  Erhält die
     Optionsvariable `assume_pos' den Wert `true', wird für die Variable
     `x' und die indizierte Variable `x[1]' ein positives Vorzeichen
     ermittelt.

          (%i1) sign(x);
          (%o1)                          pnz
          (%i2) assume_pos:true;
          (%o2)                         true
          (%i3) sign(x);
          (%o3)                          pos
          (%i4) sign(x[1]);
          (%o4)                          pos

     Die Vorzeichen der Variablen `a' und `b' sind nicht bekannt.
     Maxima ermittelt ein positives Vorzeichen für die Summe der
     Variablen.  Das Vorzeichen der Differenz ist dagegen weiterhin
     nicht bekannt.

          (%i5) sign(a+b);
          (%o5)                          pos
          (%i6) sign(a-b);
          (%o6)                          pnz

 -- Optionsvariable: assume_pos_pred
     Standardwert: `false'

     Der Optionsvariablen `assume_pos_pred' kann eine Aussagefunktion
     wie zum Beispiel `symbolp'  oder ein Lambda-Ausdruck mit einem
     Argument `x' zugewiesen werden.  Hat die Optionsvariable
     `assume_pos'  den Wert `true', werden Variablen, indizierte
     Variablen oder die Werte von Funktionen dann als positiv
     angenommen, wenn die Aussagefunktion das Ergebnis `true' hat.

     Die Aussagefunktion wird intern von den Funktionen `sign'  und
     `asksign'  aufgerufen, wenn die Optionsvariable `assume_pos' den
     Wert `true' hat und das Vorzeichen einer Variablen, indizierten
     Variablen oder für den Wert einer Funktion nicht ermittelt werden
     konnte.  Gibt die Aussagefunktion das Ergebnis `true' zurück, wird
     das Argument als positiv angenommen.

     Hat die Optionsvariable `assume_pos_pred' den Standardwert `false'
     werden Variablen und indizierte Variablen von Maxima als positiv
     angenommen, wenn die Optionsvariable `assume_pos' den Wert `true'
     hat.  Das entspricht einer Aussagefunktion, die als `lambda([x],
     symbolp(x) or subvarp(x))' definiert wird.

     Siehe auch `assume'  und `assume_pos'.

     Beispiele:

     Der Optionsvariablen `assume_pos_pred' wird der Name der
     Aussagefunktion `symbolp' zugewiesen.  Indizierte Variablen werden
     nun nicht mehr als positiv angenommen, wie es für den Standartwert
     `false' gilt.

          (%i1) assume_pos: true$
          (%i2) assume_pos_pred: symbolp$
          (%i3) sign (a);
          (%o3)                          pos
          (%i4) sign (a[1]);
          (%o4)                          pnz

     Der Optionsvariablen `assume_pos_pred' wird ein Lambda-Ausdruck
     zugewiesen, der für alle Argumente das Ergebnis `true' hat.  Die
     Funktion `sign' ermittelt nun für Variablen, indizierte Variablen
     und den Werten von Funktionen ein positives Vorzeichen.  Dies
     trifft jedoch nicht für die Logarithmusfunktion oder eine
     Differenz zu.

          (%i1) assume_pos: true$
          (%i2) assume_pos_pred: lambda([x], true);
          (%o2)                   lambda([x], true)
          (%i3) sign(a);
          (%o3)                          pos
          (%i4) sign(a[1]);
          (%o4)                          pos
          (%i5) sign(foo(x));
          (%o5)                          pos
          (%i6) sign(foo(x)+foo(y));
          (%o6)                          pos
          (%i7) sign(log(x));
          (%o7)                          pnz
          (%i8) sign(x-y);
          (%o8)                          pnz

 -- Optionsvariable: context
     Standardwert: `initial'

     Die Optionsvariable `context' enthält den Namen des aktuellen
     Kontextes.  Das ist der Kontext, der die Aussagen der Funktion
     `assume'  oder die mit der Funktion `declare'  definierten
     Eigenschaften aufnimmt und aus dem die Aussagen mit der Funktion
     `forget'  oder die Eigenschaften mit der Funktion `remove'
     gelöscht werden.

     Wird der Optionsvariablen `context' der Name eines existierenden
     Kontextes zugewiesen, wird dieser zum aktuellen Kontext.
     Existiert der Kontext noch nicht, wird er durch Aufruf der
     Funktion `newcontext'  erzeugt.

     Siehe auch `contexts'  für eine allgemeinere Beschreibung von
     Kontexten.

     Beispiele:

     Der Standardkontext ist `initial'.  Es wird ein neuer Kontext
     `mycontext' generiert, der die Aussagen und Eigenschaften aufnimmt.

          (%i1) context;
          (%o1)                        initial
          (%i2) context:mycontext;
          (%o2)                       mycontext
          (%i3) contexts;
          (%o3)             [mycontext, initial, global]
          (%i4) assume(a>0);
          (%o4)                        [a > 0]
          (%i5) declare(b,integer);
          (%o5)                         done
          (%i6) facts(mycontext);
          (%o6)               [a > 0, kind(b, integer)]

 -- Systemvariable: contexts
     Standardwert: `[initial, global]'

     Die Systemvariable `contexts' enthält eine Liste der Kontexte, die
     Maxima bekannt sind.  Die Liste enthält auch die nicht aktiven
     Kontexte.

     Die Kontexte `global' und `initial' sind immer vorhanden.  Diese
     werden von Maxima initialisiert und können nicht entfernt werden.
     Der Kontext `global' enthält Aussagen und Fakten für
     Systemvariablen und Systemfunktionen.  Mit den Funktionen
     `newcontext'  oder `supcontext'  kann der Nutzer weitere Kontexte
     anlegen.

     Die Kontexte haben eine Hierarchie.  Die Wurzel ist immer der
     Kontext `global', der damit ein Unterkontext aller anderen
     Kontexte und immer aktiv ist.  Der Kontext `initial' ist anfangs
     leer und nimmt, sofern kein weiterer Kontext angelegt wurde, die
     Aussagen und Fakten des Nutzers auf, die mit den Funktionen
     `assume'  und `declare'  definiert werden.  Mit der Funktion
     `facts'  können die Aussagen und Fakten von Kontexten angezeigt
     werden.

     Die Verwaltung verschiedener Kontexte ermöglicht es, Aussagen und
     Fakten in einem Kontext zusammenzustellen.  Durch das Aktivieren
     mit der Funktion `activate'  oder Deaktivieren mit der Funktion
     `deactivate'  können diese Aussagen und Fakten für Maxima
     verfügbar gemacht oder wieder ausgeschaltet werden.

     Die Aussagen und Fakten in einem Kontext bleiben so lange
     verfügbar, bis sie mit den Funktionen `forget'  oder `remove'
     gelöscht werden.  Weiterhin kann der gesamte Kontext mit der
     Funktion `killcontext'  entfernt werden.

     Beispiel:

     Das folgende Beispiel zeigt wie ein Kontext `mycontext' angelegt
     wird.  Der Kontext enthält die Aussage `[a>0]'.  Der Kontext kann
     mit der Funktion `activate' aktiviert werden, um die Aussage
     verfügbar zu machen.

          (%i1) newcontext(mycontext);
          (%o1)                       mycontext
          (%i2) context;
          (%o2)                       mycontext
          (%i3) assume(a>0);
          (%o3)                        [a > 0]
          (%i4) context:initial;
          (%o4)                        initial
          (%i5) is(a>0);
          (%o5)                        unknown
          (%i6) activate(mycontext);
          (%o6)                         done
          (%i7) is(a>0);
          (%o7)                         true

 -- Funktion: deactivate (<context_1>, ..., <context_n>)
     Die Kontexte <context_1>, ..., <context_n> werden deaktiviert.  Die
     Aussagen und Fakten dieser Kontexte stehen für die Auswertung von
     Aussagen nicht mehr zur Verfügung.  Die Kontexte werden nicht
     gelöscht und können mit der Funktion `activate'  wieder aktiviert
     werden.

     Die deaktivierten Kontexte werden aus der Liste `activecontexts'
     entfernt.

 -- Funktion: facts (<item>)
 -- Funktion: facts ()
     Ist <item> der Name eines Kontextes, gibt `facts(<item>)' eine
     Liste der Aussagen und Fakten des Kontextes `item' zurück.

     Ist <item> nicht der Name eines Kontextes, gibt `facts(<item>)'
     eine Liste mit den Aussagen und Fakten zurück, die zu <item> im
     aktuellen Kontext bekannt sind.  Aussagen und Fakten die zu einem
     anderen aktiven Kontext gehören einschließlich der Unterkontexte,
     sind nicht in der Liste enthalten.

     `facts()' gibt eine Liste der Fakten des aktuellen Kontextes
     zurück.

     Beispiel:

          (%i1) context:mycontext;
          (%o1)                       mycontext
          (%i2) assume(a>0, a+b>0, x<0);
          (%o2)               [a > 0, b + a > 0, x < 0]
          (%i3) facts();
          (%o3)               [a > 0, b + a > 0, 0 > x]
          (%i4) facts(a);
          (%o4)                  [a > 0, b + a > 0]
          (%i5) facts(x);
          (%o5)                        [0 > x]
          (%i6) context:initial;
          (%o6)                        initial
          (%i7) activate(mycontext);
          (%o7)                         done
          (%i8) facts();
          (%o8)                          []
          (%i9) facts(mycontext);
          (%o9)               [a > 0, b + a > 0, 0 > x]

 -- Funktion: forget (<pred_1>, ..., <pred_n>)
 -- Funktion: forget (<L>)
     Entfernt Aussagen, die mit `assume' einem Kontext hinzugefügt
     wurden.  Die Aussagen können Ausdrücke sein, die äquivalent aber
     nicht unbedingt identisch zu vorherigen Fakten sind.

     `forget(<L>)' entfernt alle Aussagen, die in der Liste <L>
     enthalten sind.

 -- Funktion: is (<expr>)
     Versucht festzustellen, ob die Aussage <expr> mit Hilfe der
     Aussagen und Fakten der aktiven Kontexte entschieden werden kann.

     Kann die Aussage <expr> zu `true' oder `false' entschieden werden,
     wird das entsprechende Ergebnis zurückgegeben.  Andernfalls wird
     der Rückgabewert durch den Schalter `prederror'  bestimmt.  Hat
     `prederror' den Wert `true', wird eine Fehlermeldung ausgegeben.
     Ansonsten wird `unknown' zurückgegeben.

     Siehe auch `assume',  `facts'  und `maybe'.

     Beispiele:

     `is' wertet Aussagen aus.

          (%i1) %pi > %e;
          (%o1)                       %pi > %e
          (%i2) is (%pi > %e);
          (%o2)                         true

     `is' versucht Aussagen anhand der Aussagen und Fakten der aktiven
     Kontexte zu entscheiden.

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) assume (b > c);
          (%o2)                        [b > c]
          (%i3) is (a < b);
          (%o3)                         false
          (%i4) is (a > c);
          (%o4)                         true
          (%i5) is (equal (a, c));
          (%o5)                         false

     Wenn `is' eine Aussage anhand der Aussagen und Fakten der aktiven
     Kontexte nicht entscheiden kann, wird der Rückgabewert vom Wert
     des Schalters `prederror' bestimmt.

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) prederror: true$
          (%i3) is (a > 0);
          Maxima was unable to evaluate the predicate:
          a > 0
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) prederror: false$
          (%i5) is (a > 0);
          (%o5)                        unknown

 -- Funktion: killcontext (<context_1>, ..., <context_n>)
     Das Kommando `killcontext(<context>)' löscht den Kontext <context>.

     Ist einer der Kontexte der aktuelle Kontext, wird der erste
     vorhandene Unterkontext zum aktuellen Kontext.  Ist der erste
     verfügbare Kontext der Kontext `global', dann wird der Kontext
     `initial' zum aktuellen Kontext.  Wird der Kontext `initial'
     gelöscht, dann wird eine neuer leerer Kontext `initial' erzeugt.

     `killcontext' löscht einen Kontext nicht, wenn dieser ein
     Unterkontext des aktuellen Kontextes ist oder wenn der Kontext mit
     der Funktion `activate' aktiviert wurde.

     `killcontext' wertet die Argumente aus.  `killcontext' gibt `done'
     zurück.

 -- Funktion: maybe (<expr>)
     Versucht festzustellen, ob die Aussage <expr> anhand der Aussagen
     und Fakten der aktive Kontexte entschieden werden kann.

     Kann die Aussage als `true' oder `false' entschieden werden, gibt
     `maybe' entsprechend `true' oder `false' zurück.  Andernfalls gibt
     `maybe' den Wert `unknown' zurück.

     `maybe' entspricht der Funktion `is' mit `prederror: false'.
     Dabei wird `maybe' ausgeführt, ohne dass `prederror' einen Wert
     erhält.

     Siehe auch `assume',  `facts'  und `is'.

     Beispiele:

          (%i1) maybe (x > 0);
          (%o1)                        unknown
          (%i2) assume (x > 1);
          (%o2)                        [x > 1]
          (%i3) maybe (x > 0);
          (%o3)                         true

 -- Funktion: newcontext (<name>)
     `newcontext(<name>)' erzeugt einen neuen, leeren Kontext mit dem
     Namen <name>. Der neue Kontext hat den Kontext `global' als
     Subkontext und wird zum aktuellen Kontext.

     `newcontext' wertet seine Argumente aus.  `newcontext' gibt `name'
     zurück.

 -- Optionsvariable: prederror
     Standardwert: `false'

     Hat `prederror' den Wert `true', wird eine Fehlermeldung
     ausgegeben, wenn eine Aussage mit einer `if'-Anweisung oder der
     Funktion `is' nicht zu `true' oder `false' ausgewertet werden kann.

     Hat `prederror' den Wert `false', wird für diese Fälle `unknown'
     zurückgegeben.

     Siehe auch `is'  und `maybe'.


 -- Funktion: sign (<expr>)
     Versucht das Vorzeichen des Ausdrucks <expr> auf Grundlage der
     Fakten der aktuellen Datenbank zu finden.  `sign' gibt eine der
     folgende Antworten zurück: `pos' (positiv), `neg' (negative),
     `zero' (null), `pz' (positive oder null), `nz' (negative oder
     null), `pn' (positiv oder negative) oder `pnz' (positiv, negative
     oder null, für den Fall das Vorzeichen nicht bekannt ist).

 -- Funktion: supcontext (<name>, <context>)
 -- FunKtion: supcontext (<name>)
     Erzeugt einen neuen Kontext, mit dem Namen `name', der den Kontext
     `context' als einen Unterkontext enthält.  Der Kontext <context>
     muss existieren.

     Wird <context> nicht angegeben, wird der aktuelle Kontext
     angenommen.


File: maxima.info,  Node: Funktionen und Variablen für Aussagen,  Prev: Funktionen und Variablen für Fakten,  Up: Maximas Datenbank

11.4 Funktionen und Variablen für Aussagen
==========================================

 -- Funktion: charfun (<p>)
     Gibt den Wert 0 zurück, wenn die Aussage <p> zu `false' ausgewertet
     werden kann und den Wert 1, wenn die Auswertung `true' liefert.
     Kann die Aussage weder zu `false' oder `true' ausgewertet werden,
     wird eine Substantiv-Form zurück gegeben.

     Beispiele:

          (%i1) charfun (x < 1);
          (%o1)                    charfun(x < 1)
          (%i2) subst (x = -1, %);
          (%o2)                           1
          (%i3) e : charfun ('"and" (-1 < x, x < 1))$
          (%i4) [subst (x = -1, e), subst (x = 0, e), subst (x = 1, e)];
          (%o4)                       [0, 1, 0]

 -- Funktion: compare (<x>, <y>)
     Liefert den Vergleichsoperator <op> (`<', `<=', `>', `>=', `='
     oder `#'), so dass der Ausdruck `is(<x> <op> <y>)' zu `true'
     ausgewertet werden kann.  Ist eines der Argumente eine komplexe
     Zahl, dann wird `notcomparable' zurückgegeben.  Kann Maxima keinen
     Vergleichsoperator bestimmen, wird `unknown' zurückgegeben.

     Beispiele:

          (%i1) compare (1, 2);
          (%o1)                           <
          (%i2) compare (1, x);
          (%o2)                        unknown
          (%i3) compare (%i, %i);
          (%o3)                           =
          (%i4) compare (%i, %i + 1);
          (%o4)                     notcomparable
          (%i5) compare (1/x, 0);
          (%o5)                           #
          (%i6) compare (x, abs(x));
          (%o6)                          <=

     Die Funktion `compare' versucht nicht festzustellen, ob der
     Wertebereich einer Funktion reelle Zahlen enthält.  Obwohl der
     Wertebereich von `acos(x^2+1)' bis auf Null keine reellen Zahlen
     enthält, gibt `compare' das folgende Ergebnis zurück:

          (%i1) compare (acos (x^2 + 1), acos (x^2 + 1) + 1);
          (%o1)                           <

 -- Funktion: equal (<a>, <b>)
     Repräsentiert die Äquivalenz, das heißt den gleichen Wert.

     `equal' wird nicht ausgewertet oder vereinfacht.  Die Funktion `is'
     versucht einen Ausdruck mit `equal' zu einem booleschen Wert
     auszuwerten.  `is(equal(<a>, <b>))' gibt `true' oder `false'
     zurück, wenn und nur wenn <a> und <b> gleich oder ungleich sind
     für alle Werte ihrer Variablen, was mit `ratsimp(<a> - <b>)'
     bestimmt wird.  Gibt `ratsimp'  das Ergebnis 0 zurück, werden die
     beiden Ausdrücke als äquivalent betracht.  Zwei Ausdrücke können
     äquivalent sein, obwohl sie nicht syntaktisch gleich (im
     allgemeinen identisch) sind.

     Kann `is' einen Ausdruck mit `equal' nicht zu `true' oder `false'
     auswerten, hängt das Ergebnis vom Wert des globalen Flags
     `prederror'  ab.  Hat `prederror' den Wert `true', gibt `is' eine
     Fehlermeldung zurück.  Ansonsten wird `unknown' zurückgegeben.

     Es gibt weitere Operatoren, die einen Ausdruck mit `equal' zu
     `true' oder `false' auswerten können.  Dazu gehören `if',

     `and',  `or'  und `not'.

     Die Umkehrung von `equal' ist `notequal'.

     Beispiele:

     `equal' wird von allein weder ausgewertet noch vereinfacht:

          (%i1) equal (x^2 - 1, (x + 1) * (x - 1));
                                  2
          (%o1)            equal(x  - 1, (x - 1) (x + 1))
          (%i2) equal (x, x + 1);
          (%o2)                    equal(x, x + 1)
          (%i3) equal (x, y);
          (%o3)                      equal(x, y)

     Die Funktion `is' versucht, `equal' zu einem booleschen Wert
     auszuwerten.  Der Ausdruck `is(equal(<a>, <b>))' gibt den Wert
     `true' zurück, when `ratsimp(<a> - <b>)' den Wert 0 hat.  Zwei
     Ausdrücke können äquivalent sein, obwohl sie nicht syntaktisch
     gleich sind.

          (%i1) ratsimp (x^2 - 1 - (x + 1) * (x - 1));
          (%o1)                           0
          (%i2) is (equal (x^2 - 1, (x + 1) * (x - 1)));
          (%o2)                         true
          (%i3) is (x^2 - 1 = (x + 1) * (x - 1));
          (%o3)                         false
          (%i4) ratsimp (x - (x + 1));
          (%o4)                          - 1
          (%i5) is (equal (x, x + 1));
          (%o5)                         false
          (%i6) is (x = x + 1);
          (%o6)                         false
          (%i7) ratsimp (x - y);
          (%o7)                         x - y
          (%i8) is (equal (x, y));
          (%o8)                        unknown
          (%i9) is (x = y);
          (%o9)                         false

     Kann `is' einen Ausdruck mit `equal' nicht zu `true' oder `false'
     vereinfachen, hängt das Ergebnis vom Wert des globalen Flags
     `prederror' ab.

          (%i1) [aa : x^2 + 2*x + 1, bb : x^2 - 2*x - 1];
                              2             2
          (%o1)             [x  + 2 x + 1, x  - 2 x - 1]
          (%i2) ratsimp (aa - bb);
          (%o2)                        4 x + 2
          (%i3) prederror : true;
          (%o3)                         true
          (%i4) is (equal (aa, bb));
          Maxima was unable to evaluate the predicate:
                 2             2
          equal(x  + 2 x + 1, x  - 2 x - 1)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) prederror : false;
          (%o5)                         false
          (%i6) is (equal (aa, bb));
          (%o6)                        unknown

     Einige weitere Operatoren werten `equal' und `notequal' zu einem
     booleschen Wert aus.

          (%i1) if equal (y, y - 1) then FOO else BAR;
          (%o1)                          BAR
          (%i2) eq_1 : equal (x, x + 1);
          (%o2)                    equal(x, x + 1)
          (%i3) eq_2 : equal (y^2 + 2*y + 1, (y + 1)^2);
                                   2                   2
          (%o3)             equal(y  + 2 y + 1, (y + 1) )
          (%i4) [eq_1 and eq_2, eq_1 or eq_2, not eq_1];
          (%o4)                  [false, true, true]

     Da `not <expr>' den Ausdruck <expr> auswertet, ist `not equal(<a>,
     <b>)' äquivalent zu `is(notequal(<a>, <b>))'

          (%i1) [notequal (2*z, 2*z - 1), not equal (2*z, 2*z - 1)];
          (%o1)            [notequal(2 z, 2 z - 1), true]
          (%i2) is (notequal (2*z, 2*z - 1));
          (%o2)                         true

 -- Funktion: notequal (<a>, <b>)
     Repräsentiert die Verneinung von `equal(<a>, <b>)'.

     Beispiele:

          (%i1) equal (a, b);
          (%o1)                      equal(a, b)
          (%i2) maybe (equal (a, b));
          (%o2)                        unknown
          (%i3) notequal (a, b);
          (%o3)                    notequal(a, b)
          (%i4) not equal (a, b);
          (%o4)                    notequal(a, b)
          (%i5) maybe (notequal (a, b));
          (%o5)                        unknown
          (%i6) assume (a > b);
          (%o6)                        [a > b]
          (%i7) equal (a, b);
          (%o7)                      equal(a, b)
          (%i8) maybe (equal (a, b));
          (%o8)                         false
          (%i9) notequal (a, b);
          (%o9)                    notequal(a, b)
          (%i10) maybe (notequal (a, b));
          (%o10)                        true

 -- Funktion: unknown (<expr>)
     Gibt den Wert `true' zurück, wenn der Ausdruck <expr> einen
     Operator oder eine Funktion enthält, die nicht von Maximas
     Vereinfacher erkannt wird.

 -- Funktion: zeroequiv (<expr>, <v>)
     Testet, ob ein Ausdruck <expr> mit der Variablen <v> äquivalent zu
     Null ist.  Die Funktion gibt `true', `false' oder `dontknow'
     zurück.

     `zeroequiv' hat Einschränkungen:

       1. Funktionen im Ausdruck <expr> müssen von Maxima
          differenzierbar und auswertbar sein.

       2. Hat der Ausdruck Pole auf der reellen Achse, können Fehler
          auftreten.

       3. Enthält der Ausdruck Funktionen, die nicht Lösung einer
          Differentialgleichung erster Ordnung sind (zum Beispiel
          Bessel Funktionen), können die Ergebnisse fehlerhaft sein.

       4. Der Algorithmus wertet die Funktion an zufällig Punkten für
          ausgewählte Teilausdrücke aus.  Dies ist ein riskantes
          Verfahren und kann zu Fehlern führen.

     `zeroequiv(sin(2*x) - 2*sin(x)*cos(x), x)' hat zum Beispiel das
     Ergebnis `true' und  `zeroequiv (%e^x + x, x)' hat das Ergebnis
     `false'.  Andererseits hat `zeroequiv (log(a*b) - log(a) - log(b),
     a)' das Ergebnis `dontknow', wegen dem zusätzlichem Parameter `b'.


File: maxima.info,  Node: Grafische Darstellung,  Next: Eingabe und Ausgabe,  Prev: Maximas Datenbank,  Up: Top

12 Grafische Darstellung
************************

* Menu:

* Einführung in die grafische Darstellung::
* Grafikformate::
* Funktionen und Variablen für die grafische Darstellung::
* Grafikoptionen::
* Gnuplot Optionen::
* Gnuplot_pipes Formatfunktionen::


File: maxima.info,  Node: Einführung in die grafische Darstellung,  Next: Grafikformate,  Prev: Grafische Darstellung,  Up: Grafische Darstellung

12.1 Einführung in die grafische Darstellung
============================================

Maxima verwendet externe Grafikprogramme, um grafische Darstellungen
auszugeben.  Die Grafikfunktionen berechnen die Punkte der Grafik und
senden diese mit einem Satz an Kommandos an das externe Grafikprogramm.
Die Daten werden als Datenstrom über eine Pipe oder als eine Datei an
das Grafikprogramm übergeben.  Die Datei erhält den Namen
`maxout.interface', wobei `interface' der Name des externen
Grafikprogramms ist.  Die möglichen Dateiendungen sind: `gnuplot',
`xmaxima', `mgnuplot' oder `gnuplot_pipes'.

Die Datei `maxout.interface' wird in dem Verzeichnis gespeichert, das
durch die Systemvariable `maxima_tempdir'  bezeichnet wird.

Die Datei `maxout.interface' kann wiederholt an das Grafikprogramm
übergeben werden.  Gibt Maxima keine Grafik aus, kann diese Datei
geprüft werden, um mögliche Fehler festzustellen.

Das Paket `draw' ist eine Alternative, um Funktionsgraphen und eine
Vielzahl anderer Graphen zu erstellen.  Das Paket `draw' hat einen
größeren Umfang an Funktionalitäten und ist flexibler, wenn der Graph
besondere Formatierungen enthalten soll.  Einige Grafikoptionen sind in
beiden beiden Grafikpaketen vorhanden, können sich aber in der Syntax
unterscheiden.  Mit dem Kommando `? opt', wobei `opt' eine Grafikoption
ist, wird möglicherweise nur die Dokumentation der
Standard-Grafikroutinen angezeigt.  Um auch die entsprechende
Grafikoption des Paketes `draw' zu sehen, kann `?? opt' auf der
Kommandozeile eingegeben werden.  Siehe *note draw::.


File: maxima.info,  Node: Grafikformate,  Next: Funktionen und Variablen für die grafische Darstellung,  Prev: Einführung in die grafische Darstellung,  Up: Grafische Darstellung

12.2 Grafikformate
==================

Maxima verwendet für die Ausgabe von Grafiken die Grafikprogramme
Gnuplot oder Xmaxima.  Mit der Grafikoption `plot_format' können
verschiedene Grafikformate für diese Programme ausgewählt werden.  Die
Grafikformate sind:

   * *gnuplot* (Standard für Windows)

     Startet das externe Programm Gnuplot.  Gnuplot muss installiert
     sein.  Die Grafikkommandos und Daten werden in die Datei
     `maxout.gnuplot' gespeichert.

   * *gnuplot_pipes* (Standard, wenn nicht Windows)

     Dieses Format ist für Windows nicht verfügbar.  Es ist ähnlich dem
     Format `gnuplot', mit der Ausnahme, dass die Grafikkommandos als
     Datenstrom über eine Pipe an Gnuplot gesendet werden, während die
     Daten in der Datei `maxout.gnuplot_pipes' gespeichert werden.  Es
     wird nur eine Instanz von Gnuplot gestartet.  Aufeinander folgende
     Grafikkommandos werden an ein bereits geöffnetes Gnuplot-Programm
     gesendet.  Gnuplot wird mit der Funktion `gnuplot_close'
     geschlossen.  In diesem Grafikformat kann die Funktion
     `gnuplot_replot'  genutzt werden, um eine Grafik zu modifizieren,
     die bereits auf dem Bildschirm ausgegeben wurde.

     Dieses Grafikformat sollte nur für die Ausgabe von Grafiken auf
     den Bildschirm verwendet werden.  Für die Ausgabe von Grafiken in
     eine Datei ist das Grafikformat `gnuplot' besser geeignet.

   * *mgnuplot*

     Mgnuplot ist eine Tcl/Tk-Anwendung, die Gnuplot für die Ausgabe
     von Grafiken nutzt.  Die Anwendung ist in der Maxima-Distribution
     enthalten.  Mgnuplot bietet eine rudimentäre GUI für Gnuplot, hat
     aber weniger Fähigkeiten als Gnuplot.  Mgnuplot benötigt die
     Installation von Gnuplot und Tcl/Tk.

   * *xmaxima*

     Xmaxima ist eine auf Tcl/Tk basierende grafische Nutzeroberfläche,
     die von der Maxima-Konsole gestartet werden kann.  Um dieses
     Grafikformat zu nutzen, muss Xmaxima installiert sein, das in der
     Distribution von Maxima enthalten ist.  Wird Maxima aus Xmaxima
     gestartet, werden die Grafikkommandos und Daten über denselben
     Socket gesendet, der auch für die Kommunikation zwischen Xmaxima
     und Maxima geöffnet wird.  Wird das Grafikformat von einer Konsole
     oder einer anderen Nutzeroberfläche gestartet, werden die
     Grafikkommandos und Daten in die Datei `maxout.xmaxima'
     gespeichert.  Diese Datei wird an Xmaxima für die Ausgabe der
     Grafik übergeben.

     In früheren Versionen wurde dieses Grafikformat `openmath' genannt.
     Dieser Name wird weiterhin als ein Synonym für `xmaxima'
     akzeptiert.


File: maxima.info,  Node: Funktionen und Variablen für die grafische Darstellung,  Next: Grafikoptionen,  Prev: Grafikformate,  Up: Grafische Darstellung

12.3 Funktionen und Variablen für die grafische Darstellung
===========================================================

 -- Funktion: contour_plot (<expr>, <x_range>, <y_range>, <options>,
          ...)
     Zeichnet einen Konturgraphen (die Isolinien einer Funktion) von
     <expr> im Bereich <x_range> und <y_range> mit den Optionen
     <options>.  <expr> ist ein Ausdruck oder der Name einer Funktion
     `f(x,y)' mit zwei Argumenten.  Alle weiteren Argumente entsprechen
     denen der Funktion `plot3d'.

     Die Funktion steht nur für die Grafikformate `gnuplot' und
     `gnuplot_pipes' zur Verfügung.  Das Paket `implicit_plot' enthält
     die Funktion `implicit_plot'  mit der für alle Grafikformate
     Konturgraphen erstellt werden können.

     Beispiele:

          (%i1) contour_plot(x^2 + y^2, [x, -4, 4], [y, -4, 4])$

          (%i1) f(x, y) := x^3 + y^2;
                                             3    2
          (%o1)                  f(x, y) := x  + y
          (%i2) contour_plot(f, [u, -4, 4], [v, -4, 4])$

     Es kann jede Option genutzt werden, die von der Funktion `plot3d'
     akzeptiert wird.  Standardmäßig zeichnet Gnuplot den Graphen mit 3
     Isolinien.  Die Anzahl der Isolinien kann mit der Gnuplot-Option
     `gnuplot_preamble'  erhöht werden.  In diesem Beispiel werden 12
     Isolinien gezeichnet und die Legende ist entfernt.

          (%i1) contour_plot (u^3 + v^2, [u, -4, 4], [v, -4, 4],
            [legend,false], [gnuplot_preamble, "set cntrparam levels 12"])$

 -- Funktion: get_plot_option (<keyword>, <index>)
     Gibt die Werte der Parameter der Option mit dem Namen <keyword>
     zurück.  Die Optionen und ihre Parameter sind in der Variablen
     `plot_options' gespeichert.  Hat <index> den Wert 1 wird der Name
     der Option <keyword> zurückgeben.  Der Wert 2 für <index> gibt den
     Wert des ersten Parameters zurück, und so weiter.

     Siehe auch `plot_options',  `set_plot_option'  und das Kapitel
     Grafikoptionen.

     Beispiel:

          (%i1) get_plot_option(color,1);
          (%o1)                         color
          (%i2) get_plot_option(color,2);
          (%o2)                         blue
          (%i3) get_plot_option(color,3);
          (%o3)                          red

 -- Funktion: implicit_plot (<expr>, <x_range>, <y_range>)
 -- Funktion: implicit_plot ([<expr_1>, ..., <expr_n>], <x_range>,
          <y_range>)
     Zeichnet den Graphen eines oder mehrerer Ausdrücke, die implizit
     gegeben sind.  <expr> ist der Ausdruck der gezeichnet werden soll,
     <x_range> ist der Wertebereich der x-Achse und <y_range> der
     Wertebereich der y-Achse.  Die Funktion `implicit_plot' beachtet
     die Werte der Parameter der Grafikoptionen, die in der
     Systemvariablen `plot_options' enthalten sind.  Grafikoptionen
     können auch als Argumente übergeben werden.

     Der Algorithmus von `implicit_plot' stellt Vorzeichenwechsel der
     Funktion in den Bereichen <x_range> und <y_range> fest.  Für
     komplizierte Flächen kann der Algorithmus versagen.

     Die Funktion wird mit dem Kommando `load(implicit_plot)' geladen.

     Beispiel:

          (%i1) implicit_plot (x^2 = y^3 - 3*y + 1, [x, -4, 4], [y, -4, 4],
           [gnuplot_preamble, "set zeroaxis"]);

 -- Funktion: make_transform ([<var1>, <var2>, <var3>], <fx>, <fy>,
          <fz>)
     Gibt eine Funktion zurück, die als Parameter für die Grafikoption
     `transform_xy' geeignet ist.  Die zwei Argumente <var1> und <var2>
     repräsentieren die zwei unabhängigen Variablen der Funktion
     `plot3d'.  Das dritte Argument <var3> ist die Funktion, die von
     den zwei Variablen abhängt.  Die drei Funktionen <fx>, <fy> und
     <fz> müssen von den drei Argumenten <var1>, <var2> und <var3>
     abhängen und die Argumente der Funktion `plot3d' in kartesische
     Koordinaten für die Ausgabe des Graphen transformieren.

     Die Transformationen `polar_to_xy'  für die Transformation von
     Polarkoordinaten und `spherical_to_xyz'  für die Transformation von
     Kugelkoordinaten in kartesische Koordinaten sind bereits definiert.

     Beispiel:

     Definition der Transformation von Zylinderkoordinaten nach
     kartesischen Koordinaten.  Die Definition ist identisch mit der
     für `polar_to_xy'.

     Der Graph zeigt einen Kegel.

          (%i1) cylinder_to_xy:make_transform([r,phi,z],r*cos(phi),
                                                        r*sin(phi),z)$
          (%i2) plot3d(-r,[r,0,3],[phi,0,2*%pi],
                                  [transform_xy, cylinder_to_xy])$

 -- Systemfunktion: polar_to_xy
     Kann als Parameter der Grafikoption `transform_xy' der Funktion
     `plot3d' übergeben werden.  Der Parameter `polar_to_xy' bewirkt,
     dass die zwei unabhängigen Variablen der Funktion `plot3d' von
     Polarkoordinaten in kartesische Koordinaten transformiert werden.

     Für ein Beispiele siehe `make_transform'.


 -- Funktion: plot2d (<plot>, <x_range>, ..., <options>, ...)
 -- Funktion: plot2d ([<plot_1>, ..., <plot_n>], ..., <options>, ...)
 -- Funktion: plot2d ([<plot_1>, ..., <plot_n>], <x_range>, ...,
          <options>, ...)
     <plot>, <plot_1>, ..., <plot_n> sind Ausdrücke, Namen von
     Funktionen oder Listen, mit denen diskrete Punkte oder Funktionen
     in einer parametrischen Darstellung angegeben werden.  Diskrete
     Punkte können als `[discrete, [<x1>, ..., <xn>], [<y1>, ...,
     <yn>]]' oder als `[discrete, [[<x1>, <y1>], ..., [<xn>, ...,
     <yn>]]' angegeben werden.  Eine parametrische Darstellung hat die
     Form `[parametric, <x_expr>, <y_expr>, <t_range>]'.

     Die Funktion `plot2d' zeichnet einen zweidimensionalen Graphen
     einer oder mehrerer Ausdrücke als Funktion einer Variablen oder
     eines Parameters.  Mit der Grafikoption <x_range> wird der Name
     der unabhängigen Variablen und deren Bereich angegeben.  Die
     Syntax der Grafikoption <x_range> ist: `[<variable>, <min>,
     <max>]'.

     Ein diskreter Graph wird durch eine Liste definiert, die mit dem
     Schlüsselwort <disrecte> beginnt.  Es folgen ein oder zwei Listen
     mit den Werten.  Werden zwei Listen übergeben, müssen diese
     dieselbe Länge haben.  Die Daten der ersten Listen werden als die
     x-Koordinaten der Punkte und die der zweiten als die y-Koordinaten
     der Punkte interpretiert.  Wird nur eine Liste übergeben, sind die
     Elemente Listen mit je zwei Elementen, die die x- und
     y-Koordinaten der Punkte repräsentieren.

     Ein parametrischer Graph wird durch eine Liste definiert, die mit
     dem Schlüsselwort <parametric> beginnt.  Es folgen zwei Ausdrücke
     oder Namen von Funktionen und ein Parameter.  Der Bereich für den
     Parameter muss eine Liste sein, die den Namen des Parameters,
     seinen größten und seinen kleinsten Wert enthält: `[<parameter>,
     <min>, <max>]'.  Der Graph ist der Weg für die zwei Ausdrücke oder
     Namen von Funktionen, wenn der Parameter <parameter> von <min>
     nach <max> zunimmt.

     Als optionales Argument kann ein Wertebereich für die vertikale
     Koordinatenachse mit der Grafikoption `y' angegeben werden: `[y,
     <min>, <max>]'.  Die vertikale Achse wird immer mit dem
     Schlüsselwort `y' bezeichnet.  Wird kein Wertebereich `y'
     angegeben, wird dieser durch den größten und kleinsten `y'-Wert
     des zu zeichnenden Graphen festgelegt.

     Auch alle anderen Grafikoptionen werden als Listen angegeben, die
     mit einem Schlüsselwort beginnen, auf das die Parameter der
     Grafikoption folgen.  Siehe `plot_options'.

     Werden mehrere Graphen gezeichnet, wird eine Legende hinzugefügt,
     die die einzelnen Graphen unterscheidet.  Mit der Grafikoption
     <legend> können die Bezeichnungen für die Legende festgelegt
     werden.  Wird diese Option nicht genutzt, generiert Maxima die
     Bezeichnungen der Legende aus den Ausdrücken oder Namen der
     Funktionen, die als Argument übergeben wurden.

     Siehe auch das Kapitel `Grafikoptionen'.

     Beispiele:

     Graph einer einfachen Funktion.

          (%i1) plot2d (sin(x), [x, -%pi, %pi])$

     Wächst die Funktion sehr schnell, kann es notwendig sein, die
     Werte auf der vertikalen Achse mit der Grafikoption `y' zu
     begrenzen.

          (%i1) plot2d (sec(x), [x, -2, 2], [y, -20, 20])$
          plot2d: some values were clipped.

     Die Ansicht eines Graphen kann sich für verschiedene
     Grafikprogramme unterscheiden.  In Xmaxima bewirkt die
     Grafikoption `[box, false]', das die Koordinatenachsen mit Pfeilen
     dargestellt werden.

          (%i1) plot2d ( x^2-1, [x, -3, 3], [y, -2, 10],
                                [box, false],
                                [plot_format, xmaxima])$

     Ein Graph mit einer logarithmischen Skala:

          (%i1) plot2d (exp(3*s), [s, -2, 2], [logy])$

     Graphen von Funktionen, deren Namen als Argumente übergeben werden.

          (%i1) F(x) := x^2 $
          (%i2) :lisp (defun |$g| (x) (m* x x x))
          $g
          (%i2) H(x) := if x < 0 then x^4 - 1 else 1 - x^5 $
          (%i3) plot2d ([F, G, H], [u, -1, 1], [y, -1.5, 1.5])$

     Graph einer parametrisch definierten Schmetterlingskurve.

          (%i1) r: (exp(cos(t))-2*cos(4*t)-sin(t/12)^5)$
          (%i2) plot2d([parametric, r*sin(t), r*cos(t), [t, -8*%pi, 8*%pi],
                       [nticks, 2000]])$

     Ein parametrischer Kreis mit zwei vollständigen Drehungen, der nur
     für 7 Punkte gezeichnet ist.

          (%i1) plot2d ([parametric, cos(t), sin(t), [t, -2*%pi, 2*%pi],
                        [nticks, 8]])$

     Graph der Funktion `abs(x)' und eines parametrischen Kreises.  Das
     Seitenverhältnis der Grafik wurde mit den Grafikoptionen `x' und
     `y' so angepasst, dass der Kreis rund erscheint.  Das hier gewählte
     Seitenverhältnis funktioniert gut für die Ausgabe im
     Postscript-Format.

          (%i1) plot2d([[parametric, cos(t), sin(t) ,[t,0,2*%pi],
                  [nticks, 80]], abs(x)], [x,-2,2], [y, -1.5, 1.5])$
          plot2d: some values were clipped.

     Graph für diskrete Punkte.  Die Punkte sind in zwei separaten
     Listen jeweils für die x- und y-Koordinaten angegeben.
     Standardmäßig werden die Punkte mit einer Linie verbunden.

          (%i1) plot2d([discrete, [10, 20, 30, 40, 50],
                                  [.6, .9, 1.1, 1.3, 1.4]])$

     Dieselben Punkte des letzten Beispiels.  Jeder Punkt wird einzeln
     in eine Liste eingetragen und die Punkte werden nicht miteinander
     verbunden.

          (%i1) plot2d([discrete, [[10, .6], [20, .9], [30, 1.1],
                                   [40, 1.3], [50, 1.4]]],
                                   [style, points])$

     In diesem Beispiel wird eine Tabelle mit drei Spalten in eine Datei
     `data.txt' gespeichert.  Die Datei wird gelesen und die zweite und
     dritte Spalte werden gezeichnet.

          (%i1) with_stdout ("data.txt",
                             for x:0 thru 10 do print (x, x^2, x^3))$
          (%i2) data: read_matrix ("data.txt")$
          (%i3) plot2d ([discrete, transpose(data)[2], transpose(data)[3]],
            [style,points], [point_type,diamond], [color,red])$

     Graph von experimentellen Datenpunkten zusammen mit einer
     theoretischen Funktion, die die Daten beschreibt.

          (%i1) xy: [[10, .6], [20, .9], [30, 1.1], [40, 1.3], [50, 1.4]]$
          (%i2) plot2d([[discrete, xy], 2*%pi*sqrt(l/980)], [l,0,50],
                  [style, points, lines], [color, red, blue],
                  [point_type, asterisk], [legend, "experiment", "theory"],
                  [xlabel, "pendulum's length (cm)"],
                  [ylabel, "period (s)"])$


 -- Funktion: plot3d (<expr>, <x_range>, <y_range>, ..., <options>, ...)
 -- Funktion: plot3d ([<expr_1>, ..., <expr_n>], <x_range>, <y_range>,
          ..., <options>, ...)
     Zeichnet einen Graph mit einer oder mehreren Flächen, die als eine
     Funktion von zwei Variablen oder in parametrischer Form definiert
     sind.

     Die zu zeichnenden Funktionen werden als Ausdrücke oder mit ihrem
     Namen als Argumente übergeben.  Mit der Maus kann der Graph
     rotiert werden, um die Fläche aus verschiedenen Blickwinkeln zu
     betrachten.

     Siehe auch das Kapitel Grafikoptionen.

     Beispiele:

     Graph einer einfachen Funktion.

          (%i1) plot3d (2^(-u^2 + v^2), [u, -3, 3], [v, -2, 2])$

     Mit der Grafikoption `z' wird der Wertebereich der z-Achse
     begrenzt.  Dieses Beispiel zeigt den Graph ohne Färbung der Fläche.

          (%i1) plot3d ( log ( x^2*y^2 ), [x, -2, 2], [y, -2, 2], [z, -8, 4],
                         [palette, false], [color, magenta, blue])$

     Unendlich große Werte der z-Koordinate können auch durch Wahl eines
     Gitters vermieden werden, das nicht mit einer der Asymptoten
     zusammenfällt.  Das Beispiel zeigt zudem die Nutzung einer
     vordefinierten Palette.

          (%i1) plot3d (log (x^2*y^2), [x, -2, 2], [y, -2, 2],
                   [grid, 29, 29], [palette, get_plot_option(palette,5)])$

     Graph mit zwei Flächen, die denselben Wertebereich haben und eine
     Palette nutzen.

          (%i1) plot3d ([2^(-x^2 + y^2), 4*sin(3*(x^2+y^2))/(x^2+y^2),
                        [x, -3, 3], [y, -2, 2]])$

     Die gleichen zwei Flächen mit verschiedenen Wertebereichen.  In
     Xmaxima nutzen die zwei Flächen verschiedene Paletten.

          (%i1) plot3d ([[2^(-x^2 + y^2), [x,-2,2], [y,-2,2]],
                   4*sin(3*(x^2+y^2))/(x^2+y^2), [x, -3, 3], [y, -2, 2]],
                   [plot_format,xmaxima])$

     Graph der kleinschen Flasche, die parametrisch definiert ist.

          (%i1) expr_1: 5*cos(x)*(cos(x/2)*cos(y)
                        + sin(x/2)*sin(2*y) + 3.0) - 10.0$
          (%i2) expr_2: -5*sin(x)*(cos(x/2)*cos(y)
                        + sin(x/2)*sin(2*y) + 3.0)$
          (%i3) expr_3: 5*(-sin(x/2)*cos(y) + cos(x/2)*sin(2*y))$
          (%i4) plot3d ([expr_1, expr_2, expr_3], [x, -%pi, %pi],
                  [y, -%pi, %pi], [grid, 40, 40])$

     Graph einer Kugelfunktion, die vordefinierte
     Koordinatentransformation `spherical_to_xyz'  wird verwendet, um
     von Kugelkoordinaten in ein kartesisches Koordinatensystem zu
     transformieren.

          (%i1) plot3d (sin(2*theta)*cos(phi),
                  [theta, 0, %pi], [phi, 0, 2*%pi],
                  [transform_xy, spherical_to_xyz], [grid,30,60])$

     Gebrauch der vordefinierten Funktion `polar_to_xy', um von
     zylindrischen Koordinaten in ein kartesisches Koordinatensystem zu
     transformieren.  Siehe auch `polar_to_xy'.   Dieses Beispiel zeigt
     auch wie der Rahmen und die Legende entfernt werden können.

          (%i1) plot3d (r^.33*cos(th/3), [r, 0, 1], [th, 0, 6*%pi],
                  [grid, 12, 80],
                  [transform_xy, polar_to_xy], [box, false], [legend,false])$

     Graph einer Kugel, wobei die Koordinatentransformation von
     Kugelkoordinaten in ein kartesisches Koordinatensystem genutzt
     wird.  In Xmaxima werden die drei Achsen gleichmäßig skaliert, um
     die Proportionen der Kugel zu bewahren.  Eine Palette mit
     verschiedenen Schattierungen einer Farbe wird genutzt.

          (%i1) plot3d( 5, [theta, 0, %pi], [phi, 0, 2*%pi],
                   [plot_format,xmaxima], [transform_xy, spherical_to_xyz],
                   [palette,[value,0.65,0.7,0.1,0.9]])$

     Definition einer Funktion mit zwei Variablen als eine Matrix.  Der
     Quote-Operator  `'' in der Definition der Funktion verhindert, das
     `plot3d' fehlschlägt, wenn die Argumente keine ganze Zahlen sind.

          (%i1) M: matrix([1, 2, 3, 4], [1, 2, 3, 2], [1, 2, 3, 4],
                          [1, 2, 3, 3])$
          (%i2) f(x, y) := float('M [round(x), round(y)])$
          (%i3) plot3d (f(x,y), [x, 1, 4], [y, 1, 4], [grid, 4, 4])$
          apply: subscript must be an integer; found: round(x)

     Wird die Höhenangabe `elevation' auf Null gesetzt, kann die Fläche
     als eine Karte betrachtet werden.  Jede Farbe repräsentiert einen
     anderen Wert der Fläche.  Die Option `colorbox' wird genutzt, um
     die Werte der Farben zu zeigen.  Die Gitterlinien sind
     ausgeschaltet.

          (%i1) plot3d (cos (-x^2 + y^3/4), [x, -4, 4], [y, -4, 4],
                  [mesh_lines_color, false], [elevation, 0], [azimuth, 0],
                  [colorbox, true], [grid, 150, 150])$


 -- Systemvariable: plot_options
     Die Elemente dieser Liste definieren die Standardwerte für die
     Ausgabe von Graphen.  Ist einer der Werte ein Argument der
     Funktionen `plot2d' oder `plot3d', wird der Standardwert
     überschrieben.  Die Standardwerte können mit der Funktion
     `set_plot_option' gesetzt werden.  Einige Grafikoptionen sind
     nicht in der Liste `plot_options' enthalten.

     Jedes Element der Liste `plot_options' ist eine Liste mit zwei oder
     mehr Einträgen.  Der erste Eintrag ist der Name der Grafikoption.
     Die weiteren Einträge sind die Parameter der Option.  In einigen
     Fällen kann der Parameter einer Option wiederum eine Liste sein.

     Siehe auch `set_plot_option',  `get_plot_option'  und das Kapitel
     Grafikoptionen.


 -- Funktion: set_plot_option (<option>)
     Akzeptiert die meisten der Optionen, die im Kapitel Grafikoptionen
     aufgelistet sind und speichert diese in der globalen Variable
     `plot_options'.  `set_plot_options' wertet die Argumente aus und
     gibt die vollständige Liste `plot_optons' zurück.

     Siehe auch `plot_options',  `get_plot_option'  und das Kapitel
     Grafikoptionen.

     Beispiele:

     Setze einen neue Werte für die Grafikoption `grid'.

          (%i1) set_plot_option ([grid, 30, 40]);
          (%o1) [[t, - 3, 3], [grid, 30, 40], [transform_xy, false],
          [run_viewer, true], [axes, true], [plot_format, gnuplot_pipes],
          [color, blue, red, green, magenta, black, cyan],
          [point_type, bullet, circle, plus, times, asterisk, box, square,
          triangle, delta, wedge, nabla, diamond, lozenge],
          [palette, [hue, 0.25, 0.7, 0.8, 0.5],
          [hue, 0.65, 0.8, 0.9, 0.55], [hue, 0.55, 0.8, 0.9, 0.4],
          [hue, 0.95, 0.7, 0.8, 0.5]], [gnuplot_term, default],
          [gnuplot_out_file, false], [nticks, 29], [adapt_depth, 5],
          [gnuplot_preamble, ], [gnuplot_default_term_command,
          set term pop], [gnuplot_dumb_term_command, set term dumb 79 22],
          [gnuplot_ps_term_command, set size 1.5, 1.5;set term postscript \
          eps enhanced color solid 24], [plot_realpart, false]]

 -- Systemfunktion: spherical_to_xyz
     Kann als Parameter für die Option `transform_xy' der Funktion
     `plot3d' übergeben werden.  Der Parameter `spherical_to_xyz'
     bewirkt, dass die zwei unabhängigen Variablen und die Funktion
     beim Aufruf von `plot3d' von Kugelkoordinaten in kartesische
     Koordinaten umgerechnet werden.


File: maxima.info,  Node: Grafikoptionen,  Next: Gnuplot Optionen,  Prev: Funktionen und Variablen für die grafische Darstellung,  Up: Grafische Darstellung

12.4 Grafikoptionen
===================

Die Grafikoptionen bestehen aus einer Liste, die mit einem Schlüsselwort
beginnt und ein oder mehrere Parameter enthält.  Die meisten Optionen
können mit den Funktionen `plot2d', `plot3d', `contour_plot' oder
`implicit_plot' genutzt und mit der Funktion `set_plot_option' gesetzt
werden.  Auf Ausnahmen wird im Folgenden hingewiesen.

 -- Grafikoption: adapt_depth [adapt_depth, <integer>]
     Standardwert: `5'

     Die maximale Zahl an Teilungen von Intervallen, die der adaptive
     Algorithmus für das Zeichnen eines Graphen vornimmt.  Zusammen mit
     der Grafikoption `nticks'  hat diese Grafikoption Einfluss darauf,
     wie glatt der Graph gezeichnet wird.

 -- Grafikoption: axes [axes, <symbol>]
     Standardwert: `true'

     `symbol' kann einen der Werte `true', `false', `x' oder `y'
     annehmen.  Ist der Wert `false', werden keine Achsen gezeichnet.
     Mit `x' oder `y' werden nur die x- oder nur die y-Achse gezeichnet.
     Mit `true' werden beide Achsen gezeichnet.  Diese Option wird nur
     von den Funktionen `plot2d'  und `implicit_plot'  beachtet.

 -- Grafikoption: azimuth [azimuth, <number>]
     Standardwert: `30'

     Setzt den Wert des Azimutwinkels in Grad für die Ansicht einer
     dreidimensionalen Grafik.  Siehe auch `elevation'.


 -- Grafikoption: box [box, <symbol>]
     Standardwert: `true'

     Hat die Grafikoption `box' den Wert `true', erhält die Grafik einen
     Rahmen.  Ist der Wert `false', wird kein Rahmen gezeichnet.

 -- Grafikoption: color [color, <color_1>, ..., <color_n>]
     Standardwert: `[blue, red, green, magenta, black, cyan]'

     Wenn die Funktionen `plot2d'  oder `implicit_plot'  mehrere Graphen
     zeichnen, definiert die Grafikoption `color' die Farben der
     einzelnen Graphen.  Für einen 3D-Graphen mit der Funktion `plot3d'
     definiert die Grafikoption `color' die Farbe der Flächen.

     Gibt es mehr Kurven oder Flächen als Farben, werden die Farben
     wiederholt.  Im Grafikformat Gnuplot können nur die Farben `blue',
     `red', `green', `magenta', `black', `cyan' verwendet werden.  Im
     Grafikformat Xmaxima können die Farben auch als eine Zeichenkette
     angegeben werden, die mit dem Zeichen # beginnt und auf dem sechs
     hexadezimale Zahlenwerte folgen.  Je zwei Werte bezeichnen die
     rote, grüne und blaue Komponente der Farbe.

     Siehe auch `style'.


 -- Grafikoption: colorbox [colorbox, <symbol>]
     Standardwert: `false'

     Hat die Grafikoption `colorbox' den Wert `true', wird immer dann,
     wenn das Grafikkommando `plot3d'  eine Palette mit verschiedenen
     Farben nutzt, um die z-Werte darzustellen, eine Legende mit den
     Farben und den dazugehörenden z-Werten angezeigt.

 -- Grafikoption: elevation [elevation, <number>]
     Standardwert: `60'

     Setzt den Wert des Elevationswinkels in Grad für die Ansicht einer
     dreidimensionalen Grafik.  Siehe auch `azimuth'.


 -- Grafikoption: grid [grid, <integer>, <integer>]
     Standardwert: `[30, 30]'

     Setzt die Anzahl der Gitterlinen für die x- und y-Achsen einer
     dreidimensionalen Grafik.

 -- Grafikoption: legend [legend, <string_1>, ..., <string_n>]
 -- Grafikoption: legend [legend, <false>]
     Definiert die Einträge einer Legende, wenn mehrere Graphen
     gezeichnet werden.  Sind mehr Graphen als Einträge vorhanden,
     werden die Einträge wiederholt.  Hat die Grafikoption `legend' den
     Wert `false', wird keine Legende gezeichnet.  Standardmäßig werden
     die Ausdrücke oder Namen der Funktionen als Einträge verwendet.
     Für diskrete Grafiken werden die Einträge mit discrete1,
     discrete2, ... bezeichnet.  Diese Grafikoption kann nicht mit der
     Funktion `set_plot_option' gesetzt werden.

 -- Grafikoption: logx [logx]
     Bewirkt, dass die horizontale Achse logarithmisch skaliert wird.
     Diese Grafikoption kann nicht mit der Funktion `set_plot_option'
     gesetzt werden.  Siehe auch `logy'.


 -- Grafikoption: logy [logy]
     Bewirkt, dass die vertikale Achse logarithmisch skaliert wird.
     Diese Grafikoption kann nicht mit der Funktion `set_plot_option'
     gesetzt werden.  Siehe auch `logx'.


 -- Grafikoption: mesh_lines_color [mesh_lines_color, <color>]
     Standardwert: `black'

     Setzt die Farbe, die von der Funktion `plot3d' genutzt wird, um die
     Gitterlinien zu zeichnen.  Es können dieselben Farben verwendet
     werden wie für die Grafikoption `color'.   Hat `mesh_lines_color'
     Wert `false', werden keine Gitterlinien gezeichnet.

 -- Grafikoption: nticks [nticks, <integer>]
     Standardwert: `29'

     Wird eine Grafik mit der Funktion `plot2d' gezeichnet, gibt
     `nticks' die Anzahl der Anfangspunkte für das Zeichnen der Grafik
     an.  Werden parametrische Kurven mit den Funktionen `plot2d' oder
     `plot3d' gezeichnet, ist `nticks' die Anzahl der Punkte, für die
     der Graph gezeichnet wird.

     Zusammen mit der Grafikoption `adapt_depth'  hat diese
     Grafikoption Einfluss darauf, wie glatt der Graph gezeichnet wird.

 -- Grafikoption: palette [palette, [<palette_1>], ..., [<palette_n>]]
 -- Grafikoption: palette [palette, <false>]
     Standardwert: `[hue, 0.25, 0.7, 0.8, 0.5], [hue, 0.65, 0.8, 0.9, 0.55],
     [hue, 0.55, 0.8, 0.9, 0.4], [hue, 0.95, 0.7, 0.8, 0.5]'

     Eine Palette kann aus einer oder einer Liste mit mehreren Paletten
     bestehen.  Jede Palette beginnt mit einem Schlüsselwort, worauf 4
     Zahlen folgen.  Die ersten drei Zahlen haben Werte zwischen 0 und
     1.  Diese definieren den Farbton `hue', die Sättigung `saturation'
     und die Grundfarbe `value', die der kleinste z-Wert erhält.  Die
     Schlüsselworte `hue', `saturation' und `value' spezifizieren,
     welches der drei Attribute mit dem Wert von z geändert werden.
     Der letzte Wert der Liste, spezifiziert, welcher Wert zum größten
     z-Wert gehört.  Dieser größte Wert kann größer als 1 und auch
     negativ sein.  Die Werte der modifizierten Attribute werden Modulo
     1 gerundet.

     Gnuplot verwendet nur die erste Palette in einer Liste mit
     Paletten.  Xmaxima nutzt alle Paletten nacheinander, wenn mehrere
     Flächen gezeichnet werden.  Sind nicht genügend Paletten
     vorhanden, werden die Paletten wiederholt.

     Die Farbe der Gitterlinien wird mit der Option `mesh_lines_color'
     angegeben.  Hat `palette' den Wert `false', werden die Flächen
     nicht gefärbt, sondern als ein Gitternetz gezeichnet.  Die Farbe
     der Gitterlinien wird in diesem Fall mit der Grafikoption `color'
     festgelegt.

 -- Grafikoption: plot_format [plot_format, <format>]
     Standardwert: `gnuplot' für Windows, ansonsten `gnuplot_pipes'

     Setzt das Grafikformat für die Ausgabe einer Grafik.  `format'
     kann die Werte `gnuplot', `xmaxima', `mgnuplot' oder
     `gnuplot_pipes' annehmen.  Siehe das Kapitel Grafikformate.


 -- Grafikoption: plot_realpart [plot_realpart, <symbol>]
     Standardwert: `false'

     Hat `plot_realpart' den Wert `true', werden Funktionen als komplex
     angenommen und der Realteil wird gezeichnet.  Das entspricht dem
     Aufruf der Grafikfunktion mit dem Ausdruck `realpart(<function>)'.
     Hat `plot_realpart' den Wert `false', wird keine Grafik
     gezeichnet, wenn die Funktion keinen Realteil hat.  Zum Beispiel
     ist `log(x)' komplex, wenn <x> negativ ist.  Hat `plot_realpart'
     den Wert `true', wird der Wert `log(-5)' als `log(5)' gezeichnet.
     Hat `plot_realpart' den Wert `false' wird kein Wert gezeichnet.

 -- Grafikoption: point_type [point_type, <type_1>, ..., <type_n>]
     Standardwert: `[bullet, circle, plus, times, asterisk, box, square,
     triangle, delta, wedge, nabla, diamond, lozenge]'

     Werden im Grafikformat Gnuplot Punkte mit den Stilen `points' oder
     `linespoints' gezeichnet, werden die Symbole für die einzelnen
     Datensätze nacheinander der Liste `point_type' entnommen.  Gibt es
     mehr Datensätze als Symbole, werden diese wiederholt.  Siehe auch
     `style'.


 -- Grafikoption: psfile [psfile, <filename>]
     Speichert die Grafik in eine Postscript-Datei mit den Namen
     <filename>.  Die Grafik wird nicht auf dem Bildschirm ausgegeben.
     Standardmäßig wird die Datei in dem Ordner abgespeichert, dessen
     Namen in der Optionsvariablen `maxima_tempdir' enthalten ist.

 -- Grafikoption: run_viewer [run_viewer, <symbol>]
     Standardwert: `true'

     Kontrolliert, ob die Bildschirmausgabe des Grafikformats gestartet
     wird.

 -- Grafikoption: style [style, <type_1>, ..., <type1_n>]
 -- Grafikoption: style [style, [<style_1>], ..., [<style_n>]]
     Standardwert: `lines'

     Bestimmt den Stil für das Zeichnen von Funktionen oder Datensätzen
     mit der Funktion `plot2d'.  Werden mehr Graphen gezeichnet, als
     Stile vorhanden sind, werden diese wiederholt.  Die möglichen
     Stile sind `lines' für Linien, `points' für einzelne Punkte,
     `linespoints' für Linien mit Punkten oder `dots' für kleine
     Punkte.  Das Grafikformat Gnuplot akzeptiert zusätzlich den Stil
     `impulses'.

     Jeder Stil kann weitere Parameter erhalten, die zusammen mit dem
     Stil als eine Liste angegeben werden.  Der Stil `lines' akzeptiert
     zwei Zahlen, die die Breite der Linie und deren Farbe angegeben.
     Die Standardfarben haben die Zahlenwerte: 1: `blue', 2: `red', 3:
     `magenta', 4: `orange', 5: `brown', 6: `lime' und 7: `aqua'.  Im
     Grafikformat Gnuplot kann die Kodierung der Farben für
     verschiedene Terminals abweichend sein.  Wird zum Beispiel das
     Terminal [<gnuplot_term>,<ps>] verwendet, entspricht dem
     Zahlenwert 4 die Farbe `black'.

     Der Stil `points' akzeptiert zwei oder drei Parameter.  Der erste
     Parameter ist der Radius des Punktes.  Der zweite Parameter ist
     eine Zahl, der wie für den Stil `lines' eine Farbe angibt.  Der
     dritte Parameter ist eine Zahl, mit der im Grafikformat Gnuplot
     die folgenden Zeichen für die Darstellung der Punkte ausgewählt
     werden können: 1: `bullet', 2: `circle', 3: `plus', 4: `times', 5:
     `asterisk', 6: `box', 7: `square', 8: `triangle', 9: `delta', 10:
     `wedge', 11: `nabla', 12: `diamond', 13: `lozenge'.

     Der Stil `linesdots' akzeptiert bis zu vier Parameter: die Breite
     der Linie, den Radius der Punkte, die Farbe und das Symbol für das
     Zeichnen der Punkte.

     Siehe auch die Grafikoptionen `color'  und `point_type'.


 -- Grafikoption: t [t, <min>, <max>]
     Bestimmt den Wertebereich für das Zeichnen einer parametrischen
     Kurve mit der Funktion `plot2d'.    Die Variable einer
     parametrischen Kurve muss mit `t' bezeichnet werden.

 -- Grafikoption: transform_xy [transform_xy, <symbol>]
     Standardwert: `false'

     <symbol> hat entweder den Wert `false' oder ist das Ergebnis der
     Funktion `make_transform'.    Wenn verschieden von `false', wird
     die Funktion genutzt, um die drei Koordinaten einer
     dreidimensionalen Grafik zu transformieren.

     Siehe auch `polar_to_xy'  und `spherical_to_xyz'.   für bereits
     vordefinierte Koordinatentransformationen.

 -- Grafikoption: x [x, <min>, <max>]
     Die erste Grafikoption der Funktionen `plot2d' oder `plot3d'
     bezeichnet die unabhängige Variable.  Die unabhängige Variable muss
     nicht mit `x' bezeichnet werden, sondern kann ein beliebiges von
     `x' verschiedenes Symbol sein.  Die Werte <min> und <max> geben in
     diesem Fall den Wertebereich der unabhängigen Variablen an.  Die
     Grafikoption `x' kann ein zweites Mal angegeben werden, um den
     Bereich für die x-Achse festzulegen.

 -- Grafikoption: xlabel [xlabel, <string>]
     Standardwert: `"x"'

     Legt die Zeichenkette <string> fest, mit der die x-Achse der Grafik
     bezeichnet wird.  Der Standardwert ist `"x"' oder der Name der
     ersten unabhängigen Variablen.  Diese Grafikoption kann nicht mit
     dem Kommando `set_plot_option' gesetzt werden.

 -- Grafikoption: y [y, <min>, <max>]
     Für einen dreidimensionalen Graphen legt diese Grafikoption die
     zweite unabhängige Variable fest.  Die unabhängige Variable muss
     nicht mit `y' bezeichnet werden, sondern kann ein beliebiges von
     `y' verschiedenes Symbol sein.  Die Werte <min> und <max> geben in
     diesem Fall den Wertebereich der Variablen an.  Wird die
     Grafikoption für einen zweidimensionalen Graphen verwendet oder
     für einen dreidimensionalen Graphen ein zweites Mal eingesetzt,
     dann wird der Bereich für die y-Achse festgelegt.

 -- Grafikoption: ylabel [ylabel, <string>]
     Standardwert: `"y"'

     Legt die Zeichenkette <string> fest, mit der die y-Achse der Grafik
     bezeichnet wird.  Der Standardwert ist `"y"' oder für den Fall
     einer dreidimensionalen Grafik der Name der zweiten unabhängigen
     Variablen.  Diese Grafikoption kann nicht mit dem Kommando
     `set_plot_option' gesetzt werden.

 -- Grafikoption: z [z, <min>, <max>]
     Legt für eine dreidimensionalen Grafik den Bereich für die z-Achse
     fest.

 -- Grafikoption: zlabel [zlabel, <string>]
     Standardwert: `"z"'

     Legt die Zeichenkette <string> fest, mit der die z-Achse der Grafik
     bezeichnet wird.  Der Standardwert ist `"z"'.  Diese Grafikoption
     kann nicht mit dem Kommando `set_plot_option' gesetzt werden und
     wird von den Funktionen `plot2d' sowie `implicit_plot' ignoriert.


File: maxima.info,  Node: Gnuplot Optionen,  Next: Gnuplot_pipes Formatfunktionen,  Prev: Grafikoptionen,  Up: Grafische Darstellung

12.5 Gnuplot Optionen
=====================

Es gibt einige spezielle Optionen für das Grafikformat Gnuplot.  Diese
Optionen werden mit einem Schlüsselwort bezeichnet und zusammen mit
einer Zeichenkette, die ein gültiges Gnuplot-Kommando darstellt, an
Gnuplot übergeben.  In den meisten Fällen gibt es eine entsprechende
Grafikoption, die ein vergleichbares Ergebnis erzeugt.  Die
Grafikoptionen sollten den Gnuplot-Optionen vorgezogen werden.

 -- Grafikoption: gnuplot_term
     Setzt den Terminaltyp für das Grafikformat Gnuplot.

        * *default* (Standardwert)

          Die Ausgabe von Gnuplot wird in einem separatem Fenster
          angezeigt.

        * *dumb*

          Die Ausgabe von Gnuplot wird in der Maxima Konsole mit
          Ascii-Zeichen angezeigt.

        * *ps*

          Gnuplot generiert PostScript-Kommandos.  Mit der Grafikoption
          `gnuplot_out_file' werden die PostScript-Kommandos in eine
          Datei <filename> geschrieben.  Ansonsten werden die Kommandos
          in die Datei `maxplot.ps' geschrieben.

        * Jede andere gültige Gnuplot Spezifikation

     Gnuplot kann Ausgaben in verschiedenen Formaten wie zum Beispiel
     PNG, JPEG, SVG generieren.  Die verschiedenen Formate werden mit
     der Option `gnuplot_term' angegeben.  Weiterhin kann jedes gültige
     Kommando als Zeichenkette übergeben werden.  Zum Beispiel
     generiert `[gnuplot_term, png]' eine Grafik im PNG-Format.  Das
     Kommando `[gnuplot_term, "png size 1000, 1000"]' generiert eine
     Grafik im PNG-Format mit dem Format 1000 x 1000 Punkte.  Erhält die
     Grafikoption `gnuplot_out_file' den Wert <filename>, wird die
     Ausgabe in die Datei <filename> geschrieben.  Ansonsten werden die
     Kommandos in die Datei `maxplot.<term>' geschrieben, wobei <term>
     das verwendete Grafikformat ist.

 -- Grafikoption: gnuplot_out_file
     Zusammen mit der Option `gnuplot_term', kann die Ausgabe in dem
     angegebenen Gnuplot-Format in eine Datei geschrieben werden.  Eine
     Postscript-Datei kann auch mit der Grafikoption `psfile' angegeben
     werden.  Die Grafikoption `psfile' funktioniert auch mit dem
     Grafikformat `xmaxima'.

          [gnuplot_term, png], [gnuplot_out_file, "graph3.png"]

 -- Grafikoption: gnuplot_pm3d
     Hat die Grafikoption `gnuplot_pm3d' den Wert `false', wird der
     PM3D-Modus ausgeschaltet.  Dieser Modus ist standardmäßig
     eingeschaltet.

 -- Grafikoption: gnuplot_preamble
     Fügt Gnuplot-Kommandos ein, die vor dem Zeichnen der Grafik
     ausgeführt werden.  Jedes gültige Gnuplot-Kommando kann verwendet
     werden.  Mehrere Kommandos sollten mit einem Semikolon voneinander
     getrennt werden.  Der Standardwert der Option `gnuplot_preamble'
     ist eine leere Zeichenkette `""'.

 -- Grafikoption: gnuplot_curve_titles
     Dies ist eine veraltete Option, die von der Grafikoption `legend'
     ersetzt wurde.

 -- Grafikoption: gnuplot_curve_styles
     Dies ist eine veraltete Option, die von der Grafikoption `style'
     ersetzt wurde.

 -- Grafikoption: gnuplot_default_term_command
     Das Gnuplot-Kommando, um den Standardtyp eines Terminals zu setzen.
     Der Standardwert ist `set term pop'.

 -- Grafikoption: gnuplot_dumb_term_command
     Das Gnuplot-Kommando, um die Breite und Höhe des Terminaltyps
     `dumb' zu setzen.  Der Standardwert ist `"set term dumb 79 22"'.
     Die Ausgabe hat eine Breite von 79 Zeichen und eine Höhe von 22
     Zeichen.

 -- Grafikoption: gnuplot_ps_term_command
     Das Gnuplot-Kommando, um die Parameter für eine
     Postscript-Terminal zu setzen.  Ein Postscript-Terminal hat die
     Standardwerte `"set size 1.5, 1.5; set term postscript eps
     enhanced color solid 24"'.  Das Terminal wird auf den 1,5 fachen
     Wert des Standardwertes und die Schriftgröße auf 24 gesetzt.
     Siehe die Gnuplot-Dokumentation für eine Beschreibung weiterer
     Parameter, die für ein Postscript-Terminal gesetzt werden können.


File: maxima.info,  Node: Gnuplot_pipes Formatfunktionen,  Prev: Gnuplot Optionen,  Up: Grafische Darstellung

12.6 Gnuplot_pipes Formatfunktionen
===================================

 -- Funktion: gnuplot_start ()
     Öffnet eine Pipe, die im Grafikformat `gnuplot_pipes' für den
     Austausch der Daten genutzt wird.

 -- Funktion: gnuplot_close ()
     Schließt die Pipe, die im Grafikformat `gnuplot_pipes' für den
     Austausch der Daten genutzt wird.

 -- Funktion: gnuplot_restart ()
     Schließt die Pipe, die im Grafikformat `gnuplot_pipes' für den
     Austausch der Daten genutzt wird, und öffnet eine neue Pipe.

 -- Funktion: gnuplot_replot ()
 -- Funktion: gnuplot_replot (<string>)
     Aktualisiert die Ausgabe von Gnuplot.  Wird `gnuplot_replot' mit
     einer Zeichenkette <string> aufgerufen, die Gnuplot-Kommandos
     enthält, dann werden die Kommandos vor der Aktualisierung an
     Gnuplot gesendet.

 -- Funktion: gnuplot_reset ()
     Im Grafikformat `gnuplot_pipes' wird Gnuplot zurückgesetzt.  Um die
     Anzeige zu aktualisieren, kann das Kommando `gnuplot_replot' nach
     dem Kommando `gnuplot_reset' ausgeführt werden.


File: maxima.info,  Node: Eingabe und Ausgabe,  Next: Mengen,  Prev: Grafische Darstellung,  Up: Top

13 Eingabe und Ausgabe
**********************

* Menu:

* Kommentare::
* Dateien::
* Funktionen und Variablen für die Eingabe und Ausgabe::
* Funktionen und Variablen für die TeX-Ausgabe::
* Funktionen und Variablen für die Fortran-Ausgabe::


File: maxima.info,  Node: Kommentare,  Next: Dateien,  Prev: Eingabe und Ausgabe,  Up: Eingabe und Ausgabe

13.1 Kommentare
===============

Ein Kommentar in der Maxima-Eingabe ist ein Text der von den Zeichen
`/*' und `*/' eingeschlossen ist.  Der Maxima-Parser behandelt einen
Kommentar wie ein Zwischenraumzeichen, wenn ein Token eingelesen wird.
Ein Token endet immer an einem Zwischenraumzeichen.  Eine Eingabe wie
`a/* foo */b' enthält die beiden Token `a' und `b' und nicht das
einzelne Token `ab'.  Ansonsten werden Kommentare von Maxima ignoriert.
Kommentare werden im eingelesenen Ausdruck nicht gespeichert.

Kommentare können in beliebiger Tiefe verschachtelt werden.  Die
Begrenzungszeichen `/*' und `*/' müssen paarweise auftreten.

Beispiele:

     (%i1) /* aa is a variable of interest */  aa : 1234;
     (%o1)                         1234
     (%i2) /* Value of bb depends on aa */  bb : aa^2;
     (%o2)                        1522756
     (%i3) /* User-defined infix operator */  infix ("b");
     (%o3)                           b
     (%i4) /* Parses same as a b c, not abc */  a/* foo */b/* bar */c;
     (%o4)                         a b c
     (%i5) /* Comments /* can be nested /* to any depth */ */ */  1 + xyz;
     (%o5)                        xyz + 1


File: maxima.info,  Node: Dateien,  Next: Funktionen und Variablen für die Eingabe und Ausgabe,  Prev: Kommentare,  Up: Eingabe und Ausgabe

13.2 Dateien
============

Folgende Funktionen und Variablen arbeiten mit Dateien:

   appendfile           batch                 batchload
   closefile            file_output_append    filename_merge
   file_search          file_search_maxima    file_search_lisp
   file_search_demo     file_search_usage     file_search_tests
   file_type            file_type_lisp        file_type_maxima
   load                 load_pathname         loadfile
   loadprint            pathname_directory    pathname_name
   pathname_type        printfile             save
   stringout            with_stdout           writefile


File: maxima.info,  Node: Funktionen und Variablen für die Eingabe und Ausgabe,  Next: Funktionen und Variablen für die TeX-Ausgabe,  Prev: Dateien,  Up: Eingabe und Ausgabe

13.3 Funktionen und Variablen für die Eingabe und Ausgabe
=========================================================

 -- Funktion: appendfile (<filename>)
     Startet wie die Funktion `writefile'  eine Aufzeichnung aller Ein-
     und Ausgaben der Konsole.  Die Ein- und Ausgaben werden in die
     Datei <filename> geschrieben.  Im Unterschied zu `writefile'
     werden die Daten immer an eine existierende Datei angehängt, wenn
     diese existiert.  Existiert die Datei nicht, wird diese angelegt.

     Die Funktion `closefile'  beendet die Aufzeichnung.

 -- Funktion: batch (<filename>)
 -- Funktion: batch (<filename>, option)
     Das Kommando `batch(<filename>)' liest Maxima-Ausdrücke aus der
     Datei <filename> ein, wertet diese aus und gibt die Ergebnisse auf
     der Konsole aus.  `batch' sucht die Datei <filename> in den
     Verzeichnissen, die in der Liste `file_search_maxima'  enthalten
     sind.  Siehe auch die Funktion `file_search'.

     `batch(<filename>, `demo')' entspricht dem Kommando
     `demo(<filename>)'.  `batch' sucht für diesen Fall die Datei in
     der Liste der Verzeichnisse `file_search_demo'.    Siehe auch die
     Funktion `demo'.

     `batch(<filename>, `test')' entspricht dem Kommando `run_testsuite'
     mit der Option `display_all=true'.  Im Unterschied zur Funktion
     `run_testsuite' sucht die Funktion `batch' die Datei <filename> in
     den Verzeichnissen der Liste `file_search_maxima' und nicht in der
     Liste `file_search_tests'.

     Die Maxima-Ausdrücke in der Datei werden wie auf der Konsole mit
     den Zeichen `;' oder `$' beendet.  Die Systemvariable `%' und die
     Funktion `%th' beziehen sich auf vorhergehende Zeilen in der
     Datei.  Die Datei kann `:lisp'-Unterbrechungskommandos enthalten.
     Leerzeichen, Tabulatoren, Zeilenschaltungen und Kommentare werden
     ignoriert.  Eine geeignete Datei kann mit einem Texteditor oder
     der Funktion `stringout'  erstellt werden.

     Den Ein- und Ausgaben werden jeweils Ein- und Ausgabemarken
     zugewiesen.  Tritt während der Auswertung eines Ausdrucks ein
     Fehler auf, wird das Einlesen der Datei abgebrochen.  Werden
     Eingaben vom Nutzer benötigt, wie zum Beispiel bei Fragen der
     Funktionen `asksign' oder `askinteger', dann wartet `batch' auf
     die Antworten, um dann die Verarbeitung der Datei fortzusetzen.

     Die Verarbeitung von `batch' kann durch die Eingabe von `control-C'
     abgebrochen werden.  Die weitere Reaktion auf einen Abbruch mit
     `control-C' hängt von der Lisp-Implementation ab.

     `batch' wertet die Argumente aus.  `batch' gibt den Namen der Datei
     <filename> als Zeichenkette zurück, wenn die Funktion ohne zweites
     Argument oder mit der Option `demo' aufgerufen wird.  Wird die
     Funktion mit der Option `test' aufgerufen, ist die Rückgabe eine
     leere Liste `[]' oder eine Liste, die <filename> und die Nummern
     der fehlgeschlagenen Tests enthält.

     Siehe auch die Funktionen `load'  und `batchload',  um Dateien zu
     laden, sowie die Funktionen `run_testsuite'  und `demo'.


 -- Funktion: batchload (<filename>)
     Liest Ausdrücke aus der Datei <filename> ein und wertet diese aus,
     ohne die eingelesenen und ausgewerteten Ausdrücke anzuzeigen und
     ohne Zuweisung von Eingabe- und Ausgabemarken.  Die Ausgabe von
     Fehlermeldungen oder sonstigem Text, der von Funktionen ausgegeben
     wird, wird nicht unterdrückt.

     Die Systemvariable `%' und die Funktion `%th' beziehen sich auf die
     letzte Eingabe auf der Konsole und nicht auf Zeilen oder
     Ergebnisse der Datei.  Im Gegensatz zur Funktion `batch' darf eine
     Datei, die von `batchload' geladen wird, keine
     `:lisp'-Unterbrechungskommandos enthalten.

     `batchload' gibt eine Zeichenkette mit dem Pfad der Datei
     <filename> zurück.  Siehe auch die Funktionen `batch'  und `load',
     um Dateien zu laden.

 -- Funktion: closefile ()
     Beendet eine Aufzeichnung, die von den Funktionen `writefile'  oder
     `appendfile'  gestartet wurde, und schließt die Ausgabedatei.

 -- Optionsvariable: file_output_append
     Standardwert: `false'

     Die Optionsvariable `file_output_append' kontrolliert, ob die
     Funktionen `save',  `stringout'  oder `with_stdout',  die in eine
     Datei schreiben, diese löschen und neu anlegen oder die Daten
     anhängen.  Wenn `file_output_append' den Wert `true' hat, werden
     die Daten an die existierende Datei angehängt.  Ansonsten wird
     eine neue Datei erstellt.

     Plot-Funktionen und der Übersetzer erstellen grundsätzlich neue
     Dateien und die Funktionen `tex'  und `appendfile'  hängen die
     Ausgabe immer an eine bestehende Datei an.

 -- Funktion: filename_merge (<path>, <filename>)
     Setzt einen Pfad aus <path> und <filename> zusammen.  Endet <path>
     mit einer Zeichenkette der Form `###.<something>', wird diese
     Zeichenkette durch `<filename.SOMETHING>' ersetzt.  Ansonsten wird
     der Endbestandteil durch <filename> ersetzt.

     Die Rückgabe ist ein Lisp-Dateiname.

     Beispiele:

          (%i1) filename_merge("user/", "myfile");
          (%o1)                      user/myfile

          (%i2) filename_merge("user/###.lisp", "myfile");
          (%o2)                   user/myfile.lisp

 -- Funktion: file_search (<filename>)
 -- Funktion: file_search (<filename>, <pathlist>)
     `file_search' sucht die Datei <filename> und gibt den Pfad als eine
     Zeichenkette zurück, wenn die Datei gefunden wurde.  Ansonsten wird
     `false' zurückgegeben.  `file_search(<filename>)' sucht in den
     Standardsuchverzeichnissen, die mit den Optionsvariablen
     `file_search_maxima',  `file_search_lisp'  und `file_search_demo'
     spezifiziert werden.

     `file_search' prüft zuerst, ob die Datei `filename' existiert.
     Dann prüft `file_search', ob die Datei anhand von Mustern im
     Dateinamen gefunden werden kann.  Siehe `file_search_maxima'  für
     die Suche von Dateien.

     Das Argument <filename> kann ein Name mit einer Pfadangabe oder
     allein der Dateiname sein.  Sind in den Suchverzeichnissen
     Dateinamen mit Mustern enthalten, kann die Datei auch ohne Endung
     angegeben werden.  Zum Beispiel finden die folgenden Kommandos
     dieselbe Datei, wenn `/home/wfs/special/###.mac' in der Liste
     `file_search_maxima' enthalten ist:

          file_search ("/home/wfs/special/zeta.mac");
          file_search ("zeta.mac");
          file_search ("zeta");

     `file_search(<filename>, <pathlist>)' sucht nur in den
     Verzeichnissen <pathlist>.  Das Argument <pathlist> überschreibt
     die Standardsuchverzeichnisse.  Auch ein einzelnes Verzeichnis
     muss als eine Liste übergeben werden.

     Die Standardsuchverzeichnisse können modifiziert werden.  Siehe
     dazu auch `file_search_maxima'.

     `file_search' wird von der Funktion `load'  mit den
     Verzeichnislisten `file_search_maxima' und `file_search_lisp'
     aufgerufen.

 -- Optionsvariable: file_search_maxima
 -- Optionsvariable: file_search_lisp
 -- Optionsvariable: file_search_demo
 -- Optionsvariable: file_search_usage
 -- Optionsvariable: file_search_tests
     Diese Optionsvariablen bezeichnen Listen mit Verzeichnissen, die
     von Funktionen wie `load'  und `demo'  durchsucht werden, um eine
     Datei zu finden.  Die Standardwerte bezeichnen verschiedene
     Verzeichnisse der Maxima-Installation.

     Diese Variablen können modifiziert werden, indem die Standardwerte
     ersetzt oder weitere Verzeichnisse angehängt werden.  Zum Beispiel
     wird im Folgenden der Standardwert der Optionsvariablen
     `file_search_maxima' ersetzt:

          file_search_maxima: ["/usr/local/foo/###.mac",
              "/usr/local/bar/###.mac"]$

     In diesem Beispiel werden zwei weitere Verzeichnisse zu der
     Optionsvariablen `file_search_maxima' hinzugefügt:

          file_search_maxima: append (file_search_maxima,
              ["/usr/local/foo/###.mac", "/usr/local/bar/###.mac"])$

     Soll eine erweiterte Liste der Suchverzeichnisse nach jedem Start
     von Maxima zur Verfügung stehen, kann das obige Kommando in die
     Datei `maxima-init.mac' aufgenommen werden.

     Mehrere Dateiendungen und Pfade können mit Wildcard-Konstruktionen
     spezifiziert werden.  Eine Zeichenkette `###' wird durch einen
     Dateinamen ersetzt.  Werden mehrere Zeichenketten durch Kommata
     getrennt und mit geschweiften Klammern angegeben wie zum Beispiel
     `{foo, bar, baz}', expandiert die Liste in mehrere Zeichenketten.
     Das folgende Beispiel expandiert für `neumann'

          "/home/{wfs,gcj}/###.{lisp,mac}"

     in `/home/wfs/neumann.lisp', `/home/gcj/neumann.lisp',
     `/home/wfs/neumann.mac' und `/home/gcj/neumann.mac'.

 -- Funktion: file_type (<filename>)
     Gibt eine Vermutung über den Typ der Datei <filename> zurück.  Es
     wird nur die Dateiendung betrachtet.

     Die Rückgabe ist das Symbol `maxima' oder `lisp', wenn die
     Dateiendung einen der Werte der Optionsvariablen `file_type_maxima'
     oder der Optionsvariablen `file_type_lisp'  entspricht.  Ansonsten
     ist die Rückgabe das Symbol `object'.

     Siehe auch die Funktion `pathname_type'.


 -- Optionsvariable: file_type_lisp
     Standardwert:  `[l, lsp, lisp]'

     Die Optionsvariable `file_type_lisp' enthält die Dateiendungen, die
     Maxima als die Bezeichnung für eine Lisp-Datei annimmt.

     Siehe auch die Funktion `file_type'.


 -- Optionsvariable: file_type_maxima
     Standardwert:  `[mac, mc, demo, dem, dm1, dm2, dm3, dmt]'

     Die Optionsvariable `file_type_maxima' enthält die Dateiendungen,
     die Maxima als die Bezeichnung für eine Maxima-Datei annimmt.

     Siehe auch die Funktion `file_type'.


 -- Funktion: load (<filename>)
     Wertet die Ausdrücke in der Datei <filename> aus, wodurch die
     Variablen, Funktionen und andere Objekte in Maxima geladen werden.
     Alle bisher zugewiesen Variablen und Definitionen werden
     überschrieben.  Um die Datei zu finden, wird von `load' die
     Funktion `file_search'  mit den Verzeichnislisten
     `file_search_maxima'  und `file_search_lisp'  aufgerufen.  Ist
     `load' erfolgreich, wird der Dateiname zurückgegeben.  Ansonsten
     gibt `load' eine Fehlermeldung aus.

     `load' verarbeitet Dateien mit Lisp-Code oder Maxima-Code.
     Dateien, die mit den Funktionen `save',  `translate_file'  und
     `compile_file'  erstellt wurden, enthalten Lisp-Code.  Dateien,
     die mit `stringout'  erstellt wurden, enthalten Maxima-Code.  Die
     Ausgabedateien dieser Funktionen können mit `load' geladen werden.
     `load' ruft die Funktion `loadfile'  auf, um Lisp-Dateien und
     `batchload'  auf, um Maxima-Dateien zu verarbeiten.

     `load' erkennt keine `:lisp'-Unterbrechungskommandos in
     Maxima-Dateien.  Die Systemvariablen `_',  `__'  und `%'  und die
     Funktion `%th'  behalten jeweils ihren letzten Wert vor dem Aufruf
     von `load'.

     Siehe auch die Funktionen `loadfile',  `batch',

     `batchload'  und `demo'.    `loadfile' verarbeitet Lisp-Dateien.
     `batch', `batchload' und `demo' verarbeiten Maxima-Dateien.

     Siehe `file_search'  für mehr Informationen, wie Maxima Dateien in
     Verzeichnissen findet.  `load' wertet die Argumente aus.

 -- Systemvariable: load_pathname
     Standardwert: `false'

     Wird eine Datei mit den Funktionen `load',  `loadfile'  oder
     `batchload'  geladen, enthält die Systemvariable `load_pathname'
     den Namen der Datei.  Der Wert der Systemvariablen kann in der
     Datei, die geladen wird, ausgelesen werden.

     Beispiele:

     Ist eine Batch-Datei mit den Namen `test.mac' in dem Verzeichnis
          "/home/dieter/workspace/mymaxima/temp/"
     abgelegt und enthält die Datei die folgenden Befehle

          print("The value of load_pathname is: ", load_pathname)$
          print("End of batchfile")$

     dann wird das Folgende ausgegeben:

          (%i1) load("/home/dieter/workspace/mymaxima/temp/test.mac")$
          The value of load_pathname is:
                        /home/dieter/workspace/mymaxima/temp/test.mac
          End of batchfile

 -- Funktion: loadfile (<filename>)
     Lädt die Datei <filename> und wertet die Lisp-Ausdrücke in der
     Datei aus.  `filename' ruft nicht `file_search'  auf, um eine
     Datei zu finden.  Daher muss `filename' ein vollständiger
     Dateiname sein.

     `loadfile' kann Dateien verarbeiten, die mit den Funktionen `save',
     `translate_file'  und `compile_file'  erzeugt wurden.

 -- Optionsvariable: loadprint
     Standardwert: `true'

     `loadprint' kontrolliert, ob Meldungen ausgegeben werden, wenn
     eine Datei geladen wird.

        * Hat `loadprint' den Wert `true', wird immer eine Meldung
          ausgegeben.

        * Hat `loadprint' den Wert `'loadfile', wird eine Meldung
          ausgegeben, wenn die Datei mit der Funktion `loadfile'
          geladen wird.

        * Hat `loadprint' den Wert `'autoload', wird eine Meldung
          ausgegeben, wenn eine Datei automatisch geladen wird.

        * Hat `loadprint' den Wert `false', werden keine Meldungen beim
               Laden von Dateien ausgegeben.

 -- Funktion: pathname_directory (<pathname>)
 -- Funktion: pathname_name (<pathname>)
 -- Funktion: pathname_type (<pathname>)
     Diese Funktionen geben die Bestandteile eines Pfadnamens zurück.

     Beispiele:

          (%i1) pathname_directory("/home/dieter/maxima/changelog.txt");
          (%o1)                 /home/dieter/maxima/
          (%i2) pathname_name("/home/dieter/maxima/changelog.txt");
          (%o2)                       changelog
          (%i3) pathname_type("/home/dieter/maxima/changelog.txt");
          (%o3)                          txt

 -- Funktion: printfile (<path>)
     Druckt eine Datei mit dem Namen <path> auf der Konsole aus.
     <path> kann ein Symbol oder eine Zeichenkette sein.  `printfile'
     sucht die Datei in den Verzeichnissen, die in der Optionsvariablen
     `file_search_usage'  enthalten sind.

     `printfile' gibt <path> zurück, wenn die Datei existiert.

 -- Funktion: save (<filename>, <name_1>, <name_2>, <name_3>, ...)
 -- Funktion: save (<filename>, values, functions, labels, ...)
 -- Funktion: save (<filename>, [<m>, <n>])
 -- Funktion: save (<filename>, <name_1>=<expr_1>, ...)
 -- Funktion: save (<filename>, all)
 -- Funktion: save (<filename>, <name_1>=<expr_1>, <name_2>=<expr_2>,
          ...)
     Speichert die aktuellen Werte von <name_1>, <name_2>, <name_3>,
     ..., in die Datei <filename>.  Die Argumente sind die Namen von
     Variablen, Funktionen oder anderen Objekten.  Argumente, die
     keinen Wert haben, werden ignoriert.  `save' gibt den Namen der
     Datei `filename' zurück.

     `save' speichert die Daten in einem Lisp-Format.  Die
     gespeicherten Daten können mit dem Kommando `load(<filename>)'
     zurückgelesen werden.  Siehe `load'.

     Die Optionsvariable `file_output_append'  kontrolliert, ob `save'
     die Daten an die Ausgabedatei anhängt, wenn diese bereits
     existiert, oder die Ausgabedatei zuvor löscht.  Hat
     `file_output_append' den Wert `true', werden die Daten angehängt.
     Ansonsten wird die Datei gelöscht und neu angelegt, wenn diese
     bereits existiert.  Existiert die Ausgabedatei noch nicht, wird
     diese angelegt.

     `save(<filename>, values, functions, labels, ...)' speichert die
     Werte aller Einträge der Listen `values', `functions', `labels',
     u.s.w. in die Ausgabedatei.  Es kann jede der vorhandenen
     Informationslisten, die in der Systemvariablen `infolists'
     enthalten ist, als Argument übergeben werden.  `values' enthält
     zum Beispiel alle vom Nutzer definierten Variablen.

     `save(<filename>, [<m>, <n>])' speichert die Werte der Eingabe-
     und Ausgabemarken von <m> bis <n>.  <m> und <n> müssen ganze
     Zahlen sein.  Die Eingabe- und Ausgabemarken können auch einzeln
     gespeichert werden, zum Beispiel mit dem Kommando `save("foo.1",
     %i42, %o42)'.  `save(<filename>, labels)' speichert alle Eingabe-
     und Ausgabemarken.  Beim Zurücklesen der Marken werden vorhandene
     Werte überschrieben.

     `save(<filename>, <name_1> = <expr_1>, <name_2> = <expr_2>, ...)'
     speichert die Werte <expr_1>, <expr_2>, ..., unter den Namen
     <name_1>, <name_2>, ... ab.  Dies kann  nützlich sein, um zum
     Beispiel die Werte von Marken unter einem neuen Namen
     abzuspeichern.  Die rechte Seite der Gleichungen kann ein
     beliebiger ausgewerteter Ausdruck sein.  Die neuen Namen werden
     der aktuellen Sitzung nicht hinzugefügt und nur in der
     Ausgabedatei gespeichert.

     Die verschiedenen Möglichkeiten der Funktion `save', können
     miteinander kombiniert werden.  Das Kommando `save(<filename>, aa,
     bb, cc=42, functions, [11,17])' ist dafür ein Beispiel.

     `save(<filename>, all)' speichert den aktuellen Zustand von Maxima
     in eine Ausgabedatei.  Eingeschlossen sind alle nutzerdefinierten
     Variablen, Funktionen oder Arrays, einschließlich automatischer
     Definitionen.  Die gespeicherten Daten enthalten auch die Werte
     von geänderten System- oder Optionsvariablen.  Siehe dazu auch
     `myoptions'.

     `save' wertet das Argument <filename> aus.  Alle anderen Argumente
     werden nicht ausgewertet.

 -- Funktion: stringout (<filename>, <expr_1>, <expr_2>, <expr_3>, ...)
 -- Funktion: stringout (<filename>, [<m>, <n>])
 -- Funktion: stringout (<filename>, input)
 -- Funktion: stringout (<filename>, functions)
 -- Funktion: stringout (<filename>, values)
     `stringout' schreibt Ausdrücke in einem Format in eine Datei, dass
     identisch mit dem Format der Eingabe ist.  Die Datei kann als
     Eingabedatei für die Funktionen `batch'  oder `demo'  genutzt
     werden.  Sie kann mit einem Texteditor für jeden Zweck editiert
     werden.  `stringout' kann ausgeführt werden, wenn das Kommando
     `writefile'  aktiv ist.

     Die Optionsvariable `file_output_append'  kontrolliert, ob
     `stringout' die Daten an die Ausgabedatei anhängt, wenn diese
     bereits existiert oder die Ausgabedatei zuvor löscht.  Hat
     `file_output_append' den Wert `true', werden die Daten angehängt,
     wenn die Datei bereits existiert.  Ansonsten wird die Datei
     gelöscht und neu angelegt.  Existiert die Ausgabedatei noch nicht,
     wird diese angelegt.

     Die allgemeine Form von `stringout' schreibt die Werte eines oder
     mehrerer Ausdrücke in die Ausgabedatei.  Ist ein Ausdruck eine
     Variable, wird nur der Wert der Variablen, nicht jedoch der Name
     der Variablen in die Ausgabedatei geschrieben.  Ein nützlicher
     Spezialfall ist, dass die Werte der Eingabe- und Ausgabemarken
     (`%i1', `%i2', `%i3', ... und `%o1', `%o2', `%o3', ...) in die
     Datei geschrieben werden können.

     Hat die Optionsvariable `grind' den Wert `true', wird die Ausgabe
     im Format der Funktion `grind'  in die Ausgabedatei geschrieben.
     Ansonsten wird das Format der Funktion `string'  für die Ausgabe
     genutzt.

     `stringout(<filename>, [<m>, <n>])' schreibt die Werte aller
     Eingabemarken von <m> bis <n> in die Ausgabedatei.
     `stringout(<filename>, input)' schreibt alle Eingabemarken in die
     Ausgabedatei.  `stringout(<filename>, functions)' schreibt alle vom
     Nutzer definierten Funktionen, die in der Informationsliste
     `functions' enthalten sind, in die Ausgabedatei.

     `stringout(<filename>, values)' schreibt alle benuzterdefinierten
     Variablen, die in der Informationsliste `values' enthalten sind,
     in die Ausgabedatei.  Die Variablen werden als eine Zuweisung, mit
     dem Namen der Variablen, dem Zuweisungsoperator `:' und dem Wert
     in die Datei geschrieben.  Im Unterschied dazu, speichert die
     allgemeine Form der Funktion `stringout' die Variablen nicht als
     Zuweisung.

 -- Funktion: with_stdout (<f>, <expr_1>, <expr_2>, <expr_3>, ...)
 -- Funktion: with_stdout (<s>, <expr_1>, <expr_2>, <expr_3>, ...)
     `with_stdout' wertet Argumente <expr_1>, <expr_2>, <expr_3>, ...
     aus und schreibt die Ergebnisse der Auswertung in die Ausgabedatei
     `f' oder in den Stream `s'.  Die Ergebnisse werden nicht auf der
     Konsole ausgegeben.

     Die Optionsvariable `file_output_append' bestimmt, ob `with_stdout'
     die Daten an die Ausgabedatei anhängt oder die Ausgabedatei zuvor
     löscht.  Hat `file_output_append' den Wert `true', werden die Daten
     angehängt.  Ansonsten wird die Datei gelöscht und neu angelegt.
     Existiert die Ausgabedatei noch nicht, wird diese angelegt.

     `with_stout' gibt das Ergebnis des letzten Argumentes zurück.

     Siehe auch `writefile'.

     Beispiel:

          (%i1) with_stdout ("tmp.out", for i:5 thru 10 do
                   print (i, "! yields", i!))$
          (%i2) printfile ("tmp.out")$
          5 ! yields 120
          6 ! yields 720
          7 ! yields 5040
          8 ! yields 40320
          9 ! yields 362880
          10 ! yields 3628800

 -- Funktion: writefile (<filename>)
     Startet eine Aufzeichnung aller Ein- und Ausgaben der Konsole.
     Die Ein- und Ausgaben werden in die Datei <filename> geschrieben.

     Die Ausgabedatei kann von Maxima nicht wieder zurückgelesen
     werden.  Um ein Datei zu erzeugen, die von Maxima zurückgelesen
     werden kann, siehe die Funktionen `save'  und `stringout'.
     `save' speichert Ausdrücke in einem Lisp-Format und `stringout' in
     einem Maxima-Format.

     Die Reaktion der Funktion `writefile' für den Fall, dass die
     Ausgabedatei bereits existiert, hängt von der Lisp-Implementation
     ab.  Die Ausgabedatei kann zurückgesetzt werden oder die Daten
     werden angehängt.  Die Funktion `appendfile'  hängt die Daten
     immer an eine existierende Datei an.

     Um eine Aufzeichnung ohne Textausgaben von Funktionen zu erhalten,
     kann `writefile' nach der Ausführung von `playback' ausgeführt
     werden.  `playback' gibt alle vorhergenden Eingabe- und
     Ausgabemarken aus, jedoch nicht sonstige Textausgaben von
     Maxima-Funktionen.

     Mit `closefile'  wird die Aufzeichnung beendet.



Local Variables:
coding: iso-8859-1
End:
