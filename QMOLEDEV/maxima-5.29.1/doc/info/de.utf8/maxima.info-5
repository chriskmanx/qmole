This is maxima.info, produced by makeinfo version 4.13 from
/home/robert/maxima/maxima-git/maxima-code/doc/info/de.utf8//include-maxima.de.texi.

Das ist ein Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Ein Computer Algebra System.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Exponentielle Integrale,  Next: Fehlerfunktionen,  Prev: Gammafunktionen und verwandte Funktionen,  Up: Spezielle Funktionen

22.4 Exponentielle Integrale
============================

Die Exponentiellen Integrale und verwandte Funktionen sind definiert in
Abramowitz und Stegun, Handbook of Mathematical Functions, Kapitel 5.

 -- Funktion: expintegral_e1 (<z>)
     Das Exponentielle Integral `E1(z)' (A&S 5.1.1).

 -- Funktion: expintegral_ei (<z>)
     Das Exponentielle Integral `Ei(z)' (A&S 5.1.2).

 -- Funktion: expintegral_li (<n>,<z>)
     Das Exponentielle Integral `Li(z)' (A&S 5.1.3).

 -- Funktion: expintegral_e (<n>, <z>)
     Das Exponentielle Integral `E[n](z)' (A&S 5.1.4).

 -- Funktion: expintegral_si (<z>)
     Das Exponentielle Integral `Si(z)' (A&S 5.2.1).

 -- Funktion: expintegral_ci (<z>)
     Das Exponentielle Integral `Ci(z)' (A&S 5.2.2).

 -- Funktion: expintegral_shi (<z>)
     Das Exponentielle Integral `Shi(z)' (A&S 5.2.3).

 -- Funktion: expintegral_chi (<z>)
     Das Exponentielle Integral `Chi(z)' (A&S 5.2.4).

 -- Optionsvariable: expintrep
     Standardwert: `false'

     Wechselt die Darstellung eines Exponentiellen Integrals in eine
     der anderen Funktionen `gamma_incomplete',  `expintegral_e1',

     `expintegral_ei',  `expintegral_li',

     `expintegral_si',  `expintegral_ci',

     `expintegral_shi',  oder `expintegral_chi'.


 -- Optionsvariable: expintexpand
     Standardwert: `false'

     Expandiert das Exponentielle Integral `E[n](z)' für halbzahlige,
     gerade Ordnung <n> nach den Funktionen `erfc'  und `erf'.   sowie
     für positive ganze Zahlen nach der Funktion `expintegral_ei'.



File: maxima.info,  Node: Fehlerfunktionen,  Next: Elliptische Funktionen und Integrale,  Prev: Exponentielle Integrale,  Up: Spezielle Funktionen

22.5 Fehlerfunktionen
=====================

Die Fehlerfunktion und verwandte Funktionen sind definiert in Abramowitz
und Stegun, Handbook of Mathematical Functions, Kapitel 7.

 -- Funktion: erf (<z>)
     Die Fehlerfunktion `erf(z)' (A&S 7.1.1).

     Siehe auch die Optionsvariable `erfflag'.


 -- Function: erfc (<z>)
     Die komplementäre Fehlerfunktion `erfc(z) = 1 - erf(z)' (A & S
     7.1.2).

 -- Funktion: erfi (<z>)
     Die imaginäre Fehlerfunktion `erfi(z) = -%i*erf(%i*z)'.

 -- Funktion: erf_generalized (<z1>, <z2>)
     Die verallgemeinerte Fehlerfunktion Erf(z1, z2).

 -- Funktion: fresnel_c (<z>)
     Das Fresnel-Integral, das definiert ist als (A & S 7.3.1):

                     z
                    /           2
                    [      %pi t
             C(z) = I  cos(------) dt
                    ]        2
                    /
                     0

     Hat die Optionsvariable `trigsign'  den Wert `true', vereinfacht
     Maxima `fresnel_c(-x)' zu `-fresnel_c(x)'.

     Hat die Optionsvariable `%iargs'  den Wert `true', vereinfacht
     Maxima `fresnel_c(%i*x)' zu `%i*fresnel_c(x)'.

     Siehe auch die Optionsvariable `hypergeometric_representation',  um
     die Fresnelfunktion in eine hypergeometrische Darstellung zu
     transformieren, und die Optionsvariable `erf_representation'  für
     eine Darstellung als Fehlerfunktion.

 -- Funktion: fresnel_s (<z>)
     Das Fresnel-Integral, das definiert ist als (A & S 7.3.2):

                     z
                    /           2
                    [      %pi t
             S(z) = I  sin(------) dt
                    ]        2
                    /
                     0

     Hat die Optionsvariable `trigsign'  den Wert `true', vereinfacht
     Maxima `fresnel_s(-x)' zu `-fresnel_s(x)'.

     Hat die Optionsvariable `%iargs'  den Wert `true', vereinfacht
     Maxima `fresnel_s(%i*x)' zu `%i*fresnel_s(x)'.

     Siehe auch die Optionsvariable `hypergeometric_representation',  um
     die Fresnelfunktion in eine hypergeometrische Darstellung zu
     transformieren, und die Optionsvariable `erf_representation'  für
     eine Darstellung als Fehlerfunktion.

 -- Optionsvariable: erf_representation
     Standarwert: `false'

     Hat die Optionsvariable `erf_representation' den Wert `true',
     werden die Funktionen `erfc',  `erfi',

     `erf_generalized',  `fresnel_s'  und `fresnel_c'  in eine
     Darstellung mit der Funktion `erf'  transformiert.

 -- Optionsvariable: hypergeometric_representation
     Standardwert: `false'

     Hat die Optionsvariable `hypergeometric_representation' den Wert
     `true', werden die Funktionen `fresnel_s'  und `fresnel_c'  in
     eine hypergeometrische Funktion transformiert.


File: maxima.info,  Node: Elliptische Funktionen und Integrale,  Next: Hypergeometrische Funktionen,  Prev: Fehlerfunktionen,  Up: Spezielle Funktionen

22.6 Elliptische Funktionen und Integrale
=========================================

* Menu:

* Einführung in Elliptische Funktionen und Integrale::
* Funktionen und Variablen für Elliptische Funktionen::
* Funktionen und Variablen für Elliptische Integrale::


File: maxima.info,  Node: Einführung in Elliptische Funktionen und Integrale,  Next: Funktionen und Variablen für Elliptische Funktionen,  Prev: Elliptische Funktionen und Integrale,  Up: Elliptische Funktionen und Integrale

22.6.1 Einführung in Elliptische Funktionen und Integrale
---------------------------------------------------------

Maxima unterstützt die Jacobischen elliptische Funktionen sowie die
vollständigen und unvollständigen elliptischen Integrale.  Die
Funktionen sind für das symbolische und numerische Rechnen geeignet.
Die Definition der Funktionen und viele ihrer Eigenschaften sind in
Abramowitz and Stegun, Kapitel 16 und 17 enthalten.  Die dort
beschriebenen Definitionen und Beziehungen werden so weit als möglich
verwendet.

Im besonderen nutzen alle elliptischen Funktionen und Integrale den
Parameter m anstatt den Modulus k oder den modularen Winkel \alpha.
Dies ist ein Unterschied zu der Definition von Abramowitz und Stegun.
Es gelten die folgenden Beziehungen: m = k^2 und k = \sin(\alpha)

Die elliptischen Funktionen und Integrale sind zuallererst für das
symbolische Rechnen gedacht.  Daher sind die Ableitungen und Integrale
der Funktionen im wesentlichen in Maxima bekannt.  Maxima unterstützt
jedoch auch die numerische Berechnung, wenn die Argumente
Gleitkommazahlen sind.

Viele bekannte Eigenschaften der Elliptischen Funktionen und Integrale
sind noch nicht in Maxima implementiert.

Einige Beispiele für elliptische Funktionen.

     (%i1) jacobi_sn (u, m);
     (%o1)                    jacobi_sn(u, m)
     (%i2) jacobi_sn (u, 1);
     (%o2)                        tanh(u)
     (%i3) jacobi_sn (u, 0);
     (%o3)                        sin(u)
     (%i4) diff (jacobi_sn (u, m), u);
     (%o4)            jacobi_cn(u, m) jacobi_dn(u, m)
     (%i5) diff (jacobi_sn (u, m), m);
     (%o5) jacobi_cn(u, m) jacobi_dn(u, m)

           elliptic_e(asin(jacobi_sn(u, m)), m)
      (u - ------------------------------------)/(2 m)
                          1 - m

                 2
        jacobi_cn (u, m) jacobi_sn(u, m)
      + --------------------------------
                   2 (1 - m)

Einige Beispiele für elliptische Integrale.

     (%i1) elliptic_f (phi, m);
     (%o1)                  elliptic_f(phi, m)
     (%i2) elliptic_f (phi, 0);
     (%o2)                          phi
     (%i3) elliptic_f (phi, 1);
                                    phi   %pi
     (%o3)                  log(tan(--- + ---))
                                     2     4
     (%i4) elliptic_e (phi, 1);
     (%o4)                       sin(phi)
     (%i5) elliptic_e (phi, 0);
     (%o5)                          phi
     (%i6) elliptic_kc (1/2);
                                          1
     (%o6)                    elliptic_kc(-)
                                          2
     (%i7) makegamma (%);
                                      2 1
                                 gamma (-)
                                        4
     (%o7)                      -----------
                                4 sqrt(%pi)
     (%i8) diff (elliptic_f (phi, m), phi);
                                     1
     (%o8)                 ---------------------
                                         2
                           sqrt(1 - m sin (phi))
     (%i9) diff (elliptic_f (phi, m), m);
            elliptic_e(phi, m) - (1 - m) elliptic_f(phi, m)
     (%o9) (-----------------------------------------------
                                   m

                                      cos(phi) sin(phi)
                                  - ---------------------)/(2 (1 - m))
                                                  2
                                    sqrt(1 - m sin (phi))

Die Implementierung der elliptischen Funktionen und Integrale wurde von
Raymond Toy geschrieben.  Der Code steht wie Maxima unter der General
Public License (GPL).


File: maxima.info,  Node: Funktionen und Variablen für Elliptische Funktionen,  Next: Funktionen und Variablen für Elliptische Integrale,  Prev: Einführung in Elliptische Funktionen und Integrale,  Up: Elliptische Funktionen und Integrale

22.6.2 Funktionen und Variablen für Elliptische Funktionen
----------------------------------------------------------

 -- Funktion: jacobi_sn (<u>, <m>)
     Die Jacobische elliptische Funktion sn(u,m).

 -- Funktion: jacobi_cn (<u>, <m>)
     Die Jacobische elliptische Funktion cn(u,m).

 -- Funktion: jacobi_dn (<u>, <m>)
     Die Jacobische elliptische Funktion dn(u,m).

 -- Funktion: jacobi_ns (<u>, <m>)
     Die Jacobische elliptische Funktion ns(u,m) = 1/sn(u,m).

 -- Funktion: jacobi_sc (<u>, <m>)
     Die Jacobische elliptische Funktion sc(u,m) = sn(u,m)/cn(u,m).

 -- Funktion: jacobi_sd (<u>, <m>)
     Die Jacobische elliptische Funktion sd(u,m) = sn(u,m)/dn(u,m).

 -- Funktion: jacobi_nc (<u>, <m>)
     Die Jacobische elliptische Funktion nc(u,m) = 1/cn(u,m).

 -- Funktion: jacobi_cs (<u>, <m>)
     Die Jacobische elliptische Funktion cs(u,m) = cn(u,m)/sn(u,m).

 -- Funktion: jacobi_cd (<u>, <m>)
     Die Jacobische elliptische Funktion cd(u,m) = cn(u,m)/dn(u,m).

 -- Funktion: jacobi_nd (<u>, <m>)
     Die Jacobische elliptische Funktion nc(u,m) = 1/cn(u,m).

 -- Funktion: jacobi_ds (<u>, <m>)
     Die Jacobische elliptische Funktion ds(u,m) = dn(u,m)/sn(u,m).

 -- Funktion: jacobi_dc (<u>, <m>)
     Die Jacobische elliptische Funktion dc(u,m) = dn(u,m)/cn(u,m).

 -- Funktion: inverse_jacobi_sn (<u>, <m>)
     Die inverse Jacobische elliptische Funktion sn(u,m).

 -- Funktion: inverse_jacobi_cn (<u>, <m>)
     Die inverse Jacobische elliptische Funktion cn(u,m).

 -- Funktion: inverse_jacobi_dn (<u>, <m>)
     Die inverse Jacobische elliptische Funktion dn(u,m).

 -- Funktion: inverse_jacobi_ns (<u>, <m>)
     Die inverse Jacobische elliptische Funktion ns(u,m).

 -- Funktion: inverse_jacobi_sc (<u>, <m>)
     Die inverse Jacobische elliptische Funktion sc(u,m).

 -- Funktion: inverse_jacobi_sd (<u>, <m>)
     Die inverse Jacobische elliptische Funktion sd(u,m).

 -- Funktion: inverse_jacobi_nc (<u>, <m>)
     Die inverse Jacobische elliptische Funktion nc(u,m).

 -- Funktion: inverse_jacobi_cs (<u>, <m>)
     Die inverse Jacobische elliptische Funktion cs(u,m).

 -- Funktion: inverse_jacobi_cd (<u>, <m>)
     Die inverse Jacobische elliptische Funktion cd(u,m).

 -- Funktion: inverse_jacobi_nd (<u>, <m>)
     Die inverse Jacobische elliptische Funktion nc(u,m).

 -- Funktion: inverse_jacobi_ds (<u>, <m>)
     Die inverse Jacobische elliptische Funktion ds(u,m).

 -- Funktion: inverse_jacobi_dc (<u>, <m>)
     Die inverse Jacobische elliptische Funktion dc(u,m).


File: maxima.info,  Node: Funktionen und Variablen für Elliptische Integrale,  Prev: Funktionen und Variablen für Elliptische Funktionen,  Up: Elliptische Funktionen und Integrale

22.6.3 Funktionen und Variablen für Elliptische Integrale
---------------------------------------------------------

 -- Funktion: elliptic_f (<phi>, <m>)
     Das unvollständige elliptische Integral der ersten Art, das
     definiert ist als

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, phi)

     Siehe auch `elliptic_e'  und `elliptic_kc'.


 -- Funktion: elliptic_e (<phi>, <m>)
     Das unvollständige elliptische Integral der zweiten Art, das
     definiert ist als

     elliptic_e(phi, m) = integrate(sqrt(1 - m*sin(x)^2), x, 0, phi)

     Siehe auch `elliptic_e'  und `elliptic_ec'.


 -- Funktion: elliptic_eu (<u>, <m>)
     Das unvollständige elliptische Integral der zweiten Art, das
     definiert ist als

     integrate(dn(v,m)^2,v,0,u) = integrate(sqrt(1-m*t^2)/sqrt(1-t^2),
     t, 0, tau)

     mit tau = sn(u,m).

     Dieses Integral steht in Beziehung zum elliptischen Integral
     `elliptiec_e'

     elliptic_eu(u, m) = elliptic_e(asin(sn(u,m)),m)

     Siehe auch `elliptic_e'.


 -- Funktion: elliptic_pi (<n>, <phi>, <m>)
     Das unvollständige elliptische Integral der dritten Art, das
     definiert ist als

     integrate(1/(1-n*sin(x)^2)/sqrt(1 - m*sin(x)^2), x, 0, phi)

     Maxima kennt nur die Ableitung nach der Variablen <phi>.

 -- Funktion: elliptic_kc (<m>)
     Das vollständige elliptische Integral der ersten Art, das
     definiert ist als

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     Für einige spezielle Argumente <m> kennt Maxima Werte mit der
     Gammafunktion `gamma'.    Die Werte können mit der Funktion
     `makegamma'  berechnet werden.

 -- Funktion: elliptic_ec (<m>)
     Das vollständige elliptische Integral der zweiten Art, das
     definiert ist als

     integrate(sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     Für einige spezielle Argumente <m> kennt Maxima Werte mit der
     Gammafunktion `gamma'.    Die Werte können mit der Funktion
     `makegamma'  berechnet werden.


File: maxima.info,  Node: Hypergeometrische Funktionen,  Next: Weitere spezielle Funktionen,  Prev: Elliptische Funktionen und Integrale,  Up: Spezielle Funktionen

22.7 Hypergeometrische Funktionen
=================================

 -- Funktion: %m [<k>, <u>] (<z>)
     Ist die Whittaker M Funktion `M[k,u](z) = exp(-z/2) * z^(1/2+u) *
     M(1/2+u-k, 1+2*u, z)'.  Siehe A & S 13.1.32 für die Definition.

 -- Funktion: %w [<k>, <u>] (<z>)
     Ist die Whittaker W Funktion.  Siehe A & S 13.1.33 für die
     Definition.

 -- Funktion: %f [<p>,<q>] (<[a], [b], z>)
     Ist die hypergeometrische Funktion `F[p,q](a_1, ..., a_p; b_1,...,
     b_q; z)'.  Das Argument <a> ist eine Liste mit den <p>-Elementen
     <a_i> und das Argument <b> die Liste mit den <q>-Elementen <b_i>.

 -- Funktion: hypergeometric ([<a_1>, ..., <a_p>], [<b_1>, ... ,<b_q>],
          z)
     Ist die hypergeometrische Funktion.  Im Unterschied zu den
     Funktionen `%f'  und `hgfred',  ist die Funktion `hypergeometric'
     eine vereinfachende Funktion.  `hypergeometric' unterstützt die
     Berechnung von numerischen Werten für reelle und komplexe
     Gleitkommazahlen in doppelter und mit beliebiger Genauigkeit.  Für
     die Gaußsche hypergeometrische Funktion ist p = 2 und q = 1.  In
     diesem Fall wird auch die numerische Berechnung außerhalb des
     Einheitskreises unterstützt.

     Hat die Optionsvariable `expand_hypergeometric' den Wert `true',
     das ist der Standardwert, und eines der Argumente `a_1', ..., `a_p'
     ist eine negative ganze Zahl, gibt `hypergeometric' ein Polynom
     zurück.

     Beispiel:

           (%i1)  hypergeometric([],[],x);
           (%o1) %e^x

     Expansion in ein Polynom für eine negative ganze Zahl, wenn die
     Optionsvariable `expand_hypergeometric' den Wert `true' hat.

           (%i2) hypergeometric([-3],[7],x);
           (%o2) hypergeometric([-3],[7],x)

           (%i3) hypergeometric([-3],[7],x), expand_hypergeometric : true;
           (%o3) -x^3/504+3*x^2/56-3*x/7+1

     Numerische Berechnung in doppelter und beliebiger
     Gleitkommagenauigkeit.

          (%i4) hypergeometric([5.1],[7.1 + %i],0.42);
          (%o4)       1.346250786375334 - 0.0559061414208204 %i
          (%i5) hypergeometric([5,6],[8], 5.7 - %i);
          (%o5)     .007375824009774946 - .001049813688578674 %i
          (%i6) hypergeometric([5,6],[8], 5.7b0 - %i), fpprec : 30;
          (%o6) 7.37582400977494674506442010824b-3
                                    - 1.04981368857867315858055393376b-3 %i

 -- Funktion: parabolic_cylinder_d (<v>, <z>)
     Die parabolische Zylinderfunktion `parabolic_cylinder_d(v,z)'.

     Die parabolischen Zylinderfunktionen sind in Abramowitz and Stegun,
     Handbook of Mathematical Functions, Kapitel 19 definiert.

     Die parabolischen Zylinderfunktionen können als Ergebnis der
     Funktion `hgfred'  auftreten.  Maxima kennt keine weiteren
     Eigenschaften.


File: maxima.info,  Node: Weitere spezielle Funktionen,  Prev: Hypergeometrische Funktionen,  Up: Spezielle Funktionen

22.8 Weitere spezielle Funktionen
=================================

 -- Funktion: li [<s>] (<z>)
     Ist der Polylogarithmus der Ordnung <s> mit dem Argument <z>.  Der
     Polylogarithmus wird durch die folgende Reihe definiert werden:

                                           inf
                                           ====   k
                                           \     z
                                  Li (z) =  >    --
                                    s      /      s
                                           ====  k
                                           k = 1

     Für <s=1> geht der Polylogarithmus in die gewöhnliche
     Logarithmusfunktion über und man erhält `-log(1-z)'.  Für <s=2>
     oder <s=3> spricht man vom Dilogarithmus oder Trilogarithmus.

     Maxima vereinfacht für <s=1> sofort zum gewöhnlichen Logarithmus.
     Für negative ganze Zahlen <s> einschließlich der Null vereinfacht
     Maxima den Polylogarithmus zu einer rationalen Funktion.

     Ist <s=2> oder <s=3> und das Argument <z> eine Gleitkommazahl,
     vereinfacht Maxima den Di- oder Trilogarithmus zu einer
     Gleitkommazahl.

     Beispiele:

          (%i1) assume (x > 0);
          (%o1)                        [x > 0]
          (%i2) integrate ((log (1 - t)) / t, t, 0, x);
          (%o2)                       - li (x)
                                          2
          (%i3) li [2] (7);
          (%o3)                        li (7)
                                         2
          (%i4) li [2] (7), numer;
          (%o4)        1.24827317833392 - 6.113257021832577 %i
          (%i5) li [3] (7);
          (%o5)                        li (7)
                                         3
          (%i6) li [2] (7), numer;
          (%o6)        1.24827317833392 - 6.113257021832577 %i
          (%i7) L : makelist (i / 4.0, i, 0, 8);
          (%o7)   [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0]
          (%i8) map (lambda ([x], li [2] (x)), L);
          (%o8) [0, .2676526384986274, .5822405249432515,
          .9784693966661848, 1.64493407, 2.190177004178597
           - .7010261407036192 %i, 2.374395264042415
           - 1.273806203464065 %i, 2.448686757245154
           - 1.758084846201883 %i, 2.467401098097648
           - 2.177586087815347 %i]
          (%i9) map (lambda ([x], li [3] (x)), L);
          (%o9) [0, .2584613953442624, 0.537213192678042,
          .8444258046482203, 1.2020569, 1.642866878950322
           - .07821473130035025 %i, 2.060877505514697
           - .2582419849982037 %i, 2.433418896388322
           - .4919260182322965 %i, 2.762071904015935
           - .7546938285978846 %i]

 -- Funktion: specint (exp(- s*<t>) * <expr>, <t>)
     Berechnet die Laplace-Transformation des Ausdrucks <expr> für die
     Integrationsvariable <t>.  <s> ist der Parameter der
     Laplace-Transformation.  Der Integrand <expr> kann spezielle
     Funktionen der Mathematik enthalten.

     Die folgenden speziellen Funktionen können als Integrand
     auftreten: die unvollständige Gammafunkion `gamma_incomplete',  die
     Fehlerfunktionen `erf'  und `erfc',  nicht jedoch die Funktion
     `erfi',  die jedoch in eine andere Fehlerfunktion transformiert
     werden kann, die Exponentiellen Integrale wie zum Beispiel
     `expintegral_e1',

     die Bessel-Funktionen wie zum Beispiel `bessel_j',  einschließlich
     der Produkte von Bessel-Funktionen, Hankel-Funktionen wie zum
     Beispiel `hankel_1',  Hermite `hermite'  und Laguerre Polynome
     `laguerre'.    Weiterhin kann `specint' Integranden mit der
     Hypergeometrische Funktion `%f[p,q]([],[],z)', die Whittaker
     Funktion der ersten Art `%m[u,k](z)' und die der zweiten Art
     `%w[u,k](z)' integrieren.

     Das Ergebnis kann spezielle Funktionen und die Hypergeometrische
     Funktion enthalten.

     Kann die Funktion `laplace'  keine Laplace-Transformation finden,
     wird `specint' aufgerufen.  Da die Funktion `laplace' einige
     allgemeine Regeln kennt, um die Laplace-Transformation zu finden,
     ist es von Vorteil die Laplace-Transformation mit der Funktion
     `laplace' zu berechnen.

     `demo(hypgeo)' zeigt einige Beispiele für Laplace-Transformationen
     mit der Funktion `specint'.

     Beispiele:

          (%i1) assume (p > 0, a > 0)$
          (%i2) specint (t^(1/2) * exp(-a*t/4) * exp(-p*t), t);
                                     sqrt(%pi)
          (%o2)                     ------------
                                           a 3/2
                                    2 (p + -)
                                           4
          (%i3) specint (t^(1/2) * bessel_j(1, 2 * a^(1/2) * t^(1/2))
                        * exp(-p*t), t);
                                             - a/p
                                   sqrt(a) %e
          (%o3)                    ---------------
                                          2
                                         p

     Beispiel mit Exponentiellen Integralen.

          (%i4) assume(s>0,a>0,s-a>0)$
          (%i5) ratsimp(specint(%e^(a*t)
                                *(log(a)+expintegral_e1(a*t))*%e^(-s*t),t));
                                       log(s)
          (%o5)                        ------
                                       s - a
          (%i6) logarc:true$
          (%i7) gamma_expand:true$

          radcan(specint((cos(t)*expintegral_si(t)
                               -sin(t)*expintegral_ci(t))*%e^(-s*t),t));
                                       log(s)
          (%o8)                        ------
                                        2
                                       s  + 1
          ratsimp(specint((2*t*log(a)+2/a*sin(a*t)
                                -2*t*expintegral_ci(a*t))*%e^(-s*t),t));
                                         2    2
                                    log(s  + a )
          (%o9)                     ------------
                                          2
                                         s

     Entwicklung der unvollständigen Gammafunktion und Wechsel in eine
     Darstellung mit dem Exponentiellen Integral `expintegral_e1'.

          (%i10) assume(s>0)$
          (%i11) specint(1/sqrt(%pi*t)*unit_step(t-k)*%e^(-s*t),t);
                                                      1
                                      gamma_incomplete(-, k s)
                                                      2
          (%o11)                      ------------------------
                                         sqrt(%pi) sqrt(s)

          (%i12) gamma_expand:true$
          (%i13) specint(1/sqrt(%pi*t)*unit_step(t-k)*%e^(-s*t),t);
                                        erfc(sqrt(k) sqrt(s))
          (%o13)                        ---------------------
                                               sqrt(s)

          (%i14) expintrep:expintegral_e1$
          (%i15) ratsimp(specint(1/(t+a)^2*%e^(-s*t),t));
                                        a s
                                  a s %e    expintegral_e1(a s) - 1
          (%o15)                - ---------------------------------
                                                  a

 -- Funktion: hgfred (<a>, <b>, <z>)
     Vereinfacht die Hypergeometrische Funktion zu einfacheren
     Funktionen, wie Polynome und spezielle Funktionen.  Die
     Hypergeometrische Funktion ist die verallgemeinerte geometrische
     Reihe und ist wie folgt definiert:

             F    (a_1, ... a_p; b_1, ..., b_q; z) =
              p, q

                       inf      p                    q                k
                       ====   /===\ gamma(k + a )  /===\   gamma(b ) z
                       \       ! !             i    ! !           j
                     =  >      ! !  -------------   ! !  ----------------
                       /       ! !    gamma(a )     ! !  k! gamma(k + b )
                       ====   i = 1          i     j = 1               j
                       k = 0

     Die Argumente <a> und <b> sind Listen mit den Parametern der
     Hypergeometrischen Funktion `a_1', ..., `a_p' sowie `b_1', ...,
     `b_p'.  Die Liste <a> enthält die `p'-Elemente <a_i> und die Liste
     <b> enthält die <q>-Elemente <b_i>.

     Kann `hgfred' die Hypergeomentrische Funktion nicht vereinfachen,
     wird eine Substantivform `%f[p,q]([a], [b], z)' zurückgegeben.

     Beispiele:

          (%i1) assume(not(equal(z,0)));
          (%o1)                          [notequal(z, 0)]
          (%i2) hgfred([v+1/2],[2*v+1],2*%i*z);

                               v/2                               %i z
                              4    bessel_j(v, z) gamma(v + 1) %e
          (%o2)               ---------------------------------------
                                                 v
                                                z
          (%i3) hgfred([1,1],[2],z);

                                             log(1 - z)
          (%o3)                            - ----------
                                                 z
          (%i4) hgfred([a,a+1/2],[3/2],z^2);

                                         1 - 2 a          1 - 2 a
                                  (z + 1)        - (1 - z)
          (%o4)                   -------------------------------
                                           2 (1 - 2 a) z

 -- Funktion: lambert_w (<z>)
     Der Hauptzweig der Lambert W Funktion, die Lösung von `z = W(z) *
     exp(W(z))'.

 -- Funktion: nzeta (<z>)
     Die Plasma Dispersion Funktion `nzeta(z) =
     %i*sqrt(%pi)*exp(-z^2)*(1-erf(-%i*z))'.

 -- Funktion: nzetar (<z>)
     Gibt  `realpart(nzeta(z))' zurück.

 -- Funktion: nzetai (<z>)
     Gibt `imagpart(nzeta(z))' zurück.

 -- Funktion: %s [<u>,<v>] (<z>)
     Lommels kleine Funktion `s[u,v](z)'.  Siehe Gradshteyn & Ryzhik
     8.570.1.


File: maxima.info,  Node: Fourier-Transformationen,  Next: Muster und Regeln,  Prev: Spezielle Funktionen,  Up: Top

23 Fourier-Transformationen
***************************

* Menu:

* Einführung in die schnelle Fourier-Transformation::
* Funktionen und Variablen für die schnelle Fourier-Transformation::
* Einführung in Fourierreihen::
* Funktionen und Variablen für Fourierreihen::


File: maxima.info,  Node: Einführung in die schnelle Fourier-Transformation,  Next: Funktionen und Variablen für die schnelle Fourier-Transformation,  Prev: Fourier-Transformationen,  Up: Fourier-Transformationen

23.1 Einführung in die schnelle Fourier-Transformation
======================================================

Das Paket `fft' enthält Funktionen für die numerische Berechnung der
schnellen Fourier Transformation (FFT - "Fast Fourier Transform").


File: maxima.info,  Node: Funktionen und Variablen für die schnelle Fourier-Transformation,  Next: Einführung in Fourierreihen,  Prev: Einführung in die schnelle Fourier-Transformation,  Up: Fourier-Transformationen

23.2 Funktionen und Variablen für die schnelle Fourier-Transformation
=====================================================================

 -- Funktion: polartorect (<r>, <t>)
     Transformiert komplexe Zahlen der Form `r %e^(%i t)' in die
     Standardform `a + b %i'.  <r> ist der Betrag der komplexen Zahl
     und <t> die Phase.  Die Argumente <r> und <t> sind eindimensionale
     Arrays derselben Größe.  Die Größe der Arrays muss eine Potenz von
     2 sein.

     Die Werte der originalen Arrays werden durch den Realteil `a = r
     cos(t)' und den Imaginärteil `b = r sin(t)' ersetzt.

     `polartorect' ist die inverse Funktion zu `recttopolar'.

     Das Kommando `load(fft)' lädt die Funktion.

 -- Funktion: recttopolar (<a>, <b>)
     Transformiert komplexe Zahlen der Form `a + b %i' in die Polarform
     `r %e^(%i t)'.  <a> ist der Realteil und <b> der Imaginärteil der
     komplexen Zahl.  Die Argumente <a> und <b> sind eindimensionale
     Arrays derselben Größe.  Die Größe der Arrays muss eine Potenz von
     2 sein.

     Die Werte der originalen Arrays werden durch den Betrag `r =
     sqrt(a^2 + b^2' und die Phase `t = atan2(b, a)' ersetzt.  Die
     Phase ist ein Winkel in dem Bereich `-%pi' bis `%pi'.

     `recttoploar' ist die inverse Funktion zu `polartorect'.

     Das Kommando `load(fft)' lädt die Funktion.

 -- Funktion: inverse_fft (<y>)
     Berechnet die inverse schnelle Fourier-Transformation.  Das
     Argument <y> ist eine Liste oder ein Array mit den Daten, die zu
     transformieren sind.  Die Anzahl der Daten muss eine Potenz von 2
     sein.  Die Elemente müssen Zahlen (ganze, rationale,
     Gleitkommazahlen oder große Gleitkommazahlen) oder numerische
     Konstanten sein.  Weiterhin können die Elemente komplexe Zahlen `a
     + b*%i' sein, wobei der Realteil und der Imaginärteil wiederum
     Zahlen oder numerische Konstanten sein müssen.

     `inverse_fft' gibt ein neues Objekt vom selben Typ wie <y> zurück.
     Die Ergebnisse sind immer Gleitkommazahlen oder komplexe Zahlen `a
     + %i*b', wobei `a' und `b' Gleitkommazahlen sind.

     Die inverse diskrete Fourier-Transformation ist wie folgt
     definiert.  Wenn `x' das Ergebnis der inversen
     Fourier-Transformation ist, dann gilt für `j' von 0 bis `n-1'

          x[j] = sum(y[k] exp(2 %i %pi j k / n), k, 0, n - 1)

     Mit dem Kommando `load(fft)' wird die Funktion geladen.  Siehe auch
     `fft'  für die schnelle Fourier-Transformation.

     Beispiele:

     Reelle Daten.

          (%i1) load (fft) $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 2, 3, 4, -1, -2, -3, -4] $
          (%i4) L1 : inverse_fft (L);
          (%o4) [0.0, 14.49 %i - .8284, 0.0, 2.485 %i + 4.828, 0.0,
                                 4.828 - 2.485 %i, 0.0, - 14.49 %i - .8284]
          (%i5) L2 : fft (L1);
          (%o5) [1.0, 2.0 - 2.168L-19 %i, 3.0 - 7.525L-20 %i,
          4.0 - 4.256L-19 %i, - 1.0, 2.168L-19 %i - 2.0,
          7.525L-20 %i - 3.0, 4.256L-19 %i - 4.0]
          (%i6) lmax (abs (L2 - L));
          (%o6)                       3.545L-16

     Komplexe Daten.

          (%i1) load (fft) $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 1 + %i, 1 - %i, -1, -1, 1 - %i, 1 + %i, 1] $
          (%i4) L1 : inverse_fft (L);
          (%o4) [4.0, 2.711L-19 %i + 4.0, 2.0 %i - 2.0,
          - 2.828 %i - 2.828, 0.0, 5.421L-20 %i + 4.0, - 2.0 %i - 2.0,
          2.828 %i + 2.828]
          (%i5) L2 : fft (L1);
          (%o5) [4.066E-20 %i + 1.0, 1.0 %i + 1.0, 1.0 - 1.0 %i,
          1.55L-19 %i - 1.0, - 4.066E-20 %i - 1.0, 1.0 - 1.0 %i,
          1.0 %i + 1.0, 1.0 - 7.368L-20 %i]
          (%i6) lmax (abs (L2 - L));
          (%o6)                       6.841L-17

 -- Funktion: fft (<x>)
     Berechnet die schnelle Fourier-Transformation.  Das Argument <x>
     ist eine Liste oder ein Array mit den Daten, die zu transformieren
     sind.  Die Anzahl der Elemente muss eine Potenz von 2 sein.  Die
     Elemente müssen Zahlen (ganze, rationale, Gleitkommazahlen oder
     große Gleitkommazahlen) oder numerische Konstanten sein.
     Weiterhin können die Elemente komplexe Zahlen `a + b*%i' sein,
     wobei der Realteil und der Imaginärteil wiederum Zahlen oder
     numerische Konstanten sein müssen.

     `inverse_fft' gibt ein neues Objekt vom selben Typ wie <x> zurück.
     Die Ergebnisse sind immer Gleitkommazahlen oder komplexe Zahlen `a
     + %i*b', wobei `a' und `b' Gleitkommazahlen sind.

     Die diskrete Fourier-Transformation ist wie folgt definiert.  Wenn
     `y' das Ergebnis der Fourier-Transformation ist, dann gilt für `k'
     von 0 bis `n-1'

          y[k] = (1/n) sum(x[j] exp(-2 %i %pi j k / n), j, 0, n - 1)

     Sind die Daten <x> reelle Zahlen, dann werden die reellen
     Koeffizienten <a> und <b> so berechnet, dass gilt

          x[j] = sum (a[k] * cos (2*%pi*j*k / n)
                    + b[k] * sin (2*%pi*j*k / n), k, 0, n/2)

     wobei

          a[0] = realpart (y[0])
          b[0] = 0

     und für <k> von 1 bis `n/2-1'

          a[k] = realpart (y[k] + y[n - k])
          b[k] = imagpart (y[n - k] - y[k])

     sowie

          a[n/2] = realpart (y[n/2])
          b[n/2] = 0

     Das Kommando `load(fft)' lädt die Funktion.  Siehe auch
     `inverse_fft'  für die inverse schnelle Fourier-Transformation.

     Beispiele:

     Reelle Daten.

          (%i1) load (fft) $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 2, 3, 4, -1, -2, -3, -4] $
          (%i4) L1 : fft (L);
          (%o4) [0.0, - 1.811 %i - .1036, 0.0, .6036 - .3107 %i, 0.0,
                                   .3107 %i + .6036, 0.0, 1.811 %i - .1036]
          (%i5) L2 : inverse_fft (L1);
          (%o5) [1.0, 2.168L-19 %i + 2.0, 7.525L-20 %i + 3.0,
          4.256L-19 %i + 4.0, - 1.0, - 2.168L-19 %i - 2.0,
          - 7.525L-20 %i - 3.0, - 4.256L-19 %i - 4.0]
          (%i6) lmax (abs (L2 - L));
          (%o6)                       3.545L-16

     Komplexe Daten.

          (%i1) load (fft) $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 1 + %i, 1 - %i, -1, -1, 1 - %i, 1 + %i, 1] $
          (%i4) L1 : fft (L);
          (%o4) [0.5, .3536 %i + .3536, - 0.25 %i - 0.25,
          0.5 - 6.776L-21 %i, 0.0, - .3536 %i - .3536, 0.25 %i - 0.25,
          0.5 - 3.388L-20 %i]
          (%i5) L2 : inverse_fft (L1);
          (%o5) [1.0 - 4.066E-20 %i, 1.0 %i + 1.0, 1.0 - 1.0 %i,
          - 1.008L-19 %i - 1.0, 4.066E-20 %i - 1.0, 1.0 - 1.0 %i,
          1.0 %i + 1.0, 1.947L-20 %i + 1.0]
          (%i6) lmax (abs (L2 - L));
          (%o6)                       6.83L-17

     Berechnung der Sinus- und Kosinus-Koeffizienten.

          (%i1) load (fft) $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 2, 3, 4, 5, 6, 7, 8] $
          (%i4) n : length (L) $
          (%i5) x : make_array (any, n) $
          (%i6) fillarray (x, L) $
          (%i7) y : fft (x) $
          (%i8) a : make_array (any, n/2 + 1) $
          (%i9) b : make_array (any, n/2 + 1) $
          (%i10) a[0] : realpart (y[0]) $
          (%i11) b[0] : 0 $
          (%i12) for k : 1 thru n/2 - 1 do
             (a[k] : realpart (y[k] + y[n - k]),
              b[k] : imagpart (y[n - k] - y[k]));
          (%o12)                        done
          (%i13) a[n/2] : y[n/2] $
          (%i14) b[n/2] : 0 $
          (%i15) listarray (a);
          (%o15)          [4.5, - 1.0, - 1.0, - 1.0, - 0.5]
          (%i16) listarray (b);
          (%o16)           [0, - 2.414, - 1.0, - .4142, 0]
          (%i17) f(j) := sum (a[k] * cos (2*%pi*j*k / n) + b[k]
                                   * sin (2*%pi*j*k / n), k, 0, n/2) $
          (%i18) makelist (float (f (j)), j, 0, n - 1);
          (%o18)      [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]

 -- Funktion: horner (<expr>, <x>)
 -- Funktion: horner (<expr>)
     Formt ein Polynom <expr> in das Horner-Schema um.  Mit <x> wird die
     Variable angegeben, für die das Horner-Schema zu bilden ist.  Wird
     das Argument <x> nicht angegeben, wird die Hauptvariable des
     kanonischen Ausdrucks <expr> für die Bildung des Horner-Schemas
     genutzt.

     Das Horner-Schema kann die Stabilität der numerischen Berechnung
     eines Ausdrucks verbessern.

     Beispiel:

          (%i1) expr: 1e-155*x^2 - 5.5*x + 5.2e155;
                                     2
          (%o1)            1.0E-155 x  - 5.5 x + 5.2E+155
          (%i2) expr2: horner (%, x), keepfloat: true;
          (%o2)            (1.0E-155 x - 5.5) x + 5.2E+155
          (%i3) ev (expr, x=1e155);
          Maxima encountered a Lisp error:

           floating point overflow

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.
          (%i4) ev (expr2, x=1e155);
          (%o4)                       7.0E+154

 -- Funktion: find_root (<expr>, <x>, <a>, <b>)
 -- Funktion: find_root (<f>, <a>, <b>)
 -- Optionsvariable: find_root_error
 -- Optionsvariable: find_root_abs
 -- Optionsvariable: find_root_rel
     Findet die Nullstellen eines Ausdrucks <expr> oder einer Funktion
     <f> in dem Intervall `[<a>, <b>]'.  Der Ausdruck <expr> kann eine
     Gleichung sein.  In diesem Fall sucht die Funktion `find_root' die
     Nullstellen für den Ausdruck `lhs(<expr>) - rhs(<expr>)'.

     Kann Maxima den Ausdruck <expr> oder die Funktion <f> in dem
     Intervall `[<a>, <b>]' für alle Werte auswerten und ist der
     Ausdruck <expr> oder die Funktion <f> in dem Intervall stetig,
     dann ist sicher, dass `find_root' die Nullstelle oder zumindest
     eine Nullstelle findet, wenn mehrere Nullstellen vorhanden sind.

     `find_root' beginnt mit einer binären Suche der Nullstelle.
     Erscheint die Funktion als glatt genug, wendet Maxima einen
     Algorithmus mit einer linearen Interpolation für die Suche der
     Nullstelle an.

     Die Genauigkeit der Nullstellensuche wird von den Optionsvariablen
     `find_root_abs' und `find_root_rel' kontrolliert.  `find_root'
     endet, wenn die Auswertung der Funktion ein Ergebnis hat, das
     kleiner als `find_root_abs' ist oder wenn aufeinander folgende
     Auswertungen Ergebnisse <x_0> und <x_1> haben, die sich
     voneinander weniger als `find_root_rel * max(abs(x_0), abs(x_1))'
     unterscheiden.  Der Standardwert der Optionsvariablen
     `find_root_abs' und `find_root_rel' ist Null.

     `find_root' erwartet, dass die Funktion an den Endpunkten des
     Intervalls für die Nullstellensuche ein unterschiedliches
     Vorzeichen hat.  Hat die Funktion an den Endpunkten des Intervalls
     dasselbe Vorzeichen, wird das Verhalten der Funktion `find_root'
     von der Optionsvariablen `find_root_error' kontrolliert.  Hat
     `find_root_error' den Wert `true', wird eine Fehlermeldung
     ausgegeben.  Ansonsten wird von `find_root' der Wert von
     `find_root_error' als Ergebnis zurückgegeben.  Der Standardwert
     von `find_root_error' ist `true'.

     Kann die Funktion <f> bei der Nullstellensuche nicht zu einer Zahl
     ausgewertet werden, gibt `find_root' ein teilweise ausgewertetes
     Ergebnis zurück.

     Die Reihenfolge der Grenzen des Intervalls <a> und <b> wird
     ignoriert.  `find_root' sucht die Nullstellen immer in dem
     Intervall `[min(<a>, <b>), max(<a>, <b>)]'.

     Beispiele:

          (%i1) f(x) := sin(x) - x/2;
                                                  x
          (%o1)                  f(x) := sin(x) - -
                                                  2
          (%i2) find_root (sin(x) - x/2, x, 0.1, %pi);
          (%o2)                   1.895494267033981
          (%i3) find_root (sin(x) = x/2, x, 0.1, %pi);
          (%o3)                   1.895494267033981
          (%i4) find_root (f(x), x, 0.1, %pi);
          (%o4)                   1.895494267033981
          (%i5) find_root (f, 0.1, %pi);
          (%o5)                   1.895494267033981
          (%i6) find_root (exp(x) = y, x, 0, 100);
                                      x
          (%o6)           find_root(%e  = y, x, 0.0, 100.0)
          (%i7) find_root (exp(x) = y, x, 0, 100), y = 10;
          (%o7)                   2.302585092994046
          (%i8) log (10.0);
          (%o8)                   2.302585092994046


File: maxima.info,  Node: Einführung in Fourierreihen,  Next: Funktionen und Variablen für Fourierreihen,  Prev: Funktionen und Variablen für die schnelle Fourier-Transformation,  Up: Fourier-Transformationen

23.3 Einführung in Fourierreihen
================================

Das Paket `fourie' enthält Funktionen für die symbolische Berechnungen
von Fourierreihen.  Weiterhin enthält das Paket Funktionen, um
Fourierkoeffizienten zu berechnen und einige weitere Funktionen.


File: maxima.info,  Node: Funktionen und Variablen für Fourierreihen,  Prev: Einführung in Fourierreihen,  Up: Fourier-Transformationen

23.4 Funktionen und Variablen für Fourierreihen
===============================================

 -- Funktion: equalp (<x>, <y>)
     Gibt `true' zurück, wenn `equal(<x>, <y>)' das Ergebnis `true'
     hat.  Ansonsten ist das Ergebnis `false'.

 -- Funktion: remfun (<f>, <expr>)
 -- Funktion: remfun (<f>, <expr>, <x>)
     `remfun(<f>, <expr>' ersetzt `<f>(<arg>)' durch <arg> im Ausdruck
     <expr>.

     `remfun(<f>, <expr>, <x>)' ersetzt `<f> (<arg>)' durch <arg> im
     Ausdruck <expr> nur dann, wenn <arg> die Variable <x> enthält.

 -- Funktion: funp (<f>, <expr>)
 -- Funktion: funp (<f>, <expr>, <x>)
     `funp(<f>, <expr>)' hat das Ergebnis `true', wenn der Ausdruck
     <expr> die Funktion <f> enthält.

     `funp(<f>, <expr>, <x>)' hat das Ergebnis `true', wenn der
     Ausdruck <expr> die Funktion <f> enthÃ¤lt und die Variable <x> ein
     Argument der Funktion <f> ist.

 -- Funktion: absint (<f>, <x>, <halfplane>)
 -- Funktion: absint (<f>, <x>)
 -- Funktion: absint (<f>, <x>, <a>, <b>)
     `absint(<f>, <x>, <halfplane>)' gibt das unbestimmte Integral der
     Funktion <f> für die Variable <x> zurück.  Das Integral wird in
     der angegebenen Halbebene `pos', `neg' oder für beide Halbebenen
     mit `both' berechnet.  Der Integrand kann die Betragsfunktion
     enthalten: `abs(x)', `abs(sin(x))', `abs(a) * exp(-abs(b) *
     abs(x))'.

     `absint(<f>, <x>)' ist äquivalent zu `absint(<f>, <x>, pos)'.

     `absint(<f>, <x>, <a>, <b>)' gibt das bestimmte Integral der
     Funktion <f> für die Variable <x> in den Grenzen <a> und <b>
     zurück.  Der Integrand kann die Betragsfunktion enthalten.

 -- Funktion: fourier (<f>, <x>, <l>)
     Berechnet die Fourier-Koeffizienten `a[0]', `a[n]' und `b[n]' der
     Funktion `<f>(<x>)' für das Intervall `[-l, l]'.  Die Fourierreihe
     ist definiert als:

                   inf
                   ====
                   \             %pi n x           %pi n x
            f(x) =  >    (b  sin(-------) + a  cos(-------))
                   /       n        l        n        l
                   ====
                   n = 0

     Die Koeffizienten der Fourierreihe werden folgendermaßen berechnet:

                               l
                              /
                          - 1 [
                a  = 1/2 l    I    f(x) dx
                 0            ]
                              /
                               - l

                           l
                          /
                      - 1 [                  - 1
                a  = l    I    f(x) cos(%pi l    n x) dx
                 n        ]
                          /
                           - l

                            l
                           /
                      - 1 [                  - 1
                b  = l    I    f(x) sin(%pi l    n x) dx
                 n        ]
                          /
                           - l

     `fourier' weist die Fourier-Koeffizienten Zwischenmarken zu.  Die
     Zwischenmarken werden als eine Liste zurückgegeben.

     Der Index der Summe ist immer das Symbol <n>.  Sinus- und
     Kosinusfunktionen mit ganzzahligen Vielfachen von `%pi' werden
     nicht automatisch vereinfacht.  Dies kann mit der Funktion
     `foursimp'  erreicht werden, der als Argument die Liste der
     Fourier-Koeffizienten übergeben wird.

     Mit der Funktion `fourexpand'  kann die Fourierreihe aus den
     Fourier-Koeffizienten konstruiert werden.  Siehe auch die Funktion
     `totalfourier'.

     Mit den Funktionen `fourcos'  und `foursin'  werden jeweils die
     Koeffizienten der Kosinus- und Sinus-Entwicklung berechnet.

     Beispiel:

          (%i1) load(fourie)$

          (%i2) fourier(x, x, 1);
          (%t2)                        a  = 0
                                        0

          (%t3)                        a  = 0
                                        n

                                  sin(%pi n)   cos(%pi n)
          (%t4)           b  = 2 (---------- - ----------)
                           n          2  2       %pi n
                                   %pi  n

          (%o4)                    [%t2, %t3, %t4]
          (%i5) foursimp(%);
          (%t5)                        a  = 0
                                        0

          (%t6)                        a  = 0
                                        n

                                                 n
                                          2 (- 1)
          (%t7)                    b  = - --------
                                    n      %pi n

          (%o7)                    [%t5, %t6, %t7]
          (%i8) fourexpand(%, x, 1, inf);
                                inf
                                ====       n
                                \     (- 1)  sin(%pi n x)
                              2  >    -------------------
                                /              n
                                ====
                                n = 1
          (%o8)             - ---------------------------
                                          %pi

 -- Funktion: foursimp (<l>)
     `foursimp' wird auf das Ergebnis der Funktion `fourier'
     angewendet, um Sinus- und Kosinus-Funktionen zu vereinfachen, die
     ganzzahlige Vielfache von `%pi' enthalten.  Das Argument <l> ist
     eine Liste mit den Koeffizienten der Fourierreihe, für die die
     Vereinfachung ausgeführt werden soll.

     `sin(n %pi)' wird zu `0' vereinfacht, wenn die Optionsvariable
     `sinnpiflag'  den Wert `true' hat, und `cos(n %pi)' wird zu
     `(-1)^n', wenn die Optionsvariable `cosnpiflag'  den Wert `true'
     hat.

     Siehe die Funktion `fourier'  für ein Beispiel.

 -- Optionsvariable: sinnpiflag
     Standardwert: `true'

     Kontrolliert die Vereinfachung der Sinus-Funktion durch die
     Funktion `foursimp'.  Siehe die Funktion `foursimp'.


 -- Optionsvariable: cosnpiflag
     Standardwert: `true'

     Kontrolliert die Vereinfachung der Kosinus-Funktion durch die
     Funktion `foursimp'.  Siehe die Funktion `foursimp'.


 -- Funktion: fourexpand (<l>, <x>, <p>, <limit>)
     Konstruiert aus der Liste der Fourier-Koeffizienten <l> eine
     Fourierreihe mit <limit> Termen.  Das Argument <limit> kann `inf'
     sein.  Die Argumente <x> und <p> haben dieselbe Bedeutung wie für
     die Funktion `fourier'.

     Siehe die Funktion `fourier'  für ein Beispiel.

 -- Funktion: fourcos (<f>, <x>, <p>)
     Gibt die Kosinus-Koeffizienten einer Fourierreihe für die Funktion
     `<f>(<x>)' zurück, die auf dem Intervall `[0, <p>]' definiert ist.

 -- Funktion: foursin (<f>, <x>, <p>)
     Gibt die Sinus-Koeffizienten einer Fourierreihe für die Funktion
     `<f>(<x>)' zurück, die auf dem Intervall `[0, <p>]' definiert ist.

 -- Funktion: totalfourier (<f>, <x>, <l>)
     Gibt die Fourierreihe der Funktion <f(x)> für das Intervall
     `[<-l>, <l>]' zurück.  Das Ergebnis wird berechnet, indem die
     nacheinander die Funktionen `foursimp'  und `fourexpand'  auf das
     Ergebnis der Funktion `fourier'  angewendet werden.

     Beispiel:

          (%i1) load(fourie)$

          (%i2) totalfourier(x, x, 1);
          (%t2)                        a  = 0
                                        0

          (%t3)                        a  = 0
                                        n

                                  sin(%pi n)   cos(%pi n)
          (%t4)           b  = 2 (---------- - ----------)
                           n          2  2       %pi n
                                   %pi  n

          (%t5)                        a  = 0
                                        0

          (%t6)                        a  = 0
                                        n
                                                 n
                                          2 (- 1)
          (%t7)                    b  = - --------
                                    n      %pi n
                                inf
                                ====       n
                                \     (- 1)  sin(%pi n x)
                              2  >    -------------------
                                /              n
                                ====
                                n = 1
          (%o7)             - ---------------------------
                                          %pi


 -- Funktion: fourint (<f>, <x>)
     Konstruiert eine Liste der Fourierintegral-Koeffizienten der
     Funktion `<f>(<x>)', die auf dem Intervall `[minf, inf]' definiert
     ist.

 -- Funktion: fourintcos (<f>, <x>)
     Gibt die Koeffizienten des Kosinus-Fourierintegrals der Funktion
     `<f>(<x>)' zurück, die auf dem Intervall `[0, inf]' definiert ist.


 -- Funktion: fourintsin (<f>, <x>)
     Gibt die Koeffizienten des Sinus-Fourierintegrals der Funktion
     `<f>(<x>)' zurück, die auf dem Intervall `[0, inf]' definiert ist.


File: maxima.info,  Node: Muster und Regeln,  Next: Funktionsdefinitionen,  Prev: Fourier-Transformationen,  Up: Top

24 Muster und Regeln
********************

* Menu:

* Einführung in Muster und Regeln::
* Funktionen und Variablen für Muster und Regeln::


File: maxima.info,  Node: Einführung in Muster und Regeln,  Next: Funktionen und Variablen für Muster und Regeln,  Prev: Muster und Regeln,  Up: Muster und Regeln

24.1 Einführung in Muster und Regeln
====================================

Dieses Kapitel beschreibt nutzerdefinierte Muster und Regeln für die
Vereinfachung von Ausdrücken.  Es gibt zwei verschiedene Gruppen von
Funktionen, die einen unterschiedlichen Musterabgleich implementieren.
Die eine Gruppe enthält die Funktionen `tellsimp',

`tellsimpafter',  `defmatch',  `defrule',

`apply1',  `applyb1'  und `apply2'.    In der anderen Gruppe sind die
Funktionen `let'  und `letsimp'  enthalten.  Beide Methoden verwenden
Mustervariablen, die mit der Funktion `matchdeclare'  definiert werden.

Regeln, die mit den Funktionen `tellsimp' und `tellsimpafter' definiert
werden, werden von Maxima automatisch bei der Vereinfachung von
Ausdrücken angewendet.  Regeln, die mit den Funktionen `defmatch',
`defrule' oder `let' definiert werden, werden durch den Aufruf einer
Funktion auf einen Ausdruck angewendet.

Maxima kennt weitere Methoden wie die Definition von minimalen
Polynomen mit der Funktion `tellrat',  um Einfluss auf die
Vereinfachung von Polynomen zu nehmen, oder Funktionen der kommutativen
und nicht-kommutativen Algebra, die in dem Paket *note affine::
definiert sind.


File: maxima.info,  Node: Funktionen und Variablen für Muster und Regeln,  Prev: Einführung in Muster und Regeln,  Up: Muster und Regeln

24.2 Funktionen und Variablen für Muster und Regeln
===================================================

 -- Optionsvariable: announce_rules_firing
     Standardwert: `false'

     Hat die Optionsvariable `announce_rules_firing' den Wert `true' und
     wird mit den Funktionen `tellsimp'  oder `tellsimpafter'  eine
     Regel definiert, dann wird immer dann eine Meldung ausgegeben,
     wenn die Regel angewendet wird.  `announce_rules_firing' hat
     keinen Einfluss auf Regeln, die bereits definiert sind.  Die
     Meldung von Regeln kann auch nicht durch das Setzen von
     `announce_rules_firing' auf den Wert `false' abgeschaltet werden.

     Diese Optionsvariable ist nützlich, wenn die Anwendung von
     nutzerdefinierten Regeln für die Fehlersuche kontrolliert werden
     soll.

     Beispiel:

          (%i1) announce_rules_firing:true;
          (%o1)                         true
          (%i2) tellsimpafter(tan(x), sin(x)/cos(x));
          (%o2)                 [tanrule1, simp-%tan]
          (%i3) tan(x);

          By tanrule1 , tan(x) --> sin(x)/cos(x)
                                       sin(x)
          (%o3)                        ------
                                       cos(x)

 -- Funktion: apply1 (<expr>, <rule_1>, ..., <rule_n>)
     Wendet die Regel <rule_1> auf den Ausdruck <expr> solange an, bis
     sich das Ergebnis nicht mehr ändert.  Die Regel wird zuerst auf
     der obersten Ebene des Ausdrucks und dann nacheinander von links
     nach rechts auf die Teilausdrücke angewendet.  Ist <expr_1> das
     Ergebnis der Anwendung der Regel <rule_1>, dann wird die Regel
     <rule_2> auf gleiche Weise auf den Ausdruck <expr_1> angewendet.
     Zuletzt wird die Regel <rule_n> angewendet.  Das letzte Ergebnis
     wird zurückgegeben.

     Die Optionsvariable `maxapplydepth'  enthält die größte
     Verschachtelungstiefe, für die die Funktionen `apply1' und
     `apply2' auf einen Ausdruck angewendet werden.

     Siehe auch die Funktionen `applyb1'  und `apply2',  um Regeln auf
     einen Ausdruck anzuwenden, die mit der Funktion `defrule'
     definiert sind.

     Beispiele:

          (%i1) defrule(trig1, tan(x), sin(x)/cos(x));
                                                sin(x)
          (%o1)               trig1 : tan(x) -> ------
                                                cos(x)
          (%i2) defrule(trig2, cot(x), 1/tan(x));
                                                  1
          (%o2)               trig2 : cot(x) -> ------
                                                tan(x)
          (%i3) apply1(cot(x), trig1, trig2);
                                         1
          (%o3)                        ------
                                       tan(x)
          (%i4) apply1(cot(x), trig2, trig1);
                                       cos(x)
          (%o4)                        ------
                                       sin(x)

     Die folgenden Beispiele zeigen, wie mit der Optionsvariablen
     `maxapplydepth' die Tiefe kontrolliert wird, in der eine Regel auf
     die Teilausdrücke angewendet wird.

          (%i1) expr: tan(x)+exp(a+2*tan(x));
                                          2 tan(x) + a
          (%o1)                tan(x) + %e
          (%i2) defrule(trig, tan(x), sin(x)/cos(x));
                                                sin(x)
          (%o2)                trig : tan(x) -> ------
                                                cos(x)
          (%i3) maxapplydepth: 1;
          (%o3)                           1
          (%i4) apply1(expr, trig);
                               sin(x)     2 tan(x) + a
          (%o4)                ------ + %e
                               cos(x)
          (%i5) maxapplydepth: 4;
          (%o5)                           4
          (%i6) apply1(expr, trig);
                                          2 sin(x)
                                          -------- + a
                               sin(x)      cos(x)
          (%o6)                ------ + %e
                               cos(x)

 -- Funktion: apply2 (<expr>, <rule_1>, ..., <rule_n>)
     Zunächst werden nacheinander die Regeln <rule_1>, <rule_2>, ...
     auf den Ausdruck <expr> angewendet.  Schlägt die Anwendung aller
     Regeln fehl, werden die Regeln nacheinander auf die Teilausdrücke
     des Argumentes <expr> angewendet.  Kann eine der Regeln
     erfolgreich angewendet werden, wird die Anwendung aller Regeln auf
     den Teilausdruck wiederholt.

     Im Unterschied zur Funktion `apply1'  werden von der Funktion
     `apply2' immer alle Regeln angewendet.  Sind jedoch die Regeln,
     die als Argumente übergeben werden, zirkulär definiert, so führt
     Maxima eine Endlosschleife aus.  Siehe dazu auch das Beispiel
     unten.

     Die Optionsvariable `maxapplydepth'  enthält die größte
     Verschachtelungstiefe, für die die Funktionen `apply1' und `apply2'
     auf einen Ausdruck angewendet werden.

     Siehe auch die Funktionen `apply1'  und `applyb1',  um Regeln auf
     einen Ausdruck anzuwenden, die mit der Funktion `defrule'
     definiert sind.

     Beispiele:

     Im Unterschied zur Funktion `apply1'  ist in diesem Fall das
     Ergebnis immer `sin(x)/cos(x)', da alle Regeln wiederholt auf
     einen Teilausdruck angewendet werden, wenn sich der Ausdruck für
     eine Regel ändert.

          (%i1) defrule(trig1, tan(x), sin(x)/cos(x));
                                                sin(x)
          (%o1)               trig1 : tan(x) -> ------
                                                cos(x)
          (%i2) defrule(trig2, cot(x), 1/tan(x));
                                                  1
          (%o2)               trig2 : cot(x) -> ------
                                                tan(x)
          (%i3) apply2(cot(x), trig1, trig2);
                                       cos(x)
          (%o3)                        ------
                                       sin(x)
          (%i4) apply2(cot(x), trig2, trig1);
                                       cos(x)
          (%o4)                        ------
                                       sin(x)

     Das folgende Beispiel zeigt eine zirkuläre Definition der Regeln
     `trig1' und `trig2'.  Mit der Funktion `apply1' hängt das Ergebnis
     von der Reihenfolge der Anwendung der Regeln ab.  Die Anwendung
     der Funktion `apply2' führt für dieses Beispiel zu einer
     Endlosschleife.

          (%i1) defrule(trig1, tan(x), sin(x)/cos(x));
                                                sin(x)
          (%o1)               trig1 : tan(x) -> ------
                                                cos(x)
          (%i2) defrule(trig2, sin(x)/cos(x), tan(x));
                                      sin(x)
          (%o2)               trig2 : ------ -> tan(x)
                                      cos(x)
          (%i3) expr: tan(x) + exp(sin(x)/cos(x));
                                             sin(x)
                                             ------
                                             cos(x)
          (%o3)                   tan(x) + %e
          (%i4) apply1(expr, trig1, trig2);
                                             tan(x)
          (%o4)                   tan(x) + %e
          (%i5) apply1(expr, trig2, trig1);
                                             sin(x)
                                             ------
                                  sin(x)     cos(x)
          (%o5)                   ------ + %e
                                  cos(x)

 -- Funktion: applyb1 (<expr>, <rule_1>, ..., <rule_n>)
     Wendet die Regel <rule_1> auf den tiefsten Teilausdruck in der
     Baumstruktur eines Ausdrucks an.  Schlägt die Anwendung fehl, wird
     der Teilausdruck eine Ebene höher betrachtet, bis <rule_1> auf die
     oberste Ebene des Ausdrucks <expr> angewendet wird.  Danach wird
     auf gleiche Weise die Regel <rule_2> auf den Ausdruck <expr>
     angewendet.  Nachdem die letzte Regel <rule_n> angewendet wurde,
     wird das Ergebnis zurückgegeben.

     `applyb1' ist vergleichbar mit `apply1'  mit dem Unterschied, dass
     die Regeln Bottom-Up angewendet werden.

     Die Optionsvariable `maxapplyheight'  enthält den Wert der größten
     Verschachtelungstiefe, für die `applyb1' angewendet wird.

     Siehe auch die Funktionen `apply1'  und `apply2',  um Regeln auf
     einen Ausdruck anzuwenden, die mit der Funktion `defrule'
     definiert sind.

     Beispiel:

     Das folgende Beispiel zeigt, wie die Regel `trig' zuerst auf die
     unterste Ebene des Ausdrucks angewendet wird.  Dazu wird die
     Optionsvariable `maxapplyheight' zunächst auf den Wert `1' gesetzt
     und dann auf den Wert `4' erhöht.

          (%i1) matchdeclare(x, true);
          (%o1)                         done
          (%i2) defrule(trig, tan(x), sin(x)/cos(x));
                                                sin(x)
          (%o2)                trig : tan(x) -> ------
                                                cos(x)
          (%i3) expr: exp(a+2*tan(b+exp(tan(x))));
                                        tan(x)
                                2 tan(%e       + b) + a
          (%o3)               %e
          (%i4) maxapplyheight: 1;
          (%o4)                           1
          (%i5) applyb1(expr, trig);
                                        sin(x)
                                        ------
                                        cos(x)
                                2 tan(%e       + b) + a
          (%o5)               %e
          (%i6) maxapplyheight: 4;
          (%o6)                           4
          (%i7) applyb1(expr, trig);
                                        sin(x)
                                        ------
                                        cos(x)
                                2 sin(%e       + b)
                                ------------------- + a
                                       sin(x)
                                       ------
                                       cos(x)
                                 cos(%e       + b)
          (%o7)               %e

 -- Funktion: clear_rules ()
     Führt das Kommando `kill(rules)' aus und setzt die internen Zähler
     für die Benennung der Regeln für die Addition, die Multiplikation
     und die Exponentiation auf den Anfangswert zurück.  Mit dem
     Kommando `kill(rules)' werden alle Regeln entfernt, ohne dass die
     internen Zähler zurückgesetzt werden.  Siehe auch die Funktion
     `kill'.

     Beispiel:

          (%i1) tellsimpafter(a+b, add(a,b));
          (%o1)                   [+rule1, simplus]
          (%i2) tellsimpafter(a*b, mul(a,b));
          (%o2)                  [*rule1, simptimes]
          (%i3) tellsimpafter(a^b, expt(a,b));
          (%o3)                  [^rule1, simpexpt]
          (%i4) rules;
          (%o4)               [+rule1, *rule1, ^rule1]
          (%i5) clear_rules();
          (%o5)                         done
          (%i6) rules;
          (%o6)                          []

     Das folgende Beispiel zeigt einen Programmfehler von Maxima.  Die
     Funktion `trigsimp'  ist mit Hilfe von Regeln implementiert.  Die
     Regeln werden automatisch beim ersten Aufruf der Funktion
     `trigsimp' geladen und in die Liste `rules'  eingetragen.  Werden
     die Regeln mit der Funktion `clear_rules' oder `kill' gelöscht,
     führt der nächste Aufruf der Funktion `trigsimp' zu einem Fehler.

          (%i1) trigsimp(sin(x)^2+cos(x)^2);
          (%o1)                           1
          (%i2) rules;
          (%o2) [trigrule1, trigrule2, trigrule3, trigrule4, htrigrule1,
                                        htrigrule2, htrigrule3, htrigrule4]
          (%i3) disprule(trigrule1, trigrule2, trigrule3, trigrule4)$
                                                  sin(a)
          (%t3)             trigrule1 : tan(a) -> ------
                                                  cos(a)

                                                    1
          (%t4)             trigrule2 : sec(a) -> ------
                                                  cos(a)

                                                    1
          (%t5)             trigrule3 : csc(a) -> ------
                                                  sin(a)

                                                  cos(a)
          (%t6)             trigrule4 : cot(a) -> ------
                                                  sin(a)

          (%i7) clear_rules();
          (%o7)                         done
          (%i8) rules;
          (%o8)                          []
          (%i9) trigsimp(sin(x)^2+cos(x)^2);

          apply1: no such rule: trigrule1
          #0: trigsimp(x=sin(x)^2+cos(x)^2)(trgsmp.mac line 71)
           -- an error. To debug this try: debugmode(true);

 -- Optionsvariable: current_let_rule_package
     Standardwert: `default_let_rule_package'

     Die Optionsvariable `current_let_rule_package' enthält den Namen
     des aktuellen Regelpaketes, das von den Funktionen `let',

     `letrules',  `letsimp'  und `remlet'  verwendet wird.  Der
     Optionsvariablen kann jedes mit der Funktion `let' definierte
     Regelpaket zugewiesen werden.

     Wird das Kommando `letsimp(expr, rule_pkg_name)' ausgeführt, dann
     wird für das aktuelle Kommando das Paket `rule_pkg_name'
     verwendet.  Der Wert der Variablen `current_let_rule_package' wird
     nicht geändert.

     Siehe auch die Optionsvariable `default_let_rule_package'.


 -- Optionsvariable: default_let_rule_package
     Standardwert: `default_let_rule_package'

     Die Optionsvariable `default_let_rule_package' bezeichnet das
     Regelpaket, das verwendet wird, wenn kein Regelpaket mit der
     Funktion `let' explizit definiert und der Wert der
     Optionsvariablen `current_let_rule_package'

     nicht geändert wurde.

 -- Funktion: defmatch (<progname>, <pattern>, <x_1>, ..., <x_n>)
 -- Funktion: defmatch (<progname>, <pattern>)
     Definiert eine Aussagefunktion `<progname>(<expr>)' oder
     `<progname>(<expr>, <x_1>, ..., <x_n>)', die einen Ausdruck <expr>
     testet, um zu prüfen, ob dieser das Muster <pattern> enthält.

     Das Argument <pattern> ist ein Ausdruck mit den Musterargumenten
     <x_1>, ..., <x_n>.  Die Musterargumente können entfallen.  Der
     Ausdruck kann weiterhin Mustervariablen enthalten, die mit der
     Funktion `matchdeclare'  definiert sind.  Alle anderen Variablen
     und Bezeichner entsprechen sich selbst bei einem Musterabgleich.

     Das erste Argument der Aussagefunktion <progname> ist ein Ausdruck
     <expr>, für den geprüft wird, ob das Muster <pattern> enthalten
     ist.  Die weiteren Argumente der Funktion `progname' sind die
     Variablen, die den Musterargumenten <x_1>, ..., <x_n> des Musters
     <pattern> entsprechen.

     Ist der Musterabgleich erfolgreich, gibt die Aussagefunktion
     <progname> eine Liste mit Gleichungen zurück.  Die linken Seiten
     der Gleichungen sind die Musterargumente und Mustervariablen und
     die rechten Seiten sind die Teilausdrücke, für die der
     Musterabgleich eine Übereinstimmung gefunden hat.  Die erhaltenen
     Ergebnisse des Musterabgleichs werden den mit `matchdeclare'
     definierten Mustervariablen, jedoch nicht den Musterargumenten der
     Funktion `defmatch' zugewiesen.  Ist der Musterabgleich nicht
     erfolgreich, ist die Rückgabe `false'.

     Ein Muster, das keine Musterargumente oder Mustervariablen
     enthält, hat den Rückgabewert `true', wenn der Musterabgleich
     erfolgreich ist.

     Die Aussagefunktion `progname' wird in die Informationsliste
     `rules'  eingetragen.

     Siehe auch die Funktionen `matchdeclare',  `defrule',

     `tellsimp'  und `tellsimpafter'.

     Beispiele:

     Definition einer Funktion `linearp(expr, x)', die prüft, ob ein
     Ausdruck <expr> die Form `a*x+b' hat, wobei `a' und `b' die
     Variable <x> nicht enthalten und `a' von Null verschieden ist.
     Die Definition enthält das Musterargument <x>, so dass die
     Linearität des Ausdrucks für eine beliebige Variable getestet
     werden kann.  Den Mustervariablen `a' und `b' werden die
     Teilausdrücke des Musterabgleichs zugewiesen, nicht jedoch dem
     Musterargument `x'.

          (%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)),
                              b, freeof(x));
          (%o1)                         done
          (%i2) defmatch (linearp, a*x + b, x);
          (%o2)                        linearp
          (%i3) linearp (3*z + (y + 1)*z + y^2, z);
                                   2
          (%o3)              [b = y , a = y + 4, x = z]
          (%i4) a;
          (%o4)                         y + 4
          (%i5) b;
                                          2
          (%o5)                          y
          (%i6) x;
          (%o6)                           x

     Wie im letzten Beispiel wird eine Aussagefunktion definiert, die
     prüft, ob ein Ausdruck <expr> linear ist.  In diesem Fall wird
     kein Musterargument angegeben.  Der Musterabgleich kann nur
     feststellen, ob ein Ausdruck linear in der Variablen <x> ist.
     Eine andere Variable ist nicht möglich.

          (%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b,
                              freeof(x));
          (%o1)                         done
          (%i2) defmatch (linearp, a*x + b);
          (%o2)                        linearp
          (%i3) linearp (3*z + (y + 1)*z + y^2);
          (%o3)                         false
          (%i4) linearp (3*x + (y + 1)*x + y^2);
                                       2
          (%o4)                  [b = y , a = y + 4]

     Definition eine Aussagefunktion `checklimits(expr)', die prüft, ob
     ein Ausdruck <expr> ein bestimmtes Integral ist.

          (%i1) matchdeclare ([a, f], true);
          (%o1)                         done
          (%i2) constinterval (l, h) := constantp (h - l);
          (%o2)        constinterval(l, h) := constantp(h - l)
          (%i3) matchdeclare (b, constinterval (a));
          (%o3)                         done
          (%i4) matchdeclare (x, atom);
          (%o4)                         done
          (%i5) simp : false;
          (%o5)                         false
          (%i6) defmatch (checklimits, 'integrate (f, x, a, b));
          (%o6)                      checklimits
          (%i7) simp : true;
          (%o7)                         true
          (%i8) 'integrate (sin(t), t, %pi + x, 2*%pi + x);
                                 x + 2 %pi
                                /
                                [
          (%o8)                 I          sin(t) dt
                                ]
                                /
                                 x + %pi
          (%i9) checklimits (%);
          (%o9)    [b = x + 2 %pi, a = x + %pi, x = t, f = sin(t)]

 -- Funktion: defrule (<rulename>, <pattern>, <replacement>)
     Definiert eine Regel, um das Muster <pattern> durch den Ausdruck
     <replacement> zu ersetzen.  Wird die Regel mit dem Namen <rulename>
     mit den Funktionen `apply1',  `apply2'  oder `applyb1'  auf einen
     Ausdruck angewendet, werden alle Teilausdrücke, die dem Muster
     <pattern> entsprechen, durch den Ausdruck <replacement> ersetzt.
     Sind Mustervariablen vorhanden, die durch den Musterabgleich einen
     Wert erhalten haben, werden die Werte eingesetzt und der Ausdruck
     wird vereinfacht.

     Die Regel <rulename> kann als eine Funktion aufgefasst werden, die
     einen Ausdruck durch Anwendung eines Musterabgleichs
     transformiert.  Die Regel kann wie ein Funktionsaufruf auf einen
     Ausdruck angewendet werden.

     Schlägt der Musterabgleich fehl, gibt die Regel den Wert `false'
     zurück.

     Die Regel wird in die Informationsliste `rules'  eingetragen.

     Beispiele:

     Es wird eine Regel `trig' definiert, die den Ausdruck `sin(x)^2'
     nach `1-cos(x)^2' transformiert.  Diese Definition funktioniert
     nur, wenn das Argument der Sinusfunktion das Symbol `x' ist.

          (%i1) defrule(trig, sin(x)^2, 1-cos(x)^2);
                                      2              2
          (%o1)             trig : sin (x) -> 1 - cos (x)
          (%i2) trig(sin(x)^2);
                                            2
          (%o2)                      1 - cos (x)
          (%i3) trig(sin(y)^2);
          (%o3)                         false

     In diesem Beispiel wird zunächst mit der Funktion `matchdeclare'
     eine Mustervariable `a' definiert, der jeder Ausdruck zugewiesen
     werden kann und die als Argument der Regel verwendet wird.  Jetzt
     kann das Argument der Sinusfunktion ein beliebiger Ausdruck sein.

          (%i1) matchdeclare(a, true);
          (%o1)                         done
          (%i2) defrule(trig, sin(a)^2, 1-cos(a)^2);
                                      2              2
          (%o2)             trig : sin (a) -> 1 - cos (a)
          (%i3) trig(sin(x)^2);
                                            2
          (%o3)                      1 - cos (x)
          (%i4) trig(sin(exp(x))^2);
                                           2   x
          (%o4)                     1 - cos (%e )

     Die Regel kann mit der Funktion `apply1'  auf Ausdrücke angewendet
     werden, wobei Teilausdrücke, die das Muster enthalten
     transformiert werden.

          (%i5) trig(exp(sin(x)^2));
          (%o5)                         false
          (%i6) apply1(exp(sin(x)^2), trig);
                                             2
                                      1 - cos (x)
          (%o6)                     %e

 -- Funktion: disprule (<rulename_1>, ..., <rulename_n>)
 -- Funktion: disprule (all)
     Zeigt die Regeln mit den Namen <rulename_1>, ..., <rulename_n> an,
     die mit den Funktionen `defrule',  `tellsimp'  oder `tellsimpafter'
     definiert sind, oder ein Muster, das mit der Funktion `defmatch'
     definiert ist.  Die Regeln werden mit einer Zwischenmarke `%t'
     angezeigt.

     Mit dem Kommando `disprule(all)' werden alle Regeln und Muster
     angezeigt, die der Nutzer definiert hat und in der
     Informationsliste `rules'

     enthalten sind.

     `disprule' wertet die Argumente nicht aus.  Der Rückgabewert ist
     eine Liste mit den Zwischenmarken, denen eine Regel zugewiesen
     wurde.

     Siehe auch die Funktion `letrules',  die die Regeln anzeigt, die
     mit der Funktion `let'  definiert sind.

     Beispiele:

          (%i1) tellsimpafter (foo (x, y), bar (x) + baz (y));
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (x + y, special_add (x, y));
          (%o2)                   [+rule1, simplus]
          (%i3) defmatch (quux, mumble (x));
          (%o3)                         quux
          (%i4) disprule (foorule1, "+rule1", quux);
          (%t4)        foorule1 : foo(x, y) -> baz(y) + bar(x)

          (%t5)          +rule1 : y + x -> special_add(x, y)

          (%t6)                quux : mumble(x) -> []

          (%o6)                    [%t4, %t5, %t6]
          (%i6) ''%;
          (%o6) [foorule1 : foo(x, y) -> baz(y) + bar(x),
               +rule1 : y + x -> special_add(x, y), quux : mumble(x) -> []]

 -- Funktion: let (<prod>, <repl>)
 -- Funktion: let (<prod>, <repl>, <predname>, <arg_1>, ..., <arg_n>)
 -- Funktion: let ([<prod>, <repl>, <predname>, <arg_1>, ..., <arg_n>],
          <package_name>)
     Definiert eine Regel, die mit der Funktion `letsimp'  auf einen
     Ausdruck angewendet werden kann, so dass <prod> durch <repl>
     ersetzt wird.  Das Argument <prod> ist ein Produkt von positiven
     oder negativen Potenzen der folgenden Terme:

        * Atome, nach denen die Funktion `letsimp' wörtlich sucht, wenn
          diese keine Mustervariablen sind, die mit Funktion
          `matchdeclare'  definiert sind, sowie Atome, die
          Mustervariablen sind.  In diesem Fall führt die Funktion
          `letsimp' einen Musterabgleich für die Atome durch, auf die
          die mit der Funktion `matchdeclare' zugeordnete
          Aussagefunktion zutrifft.

        * Terme wie `sin(x)', `n!' oder `f(x,y)':  wie für Atome sucht
          die Funktion `letsimp' nach wörtlichen Übereinstimmungen,
          außer wenn die Argumente der Terme Mustervariablen sind, die
          mit der Funktion `matchdeclare'  definiert sind.  In diesem
          Fall wird ein Musterabgleich ausgeführt.

     Ein Term mit einer positiven Potenz stimmt mit einem Ausdruck nur
     dann überein, wenn dieser mindestens dieselbe Potenz hat.
     Entsprechend gilt für einen Term mit einer negativen Potenz, dass
     dieser dann mit einem Ausdruck übereinstimmt, wenn dieser
     mindestens dieselbe negative Potenz hat.  Für negative Potenzen
     wird eine Übereinstimmung nur dann gefunden, wenn die
     Optionsvariable `letrat'  den Wert `true' hat.

     Hat die Funktion `let' eine Aussagefunktion <predname> als Argument
     mit den Argumenten <arg_1>, ..., <arg_n>, wird eine
     Übereinstimmung dann festgestellt, wenn der Ausdruck
     `predname(arg_1', ..., arg_n')' das Ergebnis `true' hat.  Dabei
     sind die Argumente <arg_i'> die Werte aus dem Musterabgleich.  Die
     Argumente <arg_i> können die Namen von Variablen oder Termen sein,
     die im Ausdruck <pred> auftreten.  <repl> kann ein beliebiger
     rationaler Ausdruck sein.  Treten irgendwelche der Symbole oder
     Argumente aus <prod> im Argument <repl> auf, wird die
     entsprechende Substitution ausgeführt.

     Die Optionsvariable `letrat'  kontrolliert die Vereinfachung von
     Quotienten durch `letsimp'.    Hat `letrat' den Wert `false',
     werden der Zähler und der Nenner eines Bruches einzeln
     vereinfacht.  Der Bruch als ganzes wird dagegen nicht vereinfacht.
     Hat die Optionsvariable `letrat' den Wert `true', werden
     nacheinander der Zähler, der Nenner und dann der Bruch vereinfacht.

     Die Funktion `letsimp'  kann mit verschiedenen Regelpaketen
     arbeiten.  Jedes Regelpaket kann eine beliebige Anzahl an Regeln
     enthalten.  Das Kommando `let([<prod>, <repl>, <predname>,
     <arg_1>, ..., <arg_n>], <package_name>)' fügt die Regel <predname>
     dem Paket <package_name> hinzu.

     Die Optionsvariable `current_let_rule_package'  enthält den Namen
     des Regelpaketes, das aktuell von der Funktion `letsimp' verwendet
     wird.  Der Optionsvariablen kann jedes mit dem Kommando `let'
     definierte Regelpaket zugewiesen werden.  Wird mit
     `letsimp(<expr>, <package_name>)' ein Regelpaket als Argument
     übergeben, wird dieses anstatt dem in `current_let_rule_package'
     enthaltene Regelpaket für die Vereinfachung verwendet.  Wenn nicht
     anders spezifiziert, hat `current_let_rule_package' den
     Standardwert `default_let_rule_package'.

     Die Informationsliste `let_rule_packages'  enthält die definierten
     Regelpakete.  Mit der Funktion `letrules'  können alle definierten
     Regeln oder Regeln einzelner Pakete angezeigt werden.

     Beispiele:

     Die Funktion `isintegerp' prüft auch, ob Variablen oder Ausdrücke
     eine ganze Zahl repräsentieren.  Es wird eine Regel definiert, die
     dann angewendet wird, wenn das Argument eine ganze Zahl
     repräsentiert.

          (%i1) isintegerp(x) := featurep(x, integer)$

          (%i2) let(tan(x), sin(x)/cos(x), isintegerp, x);
          (%o2) tan(x) --> sin(x)/cos(x) where isintegerp(x)

          (%i3) letsimp(tan(x));
          (%o3) tan(x)

          (%i4) declare(x, integer)$

          (%i5) letsimp(tan(x));
          (%o5) sin(x)/cos(x)
          (%i6) letsimp(tan(1));
          (%o6) tan(1)

     Weitere Beispiele:

          (%i1) matchdeclare ([a, a1, a2], true)$
          (%i2) oneless (x, y) := is (x = y-1)$
          (%i3) let (a1*a2!, a1!, oneless, a2, a1);
          (%o3)         a1 a2! --> a1! where oneless(a2, a1)
          (%i4) letrat: true$
          (%i5) let (a1!/a1, (a1-1)!);
                                  a1!
          (%o5)                   --- --> (a1 - 1)!
                                  a1
          (%i6) letsimp (n*m!*(n-1)!/m);
          (%o6)                      (m - 1)! n!
          (%i7) let (sin(a)^2, 1 - cos(a)^2);
                                  2               2
          (%o7)                sin (a) --> 1 - cos (a)
          (%i8) letsimp (sin(x)^4);
                                  4           2
          (%o8)                cos (x) - 2 cos (x) + 1

 -- Optionsvariable: let_rule_packages
     Standardwert: `[default_let_rule_package]'

     `let_rule_packages' ist eine Informationsliste mit den vom Nutzer
     mit der Funktion `let'  definierten Regelpaketen.

 -- Optionsvariable: letrat
     Standardwert: `false'

     Hat die Optionsvariable `letrat' den Wert `false', werden von der
     Funktion `letsimp'  der Zähler und der Nenner eines Bruches einzeln
     vereinfacht.  Der Bruch als ganzes wird dagegen nicht vereinfacht.

     Hat die Optionsvariable `letrat' den Wert `true', werden
     nacheinander der Zähler, der Nenner und dann der Bruch vereinfacht.

     Beispiele:

          (%i1) matchdeclare (n, true)$
          (%i2) let (n!/n, (n-1)!);
                                   n!
          (%o2)                    -- --> (n - 1)!
                                   n
          (%i3) letrat: false$
          (%i4) letsimp (a!/a);
                                         a!
          (%o4)                          --
                                         a
          (%i5) letrat: true$
          (%i6) letsimp (a!/a);
          (%o6)                       (a - 1)!

 -- Funktion: letrules ()
 -- Funktion: letrules (<package_name>)
     Zeigt die Regeln eines Regelpaketes an.  Das Kommando `letrules()'
     zeigt die Regeln des aktuellen Regelpaketes an, das durch die
     Optionsvariable `current_let_rule_package'  bezeichnet wird.  Das
     Kommando `letrules(<package_name>)' zeigt die Regeln des Paketes
     <package_name> an.

     Wenn der Optionsvariablen `current_let_rule_package' kein Name
     eines Paketes zugewiesen wurde, enthält es den Standardwert
     `default_let_rule_package'.

     Siehe auch die Funktion `disprule',  um Regeln anzuzeigen, die mit
     den Funktionen `tellsimp',  `tellsimpafter'  und `defrule'

     definiert wurden.

     Beispiel:

     Im folgenden Beispiel werden einem Paket mit dem Namen `trigrules'
     zwei Regeln hinzugefügt.  Die Regeln werden mit dem Kommando
     `letrules(trigrules)' angezeigt.  Wird das Paket zum aktuellen
     Paket erklärt, indem es der Variablen `current_let_rule_package'
     zugewiesen wird, dann werden die Regeln auch mit dem Kommando
     `letrules()' angezeigt.

          (%i1) let([sin(x)^2, 1-cos(x)^2], trigrules);
                                  2               2
          (%o1)                sin (x) --> 1 - cos (x)
          (%i2) let([tan(x), sin(x)/cos(x)], trigrules);
                                             sin(x)
          (%o2)                   tan(x) --> ------
                                             cos(x)
          (%i3) letrules(trigrules);
                                             sin(x)
                                  tan(x) --> ------
                                             cos(x)

                                  2               2
                               sin (x) --> 1 - cos (x)

          (%o3)                         done
          (%i4) letrules();
          (%o4)                         done
          (%i5) current_let_rule_package: trigrules;
          (%o5)                       trigrules
          (%i6) letrules();
                                             sin(x)
                                  tan(x) --> ------
                                             cos(x)

                                  2               2
                               sin (x) --> 1 - cos (x)

          (%o6)                         done

 -- Funktion: letsimp (<expr>)
 -- Funktion: letsimp (<expr>, <package_name>)
 -- Funktion: letsimp (<expr>, <package_name_1>, ..., <package_name_n>)
     Wendet die Regeln, die mit der Funktion `let'  definiert sind,
     solange an, bis sich das Argument <expr> nicht mehr ändert.
     `letsimp(<expr>)' wendet die aktuellen Regeln an, die mit der
     Optionsvariablen `current_let_rule_package'  bezeichnet werden.

     `letsimp(<expr>, <package_name>)' wendet die Regeln des Argumentes
     <package_name> an.  Die Optionsvariable `current_let_rule_package'
     ändert ihren Wert nicht.  Es können auch mehrere Regelpakete
     <package_name_1>, ..., <package_name_n> angegeben werden.

     Die Optionsvariable `letrat'  kontrolliert die Vereinfachung von
     Quotienten durch `letsimp'.  Hat `letrat' den Wert `false', werden
     der Zähler und der Nenner eines Bruches einzeln vereinfacht.  Der
     Bruch als ganzes wird dagegen nicht vereinfacht.  Hat die
     Optionsvariable `letrat' den Wert `true', werden nacheinander der
     Zähler, der Nenner und dann der Bruch vereinfacht.

 -- Funktion: matchdeclare (<a_1>, <pred_1>, ..., <a_n>, <pred_n>)
     Mit der Funktion `matchdeclare' werden Mustervariablen definiert.
     `matchdeclare' ordnet eine Aussagefunktion <pred_k> einer Variable
     oder eine Liste von Variablen <a_k> zu, so dass <a_k> bei einem
     Musterabgleich mit Ausdrücken übereinstimmt, für die die Aussage
     ein anderes Ergebnis als `false' hat.

     Eine Aussagefunktion <pred_i> kann durch den Namen einer Funktion,
     einen Lambda-Ausdruck, einen Funktionsaufruf, einen
     Lambda-Ausdruck, dem das letzte Argument fehlt, oder die Werte
     `true' oder `all' bezeichnet werden.  Ist die Aussagefunktion ein
     Funktionsaufruf oder ein Lambda-Aufruf, dann wird der zu testende
     Ausdruck der Liste der Argumente hinzugefügt.  Die Argumente
     werden ausgewertet, wenn der Musterabgleich ausgeführt wird.  Ist
     die Aussage der Name einer Funktion oder ein Lambda-Ausdruck, ist
     die zu testende Aussage das einzige Argument.  Die Aussagefunktion
     braucht noch nicht definiert zu sein, wenn mit `matchdeclare' eine
     Mustervariable definiert wird, da die Aussagefunktion erst
     aufgerufen wird, wenn ein Musterabgleich durchgeführt wird.

     Eine Aussagefunktion kann einen logischen Ausdruck oder die Werte
     `true' oder `false' zurückgeben.  Logische Ausdrücke werden von
     der Funktion `is'  ausgewertet, wenn die Regel angewendet wird.
     Daher ist es nicht notwendig, dass die Aussagefunktion selbst die
     Funktion `is' aufruft.

     Wenn für einen Ausdruck eine Übereinstimmung bei einem
     Musterabgleich gefunden wird, wird der Mustervariablen der
     Ausdruck zugewiesen.  Jedoch nicht für Mustervariablen, die
     Argumente der Addition `+' oder Multiplikation `*' sind.  Diese
     Operatoren werden besonders behandelt.  Andere Maxima oder vom
     Nutzer definierte N-ary-Operatoren werden dagegen wie normale
     Funktionen behandelt.

     Im Falle der Addition und der Multiplikation kann der
     Mustervariablen ein einzelner Term zugewiesen werden, für den der
     Musterabgleich zu einer Überstimmung führt, oder auch eine Summe
     oder ein Produkt von Termen.  Die mehrfache Übereinstimmung hat
     Vorrang.  Aussagefunktionen werden in der Reihenfolge ausgewertet,
     in der die der Aussagefunktion zugeordneten Mustervariablen im
     Muster auftreten.  Führt der Musterabgleich für einen Term zu
     einer Übereinstimmung mit mehreren Aussagefunktionen, dann wird der
     Term der Mustervariablen zugeordnet für den die erste
     Aussagefunktion zutrifft.  Jede Aussagefunktion wird zunächst auf
     alle Argumente einer Summe oder eines Produktes angewendet, bevor
     die nächste Aussagefunktion ausgewertet wird.  Wird für die Zahlen
     0 oder 1 eine Übereinstimmung gefunden und es sind keine weiteren
     Terme vorhanden, wird der Mustervariablen 0 oder 1 zugewiesen.

     Der Algorithmus, um Muster abzugleichen, die die Addition oder die
     Multiplikation als Operanden enthalten, kann von der Anordnung der
     Terme im Muster oder im zu prüfenden Ausdruck abhängen.  Solange
     sich jedoch die einzelnen Aussagefunktionen gegeneinander
     ausschließen, wird das Ergebnis nicht von der Reihenfolge der
     Argumente beeinflußt.

     Der Aufruf von `matchdeclare' für eine Variable <a> überschreibt
     eine vorhergehende Definition für diese Variable.  Wird eine Regel
     definiert, ist die letzte mit `matchdeclare' definierte Zuordnung
     zu einer Aussagefunktion wirksam.  Der erneute Aufruf von
     `matchdeclare' für eine Variable hat keinen Einfluss auf bereits
     vorhandene Regeln.

     Das Kommando `propvars(matchdeclare)' gibt eine Liste der Variablen
     zurück, die mit `matchdeclare' als Mustervariable definiert sind.
     `printprops(<a>, matchdeclare)' gibt die der Variable <a>
     zugeordnete Aussagefunktion zurück.  `printprops(all,
     matchdeclare)' gibt die Aussagefunktionen aller Mustervariablen
     zurück.  Mit dem Kommando `remove(<a>, matchdeclare)' wird die
     Definition von <a> als Mustervariable entfernt.  Siehe auch die
     Funktionen `propvars',

     `printprops'  und `remove'.

     Mit den Funktionen `defmatch',  `defrule',

     `tellsimp',  `tellsimpafter'  und `let'  werden Regeln definiert,
     die für Ausdrücke einen Musterabgleich ausführen, wobei die
     Mustervariablen mit den Werten belegt werden, für die eine
     Übereinstimmung gefunden wird.

     `matchdeclare' wertet die Argumente nicht aus.  `matchdeclare' gibt
     immer `done' als Ergebnis zurück.

     Beispiele:

     Eine Aussagefunktion kann mit dem Namen einer Funktion, einem
     Lambda-Ausdruck, einem Funktionsaufruf, einem Lambda-Ausdruck, dem
     das letzte Argument fehlt, oder den Werten `true' oder `all'
     bezeichnet werden.

          (%i1) matchdeclare (aa, integerp);
          (%o1)                         done
          (%i2) matchdeclare (bb, lambda ([x], x > 0));
          (%o2)                         done
          (%i3) matchdeclare (cc, freeof (%e, %pi, %i));
          (%o3)                         done
          (%i4) matchdeclare (dd, lambda ([x, y], gcd (x, y) = 1) (1728));
          (%o4)                         done
          (%i5) matchdeclare (ee, true);
          (%o5)                         done
          (%i6) matchdeclare (ff, all);
          (%o6)                         done

     Wird für einen Ausdruck beim Musterabgleich eine Übereinstimmung
     gefunden, wird dieser der Mustervariablen zugewiesen.

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) defrule (r1, bb^aa, ["integer" = aa, "atom" = bb]);
                              aa
          (%o2)        r1 : bb   -> [integer = aa, atom = bb]
          (%i3) r1 (%pi^8);
          (%o3)               [integer = 8, atom = %pi]

     Im Falle der Addition und Multiplikation kann der Mustervariablen
     ein einzelner Term zugewiesen werden, welcher mit der Aussage
     übereinstimmt, aber auch eine Summe oder ein Produkt solcher
     Ausdrücke.

          (%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
          (%o1)                         done
          (%i2) defrule (r1, aa + bb, ["all atoms" = aa, "all nonatoms" =
                         bb]);
          bb + aa partitions `sum'
          (%o2)  r1 : bb + aa -> [all atoms = aa, all nonatoms = bb]
          (%i3) r1 (8 + a*b + sin(x));
          (%o3)     [all atoms = 8, all nonatoms = sin(x) + a b]
          (%i4) defrule (r2, aa * bb, ["all atoms" = aa, "all nonatoms" =
                         bb]);
          bb aa partitions `product'
          (%o4)   r2 : aa bb -> [all atoms = aa, all nonatoms = bb]
          (%i5) r2 (8 * (a + b) * sin(x));
          (%o5)    [all atoms = 8, all nonatoms = (b + a) sin(x)]

     Wird nach Übereinstimmungen für die Argumente der Operatoren `+'
     oder `*' gesucht und schließen sich die Aussagefunktionen
     gegeneinander aus, ist das Ergebnis unabhängig von der Anordnung
     der Terme.

          (%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
          (%o1)                         done
          (%i2) defrule (r1, aa + bb, ["all atoms" = aa, "all nonatoms" =
                         bb]);
          bb + aa partitions `sum'
          (%o2)  r1 : bb + aa -> [all atoms = aa, all nonatoms = bb]
          (%i3) r1 (8 + a*b + %pi + sin(x) - c + 2^n);
                                                               n
          (%o3) [all atoms = %pi + 8, all nonatoms = sin(x) + 2  - c + a b]
          (%i4) defrule (r2, aa * bb, ["all atoms" = aa, "all nonatoms" =
                         bb]);
          bb aa partitions `product'
          (%o4)   r2 : aa bb -> [all atoms = aa, all nonatoms = bb]
          (%i5) r2 (8 * (a + b) * %pi * sin(x) / c * 2^n);
                                                            n
                                                   (b + a) 2  sin(x)
          (%o5) [all atoms = 8 %pi, all nonatoms = -----------------]
                                                           c

     Die Funktionen `propvars'  und `printprops'  geben Informationen
     über Mustervariablen aus.

          (%i1) matchdeclare ([aa, bb, cc], atom, [dd, ee], integerp);
          (%o1)                         done
          (%i2) matchdeclare (ff, floatnump, gg, lambda ([x], x > 100));
          (%o2)                         done
          (%i3) propvars (matchdeclare);
          (%o3)             [aa, bb, cc, dd, ee, ff, gg]
          (%i4) printprops (ee, matchdeclare);
          (%o4)                    [integerp(ee)]
          (%i5) printprops (gg, matchdeclare);
          (%o5)              [lambda([x], x > 100, gg)]
          (%i6) printprops (all, matchdeclare);
          (%o6) [lambda([x], x > 100, gg), floatnump(ff), integerp(ee),
                                integerp(dd), atom(cc), atom(bb), atom(aa)]

 -- Optionsvariable: maxapplydepth
     Standardwert: 10000

     `maxapplydepth' ist die maximale Verschachtelungstiefe für die die
     Funktionen `apply1'  und `apply2'  auf die Baumstruktur eines
     Ausdrucks angewendet werden.

 -- Optionsvariable: maxapplyheight
     Standardwert: 10000

     `maxapplyheight' ist die maximale Verschachtelungstiefe für die die
     Funktion `applyb1'  Bottom-up auf die Baumstruktur eines Ausdrucks
     angewendet wird.

 -- Funktion: remlet (<prod>, <package_name>)
 -- Funktion: remlet ()
 -- Funktion: remlet (all)
 -- Funktion: remlet (all, <package_name>)
     Entfernt die Regel <prod> -> <repl>, die zuletzt mit der Funktion
     `let'  definiert wurde.  Wird mit dem Argument <package_name> ein
     Paket angegeben, wird die Regeln aus dem entsprechenden Paket
     entfernt.

     `remlet()' und `remlet(all)' entfernen alle Regeln aus dem
     aktuellen Paket, das mit `current_let_rule_package'  bezeichnet
     ist.  Wird der Name eines Regelpaketes als Argument angegeben,
     werden zusätzlich die Regeln dieses Paketes entfernt.

     Soll eine vorhandene Regel durch eine neue Definition ersetzt
     werden, muss die Regel nicht zuvor mit `remlet' entfernt werden.
     Die neue Definition überschreibt eine vorhandene Regel.  Wurde
     eine vorhandene Regel überschrieben und wird die letzte Regel
     entfernt, dann ist die vorhergehende Regel wieder aktiv.

     Siehe auch die Funktion `remrule',  um Regeln zu entfernen, die mit
     den Funktionen `tellsimp'  oder `tellsimpafter'  definiert sind.

 -- Funktion: remrule (<op>, <rulename>)
 -- Funktion: remrule (<op>, all)
     Entfernt Regeln, die mit den Funktionen `tellsimp'  oder
     `tellsimpafter'  definiert sind.

     `remrule(<op>, <rulename>)' entfernt die Regel mit dem Namen
     <rulename> vom Operator <op>.  Ist der Operator <op> ein
     Maxima-Operator oder ein nutzerdefinierter Operator, der mit
     Funktionen wie `infix'  oder `prefix'  definiert wurde, muss der
     Name des Operators <op> als eine Zeichenkette in Anführungszeichen
     angegeben werden.

     `remrule(<op>, all)' entfernt alle Regeln des Operators <op>.

     Siehe auch die Funktion `remlet',  um Regeln zu entfernen, die mit
     der Funktion `let'  definiert sind.

     Beispiele:

          (%i1) tellsimp (foo (aa, bb), bb - aa);
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (aa + bb, special_add (aa, bb));
          (%o2)                   [+rule1, simplus]
          (%i3) infix ("@@");
          (%o3)                          @@
          (%i4) tellsimp (aa @@ bb, bb/aa);
          (%o4)                   [@@rule1, false]
          (%i5) tellsimpafter (quux (%pi, %e), %pi - %e);
          (%o5)                  [quuxrule1, false]
          (%i6) tellsimpafter (quux (%e, %pi), %pi + %e);
          (%o6)             [quuxrule2, quuxrule1, false]
          (%i7) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
                 quux (%e, %pi)];
                                               bb
          (%o7) [bb - aa, special_add(aa, bb), --, %pi - %e, %pi + %e]
                                               aa
          (%i8) remrule (foo, foorule1);
          (%o8)                          foo
          (%i9) remrule ("+", ?\+rule1);
          (%o9)                           +
          (%i10) remrule ("@@", ?\@\@rule1);
          (%o10)                         @@
          (%i11) remrule (quux, all);
          (%o11)                        quux
          (%i12) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
                  quux (%e, %pi)];
          (%o12) [foo(aa, bb), bb + aa, aa @@ bb, quux(%pi, %e),
                                                   quux(%e, %pi)]

 -- Systemvariable: rules
     Standardwert: `[]'

     `rules' ist eine Informationsliste, die die vom Nutzer mit den
     Funktionen `tellsimp', `tellsimpafter', `defmatch' oder `defrule'
     definierten Regeln enthält.

     Regeln, die mit der Funktion `let'  definiert sind, sind nicht in
     der Liste `rules' enthalten.  Diese Regeln werden in Paketen
     organisiert, die in der Systemvariablen `let_rule_packages'
     aufgelistet und mit der Funktion `letrules'  angezeigt werden.

     Siehe auch die Systemvariable `infolists'.


 -- Funktion: tellsimp (<pattern>, <replacement>)
     `tellsimp' ist vergleichbar mit der Funktion `tellsimpafter',

     wobei mit `tellsimp' Regeln für die Vereinfachung von Ausdrücken
     definiert werden, die noch vor den Regeln angewendet werden, die
     intern in Maxima bekannt sind.

     `tellsimp' wird daher eingesetzt, wenn Maxima Regeln für die
     Vereinfachung des Ausdruckes kennt, es jedoch notwendig ist, noch
     vor Anwendung dieser Regeln den Ausdruck auf eine andere Art zu
     modifizieren.  Für den Fall das Maxima den Ausdruck nicht
     ausreichend vereinfacht, kann es besser sein, eine Regel mit der
     Funktion `tellsimpafter'  zu definieren.

     Das Argument <pattern> kann keine Summe, kein Produkt, keine
     einzelne Variable und keine Zahl sein.

     Regeln die mit `tellsimp' definiert werden, werden in die
     Informationsliste `rules'  aufgenommen.

     Beispiele:

          (%i1) matchdeclare (x, freeof (%i));
          (%o1)                         done
          (%i2) %iargs: false$
          (%i3) tellsimp (sin(%i*x), %i*sinh(x));
          (%o3)                 [sinrule1, simp-%sin]
          (%i4) trigexpand (sin (%i*y + x));
          (%o4)         sin(x) cos(%i y) + %i cos(x) sinh(y)
          (%i5) %iargs:true$
          (%i6) errcatch(0^0);
           0
          0  has been generated
          (%o6)                          []
          (%i7) ev (tellsimp (0^0, 1), simp: false);
          (%o7)                  [^rule1, simpexpt]
          (%i8) 0^0;
          (%o8)                           1
          (%i9) remrule ("^", %th(2)[1]);
          (%o9)                           ^
          (%i10) tellsimp (sin(x)^2, 1 - cos(x)^2);
          (%o10)                 [^rule2, simpexpt]
          (%i11) (1 + sin(x))^2;
                                                2
          (%o11)                    (sin(x) + 1)
          (%i12) expand (%);
                                             2
          (%o12)               2 sin(x) - cos (x) + 2
          (%i13) sin(x)^2;
                                            2
          (%o13)                     1 - cos (x)
          (%i14) kill (rules);
          (%o14)                        done
          (%i15) matchdeclare (a, true);
          (%o15)                        done
          (%i16) tellsimp (sin(a)^2, 1 - cos(a)^2);
          (%o16)                 [^rule3, simpexpt]
          (%i17) sin(y)^2;
                                            2
          (%o17)                     1 - cos (y)

 -- Funktion: tellsimpafter (<pattern>, <replacement>)
     Definiert eine Regel für die Vereinfachung eines Ausdrucks, die
     nach Anwendung der Regeln angewendet wird, die Maxima intern
     kennt.  <pattern> ist ein Ausdruck, der Mustervariablen enthält,
     die mit der Funktion `matchdeclare'  definiert sind und weitere
     Symbole und Operatoren, für die die wörtliche Übereinstimmung bei
     einem Musterabgleich angenommen wird.  <replacement> wird in den
     Ausdruck substituiert, wenn der Musterabgleich das Muster
     <pattern> im Ausdruck findet.  Den Mustervariablen in
     <replacement> werden die Werte des Musterabgleichs zugewiesen.

     Das Muster <pattern> kann ein beliebiger Ausdruck sein, in dem der
     Hauptoperator keine Mustervariable ist.  Die neue Regel wird nach
     dem Hauptoperator des Musters benannt und diesem zugeordnet.  Der
     Name von Funktionen, mit einer unten beschriebenen Ausnahme,
     Listen und Arrays können in <pattern> nicht als eine
     Mustervariable auftreten.  Daher können Ausdrücke wie `aa(x)' oder
     `bb[y]' nicht als Muster verwendet werden, wenn `aa' oder `bb'
     Mustervariablen sind.  Die Namen von Funktionen, Listen und
     Arrays, welche Mustervariablen sind, können dann in dem Muster
     <pattern> auftreten, wenn sie nicht der Hauptoperator sind.

     Es gibt eine Ausnahme der oben genannten Einschränkung für die
     Verwendung von Funktionsnamen.  Der Name einer indizierten
     Funktion wie `aa[x](y)' kann eine Mustervariable sein, da der
     Hauptoperator nicht `aa' ist, sondern das interne Symbol
     `mqapply'.  Dies ist eine Konsequenz der internen Darstellung
     einer indizierten Funktion.

     Regeln für die Vereinfachung werden nach der Auswertung eines
     Ausdrucks angewendet, sofern die Auswertung, zum Beispiel mit dem
     Schalter `noeval',  nicht unterdrückt wurde.  Regeln, die mit
     `tellsimpafter' definiert sind, werden nach den internen Regeln
     und in der Reihenfolge angewendet, in der sie definiert sind.  Die
     Regeln für die Vereinfachung werden zunächst für Teilausdrücke und
     zuletzt für den ganzen Ausdruck angewendet.  Es kann notwendig
     sein, Regeln für die Vereinfachung mehrfach zum Beispiel mit dem
     Quote-Quote-Operator

     `''' oder dem Auswertungsschalter `infeval'  anzuwenden, um zu
     erreichen, dass alle Regeln angewendet werden.

     Mustervariable werden als lokale Variablen in Regeln für die
     Vereinfachung behandelt.  Sobald eine Regel definiert ist,
     beeinflusst die Zuweisung eines Wertes an die Mustervariable nicht
     die Regel und die Variable wird nicht von der Regel beeinflusst.
     Die Zuweisung an eine Mustervariable, die aufgrund eines
     erfolgreichen Musterabgleichs vorgenommen wird, beeinflusst nicht
     den aktuellen Wert der Variablen.  Jedoch sind die Eigenschaften
     der Mustervariablen, wie sie zum Beispiel auch mit der Funktion
     `put'  definiert werden können, global in Maxima.

     Eine mit `tellsimpafter' definierte Regel wird nach dem
     Hauptoperator des Musters <pattern> benannt.  Regeln für
     Maxima-Operatoren und für Funktionen, die mit `infix',  `prefix',
     `postfix',

     `matchfix'  und `nofix'  als Operator definiert sind, haben einen
     Lisp-Bezeichner als Namen.  Alle anderen Regeln erhalten einen
     Maxima-Bezeichner als Namen.

     `tellsimpafter' wertet die Argumente nicht aus.  `tellsimpafter'
     gibt eine Liste der Regeln zurück, die für den Hauptoperator des
     Musters <pattern> definiert sind.

     Siehe auch die Funktionen `matchdeclare',  `defmatch',

     `defrule',  `tellsimp',  `remrule'  und `clear_rules'.

     Beispiele:

     Das Muster <pattern> kann ein beliebiger Ausdruck sein, in dem der
     Hauptoperator keine Mustervariable ist.

          (%i1) matchdeclare (aa, atom, [ll, mm], listp, xx, true)$
          (%i2) tellsimpafter (sin (ll), map (sin, ll));
          (%o2)                 [sinrule1, simp-%sin]
          (%i3) sin ([1/6, 1/4, 1/3, 1/2, 1]*%pi);
                              1  sqrt(2)  sqrt(3)
          (%o3)              [-, -------, -------, 1, 0]
                              2     2        2
          (%i4) tellsimpafter (ll^mm, map ("^", ll, mm));
          (%o4)                  [^rule1, simpexpt]
          (%i5) [a, b, c]^[1, 2, 3];
                                          2   3
          (%o5)                      [a, b , c ]
          (%i6) tellsimpafter (foo (aa (xx)), aa (foo (xx)));
          (%o6)                   [foorule1, false]
          (%i7) foo (bar (u - v));
          (%o7)                    bar(foo(u - v))

     Regeln werden in der Reihenfolge angewendet, in der sie definiert
     sind.  Treffen zwei Regeln bei einem Musterabgleich zu, wird die
     zuerst definierte Regel angewendet.

          (%i1) matchdeclare (aa, integerp);
          (%o1)                         done
          (%i2) tellsimpafter (foo (aa), bar_1 (aa));
          (%o2)                   [foorule1, false]
          (%i3) tellsimpafter (foo (aa), bar_2 (aa));
          (%o3)              [foorule2, foorule1, false]
          (%i4) foo (42);
          (%o4)                       bar_1(42)

     Mustervariable werden als lokale Variable beim Musterabgleich der
     mit der Funktion `tellsimpafter' definierten Regel behandelt.  Im
     Unterschied dazu werden von Regeln, die mit `defmatch'  definiert
     sind, Mustervariable als globale Variable behandelt.

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
          (%o2)                   [foorule1, false]
          (%i3) bb: 12345;
          (%o3)                         12345
          (%i4) foo (42, %e);
          (%o4)                 bar(aa = 42, bb = %e)
          (%i5) bb;
          (%o5)                         12345

     Die Eigenschaften von Mustervariablen sind global, auch wenn die
     Werte lokal sind.  In diesem Beispiel wird eine Eigenschaft für
     die Zuweisung an eine Variable mit der Funktion `define_variable'
     definiert.  Die Eigenschaft des Symbols `bb' ist global in Maxima.

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
          (%o2)                   [foorule1, false]
          (%i3) foo (42, %e);
          (%o3)                 bar(aa = 42, bb = %e)
          (%i4) define_variable (bb, true, boolean);
          (%o4)                         true
          (%i5) foo (42, %e);
          Error: bb was declared mode boolean, has value: %e
           -- an error.  Quitting.  To debug this try debugmode(true);

     Regeln werden nach dem Hauptoperator benannt.  Die Namen der
     Regeln für Maxima-Funktionen und nutzerdefinierte Operatoren sind
     Lisp-Bezeichner.  Alle anderen Namen sind Maxima-Bezeichner.

          (%i1) tellsimpafter (foo (%pi + %e), 3*%pi);
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (foo (%pi * %e), 17*%e);
          (%o2)              [foorule2, foorule1, false]
          (%i3) tellsimpafter (foo (%i ^ %e), -42*%i);
          (%o3)         [foorule3, foorule2, foorule1, false]
          (%i4) tellsimpafter (foo (9) + foo (13), quux (22));
          (%o4)                   [+rule1, simplus]
          (%i5) tellsimpafter (foo (9) * foo (13), blurf (22));
          (%o5)                  [*rule1, simptimes]
          (%i6) tellsimpafter (foo (9) ^ foo (13), mumble (22));
          (%o6)                  [^rule1, simpexpt]
          (%i7) rules;
          (%o7) [foorule1, foorule2, foorule3, +rule1, *rule1, ^rule1]
          (%i8) foorule_name: first (%o1);
          (%o8)                       foorule1
          (%i9) plusrule_name: first (%o4);
          (%o9)                        +rule1
          (%i10) remrule (foo, foorule1);
          (%o10)                         foo
          (%i11) remrule ("^", ?\^rule1);
          (%o11)                          ^
          (%i12) rules;
          (%o12)        [foorule2, foorule3, +rule1, *rule1]

     Ein ausgearbeitetes Beispiel der nicht-kommutativen Multiplikation.

          (%i1) gt (i, j) := integerp(j) and i < j;
          (%o1)           gt(i, j) := integerp(j) and i < j
          (%i2) matchdeclare (i, integerp, j, gt(i));
          (%o2)                         done
          (%i3) tellsimpafter (s[i]^^2, 1);
          (%o3)                 [^^rule1, simpncexpt]
          (%i4) tellsimpafter (s[i] . s[j], -s[j] . s[i]);
          (%o4)                   [.rule1, simpnct]
          (%i5) s[1] . (s[1] + s[2]);
          (%o5)                    s  . (s  + s )
                                    1     2    1
          (%i6) expand (%);
          (%o6)                      1 - s  . s
                                          2    1
          (%i7) factor (expand (sum (s[i], i, 0, 9)^^5));
          (%o7) 100 (s  + s  + s  + s  + s  + s  + s  + s  + s  + s )
                      9    8    7    6    5    4    3    2    1    0


File: maxima.info,  Node: Funktionsdefinitionen,  Next: Laufzeitumgebung,  Prev: Muster und Regeln,  Up: Top

25 Funktionsdefinitionen
************************

* Menu:

* Funktionen::
* Makros::
* Funktionen und Variablen für Funktionsdefinitionen::


File: maxima.info,  Node: Funktionen,  Next: Makros,  Prev: Funktionsdefinitionen,  Up: Funktionsdefinitionen

25.1 Funktionen
===============

25.1.1 Gewöhnliche Funktionen
-----------------------------

Eine Maxima-Funktion wird mit dem Operator `:='  oder der Funktion
`define'  definiert.  Im folgenden wird die Funktion `f' mit dem
Operator `:=' definiert:

     f(x) := sin(x)

Funktionen, die mit der Funktion `lambda'  definiert werden, sind
anonyme Funktionen, die keinen Namen haben.  Diese werden auch
`lambda'-Ausdrücke genannt:

     lambda ([i, j], ...)

Anonyme Funktionen können überall dort verwendet werden, wo eine
Funktion als Argument erwartet wird.  Das folgende Beispiel gibt eine
Liste zurück, bei der jedes Element der Liste `L' mit 1 addiert wird:

     map (lambda ([i], i+1), L)

Ist das letzte oder einzige Argument einer Funktion eine Liste mit einem
Element, kann eine variable Anzahl an Argumenten an die Funktion
übergeben werden:

     (%i1) f ([u]) := u;
     (%o1)                      f([u]) := u
     (%i2) f (1, 2, 3, 4);
     (%o2)                     [1, 2, 3, 4]
     (%i3) f (a, b, [u]) := [a, b, u];
     (%o3)               f(a, b, [u]) := [a, b, u]
     (%i4) f (1, 2, 3, 4, 5, 6);
     (%o4)                 [1, 2, [3, 4, 5, 6]]

Die rechte Seite einer Funktionsdefinition ist ein Ausdruck.  Mehrere
Ausdrücke werden durch Kommata getrennt und mit Klammern umgeben.  Das
Ergebnis der Funktion ist der Wert des letzten Ausdrucks `exprn':

     f(x) := (expr1, expr2, ...., exprn);

Ein Rücksprung mit der Anweisung `return'  aus einer Funktion ist
möglich, wenn die Definition der Funktion in einen Block eingefügt wird.
Ein Block wird mit der `block' -Anweisung definiert.  Das folgende
Beispiel hat entweder den Wert `a' oder den Wert des Ausdrucks <exprn>
als Ergebnis:

     block ([], expr1, ..., if (a > 10) then return(a), ..., exprn)

Das erste paar Klammern `[]' in einem Block enthält die Definition von
lokalen Variablen wie zum Beispiel `[a: 3, b, c: []]'.  Die Variablen
sind außerhalb des Blocks nicht sichtbar.  Die Werte von globalen
Variablen werden von den lokalen Werten überschrieben.  Außerhalb des
Blocks haben die Variablen, wenn vorhanden, wieder ihre alten Werte.
Die Zuweisung der Werte an die lokalen Variablen wird parallel
ausgeführt.

Im folgenden Beispiel wird der Wert der globalen Variablen <a> der
lokalen Variablen <a> zugewiesen.  Änderungen von <a> im Block wirken
sich nicht auf den globalen Wert der Variablen aus.

     block ([a: a], expr1, ... a: a+3, ..., exprn)

Die Anweisung `block ([x], ...)' bewirkt, dass `x' als lokale Variable
ohne einen Wert verwendet werden kann.

Die Argumente einer Funktion werden in gleicher Weise wie lokal
definierte Variable behandelt.  Die folgende Definition

     f(x) := (expr1, ..., exprn);

mit

     f(1);

hat denselben Effekt wie der folgende Block:

     block ([x: 1], expr1, ..., exprn)

Soll die rechte Seite einer Funktionsdefinition ausgewertet werden,
kann die Funktionen `define'  für die Definition der Funktion verwendet
werden.  Mit der Funktion `buildq'  kann die Definition einer Funktion
konstruiert werden, wobei die Auswertung gezielt kontrolliert werden
kann.

25.1.2 Array-Funktionen
-----------------------

Eine Array-Funktion speichert bei dem ersten Aufruf den Funktionswert
zu dem Argument.  Wird die Array-Funktion mit demselben Argument
aufgerufen, wird der gespeicherte Wert zurückgeben, ohne diesen neu zu
berechnen.  Dies wird auch Memoisation genannt.

Beispiel:

Das folgende Beispiel zeigt die Definition einer Array-Funktion `f', die
die Fakultät einer Zahl faktorisiert.  Im ersten Aufruf der Funktion
mit dem Argument `25000' wird eine Rechenzeit von etwa 24 Sekunden
benötigt.  Der zweite Aufruf mit demselben Argument gibt sofort den
abgespeicherten Wert zurück.

     (%i1) f[x]:=factor(x!);
     (%o1)                   f  := factor(x!)
                              x
     (%i2) showtime:true;
     Evaluation took 0.0000 seconds (0.0000 elapsed) using 0 bytes.
     (%o2)                         true
     (%i3) f[25000]$
     Evaluation took 23.9250 seconds (26.0790 elapsed) using 3829.778 MB.
     (%i4) f[25000]$
     Evaluation took 0.0000 seconds (0.0000 elapsed) using 0 bytes.

Die Namen der Array-Funktionen werden in die Informationsliste `arrays'

und nicht in die Liste `functions'  eingetragen.  `arrayinfo'  gibt eine
Liste der Argumente zurück, für die Werte gespeichert sind und
`listarray'  gibt die Werte zurück.  Die Funktionen `dispfun'  und
`fundef'  geben die Definition der Array-Funktion zurück.

Beispiele:

Mit dem obigen Beispiel werden die folgenden Ergebnisse ausgegeben.

     (%i5) arrays;
     (%o5)                          [f]
     (%i6) arrayinfo(f);
     (%o6)                 [hashed, 1, [25000]]
     (%i7) dispfun(f);
     (%t7)                   f  := factor(x!)
                              x
     (%o7)                         [%t7]

`arraymake'  erzeugt den Aufruf einer Array-Funktion.  Dies ist analog
zu der Funktion `funmake'  für gewöhnliche Funktionen.  `arrayapply'
wendet eine Array-Funktion auf die Argumente an.  Dies entspricht der
Funktion `apply'  für gewöhnliche Funktionen.  Die Funktion `map'  hat
keine Entsprechung für Array-Funktionen.  Vergleichbare Konstruktionen
sind `map(lambda([<x>], <a>[<x>]), <L>)' oder `makelist(<a>[<x>], <x>,
<L>)', wobei <L> eine Liste ist.

`remarray'  entfernt die Definition einer Array-Funktion einschließlich
der gespeicherten Werte.  Dies entspricht `remfunction'  für gewöhnliche
Funktionen.

`kill(<a>[<x>])' entfernt den für das Argument <x> gespeicherten Wert
einer Array-Funktion <a>.  Beim nächsten Aufruf von <a> mit dem
Argument <x> wird der Funktionswert neu berechnet.  Es gibt keine
Möglichkeit, alle gespeicherten Werte zu löschen, ohne dass die
Definition der Funktion entfernt wird.  Die Kommandos `kill(<a>)' und
`remarray(<a>)' löschen alle Werte einschließlich der Definition der
Funktion.


File: maxima.info,  Node: Makros,  Next: Funktionen und Variablen für Funktionsdefinitionen,  Prev: Funktionen,  Up: Funktionsdefinitionen

25.2 Makros
===========

 -- Funktion: buildq (<L>, <expr>)
     Die Variablen der Liste <L> werden in den Ausdruck <expr>
     substituiert.  Die Substitution wird parallel ausgeführt.  Das
     Ergebnis der Substitution wird vereinfacht, aber nicht ausgewertet.

     Die Elemente der Liste <L> sind Symbole oder Zuweisungen der Form
     `<symbol>: <value>'.  Die Zuweisungen werden parallel ausgewertet.
     Der Wert einer Variablen auf der rechten Seite einer Zuweisung ist
     der globale Wert in dem Kontext in dem `buildq' aufgerufen wird
     und nicht der lokale Wert einer vorhergehenden Zuweisung.  Erhält
     eine Variable keinen Wert, dann behält die Variable den globalen
     Wert.

     Dann werden die in der Liste <L> enthaltenen Variablen parallel in
     den Ausdruck <expr> substituiert.

     Enthält <expr> Ausdrücke der Form `splice(<x>)', muss die Variable
     <x> eine Liste sein.  Die Liste wird in den Ausdruck eingefügt.
     Siehe auch `splice'.

     Variablen in in dem Ausdruck <expr>, die nicht in <L> enthalten
     sind, werden nicht durch einen Wert ersetzt, auch wenn es eine
     globale Variable mit demselben Namen gibt, da der Ausdruck nicht
     ausgewertet wird.

     Beispiele:

     Der Variablen `a' wird der Wert zugewiesen.  Die Variable `b'
     erhält den globalen Wert.  Die Variable `c' hat keinen Wert.  Das
     Ergebnis ist ein nicht ausgewerteter Ausdruck.  Die Auswertung
     wird mit dem Quote-Quote-Operator  `''' erzwungen.

          (%i1) (a: 17, b: 29, c: 1729)$
          (%i2) buildq ([a: x, b], a + b + c);
          (%o2)                      x + c + 29
          (%i3) ''%;
          (%o3)                       x + 1758

     `e' ist eine Liste, die einmal als Argument der Funktion `foo'
     vorliegt und zum anderen in die Argumentliste der Funktion `bar'
     eingefügt wird.

          (%i1) buildq ([e: [a, b, c]], foo (x, e, y));
          (%o1)                 foo(x, [a, b, c], y)
          (%i2) buildq ([e: [a, b, c]], bar (x, splice (e), y));
          (%o2)                  bar(x, a, b, c, y)

     Das Ergebnis wird nach der Substitution vereinfacht, ansonsten
     hätten die beiden folgenden Beispiele dasselbe Ergebnis.

          (%i1) buildq ([e: [a, b, c]], splice (e) + splice (e));
          (%o1)                    2 c + 2 b + 2 a
          (%i2) buildq ([e: [a, b, c]], 2 * splice (e));
          (%o2)                        2 a b c

     Die Variablen der Liste <L> erhalten ihren Wert parallel,
     ansonsten wäre das erste Ergebnis `foo(b,b)'.  Substitutionen
     werden parallel ausgeführt.  Im Gegensatz dazu werden die
     Substitutionen mit der Funktion `subst'  nacheinander ausgeführt.

          (%i1) buildq ([a: b, b: a], foo (a, b));
          (%o1)                       foo(b, a)
          (%i2) buildq ([u: v, v: w, w: x, x: y, y: z, z: u],
                        bar (u, v, w, x, y, z));
          (%o2)                 bar(v, w, x, y, z, u)
          (%i3) subst ([u=v, v=w, w=x, x=y, y=z, z=u],
                       bar (u, v, w, x, y, z));
          (%o3)                 bar(u, u, u, u, u, u)

     Konstruktion einer Liste mit Gleichungen mit Variablen oder
     Ausdrücken auf der linken Seite und deren Werten auf der rechten
     Seite.  Die Funktion `macroexpand'  expandiert das Makro
     `show_values'.

          (%i1) show_values ([L]) ::= buildq ([L], map ("=", 'L, L))$
          (%i2) (a: 17, b: 29, c: 1729)$
          (%i3) show_values (a, b, c - a - b);
          (%o3)          [a = 17, b = 29, c - b - a = 1683]
          (%i4) macroexpand (show_values (a, b, c - a - b));
          (%o4)    map(=, '([a, b, c - b - a]), [a, b, c - b - a])

     Konstruktion einer Funktion.

          (%i1) curry (f, [a]) :=
                  buildq ([f, a], lambda ([[x]], apply (f, append (a, x))))$
          (%i2) by3 : curry ("*", 3);
          (%o2)        lambda([[x]], apply(*, append([3], x)))
          (%i3) by3 (a + b);
          (%o3)                       3 (b + a)

 -- Funktion: macroexpand (<expr>)
     Ist das Argument <expr> ein Makro, wird das Makro expandiert, ohne
     dass es ausgewertet wird.  Ansonsten wird <expr> zurückgegeben.

     Ist die Expansion des Makros selbst ein Makro, wird dieses Makro
     wiederholt expandiert.

     `macroexpand' wertet das Argument <expr> nicht aus.  Hat die
     Expansion des Makros Seiteneffekte, dann werden diese ausgeführt.

     Siehe auch `::='  und `macroexpand1'.

     Beispiele:

          (%i1) g (x) ::= x / 99;
                                              x
          (%o1)                      g(x) ::= --
                                              99
          (%i2) h (x) ::= buildq ([x], g (x - a));
          (%o2)            h(x) ::= buildq([x], g(x - a))
          (%i3) a: 1234;
          (%o3)                         1234
          (%i4) macroexpand (h (y));
                                        y - a
          (%o4)                         -----
                                         99
          (%i5) h (y);
                                      y - 1234
          (%o5)                       --------
                                         99

 -- Funktion: macroexpand1 (<expr>)
     Gibt die Makro-Expansion von <expr> zurück, ohne das Ergebnis
     auszuwerten.  Ist <expr> keine Makro-Funktion gibt `macroexpand1'
     das Argument <expr> zurück.

     `macroexpand1' wertet das Argument nicht aus.  Hat die Expansion
     des Makros Seiteneffekte, dann werden diese ausgeführt.

     Enthält die Expansion <expr> wiederum Makros, werden diese im
     Unterschied zur Funktion `macroexpand' nicht expandiert.

     Siehe auch `::='  und `macroexpand'.

     Beispiele:

          (%i1) g (x) ::= x / 99;
                                              x
          (%o1)                      g(x) ::= --
                                              99
          (%i2) h (x) ::= buildq ([x], g (x - a))$
          (%i3) a: 1234;
          (%o3)                         1234
          (%i4) macroexpand1 (h (y));
          (%o4)                       g(y - a)
          (%i5) h (y);
                                      y - 1234
          (%o5)                       --------
                                         99

 -- Optionsvariable: macroexpansion
     Standardwert: `false'

     `macroexpansion' kontrolliert die Expansion von Makros.

    `false'
          Die Expansion des Makros wird nicht für die aufrufende
          Funktion ersetzt.

    `expand'
          Wird die Makro-Funktion das erste Mal ausgewertet, wird die
          Expansion des Makros gespeichert.  Weitere Aufrufe werten das
          Makro nicht erneut aus.  Seiteneffekte, wie Zuweisungen an
          globale Variablen, werden nur bei der ersten Auswertung
          wirksam.  Die Expansion des Makros beeinflusst nicht andere
          Ausdrücke, die das Makro ebenfalls aufrufen.

    `displace'
          Wird die Makro-Funktion das erste mal ausgewertet, wird die
          Expansion des Makros in den aufrufenden Ausdruck eingesetzt.
          Weitere Aufrufe werten das Makro nicht erneut aus.
          Seiteneffekte, wie Zuweisungen an globale Variablen, werden
          nur bei der ersten Auswertung wirksam.  Die Expansion des
          Makros beeinflusst nicht andere Ausdrücke, die das Makro
          ebenfalls aufrufen.

     Beispiele:

     Hat `macroexpansion' den Wert `false', wird eine Makro-Funktion
     jedes mal aufgerufen, wenn der aufrufende Ausdruck ausgewertet
     wird.  Der aufrufende Ausdruck wird nicht modifiziert.

          (%i1) f (x) := h (x) / g (x);
                                            h(x)
          (%o1)                     f(x) := ----
                                            g(x)
          (%i2) g (x) ::= block (print ("x + 99 is equal to", x),
                                 return (x + 99));
          (%o2) g(x) ::= block(print("x + 99 is equal to", x),
                                                            return(x + 99))
          (%i3) h (x) ::= block (print ("x - 99 is equal to", x),
                                 return (x - 99));
          (%o3) h(x) ::= block(print("x - 99 is equal to", x),
                                                            return(x - 99))
          (%i4) macroexpansion: false;
          (%o4)                         false
          (%i5) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o5)                       --------
                                      a b + 99
          (%i6) dispfun (f);
                                            h(x)
          (%t6)                     f(x) := ----
                                            g(x)

          (%o6)                         done
          (%i7) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o7)                       --------
                                      a b + 99

     Hat `macroexpansion' den Wert `expand', wird eine Makro-Funktion
     nur einmal aufgerufen.  Der aufrufende Ausdruck wird nicht
     modifiziert.

          (%i1) f (x) := h (x) / g (x);
                                            h(x)
          (%o1)                     f(x) := ----
                                            g(x)
          (%i2) g (x) ::= block (print ("x + 99 is equal to", x),
                                 return (x + 99));
          (%o2) g(x) ::= block(print("x + 99 is equal to", x),
                                                            return(x + 99))
          (%i3) h (x) ::= block (print ("x - 99 is equal to", x),
                                 return (x - 99));
          (%o3) h(x) ::= block(print("x - 99 is equal to", x),
                                                            return(x - 99))
          (%i4) macroexpansion: expand;
          (%o4)                        expand
          (%i5) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o5)                       --------
                                      a b + 99
          (%i6) dispfun (f);
                                            h(x)
          (%t6)                     f(x) := ----
                                            g(x)

          (%o6)                         done
          (%i7) f (a * b);
                                      a b - 99
          (%o7)                       --------
                                      a b + 99

     Hat `macroexpansion' den Wert `displace', wird eine Makro-Funktion
     nur einmal aufgerufen.  Der aufrufende Ausdruck wird modifiziert.

          (%i1) f (x) := h (x) / g (x);
                                            h(x)
          (%o1)                     f(x) := ----
                                            g(x)
          (%i2) g (x) ::= block (print ("x + 99 is equal to", x),
                                 return (x + 99));
          (%o2) g(x) ::= block(print("x + 99 is equal to", x),
                                                            return(x + 99))
          (%i3) h (x) ::= block (print ("x - 99 is equal to", x),
                                 return (x - 99));
          (%o3) h(x) ::= block(print("x - 99 is equal to", x),
                                                            return(x - 99))
          (%i4) macroexpansion: displace;
          (%o4)                       displace
          (%i5) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o5)                       --------
                                      a b + 99
          (%i6) dispfun (f);
                                           x - 99
          (%t6)                    f(x) := ------
                                           x + 99

          (%o6)                         done
          (%i7) f (a * b);
                                      a b - 99
          (%o7)                       --------
                                      a b + 99

 -- Systemvariable: macros
     Standardwert: `[]'

     Die Systemvariable `macros' ist eine Informationsliste, die die
     vom Nutzer mit dem Operator `::='  definierten Makros enthält.
     Wird das Makro mit einer der Funktionen `kill',  `remove'  oder
     `remfunction'

     gelöscht, wird der Eintrag aus der Informationsliste entfernt.
     Siehe auch die Systemvariable `infolists'.


 -- Funktion: splice (<a>)
     Die Funktion `splice' kann nur im Zusammenhang mit der Funktion
     `buildq'  verwendet werden.  Das Argument <a> bezeichnet eine
     Liste, die an Stelle von `splice(a)' in einen Ausdruck eingefügt
     wird.  <a> kann nicht selbst eine Liste oder ein Ausdruck sein,
     der zu einer Liste auswertet.

     Beispiele:

          (%i1) buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
                                 foo(1, %pi, z - y)
          (%o1)                -----------------------
                               length([1, %pi, z - y])
          (%i2) buildq ([x: [1, %pi]], "/" (splice (x)));
                                          1
          (%o2)                          ---
                                         %pi
          (%i3) matchfix ("<>", "<>");
          (%o3)                          <>
          (%i4) buildq ([x: [1, %pi, z - y]], "<>" (splice (x)));
          (%o4)                   <>1, %pi, z - y<>


File: maxima.info,  Node: Funktionen und Variablen für Funktionsdefinitionen,  Prev: Makros,  Up: Funktionsdefinitionen

25.3 Funktionen und Variablen für Funktionsdefinitionen
=======================================================

 -- Funktion: apply (<F>, [<x_1>, ..., <x_n>])
     Konstruiert den Ausdruck `<F>(<arg_1>, ..., <arg_n>)' und wertet
     diesen aus.

     `apply' versucht nicht Array-Funktionen von gewöhnlichen
     Funktionen zu unterscheiden.  Ist <F> der Name eine
     Array-Funktion, wertet `apply' den Ausdruck `<F>(...)' aus.
     `arrayapply'  entspricht der Funktion `apply', wenn <F> eine
     Array-Funktion ist.

     Beispiele:

     `apply' wertet die Argumente aus.  In diesem Beispiel wird die
     Funktion `min'  auf die Liste `L' angewendet.

          (%i1) L : [1, 5, -10.2, 4, 3];
          (%o1)                 [1, 5, - 10.2, 4, 3]
          (%i2) apply (min, L);
          (%o2)                        - 10.2

     `apply' wertet die Argumente auch dann aus, wenn die Funktion `F'
     die Auswertung ihrer Argumente unterdrückt.

          (%i1) F (x) := x / 1729;
                                             x
          (%o1)                     F(x) := ----
                                            1729
          (%i2) fname : F;
          (%o2)                           F
          (%i3) dispfun (F);
                                             x
          (%t3)                     F(x) := ----
                                            1729

          (%o3)                         [%t3]
          (%i4) dispfun (fname);
          fname is not the name of a user function.
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) apply (dispfun, [fname]);
                                             x
          (%t5)                     F(x) := ----
                                            1729

          (%o5)                         [%t5]

     `apply' wertet den Namen der Funktion <F> aus.  Mit dem
     Quote-Operator  `'' wird die Auswertung unterdrückt.  `demoivre'
     ist der Name einer globalen Optionsvariable und einer Funktion.

          (%i1) demoivre;
          (%o1)                         false
          (%i2) demoivre (exp (%i * x));
          (%o2)                  %i sin(x) + cos(x)
          (%i3) apply (demoivre, [exp (%i * x)]);
          demoivre evaluates to false
          Improper name or value in functional position.
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) apply ('demoivre, [exp (%i * x)]);
          (%o4)                  %i sin(x) + cos(x)

 -- Funktion: define (<f>(<x_1>, ..., <x_n>), <expr>)
 -- Funktion: define (<f>[<x_1>, ..., <x_n>], <expr>)
 -- Funktion: define (funmake (<f>, [<x_1>, ..., <x_n>]), <expr>)
 -- Funktion: define (arraymake (<f>, [<x_1>, ..., <x_n>]), <expr>)
 -- Funktion: define (ev (<expr_1>), <expr_2>)
     Definiert eine Funktion mit dem Namen <f> und den Argumenten <x1>,
     ..., <x_n> und der Funktionsdefinition <expr>.  `define' wertet
     das zweite Argument immer aus.

     Ist das letzte oder einzige Argument <x_n> eine Liste mit einem
     Element, dann akzeptiert die Funktion eine variable Anzahl an
     Argumenten.  Die Argumente der Funktion werden nacheinander den
     Variablen <x_1>, ..., <x_(n-1)> zugewiesen.  Sind weitere
     Argumente vorhanden, werden diese als Liste der Variablen <x_n>
     zugewiesen.

     Ist das erste Argument der Funktion `define' ein Ausdruck der Form
     `<f>(<x_1>, ..., <x_n>)' oder `<f>[<x_1>, ..., <x_n>]' werden die
     Argumente der Funktion ausgewertet, aber nicht die Funktion <f>
     selbst.  <f> wird auch dann nicht ausgewertet, wenn es bereits
     eine Funktion mit dem Namen <f> gibt.

     Das erste Argument wird dann ausgewertet, wenn es ein Ausdruck mit
     den Funktionen `funmake',  `arraymake'  oder `ev'  ist.

     Alle Funktionsdefinitionen treten in demselben Namensraum auf.
     Die Definition einer Funktion `g' innerhalb einer Funktion `f'
     führt nicht automatisch zu einer lokalen Definition.  Um eine
     lokale Funktion zu erhalten, kann `lokal(g)' innerhalb der
     Funktion `f' ausgeführt werden.  Siehe auch `local'.

     Ist eines der Argumente <x_k> nach der Auswertung ein quotiertes
     Symbol, wertet die mit `define' definierte Funktion das Argument
     nicht aus.  Alle weiteren Argumente der Funktion werden
     ausgewertet.

     Siehe auch `:='  und `::='.

     Beispiele:

     `define' wertet das zweite Argument aus.

          (%i1) expr : cos(y) - sin(x);
          (%o1)                    cos(y) - sin(x)
          (%i2) define (F1 (x, y), expr);
          (%o2)              F1(x, y) := cos(y) - sin(x)
          (%i3) F1 (a, b);
          (%o3)                    cos(b) - sin(a)
          (%i4) F2 (x, y) := expr;
          (%o4)                   F2(x, y) := expr
          (%i5) F2 (a, b);
          (%o5)                    cos(y) - sin(x)

     Mit `define' können gewöhnliche Maxima-Funktionen und
     Array-Funktionen definiert werden.

          (%i1) define (G1 (x, y), x.y - y.x);
          (%o1)               G1(x, y) := x . y - y . x
          (%i2) define (G2 [x, y], x.y - y.x);
          (%o2)                G2     := x . y - y . x
                                 x, y

     Ist das letzte oder einzige Argument <x_n> eine Liste mit einem
     Element, akzeptiert die mit `define' definierte Funktion eine
     variable Anzahl an Argumenten.

          (%i1) define (H ([L]), '(apply ("+", L)));
          (%o1)                H([L]) := apply("+", L)
          (%i2) H (a, b, c);
          (%o2)                       c + b + a

     Ist das erste Argument ein Ausdruck mit den Funktionen `funmake',
     `arraymake' oder `ev' wird das Argument ausgewertet.

          (%i1) [F : I, u : x];
          (%o1)                        [I, x]
          (%i2) funmake (F, [u]);
          (%o2)                         I(x)
          (%i3) define (funmake (F, [u]), cos(u) + 1);
          (%o3)                  I(x) := cos(x) + 1
          (%i4) define (arraymake (F, [u]), cos(u) + 1);
          (%o4)                   I  := cos(x) + 1
                                   x
          (%i5) define (foo (x, y), bar (y, x));
          (%o5)                foo(x, y) := bar(y, x)
          (%i6) define (ev (foo (x, y)), sin(x) - cos(y));
          (%o6)             bar(y, x) := sin(x) - cos(y)

 -- Funktion: define_variable (<name>, <default_value>, <mode>)
     Definiert eine globale Variable in der Maxima-Umgebung.
     `define_variable' ist nützlich für das Schreiben von Paketen, die
     häufig übersetzt oder kompiliert werden.  `define_variable' führt
     die folgenden Schritte aus:

       1. `mode_declare(<name>, <mode>)' deklariert den Typ der
          Variablen <name> für den Übersetzer.  Siehe `mode_declare'
          für eine Liste der möglichen Typen.

       2. Hat die Variable keinen Wert, wird der Variablen der Wert
          <default_value> zugewiesen.

       3. `declare(<name>, special)' deklariert die Variable als
          Special.

       4. Ordnet der Variablen <name> eine Testfunktion zu, um
          sicherzustellen, dass der Variablen nur Werte zugewiesen
          werden können.

     Einer mit `define_variable' definierten Variablen, die einen
     anderen Typ als `any' erhalten hat, kann die Eigenschaft
     `value_check' zugewiesen werden.  Die `value_check'-Eigenschaft
     ist eine Aussagefunktion mit einer Variablen oder ein
     Lambda-Ausdruck, die aufgerufen werden, wenn der Variablen ein
     Wert zugewiesen werden soll.  Das Argument der
     `value_check'-Funktion ist der Wert, den die Variable erhalten
     soll.

     `define_variable' wertet `default_value' aus.  Die Argumente
     `name' und `mode' werden nicht ausgewertet.  `define_variable'
     gibt den aktuellen Wert der Variable `name' zurück.  Dieser ist
     `default_value', wenn der Variablen bisher kein Wert zugewiesen
     wurde.

     Beispiele:

     `foo' ist eine boolesche Variable mit dem Wert `true'.

          (%i1) define_variable (foo, true, boolean);
          (%o1)                         true
          (%i2) foo;
          (%o2)                         true
          (%i3) foo: false;
          (%o3)                         false
          (%i4) foo: %pi;
          Error: foo was declared mode boolean, has value: %pi
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) foo;
          (%o5)                         false

     `bar' ist eine Variable mit dem Typ einer ganzen Zahl, die eine
     Primzahl sein muss.

          (%i1) define_variable (bar, 2, integer);
          (%o1)                           2
          (%i2) qput (bar, prime_test, value_check);
          (%o2)                      prime_test
          (%i3) prime_test (y) := if not primep(y) then
                                     error (y, "is not prime.");
          (%o3) prime_test(y) := if not primep(y)

                                             then error(y, "is not prime.")
          (%i4) bar: 1439;
          (%o4)                         1439
          (%i5) bar: 1440;
          1440 is not prime.
          #0: prime_test(y=1440)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i6) bar;
          (%o6)                         1439

     `baz_quux' ist eine Variable, der kein Wert zugewiesen werden
     kann.  Der Typ `any_check' ist vergleichbar mit `any'.  Aber
     `any_check' ruft im Gegensatz zu `any' den
     `value_check'-Mechanismus auf.

          (%i1) define_variable (baz_quux, 'baz_quux, any_check);
          (%o1)                       baz_quux
          (%i2) F: lambda ([y], if y # 'baz_quux then
                           error ("Cannot assign to `baz_quux'."));
          (%o2) lambda([y], if y # 'baz_quux

                                  then error(Cannot assign to `baz_quux'.))
          (%i3) qput (baz_quux, ''F, value_check);
          (%o3) lambda([y], if y # 'baz_quux

                                  then error(Cannot assign to `baz_quux'.))
          (%i4) baz_quux: 'baz_quux;
          (%o4)                       baz_quux
          (%i5) baz_quux: sqrt(2);
          Cannot assign to `baz_quux'.
          #0: lambda([y],if y # 'baz_quux then
                           error("Cannot assign to `baz_quux'."))(y=sqrt(2))
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i6) baz_quux;
          (%o6)                       baz_quux

 -- Funktion: dispfun (<f_1>, ..., <f_n>)
 -- Funktion: dispfun (all)
     Zeigt die Definitionen der nutzerdefinierten Funktionen <f_1>, ...,
     <f_n> an.  Die Argumente können gewöhnliche Funktionen, Makros,
     Array-Funktionen oder indizierte Funktionen sein.

     `dispfun(all)' zeigt die Definitionen aller nutzerdefinierten
     Funktionen an, die in den Informationslisten `functions',  `arrays'
     oder `macros'  enthalten sind.

     `dispfun' erzeugt Zwischenmarken `%t' für jede einzelne
     anzuzeigende Funktion und weist die Funktionsdefinitionen den
     Zwischenmarken zu.  Im Gegensatz dazu, zeigt die Funktion `fundef'
     die Funktionsdefinition ohne Zwischenmarken an.

     `dispfun' wertet die Argumente nicht aus.  `dispfun' gibt eine
     Liste mit den Zwischenmarken zurück, die zu den angezeigten
     Funktionen gehören.

     Beispiele:

          (%i1) m(x, y) ::= x^(-y);
                                               - y
          (%o1)                   m(x, y) ::= x
          (%i2) f(x, y) :=  x^(-y);
                                               - y
          (%o2)                    f(x, y) := x
          (%i3) g[x, y] :=  x^(-y);
                                              - y
          (%o3)                     g     := x
                                     x, y
          (%i4) h[x](y) :=  x^(-y);
                                              - y
          (%o4)                     h (y) := x
                                     x
          (%i5) i[8](y) :=  8^(-y);
                                              - y
          (%o5)                     i (y) := 8
                                     8
          (%i6) dispfun (m, f, g, h, h[5], h[10], i[8]);
                                               - y
          (%t6)                   m(x, y) ::= x

                                               - y
          (%t7)                    f(x, y) := x

                                              - y
          (%t8)                     g     := x
                                     x, y

                                              - y
          (%t9)                     h (y) := x
                                     x

                                              1
          (%t10)                     h (y) := --
                                      5        y
                                              5

                                               1
          (%t11)                    h  (y) := ---
                                     10         y
                                              10

                                              - y
          (%t12)                    i (y) := 8
                                     8

          (%o12)       [%t6, %t7, %t8, %t9, %t10, %t11, %t12]
          (%i12) ''%;
                               - y              - y            - y
          (%o12) [m(x, y) ::= x   , f(x, y) := x   , g     := x   ,
                                                      x, y
                            - y           1              1             - y
                  h (y) := x   , h (y) := --, h  (y) := ---, i (y) := 8   ]
                   x              5        y   10         y   8
                                          5             10

 -- Funktion: fullmap (<f>, <expr_1>, ...)
     Die Funktion `fullmap' ist vergleichbar mit der Funktion `map'.

     Im  Unterschied zu der Funktion `map' kann `fullmap' auf
     verschachtelte Ausdrücke angewendet werden.

     Intern wird `fullmap' von Maxima für die Vereinfachung von Matrizen
     aufgerufen.  Daher können bei der Vereinfachung von Matrizen
     Fehlermeldungen im Zusammenhang mit `fullmap' auftreten, ohne dass
     die Funktion direkt aufgerufen wurde.

     Beispiele:

          (%i1) a + b * c;
          (%o1)                        b c + a
          (%i2) fullmap (g, %);
          (%o2)                   g(b) g(c) + g(a)
          (%i3) map (g, %th(2));
          (%o3)                     g(b c) + g(a)

 -- Funktion: fullmapl (<f>, <list_1>, ...)
     Die Funktion `fullmapl' ist vergleichbar mit `fullmap'.

     `fullmapl' kann jedoch nur auf Matrizen und Listen angewendet
     werden kann.

     Beispiele:

          (%i1) fullmapl ("+", [3, [4, 5]], [[a, 1], [0, -1.5]]);
          (%o1)                [[a + 3, 4], [4, 3.5]]

 -- Systemvariable: functions
     Standardwert: `[]'

     `functions' ist eine Informationsliste, die die vom Nutzer mit dem
     Operator `:='  oder der Funktion `define'  definierten Funktionen
     enthält.  Siehe auch die Systemvariable `infolists'.

     Array-Funktionen und indizierte Funktionen werden nicht in die
     Informationsliste `functions',  sondern in die Informationsliste
     `arrays'

     eingetragen.

     Beispiele:

          (%i1) F_1 (x) := x - 100;
          (%o1)                   F_1(x) := x - 100
          (%i2) F_2 (x, y) := x / y;
                                                x
          (%o2)                    F_2(x, y) := -
                                                y
          (%i3) define (F_3 (x), sqrt (x));
          (%o3)                   F_3(x) := sqrt(x)
          (%i4) G_1 [x] := x - 100;
          (%o4)                    G_1  := x - 100
                                      x
          (%i5) G_2 [x, y] := x / y;
                                               x
          (%o5)                     G_2     := -
                                       x, y    y
          (%i6) define (G_3 [x], sqrt (x));
          (%o6)                    G_3  := sqrt(x)
                                      x
          (%i7) H_1 [x] (y) := x^y;
                                                y
          (%o7)                     H_1 (y) := x
                                       x
          (%i8) functions;
          (%o8)              [F_1(x), F_2(x, y), F_3(x)]
          (%i9) arrays;
          (%o9)                 [G_1, G_2, G_3, H_1]

 -- Funktion: fundef (<f>)
     Gibt die Definition der Funktion <f> zurück.

     Das Argument <f> kann eine gewöhnliche Funktion, eine
     Makro-Funktion, eine Array-Funktion oder eine indizierte Funktion
     sein.

     `fundef' wertet das Argument aus.  Siehe auch `dispfun'.


 -- Funktion: funmake (<F>, [<arg_1>, ..., <arg_n>])
     Gibt den Ausdruck `<F>(<arg_1>, ..., <arg_n>)' zurück.  Die
     Rückgabe wird vereinfacht, aber nicht ausgewertet.  Die Funktion
     <F> wird also nicht aufgerufen, auch wenn diese existiert.

     `funmake' versucht nicht, Array-Funktionen von gewöhnlichen
     Funktionen zu unterscheiden.  Ist <F> der Name einer
     Array-Funktion, dann gibt `funmake' einen Ausdruck der Form
     `<F>(...)' zurück.  Für Array-Funktionen kann die Funktion
     `arraymake'  verwendet werden.

     `funmake' wertet die Argumente aus.

     Beispiele:

     `funmake' angewendet auf eine gewöhnliche Funktion.

          (%i1) F (x, y) := y^2 - x^2;
                                             2    2
          (%o1)                  F(x, y) := y  - x
          (%i2) funmake (F, [a + 1, b + 1]);
          (%o2)                    F(a + 1, b + 1)
          (%i3) ''%;
                                        2          2
          (%o3)                  (b + 1)  - (a + 1)

     `funmake' angewendet auf ein Makro.

          (%i1) G (x) ::= (x - 1)/2;
                                            x - 1
          (%o1)                    G(x) ::= -----
                                              2
          (%i2) funmake (G, [u]);
          (%o2)                         G(u)
          (%i3) ''%;
                                        u - 1
          (%o3)                         -----
                                          2

     `funmake' angewendet auf eine indizierte Funktion.

          (%i1) H [a] (x) := (x - 1)^a;
                                                  a
          (%o1)                   H (x) := (x - 1)
                                   a
          (%i2) funmake (H [n], [%e]);
                                                 n
          (%o2)               lambda([x], (x - 1) )(%e)
          (%i3) ''%;
                                              n
          (%o3)                       (%e - 1)
          (%i4) funmake ('(H [n]), [%e]);
          (%o4)                        H (%e)
                                        n
          (%i5) ''%;
                                              n
          (%o5)                       (%e - 1)

     `funmake' angewendet auf ein Symbol, welches keine Funktion
     repräsentiert.

          (%i1) funmake (A, [u]);
          (%o1)                         A(u)
          (%i2) ''%;
          (%o2)                         A(u)

     `funmake' wertet die Argumente, aber nicht die Rückgabe aus.

          (%i1) det(a,b,c) := b^2 -4*a*c;
                                              2
          (%o1)              det(a, b, c) := b  - 4 a c
          (%i2) (x : 8, y : 10, z : 12);
          (%o2)                          12
          (%i3) f : det;
          (%o3)                          det
          (%i4) funmake (f, [x, y, z]);
          (%o4)                    det(8, 10, 12)
          (%i5) ''%;
          (%o5)                         - 284

     Maxima vereinfacht den Rückgabewert der Funktion `funmake'.

          (%i1) funmake (sin, [%pi / 2]);
          (%o1)                           1

 -- Funktion: lambda ([<x_1>, ..., <x_m>], <expr_1>, ..., <expr_n>)
 -- Funktion: lambda ([[<L>]], <expr_1>, ..., <expr_n>)
 -- Funktion: lambda ([<x_1>, ..., <x_m>, [<L>]], <expr_1>, ...,
          <expr_n>)
     Definiert einen Lambda-Ausdruck, der auch als anonyme Funktion
     bezeichnet wird, und gibt diesen zurück.  Die Funktion kann
     Argumente <x_1>, ..., <x_m> und optionale Argumente <L> haben.
     Die Rückgabe der Funktion ist das Ergebnis des Ausdrucks <exprn>.
     Ein Lambda-Ausdruck kann einer Variablen zugewiesen werden und
     wertet wie eine gewöhnliche Funktion aus.  Ein Lambda-Ausdruck
     kann an solchen Stellen verwendet werden, wo der Name einer
     Funktion erwartet wird.

     Wird der Lambda-Ausdruck ausgewertet, werden lokale Variablen
     <x_1>, ..., <x_m> erzeugt.  `lambda' kann innerhalb von Blöcken
     oder anderen Lambda-Ausdrücken verwendet werden.  Mit jeder
     `block'-Anweisung oder jedem Lambda-Ausdruck werden erneut lokale
     Variablen erzeugt.  Die lokalen Variablen sind jeweils global zu
     jeder eingeschlossenen `block'-Anweisung oder zu jedem
     eingeschlossenen Lambda-Ausdruck.  Ist eine Variable innerhalb von
     `block' oder `lambda' nicht lokal, hat sie den Wert der nächst
     höheren Anweisung, die ihr einen Wert gibt oder den globalen Wert
     der Maxima-Umgebung.

     Nachdem die lokalen Variablen erzeugt sind, werden die Ausdrücke
     <expr_1>, ..., <expr_n> nacheinander ausgewertet.  Die
     Systemvariable `%%', welche das Ergebnis eines vorhergehendes
     Ausdrucks enthält, kann verwendet werden.  In einem
     Lambda-Ausdruck können die Anweisungen `catch'  und `throw'
     verwendet werden.

     Die `return' -Anweisung kann in einem Lambda-Ausdruck nur
     verwendet werden, wenn sie von einer `block'-Anweisung
     eingeschlossen wird.  Die `return'-Anweisung definiert jedoch den
     Rückgabewert des Blocks und nicht des Lambda-Ausdrucks.  Auch die
     `go' -Anweisung kann in einem Lambda-Ausdrucks nur in einem Block
     verwendet werden.

     `lambda' wertet die Argumente nicht aus.

     Beispiele:

     Ein Lambda-Ausdruck kann einer Variablen zugewiesen werden und wie
     eine gewöhnliche Funktion ausgewertet werden.

          (%i1) f: lambda ([x], x^2);
                                                2
          (%o1)                    lambda([x], x )
          (%i2) f(a);
                                          2
          (%o2)                          a

     Ein Lamda-Ausdruck kann an Stellen verwendet werden, wo der Name
     einer Funktion erwartet wird.

          (%i3) lambda ([x], x^2) (a);
                                          2
          (%o3)                          a
          (%i4) apply (lambda ([x], x^2), [a]);
                                          2
          (%o4)                          a
          (%i5) map (lambda ([x], x^2), [a, b, c, d, e]);
                                  2   2   2   2   2
          (%o5)                 [a , b , c , d , e ]

     Die Argumente sind lokale Variablen.  Andere Variablen sind
     globale Variablen.  Globale Variablen werden zu dem Zeitpunkt
     ausgewertet, wenn der Lambda-Ausdruck ausgewertet wird.

          (%i6) a: %pi$
          (%i7) b: %e$
          (%i8) g: lambda ([a], a*b);
          (%o8)                   lambda([a], a b)
          (%i9) b: %gamma$
          (%i10) g(1/2);
                                       %gamma
          (%o10)                       ------
                                         2
          (%i11) g2: lambda ([a], a*''b);
          (%o11)                lambda([a], a %gamma)
          (%i12) b: %e$
          (%i13) g2(1/2);
                                       %gamma
          (%o13)                       ------
                                         2

     Lambda-Ausdrücke können verschachtelt werden.  Lokale Variablen
     eines äußeren Lambda-Ausdrucks sind global zu den enthaltenen
     Lambda-Ausdrücken, außer diese werden wieder als lokal erklärt.

          (%i14) h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
                                                             1
          (%o14)    lambda([a, b], h2 : lambda([a], a b), h2(-))
                                                             2
          (%i15) h(%pi, %gamma);
                                       %gamma
          (%o15)                       ------
                                         2

     Da `lambda' die Argumente nicht auswertet, definiert der unten
     angegebene Ausdruck `i' keine Funktion "multipliziere mit `a'".
     Solch eine Funktion kann mit Hilfe der Funktion `buildq'
     definiert werden.

          (%i16) i: lambda ([a], lambda ([x], a*x));
          (%o16)            lambda([a], lambda([x], a x))
          (%i17) i(1/2);
          (%o17)                  lambda([x], a x)
          (%i18) i2: lambda([a], buildq([a: a], lambda([x], a*x)));
          (%o18)    lambda([a], buildq([a : a], lambda([x], a x)))
          (%i19) i2(1/2);
                                               x
          (%o19)                   lambda([x], -)
                                               2
          (%i20) i2(1/2)(%pi);
                                         %pi
          (%o20)                         ---
                                          2

     Ein Lambda-Ausdruck kann eine variable Anzahl an Argumenten haben,
     wenn das letzte Argument eine Liste mit einem Element ist.

          (%i1) f : lambda ([aa, bb, [cc]], aa * cc + bb);
          (%o1)          lambda([aa, bb, [cc]], aa cc + bb)
          (%i2) f (foo, %i, 17, 29, 256);
          (%o2)       [17 foo + %i, 29 foo + %i, 256 foo + %i]
          (%i3) g : lambda ([[aa]], apply ("+", aa));
          (%o3)             lambda([[aa]], apply(+, aa))
          (%i4) g (17, 29, x, y, z, %e);
          (%o4)                  z + y + x + %e + 46

 -- Funktion: map (<f>, <expr_1>, ..., <expr_n>)
     Gibt einen Ausdruck zurück, dessen Hauptoperator derselbe ist, wie
     der der Argumente <expr_1>, ..., <expr_n> aber dessen Operanden
     das Ergebnis der Anwendung des Operators <f> auf die Teilausdrücke
     des Ausdrucks sind.  <f> ist entweder der Name einer Funktion mit
     n Argumenten oder ein Lambda-Ausdruck mit n Argumenten.

     Hat `maperror'  den Wert `false', wird die Anwendung der Funktion
     <f> gestoppt, (1) wenn die Anwendung auf den kürzesten Ausdruck
     <expr_i> beendet ist und die Ausdrücke nicht alle dieselbe Länge
     haben oder (2) wenn die Ausdrücke <expr_i> einen verschiedenen Typ
     haben.  Hat `maperror' den Wert `true' wird in den obigen Fällen
     eine Fehlermeldung ausgegeben.

     Beispiele:

          (%i1) map(f,x+a*y+b*z);
          (%o1)                        f(b z) + f(a y) + f(x)
          (%i2) map(lambda([u],partfrac(u,x)),x+1/(x^3+4*x^2+5*x+2));
                                     1       1        1
          (%o2)                     ----- - ----- + -------- + x
                                   x + 2   x + 1          2
                                                   (x + 1)
          (%i3) map(ratsimp, x/(x^2+x)+(y^2+y)/y);
                                                1
          (%o3)                            y + ----- + 1
                                              x + 1
          (%i4) map("=",[a,b],[-0.5,3]);
          (%o4)                          [a = - 0.5, b = 3]

 -- Funktion: mapatom (<expr>)
     Gibt den Wert `true' zurück, wenn der Ausdruck <expr> von
     Funktionen die auf Argumente angewendete werden, als ein Atom
     betrachtet wird.  Als Atome werden Zahlen, einschließlich
     rationaler Zahlen und großer Gleitkommazahlen, Symbole und
     indizierte Symbole betrachtet.

 -- Optionsvariable: maperror
     Standardwert: `true'

     Hat `maperror' den Wert `false', wird die Anwendung der Funktion
     <f> gestoppt, (1) wenn die Anwendung auf den kürzesten Ausdruck
     <expr_i> beendet ist und die Ausdrücke nicht alle dieselbe Länge
     haben oder (2) wenn die Ausdrücke <expr_i> einen verschiedenen Typ
     haben.  Hat `maperror' den Wert `true' wird in den obigen Fällen
     eine Fehlermeldung ausgegeben.

 -- Optionsvariable: mapprint
     Standardwert: `true'

     Hat `mapprint' den Wert `true', werden verschiedene Informationen
     von den Funktionen `map',  `maplist'  und `fullmap'  ausgegeben.
     Dies ist der Fall, wenn die Funktion `map' die Funktion `apply'
     aufruft oder wenn für die Funktion `map' die Argumente eine
     verschiedene Länge haben.

     Hat `mapprint' den Wert `false', werden diese Meldungen
     unterdrückt.

 -- Funktion: maplist (<f>, <expr_1>, ..., <expr_n>)
     Wendet die Funktion <f> auf die Ausdrücke <expr_1>, ..., <expr_n>
     an und gibt das Ergebnis als eine Liste zurück.  <f> ist der Name
     einer Funktion oder ein lambda-Ausdruck.

     Im Unterschied zu `maplist' gibt die Funktion `map'  einen Ausdruck
     zurück, der denselben Hauptoperator wie die Ausdrücke <expr_i> hat.

 -- Funktion: outermap (<f>, <a_1>, ..., <a_n>)
     Wendet die Funktion <f> auf jedes Element des äußeren Produktes der
     Argumente <a_1> `x' <a_2> `x' ... `x' <a_n> an.

     <f> ist der Name einer Funktion mit n Argumenten oder ein
     Lambda-Ausdruck mit n Argumenten.  Jedes Argument <a_k> kann eine
     Liste oder verschachtelte Liste, eine Matrix oder irgendein
     anderer Ausdruck sein.

     `outermap' wertet die Argumente aus.

     Siehe auch `map',  `maplist'  und `apply'.

     Beispiele:

     Einfaches Beispiel für `outermap'.  Die Funktion `F' ist
     undefiniert.

          (%i1) outermap(F, [a, b, c], [1, 2, 3]);
          (%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)],
                                               [F(c, 1), F(c, 2), F(c, 3)]]
          (%i2) outermap(F, matrix([a, b],[c, d]), matrix([1, 2],[3, 4]));
                   [ [ F(a, 1)  F(a, 2) ]  [ F(b, 1)  F(b, 2) ] ]
                   [ [                  ]  [                  ] ]
                   [ [ F(a, 3)  F(a, 4) ]  [ F(b, 3)  F(b, 4) ] ]
          (%o2)    [                                            ]
                   [ [ F(c, 1)  F(c, 2) ]  [ F(d, 1)  F(d, 2) ] ]
                   [ [                  ]  [                  ] ]
                   [ [ F(c, 3)  F(c, 4) ]  [ F(d, 3)  F(d, 4) ] ]
          (%i3) outermap (F, [a, b], x, matrix ([1, 2], [3, 4]));
                 [ F(a, x, 1)  F(a, x, 2) ]  [ F(b, x, 1)  F(b, x, 2) ]
          (%o3) [[                        ], [                        ]]
                 [ F(a, x, 3)  F(a, x, 4) ]  [ F(b, x, 3)  F(b, x, 4) ]
          (%i4) outermap (F, [a, b], matrix ([1, 2]), matrix ([x], [y]));
                 [ [ F(a, 1, x) ]  [ F(a, 2, x) ] ]
          (%o4) [[ [            ]  [            ] ],
                 [ [ F(a, 1, y) ]  [ F(a, 2, y) ] ]
                                        [ [ F(b, 1, x) ]  [ F(b, 2, x) ] ]
                                        [ [            ]  [            ] ]]
                                        [ [ F(b, 1, y) ]  [ F(b, 2, y) ] ]
          (%i5) outermap ("+", [a, b, c], [1, 2, 3]);
          (%o5) [[a + 1, a + 2, a + 3], [b + 1, b + 2, b + 3],
                                                     [c + 1, c + 2, c + 3]]

     Das Beispiel zeigt die Rückgabe der Funktion `outermap'
     detaillierter.  Das erste, zweite und dritte Argument sind eine
     Matrix, eine Liste und eine Matrix.  Der Rückgabewert ist eine
     Matrix.  Jedes Element der Matrix ist eine Liste und jedes Element
     der Liste ist eine Matrix.

          (%i1) arg_1 :  matrix ([a, b], [c, d]);
                                      [ a  b ]
          (%o1)                       [      ]
                                      [ c  d ]
          (%i2) arg_2 : [11, 22];
          (%o2)                       [11, 22]
          (%i3) arg_3 : matrix ([xx, yy]);
          (%o3)                      [ xx  yy ]
          (%i4) xx_0 : outermap(lambda([x, y, z], x / y + z), arg_1,
                                                             arg_2, arg_3);
                         [  [      a        a  ]  [      a        a  ]  ]
                         [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                         [  [      11       11 ]  [      22       22 ]  ]
          (%o4)  Col 1 = [                                              ]
                         [  [      c        c  ]  [      c        c  ]  ]
                         [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                         [  [      11       11 ]  [      22       22 ]  ]
                           [  [      b        b  ]  [      b        b  ]  ]
                           [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                           [  [      11       11 ]  [      22       22 ]  ]
                   Col 2 = [                                              ]
                           [  [      d        d  ]  [      d        d  ]  ]
                           [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                           [  [      11       11 ]  [      22       22 ]  ]
          (%i5) xx_1 : xx_0 [1][1];
                     [      a        a  ]  [      a        a  ]
          (%o5)     [[ xx + --  yy + -- ], [ xx + --  yy + -- ]]
                     [      11       11 ]  [      22       22 ]
          (%i6) xx_2 : xx_0 [1][1] [1];
                                [      a        a  ]
          (%o6)                 [ xx + --  yy + -- ]
                                [      11       11 ]
          (%i7) xx_3 : xx_0 [1][1] [1] [1][1];
                                            a
          (%o7)                        xx + --
                                            11
          (%i8) [op (arg_1), op (arg_2), op (arg_3)];
          (%o8)                  [matrix, [, matrix]
          (%i9) [op (xx_0), op (xx_1), op (xx_2)];
          (%o9)                  [matrix, [, matrix]

     `outermap' erhält die Struktur der Argumente im Ergebnis.  Die
     Funktion `cartesian_product' erhält die Struktur der Argumente
     nicht.

          (%i1) outermap (F, [a, b, c], [1, 2, 3]);
          (%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)],
                                               [F(c, 1), F(c, 2), F(c, 3)]]
          (%i2) setify (flatten (%));
          (%o2) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3),
                                                 F(c, 1), F(c, 2), F(c, 3)}
          (%i3) map(lambda([L], apply(F, L)),
                               cartesian_product({a, b, c}, {1, 2, 3}));
          (%o3) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3),
                                                 F(c, 1), F(c, 2), F(c, 3)}
          (%i4) is (equal (%, %th (2)));
          (%o4)                         true

 -- Funktion: remfunction (<f_1>, ..., <f_n>)
 -- Funktion: remfunction (all)
     Hebt die Bindung der Symbole <f_1>, ..., <f_n> an ihre
     Funktionsdefinitionen auf.  Die Argumente können die Namen von
     Funktionen sein, die mit dem Operator `:='  oder der Funktion
     `define'  definiert wurden sowie Makro-Funktionen, die mit dem
     Operator `::='  definiert wurden.

     `remfunction(all)' entfernt alle Bindungen von
     Funktionsdefinitionen.

     `remfunction' gibt eine Liste mit den Symbolen zurück, die von
     ihren Funktionsdefinitionen entbunden wurden.  `false' wird für
     die Symbole zurückgegeben, für die es keine Funktionsdefinition
     gibt.

     `remfunction' wertet die Argumente nicht aus.

     `remfunction' kann nicht auf Array-Funktionen und indizierte
     Funktionen angewendet werden.  Für diese Funktionen kann `remarray'
     verwendet werden.

 -- Funktion: scanmap (<f>, <expr>)
 -- Funktion: scanmap (<f>, <expr>, bottomup)
     Wendet die Funktion <f> rekursiv auf alle Teilausdrücke in <expr>
     an.  Dies kann zum Beispiel verwendet werden, um einen Ausdruck
     vollständig zu faktorisieren.

     Beispiele:

          (%i1) exp:(a^2+2*a+1)*y + x^2$
          (%i2) scanmap(factor,exp);
                                              2      2
          (%o2)                         (a + 1)  y + x

          (%i3) scanmap(factor,expand(exp));
                                     2                  2
          (%o3)                      a  y + 2 a y + y + x

     Ein weiteres Beispiel für die Anwendung einer Funktion auf alle
     Teilausdrücke.

          (%i4) expr : u*v^(a*x+b) + c$
          (%i5) scanmap('f, expr);
                              f(f(f(a) f(x)) + f(b))
          (%o5) f(f(f(u) f(f(v)                      )) + f(c))

     `scanmap (<f>, <expr>, bottomup)' wendet die Funktion <f>
     Bottom-up auf den Ausdruck <expr> an.

          scanmap(f,a*x+b) ->
             f(a*x+b) -> f(f(a*x)+f(b)) -> f(f(f(a)*f(x))+f(b))
          scanmap(f,a*x+b,bottomup) -> f(a)*f(x)+f(b)
              -> f(f(a)*f(x))+f(b) ->
               f(f(f(a)*f(x))+f(b))


File: maxima.info,  Node: Laufzeitumgebung,  Next: Programmierung,  Prev: Funktionsdefinitionen,  Up: Top

26 Laufzeitumgebung
*******************

* Menu:

* Initialisierung von Maxima::
* Interrupts::
* Funktionen und Variablen der Laufzeitumgebung::


File: maxima.info,  Node: Initialisierung von Maxima,  Next: Interrupts,  Prev: Laufzeitumgebung,  Up: Laufzeitumgebung

26.1 Initialisierung von Maxima
===============================

Wenn Maxima startet, werden die beiden Dateien `maxima-init.mac' und
`maxima-init.lisp' automatisch geladen, sofern diese vorhanden sind.
Die Datei `maxima-init.mac' wird mit der Funktion `batchload'  von
Maxima geladen und kann beliebige Maxima-Ausdrücke enthalten, die beim
Starten von Maxima ausgeführt werden.  Die Datei `maxima-init.lisp'
wird mit der Funktion `load'  geladen und kann entsprechende
Lisp-Anweisungen enthalten.  Beide Dateien erlauben es dem Nutzer,
globale Variablen zu setzen, Funktionen zu definieren oder sonstige
Aktionen auszuführen, um zum Beispiel die Maxima-Umgebung anzupassen.

Die Dateien `maxima-init.mac' und `maxima-init.lisp' können in jedem
Verzeichnis abgelegt werden, das von der Funktion `file_search'
gefunden wird.  Üblicherweise wird das Verzeichnis gewählt, das in der
Optionsvariablen `maxima_userdir'  enthalten ist und die von Maxima beim
Starten entsprechend dem Betriebssystem mit einem Standardwert
initialisiert wird.

Beispiel:

Im Folgenden wird ein Beispiel für den Inhalt einer Datei
`maxima-init.mac' gezeigt.  In diesem Beispiel werden einige globale
Werte auf neue Anfangswerte gesetzt.

     /* maxima-init.mac */
     print(" Lade ", file_search("maxima-init.mac"), " ...")$
     linel:65$      /* 65 Zeichen pro Zeile */
     leftjust:true$ /* Linksbündige Ausgabe */
     algebraic:true$ /* Vereinfache algebraische Zahlen */
     fpprec:25$      /* große Gleitkommazahlen mit 25 Stellen */
     print (" maxima-init.mac ist geladen.")$

Die Optionsvariable `maxima_userdir' enthält ein geeignetes Verzeichnis,
um die Datei `maxima-init.mac' abzulegen.  Mit der Funktion
`file_search' kann geprüft werden, ob die Datei von Maxima gefunden
wird.

     (%i1) maxima_userdir;
     (%o1)                 /home/dieter/.maxima
     (%i2) file_search("maxima-init.mac");
     (%o2)         /home/dieter/.maxima/maxima-init.mac

Im Folgenden wird Maxima mit einer Datei `maxima-init.mac' gestartet,
die die oben angegebenen Maxima Kommandos enthält.

     dieter@dieter:~/Maxima/maxima$ rmaxima
     Maxima 5.25.1 http://maxima.sourceforge.net
     Mit Lisp SBCL 1.0.53
     Lizensiert unter der GNU Public License. Siehe die Datei COPYING.
     Gewidmet dem Andenken an William Schelter.
     Die Funktion bug_report() gibt Informationen zum Berichten von Fehlern.
      Lade  /home/dieter/.maxima/maxima-init.mac  ...
      maxima-init.mac ist geladen.
     (%i1)

Die Sitzung wird fortgesetzt, die Variablen enthalten die gewünschten
neuen Standardwerte und die Anzeige ist linksbündig formatiert.

     (%i1) linel;
     (%o1) 65
     (%i2) algebraic;
     (%o2) true
     (%i3) fpprec;
     (%o3) 25

_Hinweis:_

Mit dem Kommando `reset'  werden die Optionsvariablen nicht auf die
Werte der Datei `maxima-init.mac' zurückgesetzt, sondern auf die
ursprünglichen in Maxima festgelegten Standardwerte.  Wird das Kommando
`kill'  ausgeführt, gehen weiterhin alle in der Initialisierungsdatei
definierten Variablen und Funktionen verloren.  In beiden Fällen muss
die Datei `maxima-init.mac' erneut zum Beispiel mit der Funktion `load'
geladen werden.

Die obige Sitzung wird fortgesetzt.  Die Variablen werden mit `reset'
zurückgesetzt.  Dann wird die Datei `maxima-init.mac' mit der Funktion
`load' geladen.

     (%i4) reset();
     (%o1) [features, fpprec, _, __, labels, %, linenum, algebraic,
                                        tr-unique, leftjust, lispdisp]
     (%i2) fpprec;
     (%o2)                          16
     (%i3) load("maxima-init.mac");
      Lade  /home/dieter/.maxima/maxima-init.mac  ...
      maxima-init.mac ist geladen.
     (%o3) /home/dieter/.maxima/maxima-init.mac
     (%i4) fpprec;
     (%o4) 25

Die obigen Ausführungen treffen auf gleiche Weise auf die Datei
`maxima-init.lisp' zu, wobei in diesem Fall die Datei Lisp-Anweisungen
enthält.

Beispiel:

Das folgende Beispiel zeigt die Übersetzung des obigen Beispiels für die
Datei `maxima-init.mac' in Lisp-Anweisungen.

     ;;; maxima-init.lisp
     (format t " Lade ~A ...~%" ($file_search "maxima-init.lisp"))
     (setq $linel 65)
     (setq $leftjust t)
     (setq $algebraic t)
     (setq $fpprec 25)
     (fpprec1 nil $fpprec)
     (format t " maxima-init.lisp ist geladen.~%")

Die Datei `maxima-init.lisp' ist im besonderen dazu geeignet, einen
Patch in Maxima einzuspielen, um einen Programmierfehler zu beheben.


File: maxima.info,  Node: Interrupts,  Next: Funktionen und Variablen der Laufzeitumgebung,  Prev: Initialisierung von Maxima,  Up: Laufzeitumgebung

26.2 Interrupts
===============

Eine Berechnung kann mit dem Kommando `^c' (`control-c') abgebrochen
werden.  Standardmäßig kehrt Maxima zu der Eingabeaufforderung der
Konsole zurück.  In diesem Fall ist es nicht möglich, die Berechnung
fortzusetzen.

Beispiel:

Eine lange Rechnung wird mit `^c' abgebrochen.  Maxima kehrt zur
Eingabeaufforderung zurück.

     (%i1) factor(factorial(10000))$

     Maxima encountered a Lisp error:
      Interactive interrupt at #x9224192.

     Automatically continuing.
     To enable the Lisp debugger set *debugger-hook* to nil.
     (%i2)

Wird die Lisp-Variable `*debugger-hook*' mit dem Kommando `:lisp (setq
*debugger-hook* nil)' auf den Wert `nil' gesetzt, dann startet Maxima
den Lisp-Debugger, wenn das Kommando `^c' ausgeführt wird.  Mit dem
Kommando `continue' im Lisp-Debugger kann die unterbrochene Berechnung
fortgesetzt werden.

Beispiel:

Die Variable `*debugger-hook*' wird auf den Wert `nil' gesetzt.  Der
Abbruch der Rechnung startet in diesem Fall den Lisp-Debugger.  Die
Rechnung kann mit der Auswahl `0' für das Kommando `continue'
fortgesetzt werden.

     (%i2) :lisp (setq *debugger-hook* nil)
     NIL
     (%i2) factor(factorial(10000))$

     debugger invoked on a SB-SYS:INTERACTIVE-INTERRUPT
          in thread #<THREAD
          "initial thread" RUNNING
          {C597F49}>:
       Interactive interrupt at #x9224192.

     Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

     restarts (invokable by number or by possibly-abbreviated name):
       0: [CONTINUE    ] Return from SB-UNIX:SIGINT.
       1: [MACSYMA-QUIT] Maxima top-level
       2: [ABORT       ] Exit debugger, returning to top level.

     (SB-BIGNUM:BIGNUM-TRUNCATE #<unavailable argument>
                                #<unavailable argument>)
     0] 0

     (%i3)

Hinweis:

Mit dem Kommando `:lisp (setq *debugger-hook* 'maxima-lisp-debugger)'
kann das Standardverhalten von Maxima wiederhergestellt werden.

In Unix-Systemen kann die Ausführung auch mit Kommando `^z'
(`control-z') abgebrochen werden.  In diesem Fall wird eine Unix-Shell
gestartet.  Das Kommando `fg' kehrt zu Maxima zurück.

Wie mit dem Kommando `^c' kann auch ein Lisp-Fehler zu einem Abbruch
der Berechnung führen.  Maxima meldet den Lisp-Fehler und kehrt
standardmäßig zu der Eingabeaufforderung zurück.  Wurde die
Lisp-Variable `*debugger-hook*' auf den Wert `nil' gesetzt, startet
Maxima den Lisp-Debugger.

Beispiel:

Es wird eine Lisp-Funktion `$sqr' definiert, die aus Maxima mit `sqr'
aufgerufen werden kann und ihr Argument quadriert.  Wird die Funktion
mit mehr als einem Argument aufgerufen, wird ein Lisp-Fehler generiert
und Maxima kehrt zu der Eingabeaufforderung zurück.

     (%i1) :lisp (defun $sqr (x) (* x x))
     $SQR
     (%i1) sqr(3);
     (%o1)                           9
     (%i2) sqr(2,3);

     Maxima encountered a Lisp error:

      invalid number of arguments: 2

     Automatically continuing.
     To enable the Lisp debugger set *debugger-hook* to nil.

     (%i3)

Jetzt wird die Lisp-Variable `*debugger-hook*' auf den Wert `nil'
gesetzt.  In diesem Fall wird der Lisp-Debugger aufgerufen.  Die
Ausführung kann in diesem Fall nicht mit dem Kommando `continue'
fortgesetzt werden, da ein Syntax-Fehler aufgetreten ist.  Jedoch ist
es möglich, Maxima mit dem Kommando `(run)' vom Lisp-Prompt neu zu
starten.

     (%i3) :lisp (setq *debugger-hook* nil)
     NIL
     (%i3) sqr(2,3);

     debugger invoked on a SB-INT:
        SIMPLE-PROGRAM-ERROR in thread #<THREAD
        "initial thread" RUNNING {C597F49}>:
       invalid number of arguments: 2

     Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

     restarts (invokable by number or by possibly-abbreviated name):
       0: [MACSYMA-QUIT] Maxima top-level
       1: [CONTINUE    ] Ignore runtime option --eval "(cl-user::run)".
       2: [ABORT       ] Skip rest of --eval and --load options.
       3:                Skip to toplevel READ/EVAL/PRINT loop.
       4: [QUIT        ] Quit SBCL (calling #'QUIT, killing the process).

     ($SQR 2)[:EXTERNAL]
     0] continue

     * (run)
     Maxima restarted.
     (%i4)


File: maxima.info,  Node: Funktionen und Variablen der Laufzeitumgebung,  Prev: Interrupts,  Up: Laufzeitumgebung

26.3 Funktionen und Variablen der Laufzeitumgebung
==================================================

 -- Systemvariable: maxima_tempdir
     Die Systemvariable `maxima_tempdir' enthält das Verzeichnis, in dem
     Maxima temporäre Dateien ablegt.  Insbesondere werden temporäre
     Grafikausgaben von Funktionen wie `plot2d'  und `plot3d'  in diesem
     Verzeichnis abgelegt.  Der Standardwert von `maxima_tempdir' ist
     das Home-Verzeichnis des Nutzers, sofern Maxima dieses feststellen
     kann.  Andernfalls initialisiert Maxima die Systemvariable
     `maxima_tempdir' mit einer geeigneten Annahme.

     Der Systemvariablen `maxima_tempdir' kann eine Zeichenkette
     zugewiesen werden, die ein Verzeichnis bezeichnet.

 -- Systemvariable: maxima_userdir
     Die Systemvariable `maxima_userdir' enthält ein Verzeichnis, das
     Maxima durchsucht, um Maxima- oder Lisp-Dateien zu finden.  Der
     Standardwert der Systemvariablen `maxima_userdir' ist ein
     Unterverzeichnis des Home-Verzeichnis des Nutzers, sofern Maxima
     dieses bestimmen kann.  Ansonsten initialisiert Maxima die
     Systemvariable `maxima_userdir' mit einer geeigneten Annahme.
     Dieses Verzeichnis ist zum Beispiel geeignet, um die
     Initialisisierungsdateien `maxima-init.mac' und `maxima-init.lisp'
     abzulegen.

     Maxima sucht in weiteren Verzeichnissen nach Dateien.  Die
     vollständige Liste der Suchverzeichnisse ist den Variablen
     `file_search_maxima'  und `file_search_lisp'  enthalten.

     Der Systemvariablen `maxima_userdir' kann eine Zeichenkette
     zugewiesen werden, die ein Verzeichnis bezeichnet.  Wenn der Wert
     von `maxima_userdir' geändert wird, werden die Variablen
     `file_search_maxima' und `file_search_lisp' nicht automatisch
     angepasst.

 -- Funktion: room ()
 -- Funktion: room (true)
 -- Funktion: room (false)
     Gibt eine Beschreibung der Speicherplatznutzung aus.  Die
     Darstellung und der Inhalt der Beschreibung hängt von dem Maxima
     zugrunde liegendem Lisp ab.  Mit den Argumenten `true' und `false'
     kann der Umfang der auszugebenden Information kontrolliert werden,
     sofern die Option vom verwendeten Lisp unterstützt wird.  Mit dem
     Argument `true' wird die umfangreichste Darstellung ausgegeben und
     mit dem Argument `false' die kürzeste.

     Beispiel:

     Das folgende Beispiel zeigt die Ausgabe auf einem Linux-System mit
     der Lisp-Implementierung SBCL 1.0.45.

          (%i1) room(false);
          Dynamic space usage is:   63,719,856 bytes.
          Read-only space usage is:      3,512 bytes.
          Static space usage is:         2,256 bytes.
          Control stack usage is:        1,440 bytes.
          Binding stack usage is:          184 bytes.
          Control and binding stack usage is for the current thread only.
          Garbage collection is currently enabled.
          (%o2)                         false

 -- Funktion: sstatus (<keyword>, <item>)
     Hat das Argument <keyword> den Wert `feature', wird das Argument
     <item> der internen Lisp-Eigenschaftsliste `*features*'
     hinzugefügt.  Das Kommando `status(feature, item)' hat dann das
     Ergebnis `true'.  Hat das Argument <keyword> den Wert `nofeature',
     wird das Argument <item> von der internen Lisp-Eigenschaftsliste
     `*features*' entfernt.

     Siehe auch die Funktion `status'.


 -- Funktion: status (`feature')
 -- Funktion: status (`feature', <item>)
     Das Kommando `status(feature)' gibt die interne
     Lisp-Eigenschaftsliste `*features*' zurück.
     `status(feature,item)' gibt `true' zurück, wenn das Argument
     <item> in der internen Lisp-Eigenschaftsliste `*features*'
     enthalten ist.  Ansonsten ist die Rückgabe `false'.  `status'
     wertet die Argumente nicht aus.  Eine Systemeigenschaft <item>,
     die Sonderzeichen wie `-' oder `*' enthält, muss als Zeichenkette
     angegeben werden.

     Siehe auch die Funktion `sstatus'.

     Die Lisp-Variable `*features*' steht in keinem Zusammenhang mit der
     Maxima-Systemvariablen `features',  die eine Liste mit
     mathematischen Eigenschaften enthält, die Funktionen und Variablen
     erhalten können.

     Beispiel:

     Das folgende Beispiel zeigt die Ausgabe für ein Linux-System mit
     SBCL als Lisp.  Die Ausgabe ist abgekürzt.

          (%i1) status(feature);
          (%o1) [sb-bsd-sockets-addrinfo, asdf2, asdf, cl, mk-defsystem,
          cltl2, ansi-cl, common-lisp, sbcl, ...]

          (%i2) status(feature,"ansi-cl");
          (%o2)                         true

 -- Funktion: system (<command>)
     `system(command)' führt das Kommando <command> in einem eigenen
     Prozess aus.  Das Kommando wird an die Standard-Shell übergeben.
     `system' wird nicht von allen Betriebssystemen unterstützt, steht
     aber im Allgemeinen unter Unix oder Unix ähnlichen
     Betriebssystemen zur Verfügung.

 -- Funktion: time (%o1, %o2, %o3, ...)
     Gibt eine Liste mit den Ausführungszeiten zurück, die benötigt
     wurden, um die Ergebnisse `%o1', `%o2', `%o3', ... zu berechnen.
     Die Argumente der Funktion `time' können nur Ausgabemarken sein.
     Für andere Argumente ist das Ergebnis `unknown'.

     Siehe die Optionsvariable `showtime',  um die Ausführungszeiten für
     jede einzelne Berechnung anzuzeigen.

     Beispiel:

     Die Zeit für die Berechnung der Fakultät einer großen ganzen Zahl
     wird mit `time' ausgegeben.

          (%i1) factorial(100000)$

          (%i2) time(%o1);
          (%o2)                        [7.589]

 -- Funktion: timedate ()
     Gibt eine Zeichenkette zurück, die das aktuelle Datum und die
     aktuelle Zeit enthält.  Die Zeichenkette hat das Format
     `yyyy-mm-dd HH:MM:SS (GMT-n)'.

     Beispiel:

          (%i1) timedate();
          (%o1)               2010-12-28 21:56:32+01:00

 -- Funktion: absolute_real_time ()
     Gibt die Sekunden zurück, die seit dem 1. Januar 1990 UTC
     verstrichen sind.  Die Rückgabe ist eine ganze Zahl.

     Siehe auch `elapsed_real_time'  und `elapsed_run_time'.

     Beispiel:

          (%i1) absolute_real_time ();
          (%o1)                      3502559124
          (%i2) truncate(1900+absolute_real_time()/(365.25*24*3600));
          (%o2)                         2010

 -- Funktion: elapsed_real_time ()
     Gibt die Sekunden zurück, die seit dem letzten Start von Maxima
     verstrichen sind.  Die Rückgabe ist eine Gleitkommazahl.

     Siehe auch `absolute_real_time'  und `elapsed_run_time'.

     Beispiel:

          (%i1) elapsed_real_time ();
          (%o1)                       2.559324
          (%i2) expand ((a + b)^500)$
          (%i3) elapsed_real_time ();
          (%o3)                       7.552087

 -- Funktion: elapsed_run_time ()
     Gibt eine Schätzung der Zeit in Sekunden zurück, die Maxima für
     Berechnungen seit dem letzten Start benötigt hat.  Der
     Rückgabewert ist eine Gleitkommazahl.

     Siehe auch `absolute_real_time'  und `elapsed_real_time'.

     Beispiel:

          (%i1) elapsed_run_time ();
          (%o1)                         0.04
          (%i2) expand ((a + b)^500)$
          (%i3) elapsed_run_time ();
          (%o3)                         1.26


File: maxima.info,  Node: Programmierung,  Next: Übersetzer,  Prev: Laufzeitumgebung,  Up: Top

27 Programmierung
*****************

* Menu:

* Lisp und Maxima::
* Einführung in die Programmierung::
* Funktionen und Variablen der Programmierung::


File: maxima.info,  Node: Lisp und Maxima,  Next: Einführung in die Programmierung,  Prev: Programmierung,  Up: Programmierung

27.1 Lisp und Maxima
====================

Lisp- und Maxima-Bezeichner
---------------------------

Maxima ist in Lisp programmiert.  Es ist einfach, Lisp-Funktionen und
Lisp-Variable in Maxima zu verwenden.  Umgekehrt können
Maxima-Funktionen und Maxima-Variablen in Lisp verwendet werden.  Ein
Lisp-Symbol, das mit einem Dollarzeichen `$' beginnt, entspricht einem
Maxima-Symbol ohne einem Dollarzeichen.  Umgekehrt entspricht einem
Maxima-Symbol, das mit einem Fragezeichen `?' beginnt, ein Lisp-Symbol
ohne das Fragezeichen.  Zum Beispiel entspricht dem Maxima-Symbol `foo'
das Lisp-Symbol `$foo' und dem Maxima-Symbol `?foo' entspricht das
Lisp-Symbol `foo'.

Speziellen Zeichen wie einem Trennstrich `-' oder einem Stern `*' in
Lisp-Symbolen muss ein Backslash `\' vorangestellt werden, um diese in
Maxima zu verwenden.  Zum Beispiel entspricht dem Lisp-Symbol
`*foo-bar*' das Maxima-Symbol `?\*foo\-bar\*'.

Im Gegensatz zu Lisp unterscheidet Maxima Groß- und Kleinschreibung.  Es
gibt einige Regeln, die eine Übersetzung von Namen zwischen Lisp und
Maxima betreffen:

  1. Ein Lisp-Bezeichner, der nicht von senkrechten Strichen
     eingeschlossen ist, entspricht einem klein geschriebenen
     Maxima-Bezeichner.  Die Schreibweise des Lisp-Bezeichners wird
     dabei ignoriert.  Zum Beispiel entspricht den folgenden
     Lisp-Bezeichnern `$foo', `$FOO' und `$Foo' jeweils der
     Maxima-Bezeichner `foo'.

  2. Ein Lisp-Bezeichner, der vollständig groß oder klein geschrieben
     ist und von senkrechten Strichen eingeschlossen wird, entspricht
     einem Maxima-Bezeichner in der umgekehrten Schreibweise.  Ein
     klein geschriebener Lisp-Bezeichner wird also zu einem
     großgeschriebenen Maxima-Bezeichner und umgekehrt.  Zum Beispiel
     entsprechen den Lisp-Bezeichnern `|$FOO|' und `|$foo|' die
     Maxima-Bezeichner `foo' und `FOO'.

  3. Ein Lisp-Bezeichner in gemischter Schreibweise, der von
     senkrechten Strichen eingeschlossen ist, entspricht einem
     Maxima-Bezeichner in der gleichen Schreibweise.  Zum Beispiel
     entspricht dem Lisp-Bezeichner `|$Foo|' der Maxima-Bezeichner
     `Foo'.

Für die Syntax von Maxima-Bezeichnern siehe auch *note Bezeichner::.

Ausführung von Lisp-Code in Maxima
----------------------------------

Lisp-Code kann mit dem Unterbrechungskommando `:lisp' von einer
Maxima-Kommandozeile ausgeführt werden.  Siehe *note
Debugger-Kommandos:: für weitere Unterbrechungskommandos und deren
Beschreibung.

Beispiele:

Addiere die Werte der Maxima-Variablen `x' und `y' mit dem
Lisp-Operator `+'.

     (%i1) x:10$ y:5$
     (%i3) :lisp (+ $x $y)
     15

Addiere die Symbole `a' und `b' mit der Lisp-Funktion `ADD'.  Das
Ergebnis wird der Variablen `$RES' zugewiesen.  Die Variable hat in
Maxima den Namen `res'.

     (%i3) :lisp (setq $res (add '$a '$b))
     ((MPLUS SIMP) $A $B)
     (%i3) res;
     (%o3)                         b + a

Das `:lisp'-Kommando ist nützlich, um zum Beispiel Lisp-Eigenschaften
von Maxima-Symbolen anzuzeigen, globale Lisp-Variablen wie
`*PRINT-CIRCLE*' zu setzen oder wie im letzten Beispiel die interne
Form von Maxima-Ausdrücken anzuzeigen.

     (%i4) :lisp (symbol-plist 'mabs)
     (TEXSYM ((\left| ) \right| ) TEX TEX-MATCHFIX REAL-VALUED T
             MAPS-INTEGERS-TO-INTEGERS T DIMENSION DIM-MABS TRANSLATE
             #<FUNCTION (LAMBDA #) {972D045}> FLOATPROG MABSBIGFLOAT INTEGRAL
             ((X) #<FUNCTION ABS-INTEGRAL>) OPERATORS SIMPABS DISTRIBUTE_OVER
             (MLIST $MATRIX MEQUAL) NOUN $ABS REVERSEALIAS $ABS GRAD
             ((X) ((MTIMES) X ((MEXPT) ((MABS) X) -1))))

     (%i4) :lisp (setq *print-circle* nil)
     NIL

     (%i4) 'integrate(t*sin(t), t);
                               /
                               [
     (%o4)                     I t sin(t) dt
                               ]
                               /
     (%i5) :lisp $%
     ((%INTEGRATE SIMP) ((MTIMES SIMP) $T ((%SIN SIMP) $T)) $T)

Das Kommando `:lisp' kann in einer Kommandozeile und in Dateien
verwendet werden, die mit den Funktionen `batch'  oder `demo'  geladen
werden.  Dagegen kann das Kommando `:lisp' nicht in Dateien verwendet
werden, die mit den Funktionen `load',  `batchload',

`translate_file'  oder `compile_file'  geladen werden.

Ausführung von Maxima-Code in Lisp
----------------------------------

Das Lisp-Makro `#$' erlaubt die Nutzung von Maxima-Ausdrücken in
Lisp-Code.  `#$<expr>$' wird zu einem Lisp-Ausdruck expandiert, der dem
Maxima-Ausdruck <expr> entspricht.

Beispiele:

Die beiden folgenden Beispiele zeigen die Zuweisung an eine Variable
`var'.  Im ersten Beispiel werden Lisp- und Maxima-Code gemischt.  Für
die Zuweisung an die Variable wird die Lisp-Funktion `MSETQ'
aufgerufen.  Das Makro `#$' transformiert den Maxima Ausdruck `sin(x) +
a^2' in die Lisp-Form `((MPLUS SIMP) ((MEXPT SIMP) $A 2) ((%SIN SIMP)
$X))'.  Dies entspricht dem im zweiten Beispiel gezeigten
Maxima-Kommando.

     (%i1) :lisp (msetq $var #$sin(x)+a^2$)
     ((MPLUS SIMP) ((MEXPT SIMP) $A 2) ((%SIN SIMP) $X))

     (%i1) var: sin(x)+a^2;
                                          2
     (%o1)                      sin(x) + a

In diesem Beispiel wird zunächst ein Maxima-Ausdruck der Variablen
`$VAR' zugewiesen und dann mit der Lisp-Funktion `DISPLA' ausgegeben.

     (%i1) :lisp (setq $var #$'integrate(f(x), x)$)
     ((%INTEGRATE SIMP) (($F SIMP) $X) $X)
     (%i1) :lisp (displa $var)
     /
     [
     I f(x) dx
     ]
     /
     NIL

Maxima-Funktionen sind keine Lisp-Funktionen.  Um eine Maxima-Funktion
in Lisp-Code aufzurufen, kann die Lisp-Funktion `MFUNCALL' aufgerufen
werden.

     (%i1) f(x,y) := x^2 + sin(y)$
     (%i2) :lisp (mfuncall '$f '$a 10)
     ((MPLUS SIMP) ((%SIN SIMP) 10) ((MEXPT SIMP) $A 2))

Öffnen einer Lisp-Sitzung
-------------------------

Mit dem Kommando `to_lisp()' kann von einer Maxima-Kommandozeile eine
Lisp-Sitzung geöffnet werden.  Mit dem Kommando `(TO-MAXIMA)' wird die
Lisp-Sitzung beendet und nach Maxima zurückgekehrt.  Siehe auch
`to_lisp'  für ein Beispiel.

Die folgenden Lisp-Funktionen können in Maxima nicht verwendet werden:

`complement', `continue', `/', `float', `functionp', `array', `exp',
`listen', `signum', `atan', `asin', `acos', `asinh', `acosh', `atanh',
`tanh', `cosh', `sinh', `tan', `break', und `gcd'.


File: maxima.info,  Node: Einführung in die Programmierung,  Next: Funktionen und Variablen der Programmierung,  Prev: Lisp und Maxima,  Up: Programmierung

27.2 Einführung in die Programmierung
=====================================

In Maxima können Programme geschrieben werden.  Alle Maxima-Funktionen
und Maxima-Variablen können in Programmen verwendet werden.  Maxima hat
einen Übersetzer, um Maxima-Programme in Lisp-Programme zu übersetzen,
und einen Compiler, um die übersetzten Programme zu kompilieren.  Siehe
dazu das Kapitel Übersetzer.

Maxima-Programme bestehen aus Funktionen und Makros, die im Kapitel
Funktionsdefinitionen  beschrieben sind.  Die Funktionen werden aus
Ausdrücken der Form `(expr_1, expr_2, ..., expr_n)' oder `block'
-Anweisungen zusammengesetzt.  Mit der Anweisung `local'  werden
Variablen definiert, deren Werte und Eigenschaften lokal zu einem Block
sind.

Konditionale Verzweigen werden mit der Anweisung `if'  definiert und
haben die Form `if ... then ... else'.

Maxima kennt die sehr allgemeine Anweisung `for',  um Schleifen zu
programmieren.  Schlüsselworte für die Programmierung von Schleifen sind
`while',  `unless',  `do'  sowie `thru', `step', `in'.

Mit der Sprunganweisung `return'  kann ein Block verlassen werden und
mit der Sprunganweisung `go'  wird innerhalb eines Blockes zu eine Marke
verzweigt.  Nicht-lokale Rücksprünge aus Funktionen werden mit den
Anweisungen `catch'  und `throw'  programmiert.

Die Anweisung `errcatch'  fängt Fehler ab, so dass die Ausführung eines
Programms nicht abgebrochen wird.  Mit der Anweisungen `error'  und
`break'  wird ein Programm abgebrochen.  Im ersten Fall kann eine
Fehlermelung ausgegeben werden und das Programm kehrt zur
Maxima-Kommandozeile zurück.  Mit `break' wird der Maxima-Debugger
gestartet.

Maxima kennt die folgenden Anweisungen und Variablen um Programme zu
definieren:

   backtrace    block        break
   catch        do           eval_when
   errcatch     error        error_size
   error_syms   errormsg     for
   go           if           local
   return       throw        unless
   while


File: maxima.info,  Node: Funktionen und Variablen der Programmierung,  Prev: Einführung in die Programmierung,  Up: Programmierung

27.3 Funktionen und Variablen der Programmierung
================================================

 -- Funktion: backtrace ()
 -- Funktion: backtrace (<n>)
     Gibt den Aufruf-Stack der Funktion zurück, die ausgeführt wird.

     Das Kommando `backtrace()' zeigt den gesamten Stack.
     `backtrace(<n>)' zeigt die letzten <n> Funktionen einschließlich
     der Funktion, die ausgeführt wird.

     `backtrace' kann in einer Batch-Datei, die zum Beispiel mit der
     Funktion `batch'  geladen wird, in einer Funktion oder von einer
     Kommandozeile aufgerufen werden.

     Beispiele:

     `backtrace()' gibt den gesamten Stack aus.

          (%i1) h(x) := g(x/7)$
          (%i2) g(x) := f(x-11)$
          (%i3) f(x) := e(x^2)$
          (%i4) e(x) := (backtrace(), 2*x + 13)$
          (%i5) h(10);
          #0: e(x=4489/49)
          #1: f(x=-67/7)
          #2: g(x=10/7)
          #3: h(x=10)
                                        9615
          (%o5)                         ----
                                         49

     `backtrace(<n>)' gibt die letzten <n> Funktionen aus.

          (%i1) h(x) := (backtrace(1), g(x/7))$
          (%i2) g(x) := (backtrace(1), f(x-11))$
          (%i3) f(x) := (backtrace(1), e(x^2))$
          (%i4) e(x) := (backtrace(1), 2*x + 13)$
          (%i5) h(10);
          #0: h(x=10)
          #0: g(x=10/7)
          #0: f(x=-67/7)
          #0: e(x=4489/49)
                                        9615
          (%o5)                         ----
                                         49

 -- Funktion: block ([<v_1>, ..., <v_m>], <expr_1>, ..., <expr_n>)
 -- Funktion: block (<expr_1>, ..., <expr_n>)
     Mit der Anweisung `block' werden Ausdrücke in einer lokalen
     Umgebung zusammengefasst.  `block' wertet die Argument <expr_1>,
     <expr_2>, ..., <expr_n> nacheinander aus und gibt das Ergebnis des
     letzten ausgewerteten Ausdrucks zurück.  Die Liste `[v_1, ...,
     v_m]' am Anfang der `block'-Anweisung bezeichnet Variablen, die
     innerhalb der `block'-Anweisung lokal sind.  Alle anderen
     Variablen, die in einem Block verwendet werden, beziehen sich auf
     globale Variablen, die auÃerhalb des Block definiert sind.  Dies
     kann ein weiterer Block oder die globale Maxima-Umgebung sein.
     `block' sichert die aktuellen Werte der Variablen <v_1>, ...,
     <v_m>.  Wird `block' verlassen, werden diese Werte
     wiederhergestellt.

     Die Deklaration `local(<v_1>, ..., <v_m>)' innerhalb der
     `block'-Anweisung sichert nicht nur die Werte, sondern auch die
     Eigenschaften der Variablen wie sie zum Beispiel mit den Funktionen
     `declare'  oder `depends'  definiert werden.  Erhalten die mit
     `local' deklarierten Variablen innerhalb der `block'-Anweisung
     Eigenschaften, wirken sich diese nur lokal aus.  Beim Verlassen der
     `block'-Anweisung werden die globalen Eigenschaften
     wiederhergestellt.  Siehe auch `local'.

     Die `block'-Anweisung kann verschachtelt werden.  Jeder Block kann
     eigene lokale Variablen definieren.  Diese sind global zu jedem
     anderen Block der sich innerhalb des Blockes befindet.  Ein
     Variable die nicht als lokal definiert ist, hat den globalen Wert
     eines umgebenden Blocks oder den Wert der globalen Maxima-Umgebung.

     Der Rückgabewert eines Blocks ist der Wert des letzten Ausdrucks
     oder der Wert, der mit den `return'-Anweisung zurückgegeben wird.
     Mit der `go'-Anweisung kann innerhalb eines Blocks zu einer Marke
     gesprungen werden.  Weiterhin kann mit der `throw' -Anweisung ein
     nicht-lokaler Rücksprung zu einer entsprechenden `catch'
     -Anweisung erfolgen.

     Blöcke erscheinen typischerweise auf der rechten Seite einer
     Funktionsdefinitionen.  Sie können aber auch an anderen Stellen
     verwendet werden.

     Beispiel:

     Das Beispiel zeigt eine einfache Implementation des
     Newton-Algorithmus.  Der Block definiert die lokalen Variablen
     `xn', `s' und <numer>.  `numer'  ist eine Optionsvariable, die im
     Block einen lokalen Wert erhält.  Im Block ist das Tag `loop'
     definiert.  Zu diesem Tag wird mit der Anweisung `go(loop)'
     gesprungen.  Der Block und damit die Funktion wird mit der
     Anweisung `return(xn)' verlassen.  Der Wert der Variablen `xn' ist
     das Ergebnis der Funktion `newton'.

          newton(exp,var,x0,eps):=
             block([xn,s,numer],
                numer:true,
                s:diff(exp,var),
                xn:x0,
             loop,
                if abs(subst(xn,var,exp))<eps then return(xn),
                xn:xn-subst(xn,var,exp)/subst(xn,var,s),
                go(loop) )$

 -- Funktion: break (<expr_1>, ..., <expr_n>)
     Wertet die Ausdrücke <expr_1>, ..., <expr_n> aus, zeigt die
     Ergebnisse an und führt dann eine Unterbrechung aus.  Mit dem
     Kommando `exit;' wird Maxima fortgesetzt.  Siehe das Kapitel

     Beispiel:

     Der Variablen `a' wird der Wert 2 zugewiesen.  Dann wird die
     Unterbrechung ausgeführt.  Mit dem Kommando `exit;' wird Maxima
     fortgesetzt.

          (%i1) break(a:2);
          2

          Entering a Maxima break point. Type 'exit;' to resume.
          _a;
          2
          _exit;
          (%o1)                           2

 -- Funktion: catch (<expr_1>, ..., <expr_n>)
     Wertet die Ausdrücke <expr_1>, ..., <expr_n> nacheinander aus.
     Wertet irgendeiner der Ausdrücke zu `throw(arg)' aus, dann ist das
     Ergebnis der Wert von `throw(arg)' und es werden keine weiteren
     Ausdrücke ausgewertet.  Diese nicht-lokale Rückgabe kehrt zu dem
     nächsten `catch' in einer beliebigen Verschachtelungstiefe zurück.
     Wird kein `catch' gefunden gibt Maxima eine Fehlermeldung aus.

     Führt die Auswertung der Argumente nicht zu einem `throw', dann ist
     die Rückgabe das Ergebnis des letzten Ausdrucks `expr_n'.

     Beispiel:

     Die Funktion `g' gibt eine Liste mit den Werten des
     Lambda-Ausdrucks zurück.  Tritt ein negativer Wert auf, bricht die
     Funktion ab, in diesem Beispiel mit `throw(-3)'.

          (%i1) lambda ([x], if x < 0 then throw(x) else f(x))$
          (%i2) g(l) := catch (map (''%, l))$
          (%i3) g ([1, 2, 3, 7]);
          (%o3)               [f(1), f(2), f(3), f(7)]
          (%i4) g ([1, 2, -3, 7]);
          (%o4)                          - 3

 -- Spezieller Operator: do
     Die `do'-Anweisung erlaubt die Definition von Iterationen.
     Aufgrund der großen Allgemeinheit der `do'-Anweisung folgt die
     Beschreibung in zwei Teilen.  Zunächst werden die bekannteren
     Formen beschrieben, wie sie auch in anderen Programmiersprachen
     vorhanden sind.  Dann folgen die weiteren Möglichkeiten.

     Es gibt drei Varianten der `do'-Anweisung, die sich nur durch die
     Abbruchbedingung voneinander unterscheiden.  Diese sind:

          for <variable>: <initial_value> step <increment>
                thru <limit> do <body>

          for <variable>: <initial_value> step <increment>
                while <condition> do <body>

          for <variable>: <initial_value> step <increment>
                unless <condition> do <body>

     <initial_value>, <increment>, <limit> und <body> können beliebige
     Ausdrücke sein.  Ist das Inkrement 1, kann `step' entfallen.

     Die Ausführung der `do'-Anweisung beginnt mit der Zuweisung von
     `initial_value' an die Kontrollvariable <variable>.  Dann folgen
     die Schritte: (1) Hat die Kontrollvariable den Wert einer
     `thru'-Anweisung überschritten oder hat die Bedingung einer
     `unless'-Anweisung den Wert `true' oder hat die Bedingung einer
     `while'-Anweisung den Wert `false', dann endet die Ausführung der
     `do'-Anweisung.  (2) Die Ausdrücke in <body> werden ausgewertet.
     (3) Das Inkrement wird zu der Kontrollvariablen hinzuaddiert.  Die
     Schritte (1) bis (3) werden solange ausgeführt, bis eine der
     Bedingungen für die Beendigung der `do'-Anweisung zutrifft.

     Im Allgemeinen ist der `thru'-Test erfüllt, wenn die
     Kontrollvariable größer als <limit> ist, falls <increment> nicht
     negativ ist.  Oder wenn die Kontrollvariable kleiner als `limit'
     ist, für den Fall, dass das Inkrement negativ ist.  <increment>
     und <limit> können Ausdrücke sein, sofern die Bedingung zum
     Abbruch der `do'-Anweisung ausgewertet werden kann.  Soll
     `increment' zu einem negativen Wert auswerten und kann dies jedoch
     bei Eintritt in die Schleife von Maxima nicht festgestellt werden,
     so wird das Inkrement als positiv angenommen.  Dies kann dazu
     führen, dass die Schleife nicht korrekt ausgeführt wird.

     <limit>, <increment> und die Bedingung für den Abbruch der Schleife
     werden für jeden Durchgang durch die Schleife ausgewertet.  Ändern
     diese ihren Wert nicht, kann es daher effizienter sein, die Werte
     diese Ausdrücke vor Eintritt in die Schleife zu berechnen und in
     Variablen abzulegen, die anstatt der Ausdrücke in der Schleife
     verwendet werden.

     Die `do'-Anweisung hat den Rückgabewert `done'.  Um einen anderen
     Wert zurückzugeben, kann die `return'-Anweisung innerhalb von
     `body' genutzt werden.  Befindet sich die `do'-Anweisung innerhalb
     eines Blockes, so wird dieser nicht mit einer `return'-Anweisung
     verlassen, die sich innerhalb der `do'-Anweisung befindet.  Auch
     kann nicht mit der `go'-Anweisung in einen umgebenen Block
     gesprungen werden.

     Die Kontrollvariable ist immer lokal zur `do'-Anweisung.  Nach dem
     Verlassen der `do'-Anweisung kann auf die Kontrollvariable nicht
     mehr zugegriffen werden.

          (%i1) for a:-3 thru 26 step 7 do display(a)$
                                       a = - 3

                                        a = 4

                                       a = 11

                                       a = 18

                                       a = 25

     Die Bedingung `while i <= 10' ist äquivalent zu den Bedingungen
     `unless i > 10' und `thru 10' ist.

          (%i1) s: 0$
          (%i2) for i: 1 while i <= 10 do s: s+i;
          (%o2)                         done
          (%i3) s;
          (%o3)                          55

     Berechne die ersten acht Terme einer Taylorreihe in einer
     `do'-Schleife.

          (%i1) series: 1$
          (%i2) term: exp (sin (x))$
          (%i3) for p: 1 unless p > 7 do
                    (term: diff (term, x)/p,
                     series: series + subst (x=0, term)*x^p)$
          (%i4) series;
                            7    6     5    4    2
                           x    x     x    x    x
          (%o4)            -- - --- - -- - -- + -- + x + 1
                           90   240   15   8    2

     In diesem Beispiel wird die negative Wurzel von 10 mit einem
     Newton-Raphson-Algorithmus berechnet.

          (%i1) poly: 0$
          (%i2) for i: 1 thru 5 do
                    for j: i step -1 thru 1 do
                        poly: poly + i*x^j$
          (%i3) poly;
                            5      4       3       2
          (%o3)          5 x  + 9 x  + 12 x  + 14 x  + 15 x
          (%i4) guess: -3.0$
          (%i5) for i: 1 thru 10 do
                    (guess: subst (guess, x, 0.5*(x + 10/x)),
                     if abs (guess^2 - 10) < 0.00005 then return (guess));
          (%o5)                  - 3.162280701754386

     Anstatt eines festes Inkrements mit `step' kann die
     Kontrollvariable auch mit `next' für jeden Schleifendurchgang
     berechnet werden.

          (%i6) for count: 2 next 3*count thru 20 do display (count)$
                                      count = 2

                                      count = 6

                                     count = 18

     Anstatt mit der Syntax `for <variable>: <value> ...' kann die
     Kontrollvariable auch mit `for <variable> from <value> ...do...'
     initialisiert werden.  Wird auch `from <value>' fortgelassen, wird
     die Kontrollvariable mit dem Wert 1 initialisiert.

     Manchmal kann es von Interesse sein, in einer Schleife keine
     Kontrollvariable zu nutzen.  In diesem Fall genügt es allein die
     Bedingung für den Abbruch der Schleife anzugeben.  Im folgenden
     wird die Wurzel aus 5 mit dem Heron-Verfahren bestimmt.

          (%i1) x: 1000$
          (%i2) thru 20 do x: 0.5*(x + 5.0/x)$
          (%i3) x;
          (%o3)                   2.23606797749979
          (%i4) sqrt(5), numer;
          (%o4)                   2.23606797749979

     Auch die Abbruchbedingung kann fortgelassen werden.  Wird allein
     `do <body>' angegeben, wird die Schleife unendlich oft ausgeführt.
     Die Schleife kann mit der `return'-Anweisung verlassen werden.
     Das folgende Beispiel zeigt eine Implementierung des
     Newton-Algorithmus.

          (%i1) newton (f, x):= ([y, df, dfx], df: diff (f ('x), 'x),
                    do (y: ev(df), x: x - f(x)/y,
                        if abs (f (x)) < 5e-6 then return (x)))$
          (%i2) sqr (x) := x^2 - 5.0$
          (%i3) newton (sqr, 1000);
          (%o3)                   2.236068027062195

     Eine weitere Syntax ist die folgende:

          for <variable> in <list> <end_tests> do <body>

     Die Elemente der Liste <list> können beliebige Ausdrücke sein, die
     nacheinander der Kontrollvariablen zugewiesen werden.  Die
     Schleife bricht ab, wenn die optionale Abbruchbedingung `end_test'
     zutrifft, wenn die Liste <list> keine weiteren Elemente enthält
     oder wenn die Schleife zum Beispiel mit der Funktion `return'
     verlassen wird.

          (%i1)  for f in [log, rho, atan] do ldisp(f(1))$
          (%t1)                                  0
          (%t2)                                rho(1)
                                               %pi
          (%t3)                                 ---
                                                4
          (%i4) ev(%t3,numer);
          (%o4)                             0.78539816

 -- Funktion: eval_when (<keyword>, <expr_1>, ..., <expr_n>)
 -- Funktion: eval_when ([<keyword_1>, <keyword_2>, ...], <expr_1>,
          ..., <expr_n>)
     Ein Ausdruck mit der Funktion `eval_when' wird an oberster Stelle
     in einer Datei definiert und erlaubt die bedingte Auswertung von
     Ausdrücken beim Laden, Übersetzen oder Kompilieren einer Datei.
     Das Argument <keyword> ist eines der Schlüsselworte `batch',
     `translate', `compile' oder `loadfile'.  Das erste Argument kann
     ein einzelnes Schlüsselwort oder ein Liste mit mehreren
     Schlüsselworten sein.  Trifft die mit dem Schlüsselwort angegebene
     Bedingung zu, wird eine oder mehrere der folgenden Aktionen
     ausgeführt:

    `batch'
          Wird die Datei mit einer der Funktionen `load',  `batch',

          `batchload'  oder `demo'  geladen und ist `batch' in der
          Liste der Schlüsselworte enthalten, dann werden die Ausdrücke
          <expr1>, ..., <expr_n> genau einmal beim Laden der Datei
          ausgewertet.  Die Rückgabe der Funktion `eval_when' ist ein
          Ausdruck `evaluated_when(<result)>', wobei <result> das
          Ergebnis der Auswertung ist.  Ist das Schlüsselwort `batch'
          nicht vorhanden, ist die Rückgabe das Symbol
          `not_evaluated_when'.

    `translate'
          Wird die Datei mit dem Kommando `translate_file'  oder
          `compile_file'  geladen und ist `translate' unter den
          Schlüsselworten, dann werden die Ausdrücke <expr_1>, ...,
          <expr_n> sofort ausgewertet.  Seiteneffekte wie Zuweisungen
          von Werten an Optionsvariablen oder Deklarationen sind für
          die folgende Übersetzung der Datei nach Lisp wirksam.  Die
          Ausdrücke sind jedoch nicht Teil des übersetzten Programms.

    `loadfile'
          Wird die Datei mit dem Kommando `translate_file'  oder dem
          Kommando `compile_file'  geladen und ist `loadfile' unter den
          Schlüsselworten, dann werden die Ausdrücke <expr_1>, ...,
          <expr_n> nach Lisp übersetzt und als Block der Form `(PROGN
          EXPR_1 ... EXPR_N)' in das Lisp Programm eingesetzt.  Hier
          sind die Anweisungen <EXPR_I> die nach Lisp übersetzten
          Maxima-Ausdrücke <expr_i>.

    `compile'
          Wird die Datei mit dem Kommando `translate_file'  oder
          `compile_file'  geladen und ist `compile' unter den
          Schlüsselworten, dann werden die Ausdrücke <expr_1>, ...,
          <expr_n> nach Lisp übersetzt und als eine Lisp-Anweisung in
          das Lisp-Programm eingesetzt, die die Form `(EVAL-WHEN
          (:COMPILE-TOPLEVEL) (EXPR_1 ... EXPR_N))' hat.  Das
          Schlüsselwort `compile' kann nicht mit dem Schlüsselwort
          `loadfile' in einem `eval_when'-Ausdruck kombiniert werden.
          In diesem Fall wird das Schlüsselwort `compile' ignoriert.

     Beispiele:

     Für die folgende Beispiele ist eine Datei mit den Namen
     `eval_when.mac' definiert, die verschiedene `eval_when'-Anweisungen
     enthält.

          (%i1) file: file_search("eval_when.mac");
          (%o1)        /home/dieter/.maxima/eval_when.mac
          (%i2) printfile(file);

          eval_when(batch,     print("called in mode BATCH"));
          eval_when(loadfile,  print("called in mode LOADFILE"));
          eval_when(compile,   print("called in mode COMPILE"));
          eval_when(translate, print("called in mode TRANSLATE"));

          (%o2)        /home/dieter/.maxima/eval_when.mac

     Die Datei wird mit dem Kommando `load' geladen.  Die Anweisung mit
     dem Schlüsselwort `batch' wird beim Laden einmal ausgeführt.

          (%i1) file: file_search("eval_when.mac");
          (%o1)        /home/dieter/.maxima/eval_when.mac
          (%i2) load(file);
          called in mode BATCH
          (%o2)        /home/dieter/.maxima/eval_when.mac

     In diesem Fall wird die Datei mit dem Befehl `batch' geladen.  Die
     Anweisung mit dem Schlüsselwort `batch' wird einmal ausgeführt.
     Die anderen `eval_when'-Anweisungen werten jeweils zum Ergebnis
     `not_evaluated_when' aus.

          (%i3) batch(file);

          read and interpret file: /home/dieter/.maxima/eval_when.mac
          (%i4)     eval_when(batch, print(called in mode BATCH))
          called in mode BATCH
          (%o4)         evaluated_when(called in mode BATCH)
          (%i5)  eval_when(loadfile, print(called in mode LOADFILE))
          (%o5)                  not_evaluated_when
          (%i6)   eval_when(compile, print(called in mode COMPILE))
          (%o6)                  not_evaluated_when
          (%i7) eval_when(translate, print(called in mode TRANSLATE))
          (%o7)                  not_evaluated_when
          (%o7)        /home/dieter/.maxima/eval_when.mac

     Jetzt wird die Datei mit dem Kommando `translate_file' geladen und
     nach Lisp übersetzt.  Der Ausdruck mit dem Schlüsselwort
     `translate' wird sofort ausgewertet.  Das übersetzte Programm wird
     in die Ausgabedatei `eval_when.LISP' geschrieben.  Die
     `eval_when'-Anweisung zum Schlüsselwort wird nicht ausgewertet.

          (%i1) file: file_search("eval_when.mac");
          (%o1)        /home/dieter/.maxima/eval_when.mac
          (%i2) translate_file(file);
          translator: begin translating /home/dieter/.maxima/eval_when.mac.
          called in mode TRANSLATE
          (%o2) [/home/dieter/.maxima/eval_when.mac,
          /home/dieter/.maxima/eval_when.LISP,
          /home/dieter/.maxima/eval_when.UNLISP]

     Dies ist der Inhalt der Ausgabedatei `eval_when.LISP'.  Die
     Ausgabedatei enthält eine `PROGN'-Anweisung mit dem Ausdruck
     `($print '"called in mode LOADFILE")' für den `eval_when'-Ausdruck
     zum Schlüsselwort `loadfile' sowie eine `EVAL-WHEN'-Anweisung mit
     dem Ausdruck `($print '"called in mode COMPILE")' für den
     `eval_when'-Ausdruck mit dem Schlüsselwort `compile'.

     ;;; -*- Mode: Lisp; package:maxima; syntax:common-lisp ;Base: 10 -*- ;;;
     ;;; Translated on: 2011-10-02 13:35:37+02:00
     ;;; Maxima version: 5.25post
     ;;; Lisp implementation: SBCL
     ;;; Lisp version: 1.0.45
     (in-package :maxima)

     [...]

     nil
     (progn ($print '"called in mode LOADFILE"))
     (eval-when (:compile-toplevel) ($print '"called in mode COMPILE"))
     nil

 -- Funktion: errcatch (<expr_1>, ..., <expr_n>)
     Wertet die Ausdrücke <expr_1>, ..., <expr_n> nacheinander aus und
     gibt das Ergebnis des letzten Ausdrucks als eine Liste `[<expr_n>]'
     zurück, wenn kein Fehler bei der Auswertung auftritt.  Tritt ein
     Fehler bei der Auswertung eines der Ausdrücke auf, ist die
     Rückgabe eine leere Liste `[]'.

     `errcatch' ist nützlich in Batch-Dateien.  Mit `errcatch' kann ein
     möglicher Fehler abgefangen werden, ohne das die Verarbeitung der
     Batch-Datei abbricht.

     Beispiele:

          (%i1) errcatch(x:2,1/x);
                                          1
          (%o1)                          [-]
                                          2
          (%i2) errcatch(x:0,1/x);

          Division by 0
          (%o2)                          []

 -- Funktion: error (<expr_1>, ..., <expr_n>)
 -- Systemvariable: error
     Wertet die Ausdrücke <expr_1>, ..., <expr_n> aus, gibt diese auf
     der Konsole aus und generiert einen Fehler, der zur obersten Ebene
     von Maxima führt oder zu dem nächsten `errcatch'.

     Der Systemvariablen `error' wird eine Liste zugewiesen, die eine
     Beschreibung des Fehlers enthält.  Das erste Element der Liste ist
     eine Zeichenkette und die weiteren Elemente enthalten die
     Argumente die keine Zeichenkette sind.

     `errormsg()' formatiert und gibt die Fehlermeldung in `error' aus.
     Damit wird die letzte Fehlermeldung erneut ausgegeben.

     Beispiel:

          (%i1) f(x):= if x=0 then
                          error("Division durch", x, "ist nicht gestattet.")
                       else 1/x$
          (%i2) f(0);

          Division durch 0 ist nicht gestattet.
          #0: f(x=0)
           -- an error. To debug this try: debugmode(true);
          (%i3) errormsg();

          Division durch 0 ist nicht gestattet.
          (%o3)                         done
          (%i4) error;
          (%o4)      [Division durch ~M ist nicht gestattet., 0]

 -- Optionsvariable: error_size
     Standardwert: 10

     `error_size' kontrolliert die Ausgabe eines Ausdrucks der zu einem
     Fehler geführt hat.  Ist der Ausdruck größer als `error_size' wird
     der Ausdruck bei der Ausgabe einer Fehlermeldung durch ein Symbol
     ersetzt und dem Symbol wird der Ausdruck zugewiesen.  Die Symbole
     werden aus der Liste `error_syms' ausgewählt.

     Ist der Ausdruck kleiner als `error_size' wird dieser mit der
     Fehlermeldung ausgegeben.

     Siehe auch `error'  und `error_syms'.

     Beispiel:

     Die Größe des Ausdrucks `U' ist 24.

          (%i1) U: (C^D^E + B + A)/(cos(X-1) + 1)$

          (%i2) error_size: 20$

          (%i3) error ("Example expression is", U);

          Example expression is errexp1
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) errexp1;
                                      E
                                     D
                                    C   + B + A
          (%o4)                    --------------
                                   cos(X - 1) + 1
          (%i5) error_size: 30$

          (%i6) error ("Example expression is", U);

                                   E
                                  D
                                 C   + B + A
          Example expression is --------------
                                cos(X - 1) + 1
           -- an error.  Quitting.  To debug this try debugmode(true);

 -- Optionsvariable: error_syms
     Standardwert: `[errexp1, errexp2, errexp3]'

     In Fehlermeldungen werden Ausdrücke, die größer als `error_size'
     sind, durch Symbole ersetzt, denen der Ausdruck zugewiesen wird.
     Die Symbole werden nacheinander der Liste `error_syms' entnommen.

     Sind keine Symbole mehr vorhanden, werden automatisch neue Symbole
     mit `concat('errexp, <n>)' gebildet.

     Siehe auch `error'  und `error_size'.


 -- Funktion: errormsg ()
     Gibt die letzte Fehlermeldung erneut aus.  Die Fehlermeldung ist
     in der Systemvariablen `errormsg' enthalten.  Die Funktion
     `errormsg' formatiert diese und gibt sie aus.

 -- Optionsvariable: errormsg
     Standardwert: `true'

     Hat die Optionsvariable `errormsg' den `false' wird die Ausgabe
     von Fehlermeldungen unterdrückt.

     Der Optionsvariablen `errormsg' kann in einem Block kein lokaler
     Wert zugewiesen werden.  Der globale Wert von `errormsg' ist stets
     präsent.

     Beispiele:

          (%i1) errormsg;
          (%o1)                                true
          (%i2) sin(a,b);
          Wrong number of arguments to sin
           -- an error. To debug this try: debugmode(true);
          (%i3) errormsg:false;
          (%o3)                                false
          (%i4) sin(a,b);

           -- an error. To debug this try: debugmode(true);

     Der Optionsvariablen `errormsg' kann in einem Block kein lokaler
     Wert zugewiesen werden.

          (%i1) f(bool):=block([errormsg:bool],
                               print ("value of errormsg is",errormsg))$
          (%i2) errormsg:true;
          (%o2)                                true
          (%i3) f(false);
          value of errormsg is true
          (%o3)                                true
          (%i4) errormsg:false;
          (%o4)                                false
          (%i5) f(true);
          value of errormsg is false
          (%o5)                                false

 -- Spezieller Operator: for
     Anweisung für Interationen.  Siehe die `do' -Anweisung für eine
     Beschreibung der Iterationsmöglichkeiten von Maxima.

 -- Funktion: go (<tag>)
     Erlaubt einen Sprung innerhalb eines Blocks zu einer Marke mit dem
     Namen `tag'.  Um eine Anweisung mit einer Sprungmarke zu versehen,
     wird der Anweisung die Marke vorangestellt.  Ein Beispiel ist:

          block ([x], x:1, loop, x+1, ..., go(loop), ...)

     Das Argument der Funktion `go' muss der Name einer Marke sein, die
     in demselben Block erscheint.  Es ist nicht möglich in einen
     anderen Block zu springen.

 -- Spezieller Operator: if
     Ist die bedingte Anweisung.  Verschiedene Formen einer bedingten
     Anweisung sind möglich.

     `if <cond_1> then <expr_1> else <expr_0>' wertet zu <expr_1> aus,
     wenn die Bedingung <cond_1> den Wert `true' hat.  Ansonsten wertet
     der Ausdruck zu <expr_0> aus.

     Die zusammengesetzte bedingte Anweisung `if <cond_1> then <expr_1>
     elseif <cond_2> then <expr_2> elseif ... else <expr_0>' wertet zu
     <expr_k> aus, wenn die Bedingung <cond_k> den Wert `true' hat und
     alle vorhergehenden Bedingungen den Wert `false' haben.  Trifft
     keine der Bedingungen zu, wertet der Ausdruck zu <expr_0> aus.

     Fehlt die Anweisung `else', wird diese zu `else false' angenommen.
     `if <cond_1> then <expr_1>' ist daher äquivalent zu `if <cond_1>
     then <expr_1> else false' und `if <cond_1> then <expr_1> elseif
     ... elseif <cond_n> then <expr_n>' ist äquivalent zu `if <cond_1>
     then <expr_1> elseif ... elseif <cond_n> then <expr_n> else false'.

     Die Anweisungen <expr_0>, ..., <expr_n> können beliebige
     Maxima-Ausdrücke einschließlich weiterer `if'-Anweisungen sein.
     Die Anweisungen werden nicht vereinfacht oder ausgewertet, solange
     die dazugehörende Bedingung nicht das Ergebnis `true' hat.

     Die Bedingungen <cond_1>, ..., <cond_n> sind Ausdrücke, die zu
     `true' oder `false' ausgewertet werden können.  Kann eine Bedingung
     nicht zu `true' oder `false' ausgewertet werden, hängt die Reaktion
     von der Optionsvariablen `prederror' ab.  Hat `prederror' den Wert
     `true', dann meldet Maxima einen Fehler, wenn eine Bedingung nicht
     zu `true' oder `false' ausgewertet werden kann.  Ansonsten werden
     Bedingungen akzeptiert, die nicht zu `true' oder `false'
     ausgewertet werden können und das Ergebnis ist ein bedingter
     Ausdruck.

     Die Bedingungen können die folgenden Operatoren enthalten:

          Operation              Symbol      Typ

          less than              <           relational infix
          less than              <=
            or equal to                      relational infix
          equality (syntactic)   =           relational infix
          negation of =          #           relational infix
          equality (value)       equal       relational function
          negation of equal      notequal    relational function
          greater than           >=
            or equal to                      relational infix
          greater than           >           relational infix
          and                    and         logical infix
          or                     or          logical infix
          not                    not         logical prefix

 -- Funktion: local (<v_1>, ..., <v_n>)
     Speichert alle Eigenschaften der Symbole <v_1>, ..., <v_n>,
     entfernt die Eigenschaften und stellt die abgespeicherten
     Eigenschaften nach dem Austritt aus einem Block oder einem
     zusammengesetzten Ausdruck in dem `local' auftritt wieder her.

     Einige Deklarationen sind als Eigenschaft eines Symbols
     implementiert.  Dazu gehören Deklarationen mit `:=', `array',
     `dependencies', `atvalue', `matchdeclare', `atomgrad', `constant',
     `nonscalar' oder `assume'.  Der Effekt von `local' ist, dass
     solche Deklarationen nur lokal in dem Block wirksam sind.

     `local' kann nur in `block'-Anweisungen oder in einer
     Funktionsdefinition oder in einem Lambda-Ausdruck verwendet
     werden. Weiterhin darf `local' jeweils nur einmal auftreten.

     `local' wertet die Argumente aus.  `local' hat die Rückgabe `done'.

     Beispiel:

     Eine lokale Funktionsdefinition.

          (%i1) foo (x) := 1 - x;
          (%o1)                    foo(x) := 1 - x
          (%i2) foo (100);
          (%o2)                         - 99
          (%i3) block (local (foo), foo (x) := 2 * x, foo (100));
          (%o3)                          200
          (%i4) foo (100);
          (%o4)                         - 99

 -- Funktion: return (<value>)
     Die `return'-Anweisung wird in einem Block verwendet, um den Block
     mit dem Ergebnis <value> zu verlassen.  Siehe `block'  für mehr
     Informationen.

 -- Funktion: throw (<expr>)
     Wertet den Ausdruck <expr> aus und generiert eine Ausnahme mit dem
     Ergebnis der Auswertung, die von der letzten `catch'-Anweisung
     behandelt wird.

 -- Spezieller Operator: while
 -- Spezieller Operator: unless
     Siehe den Operator `do'.



File: maxima.info,  Node: Übersetzer,  Next: Fehlersuche,  Prev: Programmierung,  Up: Top

28 Übersetzer
*************

* Menu:

* Einführung in den Übersetzer::
* Funktionen und Variablen des Übersetzers::


File: maxima.info,  Node: Einführung in den Übersetzer,  Next: Funktionen und Variablen des Übersetzers,  Prev: Übersetzer,  Up: Übersetzer

28.1 Einführung in den Übersetzer
=================================


File: maxima.info,  Node: Funktionen und Variablen des Übersetzers,  Prev: Einführung in den Übersetzer,  Up: Übersetzer

28.2 Funktionen und Variablen des Übersetzers
=============================================

 -- Funktion: compfile (<filename>, <f_1>, ..., <f_n>)
 -- Funktion: compfile (<filename>, functions)
 -- Funktion: compfile (<filename>, all)
     Übersetzt Maxima-Funktionen nach Lisp und schreibt den übersetzten
     Code in die Datei <filename>.  Mit dem Kommando
     `compfile(<filename> <f_1>, ..., <f_n>)' werden die als Argument
     angegebenen Funktionen <f_1>, ..., <f_n> übersetzt.  Die Kommandos
     `compfile(<filename>, functions)' oder `compfile(<filename>, all)'
     übersetzen dagegen alle vom Nutzer definierten Funktionen.

     Die Lisp-Übersetzungen werden nicht ausgewertet.  Auch wird die
     Ausgabedatei nicht kompiliert.  `translate' generiert und wertet
     Lisp-Übersetzungen aus.  Die Funktion `compile_file' übersetzt
     Maxima nach Lisp und führt dann den Lisp-Compiler aus.

     Siehe auch die Funktionen `translate',  `translate_file'  und
     `compile_file'.


 -- Funktion: compile (<f_1>, ..., <f_n>)
 -- Funktion: compile (functions)
 -- Funktion: compile (all)
     Übersetzt die Maxima-Funktionen <f_1>, ..., <f_n> nach Lisp,
     wertet die Lisp-Übersetzungen aus und ruft den Lisp-Compiler für
     jede übersetzte Funktion auf.  `compile' gibt eine Liste mit den
     Namen der kompilierten Funktionen zurück.

     `compile(all)' oder `compile(funtions)' kompiliert alle
     nutzerdefinierten Funktionen.

     `compile' wertet die Argumente nicht aus.  Der Quote-Quote-Operator
     `''' erzwingt die Auswertung.


 -- Funktion: compile_file (<filename>)
 -- Funktion: compile_file (<filename>, <compiled_filename>)
 -- Funktion: compile_file (<filename>, <compiled_filename>,
          <lisp_filename>)
     Übersetzt die Maxima-Datei <filename> nach Lisp, ruft den
     Lisp-Compiler auf und lädt falls erfolgreich den kompilierten Code
     in Maxima.

     `compile_file' gibt eine Liste mit den Namen von vier Dateien
     zurück: die ursprüngliche Maxima-Datei, die Lisp-Übersetzung, eine
     Datei mit Notizen zur Übersetzungen und eine Datei mit dem
     kompilierten Code.  Schlägt die Kompilierung fehlt, ist der vierte
     Eintrag `false'.

     Einige Deklarationen und Definitionen sind bereits vorhanden,
     nachdem der Lisp-Code kompiliert ist und ohne das dieser geladen
     wurde.  Dies schließt Funktionsdefinitionen mit dem Operator `:=',
     Makros definiert mit dem Operator `::=' sowie Definitionen der
     folgenden Funktionen `alias', `declare', `define_variable',
     `mode_declare', `infix', `matchfix', `nofix', `postfix', `prefix'
     und `compfile' ein.

     Zuweisungen und Funktionsaufrufe werden nicht ausgwertet bevor der
     komplierte Code geladen wird.  Im besonderen haben Zuweisungen an
     die Übersetzungsschalter wie `tr_numer' und andere, die in der
     Maxima-Datei aufgeführt sind, keinen Effekt auf die Übersetzung.

     `compile_file' kann Fehler oder Warnungen ausgegeben und `false'
     zurückgegeben, obwohl die Kompilierung erfolgreich ist.  Dies ist
     ein Programmfehler

     Die Datei <filename> darf keine `:lisp'-Anweisungen enthalten.

     `compile_file' wertet die Argumente aus.


 -- Funktion: declare_translated (<f_1>, <f_2>, ...)
     Bei der Übersetzung einer Datei von Maxima-Code nach Lisp-Code ist
     es für den Übersetzer wichtig zu wissen, welche Funktionen der
     Datei bereits übersetzte oder kompilierte Funktionen sind und
     welche Funktionen Maxima-Funktionen oder undefiniert sind.  Mit
     der Deklaration `declare_translated' am Anfang der zu
     übersetzenden Datei wird dem Übersetzer mitgeteilt, dass die als
     Argumente aufgeführten Funktionen <f_1>, <f_2>, ... zur Laufzeit
     des Programms eine Lisp-Funktion repräsentieren.  Fehlt dem
     Übersetzer diese Information wird das Kommando `(MFUNCTION-CALL fn
     arg1 arg2 ...)' generiert.


 -- Optionsvariable: mode_checkp
     Standardwert: `true'

     Hat die Optionsvariable `mode_checkp' den Wert `true' und wird mit
     `mode_declare' für eine Variable, die bereits einen Wert hat, ein
     Typ festgelegt, dann prüft Maxima, ob der vorgesehene Typ zum
     vorliegenden Wert passt.

     Beispiel:

     Im folgenden hat die Variable <n> den Wert 2.0.  Wird <n> mit
     `mode_declare' als eine ganze Zahl definiert, gibt Maxima eine
     Warnung aus, wenn `mode_checkp' den Wert `true' hat.

          (%i1) n: 2.0;
          (%o1)                          2.0
          (%i2) mode_checkp:true;
          (%o2)                         true
          (%i3) mode_declare(n,fixnum);
          warning: n was declared with mode fixnum, but it has value: 2.0
          (%o3)                          [n]
          (%i4) mode_checkp:false;
          (%o4)                         false
          (%i5) mode_declare(n,fixnum);
          (%o5)                          [n]


 -- Optionsvariable: mode_check_errorp
     Standardwert: `false'

     Hat `mode_check_errorp' den Wert `true', bricht `mode_declare' mit
     einer Fehlermeldung ab, wenn für eine Variable die bereits einen
     Wert hat, mit `mode_declare' ein verschiedener Typ deklariert
     werden soll.  Damit diese Optionsvariable wirksam ist, muss
     `mode_checkp' den Wert `true' haben.  Siehe `mode_checkp'.

          (%i1) n: 2.0;
          (%o1)                          2.0
          (%i2) mode_checkp:true;
          (%o2)                         true
          (%i3) mode_check_errorp:true;
          (%o3)                         true
          (%i4) mode_declare(n,fixnum);

          Error: n was declared mode fixnum, has value: 2.0
           -- an error. To debug this try: debugmode(true);


 -- Optionsvariable: mode_check_warnp
     Standardwert: `true'

     Hat `mode_check_warnp' den Wert `true', gibt `mode_declare' eine
     Warnung aus, wenn für eine Variable die bereits einen Wert hat,
     mit `mode_declare' ein verschiedener Typ deklariert werden soll.
     Damit diese Optionsvariable wirksam ist, muss `mode_checkp' den
     Wert `true' haben.  Siehe `mode_checkp'  und `mode_check_errorp'.


 -- Funktion: mode_declare (<y_1>, <mode_1>, ..., <y_n>, <mode_n>)
     `mode_declare' deklariert den Typ von Variablen und Funktionen für
     den Übersetzer und den Kompilierer.  Typischerweise wird
     `mode_declare' am Anfang einer Funktion oder einer Datei mit
     Maxima-Code ausgeführt.

     Die Argumente werden paarweise angegeben und bezeichnen jeweils
     den Namen einer Variablen sowie deren Typ.  Folgende Typen können
     die Variablen erhalten: `boolean', `fixnum', `number', `rational'
     oder `float'.  Anstatt dem Namen einer Variablen kann auch eine
     Liste mit den Namen von Variablen angegeben werden.  In diesem
     Fall erhalten alle Variablen der Liste den angegebenen Typ.

     Ein Array sollte bereits bei seiner Deklaration einen Typ für die
     Elemente erhalten.  Haben alle Elemente des Arrays einen Wert
     sollte das Array mit der Option `complete' deklariert werden, zum
     Beispiel `array(a, complete, dim1, dim2, ...)'.  Sind die Elemente
     des Arrays ganze Zahlen oder Gleitkommazahlen sollte der Typ als
     `fixnum' oder `flonum' deklariert werden.

     Mit der Funktion `mode_declare' kann dann der Typ des Arrays für
     den Übersetzer oder Kompilierer festgelegt werden.  Ein Array der
     Größe 10 `x' 10 mit Gleitkommazahlen erhält die Deklaration
     `mode_declare(completearray(a[10, 10], float)'.

     Der Typ von Funktionen wird mit dem Argument `function(f_1, f2,
     ...)' deklariert.  Hier sind `f_1', `f_2', ... die Funktionen.  Mit
     `mode_declare([function (f_1, f_2, ...)], fixnum)' werden die
     Rückgabewerte der Funktionen `f_1', `f_2', ... als ganze Zahlen
     definiert.

     `modedeclare' ist ein Alias-Name der Funktion `mode_declare'.


 -- Funktion: mode_identity (<mode>, <expr>)
     Mit der Funktion `mode_identity' wird der Typ <mode> für das
     Ergebnis des Ausdrucks <expr> festgelegt.  Hat das Ergebnis einen
     anderen Typ wird in Abhängigkeit von den Werten der
     Optionsvariablen `mode_checkp', `mode_check_warnp' und
     `mode_check_errorp' eine Warnung ausgegeben oder das Programm
     abgebrochen.

     Beispiel:

          (%i1) mode_identity(flonum, sin(1.0));
          (%o1)                   .8414709848078965
          (%i2) mode_identity(integer, sin(1.0));
          warning: sin(1.0) was declared with mode fixnum
                                      , but it has value: .8414709848078965
          (%o2)                   .8414709848078965
          (%i3) mode_identity(integer, sin(a));
          warning: sin(a) was declared with mode fixnum, but it has value:
                                                                     sin(a)
          (%o3)                        sin(a)


 -- Optionsvariable: savedef
     Standardwert: `true'

     Hat `savedef' den Wert `true', wird die Maxima-Definition einer
     Funktion nicht gelöscht, wenn die Funktion übersetzt wird.  Damit
     kann die Definition der Funktion weiterhin mit `dispfun' angzeigt
     werden.

     Hat `savedef' den Wert `false' wird die Maxima-Definition der
     Funktion gelöscht, wenn die Funktion übersetzt wird.

     Beispiele:

     `savedef' hat den Wert `true'.  Die Funktion `f' kann auch nach
     der Übersetzung angzeigt werden und ist in der Liste `functions'
     enthalten.

          (%i1) savedef:true;
          (%o1)                         true
          (%i2) f(x):=x^2+sin(x);
                                          2
          (%o2)                  f(x) := x  + sin(x)
          (%i3) translate(f);
          (%o3)                          [f]
          (%i4) dispfun(f);
                                          2
          (%t4)                  f(x) := x  + sin(x)

          (%o4)                         [%t4]
          (%i5) functions;
          (%o5)                        [f(x)]

     Dasselbe für eine Funktion `g' mit dem Wert `false' für `savedef'.

          (%i6) savedef:false;
          (%o6)                         false
          (%i7) g(x):=sqrt(x)+cos(x)$

          (%i8) translate(g);
          (%o8)                          [g]
          (%i9) dispfun(g);

          fundef: no such function: g
           -- an error. To debug this try: debugmode(true);
          (%i10) functions;
          (%o10)                       [f(x)]


 -- Optionsvariable: transcompile
     Standardwert: `true'

     Hat `transcompile' den Wert `true', generieren die Funktionen
     `translate' und `translate_file' Deklarationen, die das Kompilieren
     des Codes verbessern.

     `compfile' setzt den Wert von `transcompile' zu `true'.


 -- Funktion: translate (<f_1>, ..., <f_n>)
 -- Funktion: translate (functions)
 -- Funktion: translate (all)
     Die vom Nutzer definierten Maxima-Funktionen <f_1>, ..., <f_n>
     werden nach Lisp übersetzt.  Typischerweise sind die übersetzten
     Funktionen schneller als die Maxima-Funktionen.

     `translate(all)' oder `translate(functions)' übersetzt alle vom
     Benutzer definierten Funktionen.

     Funktionen, die übersetzt werden sollen, sollten mit
     `mode_declare' den Typ von Variablen und Funktionen deklarieren,
     um effizienteren Code zu erhalten.  Im Folgenden Beispiel sind
     <x_1>, <x_2>, ... die Argumente der Funktion und <v_1>, <v_2>, ...
     sind die lokalen Variablen.

          f (x_1, x_2, ...) := block ([v_1, v_2, ...],
              mode_declare (v_1, mode_1, v_2, mode_2, ...), ...)

     Die Namen von übersetzten Funktionen werden von der
     Informationsliste `functions' entfernt, wenn die Optionsvariable
     `savedef' den Wert `false' hat.  Sie werden der Informationsliste
     `props' hinzugefügt.

     Funktionen sollten erst übersetzt werden, wenn sie vollständig von
     Fehlern befreit wurden.

     Ausdrücke werden als vereinfacht angenommen.  Sind sie es nicht,
     wird zwar korrekter, aber nicht optimierter Code erzeugt.  Daher
     sollte der Schalter `simp' nicht den Wert `false' haben, wodurch
     die Vereinfachung von Ausdrücken unterdrückt wäre.

     Hat der Schalter `translate' den Wert `true', werden
     nutzerdefinierte Funktionen automatisch nach Lisp übersetzt.

     Das Laufzeitverhalten von übersetzten Funktionen kann sich von dem
     nicht-übersetzter Funktionen unterscheiden.  Grundsätzlich sollte
     die Funktion `rat' nicht mit mehr als zwei Argumenten und die
     Funktion `ratvars' nicht genutzt werden, wenn irgendeine der
     Variablen eine CRE-Form mit Deklaration mit `mode_declare'
     aufweisen.  Auch wird `prederror:false' nicht übersetzt.

     Hat die Optionsvariable `savedef' den Wert `true', wird die
     Originalversion einer Funktion nicht entfernt.  Siehe `savedef'.
     Mit dem Wert `false' für `transrun' werden, wenn noch vorhanden,
     die Originalversionen der übersetzten Funktion ausgeführt.

     Das Ergebnis der Funktion `translate' ist eine Liste der Namen der
     übersetzten Funktionen.


 -- Funktion: translate_file (<maxima_filename>)
 -- Funktion: translate_file (<maxima_filename>, <lisp_filename>)
     Übersetzt eine Datei mit Maxima-Code in eine Datei mit Lisp-Code.
     `translate_file' gibt eine Liste mit drei Dateien zurück, die den
     Namen der Maxima-Datei, den Namen der Lisp-Datei und den Namen
     einer Datei mit Informationen zur Übersetzung enthält.
     `translate_file' wertet die Argumente aus.

     Die Kommandos `translate_file("foo.mac")' und `load("foo.LISP")'
     haben bis auf wenige Ausnahmen dieselbe Wirkung wie
     `batch("foo.mac")'.  Zum Beispiel funktionieren `''' und `%'
     unterschiedlich.

     `translate_file(<maxima_filename>)' übersetzt die Maxima-Datei
     <maxima_filename> in ein Lisp-Datei mit einem vergleichbaren
     Namen.  Zum Beispiel wird die Maxima-Datei `foo.mac' zu
     `foo.LISP'.  Der Name der Maxima-Datei kann Pfadangaben enthalten.
     In diesem Fall wird die Lisp-Datei in dasselbe Verzeichnis wie die
     Maxima-Datei geschrieben.

     `translate_file(<maxima_filename>, <lisp_filename>)' übersetzt die
     Maxima-Datei <maxima_filename> in eine Lisp-Datei mit dem Namen
     `lisp_filename'.  `translate_file' ignoriert eine angegebene
     Dateiendung des Dateinamenes `lisp_filename'.  Die Dateiendung ist
     immer `.LISP'.  Der Name der Lisp-Datei kann Pfadangaben
     enthalten, um die Lisp-Datei in das gewünschte Verzeichnis zu
     schreiben.

     `translate_file' schreibt eine Ausgabedatei mit Meldungen des
     Übersetzers.  Die Dateiendung der Ausgabedatei ist `.UNILISP'.  Die
     Informationen dieser Datei können für die Fehlersuche genutzt
     werden.  Die Datei wird immer in das Verzeichnis geschrieben, das
     die Maxima-Datei enthält.

     `translate_file' generiert Lisp-Code mit Deklarationen und
     Definitionen, die bereits beim Kompilieren des Codes wirksam
     werden.  Siehe `compile_file'  für mehr Informationen.

     Siehe auch die folgenden Optionsvariablen:

     `tr_array_as_ref',
     `tr_bound_function_applyp',
     `tr_exponent',
     `tr_file_tty_messagesp',
     `tr_float_can_branch_complex',
     `tr_function_call_default',
     `tr_numer',
     `tr_optimize_max_loop',
     `tr_semicompile',
     `tr_state_vars',
     `tr_warnings_get',
     `tr_warn_bad_function_calls',
     `tr_warn_fexpr',
     `tr_warn_meval',
     `tr_warn_mode',
     `tr_warn_undeclared',
     und `tr_warn_undefined_variable'.


 -- Optionsvariable: transrun
     Standardwert: `true'

     Hat `transrun' den Wert `false', werden die nicht-übersetzten
     Versionen ausgeführt, falls diese noch vorhanden sind.  Siehe
     `savedef'.


 -- Optionsvariable: tr_array_as_ref
     Standardwert: `true'

     Hat `translate_fast_arrays' den Wert `false', werden Referenzen auf
     Arrays in Lisp-Code von der Variablen `tr_array_as_ref'
     kontrolliert.  Hat `tr_array_as_ref' den Wert `true', werden
     Array-Namen ausgewertet.

     `tr_array_as_ref' hat keinen Effekt, wenn `translate_fast_arrays'
     den Wert `true' hat.


 -- Optionsvariable: tr_bound_function_applyp
     Standardwert: `true'

     Hat `tr_bound_function_applyp' den Wert `true', gibt Maxima eine
     Warnung aus, wenn versucht wird, eine gebundene Variable als eine
     Funktion verwendet werden soll.  `tr_bound_function_applyp' hat
     keinen Effekt auf den generierten Code.

     Zum Beispiel gibt ein Ausdruck der Form  `g (f, x) := f (x+1)' eine
     Warnung.


 -- Optionsvariable: tr_file_tty_messagesp
     Standardwert: `false'

     Hat `tr_file_tty_messagesp' den Wert `true', werden Meldungen die
     von der Funktion `translate_file' während einer Übersetzung
     generiert werden auch auf der Konsole ausgegeben.  Ansonsten
     werden Meldungen nur in die Datei `.UNILISP' geschrieben.


 -- Optionsvariable: tr_float_can_branch_complex
     Standardwert: `true'

     Erklärt dem Übersetzer, dass die Funktionen `acos', `asin', `asec'
     und `acsc' komplexe Werte zurückgegeben können.


 -- Optionsvariable: tr_function_call_default
     Standardwert: `general'

     `false' bedeutet, gebe auf und rufe `meval' auf, `expr' bedeutet,
     nehme Lisp-Argumente an.  `general', der Standardwert, gibt Code
     der für `MEXPRS'-Funktionen geeignet ist.  Wird Maxima-Code mit
     dem Standardwert `general' übersetzt, ohne dass Warnmeldungen
     ausgegeben werden, kann davon ausgegangen werden, dass der
     übersetzte und komplilierte Code kompatibel mit der ursprünglichen
     Funktion ist.


 -- Optionsvariable: tr_numer
     Standardwert: `false'

     Hat `tr_numer' den Wert `true', wird die `numer'-Eigenschaft von
     Symbolen vom Übersetzer angewendet.


 -- Optionsvariable: tr_optimize_max_loop
     Standardwert: 100

     `tr_optimize_max_loop' enthält die maximale Anzahl an Durchgängen,
     um Makros zu expandieren und den Code zu optimieren.  Damit werden
     unendliche Schleifen des Übersetzers vermieden.


 -- Optionsvariable: tr_semicompile
     Standardwert: `false'

     Hat `tr_semicompile' den Wert `true', geben die Funktionen
     `translate_file' und `compfile' Code aus, in dem Makrofunktionen
     expandiert sind, der aber nicht kompliliert ist.


 -- Systemvariable: tr_state_vars
     Standardwert: [transcompile, tr_semicompile, tr_warn_undeclared, tr_warn_meval,
     tr_warn_fexpr, tr_warn_mode, tr_warn_undefined_variable,
     tr_function_call_default, tr_array_as_ref,tr_numer]

     Enthält eine Liste der Schalter, die die Übersetzung kontrollieren.


 -- Funktion: tr_warnings_get ()
     Gebe die Liste der Warnungen aus, welche bei der letzten
     Übersetzung erzeugt wurden.


 -- Optionsvariable: tr_warn_bad_function_calls
     Standardwert: `true'

     Gebe Warnungen aus, wenn Funktionsaufrufe generiert werden, die
     möglicherweise nicht korrekt sind, aufgrund von ungeeigneten
     Deklarationen für die Übersetzung.


 -- Optionsvariable: tr_warn_fexpr
     Standardwert: `compfile'

     Gebe Warnungen aus, wenn `FEXPR'-Ausdrücke im übersetzten Code
     auftreten.


 -- Optionsvariable: tr_warn_meval
     Standardwert: `compfile'

     Gebe Warnungen aus, wenn die Funktion `meval' aufgerufen wird.
     Dies signalisiert Probleme bei der Übersetzung.


 -- Optionsvariable: tr_warn_mode
     Standardwert: `all'

     Gebe Warnungen aus, wenn Variablen Werte zugewiesen werden, die
     nicht zu dem deklarierten Typ passen.


 -- Optionsvariable: tr_warn_undeclared
     Standardwert: `compile'

     Kontrolliert, wann Warnungen über nicht-deklarierte Variablen
     angezeigt werden sollen.


 -- Optionsvariable: tr_warn_undefined_variable
     Standardwert: `all'

     Gebe eine Warnung aus, wenn undefinierte globale Variablen
     auftreten.



File: maxima.info,  Node: Fehlersuche,  Next: Verschiedenes,  Prev: Übersetzer,  Up: Top

29 Fehlersuche
**************

* Menu:

* Quellcode-Debugger::
* Debugger-Kommandos::
* Funktionen und Variablen der Fehlersuche::


File: maxima.info,  Node: Quellcode-Debugger,  Next: Debugger-Kommandos,  Up: Fehlersuche

29.1 Quellcode-Debugger
=======================

Maxima hat einen Quellcode-Debugger.  Es können Unterbrechungspunkte
gesetzt werden, um die Ausführung einer Funktion abzubrechen und um
schrittweise die Funktion zu testen.  Der Stapelspeicher und Variable
können untersucht werden.

Das Kommando `:help' oder `:h' zeigt eine Liste mit den
Debugger-Kommandos.  Innerhalb des Debuggers können alle
Maxima-Funktionen genutzt werden, um Variablen und Ausdrücke
auszugeben, zu definieren oder anderweitig zu manipulieren.

Eine Unterbrechnung wird mit dem Kommando `:br' gesetzt.  Mit dem
Kommando `:n' oder `:next' wird die nächste Programmzeile ausgeführt.
Das Kommando `:bt' oder `:backtrace' zeigt eine Liste der Stack Frames.
Mit dem Kommando `:r' oder `:resume' wird der Debugger verlassen.

Beispiele:

     (%i1) load ("/tmp/foobar.mac");

     (%o1)                           /tmp/foobar.mac

     (%i2) :br foo
     Turning on debugging debugmode(true)
     Bkpt 0 for foo (in /tmp/foobar.mac line 1)

     (%i2) bar (2,3);
     Bkpt 0:(foobar.mac 1)
     /tmp/foobar.mac:1::

     (dbm:1) :bt                        <-- :bt typed here gives a backtrace
     #0: foo(y=5)(foobar.mac line 1)
     #1: bar(x=2,y=3)(foobar.mac line 9)

     (dbm:1) :n                         <-- Here type :n to advance line
     (foobar.mac 2)
     /tmp/foobar.mac:2::

     (dbm:1) :n                         <-- Here type :n to advance line
     (foobar.mac 3)
     /tmp/foobar.mac:3::

     (dbm:1) u;                         <-- Investigate value of u
     28

     (dbm:1) u: 33;                     <-- Change u to be 33
     33

     (dbm:1) :r                         <-- Type :r to resume the computation

     (%o2)                                1094

Die im obigen Beispiel geladene Datei `/tmp/foobar.mac' hat den
folgenden Inhalt:

     foo(y) := block ([u:y^2],
       u: u+3,
       u: u^2,
       u);

     bar(x,y) := (
       x: x+2,
       y: y+2,
       x: foo(y),
       x+y);

Nutzung des Debuggers mit Emacs
-------------------------------

Wird Maxima unter GNU Emacs in einer Shell ausgeführt oder wird die
Nutzeroberfläche Xmaxima verwendet, dann wird in einem zweiten
Ausgabefenster die Position einer Unterbrechung im Quellcode angezeigt.
Mit dem Emacs-Kommando `M-n' kann dann schrittweise die Funktion
ausgeführt werden.

Um diese Funktionalität zu nutzen, sollte Emacs in einer `dbl'-Shell
ausgeführt werden.  Dazu benötigt Emacs die Datei `dbl.el' im elisp
Verzeichnis.  Dazu müssen die elisp-Dateien installiert oder das Maxima
elisp Verzeichnis bekannt sein.  Dazu können die folgenden Kommandos der
Datei `.emacs' hinzugefügt werden:

     (setq load-path (cons "/usr/share/maxima/5.9.1/emacs" load-path))
     (autoload 'dbl "dbl")

Mit dem Emacs-Kommando `M-x dbl' wird eine Shell gestartet, in der
Programme wie Maxima, gcl, gdb u. a. ausgeführt werden können.  In
dieser Shell kann auch der Maxima-Debugger ausgeführt werden.

The user may set a break point at a certain line of the file by typing
`C-x space'.  This figures out which function the cursor is in, and then
it sees which line of that function the cursor is on.   If the cursor
is on,  say, line 2 of `foo', then it will insert in the other window
the  command, "`:br foo 2'", to break `foo' at its second line.  To
have this enabled, the user must have maxima-mode.el turned on in the
window  in which the file `foobar.mac' is visiting.  There are
additional  commands available in that file window, such as evaluating
the function into  the Maxima, by typing `Alt-Control-x'.


File: maxima.info,  Node: Debugger-Kommandos,  Next: Funktionen und Variablen der Fehlersuche,  Prev: Quellcode-Debugger,  Up: Fehlersuche

29.2 Debugger-Kommandos
=======================

Es gibt spezielle Kommandos, die von Maxima nicht als ein Ausdruck
interpretiert werden.  Diese Kommandos beginnen mit einem Doppelpunkt
`:' und können in der Kommandozeile oder nach einer Unterbrechung
ausgeführt werden.  Mit dem Kommando `:lisp' werden zum Beispiel
Lisp-Zeilen ausgewertet:

     (%i1) :lisp (+ 2 3)
     5

Die Anzahl der Argumente hängt vom jeweiligen Kommando ab.  Die
Kommandos können mit den ersten zwei Buchstaben abgekürzt werden.  Zum
Beispiel genügt es `:br' für das Kommando `:break' einzugeben.

Die speziellen Kommandos sind folgende:

`:break F n'
     Setzte einen Unterbrechnungspunkt in der Funktion `F' in der Zeile
     `n' vom Anfang der Funktion.  Wird `F' als eine Zeichenkette
     angegeben, dann wird `F' als der Name einer Datei angenommen.  `n'
     ist in diesem Fall die `n'-te Zeile in der Datei.  Wird `n' nicht
     angegeben, wird der Wert zu Null angenommen.

`:bt'
     Gebe einen Backtrace des Stack Frames aus.

`:continue'
     Setze die Ausführung der Funktion fort.

`:delete'
     Lösche den spezifizierten Unterbrechnungspunkt oder alle, wenn
     keiner spezifiziert wird.

`:disable'
     Schalte den spezifierten oder alle Unterbrechnungspunkte ab.

`:enable'
     Schalte den spezifizierten oder alle Unterbrechnungspunkte ein.

`:frame n'
     Gebe den Stack Frame `n' oder den aktuellen aus, wenn keiner
     spezifiert wird.

`:help'
     Gebe einen Hilfetext zu einem spezifierten Kommando oder zu allen
     Kommandos aus, wenn kein Kommando spezifierten wird.

`:info'
     Gebe Information über einen Eintrag aus.

`:lisp some-form'
     Werte `some-form' als eine Lisp-Form aus.

`:lisp-quiet some-form'
     Werte `some-form' als eine Lisp-Form aus, ohne eine Ausgabe zu
     erzeugen.

`:next'
     Wie `:step', führt aber Funktionsaufrufe als einen Schritt aus.

`:quit'
     Beende den Debugger.

`:resume'
     Setzte die Ausführung des Programms fort.

`:step'
     Setzte die Auswertung des Programms bis zur nächsten Zeile fort.

`:top'
     Beende die Auswertung und kehre zur Maxima-Eingabe zurück.



File: maxima.info,  Node: Funktionen und Variablen der Fehlersuche,  Prev: Debugger-Kommandos,  Up: Fehlersuche

29.3 Funktionen und Variablen der Fehlersuche
=============================================

 -- Optionsvariable: debugmode
     Standardwert: `false'

     Hat die Optionsvariable `debugmode' den Wert `true', wird der
     Maxima-Debugger gestartet, wenn ein Programmfehler auftritt.  Nach
     der Unterbrechung des Programms kann der Debugger genutzt werden.
     Siehe das Kapitel Debugger-Kommandos  für eine Liste der Kommandos
     des Debuggers.

     Der Maxima-Debugger behandelt keine Lisp-Programmfehler.


 -- Optionsvariable: refcheck
     Standardwert: `false'

     Hat `refcheck' den Wert `true', gibt Maxima eine Meldung aus, wenn
     einer Variablen zum ersten Mal ein Wert zugewiesen wird.


 -- Optionsvariable: setcheck
     Standardwert: `false'

     Der Optionsvariablen `setcheck' kann eine Liste mit den Namen von
     Variablen zugewiesen werden.  Dies können auch indizierte
     Variablen sein.  Immer wenn einer der Variablen mit den Operatoren
     `:' oder `::' ein Wert zugewiesen wird, gibt Maxima eine Meldung
     aus, die den Namen der Variablen und den zugewiesenen Wert enthält.

     `setcheck' kann den Wert `all' oder `true' erhalten.  In diesem
     Fall wird für alle Variablen eine Meldung ausgegeben.

     Jede Zuweisung an `setcheck' initialisert eine neue Liste mit
     Variablen.  Vorherige Zuweisungen werden überschrieben.

     Die Auswertung der Namen der Variablen muss mit dem Quote-Operator
     `'' unterdrückt werden, wenn den Variablen bereits Werte
     zugewiesen wurden.  Haben zum Beispiel die Variablen `x', `y' und
     `z' Werte, dann werden die Variablen mit dem folgenden Befehl
     angegeben:

          setcheck: ['x, 'y, 'z]$

     Es wird keine Meldung ausgegeben, wenn eine Variable sich selbst
     zugewiesen wird, zum Beispiel `X: 'X'.


 -- Optionsvariable: setcheckbreak
     Standardwert: `false'

     Hat `setcheckbreak' den Wert `true', startet Maxima den Debugger,
     wenn einer Variablen, die in der Liste `setcheck' enthalten ist,
     ein Wert zugewiesen wird.  Die Unterbrechung wird noch vor der
     Zuweisung des Wertes ausgeführt.  Die Variable `setval' enhält den
     Wert, der zugewiesen werden soll.  Dieser Variablen kann ein
     anderer Wert zugewiesen werden.

     Siehe auch `setcheck'  und `setval'.


 -- Systemvariable: setval
     Enthält den Wert, der einer Variable zugewiesen werden soll, wenn
     die Zuweisung mit der Optionsvariablen `setcheckbreak'
     unterbrochen wurde.  `setval' kann ein anderer Wert zugewiesen
     werden.

     Siehe auch `setcheck'  und `setcheckbreak'.


 -- Funktion: timer (<f_1>, ..., <f_n>)
 -- Funktion: timer (all)
 -- Funktion: timer ()
     Sammelt Statistiken über die Ausführungszeiten von Funktionen.  Die
     Argumente <f_1>, ..., <f_n> sind die Namen von Funktionen zu denen
     Statistiken gesammelt werden.  `time(g)' fügt die Funktion `g' der
     Liste an Funktionen hinzu, zu denen Informationen gesammelt werden.

     `timer(all)' fügt alle nutzerdefinierten Funktionen, die in der
     Informationsliste `functions' enthalten sind, der Liste der
     Funktionen hinzu, über die Informationen gesammelt werden.

     Wird `timer()' ohne Argumente aufgerufen, wird eine Liste der
     Funktionen zurückgeben, über die Informationen gesammelt werden.

     Maxima misst die Zeit, die eine Funktion für die Ausführung
     benötigt.  `timer_info' gibt eine Statistik für alle Funktionen
     zurück, für die die Ausführungszeiten gemessen werden.  Die
     Statistik enthält die durchschnittliche Ausführungszeit der
     Funktionen und die Anzahl der Aufrufe der Funktionen.  Mit der
     Funktion `untimer' wird die Aufzeichnung der Ausführungszeiten
     beendet.

     `timer' wertet die Argumente nicht aus.  Daher werden im Folgenden
     `f(x) := x^2$ g:f$ timer(g)$' für die Funktion `f' keine
     Ausführungszeiten aufgezeichnet.

     Wird für die Funktion `f' mit dem Kommando `trace(f)' der Ablauf
     verfolgt, hat das Kommando `timer(f)' keinen Effekt.  Für eine
     Funktion können nicht gleichzeitig Ausführungszeiten aufgezeichnet
     und der Ablauf verfolgt werden.

     Siehe auch `timer_devalue'.


 -- Funktion: untimer (<f_1>, ..., <f_n>)
 -- Funktion: untimer ()
     `untimer' beendet die Aufzeichnung von Informationen zur
     Ausführungszeit für die Funktionen <f_1>, ..., <f_n>.

     Wird `untimer' ohne Argument aufgerufen, wird die Aufzeichnung für
     alle Funktionen beendet.

     Die aufgezeichneten Informationen zu einer Funktion `f' können mit
     dem Kommando `timer_info(f)' auch dann abgerufen werden, wenn
     zuvor mit dem Kommando `untimer(f)' die Aufzeichnung für die
     Funktion `f' beendet wurde.  Jedoch werden die aufgezeichneten
     Informationen für die Funktion `f' nicht mit dem Kommando
     `timer_info()' angezeigt.  Das Kommando `timer(f)' setzt alle
     aufgezeichneten zurück und startet die Aufzeichnung für die
     Funktion erneut.


 -- Optionsvariable: timer_devalue
     Standardwert: `false'

     Hat `timer_devalue' den Wert `true', subtrahiert Maxima bei der
     Aufzeichnung der Ausführungszeiten die Zeiten, welche eine
     Funktion in anderen Funktionen verbringt.  Ansonsten enthalten die
     aufgezeichneten Zeiten auch die Ausführungszeiten der Funktionen,
     die aufgerufen werden.

     Siehe auch `timer'  und `timer_info'.


 -- Funktion: timer_info (<f_1>, ..., <f_n>)
 -- Funktion: timer_info ()
     Gibt eine Tabelle mit den aufgezeichneten Informationen über die
     Ausführungszeiten der Funktionen <f_1>, ..., <f_n> zurück.  Wird
     kein Argument angegeben, werden Informationen für alle Funktionen
     angezeigt, zu denen Informationen aufgezeichnet sind.

     Die Tabelle enthält die Namen der Funktionen, die Ausführungszeit
     pro Aufruf, die Anzahl der Aufrufe, die gesamte Zeit und die
     `gctime'-Zeit.  Die `gctime'-Zeit bedeutet "Garbage Collection
     Time".

     Die Daten, die von der Funktion `timer_info' angezeigt werden,
     können auch mit der Funktion `get' erhalten werden:

          get(f, 'calls);  get(f, 'runtime);  get(f, 'gctime);

     Siehe auch `timer'.


 -- Funktion: trace (<f_1>, ..., <f_n>)
 -- Funktion: trace (all)
 -- Funktion: trace ()
     Startet die Ablaufverfolgung für die Funktionen <f_1>, ..., <f_n>.
     Mit dem Kommando `trace(g)' kann eine weitere Funktion hinzugefügt
     werden.

     `trace(all)' startet die Ablaufverfolgung für alle
     nutzerdefinierten Funktionen, die in der Informationsliste
     `functions' enthalten sind.

     Das Kommando `trace()' zeigt eine Liste aller Funktionen für die
     eine Ablaufverfolgung gestartet wurde.

     Mit der Funktion `untrace' wird die Ablaufverfolgung beendet.
     Siehe auch `trace_options'.

     `trace' wertet die Argumente nicht aus.

     Die Ablaufverfolgung kann für eine Funktion `f' nicht gestartet
     werden, wenn für die Funktion bereits mit der Funktion `timer'
     Informationen über die Ausführungszeiten gesammelt werden.


 -- Funktion: trace_options (<f>, <option_1>, ..., <option_n>)
 -- Funktion: trace_options (<f>)
     Setzt Optionen für die Ablaufverfolgung einer Funktion <f>.
     Bereits vorliegende Optionen werden ersetzt.

     `trace_options(<f>)' setzt alle Optionen auf die Standardwerte
     zurück.

     Die Optionen sind:

    `noprint'
          Gebe keine Meldung beim Eintritt in eine oder dem Austritt
          aus einer Funktion aus.

    `break'
          Setze eine Unterbrechnung vor dem Eintritt in eine Funktion
          und nach dem Austritt aus einer Funktion.  Siehe `break'.

    ``lisp_print''
          Zeige die Argumente und Rückgabewerte in der Lisp-Syntax an.

    `info'
          Gebe `-> true' beim Eintritt in und Austritt aus einer
          Funktion aus.

    ``errorcatch''
          Catch errors, giving the option to signal an error,  retry
          the function call, or specify a return value.


     Es können bedingte Optionen für die Ablaufverfolgung definiert
     werden.  Dazu wird eine Option zusammen mit einer Aussagefunktion
     angegeben.  Die Argumente der Aussagefunktion für eine bedingte
     Option sind immer `[level, direction, function, item]'.  `level'
     ist die Rekursionstiefe der Funktion, `direction' enthält die
     Werte `enter' oder `exit', `function' ist der Name der Funktion
     und `item' ist eine Liste der Argumente oder der Rückgabewert beim
     Verlassen der Funktion.

     Dies ist ein Beispiel für eine Ablaufverfolgung ohne Bedingungen:

          (%i1) ff(n) := if equal(n, 0) then 1 else n * ff(n - 1)$

          (%i2) trace (ff)$

          (%i3) trace_options (ff, lisp_print, break)$

          (%i4) ff(3);

     In diesem Fall wird eine Aussagefunktion für eine bedingte
     Ablaufverfolgung angegeben:

          (%i5) trace_options (ff, break(pp))$

          (%i6) pp (level, direction, function, item) := block (print (item),
              return (function = 'ff and level = 3 and direction = exit))$

          (%i7) ff(6);


 -- Funktion: untrace (<f_1>, ..., <f_n>)
 -- Funktion: untrace ()
     Beendet die Ablaufverfolgung für die Funktionen <f_1>, ..., <f_n>.
     Das Kommando `untrace()' beendet die Ablaufverfolgung für alle
     Funktionen.

     `untrace' gibt eine Liste der Funktionen zurück, für die die
     Ablaufverfolgung beendet wurde.



File: maxima.info,  Node: Verschiedenes,  Next: abs_integrate,  Prev: Fehlersuche,  Up: Top

30 Verschiedenes
****************

* Menu:

* Einführung in Verschiedenes::
* Share-Pakete::
* Funktionen und Variablen für Verschiedenes::


File: maxima.info,  Node: Einführung in Verschiedenes,  Next: Share-Pakete,  Prev: Verschiedenes,  Up: Verschiedenes

30.1 Einführung in Verschiedenes
================================

Dieses Kapitel enthält verschiedene Funktionen und Optionsvariablen.


File: maxima.info,  Node: Share-Pakete,  Next: Funktionen und Variablen für Verschiedenes,  Prev: Einführung in Verschiedenes,  Up: Verschiedenes

30.2 Share-Pakete
=================

Das Maxima Share-Verzeichnis enthält viele weitere zusätzliche
Funktionen und Erweiterungen, die nicht Teil des Kernels von Maxima und
in Paketen organisiert sind.  Diese Pakete werden mit der Funktion
`load' geladen.  Einige Pakete werden automatisch geladen, wenn der
Nutzer eine Funktion des Paketes aufruft.  Mit der Funktion
`setup_autoload' können Funktionen für das automatische Laden
konfiguriert werden.

Die Lisp-Variable `*maxima-sharedir*' enthält das Verzeichnis der
Pakete.  Das Kommanod `printfile("share.usg")' gibt eine Übersicht über
Pakete aus.  Diese ist jedoch derzeit stark veraltert.


File: maxima.info,  Node: Funktionen und Variablen für Verschiedenes,  Prev: Share-Pakete,  Up: Verschiedenes

30.3 Funktionen und Variablen für Verschiedenes
===============================================

 -- Systemvariable: askexp
     Wenn `asksign' aufgerufen wird, enthält `askexp' den Ausdruck, der
     von `asksign' getestet wird.

     Es war einmal möglich, die Variable `askexp' nach einer
     Unterbrechnung mit Control-A zu inspezieren.

 -- Function: gensym ()
 -- Function: gensym (<x>)
     `gensym()' creates and returns a fresh symbol.

     The name of the new-symbol is the concatenation of a prefix, which
     defaults to "g", and a suffix, which is the decimal representation
     of a number that defaults to the value of a Lisp internal counter.

     If <x> is supplied, and is a string, then that string is used as a
     prefix instead of "g" for this call to gensym only.

     If <x> is supplied, and is an integer, then that integer, instead
     of the value of the internal Lisp integer, is used as the suffix
     for this call to gensym only.

     If and only if no explicit suffix is supplied, the Lisp internal
     integer is incremented after it is used.

     Examples:

          (%i1) gensym();
          (%o1)                         g887
          (%i2) gensym("new");
          (%o2)                        new888
          (%i3) gensym(123);
          (%o3)                         g123

 -- Option variable: packagefile
     Default value: `false'

     Package designers who use `save'  or `translate'  to create
     packages (files) for others to use may want to set `packagefile:
     true' to prevent information from being added to Maxima's
     information-lists (e.g.  `values',  `functions' ) except where
     necessary when the file is loaded in.  In this way, the contents
     of the package will not get in the user's way when he adds his own
     data.  Note that this will not solve the problem of possible name
     conflicts.  Also note that the flag simply affects what is output
     to the package file.  Setting the flag to `true' is also useful for
     creating Maxima init files.

 -- Funktion: remvalue (<name_1>, ..., <name_n>)
 -- Funktion: remvalue (all)
     Entfernt die Werte von nutzerdefinierten Variablen <name_1>, ...,
     <name_n>.  Die Variablen können indiziert sein.  `remvalue(all)'
     entfernt die Werte aller Variablen, die in der Informationsliste
     `values' enthalten sind.

     Siehe auch `values'.


 -- Funktion: rncombine (<expr>)
     Transformiert den Ausdruck <expr> so, dass alle Terme mit
     identischem Nenner oder Nennern, die sich nur um einen numerischen
     Faktor voneinander unterscheiden, über einen Nenner
     zusammengefasst werden. Die Funktion `combine' fasst ebenfalls
     Ausdrücke über einen Nenner zusammen, betrachtet aber Nenner als
     verschieden, die sich um einen Zahlenfaktor voneinander
     unterscheiden.

     Die Funktion wird mit dem Kommando `rncomb' geladen.

 -- Funktion: setup_autoload (<filename>, <function_1>, ...,
          <function_n>)
     Die Funktionen <function_1>, ..., <function_n> erhalten die
     Eigenschaft, dass die Datei <filename> automatisch geladen wird,
     wenn die Funktion zum ersten Mal genutzt werden soll.  <filename>
     wird mit der Funktion `load' geladen und enthält üblicherweise den
     Code für die Definition der zu ladenden Funktion.

     `setup_autoload' funktioniert nicht für Array-Funktionen.
     `setup_autoload' wertet die Argumente nicht aus.

     Beispiele:

          (%i1) legendre_p (1, %pi);
          (%o1)                  legendre_p(1, %pi)
          (%i2) setup_autoload ("specfun.mac", legendre_p, ultraspherical);
          (%o2)                         done
          (%i3) ultraspherical (2, 1/2, %pi);
          Warning - you are redefining the Macsyma function ultraspherical
          Warning - you are redefining the Macsyma function legendre_p
                                      2
                           3 (%pi - 1)
          (%o3)            ------------ + 3 (%pi - 1) + 1
                                2
          (%i4) legendre_p (1, %pi);
          (%o4)                          %pi
          (%i5) legendre_q (1, %pi);
                                        %pi + 1
                                %pi log(-------)
                                        1 - %pi
          (%o5)                 ---------------- - 1
                                       2


File: maxima.info,  Node: abs_integrate,  Next: affine,  Prev: Verschiedenes,  Up: Top

31 abs_integrate
****************

* Menu:

* Introduction to abs_integrate::
* Functions and Variables for abs_integrate::


File: maxima.info,  Node: Introduction to abs_integrate,  Next: Functions and Variables for abs_integrate,  Prev: abs_integrate,  Up: abs_integrate

31.1 Introduction to abs_integrate
==================================

The package `abs_integrate' extends Maxima's integration code to some
integrands that involve the absolute value, max, min, signum, or unit
step functions.  For integrands of the form p(x) |q(x)|, where p is a
polynomial and q is a polynomial that `factor' is able to factor into a
product of linear or constant terms, the `abs_integrate' package
determines an antiderivative that is continuous on the entire real
line.  Additionally, for an integrand that involves one or more
parameters, the function `conditional_integrate'  tries to determine an
antiderivative that is valid for all parameter values.

Examples:

To use the `abs_integrate' package, you'll first need to load it:

     (%i1) load("abs_integrate.mac")$
     (%i2) integrate(abs(x),x);
                                 x abs(x)
     (%o2)                       --------
                                    2

To convert (%o2) into an expression involving the absolute value
function, apply `signum_to_abs' ; thus

     (%i3) signum_to_abs(%);
                                 x abs(x)
     (%o3)                       --------
                                    2

When the integrand has the form p(x) |x - c1| |x - c2| ... |x - cn|,
where p(x) is a polynomial and c1, c2, ..., cn are constants, the
`abs_integrate' package returns an antiderivative that is valid on the
entire real line; thus without making assumptions on a and b; for
example

     (%i4) factor(convert_to_signum(integrate(abs((x-a)*(x-b)),x,a,b)));
                                 3       2
                          (b - a)  signum (b - a)
     (%o4)                -----------------------
                                     6

Additionally, `abs_integrate' is able to find antiderivatives of some
integrands involving `max',  `min',  `signum',  and `unit_step',
examples:

     (%i5) integrate(max(x,x^2),x);
                3      2                                        3    2
             2 x  - 3 x    1                   1               x    x
     (%o5) ((----------- + --) signum(x - 1) + --) signum(x) + -- + --
                 12        12                  12              6    4
     (%i6) integrate(signum(x) - signum(1-x),x);
     (%o6)                  abs(x) + abs(x - 1)

A plot indicates that indeed (%o5) and (%o6) are continuous at zero and
at one.

For definite integrals with numerical integration limits (including
both minus and plus infinity), the `abs_integrate' package converts the
integrand to signum form and then it tries to subdivide the integration
region so that the integrand simplifies to a non-signum expression on
each subinterval; for example

     (%i1) load(abs_integrate)$
     (%i2) integrate(1 / (1 + abs(x-5)),x,-5,6);
     (%o2)                   log(11) + log(2)

Finally, `abs_integrate' is able to determine antiderivatives of _some_
functions of the form F(x, |x - a|); examples

     (%i3) integrate(1/(1 + abs(x)),x);
           signum(x) (log(x + 1) + log(1 - x))
     (%o3) -----------------------------------
                            2
                                               log(x + 1) - log(1 - x)
                                             + -----------------------
                                                          2
     (%i4) integrate(cos(x + abs(x)),x);
              (signum(x) + 1) sin(2 x) - 2 x signum(x) + 2 x
     (%o4)    ----------------------------------------------
                                    4

Barton Willis (Professor of Mathematics, University of Nebraska at
Kearney) wrote the `abs_integrate' package and its English language
user documentation.  This documentation also describes the `partition'
package for integration.  Richard Fateman wrote `partition'.
Additional documentation for `partition' is located at
`http://www.cs.berkeley.edu/~fateman/papers/partition.pdf'


File: maxima.info,  Node: Functions and Variables for abs_integrate,  Prev: Introduction to abs_integrate,  Up: abs_integrate

31.2 Functions and Variables for abs_integrate
==============================================

 -- Option variable: extra_integration_methods
     Default value: `['signum_int, 'abs_integrate_use_if]'

     The list `extra_integration_methods' is a list of functions for
     integration.  When `integrate'  is unable to find an
     antiderivative, Maxima uses the methods in
     `extra_integration_methods' to attempt to determine an
     antiderivative.

     Each function `f' in `extra_integration_methods' should have the
     form `f(integrand, variable)'.  The function `f' may either return
     `false' to indicate failure, or it may return an expression
     involving an integration noun form.  The integration methods are
     tried from the first to the last member of
     `extra_integration_methods'; when no method returns an expression
     that does not involve an integration noun form, the value of the
     integral is the last value that does not fail (or a pure noun form
     if all methods fail).

     When the function `abs_integrate_use_if' is successful, it returns
     a conditional expression; for example

          (%i1) load(abs_integrate)$
          (%i2) integrate(1/(1 + abs(x+1) + abs(x-1)),x);
                                     log(1 - 2 x)            2
          (%o2) %if(- (x + 1) > 0, - ------------ + log(3) - -,
                                          2                  3
                                             x   log(3)   1  log(2 x + 1)
                          %if(- (x - 1) > 0, - + ------ - -, ------------))
                                             3     2      3       2
          (%i3) integrate(exp(-abs(x-1) - abs(x)),x);
                               2 x - 1
                             %e              - 1
          (%o3) %if(- x > 0, --------- - 2 %e   ,
                                 2
                                                         - 1      1 - 2 x
                                             - 1     3 %e       %e
                        %if(- (x - 1) > 0, %e    x - -------, - ---------))
                                                        2           2

     For definite integration, these conditional expressions can cause
     trouble:

          (%i4) integrate(exp(-abs(x-1) - abs(x)),x, minf,inf);
                                         - 1    2 x
                                       %e    (%e    - 4)
          (%o4) limit     %if(- x > 0, -----------------,
                x -> inf-                      2
                               - 1                1 - 2 x
                             %e    (2 x - 3)    %e
          %if(- (x - 1) > 0, ---------------, - ---------))
                                    2               2
                                       - 1    2 x
                                     %e    (%e    - 4)
           - limit      %if(- x > 0, -----------------,
             x -> minf+                      2
                               - 1                1 - 2 x
                             %e    (2 x - 3)    %e
          %if(- (x - 1) > 0, ---------------, - ---------))
                                    2               2

     For such definite integrals, try disallowing the method
     `abs_integrate_use_if':

          (%i5) integrate(exp(-abs(x-1) - abs(x)),x, minf,inf),
                    extra_integration_methods : ['signum_int];
                                           - 1
          (%o5)                        2 %e

     Related options `extra_definite_integration_methods'.

     To use `load(abs_integrate)'

 -- Option variable: extra_definite_integration_methods
     Default value: `['abs_defint]'

     The list `extra_definite_integration_methods' is a list of extra
     functions for definite integration.  When `integrate'  is unable
     to find a definite integral, Maxima uses the methods in
     `extra_definite_integration_methods' to attempt to determine an
     antiderivative.

     Each function `f' in `extra_definite_integration_methods' should
     have the form `f(integrand, variable, lo, hi)', where `lo' and
     `hi' are the lower and upper limits of integration, respectively.
     The function `f' may either return `false' to indicate failure, or
     it may return an expression involving an integration noun form.
     The integration methods are tried from the first to the last
     member of `extra_definite_integration_methods'; when no method
     returns an expression that does not involve an integration noun
     form, the value of the integral is the last value that does not
     fail (or a pure noun form if all methods fail).

     Related options `extra_integration_methods'.

     To use `load(abs_integrate)'.

 -- Function: intfudu (<e>, <x>)
     This function uses the derivative divides rule for integrands of
     the form f(w(x)) * diff(w(x),x).  When `infudu' is unable to find
     an antiderivative, it returns false.

          (%i1) load(abs_integrate)$
          (%i2) intfudu(cos(x^2) * x,x);
                                            2
                                       sin(x )
          (%o2)                        -------
                                          2
          (%i3) intfudu(x * sqrt(1+x^2),x);
                                       2     3/2
                                     (x  + 1)
          (%o3)                      -----------
                                          3
          (%i4) intfudu(x * sqrt(1 + x^4),x);
          (%o4)                         false

     For the last example, the derivative divides rule fails, so
     `intfudu' returns false.

     A hashed array `intable' contains the antiderivative data.  To
     append a fact to the hash table, say integrate(f) = g, do this:

          (%i5) intable[f] : lambda([u],  [g(u),diff(u,%voi)]);
          (%o5)          lambda([u], [g(u), diff(u, %voi)])
          (%i6) intfudu(f(z),z);
          (%o6)                         g(z)
          (%i7) intfudu(f(w(x)) * diff(w(x),x),x);
          (%o7)                        g(w(x))

     An alternative to calling `intfudu' directly is to use the
     `extra_integration_methods'  mechanism; an example:

          (%i1) load(abs_integrate)$
          (%i2) load(basic)$
          (%i3) load("partition.mac")$

          (%i4) integrate(bessel_j(1,x^2) * x,x);
                                                 2
                                    bessel_j(0, x )
          (%o4)                   - ---------------
                                           2
          (%i5) push('intfudu, extra_integration_methods)$

          (%i6) integrate(bessel_j(1,x^2) * x,x);
                                                 2
                                    bessel_j(0, x )
          (%o6)                   - ---------------
                                           2

     To use `load(partition)'.

     Additional documentation
     `http://www.cs.berkeley.edu/~fateman/papers/partition.pdf'.

     Related functions `intfugudu'.


 -- Function: intfugudu (<e>, <x>)
     This function uses the derivative divides rule for integrands of
     the form f(w(x)) * g(w(x)) * diff(w(x),x).  When `infugudu' is
     unable to find an antiderivative, it returns false.

          (%i1) load(abs_integrate)$
          (%i2) diff(jacobi_sn(x,2/3),x);
                                        2               2
          (%o2)            jacobi_cn(x, -) jacobi_dn(x, -)
                                        3               3
          (%i3) intfugudu(%,x);
                                                2
          (%o3)                    jacobi_sn(x, -)
                                                3
          (%i4) diff(jacobi_dn(x^2,a),x);
                                         2                2
          (%o4)       - 2 a x jacobi_cn(x , a) jacobi_sn(x , a)
          (%i5) intfugudu(%,x);
                                             2
          (%o5)                   jacobi_dn(x , a)

     For a method for automatically calling `infugudu' from `integrate',
     see the documentation for `intfudu'.

     To use `load(partition)'.

     Additional documentation
     `http://www.cs.berkeley.edu/~fateman/papers/partition.pdf'

     Related functions `intfudu'.


 -- Function: signum_to_abs (<e>)
     This function replaces subexpressions of the form q signum(q) by
     abs(q).  Before it does these substitutions, it replaces
     subexpressions of the form signum(p) * signum(q) by signum(p * q);
     examples:

          (%i1) load(abs_integrate)$
          (%i2) map('signum_to_abs, [x * signum(x),
                                     x * y * signum(x)* signum(y)/2]);
                                        abs(x) abs(y)
          (%o2)                [abs(x), -------------]
                                              2

     To use `load(abs_integrate)'.

 -- Macro: simp_assuming (<e>, <f_1>, <f_2>, ..., <f_n>)
     Appended the facts f_1, f_2, ..., f_n to the current context and
     simplify e.  The facts are removed before returning the simplified
     expression e.

          (%i1) load(abs_integrate)$
          (%i2) simp_assuming(x + abs(x), x < 0);
          (%o2)                           0

     The facts in the current context aren't ignored:

          (%i3) assume(x > 0)$
          (%i4) simp_assuming(x + abs(x),x < 0);
          (%o4)                          2 x

     Since `simp_assuming' is a macro, effectively `simp_assuming'
     quotes is arguments; this allows

          (%i5) simp_assuming(asksign(p), p < 0);
          (%o5)                          neg

     To use `load(abs_integrate)'.

 -- Function: conditional_integrate (<e>, <x>)
     For an integrand with one or more parameters, this function tries
     to determine an antiderivative that is valid for all parameter
     values.  When successful, this function returns a conditional
     expression for the antiderivative.

          (%i1) load(abs_integrate)$
          (%i2) conditional_integrate(cos(m*x),x);
                                          sin(m x)
          (%o2)                %if(m # 0, --------, x)
                                             m
          (%i3) conditional_integrate(cos(m*x)*cos(x),x);

          (%o3) %if((m - 1 # 0) %and (m + 1 # 0),
          (m - 1) sin((m + 1) x) + (- m - 1) sin((1 - m) x)
          -------------------------------------------------,
                                 2
                              2 m  - 2
          sin(2 x) + 2 x
          --------------)
                4
          (%i4) sublis([m=6],%);
                               5 sin(7 x) + 7 sin(5 x)
          (%o4)                -----------------------
                                         70
          (%i5) conditional_integrate(exp(a*x^2+b*x),x);
                                            2
                                           b
                                         - ---
                                           4 a      2 a x + b
                             sqrt(%pi) %e      erf(-----------)
                                                   2 sqrt(- a)
          (%o5) %if(a # 0, - ----------------------------------,
                                        2 sqrt(- a)
                                                                   b x
                                                                 %e
                                                      %if(b # 0, -----, x))
                                                                   b

 -- Function: convert_to_signum (<e>)
     This function replaces subexpressions of the form `abs(q),
     unit_step(q), min(q1, q2, ..., qn)' and `max(q1, q2, ..., qn)' by
     equivalent signum terms.

          (%i1) load(abs_integrate)$
          (%i2) map('convert_to_signum, [abs(x), unit_step(x),
                                         max(a,2), min(a,2)]);

                              signum(x) (signum(x) + 1)
          (%o2) [x signum(x), -------------------------,
                                          2
            (a - 2) signum(a - 2) + a + 2  - (a - 2) signum(a - 2) + a + 2
            -----------------------------, -------------------------------]
                          2                               2

     To convert `unit_step'  to signum form, the function
     `convert_to_signum' uses unit_step(x) = (1 + signum(x))/2.

     To use `load(abs_integrate)'.

     Related functions `signum_to_abs'.



File: maxima.info,  Node: affine,  Next: asympa,  Prev: abs_integrate,  Up: Top

32 affine
*********

* Menu:

* Introduction to Affine::
* Functions and Variables for Affine::


File: maxima.info,  Node: Introduction to Affine,  Next: Functions and Variables for Affine,  Prev: affine,  Up: affine

32.1 Introduction to Affine
===========================

`affine' is a package to work with groups of polynomials.


File: maxima.info,  Node: Functions and Variables for Affine,  Prev: Introduction to Affine,  Up: affine

32.2 Functions and Variables for Affine
=======================================

 -- Function: fast_linsolve ([<expr_1>, ..., <expr_m>], [<x_1>, ...,
          <x_n>])
     Solves the simultaneous linear equations <expr_1>, ..., <expr_m>
     for the variables <x_1>, ..., <x_n>.  Each <expr_i> may be an
     equation or a general expression; if given as a general
     expression, it is treated as an equation of the form `<expr_i> =
     0'.

     The return value is a list of equations of the form `[<x_1> =
     <a_1>, ..., <x_n> = <a_n>]' where <a_1>, ..., <a_n> are all free
     of <x_1>, ..., <x_n>.

     `fast_linsolve' is faster than `linsolve'  for system of equations
     which are sparse.

     `load(affine)' loads this function.

 -- Function: grobner_basis ([<expr_1>, ..., <expr_m>])
     Returns a Groebner basis for the equations <expr_1>, ..., <expr_m>.
     The function `polysimp' can then be used to simplify other
     functions relative to the equations.

     `polysimp(f)' yields 0 if and only if <f> is in the ideal
     generated by <expr_1>, ..., <expr_m>, that is, if and only if <f>
     is a polynomial combination of the elements of <expr_1>, ...,
     <expr_m>.

     `load(affine)' loads this function.

     Beispiel:

          (%i1) load(affine)$

          (%i2) grobner_basis ([3*x^2+1, y*x]);
          eliminated one
           . 0 . 0                                   2
          (%o2)/R/                [- y, - 3 x  - 1]
          (%i3) polysimp(y^2*x+x^3*9+2);
          (%o3)/R/                    - 3 x + 2

 -- Function: set_up_dot_simplifications (<eqns>,
          <check_through_degree>)
 -- Function: set_up_dot_simplifications (<eqns>)
     The <eqns> are polynomial equations in non commutative variables.
     The value of `current_variables' is the list of variables used for
     computing degrees.  The equations must be homogeneous, in order
     for the procedure to terminate.

     If you have checked overlapping simplifications in
     `dot_simplifications' above the degree of <f>, then the following
     is true: `dotsimp(<f>)' yields 0 if and only if <f> is in the ideal
     generated by the equations, i.e., if and only if <f> is a
     polynomial combination of the elements of the equations.

     The degree is that returned by `nc_degree'.   This in turn is
     influenced by the weights of individual variables.

     `load(affine)' loads this function.

 -- Function: declare_weights (<x_1>, <w_1>, ..., <x_n>, <w_n>)
     Assigns weights <w_1>, ..., <w_n> to <x_1>, ..., <x_n>,
     respectively.  These are the weights used in computing `nc_degree'.

     `load(affine)' loads this function.

 -- Function: nc_degree (<p>)
     Returns the degree of a noncommutative polynomial <p>.  See
     `declare_weights'.

     `load(affine)' loads this function.

 -- Function: dotsimp (<f>)
     Returns 0 if and only if <f> is in the ideal generated by the
     equations, i.e., if and only if <f> is a polynomial combination of
     the elements of the equations.

     `load(affine)' loads this function.

 -- Function: fast_central_elements ([<x_1>, ..., <x_n>], <n>)
     If `set_up_dot_simplifications'  has been previously done, finds
     the central polynomials in the variables <x_1>, ..., <x_n> in the
     given degree, <n>.

     For example:

          set_up_dot_simplifications ([y.x + x.y], 3);
          fast_central_elements ([x, y], 2);
          [y.y, x.x];

     `load(affine)' loads this function.

 -- Function: check_overlaps (<n>, <add_to_simps>)
     Checks the overlaps thru degree <n>, making sure that you have
     sufficient simplification rules in each degree, for `dotsimp'  to
     work correctly.  This process can be speeded up if you know before
     hand what the dimension of the space of monomials is.  If it is of
     finite global dimension, then `hilbert' should be used.  If you
     don't know the monomial dimensions, do not specify a
     `rank_function'.  An optional third argument `reset', `false' says
     don't bother to query about resetting things.

     `load(affine)' loads this function.

 -- Function: mono ([<x_1>, ..., <x_n>], <n>)
     Returns the list of independent monomials relative to the current
     dot simplifications of degree <n> in the variables <x_1>, ...,
     <x_n>.

     `load(affine)' loads this function.

 -- Function: monomial_dimensions (<n>)
     Compute the Hilbert series through degree <n> for the current
     algebra.

     `load(affine)' loads this function.

 -- Function: extract_linear_equations ([<p_1>, ..., <p_n>], [<m_1>,
          ..., <m_n>])
     Makes a list of the coefficients of the noncommutative polynomials
     <p_1>, ..., <p_n> of the noncommutative monomials <m_1>, ...,
     <m_n>.  The coefficients should be scalars.  Use
     `list_nc_monomials' to build the list of monomials.

     `load(affine)' loads this function.

 -- Function: list_nc_monomials ([<p_1>, ..., <p_n>])
 -- Function: list_nc_monomials (<p>)
     Returns a list of the non commutative monomials occurring in a
     polynomial <p> or a list of polynomials <p_1>, ..., <p_n>.

     `load(affine)' loads this function.

 -- Option variable: all_dotsimp_denoms
     Default value: `false'

     When `all_dotsimp_denoms' is a list, the denominators encountered
     by `dotsimp'  are appended to the list.  `all_dotsimp_denoms' may
     be initialized to an empty list `[]' before calling `dotsimp'.

     By default, denominators are not collected by `dotsimp'.


File: maxima.info,  Node: asympa,  Next: augmented_lagrangian,  Prev: affine,  Up: Top

33 asympa
*********

* Menu:

* Introduction to asympa::
* Functions and variables for asympa::


File: maxima.info,  Node: Introduction to asympa,  Next: Functions and variables for asympa,  Prev: asympa,  Up: asympa

33.1 Introduction to asympa
===========================

 -- Function: asympa
     `asympa' is a package for asymptotic analysis. The package contains
     simplification functions for asymptotic analysis, including the
     "big O" and "little o" functions that are widely used in
     complexity analysis and numerical analysis.

     `load ("asympa")' loads this package.



File: maxima.info,  Node: Functions and variables for asympa,  Prev: Introduction to asympa,  Up: asympa

33.2 Functions and variables for asympa
=======================================


File: maxima.info,  Node: augmented_lagrangian,  Next: bernstein,  Prev: asympa,  Up: Top

34 augmented_lagrangian
***********************

* Menu:

* Functions and Variables for augmented_lagrangian::


File: maxima.info,  Node: Functions and Variables for augmented_lagrangian,  Prev: augmented_lagrangian,  Up: augmented_lagrangian

34.1 Functions and Variables for augmented_lagrangian
=====================================================

 -- Function: augmented_lagrangian_method (<FOM>, <xx>, <C>, <yy>)
 -- Function: augmented_lagrangian_method (<FOM>, <xx>, <C>, <yy>,
          optional_args)
 -- Function: augmented_lagrangian_method ([<FOM>, <grad>], <xx>, <C>,
          <yy>)
 -- Function: augmented_lagrangian_method ([<FOM>, <grad>], <xx>, <C>,
          <yy>, optional_args)
     Returns an approximate minimum of the expression <FOM> with
     respect to the variables <xx>, holding the constraints <C> equal
     to zero.  <yy> is a list of initial guesses for <xx>.  The method
     employed is the augmented Lagrangian method (see Refs [1] and [2]).

     <grad>, if present, is the gradient of <FOM> with respect to <xx>,
     represented as a list of expressions, one for each variable in
     <xx>.  If not present, the gradient is constructed automatically.

     <FOM> and each element of <grad>, if present, must be ordinary
     expressions, not names of functions or lambda expressions.

     `optional_args' represents additional arguments, specified as
     `<symbol> = <value>'.  The optional arguments recognized are:

    `niter'
          Number of iterations of the augmented Lagrangian algorithm

    `lbfgs_tolerance'
          Tolerance supplied to LBFGS

    `iprint'
          IPRINT parameter (a list of two integers which controls
          verbosity) supplied to LBFGS

    `%lambda'
          Initial value of `%lambda' to be used for calculating the
          augmented Lagrangian

     This implementation minimizes the augmented Lagrangian by applying
     the limited-memory BFGS (LBFGS) algorithm, which is a quasi-Newton
     algorithm.

     `load(augmented_lagrangian)' loads this function.

     See also `lbfgs'.

     References:

     [1]
     `http://www-fp.mcs.anl.gov/otc/Guide/OptWeb/continuous/constrained/nonlinearcon/auglag.html'

     [2] `http://www.cs.ubc.ca/spider/ascher/542/chap10.pdf'

     Examples:

          (%i1) load (lbfgs);
          (%o1)     /maxima/share/lbfgs/lbfgs.mac
          (%i2) load (augmented_lagrangian);
          (%o2)
             /maxima/share/contrib/augmented_lagrangian.mac
          (%i3) FOM: x^2 + 2*y^2;
                                         2    2
          (%o3)                       2 y  + x
          (%i4) xx: [x, y];
          (%o4)                        [x, y]
          (%i5) C: [x + y - 1];
          (%o5)                      [y + x - 1]
          (%i6) yy: [1, 1];
          (%o6)                        [1, 1]
          (%i7) augmented_lagrangian_method(FOM, xx, C, yy, iprint=[-1,0]);
          (%o7) [[x = 0.66665984108002, y = 0.33334027245545],
                                           %lambda = [- 1.333337940892525]]

     Same example as before, but this time the gradient is supplied as
     an argument.

          (%i1) load (lbfgs)$
          (%i2) load (augmented_lagrangian)$
          (%i3) FOM: x^2 + 2*y^2;
                                         2    2
          (%o3)                       2 y  + x
          (%i4) FOM: x^2 + 2*y^2;
                                         2    2
          (%o4)                       2 y  + x
          (%i5) xx: [x, y];
          (%o5)                        [x, y]
          (%i6) grad : [2*x, 4*y];
          (%o6)                      [2 x, 4 y]
          (%i7) C: [x + y - 1];
          (%o7)                      [y + x - 1]
          (%i8) yy: [1, 1];
          (%o8)                        [1, 1]
          (%i9) augmented_lagrangian_method ([FOM, grad], xx, C, yy,
                                             iprint = [-1, 0]);
          (%o9) [[x = 0.666659841080025, y = .3333402724554462],
                                           %lambda = [- 1.333337940892543]]


File: maxima.info,  Node: bernstein,  Next: bode,  Prev: augmented_lagrangian,  Up: Top

35 bernstein
************

* Menu:

* Functions and Variables for Bernstein::


File: maxima.info,  Node: Functions and Variables for Bernstein,  Prev: bernstein,  Up: bernstein

35.1 Functions and Variables for Bernstein
==========================================

 -- Function: bernstein_poly (<k>, <n>, <x>)
     Provided `k' is not a negative integer, the Bernstein polynomials
     are defined by `bernstein_poly(k,n,x) = binomial(n,k) x^k
     (1-x)^(n-k)'; for a negative integer `k', the Bernstein polynomial
     `bernstein_poly(k,n,x)' vanishes. When either `k' or `n' are non
     integers, the option variable `bernstein_explicit' controls the
     expansion of the Bernstein polynomials into its explicit form;
     example:

          (%i1) load(bernstein)$

          (%i2) bernstein_poly(k,n,x);
          (%o2)                bernstein_poly(k, n, x)
          (%i3) bernstein_poly(k,n,x), bernstein_explicit : true;
                                                 n - k  k
          (%o3)            binomial(n, k) (1 - x)      x

     The Bernstein polynomials have both a gradef property and an
     integrate property:

          (%i4) diff(bernstein_poly(k,n,x),x);
          (%o4) (bernstein_poly(k - 1, n - 1, x)
                                           - bernstein_poly(k, n - 1, x)) n
          (%i5) integrate(bernstein_poly(k,n,x),x);
          (%o5)
                                                                      k + 1
           hypergeometric([k + 1, k - n], [k + 2], x) binomial(n, k) x
           ----------------------------------------------------------------
                                        k + 1

     For numeric inputs, both real and complex, the Bernstein
     polynomials evaluate to a numeric result:

          (%i6) bernstein_poly(5,9, 1/2 + %i);
                                  39375 %i   39375
          (%o6)                   -------- + -----
                                    128       256
          (%i7) bernstein_poly(5,9, 0.5b0 + %i);
          (%o7)           3.076171875b2 %i + 1.5380859375b2

     To use `bernstein_poly', first `load("bernstein")'.

 -- Variable: bernstein_explicit
     Default value: `false'

     When either `k' or `n' are non integers, the option variable
     `bernstein_explicit' controls the expansion of `bernstein(k,n,x)'
     into its explicit form; example:

          (%i1) bernstein_poly(k,n,x);
          (%o1)                bernstein_poly(k, n, x)
          (%i2) bernstein_poly(k,n,x), bernstein_explicit : true;
                                                 n - k  k
          (%o2)            binomial(n, k) (1 - x)      x

     When both `k' and `n' are explicitly integers, `bernstein(k,n,x)'
     _always_ expands to its explicit form.

 -- Function: multibernstein_poly (<[k1, k2, ..., kp]>, <[n1, n2, ...,
          np]>, <[x1, x2, ...,  xp]>)
     The multibernstein polynomial `multibernstein_poly (<[k1, ...,
     kp]>, <[n1, ..., np]>, <[x1, ..., xp]>)' is the product of
     bernstein polynomials `bernstein_poly(k1, n1, x1) * ... *
     bernstein_poly(kp, np, xp)'.

     To use `multibernstein_poly', first `load("bernstein")'.

 -- Function: bernstein_approx (<f>, <[x1, x1, ..., xn]>, <n>)
     Return the `n'-th order uniform Bernstein polynomial approximation
     for the function `(x1, x2, ..., xn) |--> f'.

     Examples:

          (%i1) bernstein_approx(f(x),[x], 2);
                           2       1                          2
          (%o1)      f(1) x  + 2 f(-) (1 - x) x + f(0) (1 - x)
                                   2
          (%i2) bernstein_approx(f(x,y),[x,y], 2);
                         2  2       1                2
          (%o2) f(1, 1) x  y  + 2 f(-, 1) (1 - x) x y
                                    2
                            2  2          1   2
           + f(0, 1) (1 - x)  y  + 2 f(1, -) x  (1 - y) y
                                          2
                 1  1                               1         2
           + 4 f(-, -) (1 - x) x (1 - y) y + 2 f(0, -) (1 - x)  (1 - y) y
                 2  2                               2
                      2        2       1                      2
           + f(1, 0) x  (1 - y)  + 2 f(-, 0) (1 - x) x (1 - y)
                                       2
                            2        2
           + f(0, 0) (1 - x)  (1 - y)

     To use `bernstein_approx', first `load("bernstein")'.

 -- Function: bernstein_expand (<e>, <[x1, x1, ..., xn]>)
     Express the _polynomial_ `e' exactly as a linear combination of
     multi-variable Bernstein polynomials.

          (%i1) bernstein_expand(x*y+1,[x,y]);
          (%o1)    2 x y + (1 - x) y + x (1 - y) + (1 - x) (1 - y)
          (%i2) expand(%);
          (%o2)                        x y + 1

     Maxima signals an error when the first argument isn't a polynomial.

     To use `bernstein_expand', first `load("bernstein")'.


File: maxima.info,  Node: bode,  Next: cobyla,  Prev: bernstein,  Up: Top

36 bode
*******

* Menu:

* Functions and Variables for bode::


File: maxima.info,  Node: Functions and Variables for bode,  Prev: bode,  Up: bode

36.1 Functions and Variables for bode
=====================================

 -- Function: bode_gain (<H>, <range>, ... <plot_opts> ...)
     Function to draw Bode gain plots. To use this function write first
     `load(bode)'. See also `bode_phase'.

     Examples:

     Examples (1 through 7 from
     `http://www.swarthmore.edu/NatSci/echeeve1/Ref/Bode/BodeHow.html',
     8 from Ron Crummett):

          (%i1) load("bode")$
          (%i2) H1 (s) := 100 * (1 + s) / ((s + 10) * (s + 100))$
          (%i3) bode_gain (H1 (s), [w, 1/1000, 1000])$

          (%i4) H2 (s) := 1 / (1 + s/omega0)$
          (%i5) bode_gain (H2 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i6) H3 (s) := 1 / (1 + s/omega0)^2$
          (%i7) bode_gain (H3 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i8) H4 (s) := 1 + s/omega0$
          (%i9) bode_gain (H4 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i10) H5 (s) := 1/s$
          (%i11) bode_gain (H5 (s), [w, 1/1000, 1000])$

          (%i12) H6 (s) := 1/((s/omega0)^2 + 2 * zeta * (s/omega0) + 1)$
          (%i13) bode_gain (H6 (s), [w, 1/1000, 1000]),
                                    omega0 = 10, zeta = 1/10$

          (%i14) H7 (s) := (s/omega0)^2 + 2 * zeta * (s/omega0) + 1$
          (%i15) bode_gain (H7 (s), [w, 1/1000, 1000]),
                                    omega0 = 10, zeta = 1/10$

          (%i16) H8 (s) := 0.5 / (0.0001 * s^3 + 0.002 * s^2 + 0.01 * s)$
          (%i17) bode_gain (H8 (s), [w, 1/1000, 1000])$

 -- Function: bode_phase (<H>, <range>, ... <plot_opts> ...)
     Function to draw Bode phase plots. To use this function write first
     `load(bode)'. See also `bode_gain'.

     Examples:

     Examples (1 through 7 from
     `http://www.swarthmore.edu/NatSci/echeeve1/Ref/Bode/BodeHow.html',
     8 from Ron Crummett):

          (%i1) load("bode")$
          (%i2) H1 (s) := 100 * (1 + s) / ((s + 10) * (s + 100))$
          (%i3) bode_phase (H1 (s), [w, 1/1000, 1000])$

          (%i4) H2 (s) := 1 / (1 + s/omega0)$
          (%i5) bode_phase (H2 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i6) H3 (s) := 1 / (1 + s/omega0)^2$
          (%i7) bode_phase (H3 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i8) H4 (s) := 1 + s/omega0$
          (%i9) bode_phase (H4 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i10) H5 (s) := 1/s$
          (%i11) bode_phase (H5 (s), [w, 1/1000, 1000])$

          (%i12) H6 (s) := 1/((s/omega0)^2 + 2 * zeta * (s/omega0) + 1)$
          (%i13) bode_phase (H6 (s), [w, 1/1000, 1000]),
                             omega0 = 10, zeta = 1/10$

          (%i14) H7 (s) := (s/omega0)^2 + 2 * zeta * (s/omega0) + 1$
          (%i15) bode_phase (H7 (s), [w, 1/1000, 1000]),
                             omega0 = 10, zeta = 1/10$

          (%i16) H8 (s) := 0.5 / (0.0001 * s^3 + 0.002 * s^2 + 0.01 * s)$
          (%i17) bode_phase (H8 (s), [w, 1/1000, 1000])$

          (%i18) block ([bode_phase_unwrap : true],
                        bode_phase (H8 (s), [w, 1/1000, 1000]));



Local Variables:
coding: iso-8859-1
End:
