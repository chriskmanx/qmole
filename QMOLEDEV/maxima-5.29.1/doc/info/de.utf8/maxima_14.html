<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on Dezember, 3 2012 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Maxima Manual: 14. Mengen</title>

<meta name="description" content="Maxima Manual: 14. Mengen">
<meta name="keywords" content="Maxima Manual: 14. Mengen">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body
{
    color: black;
    background: white; 
    margin-left: 8%;
    margin-right: 13%;
}

h1
{
    margin-left: +8%;
    font-size: 150%;
    font-family: sans-serif
}

h2
{
    font-size: 125%;
    font-family: sans-serif
}

h3
{
    font-size: 100%;
    font-family: sans-serif
}

h2,h3,h4,h5,h6 { margin-left: +4%; }

div.textbox
{
    border: solid;
    border-width: thin;
    /* width: 100%; */
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em
}

div.titlebox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
    background: rgb(200,255,255);
    font-family: sans-serif
}

div.synopsisbox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
     background: rgb(255,220,255);
    /*background: rgb(200,255,255); */
    /* font-family: fixed */
}

pre.example
{
    border: 1px solid gray;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 1em;
    padding-right: 1em;
    /* background: rgb(247,242,180); */ /* kind of sandy */
    /* background: rgb(200,255,255); */ /* sky blue */
    background-color: #F1F5F9; /* light blue-gray */
    /* font-family: "Lucida Console", monospace */
}

div.spacerbox
{
    border: none;
    padding-top: 2em;
    padding-bottom: 2em
}

div.image
{
    margin: 0;
    padding: 1em;
    text-align: center;
}

div.categorybox
{
    border: 1px solid gray;
    padding-top: 0px;
    padding-bottom: 0px;
    padding-left: 1em;
    padding-right: 1em;
    background: rgb(247,242,220);
}


-->
</style>

<link rel="icon" href="http://maxima.sourceforge.net/favicon.ico"/>
</head>

<body lang="de" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Mengen"></a>
<a name="SEC92"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_13.html#SEC91" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC93" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_13.html#SEC86" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_15.html#SEC99" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC409" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 14. Mengen </h1>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC93">14.1 Einf&uuml;hrung in Mengen</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC98">14.2 Funktionen und Variablen f&uuml;r Mengen</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Einf_00fchrung-in-Mengen"></a>
<a name="SEC93"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC92" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC94" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC92" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC92" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_15.html#SEC99" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC409" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 14.1 Einf&uuml;hrung in Mengen </h2>

<p>Maxima hat Funktionen wie den Schnitt und die Vereinigung von endlichen Mengen,
die durch eine explizite Aufz&auml;hlung definiert werden k&ouml;nnen.  Listen und
Mengen sind in Maxima unterschiedliche Objekte und k&ouml;nnen selbst Elemente von
Mengen sein.  Siehe auch <a href="maxima_5.html#SEC30">Listen</a>.
</p>
<p>Neben den Funktionen f&uuml;r Mengen, enth&auml;lt dieses Kapitel weitere Funktionen
der Kombinatorik.  Darunter die Stirling-Zahlen der ersten und zweiten Art, die
Bellschen Zahlen, Multinomialverteilungen, Partitionsfunktionen oder die
Kronecker-Delta-Funktion.
</p>
<hr size="6">
<a name="SEC94"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC93" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC95" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC92" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC93" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_15.html#SEC99" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC409" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 14.1.1 Anwendung </h3>

<p>Mit <code>set(a_1, ..., a_n)</code> oder <code>{a_1, ..., a_n}</code> wird eine Menge
mit den Elementen <code>a_1, ..., a_n</code> konstruiert.  Die leere Menge
wird mit <code>set()</code> oder <code>{}</code> angegeben.  Mengen werden immer mit
geschweiften Klammern angezeigt.  Werden Elemente mehrmals angegeben, werden
die doppelten Elemente aus der Menge entfernt.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) set();
(%o1)                          {}
(%i2) set(a, b, a);
(%o2)                        {a, b}
(%i3) set(a, set(b));
(%o3)                       {a, {b}}
(%i4) set(a, [b]);
(%o4)                       {a, [b]}
(%i5) {};
(%o5)                          {}
(%i6) {a, b, a};
(%o6)                        {a, b}
(%i7) {a, {b}};
(%o7)                       {a, {b}}
(%i8) {a, [b]};
(%o8)                       {a, [b]}
</pre>
<p>Zwei Elemente <var>x</var> und <var>y</var> werden als gleich angesehen, wenn
<code>is(<var>x</var> = <var>y</var>)</code> das Ergebnis <code>true</code> hat.  Die Elemente sind
dann syntaktisch gleich.  Es ist zu beachten, dass <code>is(equal(<var>x</var>,
<var>y</var>))</code> das Ergebnis <code>true</code> haben kann, jedoch der Ausdruck
<code>is(<var>x</var> = <var>y</var>)</code> das Ergebnis <code>false</code> liefert.
</p>
<pre class="example">(%i1) x: a/c + b/c;
                              b   a
(%o1)                         - + -
                              c   c
(%i2) y: a/c + b/c;
                              b   a
(%o2)                         - + -
                              c   c
(%i3) z: (a + b)/c;
                              b + a
(%o3)                         -----
                                c
(%i4) is (x = y);
(%o4)                         true
(%i5) is (y = z);
(%o5)                         false
(%i6) is (equal (y, z));
(%o6)                         true
(%i7) y - z;
                           b + a   b   a
(%o7)                    - ----- + - + -
                             c     c   c
(%i8) ratsimp (%);
(%o8)                           0
(%i9) {x, y, z};
                          b + a  b   a
(%o9)                    {-----, - + -}
                            c    c   c
</pre>
<p>Mit der Funktion <code><a href="#setify">setify</a></code>
 kann eine Menge aus einer Liste konstruiert
werden.
</p>
<pre class="example">(%i1) setify ([b, a]);
(%o1)                        {a, b}
</pre>
<p>Die Elemente <code>x</code> und <code>y</code> einer Menge sind gleich, wenn der Ausdruck
<code>is(x = y)</code> das Ergebnis <code>true</code> hat.  Daher werden zum Beispiel
<code>rat(x)</code> und <code>x</code> als gleich betrachtet.
</p>
<pre class="example">(%i1) {x, rat(x)};
(%o1)                          {x}
</pre>
<p>Da der Ausdruck <code>is((x - 1)*(x + 1) = x^2 - 1)</code> das Ergebnis <code>false</code>
hat, werden <code>(x - 1)*(x + 1)</code> und <code>x^2 - 1</code> als verschiedene Elemente
angenommen.
</p>
<pre class="example">(%i1) {(x - 1)*(x + 1), x^2 - 1};
                                       2
(%o1)               {(x - 1) (x + 1), x  - 1}
</pre>
<p>Um die Menge des letzten Beispiels auf ein Element zu reduzieren, kann die
Funktion <code><a href="maxima_17.html#rat">rat</a></code>
 auf die Elemente der Menge angewendet werden.
</p>
<pre class="example">(%i1) {(x - 1)*(x + 1), x^2 - 1};
                                       2
(%o1)               {(x - 1) (x + 1), x  - 1}
(%i2) map (rat, %);
                              2
(%o2)/R/                    {x  - 1}
</pre>
<p>Um redundante Elemente von Mengen zu entfernen, k&ouml;nnen Funktionen f&uuml;r die
Vereinfachung von Ausdr&uuml;cken angewendet werden.  In diesem Beispiel wird
die Funktion <code><a href="maxima_10.html#trigsimp">trigsimp</a></code>
 auf die Elemente der Menge angewendet.
</p>
<pre class="example">(%i1) {1, cos(x)^2 + sin(x)^2};
                            2         2
(%o1)                {1, sin (x) + cos (x)}
(%i2) map (trigsimp, %);
(%o2)                          {1}
</pre>
<p>Hat eine Menge redundante Elemente, wird sie vereinfacht und sortiert.  Die
Ordnung der Elemente wird von der Funktion <code><a href="maxima_6.html#orderlessp">orderlessp</a></code>
 bestimmt.  Einige
Operationen auf Mengen, wie zum Beispiel Substitutionen erzwingen die
Vereinfachung von Mengen.
</p>
<pre class="example">(%i1) s: {a, b, c}$
(%i2) subst (c=a, s);
(%o2)                        {a, b}
(%i3) subst ([a=x, b=x, c=x], s);
(%o3)                          {x}
(%i4) map (lambda ([x], x^2), set (-1, 0, 1));
(%o4)                        {0, 1}
</pre>
<p>Maxima behandelt Listen und Mengen als verschiedene Objekte.  Funktionen wie
<code><a href="#union">union</a></code>
 oder <code><a href="#intersection">intersection</a></code>
 geben eine Fehlermeldung, wenn die
Argumente keine Mengen sind.  Um eine Funktion f&uuml;r Mengen auf eine Liste
anzuwenden, kann diese mit der Funktion <code><a href="#setify">setify</a></code>
 in eine Menge
umgewandelt werden.
</p>
<pre class="example">(%i1) union ([1, 2], {a, b});
Function union expects a set, instead found [1,2]
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i2) union (setify ([1, 2]), {a, b});
(%o2)                     {1, 2, a, b}
</pre>
<p>Mit der Funktion <code><a href="#subset">subset</a></code>
 kann eine Teilmenge ermittelt werden, deren
Elemente f&uuml;r eine Aussagefunktion das Ergebnis <code>true</code> haben.  Um die
Gleichungen einer Menge zu finden, die nicht von der Variablen <code>z</code>
abh&auml;ngen, wird im Folgenden die Aussagefunktion <code><a href="maxima_6.html#freeof">freeof</a></code>
 verwendet.
</p>
<pre class="example">(%i1) subset ({x + y + z, x - y + 4, x + y - 5},
                                    lambda ([e], freeof (z, e)));
(%o1)               {- y + x + 4, y + x - 5}
</pre>
<p>In <a href="#SEC98">Funktionen und Variablen f&uuml;r Mengen</a> sind die Funktionen dokumentiert,
die Maxima f&uuml;r Mengen kennt.
</p>
<hr size="6">
<a name="SEC95"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC94" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC96" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC92" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC93" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_15.html#SEC99" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC409" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 14.1.2 Iteration &uuml;ber Mengen </h3>

<p>Es gibt zwei M&ouml;glichkeiten, &uuml;ber die Elemente einer Menge zu iterieren.
Im ersten Fall wird die Funktion <code><a href="maxima_25.html#map">map</a></code>
 genutzt.
</p>
<pre class="example">(%i1) map (f, {a, b, c});
(%o1)                  {f(a), f(b), f(c)}
</pre>
<p>Eine weitere M&ouml;glichkeit ist, eine <code><a href="maxima_27.html#for">for</a></code>
-Schleife einzusetzen.
</p>
<pre class="example">(%i1) s: {a, b, c};
(%o1)                       {a, b, c}
(%i2) for si in s do print (concat (si, 1));
a1 
b1 
c1 
(%o2)                         done
</pre>
<p>Die Funktionen <code><a href="maxima_5.html#first">first</a></code>
 und <code><a href="maxima_5.html#rest">rest</a></code>
 funktionieren auch f&uuml;r Mengen.
Wird die Funktion <code>first</code> auf eine Menge angewendet, ist das Ergebnis
das erste Element, wie es in der Anzeige erscheint.  Ist <code>s</code> eine Menge,
dann ist der Ausdruck <code>rest(s)</code> &auml;quivalent zu
<code>disjoin(first(s), s)</code>.  Siehe die Funktion <code><a href="#disjoin">disjoin</a></code>.
</p>

<hr size="6">
<a name="SEC96"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC95" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC97" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC92" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC93" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_15.html#SEC99" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC409" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 14.1.3 Programmfehler </h3>

<p>Die M&ouml;glichkeit mit den Funktionen <code><a href="maxima_6.html#orderless">orderless</a></code>
 und <code><a href="maxima_6.html#ordergreat">ordergreat</a></code>

eine neue Ordnung f&uuml;r Variablen zu definieren, ist nicht kompatibel mit den
Funktionen f&uuml;r Mengen.  Wird eine der Funktionen <code>orderless</code> oder
<code>ordergreat</code> ben&ouml;tigt, sollten diese vor der Konstruktion der ersten
Menge ausgef&uuml;hrt werden.  Die Funktion <code><a href="maxima_6.html#unorder">unorder</a></code>
 sollte nicht
ausgef&uuml;hrt werden.
</p>
<hr size="6">
<a name="SEC97"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC96" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC98" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC92" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC93" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_15.html#SEC99" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC409" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 14.1.4 Autoren </h3>

<p>Stavros Macrakis aus Cambridge, Massachusetts und Barton Willis von der
Universit&auml;t Nebraska in Kearney (UNK) haben die Funktionen und die
Dokumentation f&uuml;r Mengen geschrieben.
</p>
<hr size="6">
<a name="Funktionen-und-Variablen-f_00fcr-Mengen"></a>
<a name="SEC98"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC97" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_15.html#SEC99" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC92" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC92" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_15.html#SEC99" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC409" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 14.2 Funktionen und Variablen f&uuml;r Mengen </h2>

<p><a name="adjoin"></a>
</p><dl>
<dt><u>Funktion:</u> <b>adjoin</b><i> (<var>x</var>, <var>a</var>)</i>
<a name="IDX614"></a>
</dt>
<dd><p>Vereinigt die Menge <var>a</var> mit <code>{<var>x</var>}</code> und gibt die vereinigte
Menge als Ergebnis zur&uuml;ck.
</p>
<p><code>adjoin</code> gibt eine Fehlermeldung, wenn das Argument <var>a</var> keine Menge
ist.
</p>
<p><code>adjoin(<var>x</var>, <var>a</var>)</code> und <code>union(set(<var>x</var>), <var>a</var>)</code> sind
&auml;quivalent.  Die Funktion <code>adjoin</code> kann etwas schneller als die Funktion
<code><a href="#union">union</a></code>
 sein.
</p>
<p>Siehe auch die Funktion <code><a href="#disjoin">disjoin</a></code>.
</p>

<p>Beispiele:
</p>
<pre class="example">(%i1) adjoin (c, {a, b});
(%o1)                       {a, b, c}
(%i2) adjoin (a, {a, b});
(%o2)                        {a, b}
</pre></dd></dl>

<p><a name="belln"></a>
</p><dl>
<dt><u>Funktion:</u> <b>belln</b><i> (<var>n</var>)</i>
<a name="IDX615"></a>
</dt>
<dd><p>Repr&auml;sentiert die <em>n</em>-te Bellsche Zahl.
</p>
<p>Ist das Argument <var>n</var> eine nicht-negative ganze Zahl, vereinfacht
<code>belln(<var>n</var>)</code> zu der <em>n</em>-ten Bellschen Zahl.  F&uuml;r andere
Argumente vereinfacht die Funktion <code>belln</code> nicht.
</p>
<p>Ist das Argument der Funktion <code>belln</code> eine Liste, Menge, Matrix oder
eine Gleichung, wird die Funktion auf die Elemente oder beide Seiten der
Gleichung angewendet.
</p>
<p>Beispiele:
</p>
<p>Anwendung der Funktion <code>belln</code> auf nicht-negative ganze Zahlen.
</p>
<pre class="example">(%i1) makelist (belln (i), i, 0, 6);
(%o1)               [1, 1, 2, 5, 15, 52, 203]
(%i2) is (cardinality (set_partitions ({})) = belln (0));
(%o2)                         true
(%i3) is (cardinality (set_partitions ({1, 2, 3, 4, 5, 6})) =
                       belln (6));
(%o3)                         true
</pre>
<p>Anwendung der Funktion <code>belln</code> auf andere Argumente als nicht-negative
ganze Zahlen.
</p>
<pre class="example">(%i1) [belln (x), belln (sqrt(3)), belln (-9)];
(%o1)        [belln(x), belln(sqrt(3)), belln(- 9)]
</pre></dd></dl>

<p><a name="cardinality"></a>
</p><dl>
<dt><u>Funktion:</u> <b>cardinality</b><i> (<var>a</var>)</i>
<a name="IDX616"></a>
</dt>
<dd><p>Gibt die M&auml;chtigkeit (Kardinalit&auml;t) einer Menge zur&uuml;ck.  F&uuml;r endliche
Mengen ist die M&auml;chtigkeit die Anzahl der Elemente der Menge.
</p>
<p>Die Funktion <code>cardinality</code> ignoriert redundante Elemente einer Menge auch
dann, wenn die Vereinfachung abgeschaltet ist.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) cardinality ({});
(%o1)                           0
(%i2) cardinality ({a, a, b, c});
(%o2)                           3
(%i3) simp : false;
(%o3)                         false
(%i4) cardinality ({a, a, b, c});
(%o4)                           3
</pre></dd></dl>

<p><a name="cartesian_005fproduct"></a>
</p><dl>
<dt><u>Funktion:</u> <b>cartesian_product</b><i> (<var>b_1</var>, &hellip;, <var>b_n</var>)</i>
<a name="IDX617"></a>
</dt>
<dd><p>Gibt das kartesische Produkt der Mengen <var>b_1</var>, &hellip;, <var>b_n</var> zur&uuml;ck.
Das kartesische Produkt ist die Menge der geordneten Paare.
</p>
<p>Das Ergebnis ist eine Menge mit Listen der Form <code>[<var>x_1</var>, ...,
<var>x_n</var>]</code>, wobei <var>x_1</var>, &hellip;, <var>x_n</var> die Elemente der Mengen
<var>b_1</var>, &hellip;, <var>b_n</var> sind.
</p>
<p>Die Funktion <code>cartesian_product</code> gibt eine Fehlermeldung, wenn eines
der Argumente keine Menge ist.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) cartesian_product ({0, 1});
(%o1)                      {[0], [1]}
(%i2) cartesian_product ({0, 1}, {0, 1});
(%o2)           {[0, 0], [0, 1], [1, 0], [1, 1]}
(%i3) cartesian_product ({x}, {y}, {z});
(%o3)                      {[x, y, z]}
(%i4) cartesian_product ({x}, {-1, 0, 1});
(%o4)              {[x, - 1], [x, 0], [x, 1]}
</pre></dd></dl>

<p><a name="disjoin"></a>
</p><dl>
<dt><u>Funktion:</u> <b>disjoin</b><i> (<var>x</var>, <var>a</var>)</i>
<a name="IDX618"></a>
</dt>
<dd><p>Entfernt das Element <var>x</var> aus der Menge <var>a</var> und gibt das Ergebnis
zur&uuml;ck.
</p>
<p><code>disjoin</code> gibt eine Fehlermeldung, wenn das Argument <var>a</var> keine Menge
ist.
</p>
<p>Die Ausdr&uuml;cke <code>disjoin(<var>x</var>, <var>a</var>)</code>, <code>delete(<var>x</var>,
<var>a</var>)</code> und <code>setdifference(<var>a</var>, set(<var>x</var>))</code> sind &auml;quivalent.
Von diesen M&ouml;glichkeiten ist im Allgemeinen die Funktion <code>disjoin</code> am 
schnellsten.
</p>
<p>Siehe auch die Funktion <code><a href="#adjoin">adjoin</a></code>
 sowie die Funktionen <code><a href="maxima_5.html#delete">delete</a></code>
 und
<code><a href="#setdifference">setdifference</a></code>.
</p>

<p>Beispiele:
</p>
<pre class="example">(%i1) disjoin (a, {a, b, c, d});
(%o1)                       {b, c, d}
(%i2) disjoin (a + b, {5, z, a + b, %pi});
(%o2)                      {5, %pi, z}
(%i3) disjoin (a - b, {5, z, a + b, %pi});
(%o3)                  {5, %pi, b + a, z}
</pre></dd></dl>

<p><a name="disjointp"></a>
</p><dl>
<dt><u>Funktion:</u> <b>disjointp</b><i> (<var>a</var>, <var>b</var>)</i>
<a name="IDX619"></a>
</dt>
<dd><p><code>disjointp</code> hat das Ergebnis <code>true</code>, wenn die Mengen <var>a</var> und
<var>b</var> disjunkt sind.  Zwei Mengen sind disjunkt, wenn sie kein gemeinsames
Element besitzen.
</p>
<p><code>disjointp</code> gibt eine Fehlermeldung, wenn eines der Argumente keine
Menge ist.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) disjointp ({a, b, c}, {1, 2, 3});
(%o1)                         true
(%i2) disjointp ({a, b, 3}, {1, 2, 3});
(%o2)                         false
</pre></dd></dl>

<p><a name="divisors"></a>
</p><dl>
<dt><u>Funktion:</u> <b>divisors</b><i> (<var>n</var>)</i>
<a name="IDX620"></a>
</dt>
<dd><p>Gibt die Menge der Teiler der Zahl <var>n</var> zur&uuml;ck.
</p>
<p>Ist das Argument <var>n</var> eine von Null verschiedene ganze Zahl, vereinfacht
<code>divisors(<var>n</var>)</code> zu einer Menge mit ganzen Zahlen, die Teiler des
Argumentes <var>n</var> sind.  Ist das Argument <var>n</var> eine negative Zahl wird
der Betrag des Argumentes genommen.  Das Ergebnis enth&auml;lt die Elemente
<var>1</var> und <var>n</var>.
</p>
<p>Ist das Argument der Funktion <code>divisors</code> eine Liste, Menge, Matrix oder
eine Gleichung, wird die Funktion auf die Elemente oder beide Seiten der
Gleichung angewendet.
</p>
<p>Beispiele:
</p>
<p>Das Beispiel zeigt, dass 28 eine perfekte Zahl ist, die gleich die Summe
ihrer Teiler au&szlig;er sich selbst ist.
</p>
<pre class="example">(%i1) s: divisors(28);
(%o1)                 {1, 2, 4, 7, 14, 28}
(%i2) lreduce (&quot;+&quot;, args(s)) - 28;
(%o2)                          28
</pre>
<p><code>divisors</code> ist eine vereinfachende Funktion.  In diesem Beispiel braucht
daher der Ausdruck nach der Substitution nicht erneut ausgewertet werden.
</p>
<pre class="example">(%i1) divisors (a);
(%o1)                      divisors(a)
(%i2) subst (8, a, %);
(%o2)                     {1, 2, 4, 8}
</pre>
<p>Anwendung der Funktion <code>divisors</code> auf Gleichungen, Listen, Matrizen oder
Mengen.
</p>
<pre class="example">(%i1) divisors (a = b);
(%o1)               divisors(a) = divisors(b)
(%i2) divisors ([a, b, c]);
(%o2)        [divisors(a), divisors(b), divisors(c)]
(%i3) divisors (matrix ([a, b], [c, d]));
                  [ divisors(a)  divisors(b) ]
(%o3)             [                          ]
                  [ divisors(c)  divisors(d) ]
(%i4) divisors ({a, b, c});
(%o4)        {divisors(a), divisors(b), divisors(c)}
</pre></dd></dl>

<p><a name="elementp"></a>
</p><dl>
<dt><u>Funktion:</u> <b>elementp</b><i> (<var>x</var>, <var>a</var>)</i>
<a name="IDX621"></a>
</dt>
<dd><p>Gibt <code>true</code> zur&uuml;ck, wenn das Argument <var>x</var> Element der Menge <var>a</var>
ist.
</p>
<p><code>elementp</code> gibt eine Fehlermeldung, wenn das Argument <var>a</var> keine
Menge ist.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) elementp (sin(1), {sin(1), sin(2), sin(3)});
(%o1)                         true
(%i2) elementp (sin(1), {cos(1), cos(2), cos(3)});
(%o2)                         false
</pre></dd></dl>

<p><a name="emptyp"></a>
</p><dl>
<dt><u>Funktion:</u> <b>emptyp</b><i> (<var>a</var>)</i>
<a name="IDX622"></a>
</dt>
<dd><p>Gibt <code>true</code> zur&uuml;ck, wenn das Argument <var>a</var> die leere Menge oder eine
leere Liste ist.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) map (emptyp, [{}, []]);
(%o1)                     [true, true]
(%i2) map (emptyp, [a + b, {{}}, %pi]);
(%o2)                 [false, false, false]
</pre></dd></dl>

<p><a name="equiv_005fclasses"></a>
</p><dl>
<dt><u>Funktion:</u> <b>equiv_classes</b><i> (<var>s</var>, <var>F</var>)</i>
<a name="IDX623"></a>
</dt>
<dd><p>Gibt die Menge der &Auml;quivalenzklassen der Menge <var>s</var> f&uuml;r die
&Auml;quivalenzrelation <code>F</code> zur&uuml;ck.
</p>
<p>Die &Auml;quivalenzrelation <code>F</code> ist eine Funktion mit zwei Argumenten
definiert auf dem Kartesischen Produkt der Menge <var>s</var> mit <var>s</var>.  Die
R&uuml;ckgabe der Funktion <code>F</code> ist <code>true</code> oder <code>false</code> oder ein
Ausdruck <var>expr</var>, so dass <code>is(<var>expr</var>)</code> das Ergebnis <code>true</code>
oder <code>false</code> hat.
</p>
<p>Ist <var>F</var> keine &Auml;quivalenzrelation, wird die Funktion von
<code>equiv_classes</code> ohne Fehlermeldung akzeptiert.  Das Ergebnis ist jedoch
im Allgemeinen nicht korrekt.
</p>
<p>Beispiele:
</p>
<p>Die &Auml;quivalenzrelation ist ein Lambda-Ausdruck mit den Ergebnissen
<code>true</code> oder <code>false</code>.
</p>
<pre class="example">(%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0},
                        lambda ([x, y], is (equal (x, y))));
(%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}
</pre>
<p>Die &Auml;quivalenzrelation ist der Name einer relationalen Funktion, die von
<code>is</code> zu <code>true</code> oder <code>false</code> ausgewertet wird.
</p>
<pre class="example">(%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0}, equal);
(%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}
</pre>
<p>Die &Auml;quivalenzklassen sind Mengen mit Zahlen, die sich um ein Vielfaches von
3 voneinander unterscheiden.
</p>
<pre class="example">(%i1) equiv_classes ({1, 2, 3, 4, 5, 6, 7},
                     lambda ([x, y], remainder (x - y, 3) = 0));
(%o1)              {{1, 4, 7}, {2, 5}, {3, 6}}
</pre></dd></dl>

<p><a name="every"></a>
</p><dl>
<dt><u>Funktion:</u> <b>every</b><i> (<var>f</var>, <var>s</var>)</i>
<a name="IDX624"></a>
</dt>
<dt><u>Funktion:</u> <b>every</b><i> (<var>f</var>, <var>L_1</var>, &hellip;, <var>L_n</var>)</i>
<a name="IDX625"></a>
</dt>
<dd><p>Gibt das Ergebnis <code>true</code> zur&uuml;ck, wenn die Aussage <code>f</code> das Ergebnis
<code>true</code> f&uuml;r alle Elemente der Menge <var>s</var> hat.
</p>
<p>Ist das zweite Argument eine Menge, dann gibt <code>every(<var>f</var>, <var>s</var>)</code>
den Wert <code>true</code> zur&uuml;ck, wenn <code>is(<var>f</var>(<var>a_i</var>))</code> das Ergebnis
<code>true</code> f&uuml;r alle Elemente <var>a_i</var> der Menge <var>s</var> hat.  <code>every</code>
wertet <var>f</var> nicht notwendigerweise f&uuml;r alle Elemente <var>a_i</var> aus, wenn
das Ergebnis bereits feststeht.  Da Mengen nicht geordnet sind, kann die
Funktion <code>every</code> die Ausdr&uuml;cke <code><var>f</var>(<var>a_i</var>)</code> in irgendeiner
Reihenfolge auswerten.
</p>
<p>Sind die Argumente eine oder mehrere Listen, dann gibt
<code>every(<var>f</var>, <var>L_1</var>, ..., <var>L_n</var>)</code> den Wert <code>true</code> zur&uuml;ck,
wenn <code>is(<var>f</var>(<var>x_1</var>, ..., <var>x_n</var>))</code> das Ergebnis <code>true</code>
f&uuml;r alle <var>x_1</var>, &hellip;, <var>x_n</var> der Listen <var>L_1</var>, &hellip;,
<var>L_n</var> hat.  <code>every</code> wertet <var>f</var> wird nicht notwendigerweise f&uuml;r 
alle Kombinationen <var>x_1</var>, &hellip;, <var>x_n</var> aus, wenn das Ergebnis bereits
feststeht.  <code>every</code> wertet die Listen in der Reihenfolge des steigenden
Index aus.
</p>
<p>Ist die leere Menge oder leere Liste ein Argument der Funktion <code>every</code>,
dann ist das Ergebnis immer <code>false</code>.
</p>
<p>Hat die Optionsvariable <code><a href="maxima_25.html#maperror">maperror</a></code>
 den Wert <code>true</code>, m&uuml;ssen alle
Listen <var>L_1</var>, &hellip;, <var>L_n</var> die gleiche L&auml;nge haben.  Hat die
Optionsvariable <code>maperror</code> den Wert <code>false</code>, werden die Listen auf
die L&auml;nge der k&uuml;rzesten Liste abgeschnitten.
</p>
<p>Kann die Aussagefunktion <var>f</var> von der Funktion <code>is</code> nicht zu <code>true</code>
oder <code>false</code> ausgewertet werden, h&auml;ngt das Ergebnis von der
Optionsvariablen <code><a href="maxima_11.html#prederror">prederror</a></code>
 ab.  Hat die Optionsvariable <code>prederror</code>
den Wert <code>true</code>, werden solche Werte als <code>false</code> behandelt und die
Funktion <code>every</code> hat das Ergebnis <code>false</code>.  Hat <code>prederror</code>
den Wert <code>false</code>, werden solche Werte als <code>unknown</code> behandelt und die
Funktion <code>every</code> hat das Ergebnis <code>unknown</code>.
</p>
<p>Beispiele:
</p>
<p><code>every</code> angewendet auf eine Menge.  Die Aussagefunktion hat ein Argument.
</p>
<pre class="example">(%i1) every (integerp, {1, 2, 3, 4, 5, 6});
(%o1)                         true
(%i2) every (atom, {1, 2, sin(3), 4, 5 + y, 6});
(%o2)                         false
</pre>
<p><code>every</code> angewendet auf zwei Listen.  Die Aussagefunktion hat zwei
Argumente entsprechend der Anzahl der Listen.
</p>
<pre class="example">(%i1) every (&quot;=&quot;, [a, b, c], [a, b, c]);
(%o1)                         true
(%i2) every (&quot;#&quot;, [a, b, c], [a, b, c]);
(%o2)                         false
</pre>
<p>Kann die Aussagefunktion <var>f</var> nicht zu <code>true</code> oder <code>false</code>
ausgewertet werden, h&auml;ngt das Ergebnis von <code>every</code> von der 
Optionsvariablen <code>prederror</code> ab.
</p>
<pre class="example">(%i1) prederror : false;
(%o1)                         false
(%i2) map (lambda ([a, b], is (a &lt; b)), [x, y, z],
                   [x^2, y^2, z^2]);
(%o2)              [unknown, unknown, unknown]
(%i3) every (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z^2]);
(%o3)                        unknown
(%i4) prederror : true;
(%o4)                         true
(%i5) every (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z^2]);
(%o5)                         false
</pre></dd></dl>

<p><a name="extremal_005fsubset"></a>
</p><dl>
<dt><u>Funktion:</u> <b>extremal_subset</b><i> (<var>s</var>, <var>f</var>, max)</i>
<a name="IDX626"></a>
</dt>
<dt><u>Funktion:</u> <b>extremal_subset</b><i> (<var>s</var>, <var>f</var>, min)</i>
<a name="IDX627"></a>
</dt>
<dd><p>Gibt die Teilmenge von <var>s</var> zur&uuml;ck, f&uuml;r die die Funktion <var>f</var> maximale
oder minimale Ergebnisse hat.
</p>
<p><code>extremal_subset(<var>s</var>, <var>f</var>, max)</code> gibt die Teilmenge der Liste oder
Menge <var>s</var> zur&uuml;ck, f&uuml;r die die Funktion <var>f</var> ihre maximalen Werte
annimmt.
</p>
<p><code>extremal_subset(<var>s</var>, <var>f</var>, min)</code> gibt die Teilmenge der Liste oder
Menge <var>s</var> zur&uuml;ck, f&uuml;r die die Funktion <var>f</var> ihre minimalen Werte
annimmt.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) extremal_subset ({-2, -1, 0, 1, 2}, abs, max);
(%o1)                       {- 2, 2}
(%i2) extremal_subset ({sqrt(2), 1.57, %pi/2}, sin, min);
(%o2)                       {sqrt(2)}
</pre></dd></dl>

<p><a name="flatten"></a>
</p><dl>
<dt><u>Funktion:</u> <b>flatten</b><i> (<var>expr</var>)</i>
<a name="IDX628"></a>
</dt>
<dd><p>Sammelt die Argumente von allen Teilausdr&uuml;cken, die denselben Operator wie
der Ausdruck <var>expr</var> haben und konstruiert einen Ausdruck mit dem Operator
des Ausdrucks <var>expr</var> und den Argumenten.  Ein einfaches Beispiel ist eine
verschachtelte Liste.  <code>flatten</code> konstruiert in diesem Fall eine Liste
aus den Elementen aller Teillisten.
</p>
<p>Teilausdr&uuml;cke, deren Operator sich von dem Hauptoperator des Ausdrucks
<var>expr</var> unterscheidet, werden als ein Argument betrachtet, auch wenn der
Teilausdr&uuml;ck wiederum Teilausdr&uuml;cke des Hauptoperators enth&auml;lt.
</p>
<p>Es ist m&ouml;glich, dass <code>flatten</code> Ausdr&uuml;cke konstruiert, in denen die
Anzahl der Argumente nicht der erforderlichen Anzahl an Argumenten des Operators
entspricht.  Dies kann zu Fehlermeldungen bei der Auswertung oder Vereinfachung
f&uuml;hren.  <code>flatten</code> kontrolliert nicht, ob die konstruierten Ausdr&uuml;cke
g&uuml;ltig sind.
</p>
<p>Ausdr&uuml;cke mit speziellen Darstellungen, wie zum Beispiel CRE-Ausdr&uuml;cke,
k&ouml;nnen von <code>flatten</code> nicht verarbeitet werden.  In diesem F&auml;llen gibt
<code>flatten</code> das Argument unver&auml;ndert zur&uuml;ck.
</p>
<p>Beispiele:
</p>
<p>Wird <code>flatten</code> auf eine Liste angewendet, werden die Elemente aller
Teillisten zu einer Liste zusammengef&uuml;gt.
</p>
<pre class="example">(%i1) flatten ([a, b, [c, [d, e], f], [[g, h]], i, j]);
(%o1)            [a, b, c, d, e, f, g, h, i, j]
</pre>
<p>Wird <code>flatten</code> auf eine Menge angewendet, werden die Elemente aller
Teilmengen zu einer Menge zusammengef&uuml;gt.
</p>
<pre class="example">(%i1) flatten ({a, {b}, {{c}}});
(%o1)                       {a, b, c}
(%i2) flatten ({a, {[a], {a}}});
(%o2)                       {a, [a]}
</pre>
<p>Die Funktionsweise von <code>flatten</code> ist vergleichbar mit der Deklaration eines
Operators als ein N-ary-Operator.  Im Unterschied zu einer Deklaration hat 
<code>flatten</code> keinen Einfluss auf Teilausdr&uuml;cke, die einen vom Hauptoperator
verschiedenen Operator haben.
</p>
<pre class="example">(%i1) expr: flatten (f (g (f (f (x)))));
(%o1)                     f(g(f(f(x))))
(%i2) declare (f, nary);
(%o2)                         done
(%i3) ev (expr);
(%o3)                      f(g(f(x)))
</pre>
<p><code>flatten</code> kann Ausdr&uuml;cke mit indizierte Funktionen vereinfachen.
</p>
<pre class="example">(%i1) flatten (f[5] (f[5] (x, y), z));
(%o1)                      f (x, y, z)
                            5
</pre>
<p>Es ist m&ouml;glich, dass <code>flatten</code> einen Ausdruck konstruiert, der nicht die
korrekte Anzahl an Argumenten eines Operators enth&auml;lt.
</p>
<pre class="example">(%i1) 'mod (5, 'mod (7, 4));
(%o1)                   mod(5, mod(7, 4))
(%i2) flatten (%);
(%o2)                     mod(5, 7, 4)
(%i3) ''%, nouns;
Wrong number of arguments to mod
 -- an error.  Quitting.  To debug this try debugmode(true);
</pre></dd></dl>

<p><a name="full_005flistify"></a>
</p><dl>
<dt><u>Funktion:</u> <b>full_listify</b><i> (<var>a</var>)</i>
<a name="IDX629"></a>
</dt>
<dd><p>Ersetzt jedes Auftreten des Operators f&uuml;r Mengen in dem Ausdruck <var>a</var>
durch den Operator f&uuml;r Listen.  Die Ersetzung wird auch in verschachtelten
Teilausdr&uuml;cken ausgef&uuml;hrt, deren Operator nicht der Operator f&uuml;r Mengen
ist.
</p>
<p>Die Funktion <code><a href="#listify">listify</a></code>
 ersetzt nur den Hauptoperator eines Ausdrucks.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) full_listify ({a, b, {c, {d, e, f}, g}});
(%o1)               [a, b, [c, [d, e, f], g]]
(%i2) full_listify (F (G ({a, b, H({c, d, e})})));
(%o2)              F(G([a, b, H([c, d, e])]))
</pre></dd></dl>

<p><a name="fullsetify"></a>
</p><dl>
<dt><u>Funktion:</u> <b>fullsetify</b><i> (<var>a</var>)</i>
<a name="IDX630"></a>
</dt>
<dd><p>Ist <var>a</var> eine Liste, wird der Operator f&uuml;r Listen durch den Operator f&uuml;r
Mengen ersetzt.  Dann wird <code>fullsetify</code> auf alle Argumente der Liste
angewendet.  Ist ein Argument keine Liste, wenn das Argument unver&auml;ndert
zur&uuml;ckgegeben.
</p>
<p>Die Funktion <code><a href="#setify">setify</a></code>
 ersetzt nur den Hauptoperator eines Ausdrucks.
</p>
<p>Beispiele:
</p>
<p>Im zweiten Beispiel wird das Argument der Funktion <code>f</code> nicht in eine
Menge konvertiert, da der Operator des Teilausdrucks keine Liste ist.
</p>
<pre class="example">(%i1) fullsetify ([a, [a]]);
(%o1)                       {a, {a}}
(%i2) fullsetify ([a, f([b])]);
(%o2)                      {a, f([b])}
</pre></dd></dl>

<p><a name="identity"></a>
</p><dl>
<dt><u>Funktion:</u> <b>identity</b><i> (<var>x</var>)</i>
<a name="IDX631"></a>
</dt>
<dd><p>Gibt f&uuml;r jedes Argument <var>x</var> das Argument selbst zur&uuml;ck.
</p>
<p>Beispiele:
</p>
<p><code>identity</code> kann als eine Aussagefunktion genutzt werden, wenn die Argumente
boolesche Werte sind.
</p>
<pre class="example">(%i1) every (identity, [true, true]);
(%o1)                         true
</pre></dd></dl>

<p><a name="integer_005fpartitions"></a>
</p><dl>
<dt><u>Funktion:</u> <b>integer_partitions</b><i> (<var>n</var>)</i>
<a name="IDX632"></a>
</dt>
<dt><u>Funktion:</u> <b>integer_partitions</b><i> (<var>n</var>, <var>len</var>)</i>
<a name="IDX633"></a>
</dt>
<dd><p>Ermittelt die Zerlegung einer ganzen Zahl <var>n</var> in ganze Zahlen, die
<var>n</var> als Summe haben.
</p>
<p><code>integer_partitions(<var>n</var>)</code> gibt eine Menge aller Zerlegungen der ganzen
Zahl <var>n</var> zur&uuml;ck.  Jede Zerlegung ist eine Liste mit den ganzen Zahlen, die
<var>n</var> als Summe haben.  Die Listen sind nach der Gr&ouml;&szlig;e sortiert.
</p>
<p><code>integer_partitions(<var>n</var>, <var>len</var>)</code> gibt eine Menge aller Zerlegungen
der ganzen Zahl <var>n</var> zur&uuml;ck, deren Listen <code>len</code> oder weniger Elemente
haben.  Listen die weniger als <code>len</code> Elemente haben, werden mit Nullen
aufgef&uuml;llt.
</p>
<p>Siehe auch die Funktionen <code><a href="#num_005fpartitions">num_partitions</a></code>
 und
<code><a href="#num_005fdistinct_005fpartitions">num_distinct_partitions</a></code>.
</p>

<p>Beispiele:
</p>
<pre class="example">(%i1) integer_partitions (3);
(%o1)               {[1, 1, 1], [2, 1], [3]}
(%i2) s: integer_partitions (25)$
(%i3) cardinality (s);
(%o3)                         1958
(%i4) map (lambda ([x], apply (&quot;+&quot;, x)), s);
(%o4)                         {25}
(%i5) integer_partitions (5, 3);
(%o5) {[2, 2, 1], [3, 1, 1], [3, 2, 0], [4, 1, 0], [5, 0, 0]}
(%i6) integer_partitions (5, 2);
(%o6)               {[3, 2], [4, 1], [5, 0]}
</pre>
<p>Um alle Zerlegungen zu finden, die eine Bedingung erf&uuml;llen, kann die Funktion
<code><a href="#subset">subset</a></code>
 genutzt werden.  In diesem Beispiel werden alle Zerlegungen
der Zahl 10 ermittelt, die nur Primzahlen enthalten.
</p>
<pre class="example">(%i1) s: integer_partitions (10)$
(%i2) cardinality (s);
(%o2)                          42
(%i3) xprimep(x) := integerp(x) and (x &gt; 1) and primep(x)$
(%i4) subset (s, lambda ([x], every (xprimep, x)));
(%o4) {[2, 2, 2, 2, 2], [3, 3, 2, 2], [5, 3, 2], [5, 5], [7, 3]}
</pre></dd></dl>

<p><a name="intersect"></a>
</p><dl>
<dt><u>Funktion:</u> <b>intersect</b><i> (<var>a_1</var>, &hellip;, <var>a_n</var>)</i>
<a name="IDX634"></a>
</dt>
<dd><p><code>intersect</code> ist identisch mit der Funktion <code><a href="#intersection">intersection</a></code>.
</p>
</dd></dl>

<p><a name="intersection"></a>
</p><dl>
<dt><u>Funktion:</u> <b>intersection</b><i> (<var>a_1</var>, &hellip;, <var>a_n</var>)</i>
<a name="IDX635"></a>
</dt>
<dd><p>Gibt die Schnittmenge der Mengen <var>a_1</var>, &hellip;, <var>a_n</var> zur&uuml;ck.  Die
Schnittmenge enth&auml;lt die Elemente, die den Mengen gemeinsam sind.
</p>
<p><code>intersection</code> gibt eine Fehlermeldung, wenn eines der Argumente
keine Menge ist.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) S_1 : {a, b, c, d};
(%o1)                     {a, b, c, d}
(%i2) S_2 : {d, e, f, g};
(%o2)                     {d, e, f, g}
(%i3) S_3 : {c, d, e, f};
(%o3)                     {c, d, e, f}
(%i4) S_4 : {u, v, w};
(%o4)                       {u, v, w}
(%i5) intersection (S_1, S_2);
(%o5)                          {d}
(%i6) intersection (S_2, S_3);
(%o6)                       {d, e, f}
(%i7) intersection (S_1, S_2, S_3);
(%o7)                          {d}
(%i8) intersection (S_1, S_2, S_3, S_4);
(%o8)                          {}
</pre></dd></dl>

<p><a name="kron_005fdelta"></a>
</p><dl>
<dt><u>Funktion:</u> <b>kron_delta</b><i> (<var>x_1</var>, <var>x_2</var>, &hellip;, <var>x_p</var>)</i>
<a name="IDX636"></a>
</dt>
<dd><p>Ist die Kronecker-Delta-Funktion.
</p>

<p><code>kron_delta</code> vereinfacht zu <code>1</code>, wenn die Argumente <var>x_i</var> und
<var>y_i</var> f&uuml;r alle Paare gleich sind, und zu <code>0</code>, wenn <var>x_i</var> und 
<var>y_i</var> nicht gleich sind f&uuml;r irgendein Paar der Argumente.  Die Gleichheit
wird festgestellt mit <code>is(equal(xi,xj))</code> und die Ungleichheit mit
<code>is(notequal(xi,xj))</code>.  Wird nur ein Argument angegeben, signalisiert
die Funktion <code>kron_delta</code> einen Fehler.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) kron_delta(a,a);
(%o1)                                  1
(%i2) kron_delta(a,b,a,b);
(%o2)                          kron_delta(a, b)
(%i3) kron_delta(a,a,b,a+1);
(%o3)                                  0
(%i4) assume(equal(x,y));
(%o4)                            [equal(x, y)]
(%i5) kron_delta(x,y);
(%o5)                                  1
</pre></dd></dl>

<p><a name="listify"></a>
</p><dl>
<dt><u>Funktion:</u> <b>listify</b><i> (<var>a</var>)</i>
<a name="IDX637"></a>
</dt>
<dd><p>Ist das Argument <var>a</var> eine Menge, werden die Elemente der Menge als eine
Liste zur&uuml;ckgegeben.  Ansonsten wird <var>a</var> zur&uuml;ckgegeben.
</p>
<p>Siehe die Funktion <code><a href="#full_005flistify">full_listify</a></code>,
 um auch Mengen in Teilausdr&uuml;cken
von <var>a</var> durch Listen zu ersetzen.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) listify ({a, b, c, d});
(%o1)                     [a, b, c, d]
(%i2) listify (F ({a, b, c, d}));
(%o2)                    F({a, b, c, d})
</pre></dd></dl>

<p><a name="lreduce"></a>
</p><dl>
<dt><u>Funktion:</u> <b>lreduce</b><i> (<var>F</var>, <var>s</var>)</i>
<a name="IDX638"></a>
</dt>
<dt><u>Funktion:</u> <b>lreduce</b><i> (<var>F</var>, <var>s</var>, <var>s_0</var>)</i>
<a name="IDX639"></a>
</dt>
<dd><p>Wendet eine Funktion <var>F</var>, die zwei Argumente hat, auf die Elemente einer
Liste <var>s</var> an, indem die Funktionsaufrufe verkettet werden.
</p>
<p>Das Kommando <code>lreduce(<var>F</var>, <var>s</var>)</code> bildet den Ausdruck
<code>F(... F(F(s_1, s_2), s_3), ... s_n)</code>.  Ist das optionale Argument
<var>s_0</var> vorhanden, dann ist das Ergebnis &auml;quivalent zu
<code>lreduce(<var>F</var>, cons(<var>s_0</var>, <var>s</var>))</code>.
</p>
<p>Siehe auch <code><a href="#rreduce">rreduce</a></code>,
 <code><a href="#xreduce">xreduce</a></code>
 und <code><a href="#tree_005freduce">tree_reduce</a></code>.
</p>

<p>Beispiele:
</p>
<p><code>lreduce</code> ohne das optionale Argument.
</p>
<pre class="example">(%i1) lreduce (f, [1, 2, 3]);
(%o1)                     f(f(1, 2), 3)
(%i2) lreduce (f, [1, 2, 3, 4]);
(%o2)                  f(f(f(1, 2), 3), 4)
</pre>
<p><code>lreduce</code> mit dem optionalen Argument.
</p>
<pre class="example">(%i1) lreduce (f, [1, 2, 3], 4);
(%o1)                  f(f(f(4, 1), 2), 3)
</pre>
<p><code>lreduce</code> mit den bin&auml;ren Operatoren der Exponentiation &quot;^&quot; und der
Division &quot;/&quot;.
</p>
<pre class="example">(%i1) lreduce (&quot;^&quot;, args ({a, b, c, d}));
                               b c d
(%o1)                       ((a ) )
(%i2) lreduce (&quot;/&quot;, args ({a, b, c, d}));
                                a
(%o2)                         -----
                              b c d
</pre></dd></dl>

<p><a name="makeset"></a>
</p><dl>
<dt><u>Funktion:</u> <b>makeset</b><i> (<var>expr</var>, <var>x</var>, <var>s</var>)</i>
<a name="IDX640"></a>
</dt>
<dd><p>Generiert eine Menge, indem der Ausdruck <var>expr</var> ausgewertet wird, wobei das
Argument <var>x</var> eine Liste mit Variablen des Ausdrucks und <var>s</var> eine
Menge oder eine Liste mit Listen ist.  Ein Element der Menge wird generiert,
indem die Variablen in <var>x</var> nacheinander an die Elemente in <var>s</var>
gebunden werden.
</p>
<p>Jedes Element des Argumentes <var>s</var> muss dieselbe L&auml;nge wie <var>x</var> haben.
Die Liste der Variablen <var>x</var> muss eine List mit Symbolen sein.  Indizierte
Variablen sind nicht m&ouml;glich.  Auch wenn nur eine Variable angegeben wird,
muss diese Element einer Liste sein und jedes Element von <var>s</var> muss eine
Liste mit einem Element sein.
</p>
<p>Siehe auch die Funktion <code><a href="maxima_5.html#makelist">makelist</a></code>,
 um eine Liste zu generieren.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) makeset (i/j, [i, j], [[1, a], [2, b], [3, c], [4, d]]);
                           1  2  3  4
(%o1)                     {-, -, -, -}
                           a  b  c  d
(%i2) S : {x, y, z}$
(%i3) S3 : cartesian_product (S, S, S);
(%o3) {[x, x, x], [x, x, y], [x, x, z], [x, y, x], [x, y, y], 
[x, y, z], [x, z, x], [x, z, y], [x, z, z], [y, x, x], 
[y, x, y], [y, x, z], [y, y, x], [y, y, y], [y, y, z], 
[y, z, x], [y, z, y], [y, z, z], [z, x, x], [z, x, y], 
[z, x, z], [z, y, x], [z, y, y], [z, y, z], [z, z, x], 
[z, z, y], [z, z, z]}
(%i4) makeset (i + j + k, [i, j, k], S3);
(%o4) {3 x, 3 y, y + 2 x, 2 y + x, 3 z, z + 2 x, z + y + x, 
                                       z + 2 y, 2 z + x, 2 z + y}
(%i5) makeset (sin(x), [x], {[1], [2], [3]});
(%o5)               {sin(1), sin(2), sin(3)}
</pre></dd></dl>

<p><a name="moebius"></a>
</p><dl>
<dt><u>Funktion:</u> <b>moebius</b><i> (<var>n</var>)</i>
<a name="IDX641"></a>
</dt>
<dd><p>Ist die M&ouml;biusfunktion.
</p>
<p>Ist die nat&uuml;rliche Zahl <var>n</var> quadratfrei, dann vereinfacht die
M&ouml;biusfunktion zu <code>-1^k</code>, wobei <var>k</var> die Anzahl der Primfaktoren der
Zahl <var>n</var> ist.  Eine Zahl ist quadratfrei, wenn sie nur voneinander
verschiedene Primfaktoren hat.  F&uuml;r <code><var>n</var> = 1</code> vereinfacht die
M&ouml;biusfunktion zu <code>1</code> und f&uuml;r alle anderen positiven ganzen Zahlen zum
Wert <code>0</code>.  F&uuml;r andere Argumente wird eine Substantivform als Ergebnis
zur&uuml;ckgegeben.
</p>
<p>Ist das Argument der Funktion <code>moebius</code> eine Liste, Menge, Matrix oder
eine Gleichung, wird die Funktion auf die Elemente oder beide Seiten der
Gleichung angewendet.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) moebius (1);
(%o1)                           1
(%i2) moebius (2 * 3 * 5);
(%o2)                          - 1
(%i3) moebius (11 * 17 * 29 * 31);
(%o3)                           1
(%i4) moebius (2^32);
(%o4)                           0
(%i5) moebius (n);
(%o5)                      moebius(n)
(%i6) moebius (n = 12);
(%o6)                    moebius(n) = 0
(%i7) moebius ([11, 11 * 13, 11 * 13 * 15]);
(%o7)                      [- 1, 1, 1]
(%i8) moebius (matrix ([11, 12], [13, 14]));
                           [ - 1  0 ]
(%o8)                      [        ]
                           [ - 1  1 ]
(%i9) moebius ({21, 22, 23, 24});
(%o9)                      {- 1, 0, 1}
</pre></dd></dl>

<p><a name="multinomial_005fcoeff"></a>
</p><dl>
<dt><u>Funktion:</u> <b>multinomial_coeff</b><i> (<var>a_1</var>, &hellip;, <var>a_n</var>)</i>
<a name="IDX642"></a>
</dt>
<dt><u>Funktion:</u> <b>multinomial_coeff</b><i> ()</i>
<a name="IDX643"></a>
</dt>
<dd><p>Gibt den Multinomialkoeffizienten zur&uuml;ck.  Im Spezialfall <code><var>k</var> = 2</code>
ergibt sich die Binomialverteilung.  Siehe <code><a href="maxima_10.html#binomial">binomial</a></code>.
</p>

<p>Enth&auml;lt das Ergebnis Fakult&auml;ten, kann das Ergebnis m&ouml;glicherweise mit der
Funktion <code><a href="maxima_10.html#minfactorial">minfactorial</a></code>
 weiter vereinfacht werden.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) multinomial_coeff (1, 2, x);
                            (x + 3)!
(%o1)                       --------
                              2 x!
(%i2) minfactorial (%);
                     (x + 1) (x + 2) (x + 3)
(%o2)                -----------------------
                                2
(%i3) multinomial_coeff (-6, 2);
                             (- 4)!
(%o3)                       --------
                            2 (- 6)!
(%i4) minfactorial (%);
(%o4)                          10
</pre></dd></dl>

<p><a name="num_005fdistinct_005fpartitions"></a>
</p><dl>
<dt><u>Funktion:</u> <b>num_distinct_partitions</b><i> (<var>n</var>)</i>
<a name="IDX644"></a>
</dt>
<dt><u>Funktion:</u> <b>num_distinct_partitions</b><i> (<var>n</var>, list)</i>
<a name="IDX645"></a>
</dt>
<dd><p>Gibt die Anzahl der M&ouml;glichkeiten an, eine nat&uuml;rliche Zahl <var>n</var> in
Summanden zu zerlegen, wobei jeder Summand nur einmal vorkommt.  Ist <var>n</var>
keine nat&uuml;rliche Zahl wird eine Substantivform als Ergebnis zur&uuml;ckgegeben.
</p>
<p><code>num_distinct_partitions(<var>n</var>, list)</code> gibt eine Liste mit der Anzahl
der voneinander verschiedenen Partitionen der nat&uuml;rlichen Zahlen 1, 2, 3,
&hellip;, <var>n</var> zur&uuml;ck.
</p>
<p>Siehe auch die Funktionen <code><a href="#num_005fpartitions">num_partitions</a></code>
 und <code><a href="#integer_005fpartitions">integer_partitions</a></code>.
</p>

<p>Beispiele:
</p>
<pre class="example">(%i1) num_distinct_partitions (12);
(%o1)                          15
(%i2) num_distinct_partitions (12, list);
(%o2)      [1, 1, 1, 2, 2, 3, 4, 5, 6, 8, 10, 12, 15]
(%i3) num_distinct_partitions (n);
(%o3)              num_distinct_partitions(n)
</pre></dd></dl>

<p><a name="num_005fpartitions"></a>
</p><dl>
<dt><u>Funktion:</u> <b>num_partitions</b><i> (<var>n</var>)</i>
<a name="IDX646"></a>
</dt>
<dt><u>Funktion:</u> <b>num_partitions</b><i> (<var>n</var>, list)</i>
<a name="IDX647"></a>
</dt>
<dd><p>Gibt die Anzahl der M&ouml;glichkeiten an, eine nat&uuml;rliche Zahl <var>n</var> in
Summanden zu zerlegen.  Ist <var>n</var> keine nat&uuml;rliche Zahl wird eine
Substantivform als Ergebnis zur&uuml;ckgegeben.
</p>
<p><code>num_partitions(<var>n</var>, list)</code> gibt eine Liste mit der Anzahl
der Partitionen der nat&uuml;rlichen Zahlen 1, 2, 3, &hellip;, <var>n</var> zur&uuml;ck.
</p>
<p>Das Kommando <code>num_partitions(<var>n</var>)</code> ist f&uuml;r eine nat&uuml;rliche Zahl
<var>n</var> &auml;quivalent zu <code>cardinality(integer_partitions(<var>n</var>))</code>.
Da die Funktion <code>num_partitions</code> die Menge nicht konstruiert, ist diese
Funktion deutlich schneller.
</p>
<p>Siehe auch die Funktionen <code><a href="#num_005fdistinct_005fpartitions">num_distinct_partitions</a></code>
 und
<code><a href="#integer_005fpartitions">integer_partitions</a></code>.
</p>

<p>Beispiele:
</p>
<pre class="example">(%i1) num_partitions (5) = cardinality (integer_partitions (5));
(%o1)                         7 = 7
(%i2) num_partitions (8, list);
(%o2)            [1, 1, 2, 3, 5, 7, 11, 15, 22]
(%i3) num_partitions (n);
(%o3)                   num_partitions(n)
</pre></dd></dl>

<p><a name="partition_005fset"></a>
</p><dl>
<dt><u>Funktion:</u> <b>partition_set</b><i> (<var>a</var>, <var>f</var>)</i>
<a name="IDX648"></a>
</dt>
<dd><p>Zerlegt eine Menge <var>a</var> mit der Aussagefunktion <var>f</var>.
</p>
<p><code>partition_set</code> gibt eine Liste mit zwei Elementen zur&uuml;ck.  Das erste
Element ist die Menge der Elemente, f&uuml;r die die Aussagefunktion <var>f</var> zu
<code>false</code> ausgewertet wird.  Das zweite Element ist die Menge aller anderen
Elemente.  <code>partition_set</code> wendet nicht die Funktion <code>is</code> auf das
Ergebnis der Aussagefunktion <var>f</var> an.
</p>
<p><code>partition_set</code> gibt eine Fehlermeldung, wenn <var>a</var> keine Menge ist.
</p>
<p>Siehe auch die Funktion <code><a href="#subset">subset</a></code>.
</p>

<p>Beispiele:
</p>
<pre class="example">(%i1) partition_set ({2, 7, 1, 8, 2, 8}, evenp);
(%o1)                   [{1, 7}, {2, 8}]
(%i2) partition_set ({x, rat(y), rat(y) + z, 1},
                     lambda ([x], ratp(x)));
(%o2)/R/              [{1, x}, {y, y + z}]
</pre></dd></dl>

<p><a name="permutations"></a>
</p><dl>
<dt><u>Funktion:</u> <b>permutations</b><i> (<var>a</var>)</i>
<a name="IDX649"></a>
</dt>
<dd><p>Gibt eine Menge mit allen voneinander verschiedenen Permutationen der Elemente
der Liste oder Menge <var>a</var> zur&uuml;ck.  Die Permutationen sind Listen.
</p>
<p>Ist das Argument <var>a</var> eine Liste, werden auch doppelte Elemente in die
m&ouml;glichen Permutationen eingeschlossen.
</p>
<p><code>permutations</code> gibt eine Fehlermeldung, wenn <var>a</var> keine Liste oder
Menge ist.
</p>
<p>Siehe auch die Funktion <code><a href="#random_005fpermutation">random_permutation</a></code>.
</p>

<p>Beispiele:
</p>
<pre class="example">(%i1) permutations ([a, a]);
(%o1)                       {[a, a]}
(%i2) permutations ([a, a, b]);
(%o2)           {[a, a, b], [a, b, a], [b, a, a]}
</pre></dd></dl>

<p><a name="powerset"></a>
</p><dl>
<dt><u>Funktion:</u> <b>powerset</b><i> (<var>a</var>)</i>
<a name="IDX650"></a>
</dt>
<dt><u>Funktion:</u> <b>powerset</b><i> (<var>a</var>, <var>n</var>)</i>
<a name="IDX651"></a>
</dt>
<dd><p>Gibt die Menge aller Teilmengen der Menge <var>a</var> oder eine Teilmenge dieser
Menge zur&uuml;ck.
</p>
<p><code>powerset(<var>a</var>)</code> gibt die Menge aller Teilmengen der Menge <var>a</var>
zur&uuml;ck.  Die Ergebnismenge hat <code>2^cardinality(<var>a</var>)</code> Elemente.
</p>
<p><code>powerset(<var>a</var>, <var>n</var>)</code> gibt die Menge aller Teilmengen der Menge
<var>a</var> zur&uuml;ck, die die M&auml;chtigkeit <var>n</var> haben.
</p>
<p><code>powerset</code> gibt eine Fehlermeldung, wenn <var>a</var> keine Menge oder <var>n</var>
keine nat&uuml;rliche Zahl ist.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) powerset ({a, b, c});
(%o1) {{}, {a}, {a, b}, {a, b, c}, {a, c}, {b}, {b, c}, {c}}
(%i2) powerset ({w, x, y, z}, 4);
(%o2)                    {{w, x, y, z}}
(%i3) powerset ({w, x, y, z}, 3);
(%o3)     {{w, x, y}, {w, x, z}, {w, y, z}, {x, y, z}}
(%i4) powerset ({w, x, y, z}, 2);
(%o4)   {{w, x}, {w, y}, {w, z}, {x, y}, {x, z}, {y, z}}
(%i5) powerset ({w, x, y, z}, 1);
(%o5)                 {{w}, {x}, {y}, {z}}
(%i6) powerset ({w, x, y, z}, 0);
(%o6)                         {{}}
</pre></dd></dl>

<p><a name="random_005fpermutation"></a>
</p><dl>
<dt><u>Funktion:</u> <b>random_permutation</b><i> (<var>a</var>)</i>
<a name="IDX652"></a>
</dt>
<dd><p>Gibt eine zuf&auml;llige Permutation der Menge oder Liste <var>a</var> zur&uuml;ck, die mit
dem Knuth-Misch-Algorithmus generiert wird.
</p>
<p>Die R&uuml;ckgabe ist eine neue Liste, die verschieden vom Argument <var>a</var>.
Jedoch werden nicht die Elemente kopiert.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) random_permutation ([a, b, c, 1, 2, 3]);
(%o1)                  [c, 1, 2, 3, a, b]
(%i2) random_permutation ([a, b, c, 1, 2, 3]);
(%o2)                  [b, 3, 1, c, a, 2]
(%i3) random_permutation ({x + 1, y + 2, z + 3});
(%o3)                 [y + 2, z + 3, x + 1]
(%i4) random_permutation ({x + 1, y + 2, z + 3});
(%o4)                 [x + 1, y + 2, z + 3]
</pre></dd></dl>

<p><a name="rreduce"></a>
</p><dl>
<dt><u>Funktion:</u> <b>rreduce</b><i> (<var>F</var>, <var>s</var>)</i>
<a name="IDX653"></a>
</dt>
<dt><u>Funktion:</u> <b>rreduce</b><i> (<var>F</var>, <var>s</var>, <var>s_{n + 1}</var>)</i>
<a name="IDX654"></a>
</dt>
<dd><p>Wendet eine Funktion <var>F</var>, die zwei Argumente hat, auf die Elemente einer
Liste <var>s</var> an, indem die Funktionsaufrufe verkettet werden.
</p>
<p>Das Kommando <code>rreduce(<var>F</var>, <var>s</var>)</code> bildet den Ausdruck
<code>F(s_1, ... F(s_{n - 2}, F(s_{n - 1}, s_n)))</code>.  Ist das optionale
Argument <var>s_0</var> vorhanden, dann ist das Ergebnis &auml;quivalent zu
<code>rreduce(<var>F</var>, endcons(<var>s_{n + 1}</var>, <var>s</var>))</code>.
</p>
<p>Siehe auch <code><a href="#lreduce">lreduce</a></code>,
 <code><a href="#xreduce">xreduce</a></code>
 und <code><a href="#tree_005freduce">tree_reduce</a></code>.
</p>

<p>Beispiele:
</p>
<p><code>rreduce</code> ohne das optionale Argument.
</p>
<pre class="example">(%i1) rreduce (f, [1, 2, 3]);
(%o1)                     f(1, f(2, 3))
(%i2) rreduce (f, [1, 2, 3, 4]);
(%o2)                  f(1, f(2, f(3, 4)))
</pre>
<p><code>rreduce</code> mit dem optionalen Argument.
</p>
<pre class="example">(%i1) rreduce (f, [1, 2, 3], 4);
(%o1)                  f(1, f(2, f(3, 4)))
</pre>
<p><code>rreduce</code> mit den bin&auml;ren Operatoren der Exponentiation &quot;^&quot; und der
Division &quot;/&quot;.
</p>
<pre class="example">(%i1) rreduce (&quot;^&quot;, args ({a, b, c, d}));
                                 d
                                c
                               b
(%o1)                         a
(%i2) rreduce (&quot;/&quot;, args ({a, b, c, d}));
                               a c
(%o2)                          ---
                               b d
</pre></dd></dl>

<p><a name="setdifference"></a>
</p><dl>
<dt><u>Funktion:</u> <b>setdifference</b><i> (<var>a</var>, <var>b</var>)</i>
<a name="IDX655"></a>
</dt>
<dd><p>Gibt eine Menge mit den Elementen zur&uuml;ck, die in der Menge <var>a</var>, aber nicht
in der Menge <var>b</var> enthalten sind.
</p>
<p><code>setdifference</code> gibt eine Fehlermeldung, wenn die Argumente <var>a</var> oder
<var>b</var> keine Mengen sind.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) S_1 : {a, b, c, x, y, z};
(%o1)                  {a, b, c, x, y, z}
(%i2) S_2 : {aa, bb, c, x, y, zz};
(%o2)                 {aa, bb, c, x, y, zz}
(%i3) setdifference (S_1, S_2);
(%o3)                       {a, b, z}
(%i4) setdifference (S_2, S_1);
(%o4)                     {aa, bb, zz}
(%i5) setdifference (S_1, S_1);
(%o5)                          {}
(%i6) setdifference (S_1, {});
(%o6)                  {a, b, c, x, y, z}
(%i7) setdifference ({}, S_1);
(%o7)                          {}
</pre></dd></dl>

<p><a name="setequalp"></a>
</p><dl>
<dt><u>Funktion:</u> <b>setequalp</b><i> (<var>a</var>, <var>b</var>)</i>
<a name="IDX656"></a>
</dt>
<dd><p>Gibt das Ergebnis <code>true</code> zur&uuml;ck, wenn die Mengen <var>a</var> und <var>b</var>
dieselbe Anzahl an Elementen haben und der Ausdruck <code>is(<var>x</var> = <var>y</var>)</code>
das Ergebnis <code>true</code> f&uuml;r alle Elemente <var>x</var> der Menge <var>a</var> und
<var>y</var> der Menge <var>b</var> hat.  Dabei haben die Elemente eine Ordnung wie sie
von der Funktion <code>listify</code> generiert wird.  Ansonsten ist das Ergebnis
<code>false</code>.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) setequalp ({1, 2, 3}, {1, 2, 3});
(%o1)                         true
(%i2) setequalp ({a, b, c}, {1, 2, 3});
(%o2)                         false
(%i3) setequalp ({x^2 - y^2}, {(x + y) * (x - y)});
(%o3)                         false
</pre></dd></dl>

<p><a name="setify"></a>
</p><dl>
<dt><u>Funktion:</u> <b>setify</b><i> (<var>a</var>)</i>
<a name="IDX657"></a>
</dt>
<dd><p>Konstruiert eine Menge aus den Elementen der Liste <var>a</var>.  Doppelte Elemente
der Liste <var>a</var> werden entfernt und die Elemente werden mit der
Aussagefunktion <code><a href="maxima_6.html#orderlessp">orderlessp</a></code>
 sortiert.
</p>
<p><code>setify</code> gibt eine Fehlermeldung, wenn <var>a</var> keine Liste ist.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) setify ([1, 2, 3, a, b, c]);
(%o1)                  {1, 2, 3, a, b, c}
(%i2) setify ([a, b, c, a, b, c]);
(%o2)                       {a, b, c}
(%i3) setify ([7, 13, 11, 1, 3, 9, 5]);
(%o3)                {1, 3, 5, 7, 9, 11, 13}
</pre></dd></dl>

<p><a name="setp"></a>
</p><dl>
<dt><u>Funktion:</u> <b>setp</b><i> (<var>a</var>)</i>
<a name="IDX658"></a>
</dt>
<dd><p>Gibt das Ergebnis <code>true</code> zur&uuml;ck, wenn das Argument <var>a</var> eine Menge
ist.
</p>
<p><code>setp</code> gibt <code>true</code> auch f&uuml;r Mengen zur&uuml;ck, die noch nicht
vereinfacht sind, also m&ouml;glicherweise doppelte Elemente enthalten.
</p>
<p><code>setp</code> ist &auml;quivalent zu dem Kommando <code>setp(a) := not atom(a)
and op(a) = 'set</code>.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) simp : false;
(%o1)                         false
(%i2) {a, a, a};
(%o2)                       {a, a, a}
(%i3) setp (%);
(%o3)                         true
</pre></dd></dl>

<p><a name="set_005fpartitions"></a>
</p><dl>
<dt><u>Funktion:</u> <b>set_partitions</b><i> (<var>a</var>)</i>
<a name="IDX659"></a>
</dt>
<dt><u>Funktion:</u> <b>set_partitions</b><i> (<var>a</var>, <var>n</var>)</i>
<a name="IDX660"></a>
</dt>
<dd><p>Gibt die Menge aller Partitionen der Menge <var>a</var> oder eine Teilmenge
dieser Menge zur&uuml;ck.
</p>
<p><code>set_partitions(<var>a</var>, <var>n</var>)</code> gibt eine Menge aller Zerlegungen der
Menge <var>a</var> in <var>n</var> nicht-leere voneinander disjunkte Teilmengen zur&uuml;ck.
</p>
<p><code>set_partitions(<var>a</var>)</code> gibt die Menge aller Zerlegungen zur&uuml;ck.
</p>
<p><code><a href="#stirling2">stirling2</a></code>
 gibt die M&auml;chtigkeit einer Menge zur&uuml;ck, die alle
Zerlegungen einer Menge enth&auml;lt.
</p>
<p>Eine Menge mit Zerlegungen <em>P</em> ist eine Zerlegung der Menge <em>S</em>, wenn
</p>
<ol>
<li>
jedes Elemente der Menge <em>P</em> eine nicht-leere Menge ist,
</li><li>
verschiedene Elemente der Menge <em>P</em> voneinander disjunkt sind,
</li><li>
die Vereinigung von Elementen der Menge <em>P</em> gleich der Menge <em>S</em> ist.
</li></ol>

<p>Beispiele:
</p>
<p>Die leere Menge ist eine Zerlegung von sich selbst.
</p>
<pre class="example">(%i1) set_partitions ({});
(%o1)                         {{}}
</pre>
<p>Die M&auml;chtigkeit der Menge der Zerlegungen einer Menge kann mit der Funktion
<code>stirling2</code> ermittelt werden.
</p>
<pre class="example">(%i1) s: {0, 1, 2, 3, 4, 5}$
(%i2) p: set_partitions (s, 3)$ 
(%i3) cardinality(p) = stirling2 (6, 3);
(%o3)                        90 = 90
</pre>
<p>Jedes Element der Menge <code>p</code> hat 3 Elemente.
</p>
<pre class="example">(%i1) s: {0, 1, 2, 3, 4, 5}$
(%i2) p: set_partitions (s, 3)$ 
(%i3) map (cardinality, p);
(%o3)                          {3}
</pre>
<p>F&uuml;r jedes Element der Menge <code>p</code>, ist die Vereinigung ihrer Elemente
gleich der Menge <code>s</code>.
</p>
<pre class="example">(%i1) s: {0, 1, 2, 3, 4, 5}$
(%i2) p: set_partitions (s, 3)$ 
(%i3) map (lambda ([x], apply (union, listify (x))), p);
(%o3)                 {{0, 1, 2, 3, 4, 5}}
</pre></dd></dl>

<p><a name="some"></a>
</p><dl>
<dt><u>Funktion:</u> <b>some</b><i> (<var>f</var>, <var>a</var>)</i>
<a name="IDX661"></a>
</dt>
<dt><u>Funktion:</u> <b>some</b><i> (<var>f</var>, <var>L_1</var>, &hellip;, <var>L_n</var>)</i>
<a name="IDX662"></a>
</dt>
<dd><p>Gibt das Ergebnis <code>true</code> zur&uuml;ck, wenn die Aussage <var>f</var> das Ergebnis
<code>true</code> f&uuml;r eines oder mehrere Argumente hat.
</p>
<p>Ist eine Menge <var>a</var> als Argument gegeben, gibt <code>some(<var>f</var>, <var>s</var>)</code>
das Ergebnis <code>true</code> zur&uuml;ck, wenn <code>is(<var>f</var>(<var>a_i</var>))</code> das Ergebnis
<code>true</code> f&uuml;r eines oder mehrere Elemente <var>a_i</var> der Menge <var>a</var> hat.
<code>some</code> wertet <var>f</var> nicht notwendigerweise f&uuml;r alle Elemente <var>a_i</var>
aus, wenn das Ergebnis bereits feststeht.  Da Mengen nicht geordnet sind, kann
die Funktion <code>some</code> die Ausdr&uuml;cke <code><var>f</var>(<var>a_i</var>)</code> in
irgendeiner Reihenfolge auswerten.
</p>
<p>Sind die Argumente eine oder mehrere Listen, dann gibt
<code>some(<var>f</var>, <var>L_1</var>, ..., <var>L_n</var>)</code> den Wert <code>true</code> zur&uuml;ck,
wenn <code>is(<var>f</var>(<var>x_1</var>, ..., <var>x_n</var>))</code> das Ergebnis <code>true</code>
f&uuml;r eines oder mehrere Elemente <var>x_1</var>, &hellip;, <var>x_n</var> der Listen
<var>L_1</var>, &hellip;, <var>L_n</var> hat.  <code>some</code> wertet <var>f</var> wird nicht
notwendigerweise f&uuml;r alle Kombinationen <var>x_1</var>, &hellip;, <var>x_n</var> aus,
wenn das Ergebnis bereits feststeht.  <code>some</code> wertet die Listen in der
Reihenfolge des steigenden Index aus.
</p>
<p>Ist die leere Menge <code>{}</code> oder die leere Liste  <code>[]</code> unter den 
Argumenten, ist das Ergebnis immer <code>false</code>.
</p>
<p>Hat die Optionsvariable <code><a href="maxima_25.html#maperror">maperror</a></code>
 den Wert <code>true</code>, m&uuml;ssen alle
Listen <var>L_1</var>, &hellip;, <var>L_n</var> die gleiche L&auml;nge haben.  Hat die
Optionsvariable <code>maperror</code> den Wert <code>false</code>, werden Listen auf die
L&auml;nge der k&uuml;rzesten Liste abgeschnitten.
</p>
<p>Kann die Aussagefunktion <var>f</var> von der Funktion <code>is</code> nicht zu <code>true</code>
oder <code>false</code> ausgewertet werden, h&auml;ngt das Ergebnis von der
Optionsvariablen <code><a href="maxima_11.html#prederror">prederror</a></code>
 ab.  Hat die Optionsvariable <code>prederror</code>
den Wert <code>true</code>, werden solche Werte als <code>false</code> behandelt.  Hat
<code>prederror</code> den Wert <code>false</code>, werden solche Werte als <code>unknown</code>
behandelt.
</p>
<p>Beispiele:
</p>
<p><code>some</code> f&uuml;r eine Menge als Argument.  Die Aussage ist eine Funktion mit
einem Argument.
</p>
<pre class="example">(%i1) some (integerp, {1, 2, 3, 4, 5, 6});
(%o1)                         true
(%i2) some (atom, {1, 2, sin(3), 4, 5 + y, 6});
(%o2)                         true
</pre>
<p><code>some</code> angewendet auf zwei Listen.  Die Aussage ist eine Funktion mit
zwei Argumenten.
</p>
<pre class="example">(%i1) some (&quot;=&quot;, [a, b, c], [a, b, c]);
(%o1)                         true
(%i2) some (&quot;#&quot;, [a, b, c], [a, b, c]);
(%o2)                         false
</pre>
<p>Ergebnisse der Aussage <var>f</var>, die zu einem Ergebnis verschieden von
<code>true</code> oder <code>false</code> auswerten,  werden von der Optionsvariablen
<code>prederror</code> kontrolliert.
</p>
<pre class="example">(%i1) prederror : false;
(%o1)                         false
(%i2) map (lambda ([a, b], is (a &lt; b)), [x, y, z],
           [x^2, y^2, z^2]);
(%o2)              [unknown, unknown, unknown]
(%i3) some (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z^2]);
(%o3)                        unknown
(%i4) some (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z + 1]);
(%o4)                         true
(%i5) prederror : true;
(%o5)                         true
(%i6) some (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z^2]);
(%o6)                         false
(%i7) some (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z + 1]);
(%o7)                         true
</pre></dd></dl>

<p><a name="stirling1"></a>
</p><dl>
<dt><u>Funktion:</u> <b>stirling1</b><i> (<var>n</var>, <var>m</var>)</i>
<a name="IDX663"></a>
</dt>
<dd><p>Berechnet Stirling-Zahlen der ersten Art.
</p>
<p>Sind die Argumente <var>n</var> und <var>m</var> nat&uuml;rliche Zahlen, ist der Wert von
<code>stirling1(<var>n</var>, <var>m</var>)</code> die Anzahl der Permutationen einer Menge
mit <var>n</var> Elementen, die <var>m</var> Zyklen hat.  F&uuml;r Details siehe Graham,
Knuth und Patashnik in <i>Conrecte Mathematics</i>.  Maxima nutzt eine Rekursion,
um <code>stirling1(<var>n</var>, <var>m</var>)</code> f&uuml;r <var>m</var> kleiner als <code>0</code> zu
berechnen.  Die Funktion ist nicht definiert f&uuml;r <code>n</code> kleiner als <code>0</code>
und f&uuml;r Argumente die keine ganze Zahlen sind.
</p>
<p><code>stirling1</code> ist eine vereinfachende Funktion.  Maxima kennt die folgenden
Beziehungen (siehe [1]).
</p>
<ul class="toc">
<li>
<code>stirling1(0, n) = kron_delta(0, n)</code>
</li><li>
<code>stirling1(n, n) = 1</code>
</li><li>
<code>stirling1(n, n - 1) = binomial(n, 2)</code>
</li><li>
<code>stirling1(n + 1, 0) = 0</code>
</li><li>
<code>stirling1(n + 1, 1) = n!</code>
</li><li>
<code>stirling1(n + 1, 2) = 2^n  - 1</code>
</li></ul>

<p>Diese Beziehungen werden angewendet, wenn die Argumente ganze Zahlen oder
Symbole sind, die als ganze Zahlen deklariert sind, und das erste Argument
keine negative Zahl ist.  <code>stirling1</code> vereinfacht nicht f&uuml;r Argumente,
die keine ganzen Zahlen sind.
</p>
<p>Referenz:
</p>
<p>[1] Donald Knuth, <i>The Art of Computer Programming,</i>
third edition, Volume 1, Section 1.2.6, Equations 48, 49, and 50.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) declare (n, integer)$
(%i2) assume (n &gt;= 0)$
(%i3) stirling1 (n, n);
(%o3)                           1
</pre>
<p><code>stirling1</code> vereinfacht nicht f&uuml;r Argumente, die keine ganzen Zahlen
sind.
</p>
<pre class="example">(%i1) stirling1 (sqrt(2), sqrt(2));
(%o1)              stirling1(sqrt(2), sqrt(2))
</pre>
<p>Maxima kennt Vereinfachungen der Funktion <code>stirling1</code>.
</p>
<pre class="example">(%i1) declare (n, integer)$
(%i2) assume (n &gt;= 0)$
(%i3) stirling1 (n + 1, n);
                            n (n + 1)
(%o3)                       ---------
                                2
(%i4) stirling1 (n + 1, 1);
(%o4)                          n!
</pre></dd></dl>

<p><a name="stirling2"></a>
</p><dl>
<dt><u>Funktion:</u> <b>stirling2</b><i> (<var>n</var>, <var>m</var>)</i>
<a name="IDX664"></a>
</dt>
<dd><p>Berechnet Stirling-Zahlen der zweiten Art.
</p>
<p>Sind die Argumente <var>n</var> und <var>m</var> nat&uuml;rliche Zahlen, ist der Wert von
<code>stirling2(<var>n</var>, <var>m</var>)</code> die Anzahl der M&ouml;glichkeiten, mit der eine
Menge der M&auml;chtigkeit <var>n</var> in <var>m</var> disjunkte Mengen zerlegt werden kann.
Maxima nutzt eine Rekursion, um <code>stirling2(<var>n</var>, <var>m</var>)</code> f&uuml;r <var>m</var>
kleiner als <code>0</code> zu berechnen.  Die Funktion ist nicht definiert f&uuml;r
<code>n</code> kleiner als <code>0</code> und f&uuml;r Argumente, die keine ganze Zahlen sind.
</p>
<p><code>stirling2</code> ist eine vereinfachende Funktion.  Maxima kennt die folgenden
Beziehungen (siehe [1], [2], [3]).
</p>
<ul class="toc">
<li>
<code>stirling2(0, n) = kron_delta(0, n)</code>
</li><li>
<code>stirling2(n, n) = 1</code>
</li><li>
<code>stirling2(n, n - 1) = binomial(n, 2)</code>
</li><li>
<code>stirling2(n + 1, 1) = 1</code>
</li><li>
<code>stirling2(n + 1, 2) = 2^n  - 1</code>
</li><li>
<code>stirling2(n, 0) = kron_delta(n, 0)</code>
</li><li>
<code>stirling2(n, m) = 0</code> f&uuml;r <code>m &gt; n</code>
</li><li>
<code>stirling2(n, m) = sum((-1)^(m - k) binomial(m k) k^n,i,1,m) / m!</code>, wenn
<em>m</em> und <em>n</em> ganze Zahlen und <em>n</em> eine nat&uuml;rliche Zahl ist.
</li></ul>

<p>Diese Beziehungen werden angewendet, wenn die Argumente ganze Zahlen oder
Symbole sind, die als ganze Zahlen deklariert sind, und das erste Argument
keine negative Zahl ist.  <code>stirling2</code> vereinfacht nicht f&uuml;r Argumente,
die keine ganzen Zahlen sind.
</p>
<p>Referenzen:
</p>
<p>[1] Donald Knuth.  <i>The Art of Computer Programming</i>,
    third edition, Volume 1, Section 1.2.6, Equations 48, 49, and 50.
</p>
<p>[2] Graham, Knuth, and Patashnik.  <i>Concrete Mathematics</i>, Table 264.
</p>
<p>[3] Abramowitz and Stegun.  <i>Handbook of Mathematical Functions</i>,
    Section 24.1.4.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) declare (n, integer)$
(%i2) assume (n &gt;= 0)$
(%i3) stirling2 (n, n);
(%o3)                           1
</pre>
<p><code>stirling2</code> vereinfacht nicht, wenn die Argumente keine ganze Zahlen sind.
</p>
<pre class="example">(%i1) stirling2 (%pi, %pi);
(%o1)                  stirling2(%pi, %pi)
</pre>
<p>Maxima kennt Vereinfachungen der Funktion <code>stirling2</code>.
</p>
<pre class="example">(%i1) declare (n, integer)$
(%i2) assume (n &gt;= 0)$
(%i3) stirling2 (n + 9, n + 8);
                         (n + 8) (n + 9)
(%o3)                    ---------------
                                2
(%i4) stirling2 (n + 1, 2);
                              n
(%o4)                        2  - 1
</pre></dd></dl>

<p><a name="subset"></a>
</p><dl>
<dt><u>Funktion:</u> <b>subset</b><i> (<var>a</var>, <var>f</var>)</i>
<a name="IDX665"></a>
</dt>
<dd><p>Gibt eine Teilmenge der Menge <var>a</var> zur&uuml;ck, deren Elemente der Bedingung
<var>f</var> gen&uuml;gen.
</p>
<p><code>subset</code> gibt eine Menge zur&uuml;ck, die alle Elemente der Menge <var>a</var>
enth&auml;lt, die f&uuml;r die Bedingung <var>f</var> ein von <code>false</code> verschiedenes
Ergebnis haben.  <code>subset</code> wendet nicht die Funktion <code>is</code> auf das
Ergebnis der Bedingung <code>f</code> an.
</p>
<p><code>subset</code> gibt eine Fehlermeldung, wenn das Argument <var>a</var> keine Menge
ist.
</p>
<p>Siehe auch die Funktion <code><a href="#partition_005fset">partition_set</a></code>.
</p>

<p>Beispiele:
</p>
<pre class="example">(%i1) subset ({1, 2, x, x + y, z, x + y + z}, atom);
(%o1)                     {1, 2, x, z}
(%i2) subset ({1, 2, 7, 8, 9, 14}, evenp);
(%o2)                      {2, 8, 14}
</pre></dd></dl>

<p><a name="subsetp"></a>
</p><dl>
<dt><u>Funktion:</u> <b>subsetp</b><i> (<var>a</var>, <var>b</var>)</i>
<a name="IDX666"></a>
</dt>
<dd><p>Gibt das Ergebnis <code>true</code> zur&uuml;ck, wenn die Menge <var>a</var> einer Teilmenge
der Menge <var>b</var> ist.
</p>
<p><code>subsetp</code> gibt eine Fehlermeldung, wenn eines der Argumente keine Menge
ist.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) subsetp ({1, 2, 3}, {a, 1, b, 2, c, 3});
(%o1)                         true
(%i2) subsetp ({a, 1, b, 2, c, 3}, {1, 2, 3});
(%o2)                         false
</pre></dd></dl>

<p><a name="symmdifference"></a>
</p><dl>
<dt><u>Funktion:</u> <b>symmdifference</b><i> (<var>a_1</var>, &hellip;, <var>a_n</var>)</i>
<a name="IDX667"></a>
</dt>
<dd><p>Gibt die symmetrische Differenz der Mengen <code><var>a_1</var>, ..., <var>a_n</var></code>
zur&uuml;ck.  F&uuml;r zwei Argumente ist die symmetrische Differenz &auml;quivalent zu
<code>union(setdifference(<var>a</var>, <var>b</var>), setdifference(<var>b</var>, <var>a</var>))</code>.
</p>
<p><code>symmdifference</code> gibt eine Fehlermeldung, wenn eines der Argumente keine
Menge ist.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) S_1 : {a, b, c};
(%o1)                       {a, b, c}
(%i2) S_2 : {1, b, c};
(%o2)                       {1, b, c}
(%i3) S_3 : {a, b, z};
(%o3)                       {a, b, z}
(%i4) symmdifference ();
(%o4)                          {}
(%i5) symmdifference (S_1);
(%o5)                       {a, b, c}
(%i6) symmdifference (S_1, S_2);
(%o6)                        {1, a}
(%i7) symmdifference (S_1, S_2, S_3);
(%o7)                        {1, b, z}
(%i8) symmdifference ({}, S_1, S_2, S_3);
(%o8)                        {1,b, z}
</pre></dd></dl>

<p><a name="tree_005freduce"></a>
</p><dl>
<dt><u>Funktion:</u> <b>tree_reduce</b><i> (<var>F</var>, <var>s</var>)</i>
<a name="IDX668"></a>
</dt>
<dt><u>Funktion:</u> <b>tree_reduce</b><i> (<var>F</var>, <var>s</var>, <var>s_0</var>)</i>
<a name="IDX669"></a>
</dt>
<dd><p>Wendet eine Funktion <var>F</var>, die zwei Argumente hat, auf die Elemente einer
Liste oder Menge <var>s</var> an, indem die Funktionsaufrufe verkettet werden.
</p>
<p><code>tree_reduce</code> f&uuml;hrt folgende Operationen aus: Die Funktion <var>F</var> wird
auf Paare von Elementen der Liste <var>s</var> angewendet, wodurch die neue Liste
<code>[<var>F</var>(<var>s_1</var>, <var>s_2</var>), <var>F</var>(<var>s_3</var>, <var>s_4</var>), ...]</code>
entsteht.  Hat die Liste eine ungerade Anzahl an Elementen, bleibt das letzte
Element unver&auml;ndert.  Dann wird das Verfahren solange wiederholt, bis nur noch
ein einziges Element &uuml;brig ist.  Dieses wird als Ergebnis zur&uuml;ckgegeben.
</p>
<p>Ist das optionale Argument <var>s_0</var> vorhanden, dann ist das Ergebnis 
&auml;quivalent zu <code>tree_reduce(<var>F</var>, cons(<var>s_0</var>, <var>s</var>)</code>.
</p>
<p>Werden Gleitkommazahlen addiert, dann kann <code>tree_reduce</code> ein Ergebnis
mit einem kleineren Rundungsfehler als <code><a href="#lreduce">lreduce</a></code>
 oder <code><a href="#rreduce">rreduce</a></code>

liefern.
</p>
<p>Siehe auch <code><a href="#lreduce">lreduce</a></code>,
 <code><a href="#rreduce">rreduce</a></code>
 und <code><a href="#xreduce">xreduce</a></code>.
</p>

<p>Beispiele:
</p>
<p><code>tree_reduce</code> angewendet auf eine Liste mit einer geraden Anzahl an
Elementen.
</p>
<pre class="example">(%i1) tree_reduce (f, [a, b, c, d]);
(%o1)                  f(f(a, b), f(c, d))
</pre>
<p><code>tree_reduce</code> angewendet auf eine List mit einer ungeraden Anzahl an
Elementen.
</p>
<pre class="example">(%i1) tree_reduce (f, [a, b, c, d, e]);
(%o1)               f(f(f(a, b), f(c, d)), e)
</pre></dd></dl>

<p><a name="union"></a>
</p><dl>
<dt><u>Funktion:</u> <b>union</b><i> (<var>a_1</var>, &hellip;, <var>a_n</var>)</i>
<a name="IDX670"></a>
</dt>
<dd><p>Gibt die Vereinigung der Mengen <var>a_1</var>, &hellip;, <var>a_n</var> zur&uuml;ck.  Wird
<code>union</code> ohne ein Argument aufgerufen, wird die leere Menge zur&uuml;ckgegeben.
</p>
<p><code>union</code> gibt eine Fehlermeldung, wenn eines der Argumente keine Menge ist.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) S_1 : {a, b, c + d, %e};
(%o1)                   {%e, a, b, d + c}
(%i2) S_2 : {%pi, %i, %e, c + d};
(%o2)                 {%e, %i, %pi, d + c}
(%i3) S_3 : {17, 29, 1729, %pi, %i};
(%o3)                {17, 29, 1729, %i, %pi}
(%i4) union ();
(%o4)                          {}
(%i5) union (S_1);
(%o5)                   {%e, a, b, d + c}
(%i6) union (S_1, S_2);
(%o6)              {%e, %i, %pi, a, b, d + c}
(%i7) union (S_1, S_2, S_3);
(%o7)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}
(%i8) union ({}, S_1, S_2, S_3);
(%o8)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}
</pre></dd></dl>

<p><a name="xreduce"></a>
</p><dl>
<dt><u>Funktion:</u> <b>xreduce</b><i> (<var>F</var>, <var>s</var>)</i>
<a name="IDX671"></a>
</dt>
<dt><u>Funktion:</u> <b>xreduce</b><i> (<var>F</var>, <var>s</var>, <var>s_0</var>)</i>
<a name="IDX672"></a>
</dt>
<dd><p>Wendet eine Funktion <var>F</var>, die zwei Argumente hat, auf die Elemente einer
Liste oder Menge <var>s</var> an, indem die Funktionsaufrufe verkettet werden.  Ist
die Funktion eine N-ary-Funktion wird die Funktion <var>F</var> auf die Liste
angewendet.  Ist die Funktion <var>F</var> keine N-ary_Funktion ist <code>xreduce</code>
&auml;quivalent zu <code><a href="#lreduce">lreduce</a></code>.
</p>

<p>Folgende N-ary-Funktionen und Operatoren kennt <code>xreduce</code>:
Addition <code>&quot;+&quot;</code>, Multiplikation <code>&quot;*&quot;</code>, <code>and</code>, <code>or</code>,
<code>max</code>, <code>min</code> und <code>append</code>.  Funktionen und Operatoren k&ouml;nnen
mit der Funktion <code><a href="maxima_11.html#declare">declare</a></code>
 als <code><a href="maxima_7.html#nary">nary</a></code>
 deklariert werden.  F&uuml;r diese
Funktionen ist <code>xreduce</code> schneller als <code><a href="#lreduce">lreduce</a></code>
 oder
<code><a href="#rreduce">rreduce</a></code>.
</p>

<p>Ist das optionale Argument <var>s_0</var> vorhanden, dann ist das Ergebnis 
&auml;quivalent zu <code>xreduce(<var>s</var>, cons(<var>s_0</var>, <var>s</var>))</code>.
</p>
<p>Siehe auch <code><a href="#lreduce">lreduce</a></code>,
 <code><a href="#rreduce">rreduce</a></code>
 und <code><a href="#tree_005freduce">tree_reduce</a></code>.
</p>

<p>Beispiele:
</p>
<p><code>xreduce</code> angewendet mit einer N-ary-Funktion.  <code>F</code> wird einmal mit
allen Argumenten aufgerufen.
</p>
<pre class="example">(%i1) declare (F, nary);
(%o1)                         done
(%i2) F ([L]) := L;
(%o2)                      F([L]) := L
(%i3) xreduce (F, [a, b, c, d, e]);
(%o3)         [[[[[(&quot;[&quot;, simp), a], b], c], d], e]
</pre>
<p><code>xreduce</code> angewendet mit einer Funktion, die nicht die Eigenschaft 
<code>nary</code> hat.
</p>
<pre class="example">(%i1) G ([L]) := L;
(%o1)                      G([L]) := L
(%i2) xreduce (G, [a, b, c, d, e]);
(%o2)         [[[[[(&quot;[&quot;, simp), a], b], c], d], e]
(%i3) lreduce (G, [a, b, c, d, e]);
(%o3)                 [[[[a, b], c], d], e]
</pre></dd></dl>



<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC92" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_15.html#SEC99" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC409" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Robert</em> on <em>Dezember, 3 2012</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
