@c -----------------------------------------------------------------------------
@c File        : Input.de.texi
@c License     : GNU General Public License (GPL)
@c Language    : German
@c Original    : Input.texi revision 21.08.2011
@c Translation : Dr. Dieter Kaiser
@c Date        : 02.11.2010
@c Revision    : 21.08.2011
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@menu
* Kommentare::
* Dateien::
* Funktionen und Variablen f@"ur die Eingabe und Ausgabe::
* Funktionen und Variablen f@"ur die TeX-Ausgabe::
* Funktionen und Variablen f@"ur die Fortran-Ausgabe::
@end menu

@c -----------------------------------------------------------------------------
@node Kommentare, Dateien, Eingabe und Ausgabe, Eingabe und Ausgabe
@section Kommentare
@c -----------------------------------------------------------------------------

Ein Kommentar in der Maxima-Eingabe ist ein Text der von den Zeichen @code{/*} 
und @code{*/} eingeschlossen ist.  Der Maxima-Parser behandelt einen Kommentar 
wie ein Zwischenraumzeichen, wenn ein Token eingelesen wird.  Ein Token endet 
immer an einem Zwischenraumzeichen.  Eine Eingabe wie @code{a/* foo */b} 
enth@"alt die beiden Token @code{a} und @code{b} und nicht das einzelne Token 
@code{ab}.  Ansonsten werden Kommentare von Maxima ignoriert.  Kommentare werden
im eingelesenen Ausdruck nicht gespeichert.

Kommentare k@"onnen in beliebiger Tiefe verschachtelt werden.  Die 
Begrenzungszeichen @code{/*} und @code{*/} m@"ussen paarweise auftreten.

Beispiele:

@example
(%i1) /* aa is a variable of interest */  aa : 1234;
(%o1)                         1234
(%i2) /* Value of bb depends on aa */  bb : aa^2;
(%o2)                        1522756
(%i3) /* User-defined infix operator */  infix ("b");
(%o3)                           b
(%i4) /* Parses same as a b c, not abc */  a/* foo */b/* bar */c;
(%o4)                         a b c
(%i5) /* Comments /* can be nested /* to any depth */ */ */  1 + xyz;
(%o5)                        xyz + 1
@end example

@c -----------------------------------------------------------------------------
@node Dateien, Funktionen und Variablen f@"ur die Eingabe und Ausgabe, Kommentare, Eingabe und Ausgabe
@section Dateien
@c -----------------------------------------------------------------------------

@c TODO: HIER FEHLEN AUSFUEHRUNGEN DIE MAXIMA BETREFFEN.
@c       DIE OBIGEN AUSFUEHRUNGEN SIND ZU ALLGEMEIN.

Folgende Funktionen und Variablen arbeiten mit Dateien:

@verbatim
   appendfile           batch                 batchload
   closefile            file_output_append    filename_merge
   file_search          file_search_maxima    file_search_lisp
   file_search_demo     file_search_usage     file_search_tests
   file_type            file_type_lisp        file_type_maxima
   load                 load_pathname         loadfile
   loadprint            pathname_directory    pathname_name
   pathname_type        printfile             save
   stringout            with_stdout           writefile
@end verbatim

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur die Eingabe und Ausgabe, Funktionen und Variablen f@"ur die TeX-Ausgabe, Dateien, Eingabe und Ausgabe
@section Funktionen und Variablen f@"ur die Eingabe und Ausgabe
@c -----------------------------------------------------------------------------

@c --- 09.11.2010 DK -----------------------------------------------------------
@anchor{appendfile}
@deffn {Funktion} appendfile (@var{filename})

Startet wie die Funktion @mref{writefile} eine Aufzeichnung aller Ein- und 
Ausgaben der Konsole.  Die Ein- und Ausgaben werden in die Datei @var{filename} 
geschrieben.  Im Unterschied zu @code{writefile} werden die Daten immer an eine 
existierende Datei angeh@"angt, wenn diese existiert.  Existiert die Datei 
nicht, wird diese angelegt.

Die Funktion @mref{closefile} beendet die Aufzeichnung.
@end deffn

@c --- 09.11.2010 DK -----------------------------------------------------------
@anchor{batch}
@deffn  {Funktion} batch (@var{filename})
@deffnx {Funktion} batch (@var{filename}, option)

Das Kommando @code{batch(@var{filename})} liest Maxima-Ausdr@"ucke aus der Datei 
@var{filename} ein, wertet diese aus und gibt die Ergebnisse auf der Konsole 
aus.  @code{batch} sucht die Datei @var{filename} in den Verzeichnissen, die in 
der Liste @mref{file_search_maxima} enthalten sind.  Siehe auch die Funktion
@mrefdot{file_search}

@code{batch(@var{filename}, @code{demo})} entspricht dem Kommando
@code{demo(@var{filename})}.  @code{batch} sucht f@"ur diesen Fall die Datei in
der Liste der Verzeichnisse @mrefdot{file_search_demo}  Siehe auch die Funktion
@mrefdot{demo}

@code{batch(@var{filename}, @code{test})} entspricht dem Kommando
@mref{run_testsuite} mit der Option @code{display_all=true}.  Im Unterschied zur
Funktion @code{run_testsuite} sucht die Funktion @code{batch} die Datei 
@var{filename} in den Verzeichnissen der Liste @code{file_search_maxima} und 
nicht in der Liste @mrefdot{file_search_tests}

Die Maxima-Ausdr@"ucke in der Datei werden wie auf der Konsole mit den 
Zeichen @code{;} oder @code{$} beendet.  Die Systemvariable @code{%} und die
Funktion @code{%th} beziehen sich auf vorhergehende Zeilen in der Datei.  Die
Datei kann @code{:lisp}-Unterbrechungskommandos enthalten.  Leerzeichen, 
Tabulatoren, Zeilenschaltungen und Kommentare werden ignoriert.  Eine geeignete 
Datei kann mit einem Texteditor oder der Funktion @mref{stringout} erstellt 
werden.

Den Ein- und Ausgaben werden jeweils Ein- und Ausgabemarken zugewiesen.  Tritt 
w@"ahrend der Auswertung eines Ausdrucks ein Fehler auf, wird das Einlesen der 
Datei abgebrochen.  Werden Eingaben vom Nutzer ben@"otigt, wie zum Beispiel bei
Fragen der Funktionen @code{asksign} oder @code{askinteger}, dann wartet 
@code{batch} auf die Antworten, um dann die Verarbeitung der Datei fortzusetzen.

Die Verarbeitung von @code{batch} kann durch die Eingabe von @code{control-C} 
abgebrochen werden.  Die weitere Reaktion auf einen Abbruch mit @code{control-C}
h@"angt von der Lisp-Implementation ab.

@code{batch} wertet die Argumente aus.  @code{batch} gibt den Namen der Datei
@var{filename} als Zeichenkette zur@"uck, wenn die Funktion ohne zweites 
Argument oder mit der Option @code{demo} aufgerufen wird.  Wird die Funktion mit 
der Option @code{test} aufgerufen, ist die R@"uckgabe eine leere Liste @code{[]} 
oder eine Liste, die @var{filename} und die Nummern der fehlgeschlagenen Tests
enth@"alt.

Siehe auch die Funktionen @mref{load} und @mrefcomma{batchload} um Dateien
zu laden, sowie die Funktionen @mref{run_testsuite} und @mrefdot{demo}
@end deffn

@c --- 09.11.2010 DK -----------------------------------------------------------
@anchor{batchload}
@deffn {Funktion} batchload (@var{filename})

Liest Ausdr@"ucke aus der Datei @var{filename} ein und wertet diese aus, ohne 
die eingelesenen und ausgewerteten Ausdr@"ucke anzuzeigen und ohne Zuweisung von
Eingabe- und Ausgabemarken.  Die Ausgabe von Fehlermeldungen oder sonstigem 
Text, der von Funktionen ausgegeben wird, wird nicht unterdr@"uckt.

Die Systemvariable @code{%} und die Funktion @code{%th} beziehen sich auf die
letzte Eingabe auf der Konsole und nicht auf Zeilen oder Ergebnisse der Datei.
Im Gegensatz zur Funktion @code{batch} darf eine Datei, die von @code{batchload}
geladen wird, keine @code{:lisp}-Unterbrechungskommandos enthalten.

@code{batchload} gibt eine Zeichenkette mit dem Pfad der Datei @var{filename} 
zur@"uck.  Siehe auch die Funktionen @mref{batch} und @mrefcomma{load} um 
Dateien zu laden.
@end deffn

@c --- 09.11.2010 DK -----------------------------------------------------------
@anchor{closefile}
@deffn {Funktion} closefile ()

Beendet eine Aufzeichnung, die von den Funktionen @mref{writefile} oder 
@mref{appendfile} gestartet wurde, und schlie@ss{}t die Ausgabedatei.
@end deffn

@c --- 09.11.2010 DK -----------------------------------------------------------
@anchor{file_output_append}
@defvr {Optionsvariable} file_output_append
Standardwert: @code{false}

Die Optionsvariable @code{file_output_append} kontrolliert, ob die Funktionen 
@mrefcomma{save} @mref{stringout} oder @mrefcomma{with_stdout} die in eine Datei 
schreiben, diese l@"oschen und neu anlegen oder die Daten anh@"angen.  Wenn 
@code{file_output_append} den Wert @code{true} hat, werden die Daten an die 
existierende Datei angeh@"angt.  Ansonsten wird eine neue Datei erstellt.

Plot-Funktionen und der @"Ubersetzer erstellen grunds@"atzlich neue Dateien und
die Funktionen @mref{tex} und @mref{appendfile} h@"angen die Ausgabe immer an 
eine bestehende Datei an.
@end defvr

@c --- 28.08.2010 DK -----------------------------------------------------------
@anchor{filename_merge}
@deffn {Funktion} filename_merge (@var{path}, @var{filename})

Setzt einen Pfad aus @var{path} und @var{filename} zusammen.  Endet @var{path}
mit einer Zeichenkette der Form @code{###.@var{something}}, wird diese 
Zeichenkette durch @code{@var{filename.@var{something}}} ersetzt.  Ansonsten 
wird der Endbestandteil durch @var{filename} ersetzt.

Die R@"uckgabe ist ein Lisp-Dateiname.

Beispiele:

@example
(%i1) filename_merge("user/", "myfile");
(%o1)                      user/myfile

(%i2) filename_merge("user/###.lisp", "myfile");
(%o2)                   user/myfile.lisp
@end example
@end deffn

@c --- 09.11.2010 DK -----------------------------------------------------------
@anchor{file_search}
@deffn  {Funktion} file_search (@var{filename})
@deffnx {Funktion} file_search (@var{filename}, @var{pathlist})

@code{file_search} sucht die Datei @var{filename} und gibt den Pfad als eine
Zeichenkette zur@"uck, wenn die Datei gefunden wurde.  Ansonsten wird 
@code{false} zur@"uckgegeben.  @code{file_search(@var{filename})} sucht in den 
Standardsuchverzeichnissen, die mit den Optionsvariablen 
@mrefcomma{file_search_maxima} @mref{file_search_lisp} und 
@mref{file_search_demo} spezifiziert werden.

@code{file_search} pr@"uft zuerst, ob die Datei @code{filename} existiert.  Dann
pr@"uft @code{file_search}, ob die Datei anhand von Mustern im Dateinamen 
gefunden werden kann.  Siehe @mref{file_search_maxima} f@"ur die Suche von
Dateien.

Das Argument @var{filename} kann ein Name mit einer Pfadangabe oder allein der
Dateiname sein.  Sind in den Suchverzeichnissen Dateinamen mit Mustern 
enthalten, kann die Datei auch ohne Endung angegeben werden.  Zum Beispiel 
finden die folgenden Kommandos dieselbe Datei, wenn 
@code{/home/wfs/special/###.mac} in der Liste @code{file_search_maxima} 
enthalten ist:

@example
file_search ("/home/wfs/special/zeta.mac");
file_search ("zeta.mac");
file_search ("zeta");
@end example

@code{file_search(@var{filename}, @var{pathlist})} sucht nur in den
Verzeichnissen @var{pathlist}.  Das Argument @var{pathlist} @"uberschreibt die
Standardsuchverzeichnisse.  Auch ein einzelnes Verzeichnis muss als eine Liste 
@"ubergeben werden.

Die Standardsuchverzeichnisse k@"onnen modifiziert werden.  Siehe dazu auch
@mrefdot{file_search_maxima}

@code{file_search} wird von der Funktion @mref{load} mit den Verzeichnislisten
@code{file_search_maxima} und @code{file_search_lisp} aufgerufen.
@end deffn

@c --- 09.11.2010 DK -----------------------------------------------------------
@anchor{file_search_maxima}
@anchor{file_search_lisp}
@anchor{file_search_demo}
@anchor{file_search_usage}
@anchor{file_search_tests}
@defvr  {Optionsvariable} file_search_maxima
@defvrx {Optionsvariable} file_search_lisp
@defvrx {Optionsvariable} file_search_demo
@defvrx {Optionsvariable} file_search_usage
@defvrx {Optionsvariable} file_search_tests

Diese Optionsvariablen bezeichnen Listen mit Verzeichnissen, die von Funktionen 
wie @mref{load} und @mref{demo} durchsucht werden, um eine Datei zu finden.  Die
Standardwerte bezeichnen verschiedene Verzeichnisse der Maxima-Installation.

Diese Variablen k@"onnen modifiziert werden, indem die Standardwerte ersetzt 
oder weitere Verzeichnisse angeh@"angt werden.  Zum Beispiel wird im Folgenden 
der Standardwert der Optionsvariablen @code{file_search_maxima} ersetzt:

@example
file_search_maxima: ["/usr/local/foo/###.mac",
    "/usr/local/bar/###.mac"]$
@end example

In diesem Beispiel werden zwei weitere Verzeichnisse zu der Optionsvariablen 
@code{file_search_maxima} hinzugef@"ugt:

@example
file_search_maxima: append (file_search_maxima,
    ["/usr/local/foo/###.mac", "/usr/local/bar/###.mac"])$
@end example

Soll eine erweiterte Liste der Suchverzeichnisse nach jedem Start von Maxima
zur Verf@"ugung stehen, kann das obige Kommando in die Datei
@code{maxima-init.mac} aufgenommen werden.

Mehrere Dateiendungen und Pfade k@"onnen mit Wildcard-Konstruktionen 
spezifiziert werden.  Eine Zeichenkette @code{###} wird durch einen Dateinamen
ersetzt.  Werden mehrere Zeichenketten durch Kommata getrennt und mit 
geschweiften Klammern angegeben wie zum Beispiel @code{@{foo, bar, baz@}}, 
expandiert die Liste in mehrere Zeichenketten.  Das folgende Beispiel expandiert
f@"ur @code{neumann} 

@example
"/home/@{wfs,gcj@}/###.@{lisp,mac@}"
@end example

in @code{/home/wfs/neumann.lisp}, @code{/home/gcj/neumann.lisp}, 
@code{/home/wfs/neumann.mac} und @code{/home/gcj/neumann.mac}.
@end defvr

@c --- 19.04.2011 DK -----------------------------------------------------------
@anchor{file_type}
@deffn {Funktion} file_type (@var{filename})

Gibt eine Vermutung @"uber den Typ der Datei @var{filename} zur@"uck.  Es 
wird nur die Dateiendung betrachtet.

Die R@"uckgabe ist das Symbol @code{maxima} oder @code{lisp}, wenn die
Dateiendung einen der Werte der Optionsvariablen @mref{file_type_maxima} oder
der Optionsvariablen @mref{file_type_lisp} entspricht.  Ansonsten ist die
R@"uckgabe das Symbol @code{object}.

Siehe auch die Funktion @mrefdot{pathname_type}
@end deffn

@c --- 19.04.2011 DK -----------------------------------------------------------
@anchor{file_type_lisp}
@defvr {Optionsvariable} file_type_lisp
Standardwert:  @code{[l, lsp, lisp]}

Die Optionsvariable @code{file_type_lisp} enth@"alt die Dateiendungen, die
Maxima als die Bezeichnung f@"ur eine Lisp-Datei annimmt.

Siehe auch die Funktion @mrefdot{file_type}
@end defvr

@c --- 19.04.2011 DK -----------------------------------------------------------
@anchor{file_type_maxima}
@defvr {Optionsvariable} file_type_maxima
Standardwert:  @code{[mac, mc, demo, dem, dm1, dm2, dm3, dmt]}

Die Optionsvariable @code{file_type_maxima} enth@"alt die Dateiendungen, die
Maxima als die Bezeichnung f@"ur eine Maxima-Datei annimmt.

Siehe auch die Funktion @mrefdot{file_type}
@end defvr

@c --- 28.08.2010 DK -----------------------------------------------------------
@anchor{load}
@deffn {Funktion} load (@var{filename})

Wertet die Ausdr@"ucke in der Datei @var{filename} aus, wodurch die Variablen,
Funktionen und andere Objekte in Maxima geladen werden.  Alle bisher zugewiesen
Variablen und Definitionen werden @"uberschrieben.  Um die Datei zu finden, wird
von @code{load} die Funktion @mref{file_search} mit den Verzeichnislisten
@mref{file_search_maxima} und @mref{file_search_lisp} aufgerufen.  Ist 
@code{load} erfolgreich, wird der Dateiname zur@"uckgegeben.  Ansonsten gibt
@code{load} eine Fehlermeldung aus.

@code{load} verarbeitet Dateien mit Lisp-Code oder Maxima-Code.  Dateien, die 
mit den Funktionen @mrefcomma{save} @mref{translate_file} und
@mref{compile_file} erstellt wurden, enthalten Lisp-Code.  Dateien, die mit
@mref{stringout} erstellt wurden, enthalten Maxima-Code.  Die Ausgabedateien
dieser Funktionen k@"onnen mit @code{load} geladen werden.  @code{load} ruft die
Funktion @mref{loadfile} auf, um Lisp-Dateien und @mref{batchload} auf, um 
Maxima-Da@-tei@-en zu verarbeiten.

@code{load} erkennt keine @code{:lisp}-Unterbrechungskommandos in 
Maxima-Dateien.  Die Systemvariablen @mrefcomma{_} @mref{__} und @mref{%} und 
die Funktion @mref{%th} behalten jeweils ihren letzten Wert vor dem Aufruf von 
@code{load}.

Siehe auch die Funktionen @mrefcomma{loadfile} @mrefcomma{batch} 
@mref{batchload} und @mrefdot{demo}  @code{loadfile} verarbeitet 
Lisp-Da@-tei@-en.  @code{batch}, @code{batchload} und @code{demo} verarbeiten 
Maxima-Dateien.

Siehe @mref{file_search} f@"ur mehr Informationen, wie Maxima Dateien in 
Verzeichnissen findet.  @code{load} wertet die Argumente aus.
@end deffn

@c --- 09.11.2010 DK -----------------------------------------------------------
@anchor{load_pathname}
@defvr {Systemvariable} load_pathname
Standardwert: @code{false}

Wird eine Datei mit den Funktionen @mrefcomma{load} @mref{loadfile} oder
@mref{batchload} geladen, enth@"alt die Systemvariable @code{load_pathname}
den Namen der Datei.  Der Wert der Systemvariablen kann in der Datei, die 
geladen wird, ausgelesen werden.

Beispiele:

Ist eine Batch-Datei mit den Namen @code{test.mac} in dem Verzeichnis
@example
"/home/dieter/workspace/mymaxima/temp/"
@end example 
abgelegt und enth@"alt die Datei die folgenden Befehle

@example
print("The value of load_pathname is: ", load_pathname)$
print("End of batchfile")$
@end example

dann wird das Folgende ausgegeben:

@example
(%i1) load("/home/dieter/workspace/mymaxima/temp/test.mac")$
The value of load_pathname is:  
              /home/dieter/workspace/mymaxima/temp/test.mac 
End of batchfile
@end example
@end defvr

@c --- 09.11.2010 DK -----------------------------------------------------------
@anchor{loadfile}
@deffn {Funktion} loadfile (@var{filename})

L@"adt die Datei @var{filename} und wertet die Lisp-Ausdr@"ucke in der Datei 
aus.  @code{filename} ruft nicht @mref{file_search} auf, um eine Datei zu 
finden.  Daher muss @code{filename} ein voll@-st@"an@-di@-ger Dateiname sein.

@code{loadfile} kann Dateien verarbeiten, die mit den Funktionen 
@mrefcomma{save} @mref{translate_file} und @mref{compile_file} erzeugt wurden.
@end deffn

@c --- 09.11.2010 DK -----------------------------------------------------------
@anchor{loadprint}
@defvr {Optionsvariable} loadprint
Standardwert: @code{true}

@code{loadprint} kontrolliert, ob Meldungen ausgegeben werden, wenn eine Datei
geladen wird.

@itemize @bullet
@item Hat @code{loadprint} den Wert @code{true}, wird immer eine Meldung 
      ausgegeben.
@item Hat @code{loadprint} den Wert @code{'loadfile}, wird eine Meldung 
      ausgegeben, wenn die Datei mit der Funktion @mref{loadfile} geladen wird.
@item Hat @code{loadprint} den Wert @code{'autoload}, wird eine Meldung 
      ausgegeben, wenn eine Datei automatisch geladen wird.
@item Hat @code{loadprint} den Wert @code{false}, werden keine Meldungen beim 
      Laden von Dateien ausgegeben.
@end itemize
@end defvr

@c -----------------------------------------------------------------------------
@anchor{pathname_directory}
@anchor{pathname_name}
@anchor{pathname_type}
@deffn  {Funktion} pathname_directory (@var{pathname})
@deffnx {Funktion} pathname_name (@var{pathname})
@deffnx {Funktion} pathname_type (@var{pathname})

Diese Funktionen geben die Bestandteile eines Pfadnamens zur@"uck.

Beispiele:

@example 
(%i1) pathname_directory("/home/dieter/maxima/changelog.txt");
(%o1)                 /home/dieter/maxima/
(%i2) pathname_name("/home/dieter/maxima/changelog.txt");
(%o2)                       changelog
(%i3) pathname_type("/home/dieter/maxima/changelog.txt");
(%o3)                          txt
@end example
@end deffn

@c --- 09.11.2010 DK -----------------------------------------------------------
@anchor{printfile}
@deffn {Funktion} printfile (@var{path})

Druckt eine Datei mit dem Namen @var{path} auf der Konsole aus.  @var{path} kann
ein Symbol oder eine Zeichenkette sein.  @code{printfile} sucht die Datei in den 
Verzeichnissen, die in der Optionsvariablen @mref{file_search_usage} enthalten 
sind.

@code{printfile} gibt @var{path} zur@"uck, wenn die Datei existiert.
@end deffn

@c --- 11.11.2010 DK -----------------------------------------------------------
@anchor{save}
@deffn  {Funktion} save (@var{filename}, @var{name_1}, @var{name_2}, @var{name_3}, @dots{})
@deffnx {Funktion} save (@var{filename}, values, functions, labels, @dots{})
@deffnx {Funktion} save (@var{filename}, [@var{m}, @var{n}])
@deffnx {Funktion} save (@var{filename}, @var{name_1}=@var{expr_1}, @dots{})
@deffnx {Funktion} save (@var{filename}, all)
@deffnx {Funktion} save (@var{filename}, @var{name_1}=@var{expr_1}, @var{name_2}=@var{expr_2}, @dots{})

Speichert die aktuellen Werte von @var{name_1}, @var{name_2}, @var{name_3}, 
@dots{}, in die Datei @var{filename}.  Die Argumente sind die Namen von 
Variablen, Funktionen oder anderen Objekten.  Argumente, die keinen Wert haben, 
werden ignoriert.  @code{save} gibt den Namen der Datei @code{filename} 
zur@"uck.

@code{save} speichert die Daten in einem Lisp-Format.  Die gespeicherten Daten
k@"onnen mit dem Kommando @code{load(@var{filename})} zur@"uckgelesen werden.
Siehe @mrefdot{load}

Die Optionsvariable @mref{file_output_append} kontrolliert, ob @code{save} die
Daten an die Ausgabedatei anh@"angt, wenn diese bereits existiert, oder die 
Ausgabedatei zuvor l@"oscht.  Hat @code{file_output_append} den Wert 
@code{true}, werden die Daten angeh@"angt.  Ansonsten wird die Datei gel@"oscht
und neu angelegt, wenn diese bereits existiert.  Existiert die Ausgabedatei
noch nicht, wird diese angelegt.

@code{save(@var{filename}, values, functions, labels, ...)} speichert die
Werte aller Ein@-tr@"a@-ge der Listen @code{values}, @code{functions}, 
@code{labels}, u.s.w. in die Ausgabedatei.  Es kann jede der vorhandenen
Informationslisten, die in der Systemvariablen @code{infolists} enthalten ist, 
als Argument @"ubergeben werden.  @code{values} enth@"alt zum Beispiel alle vom
Nutzer definierten Variablen.

@code{save(@var{filename}, [@var{m}, @var{n}])} speichert die Werte der Eingabe-
und Ausgabemarken von @var{m} bis @var{n}.  @var{m} und @var{n} m@"ussen ganze 
Zahlen sein.  Die Eingabe- und Ausgabemarken k@"onnen auch einzeln gespeichert 
werden, zum Beispiel mit dem Kommando @code{save("foo.1", %i42, %o42)}.
@code{save(@var{filename}, labels)} speichert alle Eingabe- und Ausgabemarken.
Beim Zur@"ucklesen der Marken werden vorhandene Werte @"uberschrieben.

@code{save(@var{filename}, @var{name_1} = @var{expr_1}, @var{name_2} = 
@var{expr_2}, ...)} speichert die Werte @var{expr_1}, @var{expr_2}, @dots{}, 
unter den Namen @var{name_1}, @var{name_2}, @dots{} ab.  Dies kann  n@"utz@-lich
sein, um zum Beispiel die Werte von Marken unter einem neuen Namen 
abzuspeichern.  Die rechte Seite der Gleichungen kann ein beliebiger 
ausgewerteter Ausdruck sein.  Die neuen Namen werden der aktuellen Sitzung nicht
hinzugef@"ugt und nur in der Ausgabedatei gespeichert.

Die verschiedenen M@"oglichkeiten der Funktion @code{save}, k@"onnen
miteinander kombiniert werden.  Das Kommando
@code{save(@var{filename}, aa, bb, cc=42, functions, [11,17])} ist daf@"ur ein
Beispiel.

@code{save(@var{filename}, all)} speichert den aktuellen Zustand von Maxima
in eine Ausgabedatei.  Eingeschlossen sind alle nutzerdefinierten Variablen, 
Funktionen oder Arrays, einschlie@ss{}lich automatischer Definitionen.  Die 
gespeicherten Daten enthalten auch die Werte von ge@"anderten System- oder
Optionsvariablen.  Siehe dazu auch @mrefdot{myoptions}

@code{save} wertet das Argument @var{filename} aus.  Alle anderen Argumente
werden nicht ausgewertet.
@end deffn

@c --- 11.11.2010 DK -----------------------------------------------------------
@anchor{stringout}
@deffn  {Funktion} stringout (@var{filename}, @var{expr_1}, @var{expr_2}, @var{expr_3}, @dots{})
@deffnx {Funktion} stringout (@var{filename}, [@var{m}, @var{n}])
@deffnx {Funktion} stringout (@var{filename}, input)
@deffnx {Funktion} stringout (@var{filename}, functions)
@deffnx {Funktion} stringout (@var{filename}, values)

@code{stringout} schreibt Ausdr@"ucke in einem Format in eine Datei, dass 
identisch mit dem Format der Eingabe ist.  Die Datei kann als Eingabedatei f@"ur
die Funktionen @mref{batch} oder @mref{demo} genutzt werden.  Sie kann mit 
einem Texteditor f@"ur jeden Zweck editiert werden.  @code{stringout} kann
ausgef@"uhrt werden, wenn das Kommando @mref{writefile} aktiv ist.

Die Optionsvariable @mref{file_output_append} kontrolliert, ob @code{stringout}
die Daten an die Ausgabedatei anh@"angt, wenn diese bereits existiert oder die 
Ausgabedatei zuvor l@"oscht.  Hat @code{file_output_append} den Wert 
@code{true}, werden die Daten angeh@"angt, wenn die Datei bereits existiert.  
Ansonsten wird die Datei gel@"oscht und neu angelegt.  Existiert die 
Ausgabedatei noch nicht, wird diese angelegt.

Die allgemeine Form von @code{stringout} schreibt die Werte eines oder mehrerer
Ausdr@"ucke in die Ausgabedatei.  Ist ein Ausdruck eine Variable, wird nur der
Wert der Variablen, nicht jedoch der Name der Variablen in die Ausgabedatei 
geschrieben.  Ein n@"utzlicher Spezialfall ist, dass die Werte der Eingabe- 
und Ausgabemarken (@code{%i1}, @code{%i2}, @code{%i3}, @dots{} und @code{%o1}, 
@code{%o2}, @code{%o3}, @dots{}) in die Datei geschrieben werden k@"onnen.

Hat die Optionsvariable @code{grind} den Wert @code{true}, wird die Ausgabe
im Format der Funktion @mref{grind} in die Ausgabedatei geschrieben.  Ansonsten
wird das Format der Funktion @mref{string} f@"ur die Ausgabe genutzt.

@code{stringout(@var{filename}, [@var{m}, @var{n}])} schreibt die Werte aller
Eingabemarken von @var{m} bis @var{n} in die Ausgabedatei.
@code{stringout(@var{filename}, input)} schreibt alle Eingabemarken in die
Ausgabedatei.  @code{stringout(@var{filename}, functions)} schreibt alle vom 
Nutzer definierten Funktionen, die in der Informationsliste @code{functions} 
enthalten sind, in die Ausgabedatei.

@code{stringout(@var{filename}, values)} schreibt alle benuzterdefinierten
Variablen, die in der Informationsliste @code{values} enthalten sind, in die
Ausgabedatei.  Die Variablen werden als eine Zuweisung, mit dem Namen der 
Variablen, dem Zuweisungsoperator @code{:} und dem Wert in die Datei 
geschrieben.  Im Unterschied dazu, speichert die allgemeine Form der Funktion
@code{stringout} die Variablen nicht als Zuweisung.
@end deffn

@c --- 28.08.2010 DK -----------------------------------------------------------
@anchor{with_stdout}
@deffn  {Funktion} with_stdout (@var{f}, @var{expr_1}, @var{expr_2}, @var{expr_3}, @dots{})
@deffnx {Funktion} with_stdout (@var{s}, @var{expr_1}, @var{expr_2}, @var{expr_3}, @dots{})

@code{with_stdout} wertet Argumente @var{expr_1}, @var{expr_2}, @var{expr_3}, 
@dots{} aus und schreibt die Ergebnisse der Auswertung in die Ausgabedatei 
@code{f} oder in den Stream @code{s}.  Die Ergebnisse werden nicht auf der 
Konsole ausgegeben.

Die Optionsvariable @code{file_output_append} bestimmt, ob @code{with_stdout} 
die Daten an die Ausgabedatei anh@"angt oder die Ausgabedatei zuvor l@"oscht. 
Hat @code{file_output_append} den Wert @code{true}, werden die Daten 
angeh@"angt.  Ansonsten wird die Datei gel@"oscht und neu angelegt.  Existiert
die Ausgabedatei noch nicht, wird diese angelegt.

@code{with_stout} gibt das Ergebnis des letzten Argumentes zur@"uck.  

Siehe auch @mrefdot{writefile}

Beispiel:

@example
(%i1) with_stdout ("tmp.out", for i:5 thru 10 do
         print (i, "! yields", i!))$
(%i2) printfile ("tmp.out")$
5 ! yields 120 
6 ! yields 720 
7 ! yields 5040 
8 ! yields 40320 
9 ! yields 362880 
10 ! yields 3628800
@end example
@end deffn

@c --- 03.09.2010 DK -----------------------------------------------------------
@anchor{writefile}
@deffn {Funktion} writefile (@var{filename})

Startet eine Aufzeichnung aller Ein- und Ausgaben der Konsole.  Die Ein- und 
Ausgaben werden in die Datei @var{filename} geschrieben.

Die Ausgabedatei kann von Maxima nicht wieder zur@"uckgelesen werden.  Um ein 
Datei zu erzeugen, die von Maxima zur@"uckgelesen werden kann, siehe die 
Funktionen @mref{save} und @mrefdot{stringout}  @code{save} speichert 
Ausdr@"ucke in einem Lisp-Format und @code{stringout} in einem Maxima-Format.

Die Reaktion der Funktion @code{writefile} f@"ur den Fall, dass die Ausgabedatei
bereits existiert, h@"angt von der Lisp-Implementation ab.  Die Ausgabedatei
kann zur@"uckgesetzt werden oder die Daten werden angeh@"angt.  Die Funktion
@mref{appendfile} h@"angt die Daten immer an eine existierende Datei an.

Um eine Aufzeichnung ohne Textausgaben von Funktionen zu erhalten, kann 
@code{writefile} nach der Ausf@"uhrung von @code{playback} ausgef@"uhrt werden. 
@code{playback} gibt alle vorhergenden Eingabe- und Ausgabemarken aus, jedoch 
nicht sonstige Textausgaben von Maxima-Funktionen.

Mit @mref{closefile} wird die Aufzeichnung beendet.
@end deffn

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur die TeX-Ausgabe, Funktionen und Variablen f@"ur die Fortran-Ausgabe, Funktionen und Variablen f@"ur die Eingabe und Ausgabe, Eingabe und Ausgabe
@section Funktionen und Variablen f@"ur die TeX-Ausgabe
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{tex}
@deffn  {Function} tex (@var{expr})
@deffnx {Function} tex (@var{expr}, @var{destination})
@deffnx {Function} tex (@var{expr}, false)
@deffnx {Function} tex (@var{label})
@deffnx {Function} tex (@var{label}, @var{destination})
@deffnx {Function} tex (@var{label}, false)

Prints a representation of an expression suitable for the TeX document 
preparation system. The result is a fragment of a document, which can be copied
into a larger document but not processed by itself.

@code{tex (@var{expr})} prints a TeX representation of @var{expr} on the 
console.

@code{tex (@var{label})} prints a TeX representation of the expression named by 
@var{label} and assigns it an equation label (to be displayed to the left of 
the expression). The TeX equation label is the same as the Maxima label.

@var{destination} may be an output stream or file name. When @var{destination} 
is a file name, @code{tex} appends its output to the file. The functions 
@code{openw} and @code{opena} create output streams.

@code{tex (@var{expr}, false)} and @code{tex (@var{label}, false)} return their
TeX output as a string.

@code{tex} evaluates its first argument after testing it to see if it is a 
label. Quote-quote @code{''} forces evaluation of the argument, thereby 
defeating the test and preventing the label.

See also @code{texput}.

Examples:

@example
(%i1) integrate (1/(1+x^3), x);
                                    2 x - 1
                  2            atan(-------)
             log(x  - x + 1)        sqrt(3)    log(x + 1)
(%o1)      - --------------- + ------------- + ----------
                    6             sqrt(3)          3
(%i2) tex (%o1);
$$-@{@{\log \left(x^2-x+1\right)@}\over@{6@}@}+@{@{\arctan \left(@{@{2\,x-1
 @}\over@{\sqrt@{3@}@}@}\right)@}\over@{\sqrt@{3@}@}@}+@{@{\log \left(x+1\right)
 @}\over@{3@}@}\leqno@{\tt (\%o1)@}$$
(%o2)                          (\%o1)
(%i3) tex (integrate (sin(x), x));
$$-\cos x$$
(%o3)                           false
(%i4) tex (%o1, "foo.tex");
(%o4)                          (\%o1)
@end example

@code{tex (@var{expr}, false)} returns its TeX output as a string.

@example
(%i1) S : tex (x * y * z, false);
(%o1) $$x\,y\,z$$
(%i2) S;
(%o2) $$x\,y\,z$$
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{tex1}
@deffn {Function} tex1 (@var{e})

Returns a string which represents the TeX output for the expressions @var{e}.
The TeX output is not enclosed in delimiters for an equation or any other 
environment.

Examples:

@example
(%i1) tex1 (sin(x) + cos(x));
(%o1)                     \sin x+\cos x
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{texput}
@deffn  {Function} texput (@var{a}, @var{s})
@deffnx {Function} texput (@var{a}, @var{f})
@deffnx {Function} texput (@var{a}, @var{s}, @var{operator_type})
@deffnx {Function} texput (@var{a}, [@var{s_1}, @var{s_2}], matchfix)
@deffnx {Function} texput (@var{a}, [@var{s_1}, @var{s_2}, @var{s_3}], matchfix)

Assign the TeX output for the atom @var{a}, which can be a symbol or the name 
of an operator.

@code{texput (@var{a}, @var{s})} causes the @code{tex} function to interpolate 
the string @var{s} into the TeX output in place of @var{a}.

@code{texput (@var{a}, @var{f})} causes the @code{tex} function to call the 
function @var{f} to generate TeX output. @var{f} must accept one argument, 
which is an expression which has operator @var{a}, and must return a string 
(the TeX output). @var{f} may call @code{tex1} to generate TeX output for the 
arguments of the input expression.

@code{texput (@var{a}, @var{s}, @var{operator_type})}, where @var{operator_type}
is @code{prefix}, @code{infix}, @code{postfix}, @code{nary}, or @code{nofix},
causes the @code{tex} function to interpolate @var{s} into the TeX output in 
place of @var{a}, and to place the interpolated text in the appropriate 
position.

@code{texput (@var{a}, [@var{s_1}, @var{s_2}], matchfix)} causes the @code{tex} 
function to interpolate @var{s_1} and @var{s_2} into the TeX output on either 
side of the arguments of @var{a}. The arguments (if more than one) are separated
by commas.

@code{texput (@var{a}, [@var{s_1}, @var{s_2}, @var{s_3}], matchfix)} causes the 
@code{tex} function to interpolate @var{s_1} and @var{s_2} into the TeX output 
on either side of the arguments of @var{a}, with @var{s_3} separating the 
arguments.

Examples:

Assign TeX output for a variable.

@example
(%i1) texput (me,"\\mu_e");
(%o1)                         \mu_e
(%i2) tex (me);
$$\mu_e$$
(%o2)                         false
@end example

Assign TeX output for an ordinary function (not an operator).

@example
(%i1) texput (lcm, "\\mathrm@{lcm@}");
(%o1)                     \mathrm@{lcm@}
(%i2) tex (lcm (a, b));
$$\mathrm@{lcm@}\left(a , b\right)$$
(%o2)                         false
@end example

Call a function to generate TeX output.

@example
(%i1) texfoo (e) := block ([a, b], [a, b] : args (e),
  concat ("\\left[\\stackrel@{", tex1 (b), 
          "@}@{", tex1 (a), "@}\\right]"))$
(%i2) texput (foo, texfoo);
(%o2)                        texfoo
(%i3) tex (foo (2^x, %pi));
$$\left[\stackrel@{\pi@}@{2^@{x@}@}\right]$$
(%o3)                         false
@end example

Assign TeX output for a prefix operator.

@example
(%i1) prefix ("grad");
(%o1)                         grad
(%i2) texput ("grad", " \\nabla ", prefix);
(%o2)                        \nabla 
(%i3) tex (grad f);
$$ \nabla f$$
(%o3)                         false
@end example

Assign TeX output for an infix operator.

@example
(%i1) infix ("~");
(%o1)                           ~
(%i2) texput ("~", " \\times ", infix);
(%o2)                        \times 
(%i3) tex (a ~ b);
$$a \times b$$
(%o3)                         false
@end example

Assign TeX output for a postfix operator.

@example
(%i1) postfix ("##");
(%o1)                          ##
(%i2) texput ("##", "!!", postfix);
(%o2)                          !!
(%i3) tex (x ##);
$$x!!$$
(%o3)                         false
@end example

Assign TeX output for a nary operator.

@example
(%i1) nary ("@@@@");
(%o1)                          @@@@
(%i2) texput ("@@@@", " \\circ ", nary);
(%o2)                         \circ 
(%i3) tex (a @@@@ b @@@@ c @@@@ d);
$$a \circ b \circ c \circ d$$
(%o3)                         false
@end example

Assign TeX output for a nofix operator.

@example
(%i1) nofix ("foo");
(%o1)                          foo
(%i2) texput ("foo", "\\mathsc@{foo@}", nofix);
(%o2)                     \mathsc@{foo@}
(%i3) tex (foo);
$$\mathsc@{foo@}$$
(%o3)                         false
@end example

Assign TeX output for a matchfix operator.

@example
(%i1) matchfix ("<<", ">>");
(%o1)                          <<
(%i2) texput ("<<", [" \\langle ", " \\rangle "], matchfix);
(%o2)                [ \langle ,  \rangle ]
(%i3) tex (<<a>>);
$$ \langle a \rangle $$
(%o3)                         false
(%i4) tex (<<a, b>>);
$$ \langle a , b \rangle $$
(%o4)                         false
(%i5) texput ("<<", [" \\langle ", " \\rangle ", " \\, | \\,"],
      matchfix);
(%o5)           [ \langle ,  \rangle ,  \, | \,]
(%i6) tex (<<a>>);
$$ \langle a \rangle $$
(%o6)                         false
(%i7) tex (<<a, b>>);
$$ \langle a \, | \,b \rangle $$
(%o7)                         false
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{get_tex_enviroment}
@anchor{set_tex_enviroment}
@deffn  {Function} get_tex_environment (@var{op})
@deffnx {Function} set_tex_environment (@var{op}, @var{before}, @var{after})

Customize the TeX environment output by @code{tex}.
As maintained by these functions, the TeX environment comprises two strings:
one is printed before any other TeX output, and the other is printed after.

Only the TeX environment of the top-level operator in an expression
is output; TeX environments associated with other operators are ignored.

@code{get_tex_environment} returns the TeX enviroment which is applied
to the operator @var{op}; returns the default if no other environment
has been assigned.

@code{set_tex_environment} assigns the TeX environment for the operator 
@var{op}.

Examples:

@example
(%i1) get_tex_environment (":=");
(%o1) [
\begin@{verbatim@}
, ;
\end@{verbatim@}
]
(%i2) tex (f (x) := 1 - x);

\begin@{verbatim@}
f(x):=1-x;
\end@{verbatim@}

(%o2)                         false
(%i3) set_tex_environment (":=", "$$", "$$");
(%o3)                       [$$, $$]
(%i4) tex (f (x) := 1 - x);
$$f(x):=1-x$$
(%o4)                         false
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{get_tex_enviroment_default}
@anchor{set_tex_enviroment_default}
@deffn  {Function} get_tex_environment_default ()
@deffnx {Function} set_tex_environment_default (@var{before}, @var{after})

Customize the TeX environment output by @code{tex}.
As maintained by these functions, the TeX environment comprises two strings:
one is printed before any other TeX output, and the other is printed after.

@code{get_tex_environment_default} returns the TeX environment which is
applied to expressions for which the top-level operator has no
specific TeX environment (as assigned by @code{set_tex_environment}).

@code{set_tex_environment_default} assigns the default TeX environment.

Examples:

@example
(%i1) get_tex_environment_default ();
(%o1)                       [$$, $$]
(%i2) tex (f(x) + g(x));
$$g\left(x\right)+f\left(x\right)$$
(%o2)                         false
(%i3) set_tex_environment_default ("\\begin@{equation@}
", "
\\end@{equation@}");
(%o3) [\begin@{equation@}
, 
\end@{equation@}]
(%i4) tex (f(x) + g(x));
\begin@{equation@}
g\left(x\right)+f\left(x\right)
\end@{equation@}
(%o4)                         false
@end example
@end deffn

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur die Fortran-Ausgabe, , Funktionen und Variablen f@"ur die TeX-Ausgabe, Eingabe und Ausgabe
@section Funktionen und Variablen f@"ur die Fortran-Ausgabe
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@defvr {Option variable} fortindent
Default value: @code{0}

@code{fortindent} controls the left margin indentation of
expressions printed out by the @mref{fortran} command.  @code{0} gives normal
printout (i.e., 6 spaces), and positive values will causes the
expressions to be printed farther to the right.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{fortran}
@deffn {Function} fortran (@var{expr})

Prints @var{expr} as a Fortran statement.
The output line is indented with spaces.
If the line is too long, @code{fortran} prints continuation lines.
@code{fortran} prints the exponentiation operator @code{^} as @code{**},
and prints a complex number @code{a + b %i} in the form @code{(a,b)}.

@var{expr} may be an equation. If so, @code{fortran} prints an assignment
statement, assigning the right-hand side of the equation to the left-hand side.
In particular, if the right-hand side of @var{expr} is the name of a matrix,
then @code{fortran} prints an assignment statement for each element of the
matrix.

If @var{expr} is not something recognized by @code{fortran},
the expression is printed in @mref{grind} format without complaint.
@code{fortran} does not know about lists, arrays, or functions.

@code{fortindent} controls the left margin of the printed lines.
@code{0} is the normal margin (i.e., indented 6 spaces). Increasing
@code{fortindent} causes expressions to be printed further to the right.

When @mref{fortspaces} is @code{true}, @code{fortran} fills out
each printed line with spaces to 80 columns.

@code{fortran} evaluates its arguments;
quoting an argument defeats evaluation.
@code{fortran} always returns @code{done}.

See also the function @mxref{function_f90, f90} for printing one or more
expressions as a Fortran 90 program.

Examples:

@verbatim
(%i1) expr: (a + b)^12$
(%i2) fortran (expr);
      (b+a)**12                                                                 
(%o2)                         done
(%i3) fortran ('x=expr);
      x = (b+a)**12                                                             
(%o3)                         done
(%i4) fortran ('x=expand (expr));
      x = b**12+12*a*b**11+66*a**2*b**10+220*a**3*b**9+495*a**4*b**8+792
     1   *a**5*b**7+924*a**6*b**6+792*a**7*b**5+495*a**8*b**4+220*a**9*b
     2   **3+66*a**10*b**2+12*a**11*b+a**12
(%o4)                         done
(%i5) fortran ('x=7+5*%i);
      x = (7,5)                                                                 
(%o5)                         done
(%i6) fortran ('x=[1,2,3,4]);
      x = [1,2,3,4]                                                             
(%o6)                         done
(%i7) f(x) := x^2$
(%i8) fortran (f);
      f                                                                         
(%o8)                         done
@end verbatim
@end deffn

@c -----------------------------------------------------------------------------
@anchor{fortspaces}
@defvr {Option variable} fortspaces
Default value: @code{false}

When @code{fortspaces} is @code{true}, @code{fortran} fills out
each printed line with spaces to 80 columns.
@end defvr

@c --- End of Input.de.texi ----------------------------------------------------

