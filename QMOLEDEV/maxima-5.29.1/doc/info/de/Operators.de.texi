@c -----------------------------------------------------------------------------
@c File        : Operators.de.texi
@c License     : GNU General Public License (GPL)
@c Language    : German
@c Original    : Operators.texi revision 03.09.2011
@c Translation : Dr. Dieter Kaiser
@c Date        : 17.10.2010
@c Revision    : 24.09.2011
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in Operatoren::
* Arithmetische Operatoren::
* Relationale Operatoren::
* Logische Operatoren::
* Operatoren f@"ur Gleichungen::
* Zuweisungsoperatoren::
* Nutzerdefinierte Operatoren::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in Operatoren, Arithmetische Operatoren, Operatoren, Operatoren
@section Einf@"uhrung in Operatoren
@c -----------------------------------------------------------------------------

Maxima kennt die @"ublichen arithmetischen, relationalen und logischen
Operatoren der Mathematik.  Weiterhin kennt Maxima Operatoren f@"ur die
Zuweisung von Werten an Variablen und die Definition von Funktionen.  Die
folgende Tabelle zeigt die in diesem Kapitel beschriebenen Operatoren.
Angegeben sind der Name des Operators, der linksseitige Vorrang @code{lbp} und
der rechtsseitige Vorrang @code{rbp}, der Typ des Operators und ein Beispiel
einschlie@ss{}lich der internen Darstellung, wie sie vom Parser von der Eingabe
gelesen wird.

@verbatim

Operator  lbp rbp  Typ     Beispiel
                       
   +      100 134  nary     a+b      ((mplus) $A $B)
   -      100 134  prefix   -a       ((mminus) $A)
   *      120      nary     a*b      ((mtimes) $A $B)
   /      120 120  infix    a/b      ((mquotient) $A $B)
   ^      140 139  infix    a^b      ((mexpt) $A $B)
   **     140 139  infix    a**b     ((mexpt) $A $B)
   ^^     140 139  infix    a^^b     ((mncexpt) $A $B)
   .      130 129  infix    a.b      ((mnctimes) $A $B)
                                     
   <       80  80  infix    a<b      ((mlessp) $A $B)
   <=      80  80  infix    a<=b     ((mleqp) $A $B)
   >       80  80  infix    a>b      ((mqreaterp) $A $B)
   >=      80  80  infix    a>=b     ((mgeqp) $A $B)
                                     
   not         70  prefix   not a    ((mnot) $A)
   and     65      nary     a and b  ((mand) $A $B)
   or      60      nary     a or b   ((mor) $A $B)
                                     
   #       80  80  infix    a#b      ((mnotequal) $A $B)
   =       80  80  infix    a=b      ((mequal) $A $B)
                                     
   :      180  20  infix    a:b      ((msetq) $A $B)
   ::     180  20  infix    a::b     ((mset) $A $B)
   :=     180  20  infix    a:=b     ((mdefine) $A $B)
   ::=    180  20  infix    a::=b    ((mdefmacro) $A $B)

@end verbatim

@noindent
Mit dem Vorrang der Operatoren werden die bekannten Rechenregeln der einzelnen
Operatoren definiert.  So wird zum Beispiel @code{ a + b * c } vom Parser
als @code{ a + (b * c) } interpretiert, da der linksseitige Vorrang der
Multiplikation gr@"o@ss{}er als der linksseitige Vorrang der Addition ist.

Maxima unterscheidet die folgenden Operatoren:

@table @emph
@item Prefix
Prefix-Operatoren sind un@"are Operatoren, die einen Operanden haben, der dem 
Operator nachfolgt.  Beispiele sind die Operatoren @mref{-} und @mrefdot{not}
@item Postfix
Postfix-Operatoren sind un@"are Operatoren, die einen Operanden haben, der dem 
Operator vorangestellt ist.  Ein Beispiel ist der Operator @mref{!} f@"ur die 
Fakult@"at.
@item Infix
Infix-Operatoren, sind bin@"are Operatoren, die zwei Operanden haben.  Der
Operator steht zwischen diesen Operanden.  Hierzu z@"ahlen zum Beispiel der
Operator f@"ur die Exponentiation @mref{^} oder der Operator f@"ur die Zuweisung
@mrefdot{:}
@item N-ary
N-ary-Operatoren fassen eine beliebige Anzahl an Operanden zu einem Ausdruck
zusammen.  Hierzu z@"ahlen die Multiplikation @mref{*} oder die Addition
@mrefdot{+}
@item Matchfix
Matchfix-Operatoren sind Begrenzungszeichen, die eine beliebige Anzahl an
Operanden einschlie@ss{}en.  Ein Beispiel sind die Operatoren @mref{[} und
@mref{]}, die eine Liste @code{[a, b, ...]} definieren.
@item Nofix
Ein Nofix-Operator ist ein Operator, der keinen Operanden hat.  Maxima kennt
keinen internen Nofix-Operator.  Zum Beispiel kann mit @code{nofix(quit)} ein
Nofix-Operator definiert werden.  Dann ist es m@"oglich, Maxima allein mit
@code{quit} anstatt dem Funktionsaufruf @code{quit()} zu beenden.
@end table

Maxima unterscheidet das Symbol eines Operators, wie zum Beispiel @code{+}
f@"ur die Addition, von dem Namen eines Operators, der eine Zeichenkette ist.
Der Additionsoperator hat den Namen @code{"+"}.  Mit dem Namen des Operators
kann der Operator als eine Funktion eingegeben werden.  Im folgenden wird ein
Beispiel f@"ur den bin@"aren Infix-Operator der Exponentiation gezeigt:

@example
(%i1) a^b;
                                b
(%o1)                          a
(%i2) "^"(a,b);
                                b
(%o2)                          a
@end example

Der Name des Operators kann immer dann verwendet werden, wenn eine
Funktion als Argument ben@"otigt wird.  Beispiele sind die Funktionen
@mrefcomma{map} @mref{apply} oder auch die Substitution mit @mrefdot{subst}

@example
(%i3) apply("+", [a,b,c]);
(%o3)                       c + b + a
(%i4) map("^", [a,b,c],[1,2,3]);
                                2   3
(%o4)                      [a, b , c ]
(%i5) subst("*"="+", 10*a*b*c);
(%o5)                    c + b + a + 10
@end example

In @ref{Nutzerdefinierte Operatoren} wird beschrieben, wie interne
Maxima-Ope@-ra@-to@-ren umdefiniert oder neue Operatoren definiert werden.

Die obige Tabelle enth@"alt nicht alle von Maxima definierten Operatoren.
Weitere Operatoren sind zum Beispiel @code{!} f@"ur die Fakult@"at, die
Operatoren @code{for}, @code{do}, @code{while}, um eine Programmschleife zu 
programmieren, oder @code{if}, @code{then}, @code{else}, um eine Bedingung zu 
definieren.

@c TODO: ERGAENZE TABELLE MIT DEN FOLGENDEN OPERATOREN:
@c 
@c       [ ] ( ) ' '' ! !! , ; $
@c       if then else elseif
@c       do for from step next thru unless while
@c       @

@c -----------------------------------------------------------------------------
@need 800
@node Arithmetische Operatoren, Relationale Operatoren, Einf@"uhrung in Operatoren, Operatoren
@section Arithmetische Operatoren
@c -----------------------------------------------------------------------------

@c --- 04.05.2011 DK -----------------------------------------------------------
@anchor{+} 
@anchor{-}
@anchor{*}
@anchor{/}
@anchor{^}
@deffn {Operator} +
@ifinfo
@fnindex Addition
@end ifinfo
@deffnx {Operator} -
@ifinfo
@fnindex Subtraktion
@end ifinfo
@deffnx {Operator} *
@ifinfo
@fnindex Multiplikation
@end ifinfo
@deffnx {Operator} /
@ifinfo
@fnindex Division
@end ifinfo
@deffnx {Operator} ^
@ifinfo
@fnindex Exponentiation
@end ifinfo

Sind die Operatoren der Addition, Multiplikation, Division und Exponentiation.
Wird der Name eines Operators in einem Ausdruck ben@"otigt, k@"onnen die
Bezeichnungen @code{"+"}, @code{"*"}, @code{"/"} und @code{"^"} verwendet
werden.

In Ausdr@"ucken wie @code{(+a)*(-a)} oder @code{exp(-a)} repr@"asentieren die
Operatoren @code{+} und @code{-} die un@"are Addition und Negation.  Die Namen
der Operatoren sind @code{"+"} und @code{"-"}.

Die Subtraktion @code{a - b} wird von Maxima intern als Addition
@code{a + (- b)} dargestellt.  In der Ausgabe wird der Ausdruck @code{a + (- b)}
als Subtraktion @code{a - b} angezeigt.

Die Division @code{a / b} wird von Maxima intern als Multiplikation
@code{a * b^(- 1)} dargestellt.  In der Ausgabe wird der Ausdruck
@code{a * b^(- 1)} als Division @code{a / b} angezeigt.  Der Name des Operators
f@"ur die Division ist @code{"/"}.

Die Operatoren der Addition und Multiplikation sind kommutative
N-ary-Operatoren.  Die Operatoren der  Division und Exponentiation sind
nicht-kommutative bin@"are Operatoren.

Maxima sortiert die Operanden eines kommutativen Operators und konstruiert eine
kanonische Darstellung.  Maxima unterscheidet die interne Sortierung von der
externen Sortierung f@"ur die Anzeige.  Die interne Sortierung wird von der
Aussagefunktion @mref{orderlessp} bestimmt.  Die externe Sortierung f@"ur die
Anzeige wird von der Aussagefunktion @mref{ordergreatp} festgelegt.  Ausnahme
ist die Multiplikation.  F@"ur diese sind die interne und die externe
Sortierung identisch.

Arithmetische Rechnungen mit Zahlen (ganzen Zahlen, rationale Zahlen,
Gleitkommazahlen und gro@ss{}en Gleitkommazahlen) werden als eine Vereinfachung
und nicht als Auswertung  ausgef@"uhrt.  Mit Ausnahme der Exponentiation werden
alle arithmetischen Operationen mit Zahlen zu Zahlen vereinfacht.
Exponentiationen von Zahlen wie zum Beispiel @code{(1/3)^(1/2)} werden nicht
notwendigerweise zu Zahlen vereinfacht.  In diesem Beispiel ist das Ergebnis
der Vereinfachung @code{1/sqrt(3)}.

Bei einer arithmetischen Rechnung kann es zur Umwandlung in Gleitkommazahlen
kommen.  Ist eines der Argumente eine gro@ss{}e Gleitkommazahl, so ist auch das
Ergebnis eine gro@ss{}e Gleitkommazahl.  Entsprechend ist das Ergebnis eine
einfache Gleitkommazahl, sofern mindestens einer der Operanden eine einfache
Gleitkommazahl ist.  Treten nur ganze oder rationale Zahlen auf, ist das
Ergebnis wieder eine ganze oder rationale Zahl.

Da arithmetische Rechnungen Vereinfachungen und keine Auswertungen sind, werden
arithmetische Rechnungen auch dann ausgef@"uhrt, wenn die Auswertung des
Ausdrucks zum Beispiel mit dem @mxref{', Quote-Operator} @code{'} unterdr@"uckt
ist.

Arithmetische Operatoren werden elementweise auf Listen angewendet, wenn die
Optionsvariable @mref{listarith} den Wert @code{true} hat.  Auf Matrizen werden
die arithmetischen Operatoren immer elementweise angewendet.  Ist einer der
Operanden eine Liste oder Matrix und der andere Operand hat einen anderen
Typ, dann wird dieses Argument mit jedem Element der Liste oder Matrix
kombiniert.

Beispiele:

Addition und Multiplikation sind kommutative N-ary-Operatoren.  Maxima sortiert
die Operanden und konstruiert eine kanonische Darstellung.  Die Namen der 
Operatoren sind @code{"+"} und @code{"*"}.

@example
(%i1) c + g + d + a + b + e + f;
(%o1)               g + f + e + d + c + b + a
(%i2) [op (%), args (%)];
(%o2)              [+, [g, f, e, d, c, b, a]]
(%i3) c * g * d * a * b * e * f;
(%o3)                     a b c d e f g
(%i4) [op (%), args (%)];
(%o4)              [*, [a, b, c, d, e, f, g]]
(%i5) apply ("+", [a, 8, x, 2, 9, x, x, a]);
(%o5)                    3 x + 2 a + 19
(%i6) apply ("*", [a, 8, x, 2, 9, x, x, a]);
                                 2  3
(%o6)                       144 a  x
@end example

Division und Exponentiation sind nicht-kommutative bin@"are Operatoren.  Die 
Namen der Operatoren sind @code{"/"} und @code{"^"}.

@example
(%i1) [a / b, a ^ b];
@group
                              a   b
(%o1)                        [-, a ]
                              b
@end group
(%i2) [map (op, %), map (args, %)];
(%o2)              [[/, ^], [[a, b], [a, b]]]
(%i3) [apply ("/", [a, b]), apply ("^", [a, b])];
                              a   b
(%o3)                        [-, a ]
                              b
@end example

Subtraktion und Division werden intern als Addition und Multiplikation 
dargestellt.

@example
(%i1) [inpart (a - b, 0), inpart (a - b, 1), inpart (a - b, 2)];
(%o1)                      [+, a, - b]
(%i2) [inpart (a / b, 0), inpart (a / b, 1), inpart (a / b, 2)];
                                   1
(%o2)                       [*, a, -]
                                   b
@end example

Sind die Operanden Zahlen, werden die Rechnungen ausgef@"uhrt.  Ist einer der
Operanden eine Gleitkommazahl, ist das Ergebnis ebenfalls eine Gleitkommazahl.

@example
@group
(%i1) 17 + b - (1/2)*29 + 11^(2/4);
                                       5
(%o1)                   b + sqrt(11) + -
                                       2
@end group
(%i2) [17 + 29, 17 + 29.0, 17 + 29b0];
(%o2)                   [46, 46.0, 4.6b1]
@end example

Arithmetische Rechnungen sind Vereinfachungen und keine Auswertung.

@example
(%i1) simp : false;
(%o1)                         false
(%i2) '(17 + 29*11/7 - 5^3);
                              29 11    3
(%o2)                    17 + ----- - 5
                                7
(%i3) simp : true;
(%o3)                         true
(%i4) '(17 + 29*11/7 - 5^3);
                                437
(%o4)                         - ---
                                 7
@end example

Arithmetische Rechnungen werden elementweise f@"ur Listen und Matrizen 
ausgef@"uhrt.  Bei Listen wird dies mit der Optionsvariablen
@mref{listarith} kontrolliert.

@example
(%i1) matrix ([a, x], [h, u]) - matrix ([1, 2], [3, 4]);
@group
                        [ a - 1  x - 2 ]
(%o1)                   [              ]
                        [ h - 3  u - 4 ]
@end group
(%i2) 5 * matrix ([a, x], [h, u]);
@group
                          [ 5 a  5 x ]
(%o2)                     [          ]
                          [ 5 h  5 u ]
@end group
(%i3) listarith : false;
(%o3)                         false
(%i4) [a, c, m, t] / [1, 7, 2, 9];
                          [a, c, m, t]
(%o4)                     ------------
                          [1, 7, 2, 9]
(%i5) [a, c, m, t] ^ x;
                                      x
(%o5)                     [a, c, m, t]
(%i6) listarith : true;
(%o6)                         true
(%i7) [a, c, m, t] / [1, 7, 2, 9];
                              c  m  t
(%o7)                     [a, -, -, -]
                              7  2  9
@group
(%i8) [a, c, m, t] ^ x;
                          x   x   x   x
(%o8)                   [a , c , m , t ]
@end group
@end example
@end deffn

@c --- 04.05.2011 DK -----------------------------------------------------------
@anchor{**}
@deffn {Operator} **

Ist eine alternative Schreibweise f@"ur den Operator @code{^} der 
Exponentiation.  In der Ausgabe wird entweder @code{^} angezeigt oder der 
Exponent hochgestellt.  Siehe den Operator der Exponentiation @mrefdot{^}

Die Funktion @mref{fortran} zeigt den Operator der Exponentiation immer als 
@code{**} an, unabh@"angig davon, ob @code{**} oder @code{^} eingegeben wird.

Beispiele:

@example
(%i1) is (a**b = a^b);
(%o1)                         true
(%i2) x**y + x^z;
                              z    y
(%o2)                        x  + x
(%i3) string (x**y + x^z);
(%o3)                        x^z+x^y
(%i4) fortran (x**y + x^z);
      x**z+x**y
(%o4)                         done
@end example
@end deffn

@c --- 04.05.2011 DK -----------------------------------------------------------
@anchor{^^}
@deffn {Operator} ^^
@ifinfo
@fnindex Nicht-kommutative Exponentiation
@end ifinfo

Ist der Operator der nicht-kommutativen Exponentiation von Matrizen.  In der 
linearen Ausgabe wird der nicht-kommutative Operator als @code{^^} angezeigt.
In der zweidimensionalen Ausgabe wird der hochgestellte Exponent von spitzen 
Klammern @code{< >} eingeschlossen.

Beispiele:

@example
(%i1) a . a . b . b . b + a * a * a * b * b;
                        3  2    <2>    <3>
(%o1)                  a  b  + a    . b
(%i2) string (a . a . b . b . b + a * a * a * b * b);
(%o2)                  a^3*b^2+a^^2 . b^^3
@end example
@end deffn

@c --- 04.05.2011 DK -----------------------------------------------------------
@anchor{.}
@deffn {Operator} .
@ifinfo
@fnindex Nicht-kommutative Multiplikation
@end ifinfo

Ist der Operator der nicht-kommutativen Multiplikation von Matrizen.  Siehe
f@"ur Erl@"auterungen @ref{Nicht-kommutative Multiplikation}.
@end deffn

@c -----------------------------------------------------------------------------
@node Relationale Operatoren, Logische Operatoren, Arithmetische Operatoren, Operatoren
@section Relationale Operatoren
@c -----------------------------------------------------------------------------

@c --- 31.10.2010 DK -----------------------------------------------------------
@anchor{<}
@anchor{<=}
@anchor{>=}
@anchor{>}
@deffn {Operator} <
@ifinfo
@fnindex kleiner als
@end ifinfo
@deffnx {Operator} <=
@ifinfo
@fnindex kleiner als oder gleich
@end ifinfo
@deffnx {Operator} >=
@ifinfo
@fnindex gr@"o@ss{}er als oder gleich
@end ifinfo
@deffnx {Operator} >
@ifinfo
@fnindex gr@"o@ss{}er als
@end ifinfo

Die Symbole @code{<}, @code{<=}, @code{>=} und @code{>} sind die relationalen
Operatoren "kleiner als", "kleiner als oder gleich", "gr@"o@ss{}er als oder 
gleich" und "gr@"o@ss{}er als".  Die Namen dieser Operatoren sind jeweils: 
@code{"<"}, @code{"<="}, @code{">="} und @code{">"}.  Diese k@"onnen dort 
eingesetzt werden, wo der Name des Operators ben@"otigt wird.

Die relationalen Operatoren sind bin@"are Operatoren.  Ausdr@"ucke wie 
@code{a < b < c} werden von Maxima nicht erkannt und generieren eine
Fehlermeldung.

Relationale Ausdr@"ucke werden von den Funktionen @mref{is} und
@mref{maybe} sowie den Funktionen @mrefcomma{if} @mref{while} und
@mref{unless} zu booleschen Werten ausgewertet.  Relationale Ausdr@"ucke werden
ansonsten nicht zu booleschen Werten ausgewertet oder vereinfacht.  Jedoch
werden die Operanden eines booleschen Ausdruckes ausgewertet, wenn die
Auswertung nicht mit dem @mxref{', Quote-Operator} @code{'} unterdr@"uckt ist.

Wenn ein relationaler Ausdruck mit den Funktionen @code{is} oder @code{if} nicht
zu @code{true} oder @code{false} ausgewertet werden kann, wird das Verhalten der
Funktionen von der Optionsvariablen @mref{prederror} kontrolliert.  Hat
@code{prederror} den Wert @code{true}, wird von @code{is} und @code{if} ein
Fehler erzeugt.  Hat @code{prederror} den Wert @code{false}, hat @code{is} den
R@"uckgabewert @code{unknown} und @code{if} gibt einen konditionalen Ausdruck
zur@"uck, der teilweise ausgewertet ist.

Die Funktion @code{maybe} verh@"alt sich immer so, als ob @code{prederror} den
Wert @code{false} hat, und die Schleifenanweisungen @code{while} sowie
@code{unless} verhalten sich immer so, als ob @code{prederror} den Wert
@code{true} hat.

Relationale Operatoren werden nicht auf die Elemente von Listen oder Matrizen
sowie auf die beiden Seiten einer Gleichung angewendet.

Siehe auch die Operatoren @mref{=} und @mref{#} sowie die Funktionen
@mref{equal} und @mrefdot{notequal}

Beispiele:

Relationale Ausdr@"ucke werden von einigen Funktionen zu booleschen Werten 
ausgewertet.

@example
(%i1) [x, y, z] : [123, 456, 789];
(%o1)                    [123, 456, 789]
(%i2) is (x < y);
(%o2)                         true
(%i3) maybe (y > z);
(%o3)                         false
(%i4) if x >= z then 1 else 0;
(%o4)                           0
(%i5) block ([S], S : 0, for i:1 while i <= 100 do S : S + i, 
             return (S));
(%o5)                         5050
@end example

Relationale Ausdr@"ucke werden ansonsten nicht zu booleschen Werten ausgewertet 
oder vereinfacht, jedoch werden die Operanden eines relationalen Ausdruckes
ausgewertet.

@example
(%i1) [x, y, z] : [123, 456, 789];
(%o1)                    [123, 456, 789]
(%i2) [x < y, y <= z, z >= y, y > z];
(%o2)    [123 < 456, 456 <= 789, 789 >= 456, 456 > 789]
(%i3) map (is, %);
(%o3)               [true, true, true, false]
@end example
@end deffn

@c -----------------------------------------------------------------------------
@node Logische Operatoren, Operatoren f@"ur Gleichungen, Relationale Operatoren, Operatoren
@section Logische Operatoren
@c -----------------------------------------------------------------------------

@c --- 14.09.2011 DK -----------------------------------------------------------
@anchor{and}
@deffn {Operator} and
@ifinfo
@fnindex Logische Konjunktion
@end ifinfo

Ist der logische Operator der Konjunktion.  @code{and} ist ein 
N-ary-Operator.  Die Operanden sind boolesche Ausdr@"ucke und das Ergebnis ist
ein boolescher Wert.

Der Operator @code{and} erzwingt die Auswertung aller oder einen Teil der
Operanden.  Die Operanden werden in der Reihenfolge ausgewertet, in der sie
auftreten.  @code{and} wertet nur so viele Operanden aus, wie n@"otig sind, um
das Ergebnis des Ausdrucks zu bestimmen.  Hat irgendein Argument den Wert
@code{false}, ist das Ergebnis @code{false} und die weiteren Argumente werden
nicht ausgewertet.

Die Optionsvariable @mref{prederror} kontrolliert das Verhalten von @code{and}
f@"ur den Fall, dass ein Operand nicht zu @code{true} oder @code{false}
ausgewertet werden kann.  @code{and} gibt eine Fehlermeldung aus, wenn 
@code{prederror} den Wert @code{true} hat.  Andernfalls werden Operanden
akzeptiert, die nicht zu @code{true} oder @code{false} ausgewertet werden
k@"onnen und das Ergebnis ist ein boolescher Ausdruck.

@code{and} ist nicht kommutativ, da aufgrund von nicht ausgewerteten Operanden
die Ausdr@"ucke @code{a and b} und @code{b and a} ein unterschiedliches Ergebnis
haben k@"onnen.

Beispiele:

@example
(%i1) n:2;
(%o1)                           2
(%i2) integerp(n) and evenp(n);
(%o2)                         true
(%i3) not(a=b) and 1=1 and integerp(2);
(%o3)                         true
(%i4) not(a=b) and 1=1 and oddp(2);
(%o4)                         false
(%i5) a and b;
(%o5)                        a and b
(%i6) prederror:true$
(%i7) a and b;

Unable to evaluate predicate a
 -- an error. To debug this try: debugmode(true);
@end example

Da @code{and} nur so viele Operanden auswertet wie notwendig sind, um das
Ergebnis festzustellen, f@"uhrt der syntaktische Fehler im zweiten Operanden
nicht zu einer Fehlermeldung, das das Ergebnis bereits mit dem ersten
Operanden feststeht.

@example
(%i8) a=b and sin(2,2);
(%o8)                         false
@end example
@end deffn

@c --- 14.09.2011 DK -----------------------------------------------------------
@anchor{or}
@deffn {Operator} or
@ifinfo
@fnindex Logische Disjunktion
@end ifinfo

Ist der logische Operator der Disjunktion.  @code{or} ist ein N-ary-Operator.
Die Operanden sind boolesche Ausdr@"ucke und das Ergebnis ist ein boolescher
Wert.

Der Operator @code{or} erzwingt die Auswertung aller oder einen Teil der
Operanden.  Die Operanden werden in der Reihenfolge ausgewertet, in der sie
auftreten.  @code{or} wertet nur so viele Operanden aus wie n@"otig sind, um
das Ergebnis des Ausdrucks zu bestimmen.  Hat irgendein Operand den Wert
@code{true}, ist das Ergebnis @code{true} und die weiteren Operanden werden
nicht ausgewertet.

Die Optionsvariable @mref{prederror} kontrolliert das Verhalten von @code{or}
f@"ur den Fall, dass ein Operand nicht zu @code{true} oder @code{false}
ausgewertet werden kann.  @code{or} gibt eine Fehlermeldung, wenn
@code{prederror} den Wert @code{true} hat.  Andernfalls werden Operanden
akzeptiert, die nicht zu @code{true} oder @code{false} ausgewertet werden
k@"onnen und das Ergebnis ist ein boolescher Ausdruck.

@code{or} ist nicht kommutativ, da aufgrund von nicht ausgewerteten Operanden
die Ausdr@"ucke @code{a or b} und @code{b or a} ein unterschiedliches Ergebnis
haben k@"onnen.

Beispiele:

@example
(%i1) n:2;
(%o1)                           2
(%i2) oddp(n) or evenp(n);
(%o2)                         true
(%i3) a=b or not(1=1) or integerp(2);
(%o3)                         true
(%i4) a or b;
(%o4)                        a or b
(%i5) prederror:true$
(%i6) a or b;

Unable to evaluate predicate a
 -- an error. To debug this try: debugmode(true);
@end example

Da @code{or} nur so viele Operanden auswertet wie notwendig sind, um das
Ergebnis festzustellen, f@"uhrt der syntaktische Fehler im zweiten Operanden
nicht zu einer Fehlermeldung, da das Ergebnis bereits mit dem ersten
Operanden feststeht.

@example
(%i7) integerp(2) or sin(2,2);
(%o7)                         true
@end example
@end deffn

@c --- 14.09.2011 DK -----------------------------------------------------------
@anchor{not}
@deffn {Operator} not
@ifinfo
@fnindex Logische Negation
@end ifinfo

Ist die logische Negation.  @code{not} ist ein Prefix-Operator.  Der Operand
ist ein boolescher Ausdruck und das Ergebnis ein boolescher Wert.

Der Operator @code{not} erzwingt die Auswertung des Operanden.  Die
Optionsvariable @mref{prederror} kontrolliert das Verhalten von @code{not} f@"ur
den Fall, dass der Operand nicht zu @code{true} oder @code{false} ausgewertet
werden kann.  @code{not} gibt eine Fehlermeldung, wenn @code{prederror} den Wert
@code{true} hat.  Andernfalls wird ein Operand akzeptiert, der nicht zu
@code{true} oder @code{false} ausgewertet werden kann, und das Ergebnis ist ein
boolescher Ausdruck.

Beispiele:

@example
(%i1) not integerp(2);
(%o1)                         false
(%i2) not (a=b);
(%o2)                         true
(%i3) not a;
(%o3)                         not a
(%i4) prederror:true$
(%i5) not a;

Unable to evaluate predicate a
 -- an error. To debug this try: debugmode(true);
@end example
@end deffn

@c -----------------------------------------------------------------------------
@node Operatoren f@"ur Gleichungen, Zuweisungsoperatoren, Logische Operatoren, Operatoren
@section Operatoren f@"ur Gleichungen
@c -----------------------------------------------------------------------------

@c --- 24.09.2011 DK -----------------------------------------------------------
@anchor{#}
@deffn {Operator} #
@ifinfo
@fnindex  Nicht gleich (Ungleichheit)
@end ifinfo

Ist der Operator f@"ur eine Ungleichung.  @code{#} ist ein Infix-Operator mit
zwei Operanden.

Mit dem Operator @code{#} wird eine Ungleichung @code{a # b} formuliert, wobei
die Operanden @code{a} und @code{b} jeweils die linke und die rechte Seite der
Ungleichung sind und beliebige Ausdr@"ucke sein k@"onnen.  Die Operanden werden
ausgewertet, nicht jedoch die Ungleichung selbst.

Die Funktionen @mrefcomma{is} @mrefcomma{maybe} die logischen Operatoren
@mrefcomma{and} @mref{or} und @mref{not} sowie die Funktionen f@"ur die
Definition von Programmanweisungen wie @mrefcomma{if} @mref{while} oder
@mref{unless} erzwingen die Auswertung einer Ungleichung.

Wegen der Regeln f@"ur die Auswertung von Aussagen und weil @code{not expr} die
Auswertung des Argumentes @code{expr} bewirkt, ist der Ausdruck
@code{not (a = b)} @"aquivalent zu @code{is(a # b)} und nicht zu @code{a # b}.

Die Funktionen @mref{rhs} und @mref{lhs} geben die rechte und die linke Seite
einer Gleichung oder Ungleichung zur@"uck.

Siehe auch den Operator @mrefcomma {=} um eine Gleichung zu formulieren, sowie
die Funktionen @mref{equal} und @mrefdot{notequal}

Beispiele:

@example
(%i1) a = b;
(%o1)                         a = b
(%i2) is (a = b);
(%o2)                         false
(%i3) a # b;
(%o3)                         a # b
(%i4) not (a = b);
(%o4)                         true
(%i5) is (a # b);
(%o5)                         true
(%i6) is (not (a = b));
(%o6)                         true
@end example
@end deffn

@c --- 24.09.2011 DK -----------------------------------------------------------
@need 900
@anchor{=}
@deffn {Operator} =
@ifinfo
@fnindex Operator f@"ur Gleichungen
@fnindex gleich (Gleichheit)
@end ifinfo

Ist der Operator f@"ur eine Gleichung.  @code{=} ist ein Infix-Operator mit
zwei Operanden.

Mit dem Operator @code{=} wird eine Gleichung @code{a = b} formuliert, wobei die
Operanden @code{a} und @code{b} jeweils die linke und die rechte Seite der
Gleichung sind und beliebige Ausdr@"ucke sein k@"onnen.  Die Operanden werden
ausgewertet, nicht jedoch die Gleichung selbst.  Nicht ausgewertete Gleichungen
k@"onnen als Argument von Funktionen wie zum Beispiel den Funktionen
@mrefcomma{solve} @mref{algsys} oder @mref{ev} auftreten.

Die Funktion @mref{is} wertet eine Gleichung @code{=} zu einem booleschen Wert
aus.  @code{is(a = b)} wertet die Gleichung @code{a = b} zum Wert @code{true}
aus, wenn @code{a} und @code{b} identische Ausdr@"ucke sind.  Das trifft zu,
wenn @code{a} und @code{b} identische Atome sind oder wenn ihre Operatoren sowie
die Operanden identisch sind.  In jedem anderen Fall ist das Ergebnis
@code{false}.  Das Ergebnis der Auswertung ist nie @code{unkown}.  Hat
@code{is(a = b)} das Ergebnis @code{true}, werden @code{a} und @code{b} als
syntaktisch gleich bezeichnet.  Im Unterschied dazu gilt f@"ur @"aquivalente
Ausdr@"ucke, dass @code{is(equal(a, b))} den Wert @code{true} hat.  Ausdr@"ucke
k@"onnen @"aquivalent aber syntaktisch verschieden sein.

Eine Ungleichung wird mit dem Operator @mref{#} formuliert.  Wie f@"ur den
Operator @code{=} f@"ur eine Gleichung wird eine Ungleichung @code{a # b} nicht
ausgewertet.  Eine Auswertung erfolgt mit @code{is(a # b)}, welche die Werte
@code{true} oder @code{false} als Ergebnis hat.

Neben @code{is} werten auch die Operatoren @mrefcomma{if} @mrefcomma{and}@w{}
@mref{or} und @mref{not} Gleichungen mit dem Operator @code{=} oder
Ungleichungen mit dem Operator @code{#} zu den Werten @code{true} oder
@code{false} aus.

Wegen der Regeln f@"ur die Auswertung von Aussagen und weil im Ausdruck
@code{not expr} der Operand @code{expr} ausgewertet wird, ist
@code{not a = b} @"aquivalent zu @code{is(a # b)} und nicht zu @code{a # b}.

Die Funktionen @mref{rhs} und @mref{lhs} geben die rechte und die linke Seite
einer Gleichung oder Ungleichung zur@"uck.

Siehe auch den Operator @mref{#} f@"ur Ungleichungen sowie die Funktionen
@mref{equal} und @mrefdot{notequal}

Beispiele:

Ein Ausdruck @code{a = b} repr@"asentiert eine nicht ausgewertete Gleichung.

@example
(%i1) eq_1 : a * x - 5 * y = 17;
(%o1)                    a x - 5 y = 17
(%i2) eq_2 : b * x + 3 * y = 29;
(%o2)                    3 y + b x = 29
(%i3) solve ([eq_1, eq_2], [x, y]);
                        196         29 a - 17 b
(%o3)          [[x = ---------, y = -----------]]
                     5 b + 3 a       5 b + 3 a
(%i4) subst (%, [eq_1, eq_2]);
         196 a     5 (29 a - 17 b)
(%o4) [--------- - --------------- = 17, 
       5 b + 3 a      5 b + 3 a
                                  196 b     3 (29 a - 17 b)
                                --------- + --------------- = 29]
                                5 b + 3 a      5 b + 3 a
(%i5) ratsimp (%);
(%o5)                  [17 = 17, 29 = 29]
@end example

@code{is(a = b)} wertet die Gleichung @code{a = b} zu @code{true} aus, wenn
@code{a} und @code{b} syntaktisch gleich sind.  Ausdr@"ucke k@"onnen
@"aquivalent sein, ohne syntaktisch gleich zu sein.

@example
(%i1) a : (x + 1) * (x - 1);
(%o1)                    (x - 1) (x + 1)
(%i2) b : x^2 - 1;
                              2
(%o2)                        x  - 1
(%i3) [is (a = b), is (a # b)];
(%o3)                     [false, true]
(%i4) [is (equal (a, b)), is (notequal (a, b))];
(%o4)                     [true, false]
@end example

Einige Operatoren werten @code{=} und @code{#} zu @code{true} oder @code{false}
aus.

@example
(%i1) if expand ((x + y)^2) = x^2 + 2 * x * y + y^2 then FOO else
      BAR;
(%o1)                          FOO
(%i2) eq_3 : 2 * x = 3 * x;
(%o2)                       2 x = 3 x
(%i3) eq_4 : exp (2) = %e^2;
                              2     2
(%o3)                       %e  = %e
(%i4) [eq_3 and eq_4, eq_3 or eq_4, not eq_3];
(%o4)                  [false, true, true]
@end example

Da @code{not expr} die Auswertung des Ausdrucks @code{expr} bewirkt, ist
@code{not (a = b)} @"aquivalent zu @code{is(a # b)}.

@example
(%i1) [2 * x # 3 * x, not (2 * x = 3 * x)];
(%o1)                   [2 x # 3 x, true]
(%i2) is (2 * x # 3 * x);
(%o2)                         true
@end example
@end deffn

@c -----------------------------------------------------------------------------
@node Zuweisungsoperatoren, Nutzerdefinierte Operatoren, Operatoren f@"ur Gleichungen, Operatoren
@section Zuweisungsoperatoren
@c -----------------------------------------------------------------------------

@c --- 17.10.2010 DK -----------------------------------------------------------
@anchor{:}
@deffn {Operator} :
@ifinfo
@fnindex Zuweisungsoperator
@end ifinfo

Ist der Operator f@"ur die Zuweisung eines Wertes an eine Variable.

Ist die linke Seite eine Variable (ohne Index), wertet der Operator @code{:} die
rechte Seite aus und weist den Wert der Variablen auf der linken Seite zu.

Ist die linke Seite ein Element einer Liste, Matrix oder ein deklariertes 
Maxima- oder Lisp-Array, wird die rechte Seite diesem Element zugewiesen.  Der 
Index muss ein existierendes Element bezeichnen.

Ist die linke Seite ein Element eines nicht deklarierten Arrays, dann wird
die rechte Seite diesem Element zugewiesen, falls dieses existiert.  Existiert 
das Element noch nicht, wird ein neues Element erzeugt.

Ist die linke Seite eine Liste mit Variablen (ohne Index), muss die rechte Seite
zu einer Liste auswerten.  Die Elemente der Liste auf der rechten Seite werden 
den Elementen auf der linken Seite parallel zugewiesen.

Siehe auch @mref{kill} und @mref{remvalue} f@"ur die Aufhebung der Zuweisung
eines Wertes an ein Symbol.

Beispiele:

Zuweisung an eine einfache Variable.

@example
(%i1) a;
(%o1)                           a
(%i2) a : 123;
(%o2)                          123
(%i3) a;
(%o3)                          123
@end example

Zuweisung an ein Element einer Liste.

@example
(%i1) b : [1, 2, 3];
(%o1)                       [1, 2, 3]
(%i2) b[3] : 456;
(%o2)                          456
(%i3) b;
(%o3)                      [1, 2, 456]
@end example

Die Zuweisung erzeugt ein nicht deklariertes Array.

@example
(%i1) c[99] : 789;
(%o1)                          789
(%i2) c[99];
(%o2)                          789
(%i3) c;
(%o3)                           c
(%i4) arrayinfo (c);
(%o4)                   [hashed, 1, [99]]
(%i5) listarray (c);
(%o5)                         [789]
@end example

Mehrfache Zuweisung.

@example
(%i1) [a, b, c] : [45, 67, 89];
(%o1)                     [45, 67, 89]
(%i2) a;
(%o2)                          45
(%i3) b;
(%o3)                          67
(%i4) c;
(%o4)                          89
@end example

Die mehrfache Zuweisung wird parallel ausgef@"uhrt.  Die Werte von @code{a} und
@code{b} werden in diesem Beispiel ausgetauscht.

@example
(%i1) [a, b] : [33, 55];
(%o1)                       [33, 55]
(%i2) [a, b] : [b, a];
(%o2)                       [55, 33]
(%i3) a;
(%o3)                          55
(%i4) b;
(%o4)                          33
@end example
@end deffn

@c --- 17.10.2010 DK -----------------------------------------------------------
@anchor{::}
@deffn {Operator} ::
@ifinfo
@fnindex Zuweisungsoperator (wertet die linke Seite aus)
@end ifinfo

Ist der Operator f@"ur die Zuweisung eines Wertes an eine Variable.

Der Operator @code{::} ist vergleichbar mit dem Operator @mref{:} mit dem
Unterschied, dass @code{::} sowohl die rechte als auch die linke Seite
auswertet.

Beispiele:

@example
(%i1) x : 'foo;
(%o1)                          foo
(%i2) x :: 123;
(%o2)                          123
(%i3) foo;
(%o3)                          123
(%i4) x : '[a, b, c];
(%o4)                       [a, b, c]
(%i5) x :: [11, 22, 33];
(%o5)                     [11, 22, 33]
(%i6) a;
(%o6)                          11
(%i7) b;
(%o7)                          22
(%i8) c;
(%o8)                          33
@end example
@end deffn

@c --- 17.10.2010 DK -----------------------------------------------------------
@anchor{::=}
@deffn {Operator} ::=
@ifinfo
@fnindex Operator f@"ur Makrodefinitionen
@end ifinfo

Ist der Operator f@"ur die Definition von Makro-Funktionen.

Der Operator @code{::=} definiert eine Makro-Funktion, das ist eine Funktion,
die ihre Argumente nicht auswertet.  Der Ausdruck, der die Makro-Funktion
definiert, wird in dem Kontext ausgewertet, in dem das Makro aufgerufen wird.
Ansonsten verh@"alt sich eine Makro-Funktion wie eine gew@"ohnliche Funktion.

Die Funktion @mref{macroexpand} expandiert eine Makro-Funktion, ohne sie
auszuwerten.  @code{macroexpand(foo(x))} dem @code{''%} folgt, ist @"aquivalent
zu @code{foo(x)}, wenn @code{foo} eine Makro-Funktion ist.

Der Operator @code{::=} f@"ugt den Namen der neuen Makro-Funktion der 
Informationsliste @mref{macros} hinzu.  Die Funktionen @mrefcomma{kill}@w{}
@mref{remove} und @mref{remfunction} heben die Zuweisung der Makro-Funktion an
ein Symbol auf und entfernen die Makro-Funktion von der Informationsliste
@code{macros}.

Die Funktionen @mref{fundef} oder @mref{dispfun} geben die Definition einer
Makro-Funktion zur@"uck oder weisen die Makro-Funktion einer Marke zu.

Makro-Funktionen enthalten h@"aufig Ausdr@"ucke mit den Funktionen
@mref{buildq} und @mrefdot{splice}  Mit diesen werden Ausdr@"ucke konstruiert,
die dann ausgewertet werden.

@need 800
Beispiele:

Eine Makro-Funktion wertet ihre Argumente nicht aus.  Daher zeigt Beispiel (1)
@code{y - z} und nicht den Wert von @code{y - z}.  Das Makro wird in 
dem Kontext ausgewertet, in dem das Makro aufgerufen wird.  Dies zeigt (2).

@example
(%i1) x: %pi$

(%i2) y: 1234$

(%i3) z: 1729 * w$

(%i4) printq1 (x) ::= block (print ("(1) x is equal to", x),
      '(print ("(2) x is equal to", x)))$

(%i5) printq1 (y - z);
(1) x is equal to y - z
(2) x is equal to %pi
(%o5)                                 %pi
@end example

Eine gew@"ohnliche Funktion wertet ihre Argumente aus.  Daher zeigt (1) den Wert 
von @code{y - z}.  Der R@"uckgabewert wird nicht ausgewertet und gibt (2).  Mit
@code{''%} wird die Auswertung erzwungen.

@example
(%i1) x: %pi$

(%i2) y: 1234$

(%i3) z: 1729 * w$

(%i4) printe1 (x) := block (print ("(1) x is equal to", x),
      '(print ("(2) x is equal to", x)))$

(%i5) printe1 (y - z);
(1) x is equal to 1234 - 1729 w
(%o5)                     print((2) x is equal to, x)
(%i6) ''%;
(2) x is equal to %pi
(%o6)                                 %pi
@end example

@mref{macroexpand} gibt die Expansion des Makros zur@"uck.
@code{macroexpand(foo(x))} dem @code{''%} folgt, ist @"aquivalent zu 
@code{foo(x)}, wenn @code{foo} eine Makro-Funktion ist.

@example
(%i1) x: %pi$

(%i2) y: 1234$

(%i3) z: 1729 * w$

(%i4) g (x) ::= buildq ([x], print ("x is equal to", x))$

(%i5) macroexpand (g (y - z));
(%o5)                     print(x is equal to, y - z)
(%i6) ''%;
x is equal to 1234 - 1729 w
(%o6)                            1234 - 1729 w
(%i7) g (y - z);
x is equal to 1234 - 1729 w
(%o7)                            1234 - 1729 w
@end example
@end deffn

@c --- 09.10.2010 DK -----------------------------------------------------------
@anchor{:=}
@deffn {Operator} :=
@ifinfo
@fnindex Operator f@"ur Funktionsdefinitionen
@end ifinfo

Ist der Operator f@"ur Funktionsdefinitionen.

@code{@var{f}(@var{x_1}, ..., @var{x_n})} := @var{expr} definiert eine Funktion
mit dem Namen @var{f}, den Argumenten @var{x_1}, @dots{}, @var{x_n} und der
Funktionsdefinition @var{expr}.  Der Operator @code{:=} wertet die 
Funktionsdefinition nicht aus.  Die Auswertung kann mit dem
@nxref{'', Quote-Quote-Operator} @code{''} erzwungen werden.  Die definierte
Funktion kann eine gew@"ohnliche Maxima-Funktion @code{f(x)} sein oder eine
Array-Funktion @code{f[i](x)}.

Ist das letzte oder das einzige Argument der Funktion @var{x_n} eine Liste mit
einem Element, dann akzeptiert die mit @code{:=} definierte Funktion eine
variable Anzahl an Argumenten.  Die Argumente werden zun@"achst nacheinander den
Argumenten @var{x_1}, @dots{}, @var{x_(n - 1)} zugewiesen.  Sind weitere
Argumente vorhanden, werden diese @var{x_n} als Liste zugewiesen.

Funktionsdefinitionen erscheinen im globalen Namensraum.  Wird eine Funktion
@code{f} innerhalb einer Funktion @code{g} definiert, wird die Reichweite der
Funktion nicht automatisch auf @code{g} beschr@"ankt.  Dagegen f@"uhrt
@code{local(f)} zu einer Definition, die nur innerhalb eines Blockes oder einem
anderen zusammengesetzten Ausdr@"uck erscheint.  Siehe auch @mrefdot{local}

Ist eines der Argumente ein Symbol auf das der @nxref{', Quote-Operator}@w{}
@code{'} angewendet wurde, wird dieses Argument nicht ausgewertet.  Ansonsten
werden alle Argumente ausgewertet.

Siehe auch @mref{define} und @mrefdot{::=}

Beispiele:

@code{:=} wertet die Funktionsdefinition nie aus, au@ss{}er wenn der
Quote-Quote-Operator angewendet wird.

@example
(%i1) expr : cos(y) - sin(x);
(%o1)                    cos(y) - sin(x)
(%i2) F1 (x, y) := expr;
(%o2)                   F1(x, y) := expr
(%i3) F1 (a, b);
(%o3)                    cos(y) - sin(x)
(%i4) F2 (x, y) := ''expr;
(%o4)              F2(x, y) := cos(y) - sin(x)
(%i5) F2 (a, b);
(%o5)                    cos(b) - sin(a)
@end example

Mit dem Operator @code{:=} definierte Funktionen k@"onnen eine gew@"ohnliche
Maxima-Funktion oder eine Array-Funktion sein.

@example
(%i1) G1 (x, y) := x.y - y.x;
(%o1)               G1(x, y) := x . y - y . x
(%i2) G2 [x, y] := x.y - y.x;
(%o2)                G2     := x . y - y . x
                       x, y
@end example

Ist das letzte oder einzige Argument @var{x_n} eine Liste mit einem Element,
dann akzeptiert die Funktion eine variable Anzahl an Argumenten.

@example
(%i1) H ([L]) := apply ("+", L);
(%o1)                H([L]) := apply("+", L)
(%i2) H (a, b, c);
(%o2)                       c + b + a
@end example

@mref{local} erzeugt eine lokale Funktionsdefinition.

@example
(%i1) foo (x) := 1 - x;
(%o1)                    foo(x) := 1 - x
(%i2) foo (100);
(%o2)                         - 99
(%i3) block (local (foo), foo (x) := 2 * x, foo (100));
(%o3)                          200
(%i4) foo (100);
(%o4)                         - 99
@end example
@end deffn

@c -----------------------------------------------------------------------------
@node Nutzerdefinierte Operatoren, , Zuweisungsoperatoren, Operatoren
@section Nutzerdefinierte Operatoren
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in nutzerdefinierte Operatoren::
* Funktionen und Variablen f@"ur nutzerdefinierte Operatoren::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in nutzerdefinierte Operatoren, Funktionen und Variablen f@"ur nutzerdefinierte Operatoren, Nutzerdefinierte Operatoren, Nutzerdefinierte Operatoren
@subsection Einf@"uhrung in nutzerdefinierte Operatoren
@c -----------------------------------------------------------------------------

Es ist m@"oglich neue Operatoren zu definieren, vorhandene Operatoren zu
entfernen oder deren Eigenschaften zu @"andern.  Jede Funktion kann als ein
Operator definiert werden, die Funktion kann, muss aber nicht definiert sein.

Im Folgenden werden die Operatoren @code{dd} und @code{"<-"} definiert.  Nach
der Definition als Operatoren ist @code{dd a} gleichbedeutend mit @code{"dd"(a)}
und @code{a <- b} entspricht dem Funktionsaufruf @code{"<-"(a,b)}.  In diesem
Beispiel sind die Funktionen @code{"dd"} und @code{"<-"} nicht definiert.

@example
(%i1) prefix ("dd");
(%o1)                          dd
(%i2) dd a;
(%o2)                         dd a
(%i3) "dd" (a);
(%o3)                         dd a
(%i4) infix ("<-");
(%o4)                          <-
(%i5) a <- dd b;
(%o5)                      a <- dd b
(%i6) "<-" (a, "dd" (b));
(%o6)                      a <- dd b
@end example

Maxima kennt die folgenden Funktionen, um Operatoren zu definieren:
@code{prefix}, @code{postfix}, @code{infix}, @code{nary}, @code{matchfix} und
@code{nofix}.

Der Vorrang eines Operators @var{op} vor anderen Operatoren leitet sich aus dem
links- und rechtsseitigen Vorrang des Operators ab.  Sind die links- und
rechtsseitigen Vorr@"ange von @var{op} beide gr@"o@ss{}er als der links-
und rechtsseitige Vorrang eines anderen Operators, dann hat @var{op} 
Vorrang vor diesem Operator.  Sind die Vorr@"ange nicht beide gr@"o@ss{}er oder
kleiner, werden weitere Regeln zur Bestimmung des Vorrangs herangezogen.

Maxima kennt die Wortart eines Operanden und des Ergebnisses eines Operanden.
Wortart bedeutet hier, den Typ eines Operanden.  Maxima kennt die drei Typen
@code{expr}, @code{clause} und @code{any}.  Diese stehen f@"ur einen
algebraischen Ausdruck, einen logischen Ausdruck und einen beliebigen Ausdruck.
Mit Hilfe der f@"ur einen Operator definierten Wortart kann der Parser beim 
Einlesen eines Ausdrucks Syntaxfehler feststellen.

Die Assoziativit@"at eines Operators @var{op} h@"angt ab von seinem Vorrang.
Ein gr@"o@ss{}erer linksseitiger Vorrang hat zur Folge, dass der Operator
@var{op} vor einem anderen Operator auf seiner linken Seite ausgewertet wird.
W@"ahrend ein gr@"o@ss{}erer rechtsseitiger Vorrang zur Folge hat, dass der
Operator vor anderen Operatoren auf der rechten Seite ausgewertet wird.  Daraus
folgt, dass ein gr@"o@ss{}erer linksseitiger Vorrang @var{lbp} einen Operator
@var{op} rechts-assoziativ und eine gr@"o@ss{}erer rechtsseitiger Vorrang
@var{rbp} den Operator links-assoziativ macht.  Sind der links- und
rechtsseitige Vorrang gleich gro@ss{}, ist der Operator @var{op}
links-assoziativ.

Mit den Befehlen @mref{remove} und @mref{kill} k@"onnen Operatoreigenschaften
von einem Symbol entfernt werden.  @code{remove("@var{a}", op)} entfernt
die Operatoreigenschaften des Symbols @var{a}.  @code{kill("@var{a}")} entfernt
alle Eigenschaften einschlie@ss{}ich der Operator-Eigenschaften des Symbols 
@var{a}.  In diesem Fall steht der Name des Symbols in Anf@"uhrungszeichen.

@example
(%i1) infix ("##");
(%o1)                          ##
(%i2) "##" (a, b) := a^b;
                                     b
(%o2)                     a ## b := a
(%i3) 5 ## 3;
(%o3)                          125
(%i4) remove ("##", op);
(%o4)                         done
(%i5) 5 ## 3;
Incorrect syntax: # is not a prefix operator
5 ##
  ^
(%i5) "##" (5, 3);
(%o5)                          125
(%i6) infix ("##");
(%o6)                          ##
(%i7) 5 ## 3;
(%o7)                          125
(%i8) kill ("##");
(%o8)                         done
(%i9) 5 ## 3;
Incorrect syntax: # is not a prefix operator
5 ##
  ^
(%i9) "##" (5, 3);
(%o9)                       ##(5, 3)
@end example

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur nutzerdefinierte Operatoren, , Einf@"uhrung in nutzerdefinierte Operatoren, Nutzerdefinierte Operatoren
@subsection Funktionen und Variablen f@"ur nutzerdefinierte Operatoren
@c -----------------------------------------------------------------------------

@c --- 04.05.2011 DK -----------------------------------------------------------
@anchor{infix}
@deffn  {Funktion} infix (@var{op})
@deffnx {Funktion} infix (@var{op}, @var{lbp}, @var{rbp})
@deffnx {Funktion} infix (@var{op}, @var{lbp}, @var{rbp}, @var{lpos}, @var{rpos}, @var{pos})

Deklariert @var{op} als einen Infix-Operator.  Ein Infix-Operator hat eine 
Funktionsdefinition mit zwei Argumenten.  Der Infix-Operator steht zwischen den
Operanden.  Zum Beispiel ist die Subtraktion @mref{-} ein Infix-Operator.

@code{infix(@var{op})} deklariert @var{op} als einen Infix-Operator mit einem
links- und rechtsseitigen Vorrang von jeweils 180.

@code{infix(@var{op}, @var{lbp}, @var{rbp})} deklariert @var{op} als einen
Infix-Operator mit den angegebenen Werten f@"ur den links- und rechtsseitigen
Vorrang.

@code{infix(@var{op}, @var{lbp}, @var{rbp}, @var{lpos}, @var{rpos}, @var{pos})}
deklariert @var{op} als einen Infix-Operator mit den angegebenen
Vorr@"angen sowie den Wortarten @var{lpos}, @var{rpos} und @var{pos} f@"ur
den linken und den rechten Operanden sowie das Ergebnis des Operators.

Beispiele:

Sind die rechtsseitigen und linksseitigen Vorr@"ange eines Operators
@var{op} gr@"o@ss{}er als die entsprechenden Vorr@"ange eines anderen
Operators, dann hat der Operator @var{op} Vorrang.

@example
(%i1) :lisp (get '$+ 'lbp)
100
(%i1) :lisp (get '$+ 'rbp)
100
(%i1) infix ("##", 101, 101);
(%o1)                          ##
(%i2) "##"(a, b) := sconcat("(", a, ",", b, ")");
(%o2)       (a ## b) := sconcat("(", a, ",", b, ")")
(%i3) 1 + a ## b + 2;
(%o3)                       (a,b) + 3
(%i4) infix ("##", 99, 99);
(%o4)                          ##
(%i5) 1 + a ## b + 2;
(%o5)                       (a+1,b+2)
@end example

Ein gr@"o@ss{}erer linksseitige Vorrang @var{lbp} bewirkt, dass der
Operator @var{op} rechts-assoziativ ist.  Ein gr@"o@ss{}erer rechtsseitiger
Vorrang macht dagegen den Operator @var{op} links-as@-so@-zia@-tiv.

@example
(%i1) infix ("##", 100, 99);
(%o1)                          ##
(%i2) "##"(a, b) := sconcat("(", a, ",", b, ")")$
(%i3) foo ## bar ## baz;
(%o3)                    (foo,(bar,baz))
(%i4) infix ("##", 100, 101);
(%o4)                          ##
(%i5) foo ## bar ## baz;
(%o5)                    ((foo,bar),baz)
@end example

Maxima kann Syntaxfehler beim Einlesen eines Ausdrucks feststellen, wenn der
eingelesene Operand nicht die f@"ur den Operator definierte Wortart hat.

@example
(%i1) infix ("##", 100, 99, expr, expr, expr);
(%o1)                          ##
(%i2) if x ## y then 1 else 0;
Incorrect syntax: Found algebraic expression where 
logical expression expected
if x ## y then 
             ^
(%i2) infix ("##", 100, 99, expr, expr, clause);
(%o2)                          ##
(%i3) if x ## y then 1 else 0;
(%o3)                if x ## y then 1 else 0
@end example
@end deffn

@c --- 04.05.2011 DK -----------------------------------------------------------
@anchor{matchfix}
@deffn  {Funktion} matchfix (@var{ldelimiter}, @var{rdelimiter})
@deffnx {Funktion} matchfix (@var{ldelimiter}, @var{rdelimiter}, @var{arg_pos}, @var{pos})

Deklariert einen Matchfix-Operator mit dem linksseitigen Begrenzungszeichen 
@var{ldelimiter} und dem rechtsseitigen Begrenzungszeichen @var{rdelimiter}.

Ein Matchfix-Operator hat eine beliebige Anzahl an Argumenten, die zwischen
dem linksseitigen und dem rechtsseitigen Begrenzungszeichen stehen.  Das
Begrenzungszeichen kann eine beliebige Zeichenkette sein.  Einige Zeichen wie
@code{%}, @code{,}, @code{$} und @code{;} k@"onnen nicht als Begrenzungszeichen
definiert werden.

Ein linksseitiges Begrenzungszeichen kann nicht verschiedene rechtsseitige
Begrenzungszeichen haben.

Maxima-Operatoren k@"onnen als Matchfix-Operatoren definiert werden, ohne 
dass sich die sonstigen Operatoreigenschaften @"andern.  So kann zum Beispiel
der Operator @code{+} als Matchfix-Operator definiert werden.

@code{matchfix(@var{ldelimiter}, @var{rdelimiter}, @var{arg_pos}, @var{pos})}
definiert die Wortarten f@"ur die Argumente @var{arg_pos} und das Ergebnis
@var{pos} sowie das linksseitige @var{ldelimiter} und rechtsseitige
@var{rdelimiter} Begrenzungszeichen.

Die zu einem Matchfix-Operator zugeh@"orige Funktion kann jede 
nutzerdefinierte Funktion sein, die mit @mref{:=} oder @mref{define} definiert
wird.  Die Definition der Funktion kann mit @code{dispfun(@var{ldelimiter})} 
ausgegeben werden.

Maxima kennt nur den Operator f@"ur Listen @code{[ ]} als Matchfix-Operator.
Klammern @code{( )} und Anf@"uhrungszeichen @code{" "} arbeiten wie 
Matchfix-Operatoren, werden aber vom Parser nicht als Matchfix-Operatoren 
behandelt.

@mref{matchfix} wertet die Argumente aus.  @code{matchfix} gibt das erste
Argument @var{ldelimiter} als Ergebnis zur@"uck.

Beispiele:

Begrenzungszeichen k@"onnen eine beliebige Zeichenkette sein.

@example
(%i1) matchfix ("@@@@", "~");
(%o1)                          @@@@
(%i2) @@@@ a, b, c ~;
(%o2)                      @@@@a, b, c~
(%i3) matchfix (">>", "<<");
(%o3)                          >>
(%i4) >> a, b, c <<;
(%o4)                      >>a, b, c<<
(%i5) matchfix ("foo", "oof");
(%o5)                          foo
(%i6) foo a, b, c oof;
(%o6)                     fooa, b, coof
(%i7) >> w + foo x, y oof + z << / @@@@ p, q ~;
                     >>z + foox, yoof + w<<
(%o7)                ----------------------
                            @@@@p, q~
@end example

Matchfix-Operatoren k@"onnen f@"ur nutzerdefinierte Funktionen definiert 
werden.

@example
(%i1) matchfix ("!-", "-!");
(%o1)                         "!-"
(%i2) !- x, y -! := x/y - y/x;
                                    x   y
(%o2)                   !-x, y-! := - - -
                                    y   x
(%i3) define (!-x, y-!, x/y - y/x);
                                    x   y
(%o3)                   !-x, y-! := - - -
                                    y   x
(%i4) define ("!-" (x, y), x/y - y/x);
                                    x   y
(%o4)                   !-x, y-! := - - -
                                    y   x
(%i5) dispfun ("!-");
                                    x   y
(%t5)                   !-x, y-! := - - -
                                    y   x

(%o5)                         done
(%i6) !-3, 5-!;
                                16
(%o6)                         - --
                                15
(%i7) "!-" (3, 5);
                                16
(%o7)                         - --
                                15
@end example
@end deffn

@c --- 04.05.2011 DK -----------------------------------------------------------
@anchor{nary}
@deffn  {Funktion} nary (@var{op})
@deffnx {Funktion} nary (@var{op}, @var{bp}, @var{arg_pos}, @var{pos})

@code{nary(@var{op})} definiert einen @code{N-ary}-Operator @var{op} mit einem
linksseitigen Vorrang von 180.  Der rechtsseitige Vorrang wird nicht ben@"otigt.

@code{nary(@var{op}, @var{bp}, @var{arg_pos}, @var{pos})} definiert einen
@code{N-ary}-Operator @var{op} mit einem rechtsseitigen Vorrang von @var{bp} und
der Wortart @var{arg_pos} f@"ur den Operanden und der Wortart @var{pos} fr das
Ergebnis.

Ein @code{N-ary}-Operator ist ein Operator, der eine beliebige Anzahl an 
Argumenten haben kann.  Die Argumente werden durch den Operator voneinander 
getrennt, so ist zum Beispiel @code{+} ein @code{N-ary}-Operator und 
@code{A+B+C}.

Im Unterschied zur Definition eines Operators kann eine Funktion @code{f} auch
als @mref{nary} mit der Funktion @mref{declare} deklariert werden.  Die
Deklaration hat Auswirkung auf die Vereinfachung der Funktion.  Zum Beispiel
wird ein Ausdruck @code{j(j(a,b),j(c,d)} zu @code{j(a,b,c,d)} vereinfacht.
@end deffn

@c --- 04.05.2011 DK -----------------------------------------------------------
@anchor{nofix}
@deffn  {Funktion} nofix (@var{op})
@deffnx {Funktion} nofix (@var{op}, @var{pos})

@code{nofix(@var{op})} definiert den Operator @var{op} als einen Nofix-Operator.

@code{nofix(@var{op}, @var{pos})} definiert einen Nofix-Operator mit der
Wortart @var{pos} f@"ur das Ergebnis.

Nofix-Operatoren sind Operatoren, die kein Argument haben.  Tritt ein solcher 
Operator allein auf, wird die dazugeh@"orige Funktion ausgewertet.  Zum Beispiel
beendet die Funktion @code{quit()} eine Maxima-Sitzung.  Wird diese Funktion 
mit @code{nofix("quit")} als ein Nofix-Operator definiert, gen@"ugt die
Eingabe von @code{quit}, um eine Maxima-Sitzung zu beenden.
@end deffn

@c --- 04.05.2011 DK -----------------------------------------------------------
@anchor{postfix}
@deffn  {Funktion} postfix (@var{op})
@deffnx {Funktion} postfix (@var{op}, @var{lbp}, @var{lpos}, @var{pos})

@code{postfix (@var{op})} definiert einen Postfix-Operator @var{op}.

@code{postfix (@var{op}, @var{lbp}, @var{lpos}, @var{pos})} definiert einen
Postfix-Operator @var{op} mit einem linksseitigem Vorrang von @var{lbp} sowie
den Wortarten @var{lpos} f@"ur den Operanden und @var{pos} f@"ur das Ergebnis.

Ein Postfix-Operator hat einen Operanden, der dem Operator vorangestellt ist.
Ein Beispiel ist der @code{!}-Operator mit @code{3!}.  Die Funktion
@code{postfix("x")} erweitert die Maxima-Syntax um den Postfix-Operator 
@code{x}.
@end deffn

@c --- 04.05.2011 DK -----------------------------------------------------------
@anchor{prefix}
@deffn  {Funktion} prefix (@var{op})
@deffnx {Funktion} prefix (@var{op}, @var{rbp}, @var{rpos}, @var{pos})

@code{prefix (@var{op})} definiert einen Prefix-Operator @var{op}.

@code{prefix (@var{op}, @var{lbp}, @var{lpos}, @var{pos})} definiert einen
Prefix-Operator @var{op} mit einem rechtsseitigem Vorrang von @var{rbp} sowie
den Wortarten @var{rpos} f@"ur den Operanden und @var{pos} f@"ur das Ergebnis.

Ein Prefix-Operator hat einen Operanden, der dem Operator nachfolgt.  Mit
@code{prefix("x")} wird die Maxima-Syntax um einen Prefix-Operator @code{x}
erweitert.
@end deffn

@c --- End of file Operators.de.texi -------------------------------------------

