@c -----------------------------------------------------------------------------
@c File        : Program.de.texi
@c License     : GNU General Public License (GPL)
@c Language    : German
@c Original    : Program.texi revision 25.07.2011
@c Translation : Dr. Dieter Kaiser
@c Date        : 14.11.2010
@c Revision    : 10.12.2011
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@menu
* Lisp und Maxima::
* Einf@"uhrung in die Programmierung::
* Funktionen und Variablen der Programmierung::
@end menu

@c -----------------------------------------------------------------------------
@node Lisp und Maxima, Einf@"uhrung in die Programmierung, Programmierung, Programmierung
@section Lisp und Maxima
@c -----------------------------------------------------------------------------

@subheading Lisp- und Maxima-Bezeichner

Maxima ist in Lisp programmiert.  Es ist einfach, Lisp-Funktionen und
Lisp-Variable in Maxima zu verwenden.  Umgekehrt k@"onnen Maxima-Funktionen und
Maxima-Variablen in Lisp verwendet werden.  Ein Lisp-Symbol, das mit einem 
Dollarzeichen @code{$} beginnt, entspricht einem Maxima-Symbol ohne einem 
Dollarzeichen.  Umgekehrt entspricht einem Maxima-Symbol, das mit einem 
Fragezeichen @code{?} beginnt, ein Lisp-Symbol ohne das Fragezeichen.
Zum Beispiel entspricht dem Maxima-Symbol @code{foo} das Lisp-Symbol 
@code{$foo} und dem Maxima-Symbol @code{?foo} entspricht das Lisp-Symbol
@code{foo}.

Speziellen Zeichen wie einem Trennstrich @code{-} oder einem Stern @code{*} in
Lisp-Symbolen muss ein Backslash @code{\} vorangestellt werden, um diese
in Maxima zu verwenden.  Zum Beispiel entspricht dem Lisp-Symbol 
@code{*foo-bar*} das Maxima-Symbol @code{?\*foo\-bar\*}.

Im Gegensatz zu Lisp unterscheidet Maxima Gro@ss{}- und Kleinschreibung.  Es 
gibt einige Regeln, die eine @"Ubersetzung von Namen zwischen Lisp und Maxima 
betreffen:

@enumerate
@item
Ein Lisp-Bezeichner, der nicht von senkrechten Strichen eingeschlossen ist,
entspricht einem klein geschriebenen Maxima-Bezeichner.  Die Schreibweise des
Lisp-Bezeichners wird dabei ignoriert.  Zum Beispiel entspricht den folgenden
Lisp-Bezeichnern @code{$foo}, @code{$FOO} und @code{$Foo} jeweils der
Maxima-Bezeichner @code{foo}.

@item
Ein Lisp-Bezeichner, der vollst@"andig gro@ss{} oder klein geschrieben ist und 
von senkrechten Strichen eingeschlossen wird, entspricht einem Maxima-Bezeichner
in der umgekehrten Schreibweise.  Ein klein geschriebener Lisp-Bezeichner wird 
also zu einem gro@ss{}geschriebenen Maxima-Bezeichner und umgekehrt.  Zum 
Beispiel entsprechen den Lisp-Bezeichnern @code{|$FOO|} und @code{|$foo|} die
Maxima-Bezeichner @code{foo} und @code{FOO}.

@item
Ein Lisp-Bezeichner in gemischter Schreibweise, der von senkrechten Strichen
eingeschlossen ist, entspricht einem Maxima-Bezeichner in der gleichen
Schreibweise.  Zum Beispiel entspricht dem Lisp-Bezeichner @code{|$Foo|} der
Maxima-Bezeichner @code{Foo}.
@end enumerate

F@"ur die Syntax von Maxima-Bezeichnern siehe auch @ref{Bezeichner}.

@subheading Ausf@"uhrung von Lisp-Code in Maxima

Lisp-Code kann mit dem Unterbrechungskommando @code{:lisp} von einer
Maxima-Kom@-man@-do@-zei@-le ausgef@"uhrt werden.  Siehe
@ref{Debugger-Kommandos} f@"ur weitere Unterbrechungskommandos und deren
Beschreibung.

Beispiele:

Addiere die Werte der Maxima-Variablen @code{x} und @code{y} mit dem 
Lisp-Operator @code{+}.

@example
(%i1) x:10$ y:5$
(%i3) :lisp (+ $x $y)
15
@end example

Addiere die Symbole @code{a} und @code{b} mit der Lisp-Funktion @code{ADD}.  Das
Ergebnis wird der Variablen @code{$RES} zugewiesen.  Die Variable hat in Maxima
den Namen @code{res}.

@example
(%i3) :lisp (setq $res (add '$a '$b))
((MPLUS SIMP) $A $B)
(%i3) res;
(%o3)                         b + a
@end example

Das @code{:lisp}-Kommando ist n@"utzlich, um zum Beispiel Lisp-Eigenschaften
von Maxima-Symbolen anzuzeigen, globale Lisp-Variablen wie
@code{*PRINT-CIRCLE*} zu setzen oder wie im letzten Beispiel die interne
Form von Maxima-Ausdr@"ucken anzuzeigen.

@example
(%i4) :lisp (symbol-plist 'mabs)
(TEXSYM ((\left| ) \right| ) TEX TEX-MATCHFIX REAL-VALUED T
        MAPS-INTEGERS-TO-INTEGERS T DIMENSION DIM-MABS TRANSLATE
        #<FUNCTION (LAMBDA #) @{972D045@}> FLOATPROG MABSBIGFLOAT INTEGRAL
        ((X) #<FUNCTION ABS-INTEGRAL>) OPERATORS SIMPABS DISTRIBUTE_OVER
        (MLIST $MATRIX MEQUAL) NOUN $ABS REVERSEALIAS $ABS GRAD
        ((X) ((MTIMES) X ((MEXPT) ((MABS) X) -1))))

(%i4) :lisp (setq *print-circle* nil)
NIL

(%i4) 'integrate(t*sin(t), t);
@group
                          /
                          [
(%o4)                     I t sin(t) dt
                          ]
                          /
@end group
(%i5) :lisp $%
((%INTEGRATE SIMP) ((MTIMES SIMP) $T ((%SIN SIMP) $T)) $T)
@end example

Das Kommando @code{:lisp} kann in einer Kommandozeile und in Dateien verwendet
werden, die mit den Funktionen @mref{batch} oder @mref{demo} geladen werden.
Dagegen kann das Kommando @code{:lisp} nicht in Dateien verwendet werden, die 
mit den Funktionen @mrefcomma{load} @mrefcomma{batchload}@w{}
@mref{translate_file} oder @mref{compile_file} geladen werden.

@subheading Ausf@"uhrung von Maxima-Code in Lisp

Das Lisp-Makro @code{#$} erlaubt die Nutzung von Maxima-Ausdr@"ucken in 
Lisp-Code.  @code{#$@var{expr}$} wird zu einem Lisp-Ausdruck expandiert, der
dem Maxima-Ausdruck @var{expr} entspricht.

Beispiele:

Die beiden folgenden Beispiele zeigen die Zuweisung an eine Variable @code{var}.
Im ersten Beispiel werden Lisp- und Maxima-Code gemischt.  F@"ur die Zuweisung
an die Variable wird die Lisp-Funktion @code{MSETQ} aufgerufen.  Das Makro
@code{#$} transformiert den Maxima Ausdruck @code{sin(x) + a^2} in die Lisp-Form
@code{((MPLUS SIMP) ((MEXPT SIMP) $A 2) ((%SIN SIMP) $X))}.  Dies entspricht
dem im zweiten Beispiel gezeigten Maxima-Kommando.

@example
(%i1) :lisp (msetq $var #$sin(x)+a^2$)
((MPLUS SIMP) ((MEXPT SIMP) $A 2) ((%SIN SIMP) $X))

(%i1) var: sin(x)+a^2;
@group
                                     2
(%o1)                      sin(x) + a
@end group
@end example

In diesem Beispiel wird zun@"achst ein Maxima-Ausdruck der Variablen @code{$VAR}
zugewiesen und dann mit der Lisp-Funktion @code{DISPLA} ausgegeben.

@example
(%i1) :lisp (setq $var #$'integrate(f(x), x)$)
((%INTEGRATE SIMP) (($F SIMP) $X) $X)
(%i1) :lisp (displa $var)
/
[
I f(x) dx
]
/
NIL
@end example

Maxima-Funktionen sind keine Lisp-Funktionen.  Um eine Maxima-Funktion in 
Lisp-Code aufzurufen, kann die Lisp-Funktion @code{MFUNCALL} aufgerufen werden.

@example
(%i1) f(x,y) := x^2 + sin(y)$
(%i2) :lisp (mfuncall '$f '$a 10)
((MPLUS SIMP) ((%SIN SIMP) 10) ((MEXPT SIMP) $A 2))
@end example

@subheading @"Offnen einer Lisp-Sitzung

Mit dem Kommando @code{to_lisp()} kann von einer Maxima-Kommandozeile eine
Lisp-Sitzung ge@"offnet werden.  Mit dem Kommando @code{(TO-MAXIMA)} wird
die Lisp-Sitzung beendet und nach Maxima zur@"uckgekehrt.  Siehe auch
@mref{to_lisp} f@"ur ein Beispiel.

Die folgenden Lisp-Funktionen k@"onnen in Maxima nicht verwendet werden:

@code{complement},
@code{continue},
@code{/},
@code{float},
@code{functionp},
@code{array},
@code{exp},
@code{listen},
@code{signum},
@code{atan},
@code{asin},
@code{acos},
@code{asinh},
@code{acosh},
@code{atanh},
@code{tanh},
@code{cosh},
@code{sinh},
@code{tan},
@code{break},
und @code{gcd}.

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in die Programmierung, Funktionen und Variablen der Programmierung, Lisp und Maxima, Programmierung
@section Einf@"uhrung in die Programmierung
@c -----------------------------------------------------------------------------

In Maxima k@"onnen Programme geschrieben werden.  Alle Maxima-Funktionen und 
Maxima-Variablen k@"onnen in Programmen verwendet werden.  Maxima hat einen
@"Ubersetzer, um Maxima-Programme in Lisp-Programme zu @"ubersetzen, und einen
Compiler, um die @"ubersetzten Programme zu kompilieren.  Siehe dazu das Kapitel
@nrefdot{@"Ubersetzer}

Maxima-Programme bestehen aus Funktionen und Makros, die im Kapitel 
@nref{Funktionsdefinitionen} beschrieben sind.  Die Funktionen werden aus 
Ausdr@"ucken der Form @code{(expr_1, expr_2, ..., expr_n)} oder
@mref{block}-Anweisungen zusammengesetzt.  Mit der Anweisung @mref{local} werden
Variablen definiert, deren Werte und Eigenschaften lokal zu einem Block sind.

Konditionale Verzweigen werden mit der Anweisung @mref{if} definiert und haben 
die Form @code{if ... then ... else}.

Maxima kennt die sehr allgemeine Anweisung @mrefcomma{for} um Schleifen zu
programmieren.  Schl@"usselworte f@"ur die Programmierung von Schleifen sind
@mrefcomma{while} @mrefcomma{unless} @mref{do} sowie @code{thru}, @code{step},
@code{in}.

Mit der Sprunganweisung @mref{return} kann ein Block verlassen werden und mit
der Sprunganweisung @mref{go} wird innerhalb eines Blockes zu eine Marke
verzweigt.  Nicht-lokale R@"uckspr@"unge aus Funktionen werden mit den 
Anweisungen @mref{catch} und @mref{throw} programmiert.

Die Anweisung @mref{errcatch} f@"angt Fehler ab, so dass die Ausf@"uhrung eines
Programms nicht abgebrochen wird.  Mit der Anweisungen @mref{error} und
@mref{break} wird ein Programm abgebrochen.  Im ersten Fall kann eine
Fehlermelung ausgegeben werden und das Programm kehrt zur Maxima-Kommandozeile
zur@"uck.  Mit @code{break} wird der Maxima-Debugger gestartet.

Maxima kennt die folgenden Anweisungen und Variablen um Programme zu definieren:

@verbatim
   backtrace    block        break
   catch        do           eval_when
   errcatch     error        error_size
   error_syms   errormsg     for
   go           if           local
   return       throw        unless
   while
@end verbatim

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen der Programmierung,  , Einf@"uhrung in die Programmierung, Programmierung
@section Funktionen und Variablen der Programmierung
@c -----------------------------------------------------------------------------

@c --- 23.12.2010 DK -----------------------------------------------------------
@anchor{backtrace}
@deffn  {Funktion} backtrace ()
@deffnx {Funktion} backtrace (@var{n})

Gibt den Aufruf-Stack der Funktion zur@"uck, die ausgef@"uhrt wird.

Das Kommando @code{backtrace()} zeigt den gesamten Stack.
@code{backtrace(@var{n})} zeigt die letzten @var{n} Funktionen
einschlie@ss{}lich der Funktion, die ausgef@"uhrt wird.

@code{backtrace} kann in einer Batch-Datei, die zum Beispiel mit der Funktion
@mref{batch} geladen wird, in einer Funktion oder von einer Kommandozeile
aufgerufen werden.

Beispiele:

@code{backtrace()} gibt den gesamten Stack aus.

@example
(%i1) h(x) := g(x/7)$
(%i2) g(x) := f(x-11)$
(%i3) f(x) := e(x^2)$
(%i4) e(x) := (backtrace(), 2*x + 13)$
(%i5) h(10);
#0: e(x=4489/49)
#1: f(x=-67/7)
#2: g(x=10/7)
#3: h(x=10)
                              9615
(%o5)                         ----
                               49
@end example

@code{backtrace(@var{n})} gibt die letzten @var{n} Funktionen aus.

@example
(%i1) h(x) := (backtrace(1), g(x/7))$
(%i2) g(x) := (backtrace(1), f(x-11))$
(%i3) f(x) := (backtrace(1), e(x^2))$
(%i4) e(x) := (backtrace(1), 2*x + 13)$
(%i5) h(10);
#0: h(x=10)
#0: g(x=10/7)
#0: f(x=-67/7)
#0: e(x=4489/49)
@group
                              9615
(%o5)                         ----
                               49
@end group
@end example
@end deffn

@c --- 23.02.2011 DK -----------------------------------------------------------
@anchor{block}
@deffn  {Funktion} block ([@var{v_1}, @dots{}, @var{v_m}], @var{expr_1}, @dots{}, @var{expr_n})
@deffnx {Funktion} block (@var{expr_1}, @dots{}, @var{expr_n})

Mit der Anweisung @code{block} werden Ausdr@"ucke in einer lokalen Umgebung
zusammengefasst.  @code{block} wertet die Argument @var{expr_1}, @var{expr_2},
@dots{}, @var{expr_n} nacheinander aus und gibt das Ergebnis des letzten
ausgewerteten Ausdrucks zur@"uck.  Die Liste @code{[v_1, ..., v_m]} am Anfang
der @code{block}-Anweisung bezeichnet Variablen, die innerhalb der
@code{block}-Anweisung lokal sind.  Alle anderen Variablen, die in einem Block
verwendet werden, beziehen sich auf globale Variablen, die au√üerhalb des Block
definiert sind.  Dies kann ein weiterer Block oder die globale Maxima-Umgebung
sein.  @code{block} sichert die aktuellen Werte der Variablen @var{v_1}, 
@dots{}, @var{v_m}.  Wird @code{block} verlassen, werden diese Werte
wiederhergestellt.

Die Deklaration @code{local(@var{v_1}, ..., @var{v_m})} innerhalb der
@code{block}-Anweisung sichert nicht nur die Werte, sondern auch die
Eigenschaften der Variablen wie sie zum Beispiel mit den Funktionen
@mref{declare} oder @mref{depends} definiert werden.  Erhalten die mit
@code{local} deklarierten Variablen innerhalb der @code{block}-Anweisung
Eigenschaften, wirken sich diese nur lokal aus.  Beim Verlassen der
@code{block}-Anweisung werden die globalen Eigenschaften wiederhergestellt.
Siehe auch @mrefdot{local}

Die @code{block}-Anweisung kann verschachtelt werden.  Jeder Block kann
eigene lokale Variablen definieren.  Diese sind global zu jedem anderen Block
der sich innerhalb des Blockes befindet.  Ein Variable die nicht als lokal
definiert ist, hat den globalen Wert eines umgebenden Blocks oder den Wert der
globalen Maxima-Umgebung.

Der R@"uckgabewert eines Blocks ist der Wert des letzten Ausdrucks oder der 
Wert, der mit den @code{return}-Anweisung zur@"uckgegeben wird.  Mit der 
@code{go}-Anweisung kann innerhalb eines Blocks zu einer Marke gesprungen 
werden.  Weiterhin kann mit der @mref{throw}-Anweisung ein nicht-lokaler
R@"ucksprung zu einer entsprechenden @mref{catch}-Anweisung erfolgen.

Bl@"ocke erscheinen typischerweise auf der rechten Seite einer 
Funktionsdefinitionen.  Sie k@"onnen aber auch an anderen Stellen verwendet
werden.

Beispiel:

Das Beispiel zeigt eine einfache Implementation des Newton-Algorithmus.  Der
Block definiert die lokalen Variablen @code{xn}, @code{s} und @var{numer}.
@mref{numer} ist eine Optionsvariable, die im Block einen lokalen Wert erh@"alt.
Im Block ist das Tag @code{loop} definiert.  Zu diesem Tag wird mit der
Anweisung @code{go(loop)} gesprungen.  Der Block und damit die Funktion wird
mit der Anweisung @code{return(xn)} verlassen.  Der Wert der Variablen @code{xn}
ist das Ergebnis der Funktion @code{newton}.

@example
newton(exp,var,x0,eps):=
   block([xn,s,numer],
      numer:true,
      s:diff(exp,var),
      xn:x0,
   loop,
      if abs(subst(xn,var,exp))<eps then return(xn),
      xn:xn-subst(xn,var,exp)/subst(xn,var,s),
      go(loop) )$
@end example
@end deffn

@c --- 27.12.2010 DK -----------------------------------------------------------
@anchor{break}
@deffn {Funktion} break (@var{expr_1}, @dots{}, @var{expr_n})

Wertet die Ausdr@"ucke @var{expr_1}, @dots{}, @var{expr_n} aus, zeigt die 
Ergebnisse an und f@"uhrt dann eine Unterbrechung aus.  Mit dem Kommando 
@code{exit;} wird Maxima fortgesetzt.  Siehe das Kapitel

Beispiel:

Der Variablen @code{a} wird der Wert 2 zugewiesen.  Dann wird die Unterbrechung
ausgef@"uhrt.  Mit dem Kommando @code{exit;} wird Maxima fortgesetzt.

@example
(%i1) break(a:2);
2 

Entering a Maxima break point. Type 'exit;' to resume.
_a;
2
_exit;
(%o1)                           2
@end example
@end deffn

@c --- 27.12.2010 DK -----------------------------------------------------------
@anchor{catch}
@deffn {Funktion} catch (@var{expr_1}, @dots{}, @var{expr_n})

@c Evaluates @var{expr_1}, ..., @var{expr_n} one by one; if any leads to the 
@c evaluation of an expression of the form @code{throw (arg)}, then the value of
@c the @code{catch} is the value of @code{throw (arg)}, and no further 
@c expressions are evaluated. This "non-local return" thus goes through any 
@c depth of nesting to the nearest enclosing @code{catch}. If there is no 
@c @code{catch} enclosing a @code{throw}, an error message is printed.

Wertet die Ausdr@"ucke @var{expr_1}, @dots{}, @var{expr_n} nacheinander aus.
Wertet irgendeiner der Ausdr@"ucke zu @code{throw(arg)} aus, dann ist das 
Ergebnis der Wert von @code{throw(arg)} und es werden keine weiteren Ausdr@"ucke
ausgewertet.  Diese nicht-lokale R@"uckgabe kehrt zu dem n@"achsten @code{catch}
in einer beliebigen Verschachtelungstiefe zur@"uck.  Wird kein @code{catch} 
gefunden gibt Maxima eine Fehlermeldung aus.

@c If the evaluation of the arguments does not lead to the evaluation of any 
@c @code{throw} then the value of @code{catch} is the value of @var{expr_n}.

F@"uhrt die Auswertung der Argumente nicht zu einem @code{throw}, dann ist
die R@"uckgabe das Ergebnis des letzten Ausdrucks @code{expr_n}.

Beispiel:

@c The function @code{g} returns a list of @code{f} of each element of @code{l} 
@c if @code{l} consists only of non-negative numbers; otherwise, @code{g} 
@c "catches" the first negative element of @code{l} and "throws" it up.

Die Funktion @code{g} gibt eine Liste mit den Werten des Lambda-Ausdrucks 
zur@"uck.  Tritt ein negativer Wert auf, bricht die Funktion ab, in diesem 
Beispiel mit @code{throw(-3)}.

@example
(%i1) lambda ([x], if x < 0 then throw(x) else f(x))$
(%i2) g(l) := catch (map (''%, l))$
(%i3) g ([1, 2, 3, 7]);
(%o3)               [f(1), f(2), f(3), f(7)]
(%i4) g ([1, 2, -3, 7]);
(%o4)                          - 3
@end example
@end deffn

@c --- 23.12.2010 DK -----------------------------------------------------------
@anchor{do}
@deffn {Spezieller Operator} do

@c The @code{do} statement is used for performing iteration.  Due to its great 
@c generality the @code{do} statement will be described in two parts. First the 
@c usual form will be given which is analogous to that used in several other 
@c programming languages (Fortran, Algol, PL/I, etc.); then the other features 
@c will be mentioned.

Die @code{do}-Anweisung erlaubt die Definition von Iterationen.  Aufgrund der
gro@ss{}en Allgemeinheit der @code{do}-Anweisung folgt die Beschreibung in zwei
Teilen.  Zun@"achst werden die bekannteren Formen beschrieben, wie sie auch in 
anderen Programmiersprachen vorhanden sind.  Dann folgen die weiteren 
M@"oglichkeiten.

@c There are three variants of this form that differ only in their terminating 
@c conditions.  They are:

Es gibt drei Varianten der @code{do}-Anweisung, die sich nur durch die
Abbruchbedingung voneinander unterscheiden.  Diese sind:

@example
@b{for} @var{variable}: @var{initial_value} @b{step} @var{increment}
      @b{thru} @var{limit} @b{do} @var{body}

@group
@b{for} @var{variable}: @var{initial_value} @b{step} @var{increment}
      @b{while} @var{condition} @b{do} @var{body}
@end group

@b{for} @var{variable}: @var{initial_value} @b{step} @var{increment}
      @b{unless} @var{condition} @b{do} @var{body}
@end example

   @c UGH. DO WE REALLY NEED TO MENTION THIS??
@c (Alternatively, the @code{step} may be given after the termination condition
@c or limit.)

@c @var{initial_value}, @var{increment}, @var{limit}, and @var{body} can be any
@c expressions.  If the increment is 1 then "@code{step 1}" may be omitted.

@var{initial_value}, @var{increment}, @var{limit} und @var{body} k@"onnen 
beliebige Ausdr@"ucke sein.  Ist das Inkrement 1, kann @code{step} entfallen.

@c The execution of the @code{do} statement proceeds by first assigning the 
@c @var{initial_value} to the @var{variable} (henceforth called the 
@c control-variable). Then: (1) If the control-variable has exceeded the limit 
@c of a @code{thru} specification, or if the condition of the @code{unless} is 
@c @code{true}, or if the condition of the @code{while} is @code{false} then the
@c @code{do} terminates. (2) The @var{body} is evaluated.  (3) The increment is 
@c added to the control-variable.  The process from (1) to (3) is performed 
@c repeatedly until the termination condition is satisfied.  One may also give 
@c several termination conditions in which case the @code{do} terminates when 
@c any of them is satisfied.

Die Ausf@"uhrung der @code{do}-Anweisung beginnt mit der Zuweisung von
@code{initial_value} an die Kontrollvariable @var{variable}.  Dann folgen die 
Schritte: (1) Hat die Kontrollvariable den Wert einer @code{thru}-Anweisung
@"uberschritten oder hat die Bedingung einer @code{unless}-Anweisung den Wert
@code{true} oder hat die Bedingung einer @code{while}-Anweisung den Wert
@code{false}, dann endet die Ausf@"uhrung der @code{do}-Anweisung.  (2) Die
Ausdr@"ucke in @var{body} werden ausgewertet.  (3) Das Inkrement wird zu der
Kontrollvariablen hinzuaddiert.  Die Schritte (1) bis (3) werden solange 
ausgef@"uhrt, bis eine der Bedingungen f@"ur die Beendigung der 
@code{do}-Anweisung zutrifft.

@c In general the @code{thru} test is satisfied when the control-variable is 
@c greater than the @var{limit} if the @var{increment} was non-negative, or when
@c the control-variable is less than the @var{limit} if the @var{increment} was 
@c negative.  The @var{increment} and @var{limit} may be non-numeric expressions
@c as long as this inequality can be determined.  However, unless the 
@c @var{increment} is syntactically negative (e.g. is a negative number) at the 
@c time the @code{do} statement is input, Maxima assumes it will be positive 
@c when the @code{do} is executed.  If it is not positive, then the @code{do} 
@c may not terminate properly.

Im Allgemeinen ist der @code{thru}-Test erf@"ullt, wenn die Kontrollvariable 
gr@"o@ss{}er als @var{limit} ist, falls @var{increment} nicht negativ ist.  Oder 
wenn die Kontrollvariable kleiner als @code{limit} ist, f@"ur den Fall, dass das
Inkrement negativ ist.  @var{increment} und @var{limit} k@"onnen Ausdr@"ucke 
sein, sofern die Bedingung zum Abbruch der @code{do}-Anweisung ausgewertet 
werden kann.  Soll @code{increment} zu einem negativen Wert auswerten und kann 
dies jedoch bei Eintritt in die Schleife von Maxima nicht festgestellt werden, 
so wird das Inkrement als positiv angenommen.  Dies kann dazu f@"uhren, dass die
Schleife nicht korrekt ausgef@"uhrt wird.

@c Note that the @var{limit}, @var{increment}, and termination condition are
@c evaluated each time through the loop.  Thus if any of these involve much 
@c computation, and yield a result that does not change during all the 
@c executions of the @var{body}, then it is more efficient to set a variable to 
@c their value prior to the @code{do} and use this variable in the @code{do} 
@c form.

@var{limit}, @var{increment} und die Bedingung f@"ur den Abbruch der Schleife 
werden f@"ur jeden Durchgang durch die Schleife ausgewertet.  @"Andern diese 
ihren Wert nicht, kann es daher effizienter sein, die Werte diese Ausdr@"ucke 
vor Eintritt in die Schleife zu berechnen und in Variablen abzulegen, die 
anstatt der Ausdr@"ucke in der Schleife verwendet werden.

@c The value normally returned by a @code{do} statement is the atom @code{done}.
@c However, the function @code{return} may be used inside the @var{body} to 
@c exit the @code{do} prematurely and give it any desired value. Note however 
@c that a @code{return} within a @code{do} that occurs in a @code{block} will 
@c exit only the @code{do} and not the @code{block}. Note also that the 
@c @code{go} function may not be used to exit from a @code{do} into a 
@c surrounding @code{block}.

Die @code{do}-Anweisung hat den R@"uckgabewert @code{done}.  Um einen anderen
Wert zu@-r@"uck@-zu@-ge@-ben, kann die @code{return}-Anweisung innerhalb von 
@code{body} genutzt werden.  Befindet sich die @code{do}-Anweisung innerhalb 
eines Blockes, so wird dieser nicht mit einer @code{return}-Anweisung verlassen,
die sich innerhalb der @code{do}-Anweisung befindet.  Auch kann nicht mit der
@code{go}-Anweisung in einen umgebenen Block gesprungen werden.

@c The control-variable is always local to the @code{do} and thus any variable 
@c may be used without affecting the value of a variable with the same name 
@c outside of the @code{do}.  The control-variable is unbound after the 
@c @code{do} terminates.

Die Kontrollvariable ist immer lokal zur @code{do}-Anweisung.  Nach dem
Verlassen der @code{do}-Anweisung kann auf die Kontrollvariable nicht mehr 
zugegriffen werden.

@example
(%i1) for a:-3 thru 26 step 7 do display(a)$
                             a = - 3

                              a = 4

                             a = 11

                             a = 18

                             a = 25
@end example

@c Note that the condition @code{while i <= 10} is equivalent to 
@c @code{unless i > 10} and also @code{thru 10}.

Die Bedingung @code{while i <= 10} ist @"aquivalent zu den Bedingungen
@code{unless i > 10} und @code{thru 10} ist.

@example
(%i1) s: 0$
(%i2) for i: 1 while i <= 10 do s: s+i;
(%o2)                         done
(%i3) s;
(%o3)                          55
@end example

@c which gives 8 terms of the Taylor series for @code{e^sin(x)}.

Berechne die ersten acht Terme einer Taylorreihe in einer @code{do}-Schleife.

@example
(%i1) series: 1$
(%i2) term: exp (sin (x))$
(%i3) for p: 1 unless p > 7 do
          (term: diff (term, x)/p, 
           series: series + subst (x=0, term)*x^p)$
(%i4) series;
                  7    6     5    4    2
                 x    x     x    x    x
(%o4)            -- - --- - -- - -- + -- + x + 1
                 90   240   15   8    2
@end example

@c This example computes the negative square root of 10 using the Newton-Raphson
@c iteration a maximum of 10 times.  Had the convergence criterion not been met 
@c the value returned would have been @code{done}.

In diesem Beispiel wird die negative Wurzel von 10 mit einem 
Newton-Raphson-Algorithmus berechnet. 

@example
(%i1) poly: 0$
(%i2) for i: 1 thru 5 do
          for j: i step -1 thru 1 do
              poly: poly + i*x^j$
(%i3) poly;
                  5      4       3       2
(%o3)          5 x  + 9 x  + 12 x  + 14 x  + 15 x
(%i4) guess: -3.0$
(%i5) for i: 1 thru 10 do
          (guess: subst (guess, x, 0.5*(x + 10/x)),
           if abs (guess^2 - 10) < 0.00005 then return (guess));
(%o5)                  - 3.162280701754386
@end example

@c Instead of always adding a quantity to the control-variable one may sometimes
@c wish to change it in some other way for each iteration. In this case one may 
@c use @code{next @var{expression}} instead of @code{step @var{increment}}. This
@c will cause the control-variable to be set to the result of evaluating 
@c @var{expression} each time through the loop.

Anstatt eines festes Inkrements mit @code{step} kann die Kontrollvariable auch 
mit @code{next} f@"ur jeden Schleifendurchgang berechnet werden.

@example
(%i6) for count: 2 next 3*count thru 20 do display (count)$
                            count = 2

                            count = 6

                           count = 18
@end example

   @c UGH. DO WE REALLY NEED TO MENTION THIS??
@c As an alternative to @code{for @var{variable}: @var{value} ... the 
@c syntax @code{for @var{variable} from @var{value} ...do...}  may be used. This
@c permits the @code{from @var{value}} to be placed after the @code{step} or 
@c @code{next} value or after the termination condition. If 
@c @code{from @var{value}} is omitted then 1 is used as the initial value.

Anstatt mit der Syntax @code{for @var{variable}: @var{value} ...} kann die
Kontrollvariable auch mit @code{for @var{variable} from @var{value} ...do...}
initialisiert werden.  Wird auch @code{from @var{value}} fortgelassen, wird
die Kontrollvariable mit dem Wert 1 initialisiert.

@c Sometimes one may be interested in performing an iteration where the 
@c control-variable is never actually used.  It is thus permissible to give only
@c the termination conditions omitting the initialization and updating 
@c information as in the following example to compute the square-root of 5 using
@c a poor initial guess.

Manchmal kann es von Interesse sein, in einer Schleife keine Kontrollvariable
zu nutzen.  In diesem Fall gen@"ugt es allein die Bedingung f@"ur den Abbruch 
der Schleife anzugeben.  Im folgenden wird die Wurzel aus 5 mit dem 
Heron-Verfahren bestimmt.

@example
(%i1) x: 1000$
(%i2) thru 20 do x: 0.5*(x + 5.0/x)$
(%i3) x;
(%o3)                   2.23606797749979
(%i4) sqrt(5), numer;
(%o4)                   2.23606797749979
@end example

@c If it is desired one may even omit the termination conditions entirely and 
@c just give @code{do @var{body}} which will continue to evaluate the @var{body} 
@c indefinitely.  In this case the function @code{return} should be used to 
@c terminate execution of the @code{do}.

Auch die Abbruchbedingung kann fortgelassen werden.  Wird allein
@code{do @var{body}} angegeben, wird die Schleife unendlich oft ausgef@"uhrt. 
Die Schleife kann mit der @code{return}-Anweisung verlassen werden.   Das 
folgende Beispiel zeigt eine Implementierung des Newton-Algorithmus.

@example
@group
(%i1) newton (f, x):= ([y, df, dfx], df: diff (f ('x), 'x),
          do (y: ev(df), x: x - f(x)/y, 
              if abs (f (x)) < 5e-6 then return (x)))$
@end group
(%i2) sqr (x) := x^2 - 5.0$
(%i3) newton (sqr, 1000);
(%o3)                   2.236068027062195
@end example

   @c DUNNO IF WE NEED THIS LEVEL OF DETAIL; THIS ARTICLE IS GETTING PRETTY LONG
@c (Note that @code{return}, when executed, causes the current value of @code{x}
@c to be returned as the value of the @code{do}.  The @code{block} is exited and
@c this value of the @code{do} is returned as the value of the @code{block} 
@c because the @code{do} is the last statement in the block.)

@c One other form of the @code{do} is available in Maxima.  The syntax is:

Eine weitere Syntax ist die folgende:

@example
for @var{variable} in @var{list} @var{end_tests} do @var{body}
@end example

@c The elements of @var{list} are any expressions which will successively be 
@c assigned to the @code{variable} on each iteration of the @var{body}.  The 
@c optional termination tests @var{end_tests} can be used to terminate execution
@c of the @code{do}; otherwise it will terminate when the @var{list} is 
@c exhausted or when a @code{return} is executed in the @var{body}.  In fact, 
@c @code{list} may be any non-atomic expression, and successive parts are taken.

Die Elemente der Liste @var{list} k@"onnen beliebige Ausdr@"ucke sein, die
nacheinander der Kontrollvariablen zugewiesen werden.  Die Schleife bricht ab, 
wenn die optionale Abbruchbedingung @code{end_test} zutrifft, wenn die Liste
@var{list} keine weiteren Elemente enth@"alt oder wenn die Schleife zum Beispiel
mit der Funktion @code{return} verlassen wird.

@example
(%i1)  for f in [log, rho, atan] do ldisp(f(1))$
(%t1)                                  0
(%t2)                                rho(1)
                                     %pi
(%t3)                                 ---
                                      4
(%i4) ev(%t3,numer);
(%o4)                             0.78539816
@end example
@end deffn

@c --- 02.10.2011 DK -----------------------------------------------------------
@anchor{eval_when}
@deffn  {Funktion} eval_when (@var{keyword}, @var{expr_1}, @dots{}, @var{expr_n})
@deffnx {Funktion} eval_when ([@var{keyword_1}, @var{keyword_2}, @dots{}], @var{expr_1}, @dots{}, @var{expr_n})

Ein Ausdruck mit der Funktion @code{eval_when} wird an oberster Stelle in einer
Datei definiert und erlaubt die bedingte Auswertung von Ausdr@"ucken beim Laden,
@"Ubersetzen oder Kompilieren einer Datei.  Das Argument @var{keyword} ist eines
der Schl@"usselworte @code{batch}, @code{translate}, @code{compile} oder
@code{loadfile}.  Das erste Argument kann ein einzelnes Schl@"usselwort oder
ein Liste mit mehreren Schl@"usselworten sein.  Trifft die mit dem
Schl@"usselwort angegebene Bedingung zu, wird eine oder mehrere der folgenden
Aktionen ausgef@"uhrt:

@table @code
@item batch
Wird die Datei mit einer der Funktionen @mrefcomma{load} @mrefcomma{batch}@w{}
@mref{batchload} oder @mref{demo} geladen und ist @code{batch} in der Liste der
Schl@"usselworte enthalten, dann werden die Ausdr@"ucke @var{expr1}, @dots{},
@var{expr_n} genau einmal beim Laden der Datei ausgewertet.  Die R@"uckgabe der
Funktion @code{eval_when} ist ein Ausdruck @code{evaluated_when(@var{result)}},
wobei @var{result} das Ergebnis der Auswertung ist.  Ist das Schl@"usselwort
@code{batch} nicht vorhanden, ist die R@"uckgabe das Symbol
@code{not_evaluated_when}.

@item translate
Wird die Datei mit dem Kommando @mref{translate_file} oder
@mref{compile_file} geladen und ist @code{translate} unter den
Schl@"usselworten, dann werden die Ausdr@"ucke @var{expr_1}, @dots{},
@var{expr_n} sofort ausgewertet.  Seiteneffekte wie Zuweisungen von Werten
an Optionsvariablen oder Deklarationen sind f@"ur die folgende @"Ubersetzung
der Datei nach Lisp wirksam.  Die Ausdr@"ucke sind jedoch nicht Teil des
@"ubersetzten Programms.

@item loadfile
Wird die Datei mit dem Kommando @mref{translate_file} oder dem Kommando
@mref{compile_file} geladen und ist @code{loadfile} unter den
Schl@"us@-sel@-wor@-ten, dann werden die Ausdr@"ucke @var{expr_1}, @dots{},
@var{expr_n} nach Lisp @"ubersetzt und als Block der Form
@code{(PROGN EXPR_1 ... EXPR_N)} in das Lisp Programm eingesetzt.  Hier sind
die Anweisungen @var{EXPR_I} die nach Lisp @"ubersetzten Maxima-Ausdr@"ucke
@var{expr_i}.

@item compile
Wird die Datei mit dem Kommando @mref{translate_file} oder
@mref{compile_file} geladen und ist @code{compile} unter den
Schl@"us@-sel@-wor@-ten, dann werden die Ausdr@"ucke @var{expr_1}, @dots{},
@var{expr_n} nach Lisp @"ubersetzt und als eine Lisp-Anweisung in das
Lisp-Programm eingesetzt, die die Form @code{(EVAL-WHEN (:COMPILE-TOPLEVEL)
(EXPR_1 ... EXPR_N))} hat.  Das Schl@"usselwort @code{compile} kann nicht mit
dem Schl@"usselwort @code{loadfile} in einem @code{eval_when}-Ausdruck
kombiniert werden.  In diesem Fall wird das Schl@"usselwort @code{compile}
ignoriert.
@end table

Beispiele:

F@"ur die folgende Beispiele ist eine Datei mit den Namen
@code{eval_when.mac} definiert, die verschiedene @code{eval_when}-Anweisungen
enth@"alt.

@example
(%i1) file: file_search("eval_when.mac");
(%o1)        /home/dieter/.maxima/eval_when.mac
(%i2) printfile(file);

eval_when(batch,     print("called in mode BATCH"));
eval_when(loadfile,  print("called in mode LOADFILE"));
eval_when(compile,   print("called in mode COMPILE"));
eval_when(translate, print("called in mode TRANSLATE"));

(%o2)        /home/dieter/.maxima/eval_when.mac
@end example

Die Datei wird mit dem Kommando @code{load} geladen.  Die Anweisung mit
dem Schl@"usselwort @code{batch} wird beim Laden einmal ausgef@"uhrt.

@example
(%i1) file: file_search("eval_when.mac");
(%o1)        /home/dieter/.maxima/eval_when.mac
(%i2) load(file);
called in mode BATCH
(%o2)        /home/dieter/.maxima/eval_when.mac
@end example

In diesem Fall wird die Datei mit dem Befehl @code{batch} geladen.  Die
Anweisung mit dem Schl@"usselwort @code{batch} wird einmal ausgef@"uhrt.
Die anderen @code{eval_when}-Anweisungen werten jeweils zum Ergebnis
@code{not_evaluated_when} aus.

@example
(%i3) batch(file);

read and interpret file: /home/dieter/.maxima/eval_when.mac
(%i4)     eval_when(batch, print(called in mode BATCH))
called in mode BATCH 
(%o4)         evaluated_when(called in mode BATCH)
(%i5)  eval_when(loadfile, print(called in mode LOADFILE))
(%o5)                  not_evaluated_when
(%i6)   eval_when(compile, print(called in mode COMPILE))
(%o6)                  not_evaluated_when
(%i7) eval_when(translate, print(called in mode TRANSLATE))
(%o7)                  not_evaluated_when
(%o7)        /home/dieter/.maxima/eval_when.mac
@end example

Jetzt wird die Datei mit dem Kommando @code{translate_file} geladen und nach
Lisp @"ubersetzt.  Der Ausdruck mit dem Schl@"usselwort @code{translate} wird
sofort ausgewertet.  Das @"ubersetzte Programm wird in die Ausgabedatei
@code{eval_when.LISP} geschrieben.  Die @code{eval_when}-Anweisung zum
Schl@"usselwort wird nicht ausgewertet.

@example
(%i1) file: file_search("eval_when.mac");
(%o1)        /home/dieter/.maxima/eval_when.mac
(%i2) translate_file(file);
translator: begin translating /home/dieter/.maxima/eval_when.mac.
called in mode TRANSLATE 
(%o2) [/home/dieter/.maxima/eval_when.mac, 
/home/dieter/.maxima/eval_when.LISP, 
/home/dieter/.maxima/eval_when.UNLISP]
@end example

Dies ist der Inhalt der Ausgabedatei @code{eval_when.LISP}.  Die Ausgabedatei
enth@"alt eine @code{PROGN}-Anweisung mit dem Ausdruck
@code{($print '"called in mode LOADFILE")} f@"ur den @code{eval_when}-Ausdruck
zum Schl@"usselwort @code{loadfile} sowie eine @code{EVAL-WHEN}-Anweisung mit
dem Ausdruck @code{($print '"called in mode COMPILE")} f@"ur den
@code{eval_when}-Ausdruck mit dem Schl@"usselwort @code{compile}.

@verbatim
;;; -*- Mode: Lisp; package:maxima; syntax:common-lisp ;Base: 10 -*- ;;;
;;; Translated on: 2011-10-02 13:35:37+02:00
;;; Maxima version: 5.25post
;;; Lisp implementation: SBCL
;;; Lisp version: 1.0.45
(in-package :maxima)

[...]

nil
(progn ($print '"called in mode LOADFILE"))
(eval-when (:compile-toplevel) ($print '"called in mode COMPILE"))
nil
@end verbatim
@end deffn

@c --- 25.12.2010 DK -----------------------------------------------------------
@anchor{errcatch}
@deffn {Funktion} errcatch (@var{expr_1}, @dots{}, @var{expr_n})

@c Evaluates @var{expr_1}, ..., @var{expr_n} one by one and returns 
@c @code{[@var{expr_n}]} (a list) if no error occurs.  If an error occurs in the
@c evaluation of any argument, @code{errcatch} prevents the error from 
@c propagating and returns the empty list @code{[]} without evaluating any more 
@c arguments.

Wertet die Ausdr@"ucke @var{expr_1}, @dots{}, @var{expr_n} nacheinander aus und
gibt das Ergebnis des letzten Ausdrucks als eine Liste @code{[@var{expr_n}]}
zur@"uck, wenn kein Fehler bei der Auswertung auftritt.  Tritt ein Fehler
bei der Auswertung eines der Ausdr@"ucke auf, ist die R@"uckgabe eine leere 
Liste @code{[]}.

@c @code{errcatch} is useful in @code{batch} files where one suspects an error 
@c might occur which would terminate the @code{batch} if the error weren't 
@c caught.

@code{errcatch} ist n@"utzlich in Batch-Dateien.  Mit @code{errcatch} kann ein
m@"oglicher Fehler abgefangen werden, ohne das die Verarbeitung der Batch-Datei
abbricht.

Beispiele:

@example
(%i1) errcatch(x:2,1/x);
                                1
(%o1)                          [-]
                                2
(%i2) errcatch(x:0,1/x);

Division by 0
(%o2)                          []
@end example
@end deffn

@c --- 25.12.2010 DK -----------------------------------------------------------
@anchor{error}
@deffn  {Funktion} error (@var{expr_1}, @dots{}, @var{expr_n})
@deffnx {Systemvariable} error

@c Evaluates and prints @var{expr_1}, ..., @var{expr_n}, and then causes an 
@c error return to top level Maxima or to the nearest enclosing @code{errcatch}.

Wertet die Ausdr@"ucke @var{expr_1}, @dots{}, @var{expr_n} aus, gibt diese auf 
der Konsole aus und generiert einen Fehler, der zur obersten Ebene von Maxima 
f@"uhrt oder zu dem n@"achsten @code{errcatch}.

@c The variable @code{error} is set to a list describing the error. The first 
@c element of @code{error} is a format string, which merges all the strings 
@c among the arguments @var{expr_1}, ..., @var{expr_n}, and the remaining 
@c elements are the values of any non-string arguments.

Der Systemvariablen @code{error} wird eine Liste zugewiesen, die eine 
Beschreibung des Fehlers enth@"alt.  Das erste Element der Liste ist eine
Zeichenkette und die weiteren Elemente enthalten die Argumente die keine 
Zeichenkette sind.

@c @code{errormsg()} formats and prints @code{error}. This is effectively 
@c reprinting the most recent error message.

@code{errormsg()} formatiert und gibt die Fehlermeldung in @code{error} aus.
Damit wird die letzte Fehlermeldung erneut ausgegeben.

Beispiel:

@example
(%i1) f(x):= if x=0 then 
                error("Division durch", x, "ist nicht gestattet.") 
             else 1/x$
(%i2) f(0);

Division durch 0 ist nicht gestattet.
#0: f(x=0)
 -- an error. To debug this try: debugmode(true);
(%i3) errormsg();

Division durch 0 ist nicht gestattet.
(%o3)                         done
(%i4) error;
(%o4)      [Division durch ~M ist nicht gestattet., 0]
@end example
@end deffn

@c --- 25.12.2010 DK -----------------------------------------------------------
@anchor{error_size}
@defvr {Optionsvariable} error_size
Standardwert: 10

@c @code{error_size} modifies error messages according to the size of 
@c expressions which appear in them. If the size of an expression (as determined
@c by the Lisp function @code{ERROR-SIZE}) is greater than @code{error_size}, 
@c the expression is replaced in the message by a symbol, and the symbol is 
@c assigned the expression. The symbols are taken from the list 
@c @code{error_syms}.

@code{error_size} kontrolliert die Ausgabe eines Ausdrucks der zu einem Fehler
gef@"uhrt hat.  Ist der Ausdruck gr@"o@ss{}er als @code{error_size} wird der 
Ausdruck bei der Ausgabe einer Fehlermeldung durch ein Symbol ersetzt und dem 
Symbol wird der Ausdruck zugewiesen.  Die Symbole werden aus der Liste 
@code{error_syms} ausgew@"ahlt.

@c Otherwise, the expression is smaller than @code{error_size}, and the 
@c expression is displayed in the message.

Ist der Ausdruck kleiner als @code{error_size} wird dieser mit der Fehlermeldung
ausgegeben.

@c See also @code{error} and @code{error_syms}.

Siehe auch @mref{error} und @mrefdot{error_syms}

Beispiel:

@c The size of @code{U}, as determined by @code{ERROR-SIZE}, is 24.

Die Gr@"o@ss{}e des Ausdrucks @code{U} ist 24.

@example
(%i1) U: (C^D^E + B + A)/(cos(X-1) + 1)$

(%i2) error_size: 20$

(%i3) error ("Example expression is", U);

Example expression is errexp1
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) errexp1;
                            E
                           D
                          C   + B + A
(%o4)                    --------------
                         cos(X - 1) + 1
(%i5) error_size: 30$

(%i6) error ("Example expression is", U);

                         E
                        D
                       C   + B + A
Example expression is --------------
                      cos(X - 1) + 1
 -- an error.  Quitting.  To debug this try debugmode(true);
@end example
@end defvr

@c --- 25.12.2010 DK -----------------------------------------------------------
@anchor{error_syms}
@defvr {Optionsvariable} error_syms
Standardwert: @code{[errexp1, errexp2, errexp3]}

@c In error messages, expressions larger than @code{error_size} are replaced by 
@c symbols, and the symbols are set to the expressions.  The symbols are taken 
@c from the list @code{error_syms}. The first too-large expression is replaced 
@c by @code{error_syms[1]}, the second by @code{error_syms[2]}, and so on.

In Fehlermeldungen werden Ausdr@"ucke, die gr@"o@ss{}er als @code{error_size} 
sind, durch Symbole ersetzt, denen der Ausdruck zugewiesen wird.  Die Symbole 
werden nacheinander der Liste @code{error_syms} entnommen.

@c If there are more too-large expressions than there are elements of 
@c @code{error_syms}, symbols are constructed automatically, with the @var{n}-th 
@c symbol equivalent to @code{concat ('errexp, @var{n})}.

Sind keine Symbole mehr vorhanden, werden automatisch neue Symbole mit
@code{concat('errexp, @var{n})} gebildet.

@c See also @code{error} and @code{error_size}.

Siehe auch @mref{error} und @mrefdot{error_size}
@end defvr

@c --- 25.12.2010 DK -----------------------------------------------------------
@anchor{errormsg}
@deffn {Funktion} errormsg ()

@c Reprints the most recent error message. The variable @code{error} holds the 
@c message, and @code{errormsg} formats and prints it.

Gibt die letzte Fehlermeldung erneut aus.  Die Fehlermeldung ist in der
Systemvariablen @code{errormsg} enthalten.  Die Funktion @code{errormsg}
formatiert diese und gibt sie aus.
@end deffn

@c --- 27.12.2010 DK -----------------------------------------------------------
@anchor{variable_errormsg}
@defvr {Optionsvariable} errormsg
Standardwert: @code{true}

@c When @code{false} the output of error messages is suppressed.

Hat die Optionsvariable @code{errormsg} den @code{false} wird die Ausgabe
von Fehlermeldungen unterdr@"uckt.

@c The option variable @code{errormsg} can not be set in a block to a local 
@c value. The global value of @code{errormsg} is always present.

Der Optionsvariablen @code{errormsg} kann in einem Block kein lokaler Wert
zugewiesen werden.  Der globale Wert von @code{errormsg} ist stets pr@"asent.

Beispiele:

@example
(%i1) errormsg;
(%o1)                                true
(%i2) sin(a,b);
Wrong number of arguments to sin
 -- an error. To debug this try: debugmode(true);
(%i3) errormsg:false;
(%o3)                                false
(%i4) sin(a,b);

 -- an error. To debug this try: debugmode(true);
@end example

@c The option variable @code{errormsg} can not be set in a block to a local 
@c value.

Der Optionsvariablen @code{errormsg} kann in einem Block kein lokaler Wert
zugewiesen werden.

@example
(%i1) f(bool):=block([errormsg:bool], 
                     print ("value of errormsg is",errormsg))$
(%i2) errormsg:true;
(%o2)                                true
@group
(%i3) f(false);
value of errormsg is true 
@end group
(%o3)                                true
(%i4) errormsg:false;
(%o4)                                false
(%i5) f(true);
value of errormsg is false 
(%o5)                                false
@end example
@end defvr

@c REPHRASE
@c AT LEAST SHOULD LIST VARIANTS HERE

@c --- 25.12.2010 DK -----------------------------------------------------------
@anchor{for}
@deffn {Spezieller Operator} for

@c Used in iterations. See @code{do} for a description of Maxima's iteration 
@c facilities.

Anweisung f@"ur Interationen.  Siehe die @mref{do}-Anweisung f@"ur eine 
Beschreibung der Iterationsm@"oglichkeiten von Maxima.
@end deffn

@c --- 25.12.2010 DK -----------------------------------------------------------
@anchor{go}
@deffn {Funktion} go (@var{tag})

@c is used within a @code{block} to transfer control to the statement of the 
@c block which is tagged with the argument to @code{go}.  To tag a statement, 
@c precede it by an atomic argument as another statement in the @code{block}.  
@c For example:

Erlaubt einen Sprung innerhalb eines Blocks zu einer Marke mit dem Namen 
@code{tag}.  Um eine Anweisung mit einer Sprungmarke zu versehen, wird der
Anweisung die Marke vorangestellt.  Ein Beispiel ist:

@example
block ([x], x:1, loop, x+1, ..., go(loop), ...)
@end example

@c The argument to @code{go} must be the name of a tag appearing in the same
@c @code{block}.  One cannot use @code{go} to transfer to tag in a @code{block} 
@c other than the one containing the @code{go}.

Das Argument der Funktion @code{go} muss der Name einer Marke sein, die in
demselben Block erscheint.  Es ist nicht m@"oglich in einen anderen Block zu
springen.
@end deffn

@c NEEDS CLARIFICATION, EXPANSION, EXAMPLES
@c THIS ITEM IS IMPORTANT

@c --- 25.12.2010 DK -----------------------------------------------------------
@anchor{if}
@deffn {Spezieller Operator} if

@c Represents conditional evaluation. Various forms of @code{if} expressions are 
@c recognized.

Ist die bedingte Anweisung.  Verschiedene Formen einer bedingten Anweisung sind
m@"oglich.

@c @code{if @var{cond_1} then @var{expr_1} else @var{expr_0}} evaluates to 
@c @var{expr_1} if @var{cond_1} evaluates to @code{true}, otherwise the 
@c expression evaluates to @var{expr_0}.

@code{if @var{cond_1} then @var{expr_1} else @var{expr_0}} wertet zu 
@var{expr_1} aus, wenn die Bedingung @var{cond_1} den Wert @code{true} hat.
Ansonsten wertet der Ausdruck zu @var{expr_0} aus.

@c @code{if @var{cond_1} then @var{expr_1} elseif @var{cond_2} then @var{expr_2}
@c elseif ... else @var{expr_0}} evaluates to @var{expr_k} if @var{cond_k} is 
@c @code{true} and all preceding conditions are @code{false}. If none of the 
@c conditions are @code{true}, the expression evaluates to @code{expr_0}.

Die zusammengesetzte bedingte Anweisung @code{if @var{cond_1} then @var{expr_1}
elseif @var{cond_2} then @var{expr_2} elseif ... else @var{expr_0}} wertet 
zu @var{expr_k} aus, wenn die Bedingung @var{cond_k} den Wert @code{true} hat 
und alle vorhergehenden Bedingungen den Wert @code{false} haben.  Trifft keine 
der Bedingungen zu, wertet der Ausdruck zu @var{expr_0} aus.

@c A trailing @code{else false} is assumed if @code{else} is missing. That is, 
@c @code{if @var{cond_1} then @var{expr_1}} is equivalent to 
@c @code{if @var{cond_1} then @var{expr_1} else false}, and 
@c @code{if @var{cond_1} then @var{expr_1} elseif ... elseif @var{cond_n} then 
@c @var{expr_n}} is equivalent to @code{if @var{cond_1} then @var{expr_1} elseif
@c ... elseif @var{cond_n} then @var{expr_n} else false}.

Fehlt die Anweisung @code{else}, wird diese zu @code{else false} angenommen.
@code{if @var{cond_1} then @var{expr_1}} ist daher @"aquivalent zu 
@code{if @var{cond_1} then @var{expr_1} else false} und @code{if @var{cond_1} 
then @var{expr_1} elseif ... elseif @var{cond_n} then @var{expr_n}} ist 
@"aquivalent zu @code{if @var{cond_1} then @var{expr_1} elseif ... elseif 
@var{cond_n} then @var{expr_n} else false}.

@c The alternatives @var{expr_0}, ..., @var{expr_n} may be any Maxima 
@c expressions, including nested @code{if} expressions. The alternatives are 
@c neither simplified nor evaluated unless the corresponding condition is 
@c @code{true}.

Die Anweisungen @var{expr_0}, @dots{}, @var{expr_n} k@"onnen beliebige 
Maxima-Ausdr@"ucke ein@-schlie@ss{}@-lich weiterer @code{if}-Anweisungen sein.  
Die Anweisungen werden nicht vereinfacht oder ausgewertet, solange die 
dazugeh@"orende Bedingung nicht das Ergebnis @code{true} hat.

@c The conditions @var{cond_1}, ..., @var{cond_n} are expressions which 
@c potentially or actually evaluate to @code{true} or @code{false}. When a 
@c condition does not actually evaluate to @code{true} or @code{false}, the 
@c behavior of @code{if} is governed by the global flag @code{prederror}. When 
@c @code{prederror} is @code{true}, it is an error if any evaluated condition 
@c does not evaluate to @code{true} or @code{false}. Otherwise, conditions which
@c do not evaluate to @code{true} or @code{false} are accepted, and the result 
@c is a conditional expression.

Die Bedingungen @var{cond_1}, @dots{}, @var{cond_n} sind Ausdr@"ucke, die zu 
@code{true} oder @code{false} ausgewertet werden k@"onnen.  Kann eine Bedingung
nicht zu @code{true} oder @code{false} ausgewertet werden, h@"angt die Reaktion
von der Optionsvariablen @code{prederror} ab.  Hat @code{prederror} den Wert
@code{true}, dann meldet Maxima einen Fehler, wenn eine Bedingung nicht zu
@code{true} oder @code{false} ausgewertet werden kann.  Ansonsten werden
Bedingungen akzeptiert, die nicht zu @code{true} oder @code{false} ausgewertet
werden k@"onnen und das Ergebnis ist ein bedingter Ausdruck.

@c Among other elements, conditions may comprise relational and logical 
@c operators as follows.

Die Bedingungen k@"onnen die folgenden Operatoren enthalten:

   @c - SEEMS LIKE THIS TABLE WANTS TO BE IN A DISCUSSION OF PREDICATE FUNCTIONS
   @c   PRESENT LOCATION IS OK I GUESS
   @c - REFORMAT THIS TABLE USING TEXINFO MARKUP (MAYBE)

@example
Operation              Symbol      Typ
 
less than              <           relational infix
less than              <=
  or equal to                      relational infix
equality (syntactic)   =           relational infix
negation of =          #           relational infix
equality (value)       equal       relational function
negation of equal      notequal    relational function
greater than           >=
  or equal to                      relational infix
greater than           >           relational infix
and                    and         logical infix
or                     or          logical infix
not                    not         logical prefix
@end example
@end deffn

@c --- 27.12.2010 DK -----------------------------------------------------------
@anchor{local}
@deffn {Funktion} local (@var{v_1}, @dots{}, @var{v_n})

@c Saves the properties associated with the symbols @var{v_1}, ..., @var{v_n},
@c removes any properties before evaluating other expressions, and restores any 
@c saved properties on exit from the block or other compound expression in which
@c @code{local} appears.

Speichert alle Eigenschaften der Symbole @var{v_1}, @dots{}, @var{v_n}, entfernt
die Eigenschaften und stellt die abgespeicherten Eigenschaften nach dem Austritt
aus einem Block oder einem zusammengesetzten Ausdruck in dem @code{local}
auftritt wieder her.

@c Some declarations are implemented as properties of a symbol, including 
@c @code{:=}, @code{array}, @code{dependencies}, @code{atvalue}, 
@c @code{matchdeclare}, @code{atomgrad}, @code{constant}, @code{nonscalar}, 
@c @code{assume}, and some others. The effect of @code{local} is to make such 
@c declarations effective only within the block or other compound expression in 
@c which @code{local} appears; otherwise such declarations are global 
@c declarations.

Einige Deklarationen sind als Eigenschaft eines Symbols implementiert.  Dazu
geh@"oren Deklarationen mit @code{:=}, @code{array}, @code{dependencies}, 
@code{atvalue}, @code{matchdeclare}, @code{atomgrad}, @code{constant}, 
@code{nonscalar} oder @code{assume}.  Der Effekt von @code{local} ist, dass
solche Deklarationen nur lokal in dem Block wirksam sind.

@c @code{local} can only appear in @code{block} or in the body of a function 
@c definition or @code{lambda} expression, and only one occurrence is permitted 
@c in each.

@code{local} kann nur in @code{block}-Anweisungen oder in einer 
Funktionsdefinition oder in einem Lambda-Ausdruck verwendet werden. Weiterhin
darf @code{local} jeweils nur einmal auftreten.

@c @code{local} quotes its arguments. @code{local} returns @code{done}.

@code{local} wertet die Argumente aus.  @code{local} hat die R@"uckgabe 
@code{done}.

Beispiel:

Eine lokale Funktionsdefinition.

@example
(%i1) foo (x) := 1 - x;
(%o1)                    foo(x) := 1 - x
(%i2) foo (100);
(%o2)                         - 99
(%i3) block (local (foo), foo (x) := 2 * x, foo (100));
(%o3)                          200
(%i4) foo (100);
(%o4)                         - 99
@end example
@end deffn

@c --- 27.12.2010 DK -----------------------------------------------------------
@anchor{return}
@deffn {Funktion} return (@var{value})

@c May be used to exit explicitly from a block, bringing its argument.
@c See @code{block} for more information.

Die @code{return}-Anweisung wird in einem Block verwendet, um den Block mit dem
Ergebnis @var{value} zu verlassen.  Siehe @mref{block} f@"ur mehr Informationen.
@end deffn

@c --- 27.12.2010 DK -----------------------------------------------------------
@anchor{throw}
@deffn {Funktion} throw (@var{expr})

@c Evaluates @var{expr} and throws the value back to the most recent 
@c @code{catch}.  @code{throw} is used with @code{catch} as a nonlocal return
@c mechanism.

Wertet den Ausdruck @var{expr} aus und generiert eine Ausnahme mit dem Ergebnis
der Auswertung, die von der letzten @code{catch}-Anweisung behandelt wird.
@end deffn

@c --- 23.12.2010 Dk -----------------------------------------------------------
@anchor{while}
@anchor{unless}
@deffn  {Spezieller Operator} while
@deffnx {Spezieller Operator} unless

@c See @code{do}.

Siehe den Operator @mrefdot{do}
@end deffn

@c --- End of file Program.de.texi ---------------------------------------------

