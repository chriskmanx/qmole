@c -----------------------------------------------------------------------------
@c File        : Special.de.texi
@c License     : GNU General Public License (GPL)
@c Language    : German
@c Original    : Special.texi revision 15.06.2011
@c Translation : Dr. Dieter Kaiser
@c Date        : 13.11.2010
@c Revision    : 14.07.2011
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung f@"ur spezielle Funktionen::
* Bessel-Funktionen und verwandte Funktionen::
* Gammafunktionen und verwandte Funktionen::
* Exponentielle Integrale::
* Fehlerfunktionen::
* Elliptische Funktionen und Integrale::
* Hypergeometrische Funktionen::
* Weitere spezielle Funktionen::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung f@"ur spezielle Funktionen, Bessel-Funktionen und verwandte Funktionen, Spezielle Funktionen, Spezielle Funktionen
@section Einf@"uhrung f@"ur spezielle Funktionen
@c -----------------------------------------------------------------------------

Spezielle Funktionen haben die folgenden Notationen:

@example
bessel_j (v, z)                Bessel-Funktion der 1. Art
bessel_y (v, z)                Bessel-Funktion der 2. Art
bessel_i (v, z)                Modifizierte Bessel-Funktion der 1. Art
bessel_k (v, z)                Modifizierte Bessel-Funktion der 2. Art

hankel_1 (v, z)                Hankel-Funktion der 1. Art
hankel_2 (v, z)                Hankel-Funktion der 2. Art

airy_ai (z)                    Airy-Funktion Ai(z)
airy_bi (z)                    Airy-Funktion Bi(z)
airy_dai (z)                   Ableitung der Airy-Funktion Ai(z)
airy_dbi (z)                   Ableitung der Airy-Funktion Bi(z)

struve_h (v, z)                Struve-Funktion H[v](z)
struve_l (v, z)                Struve-Funktion L[v](z)

%f[p,q] ([], [], z)            Hypergeometrische Funktion
gamma()                        Gammafunktion
gammagreek(a, z)               unvollst@"andige Gamma-Funktion
gammaincomplete(a,z)           unvollst@"andige Gamma-Funktion
hypergeometric(l1, l2, z)      Hypergeometrische Funktion

%m[u,k] (z)                    Whittaker-Funktion der 1. Art
%w[u,k] (z)                    Whittaker-Funktion der 2. Art

erf (z)                        Fehlerfunktion
erfc (z)                       Komplement@"are Fehlerfunktion
erfi (z)                       imagin@"are Fehlerfunktion

expintegral_e (v,z)            Exponentielles Integral E
expintegral_e1 (z)             Exponentielles Integral E1
expintegral_ei (z)             Exponentielles integral Ei
expintegral_li (z)             Logarithmisches Integral Li
expintegral_si (z)             Exponentielles Integral Si
expintegral_ci (z)             Exponentielles Integral Ci
expintegral_shi (z)            Exponentielles Integral Shi
expintegral_chi (z)            Exponentielles Integral Chi

parabolic_cylinder_d (v,z)     Parabolische Zylinderfunktion D
@end example

@c -----------------------------------------------------------------------------
@node Bessel-Funktionen und verwandte Funktionen, Gammafunktionen und verwandte Funktionen, Einf@"uhrung f@"ur spezielle Funktionen, Spezielle Funktionen
@need 800
@section Bessel-Funktionen und verwandte Funktionen
@c -----------------------------------------------------------------------------

@menu
* Bessel-Funktionen::
* Hankel-Funktionen::
* Airy-Funktionen::
* Struve-Funktionen::
@end menu

@c -----------------------------------------------------------------------------
@node Bessel-Funktionen, Hankel-Funktionen, Bessel-Funktionen und verwandte Funktionen, Bessel-Funktionen und verwandte Funktionen
@subsection Bessel-Funktionen
@c -----------------------------------------------------------------------------

@c --- 12.07.2011 DK -----------------------------------------------------------
@anchor{bessel_j}
@deffn {Funktion} bessel_j (@var{v}, @var{z})

Die Bessel-Funktion der ersten Art der Ordnung @math{v} mit dem Argument
@math{z}.  @code{bessel_j} ist definiert als

@ifnottex
@example
               inf
               ====             k
               \           (- 1)           z 2 k + v
      J (z) =   >    -------------------  (-)
       v       /     k! gamma(v + k + 1)   2
               ====
               k = 0
@end example
@end ifnottex
@tex
$$J_{v}(z)=\sum_{k=0}^{\infty }{{{\left(-1\right)^{k}}\over{k!
 \,\Gamma\left(v+k+1\right)}}}\,\left({{z}\over{2}}\right)^{2
 \,k+v}$$
@end tex

Die Reihenentwicklung wird nicht f@"ur die numerische Berechnung genutzt.

Die Bessel-Funktion @code{bessel_j} ist f@"ur das numerische und symbolische
Rechnen geeignet.

Maxima berechnet @code{bessel_j} numerisch f@"ur reelle und komplexe
Gleitkommazahlen als Argumente f@"ur @math{v} und @math{z}.  Mit der Funktion
@mref{float} oder der Optionsvariablen @mref{numer} kann die numerische
Auswertung erzwungen werden, wenn die Argumente ganze oder rationale Zahlen
sind.  Die numerische Berechnung f@"ur gro@ss{}e Gleitkommazahlen ist nicht
implementiert.  In diesem Fall gibt Maxima eine Substantivform zur@"uck.

@code{bessel_j} hat die folgenden Eigenschaften, die mit mit der Funktion
@mref{properties} angezeigt werden und auf das symbolische Rechnen Einfluss
haben:

@table @code
@item conjugate function
@code{bessel_j} hat Spiegelsymmetrie, wenn das Argument @var{z} keine negative
reelle Zahl ist.  Die Spiegelsymmetrie wird zum Beispiel von der Funktion
@mref{conjugate} f@"ur die Vereinfachung eines Ausdrucks genutzt.
@item complex characteristic
Maxima kennt den Realteil und den Imagin@"arteil von @code{bessel_j} f@"ur
spezielle Argumente @math{v} und @math{z}.
@item limit function
Maxima kennt spezielle Grenzwerte der Funktion @code{bessel_j}.
@item integral
Maxima kennt das Integral der Funktion @code{bessel_j} f@"ur die
Integrationsvariable @math{z}.
@item gradef
Maxima kennt die Ableitungen der Funktion @code{bessel_j} nach den
Argumenten @math{v} und @math{z}.
@end table

Die Vereinfachung der Bessel-Funktion @code{bessel_j} wird von den folgenden
Optionsvariablen kontrolliert:

@table @code
@item distribute_over
Hat die Optionsvariable @mref{distribute_over} den Wert @code{true} und sind
die Argumente von @code{bessel_j} eine Matrix, Liste oder Gleichung wird die
Funktion auf die Elemente oder beiden Seiten der Gleichung angewendet.  Der
Standardwert ist @code{true}.
@item besselexpand
Hat die Optionsvariable @mref{besselexpand} den Wert @code{true}, wird
@code{bessel_j} mit einer halbzahligen Ordnung @math{v} als Sinus- und
Kosinusfunktionen entwickelt.
@item bessel_reduce
Hat die Optionsvariable @mref{bessel_reduce} den Wert @code{true}, wird
@code{bessel_j} mit einer ganzzahligen Ordnung @math{n} nach Bessel-Funktionen
@code{bessel_j} mit der niedrigsten Ordnung @code{0} und @code{1} entwickelt.
@item hypergeometric_representation
Hat die Optionsvariable @mref{hypergeometric_representation} den Wert
@code{true}, dann wird @code{bessel_j} als hypergeometrische Funktion
dargestellt.
@end table

Weiterhin kennt Maxima die geraden und ungeraden Symmetrieeigenschaften von
@code{bessel_j}.  F@"ur eine ganze Zahl @math{n} vereinfacht daher
@code{bessel_j(-n, z)} zu @code{(-1)^n bessel_j(n, z)}.

Maxima kennt noch die Funktion @mrefcomma{spherical_bessel_j} die im Paket
@code{orthopoly} definiert ist.   Siehe auch die anderen Bessel-Funktionen
@mrefcomma{bessel_y} @mref{bessel_i} und @mref{bessel_k} sowie die
weiteren mit den Bessel-Funktionen verwandten Funktionen wie die
Hankel-Funktionen in @ref{Hankel-Funktionen}, Airy-Funktionen in
@ref{Airy-Funktionen} und Struve-Funktionen in @ref{Struve-Funktionen}.

Beispiele:

Numerisches Rechnen mit der Bessel-Funktion.  F@"ur gro@ss{}e Gleitkommazahlen
ist die numerische Berechnung nicht implementiert.

@example
(%i1) bessel_j(1,[0.5, 0.5+%i]);
(%o1) [.2422684576748739, .5124137767280905 %i
                                             + .3392601907198862]
(%i2) bessel_j(1,[0.5b0, 0.5b0+%i]);
(%o2)    [bessel_j(1, 5.0b-1), bessel_j(1, %i + 5.0b-1)]
@end example

Vereinfachungen der Bessel-Funktion mit den Optionsvariablen @code{besselexpand}
und @code{bessel_reduce}.

@example
(%i3) bessel_j(1/2,x), besselexpand:true;
                         sqrt(2) sin(x)
(%o3)                   -----------------
                        sqrt(%pi) sqrt(x)
(%i4) bessel_j(3,x), bessel_reduce:true;
         2 bessel_j(1, x)
      4 (---------------- - bessel_j(0, x))
                x
(%o4) ------------------------------------- - bessel_j(1, x)
                        x
@end example

Ableitungen und Integrale der Bessel-Funktion.  Das letzte Beispiel zeigt
die Laplace-Transformation der Bessel-Funktion mit der Funktion
@mrefdot{laplace}

@example
(%i5) diff(bessel_j(2,x), x);
@group
                 bessel_j(1, x) - bessel_j(3, x)
(%o5)            -------------------------------
                                2
@end group
(%i6) diff(bessel_j(v,x), x);
             bessel_j(v - 1, x) - bessel_j(v + 1, x)
(%o6)        ---------------------------------------
                                2
(%i7) integrate(bessel_j(v,x), x);
(%o7) 
                                               2
                    v   1    v   3            x    - v - 1  v + 1
    hypergeometric([- + -], [- + -, v + 1], - --) 2        x
                    2   2    2   2            4
    -------------------------------------------------------------
                         v   1
                        (- + -) gamma(v + 1)
                         2   2
(%i8) laplace(bessel_j(2,t), t, s);
                                1       2
                      (1 - sqrt(-- + 1))  s
                                 2
                                s
(%o8)                 ---------------------
                               1
                          sqrt(-- + 1)
                                2
                               s
@end example

Bessel-Funktionen als L@"osung einer linearen Differentialgleichung zweiter
Ordnung.

@example
(%i1) depends(y, x);
(%o1)                        [y(x)]
(%i2) declare(n, integer);
(%o2)                         done
(%i3) 'diff(y, x, 2)*x^2 + 'diff(y, x)*x + y*(x^2-n^2) = 0;
                                2
                     2    2    d y  2   dy
(%o3)            y (x  - n ) + --- x  + -- x = 0
                                 2      dx
                               dx
(%i4) ode2(%, y, x);
(%o4)      y = %k2 bessel_y(n, x) + %k1 bessel_j(n, x)
@end example
@end deffn

@c --- 13.07.2011 DK -----------------------------------------------------------
@anchor{bessel_y}
@deffn {Funktion} bessel_y (@var{v}, @var{z})

Die Bessel-Funktion der zweiten Art der Ordnung @math{v} mit dem Argument
@math{z}.  @code{bessel_y} ist definiert als

@ifnottex
@example
              cos(%pi v) J (z) - J   (z)
                          v       - v
      Y (z) = --------------------------
       v              sin(%pi v)
@end example
@end ifnottex
@tex
$$Y_{v}(z)={{\cos \left(\pi\,v\right)\,J_{v}(z)-J_{-v}(z)}\over{\sin 
 \left(\pi\,v\right)}}$$
@end tex

f@"ur den Fall, dass @math{v} keine ganze Zahl ist.  Ist @math{v} eine ganze
Zahl @math{n}, dann wird die Bessel-Funktion @code{bessel_y} wie folgt als
ein Grenzwert definiert

@ifnottex
@example
      Y (z) = limit  Y (z)
       n      v -> n  v
@end example
@end ifnottex
@tex
$$Y_{n}(z)=\lim_{v\rightarrow n}{Y_{v}(z)}$$
@end tex

Die Bessel-Funktion @code{bessel_y} ist f@"ur das numerische und symbolische
Rechnen geeignet.

Maxima berechnet @code{bessel_y} numerisch f@"ur reelle und komplexe
Gleitkommazahlen als Argumente f@"ur @math{v} und @math{z}.  Mit der Funktion
@mref{float} oder der Optionsvariablen @mref{numer} kann die numerische
Auswertung erzwungen werden, wenn die Argumente ganze oder rationale Zahlen
sind.  Die numerische Berechnung f@"ur gro@ss{}e Gleitkommazahlen ist nicht
implementiert.  In diesem Fall gibt Maxima eine Substantivform zur@"uck.

@code{bessel_y} hat die folgenden Eigenschaften, die mit mit der Funktion
@mref{properties} angezeigt werden und auf das symbolische Rechnen Einfluss
haben:

@table @code
@item conjugate function
@code{bessel_y} hat Spiegelsymmetrie, wenn das Argument @var{z} keine negative
reelle Zahl ist.  Die Spiegelsymmetrie wird zum Beispiel von der Funktion
@mref{conjugate} f@"ur die Vereinfachung eines Ausdrucks genutzt.
@item complex characteristic
Maxima kennt den Realteil und den Imagin@"arteil von @code{bessel_y} f@"ur
spezielle Argumente @math{v} und @math{z}.
@item limit function
Maxima kennt spezielle Grenzwerte der Funktion @code{bessel_y}.
@item integral
Maxima kennt das Integral der Funktion @code{bessel_y} f@"ur die
Integrationsvariable @math{z}.
@item gradef
Maxima kennt die Ableitungen der Funktion @code{bessel_y} nach den
Argumenten @math{v} und @math{z}.
@end table

Die Vereinfachung der Bessel-Funktion @code{bessel_y} wird von den folgenden
Optionsvariablen kontrolliert:

@table @code
@item distribute_over
Hat die Optionsvariable @mref{distribute_over} den Wert @code{true} und sind
die Argumente von @code{bessel_y} eine Matrix, Liste oder Gleichung wird die
Funktion auf die Elemente oder beiden Seiten der Gleichung angewendet.  Der
Standardwert ist @code{true}.
@item besselexpand
Hat die Optionsvariable @mref{besselexpand} den Wert @code{true}, wird
@code{bessel_y} mit einer halbzahligen Ordnung @math{v} als Sinus- und
Kosinusfunktionen entwickelt.
@item bessel_reduce
Hat die Optionsvariable @mref{bessel_reduce} den Wert @code{true}, wird
@code{bessel_y} mit einer ganzzahligen Ordnung @math{n} nach Bessel-Funktionen
@code{bessel_y} mit der niedrigsten Ordnung @code{0} und @code{1} entwickelt.
@item hypergeometric_representation
Hat die Optionsvariable @mref{hypergeometric_representation} den Wert
@code{true}, dann wird @code{bessel_y} als hypergeometrische Funktion
dargestellt.  Es ist zu beachten, dass die hypergeometrische Funktion nur f@"ur
eine nicht ganzzahlige Ordnung @math{v} g@"ultig ist.
@end table

Weiterhin kennt Maxima die geraden und ungeraden Symmetrieeigenschaften von
@code{bessel_y}.  F@"ur eine ganze Zahl @math{n} vereinfacht daher
@code{bessel_y(-n, z)} zu @code{(-1)^n bessel_y(n, z)}.

Maxima kennt noch die Funktion @mrefcomma{spherical_bessel_y} die im Paket
@code{orthopoly} definiert ist.   Siehe auch die anderen Bessel-Funktionen
@mrefcomma{bessel_j} @mref{bessel_i} und @mref{bessel_k} sowie die
weiteren mit den Bessel-Funktionen verwandten Funktionen wie die
Hankel-Funktionen in @ref{Hankel-Funktionen}, Airy-Funktionen in
@ref{Airy-Funktionen} und Struve-Funktionen in @ref{Struve-Funktionen}.

Siehe die Funktion @mref{bessel_j} f@"ur Beispiele mit Bessel-Funktionen.
@end deffn

@c --- 13.07.2011 DK -----------------------------------------------------------
@anchor{bessel_i}
@deffn {Funktion} bessel_i (@var{v}, @var{z})

Die modifizierte Bessel-Funktion der ersten Art der Ordnung @math{v} mit dem 
Argument @math{v}.  @code{bessel_i} ist definiert als

@ifnottex
@example
               inf
               ====
               \              1            z 2 k + v
      I (z) =   >    -------------------  (-)
       v       /     k! gamma(v + k + 1)   2
               ====
               k = 0
@end example
@end ifnottex
@tex
$$I_{v}(z)=\sum_{k=0}^{\infty }{{{1}\over{k!\,\Gamma\left(v+k+1
 \right)}}}\,\left({{z}\over{2}}\right)^{2\,k+v}$$
@end tex

Die Reihenentwicklung wird nicht f@"ur die numerische Berechnung genutzt.

Die Bessel-Funktion @code{bessel_i} ist f@"ur das numerische und symbolische
Rechnen geeignet.

Maxima berechnet @code{bessel_i} numerisch f@"ur reelle und komplexe
Gleitkommazahlen als Argumente f@"ur @math{v} und @math{z}.  Mit der Funktion
@mref{float} oder der Optionsvariablen @mref{numer} kann die numerische
Auswertung erzwungen werden, wenn die Argumente ganze oder rationale Zahlen
sind.  Die numerische Berechnung f@"ur gro@ss{}e Gleitkommazahlen ist nicht
implementiert.  In diesem Fall gibt Maxima eine Substantivform zur@"uck.

@code{bessel_i} hat die folgenden Eigenschaften, die mit mit der Funktion
@mref{properties} angezeigt werden und auf das symbolische Rechnen Einfluss
haben:

@table @code
@item conjugate function
@code{bessel_i} hat Spiegelsymmetrie, wenn das Argument @var{z} keine negative
reelle Zahl ist.  Die Spiegelsymmetrie wird zum Beispiel von der Funktion
@mref{conjugate} f@"ur die Vereinfachung eines Ausdrucks genutzt.
@item complex characteristic
Maxima kennt den Realteil und den Imagin@"arteil von @code{bessel_i} f@"ur
spezielle Argumente @math{v} und @math{z}.
@item limit function
Maxima kennt spezielle Grenzwerte der Funktion @code{bessel_i}.
@item integral
Maxima kennt das Integral der Funktion @code{bessel_i} f@"ur die
Integrationsvariable @math{z}.
@item gradef
Maxima kennt die Ableitungen der Funktion @code{bessel_i} nach den
Argumenten @math{v} und @math{z}.
@end table

Die Vereinfachung der Bessel-Funktion @code{bessel_i} wird von den folgenden
Optionsvariablen kontrolliert:

@table @code
@item distribute_over
Hat die Optionsvariable @mref{distribute_over} den Wert @code{true} und sind
die Argumente von @code{bessel_i} eine Matrix, Liste oder Gleichung wird die
Funktion auf die Elemente oder beiden Seiten der Gleichung angewendet.  Der
Standardwert ist @code{true}.
@item besselexpand
Hat die Optionsvariable @mref{besselexpand} den Wert @code{true}, wird
@code{bessel_i} mit einer halbzahligen Ordnung @math{v} als Hyperbelfunktionen
entwickelt.
@item bessel_reduce
Hat die Optionsvariable @mref{bessel_reduce} den Wert @code{true}, wird
@code{bessel_i} mit einer ganzzahligen Ordnung @math{n} nach Bessel-Funktionen
@code{bessel_i} mit der niedrigsten Ordnung @code{0} und @code{1} entwickelt.
@item hypergeometric_representation
Hat die Optionsvariable @mref{hypergeometric_representation} den Wert
@code{true}, dann wird @code{bessel_i} als hypergeometrische Funktion
dargestellt.
@end table

Weiterhin kennt Maxima die geraden und ungeraden Symmetrieeigenschaften von
@code{bessel_i}.  F@"ur eine ganze Zahl @math{n} vereinfacht daher
@code{bessel_i(-n, z)} zu @code{bessel_i(n, z)}.

Siehe auch die anderen Bessel-Funktionen @mrefcomma{bessel_j}@w{}
@mref{bessel_y} und @mref{bessel_k} sowie die weiteren mit den Bessel-Funktionen
verwandten Funktionen wie die Hankel-Funktionen in @ref{Hankel-Funktionen},
Airy-Funktionen in @ref{Airy-Funktionen} und Struve-Funktionen in
@ref{Struve-Funktionen}.

Siehe die Funktion @mref{bessel_j} f@"ur Beispiele mit Bessel-Funktionen.
@end deffn

@c --- 13.07.2011 DK -----------------------------------------------------------
@anchor{bessel_k}
@deffn {Funktion} bessel_k (@var{v}, @var{z})

Die modifizierte Bessel-Funktion der zweiten Art der Ordnung @math{v} mit dem
Argument @math{z}.  @code{bessel_k} ist definiert als

@ifnottex
@example
              %pi csc(%pi u) (I   (z) - I (z))
                               - v       u
      K (z) = --------------------------------
       v                     2
@end example
@end ifnottex
@tex
$$K_{v}(z)={{\pi\,\csc \left(\pi\,u\right)\,\left(I_{-v}(z)-I_{u}(z)
 \right)}\over{2}}$$
@end tex

f@"ur den Fall, dass @math{v} keine ganze Zahl ist.  Ist @math{v} eine ganze
Zahl @math{n}, dann wird die Bessel-Funktion @code{bessel_k} wie folgt als
Grenzwert definiert

@ifnottex
@example
(%o5) K (z) = limit  K (z)
       n      v -> n  v
@end example
@end ifnottex
@tex
$$K_{n}(z)=\lim_{v\rightarrow n}{K_{v}(z)}$$
@end tex

Die Bessel-Funktion @code{bessel_k} ist f@"ur das numerische und symbolische
Rechnen geeignet.

Maxima berechnet @code{bessel_k} numerisch f@"ur reelle und komplexe
Gleitkommazahlen als Argumente f@"ur @math{v} und @math{z}.  Mit der Funktion
@mref{float} oder der Optionsvariablen @mref{numer} kann die numerische
Auswertung erzwungen werden, wenn die Argumente ganze oder rationale Zahlen
sind.  Die numerische Berechnung f@"ur gro@ss{}e Gleitkommazahlen ist nicht
implementiert.  In diesem Fall gibt Maxima eine Substantivform zur@"uck.

@code{bessel_k} hat die folgenden Eigenschaften, die mit mit der Funktion
@mref{properties} angezeigt werden und auf das symbolische Rechnen Einfluss
haben:

@table @code
@item conjugate function
@code{bessel_k} hat Spiegelsymmetrie, wenn das Argument @var{z} keine negative
reelle Zahl ist.  Die Spiegelsymmetrie wird zum Beispiel von der Funktion
@mref{conjugate} f@"ur die Vereinfachung eines Ausdrucks genutzt.
@item complex characteristic
Maxima kennt den Realteil und den Imagin@"arteil von @code{bessel_k} f@"ur
spezielle Argumente @math{v} und @math{z}.
@item limit function
Maxima kennt spezielle Grenzwerte der Funktion @code{bessel_k}.
@item integral
Maxima kennt das Integral der Funktion @code{bessel_k} f@"ur die
Integrationsvariable @math{z}.
@item gradef
Maxima kennt die Ableitungen der Funktion @code{bessel_k} nach den
Argumenten @math{v} und @math{z}.
@end table

Die Vereinfachung der Bessel-Funktion @code{bessel_k} wird von den folgenden
Optionsvariablen kontrolliert:

@table @code
@item distribute_over
Hat die Optionsvariable @mref{distribute_over} den Wert @code{true} und sind
die Argumente von @code{bessel_k} eine Matrix, Liste oder Gleichung wird die
Funktion auf die Elemente oder beiden Seiten der Gleichung angewendet.  Der
Standardwert ist @code{true}.
@item besselexpand
Hat die Optionsvariable @mref{besselexpand} den Wert @code{true}, wird
@code{bessel_k} mit einer halbzahligen Ordnung @math{v} als Exponentialfunktion
entwickelt.
@item bessel_reduce
Hat die Optionsvariable @mref{bessel_reduce} den Wert @code{true}, wird
@code{bessel_k} mit einer ganzzahligen Ordnung @math{n} nach Bessel-Funktionen
@code{bessel_k} mit der niedrigsten Ordnung @code{0} und @code{1} entwickelt.
@item hypergeometric_representation
Hat die Optionsvariable @mref{hypergeometric_representation} den Wert
@code{true}, dann wird @code{bessel_k} als hypergeometrische Funktion
dargestellt.  Es ist zu beachten, dass die hypergeometrische Funktion nur f@"ur
eine nicht ganzzahlige Ordnung @math{v} g@"ultig ist.
@end table

Weiterhin kennt Maxima die geraden und ungeraden Symmetrieeigenschaften von
@code{bessel_k}.  F@"ur eine ganze Zahl @math{n} vereinfacht daher
@code{bessel_k(-n, z)} zu @code{bessel_y(n, z)}.

Siehe auch die anderen Bessel-Funktionen @mrefcomma{bessel_j} @mref{bessel_y}
und @mref{bessel_i} sowie die weiteren mit den Bessel-Funktionen verwandten
Funktionen wie die Hankel-Funktionen in @ref{Hankel-Funktionen}, Airy-Funktionen
in @ref{Airy-Funktionen} und Struve-Funktionen in @ref{Struve-Funktionen}.

Siehe die Funktion @mref{bessel_j} f@"ur Beispiele mit Bessel-Funktionen.
@end deffn

@c --- 31.03.2011 DK -----------------------------------------------------------
@anchor{bessel_reduce}
@defvr {Optionsvariable} bessel_reduce
Standardwert: @code{false}

Hat die Optionsvariable @code{bessel_reduce} den Wert @code{true}, werden 
Bessel-Funktionen mit einer ganzzahligen Ordnung @math{n} nach Bessel-Funktionen
mit der niedrigsten Ordnung @math{0} und @math{1} entwickelt.
@end defvr

@c --- 31.03.2011 DK -----------------------------------------------------------
@anchor{besselexpand}
@defvr {Optionsvariable} besselexpand
Standardwert: @code{false}

Hat die Optionsvariable @code{besselexpand} den Wert @code{true}, werden
Bessel-Funktion mit einer halbzahligen Ordnung @math{v} als Sinus-,
Kosinus-, Hyperbel- oder Exponentialfunktionen entwickelt.  Die Optionsvariable
@code{besselexpand} kontrolliert auch die Entwicklung der Hankel-Funktionen
@mref{hankel_1} und @mref{hankel_2} sowie der Struve-Funktionen @mref{struve_h}
und @mrefdot{struve_l}

Beispiele:

@example
(%i1) besselexpand: false$

(%i2) bessel_j(3/2, z);
                                  3
(%o2)                    bessel_j(-, z)
                                  2
(%i3) besselexpand: true$

(%i4) bessel_j(3/2, z);
                                 sin(z)   cos(z)
                sqrt(2) sqrt(z) (------ - ------)
                                    2       z
                                   z
(%o4)           ---------------------------------
                            sqrt(%pi)
@end example

Weitere Beispiele f@"ur die Entwicklungen der Funktionen @mref{bessel_k} und
@mrefdot{struve_h}

@example
(%i5) bessel_k(3/2, z);
                                1        - z
                     sqrt(%pi) (- + 1) %e
                                z
(%o5)                -----------------------
                         sqrt(2) sqrt(z)

(%i6) struve_h(3/2, z);
                                           2
                  2 z sin(z) + 2 cos(z) - z  - 2
(%o6)           - ------------------------------
                                         3/2
                      sqrt(2) sqrt(%pi) z
@end example
@end defvr

@c --- 31.03.2011 DK -----------------------------------------------------------
@anchor{scaled_bessel_i}
@deffn {Funktion} scaled_bessel_i (@var{v}, @var{z}) 

Die skalierte modifizierte Bessel-Funktion der ersten Art der Ordnung
@math{v} mit dem Argument @math{z}.  Diese ist definiert als

@example
                                                - abs(z)
      scaled_bessel_i(v, z) = bessel_i(v, z) %e
@end example

@code{scaled_bessel_i} liefert ein numerisches Ergebnis, wenn die Argumente 
@math{v} und @math{z} Zahlen sind.  Die Funktion kann geeignet sein, wenn
@code{bessel_i} f@"ur gro@ss{}e Argumente @math{z} numerisch berechnet werden
soll.  Ganze, rationale oder gro@ss{}e Gleitkommazahlen werden in
Gleitkommazahlen mit doppelter Genauigkeit umgewandelt.  Sind die Argumente
keine Zahlen, wird ein vereinfachter Ausdruck mit der Funktion
@mref{bessel_i} zur@"uckgegeben.

@code{scaled_bessel_i} ist eine Verbfunktion, die nicht f@"ur das symbolische
Rechnen geeignet ist.  F@"ur das symbolische Rechnen ist die Funktion
@mref{bessel_i} zu verwenden.

Beispiele:

@example
(%i1) scaled_bessel_i(1, 50);
(%o1)                  .05599312389289544
(%i2) scaled_bessel_i(1/2, 50);
(%o2)                  .05641895835477567
(%i3) scaled_bessel_i(v, x);
                                     - abs(x)
(%o3)               bessel_i(v, x) %e
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{scaled_bessel_i0}
@deffn {Funktion} scaled_bessel_i0 (@var{z})

Entspricht @code{scaled_bessel_i(0,z)}.  Siehe @mrefdot{scaled_bessel_i}
@end deffn

@c -----------------------------------------------------------------------------
@anchor{scaled_bessel_i1}
@deffn {Funktion} scaled_bessel_i1 (@var{z}) 

Entspricht @code{scaled_bessel_i(1,z)}.  Siehe @mrefdot{scaled_bessel_i}
@end deffn

@c -----------------------------------------------------------------------------
@node Hankel-Funktionen, Airy-Funktionen, Bessel-Funktionen, Bessel-Funktionen und verwandte Funktionen
@subsection Hankel-Funktionen
@c -----------------------------------------------------------------------------

@c --- 13.07.2011 DK -----------------------------------------------------------
@anchor{hankel_1}
@deffn {Funktion} hankel_1 (@var{v}, @var{z})

Die Hankel-Funktion der ersten Art der Ordnung @math{v} mit dem Argument
@math{z}.  Siehe A@w{ }&@w{ }S 9.1.3.  @code{hankel_1} ist definiert als

@ifnottex
@example
      H1 (z) = J (z) + %i Y (z)
        v       v          v
@end example
@end ifnottex
@tex
$${\it H1}_{v}(z)=J_{v}(z)+i\,Y_{v}(z)$$
@end tex

Die Hankel-Funktion @code{hankel_1} ist f@"ur das numerische und symbolische
Rechnen geeignet.

Maxima berechnet @code{hankel_1} numerisch f@"ur reelle und komplexe
Gleitkommazahlen als Argumente f@"ur @math{v} und @math{z}.  Mit der Funktion
@mref{float} oder der Optionsvariablen @mref{numer} kann die numerische
Auswertung erzwungen werden, wenn die Argumente Zahlen sind.  Die numerische
Berechnung f@"ur gro@ss{}e Gleitkommazahlen ist nicht implementiert.  In diesem
Fall gibt Maxima eine Substantivform zur@"uck.

Hat die Optionsvariable @mref{besselexpand} den Wert @code{true}, werden
Hankel-Funktionen @code{hankel_1} mit einer halbzahligen Ordnung @math{v} als
Sinus- und Kosinusfunktionen entwickelt.

Maxima kennt die Ableitung der Hankel-Funktion @code{hankel_1} nach dem zweiten
Argument @code{z}.

Siehe auch die Funktion @mref{hankel_2} sowie die Bessel-Funktionen in
@ref{Bessel-Funktionen}.

Beispiele:

Numerische Berechnung.

@example
(%i1) hankel_1(1, 0.5);
(%o1)       .2422684576748738 - 1.471472392670243 %i
(%i2) hankel_1(1, 0.5+%i);
(%o2)      - .2558287994862166 %i - 0.239575601883016
@end example

F@"ur eine komplex Ordnung kann Maxima keinen numerischen Wert berechnet.  Das
Ergebnis ist eine Substantivform.

@example
(%i3) hankel_1(%i, 0.5+%i);
(%o3)                hankel_1(%i, %i + 0.5)
@end example

Entwicklung der Hankel-Funktion @code{hankel_1}, wenn die Optionsvariable
@code{besselexpand} den Wert @code{true} hat.

@example
(%i4) hankel_1(1/2, z), besselexpand:true;
               sqrt(2) sin(z) - sqrt(2) %i cos(z)
(%o4)          ----------------------------------
                       sqrt(%pi) sqrt(z)
@end example

Ableitung der Hankel-Funktion @code{hankel_1} nach dem Argument @var{z}.  Die
Ableitung nach der Ordnung @var{v} ist nicht implementiert.  Maxima gibt eine
Substantivform zur@"uck.

@example
(%i5)  diff(hankel_1(v,z), z);
             hankel_1(v - 1, z) - hankel_1(v + 1, z)
(%o5)        ---------------------------------------
                                2
(%i6)  diff(hankel_1(v,z), v);
                       d
(%o6)                  -- (hankel_1(v, z))
                       dv
@end example
@end deffn

@c --- 27.03.2011 DK -----------------------------------------------------------
@anchor{hankel_2}
@deffn {Funktion} hankel_2 (@var{v}, @var{z})

Die Hankel-Funktion der zweiten Art der Ordnung @math{v} mit dem Argument
@math{z}.  Siehe A@w{ }&@w{ }S 9.1.4.  @code{hankel_2} ist definiert als

@ifnottex
@example
      H2 (z) = J (z) - %i Y (z)
        v       v          v
@end example
@end ifnottex
@tex
$${\it H2}_{v}(z)=J_{v}(z)-i\,Y_{v}(z)$$
@end tex

Die Hankel-Funktion @code{hankel_2} ist f@"ur das numerische und symbolische
Rechnen geeignet.

Maxima berechnet @code{hankel_2} numerisch f@"ur reelle und komplexe
Gleitkommazahlen als Argumente f@"ur @math{v} und @math{z}.  Mit der Funktion
@mref{float} oder der Optionsvariablen @mref{numer} kann die numerische
Auswertung erzwungen werden, wenn die Argumente Zahlen sind.  Die numerische
Berechnung f@"ur gro@ss{}e Gleitkommazahlen ist nicht implementiert.  In diesem
Fall gibt Maxima eine Substantivform zur@"uck.

Hat die Optionsvariable @mref{besselexpand} den Wert @code{true}, werden
Hankel-Funktionen @code{hankel_2} mit einer halbzahligen Ordnung @math{v} als
Sinus- und Kosinusfunktionen entwickelt.

Maxima kennt die Ableitung der Hankel-Funktion @code{hankel_2} nach dem zweiten
Argument @code{z}.

F@"ur Beispiele siehe @mrefdot{hankel_1}  Siehe auch die Bessel-Funktionen in
@ref{Bessel-Funktionen}.
@end deffn

@c -----------------------------------------------------------------------------
@node Airy-Funktionen, Struve-Funktionen, Hankel-Funktionen, Bessel-Funktionen und verwandte Funktionen
@subsection Airy-Funktionen
@c -----------------------------------------------------------------------------

Die Airy-Funktionen @math{Ai(z)} und @math{Bi(z)} sind definiert in Abramowitz
und Stegun, @i{Handbook of Mathematical Functions}, Kapitel 10.4.  Die
Funktionen @code{y = Ai(z)} und @code{y = Bi(z)} sind zwei linear unabh@"angige
L@"osungen der Airy-Differentialgleichung.

@example
       2
      d y
      --- - y z = 0
        2
      dz
@end example

@c --- 14.07.2011.2011 DK -----------------------------------------------------------
@anchor{airy_ai}
@deffn {Funktion} airy_ai (@var{z})

Die Airy-Funktion @math{Ai(z)} (A & S 10.4.2).

Die Airy-Funktion @code{airy_ai} ist f@"ur das symbolische und numerische
Rechnen geeignet.  Ist das Argument @code{z} eine reelle oder komplexe
Gleitkommazahl, wird @code{airy_ai} numerisch berechnet.  Mit der
Optionsvariablen @mref{numer} oder der Funktion @mref{float} kann die
numerische Berechnung erzwungen werden, wenn das Argument eine ganze oder
rationale Zahl ist.  Die numerische Berechnung f@"ur gro@ss{}e Gleitkommazahlen
ist nicht implementiert.

Maxima kennt den speziellen Wert f@"ur das Argument @code{0}.

Ist das Argument eine Liste, Matrix oder Gleichung wird die Funktion
@code{airy_ai} auf die Elemente der Liste oder beide Seiten der Gleichung
angewendet.  Siehe auch @mrefdot{distribute_over}

Die Ableitung @code{diff(airy_ai(z), z)} ist als @code{airy_dai(z)}
implementiert.  Siehe die Funktion @mrefdot{airy_dai}

Weiterhin kennt Maxima das Integral der Airy-Funktion @code{airy_ai}.

Siehe auch die Funktionen @mref{airy_bi} und @mrefdot{airy_dbi}

Beispiele:

Numerische Berechnung f@"ur Gleitkommazahlen.  F@"ur ganze und rationale Zahlen
wird eine Substantivform zur@"uckgegeben.  Maxima kennt den speziellen Wert
f@"ur das Argument @code{0}.

@example
(%i1) airy_ai([0.5, 1.0+%i]);
(%o1) [.2316936064808335, .06045830837183824
                                          - .1518895658771814 %i]
(%i2) airy_ai([1, 1/2]);
@group
                                         1
(%o2)               [airy_ai(1), airy_ai(-)]
                                         2
@end group
(%i3) airy_ai(0);
                                1
(%o3)                     -------------
                           2/3       2
                          3    gamma(-)
                                     3
@end example

Ableitungen und Integral der Airy-Funktion @code{airy_ai}.

@example
(%i4) diff(airy_ai(z), z);
(%o4)                      airy_dai(z)
(%i5) diff(airy_ai(z), z, 2);
(%o5)                     z airy_ai(z)
(%i6) diff(airy_ai(z), z, 3);
(%o6)              z airy_dai(z) + airy_ai(z)
(%i7) integrate(airy_ai(z), z);
                                   3
                      1    2  4   z
      hypergeometric([-], [-, -], --) z
                      3    3  3   9
(%o7) ---------------------------------
                 2/3       2
                3    gamma(-)
                           3
                                                            3
                  1/6       2                  2    4  5   z    2
                 3    gamma(-) hypergeometric([-], [-, -], --) z
                            3                  3    3  3   9
               - ------------------------------------------------
                                      4 %pi
@end example
@end deffn

@c --- 14.07.2011 DK -----------------------------------------------------------
@anchor{airy_dai}
@deffn {Funktion} airy_dai (@var{z})

Die Ableitung der Airy-Funktion @mrefdot{airy_ai}

Die Ableitung der Airy-Funktion @code{airy_dai} ist f@"ur das symbolische und
numerische Rechnen geeignet.  Ist das Argument @var{z} eine reelle oder
komplexe Gleitkommazahl, wird @code{airy_dai} numerisch berechnet.  Mit der
Optionsvariablen @mref{numer} oder der Funktion @mref{float} kann die
numerische Berechnung erzwungen werden, wenn das Argument eine ganze oder
rationale Zahl ist.  Die numerische Berechnung f@"ur gro@ss{}e Gleitkommazahlen
ist nicht implementiert.

Maxima kennt den speziellen Wert f@"ur das Argument @code{0}.

Ist das Argument eine Liste, Matrix oder Gleichung wird die Funktion
@code{airy_dai} auf die Elemente der Liste oder beide Seiten der Gleichung
angewendet.  Siehe auch @mrefdot{distribute_over}

Maxima kennt die Ableitung und das Integral der Funktion @code{airy_dai}.

Siehe auch die Airy-Funktionen @mref{airy_bi} und @mrefdot{airy_dbi}

F@"ur Beispiele siehe die Funktion @mrefdot{airy_ai}
@end deffn

@c --- 14.07.2011 DK -----------------------------------------------------------
@need 1000
@anchor{airy_bi}
@deffn {Funktion} airy_bi (@var{z})

Die Airy-Funktion Bi(z) (A & S 10.4.3).

Die Airy-Funktion @code{airy_bi} ist f@"ur das symbolische und numerische
Rechnen geeignet.  Ist das Argument @code{z} eine reelle oder komplexe
Gleitkommazahl, wird @code{airy_bi} numerisch berechnet.  Mit der
Optionsvariablen @mref{numer} oder der Funktion @mref{float} kann die
numerische Berechnung erzwungen werden, wenn das Argument eine ganze oder
rationale Zahl ist.  Die numerische Berechnung f@"ur gro@ss{}e Gleitkommazahlen
ist nicht implementiert.

Maxima kennt den speziellen Wert f@"ur das Argument @code{0}.

Ist das Argument eine Liste, Matrix oder Gleichung wird die Funktion
@code{airy_bi} auf die Elemente der Liste oder beide Seiten der Gleichung
angewendet.  Siehe auch @mrefdot{distribute_over}

Die Ableitung @code{diff(airy_bi(z), z)} ist als @code{airy_dbi(z)}
implementiert.  Siehe die Funktion @mrefdot{airy_dbi}

Weiterhin kennt Maxima das Integral der Airy-Funktion @code{airy_bi}.

Siehe auch die Funktionen @mref{airy_ai} und @mrefdot{airy_dai}

F@"ur Beispiele siehe die Funktion @mrefdot{airy_ai}
@end deffn

@c --- 14.07.2011 DK -----------------------------------------------------------
@anchor{airy_dbi}
@deffn {Funktion} airy_dbi (@var{z})

Die Ableitung der Airy-Funktion @mrefdot{airy_bi}

Die Ableitung der Airy-Funktion @code{airy_dbi} ist f@"ur das symbolische und
numerische Rechnen geeignet.  Ist das Argument @var{z} eine reelle oder
komplexe Gleitkommazahl, wird @code{airy_dbi} numerisch berechnet.  Mit der
Optionsvariablen @mref{numer} oder der Funktion @mref{float} kann die
numerische Berechnung erzwungen werden, wenn das Argument eine ganze oder
rationale Zahl ist.  Die numerische Berechnung f@"ur gro@ss{}e Gleitkommazahlen
ist nicht implementiert.

Maxima kennt den speziellen Wert f@"ur das Argument @code{0}.

Ist das Argument eine Liste, Matrix oder Gleichung wird die Funktion
@code{airy_dbi} auf die Elemente der Liste oder beide Seiten der Gleichung
angewendet.  Siehe auch @mrefdot{distribute_over}

Maxima kennt die Ableitung und das Integral der Funktion @code{airy_dbi}.

Siehe auch die Airy-Funktionen @mref{airy_ai} und @mrefdot{airy_dai}

F@"ur Beispiele siehe die Funktion @mrefdot{airy_ai}
@end deffn

@c -----------------------------------------------------------------------------
@node Struve-Funktionen, , Airy-Funktionen, Bessel-Funktionen und verwandte Funktionen
@subsection Struve-Funktionen
@c -----------------------------------------------------------------------------

@c --- 27.03.2011---------------------------------------------------------------
@anchor{struve_h}
@deffn {Funktion} struve_h (@var{v}, @var{z})

Die Struve-Funktion @math{H} der Ordnung @math{v} mit dem Argument
@math{z}.  Siehe Abramowitz und Stegun, Handbook of Mathematical Functions,
Kapitel 12.  Die Definition ist

@ifnottex
@example
                       inf
                       ====                  k  2 k
               z v + 1 \                (- 1)  z
      H (z) = (-)       >    ----------------------------------
       v       2       /      2 k           3                3
                       ====  2    gamma(k + -) gamma(v + k + -)
                       k = 0                2                2
@end example
@end ifnottex
@tex
$$H_{v}(z)=\left({{z}\over{2}}\right)^{v+1}\,\sum_{k=0}^{\infty }{{{\left(-1
 \right)^{k}\,z^{2\,k}}\over{2^{2\,k}\,\Gamma\left(k+{{3}\over{2}}
 \right)\,\Gamma\left(v+k+{{3}\over{2}}\right)}}}$$
@end tex

Die Struve-Funktion @code{struve_h} ist f@"ur das numerische und symbolische
Rechnen geeignet.  Im Unterschied zu den @nref{Bessel-Funktionen} ist jedoch
die Implementation der Funktion @code{struve_h} weniger vollst@"andig.

Maxima berechnet @code{struve_h} numerisch f@"ur reelle und komplexe
Gleitkommazahlen als Argumente f@"ur @math{v} und @math{z}.  Mit der Funktion
@mref{float} oder der Optionsvariablen @mref{numer} kann die numerische
Auswertung erzwungen werden, wenn die Argumente Zahlen sind.  Die numerische
Berechnung f@"ur gro@ss{}e Gleitkommazahlen ist nicht implementiert.  In diesem
Fall gibt Maxima eine Substantivform zur@"uck.

Hat die Optionsvariable @mref{besselexpand} den Wert @code{true}, wird die
Struve-Funktion @code{struve_h} mit einer halbzahligen Ordnung @math{v} als
Sinus- und Kosinusfunktionen entwickelt.

Maxima kennt die Ableitung der Struve-Funktion @code{struve_h} nach dem
Argument @math{z}.

Siehe auch die Struve-Funktion @mrefdot{struve_l}

Beispiele:

@example
(%i1) struve_h(1, 0.5);
(%o1)                  .05217374424234107
(%i2) struve_h(1, 0.5+%i);
(%o2)       0.233696520211436 %i - .1522134290663428
(%i3) struve_h(3/2,x), besselexpand: true;
                                           2
                  2 x sin(x) + 2 cos(x) - x  - 2
(%o3)           - ------------------------------
                                         3/2
                      sqrt(2) sqrt(%pi) x
(%i4) diff(struve_h(v, x), x);
                   v
                  x
(%o4) (------------------------- - struve_h(v + 1, x)
                  v           3
       sqrt(%pi) 2  gamma(v + -)
                              2
                                          + struve_h(v - 1, x))/2
@end example
@end deffn

@c --- 27.03.2011 DK -----------------------------------------------------------
@anchor{struve_l}
@deffn {Funktion} struve_l (@var{v}, @var{z})

Die modifizierte Struve-Funktion @math{L} der Ordnung @math{v} mit dem Argument
@math{z}.  Siehe Abramowitz und Stegun, Handbook of Mathematical Functions, 
Kapitel 12.  Die Definition ist

@ifnottex
@example
                       inf
                       ====                  2 k
               z v + 1 \                    z
      L (z) = (-)       >    ----------------------------------
       v       2       /      2 k           3                3
                       ====  2    gamma(k + -) gamma(v + k + -)
                       k = 0                2                2
@end example
@end ifnottex
@tex
$$L_{v}(z)=\left({{z}\over{2}}\right)^{v+1}\,\sum_{k=0}^{\infty }{{{z^{2\,k}
 }\over{2^{2\,k}\,\Gamma\left(k+{{3}\over{2}}\right)\,\Gamma\left(v+k
 +{{3}\over{2}}\right)}}}$$
@end tex

Die Struve-Funktion @code{struve_l} ist f@"ur das numerische und symbolische
Rechnen geeignet.  Im Unterschied zu den @nref{Bessel-Funktionen} ist jedoch
die Implementation der Funktion @code{struve_l} weniger vollst@"andig.

Maxima berechnet @code{struve_l} numerisch f@"ur reelle und komplexe
Gleitkommazahlen als Argumente f@"ur @math{v} und @math{z}.  Mit der Funktion
@mref{float} oder der Optionsvariablen @mref{numer} kann die numerische
Auswertung erzwungen werden, wenn die Argumente Zahlen sind.  Die numerische
Berechnung f@"ur gro@ss{}e Gleitkommazahlen ist nicht implementiert.  In diesem
Fall gibt Maxima eine Substantivform zur@"uck.

Hat die Optionsvariable @mref{besselexpand} den Wert @code{true}, wird die
Struve-Funktion @code{struve_l} mit einer halbzahligen Ordnung @math{v} als
Sinus- und Kosinusfunktionen entwickelt.

Maxima kennt die Ableitung der Struve-Funktion @code{struve_l} nach dem
Argument @math{z}.

Siehe auch die Struve-Funktion @mrefdot{struve_h}

Beispiele:

@example
(%i1) struve_l(1, 0.5);
(%o1)                  .05394218262352267
(%i2) struve_l(1, 0.5+%i);
(%o2)       .1912720461247995 %i - .1646185598117401
(%i3) struve_l(3/2,x), besselexpand: true;
                                           2
                2 x sinh(x) - 2 cosh(x) - x  + 2
(%o3)           --------------------------------
                                        3/2
                     sqrt(2) sqrt(%pi) x
(%i4) diff(struve_l(v, x), x);
                   v
                  x
(%o4) (------------------------- + struve_l(v + 1, x)
                  v           3
       sqrt(%pi) 2  gamma(v + -)
                              2
                                          + struve_l(v - 1, x))/2
@end example
@end deffn

@c -----------------------------------------------------------------------------
@node Gammafunktionen und verwandte Funktionen, Exponentielle Integrale, Bessel-Funktionen und verwandte Funktionen, Spezielle Funktionen
@section Gammafunktionen und verwandte Funktionen
@c -----------------------------------------------------------------------------

Die Gammafunktion und die verwandten Funktionen wie die Beta-, Psi- und die
unvollst@"andige Gammafunktion sind definiert in Abramowitz and Stegun,
@i{Handbook of Mathematical Functions}, Kapitel 6.

@c --- 29.05.2011 DK -----------------------------------------------------------
@anchor{bffac}
@deffn {Funktion} bffac (@var{x}, @var{fpprec})

Berechnet die Fakult@"at f@"ur gro@ss{}e Gleitkommazahlen.  Das Argument @var{x}
muss eine gro@ss{}e Gleitkommazahl sein.  Das zweite Argument @var{fpprec} ist
die Anzahl der Stellen, f@"ur die die Fakult@"at berechnet wird.  Das Ergebnis
ist eine gro@ss{}e Gleitkommazahl.

F@"ur das symbolische Rechnen mit der Fakult@"at und der Gammafunktion siehe die
entsprechenden Funktionen @mref{factorial} und @mrefdot{gamma}  Maxima ruft
intern die Funktion @code{bffac} auf, um die Fakult@"at @code{factorial} und
die Gammafunktion @code{gamma} f@"ur eine gro@ss{}e Gleitkommazahl numerisch zu
berechnen.

Siehe auch die Funktion @mref{cbffac} f@"ur die Berechnung der Fakult@"at f@"ur
komplexe gro@ss{}e Gleitkommazahlen.

Beispiel:

@example
(%i1) bffac(10.5b0, 25);
(%o1)             1.189942308396224845701304b7
(%i2) fpprec:25$
(%i3) 10.5b0!;
(%o3)             1.189942308396224845701303b7
@end example
@end deffn

@c --- 29.05.2011 DK -----------------------------------------------------------
@anchor{bfpsi}
@deffn  {Funktion} bfpsi (@var{n}, @var{x}, @var{fpprec})
@deffnx {Funktion} bfpsi0 (@var{x}, @var{fpprec})

@code{bfpsi} ist die Polygammafunktion f@"ur ein reelles Argument @var{x} und
einer ganzzahligen Ordnung @var{n}.  @code{bfpsi0} ist die Digammafunktion.
@code{bfpsi0(@var{x}, @var{fpprec})} ist @"aquivalent zu @code{bfpsi(0, @var{x},
@var{fpprec})}.

Das Argument @var{x} der Funktionen @code{bfpsi} und @code{bfpsi0} muss eine
gro@ss{}e Gleitkommazahl sein.  Das Argument @var{fpprec} gibt die Anzahl der
Stellen an, f@"ur die die Funktion berechnet wird.  Das Ergebnis ist eine
gro@ss{}e Gleitkommazahl.

F@"ur das symbolische Rechnen mit der Polygammafunktion siehe die Funktion
@mrefdot{psi}  Maxima ruft intern die Funktion @code{bfpsi} auf, um die
Polygammafunktion f@"ur gro@ss{}e Gleitkommazahlen numerisch zu berechnen.

Beispiel:

@example
(%i1) bfpsi(0, 1, 25);
(%o1)            - 5.772156649015328606065121b-1
(%i2) fpprec:25$

(%i3) psi[0](1.0b0);
(%o3)            - 5.772156649015328606065121b-1
@end example
@end deffn

@c --- 29.05.2011 DK -----------------------------------------------------------
@anchor{cbffac}
@deffn {Funktion} cbffac (@var{z}, @var{fpprec})

Berechnet die Fakult@"at f@"ur komplexe gro@ss{}e Gleitkommazahlen.  Das
Argument @var{z} ist eine komplexe gro@ss{}e Gleitkommazahl.  Das zweite
Argument @var{fpprec} ist die Anzahl der Stellen, f@"ur die die Fakult@"at
berechnet wird.  Das Ergebnis ist eine komplexe gro@ss{}e Gleitkommazahl.

F@"ur das symbolische Rechnen mit der Fakult@"at und der Gammafunktion siehe die
entsprechenden Funktionen @mref{factorial} und @mrefdot{gamma}  Maxima ruft
intern die Funktion @code{cbffac} auf, um die Fakult@"at @code{factorial} und
die Gammafunktion @code{gamma} f@"ur eine komplexe gro@ss{}e Gleitkommazahl
numerisch zu berechnen.

Siehe auch die Funktion @mrefdot{bffac}
@end deffn

@c --- 29.05.2011 DK -----------------------------------------------------------
@anchor{gamma}
@deffn {Funktion} gamma (@var{z})

Die Definition der Gammafunktion ist (A & S 6.1.1)

@example
                       inf
                      /
                      [     z - 1   - t
           gamma(z) = I    t      %e    dt
                      ]
                      /
                       0
@end example

Die Gammafunktion @code{gamma} ist f@"ur das numerische und symbolische Rechnen
geeignet.  F@"ur positive ganze Zahlen und rationale Zahlen als Argument @var{z}
wird die Gammafunktion vereinfacht.  F@"ur halbzahlige rationale Zahlen ist das
Ergebnis der Vereinfachung eine rationale Zahl multipliziert mit
@code{sqrt(%pi)}.  Die Vereinfachung f@"ur ganze Zahlen wird von der
Optionsvariablen @mref{factlim} kontrolliert.  F@"ur ganze Zahlen, die
gr@"o@ss{}er als @code{factlim} sind, kann es zu einem @"Uberlauf bei der
Berechnung der Gammafunktion kommen.  Entsprechend wird die Vereinfachung f@"ur
rationale Zahlen von der Optionsvariablen @mref{gammalim} kontrolliert.

F@"ur negative ganze Zahlen ist die Gammafunktion @code{gamma} nicht definiert.

Maxima berechnet @code{gamma} numerisch f@"ur reelle und komplexe Argumente
@var{z}.  Das Ergebnis ist eine reelle oder komplexe Gleitkommazahl.

@code{gamma} hat Spiegelsymmetrie.

Hat die Optionsvariable @mref{gamma_expand} den Wert @code{true}, entwickelt
Maxima die Gammafunktion f@"ur Argumente der Form @code{z+n} und @code{z-n},
wobei @var{n} eine ganze Zahl ist.

Maxima kennt die Ableitung der Gammafunktion @code{gamma}.

Siehe auch die Funktion @mrefcomma{makegamma} um Fakult@"aten und
Betafunktionen in einem Ausdruck durch die Gammafunktion zu ersetzen.

Die Euler-Mascheroni-Konstante ist @mrefdot{%gamma}

Beispiele:

Vereinfachung f@"ur ganze Zahlen und rationale Zahlen.

@example
(%i1) map('gamma,[1,2,3,4,5,6,7,8,9]);
(%o1)        [1, 1, 2, 6, 24, 120, 720, 5040, 40320]
(%i2) map('gamma,[1/2,3/2,5/2,7/2]);
                    sqrt(%pi)  3 sqrt(%pi)  15 sqrt(%pi)
(%o2)   [sqrt(%pi), ---------, -----------, ------------]
                        2           4            8
(%i3) map('gamma,[2/3,5/3,7/3]);
                                  2           1
                          2 gamma(-)  4 gamma(-)
                      2           3           3
(%o3)          [gamma(-), ----------, ----------]
                      3       3           9
@end example

Numerische Berechnung f@"ur reelle und komplexe Argumente.

@example
(%i4) map('gamma,[2.5,2.5b0]);
(%o4)     [1.329340388179137, 1.3293403881791370205b0]
(%i5) map('gamma,[1.0+%i,1.0b0+%i]);
(%o5) [0.498015668118356 - .1549498283018107 %i, 
          4.9801566811835604272b-1 - 1.5494982830181068513b-1 %i]
@end example

@code{gamma} hat Spiegelsymmetrie.

@example
(%i6) declare(z,complex)$
(%i7) conjugate(gamma(z));
(%o7)                  gamma(conjugate(z))
@end example

Maxima entwickelt @code{gamma(z+n)} und @code{gamma(z-n)}, wenn die
Optionsvariable @code{gamma_expand} den Wert @code{true} hat.

@example
(%i8) gamma_expand:true$

(%i9) [gamma(z+1),gamma(z-1),gamma(z+2)/gamma(z+1)];
@group
                               gamma(z)
(%o9)             [z gamma(z), --------, z + 1]
                                z - 1
@end group
@end example

Die Ableitung der Gammafunktion @code{gamma}.

@example
(%i10) diff(gamma(z),z);
(%o10)                  psi (z) gamma(z)
                           0
@end example
@end deffn

@c --- 29.05.2011 DK -----------------------------------------------------------
@anchor{gamma_expand}
@defvr {Optionsvariable} gamma_expand
Standardwert: @code{false}

Kontrolliert die Vereinfachung der Gammafunktion @mref{gamma} und verwandte
Funktionen wie @mref{gamma_incomplete} f@"ur den Fall, dass das Argument die
Form @code{z+n} oder @code{z-n} hat.  Dabei ist @code{z} ist ein beliebiges
Argument und @code{n} ist eine ganze Zahl.

Siehe die Funktion @code{gamma} f@"ur ein Beispiel.
@end defvr

@c --- 29.05.2011 DK -----------------------------------------------------------
@anchor{log_gamma}
@deffn {Funktion} log_gamma (@var{z})

Der Logarithmus der Gammafunktion.
@end deffn

@c --- 29.05.2011 DK -----------------------------------------------------------
@anchor{gamma_incomplete}
@deffn {Funktion} gamma_incomplete (@var{a}, @var{z})

Die unvollst@"andige Gammafunktion (A & S 6.5.2) die definiert ist als

@tex
$$\int_{z}^{\infty }{t^{a-1}\,e^ {- t }\;dt}$$
@end tex
@ifnottex
@example
                  inf
                 /
                 [     a - 1   - t
                 I    t      %e    dt
                 ]
                 /
                  z
@end example
@end ifnottex
@end deffn

@c --- 29.05.2011 DK -----------------------------------------------------------
@anchor{gamma_incomplete_regularized}
@deffn {Funktion} gamma_incomplete_regularized (@var{a}, @var{z})

Regularisierte unvollst@"andige Gammafunktion (A & S 6.5.1)

@tex
$${{{\it gamma\_incomplete}\left(a , z\right)}\over{\Gamma\left(a
 \right)}}$$
@end tex
@ifnottex
@example
               gamma_incomplete(a, z)
               ----------------------
                      gamma(a)
@end example
@end ifnottex
@end deffn

@c --- 29.05.2011 DK -----------------------------------------------------------
@anchor{gamma_incomplete_generalized}
@deffn {Funktion} gamma_incomplete_generalized (@var{a}, @var{z1}, @var{z2})

Verallgemeinerte unvollst@"andige Gammafunktion

@tex
$$\int_{z1}^{z2}{t^{a-1}\,e^ {- t }\;dt}$$
@end tex
@ifnottex
@example
                  z2
                 /
                 [    a - 1   - t
                 I   t      %e    dt
                 ]
                 /
                  z1
@end example
@end ifnottex
@end deffn

@c --- 29.05.2011 DK -----------------------------------------------------------
@anchor{gammalim}
@defvr {Optionsvariable} gammalim
Standardwert: 1000000

Kontrolliert die Vereinfachung der Gammafunktion f@"ur rationale Argumente.
Ist der Betrag des Arguments der Gammafunktion gr@"o@ss{}er als @code{gammalim},
wird die Gammafunktion nicht vereinfacht.  Damit wird verhindert, dass
die Berechnung der Gammafunktion zu einem @"Uberlauf f@"uhrt und mit einem
Fehler abbricht.

Siehe auch die Optionsvariable @mrefcomma{factlim} um die Vereinfachung f@"ur
ganze Zahlen zu kontrollieren.
@end defvr

@c --- 29.05.2011 DK -----------------------------------------------------------
@anchor{makegamma}
@deffn {Funktion} makegamma (@var{expr})

Ersetzt Fakult@"aten sowie Binomial- und Betafunktionen durch die Gammafunktion
@mref{gamma} im Ausdruck @var{expr}.

Siehe auch die Funktion @mrefcomma{makefact} um stattdessen Fakult@"aten in den
Ausdruck einzusetzen.

Beispiel:

@example
(%i1) expr: binomial(a,b)*gamma(b+1)/gamma(a+1);
                   binomial(a, b) gamma(b + 1)
(%o1)              ---------------------------
                          gamma(a + 1)
(%i2) makegamma(expr);
                               1
(%o2)                  ------------------
                       gamma(- b + a + 1)
@end example
@end deffn

@c --- 29.05.2011 DK -----------------------------------------------------------
@anchor{beta}
@deffn {Funktion} beta (@var{a}, @var{b})

Die Betafunktion ist definiert als @code{gamma(a) gamma(b)/gamma(a+b)}
(A & S 6.2.1).

Maxima vereinfacht die Betafunktion f@"ur positive ganze Zahlen @var{a} und
@var{b} sowie rationale Zahlen, deren Summe @code{@var{a} + @var{b}} eine ganze
Zahl ist.  Hat die Optionsvariable @mref{beta_args_sum_to_integer} den Wert
@code{true}, vereinfacht Maxima die Betafunktion f@"ur allgemeine Ausdr@"ucke
@var{a} und @var{b}, deren Summe eine ganze Zahl ist.

Ist eines der Argumente @var{a} oder @var{b} Null, ist die Betafunktion nicht
definiert.

Im allgemeinen ist die Betafunktion nicht definiert f@"ur negative ganze Zahlen
als Argument.  Ausnahme ist der Fall, dass @var{a = -n}, wobei @var{n} eine
positive ganze Zahl und @var{b} eine positive ganze Zahl mit @var{b <= b} ist.
In diesem Fall kann eine analytische Fortsetzung der Betafunktion definiert
werden.  Maxima gibt f@"ur diesen Fall ein Ergebnis zur@"uck.

Hat die Optionsvariable @code{beta_expand} den Wert @code{true}, werden
Ausdr@"ucke wie @code{beta(a+n, b} und @code{beta(a-n, b)} oder
@code{beta(a, b+n} und @code{beta(a, b-n)} entwickelt.

Maxima berechnet die Betafunktion f@"ur reelle und komplexe Gleitkommazahlen
numerisch.  F@"ur die numerische Berechnung nutzt Maxima die Funktion
@mref{log_gamma}:

@example
           - log_gamma(b + a) + log_gamma(b) + log_gamma(a)
         %e
@end example

Maxima kennt Symmetrieeigenschaften der Betafunktion.  Die Betafunktion ist
symmetrisch und hat Spiegelsymmetrie.

Maxima kennt die Ableitung der Betafunktion nach den Argumenten @var{a} und
@var{b}.

Mit der Funktion @mref{makegamma} kann die Betafunktion durch Gammafunktionen
ersetzt werden.  Entsprechend ersetzt die Funktion @mref{makefact}@w{}
Betafunktionen in einem Ausdruck durch Fakult@"aten.

Beispiele:

Vereinfachung der Betafunktion, wenn eines der Argumente eine ganze Zahl ist.

@example
(%i1) [beta(2,3),beta(2,1/3),beta(2,a)];
@group
                               1   9      1
(%o1)                         [--, -, ---------]
                               12  4  a (a + 1)
@end group
@end example

Vereinfachung der Betafunktion f@"ur zwei rationale Argumente, die sich zu
einer ganzen Zahl summieren.

@example
(%i2) [beta(1/2,5/2),beta(1/3,2/3),beta(1/4,3/4)];
                          3 %pi   2 %pi
(%o2)                    [-----, -------, sqrt(2) %pi]
                            8    sqrt(3)
@end example

Hat die Optionsvariable @code{beta_args_sum_to_integer} den Wert @code{true},
vereinfacht die Betafunktion f@"ur allgemeine Ausdr@"ucke, die sich zu einer
ganzen Zahl summieren.

@example
(%i3) beta_args_sum_to_integer:true$
(%i4) beta(a+1,-a+2);
                                %pi (a - 1) a
(%o4)                         ------------------
                              2 sin(%pi (2 - a))
@end example

Die m@"oglichen Ergebnisse, wenn eines der Argumente eine negative ganze
Zahl ist.

@example
(%i5) [beta(-3,1),beta(-3,2),beta(-3,3)];
                                    1  1    1
(%o5)                            [- -, -, - -]
                                    3  6    3
@end example

Vereinfachungen, wenn die Optionsvariable @code{beta_expand} den Wert
@code{true} hat.

@example
(%i6) beta_expand:true$
(%i7) [beta(a+1,b),beta(a-1,b),beta(a+1,b)/beta(a,b+1)];
                    a beta(a, b)  beta(a, b) (b + a - 1)  a
(%o7)              [------------, ----------------------, -]
                       b + a              a - 1           b

@end example

Die Betafunktion ist nicht definiert, wenn eines der Argumente Null ist.

@example
(%i7) beta(0,b);
beta: expected nonzero arguments; found 0, b
 -- an error.  To debug this try debugmode(true);
@end example

Numerische Berechnung der Betafunktion f@"ur reelle und komplexe Argumente.

@example
(%i8) beta(2.5,2.3);
(%o8) .08694748611299981

(%i9) beta(2.5,1.4+%i);
(%o9) 0.0640144950796695 - .1502078053286415 %i

(%i10) beta(2.5b0,2.3b0);
(%o10) 8.694748611299969b-2

(%i11) beta(2.5b0,1.4b0+%i);
(%o11) 6.401449507966944b-2 - 1.502078053286415b-1 %i
@end example

Die Betafunktion ist symmetrisch und hat Spiegelsymmetrie.

@example
(%i14) beta(a,b)-beta(b,a);
(%o14)                                 0
(%i15) declare(a,complex,b,complex)$
(%i16) conjugate(beta(a,b));
(%o16)                 beta(conjugate(a), conjugate(b))
@end example

Ableitung der Betafunktion.

@example
(%i17) diff(beta(a,b),a);
(%o17)               - beta(a, b) (psi (b + a) - psi (a))
                                      0             0
@end example
@end deffn

@c --- 29.05.2011 DK -----------------------------------------------------------
@anchor{beta_incomplete}
@deffn {Funktion} beta_incomplete (@var{a}, @var{b}, @var{z})

Die Definition der unvollst@"andigen Betafunktion ist (A & S 6.6.1)

@example
                       z
                      /
                      [         b - 1  a - 1
                      I  (1 - t)      t      dt
                      ]
                      /
                       0
@end example

Diese Definition ist m@"oglich f@"ur @math{realpart(a)>0} und
@math{realpart(b)>0} sowie @math{abs(z)<1}.  F@"ur andere Werte kann die
unvollst@"andige Betafunktion als eine verallgemeinerte Hypergeometrische
Funktion definiert werden:

@example
   gamma(a) hypergeometric_generalized([a, 1 - b], [a + 1], z) z
@end example

(Siehe functions.wolfram.com f@"ur eine Definition der unvollst@"andigen
Betafunktion.)

F@"ur negative ganze Zahlen @math{a = -n} und positive ganze Zahlen
@math{b = m} mit @math{m <= n} kann die unvollst@"andige Betafunktion definiert
werden als

@example
                            m - 1           k
                            ====  (1 - m)  z
                      n - 1 \            k
                     z       >    -----------
                            /     k! (n - k)
                            ====
                            k = 0
@end example

Maxima nutzt diese Definition, um die Funktion @code{beta_incomplete} f@"ur
negative ganzzahlige Argumente @var{a} zu vereinfachen.

F@"ur positive ganzzahlige Argumente @var{a} vereinfacht @code{beta_incomplete}
f@"ur jedes Argument @var{b} und @var{z}.  Entsprechend vereinfacht
@code{beta_incomplete} f@"ur ein positives ganzzahliges Argument @var{b} mit
der Ausnahme, dass @var{a} eine negative ganze Zahl ist.

F@"ur @math{z=0} und @math{realpart(a) > 0} hat @code{beta_incomplete} den
speziellen Wert Null.  F@"ur @var{z=1} und @math{realpart(b) > 0} vereinfacht
@code{beta_incomplete} zu einem Ausdruck mit der Betafunktion @code{beta(a, b)}.

Maxima berechnet @code{beta_incomplete} numerisch f@"ur reelle und komplexe
Gleitkommazahlen als Argumente.  F@"ur die numerische Berechnung nutzt Maxima
eine Entwicklung der unvollst@"andigen Betafunktion als Kettenbruch.

Hat die Optionsvariable @mref{beta_expand} den Wert @code{true}, entwickelt
Maxima Ausdr@"ucke der Form @code{beta_incomplete(a+n, b, z)} und
@code{beta_incomplete(a-n, b, z)}, wobei @code{n} eine ganze Zahl ist.

Maxima kennt die Ableitungen der unvollst@"andigen Betafunktion nach den
Variablen @var{a}, @var{b} und @var{z} und das Integral f@"ur die 
Integrationsvariable @var{z}.

Beispiele:

Vereinfachung f@"ur eine positive ganze Zahl als Argument @var{a}.

@example
(%i1) beta_incomplete(2,b,z);
                                       b
                            1 - (1 - z)  (b z + 1)
(%o1)                       ----------------------
                                  b (b + 1)
@end example

Vereinfachung f@"ur eine positive ganze Zahl als Argument @var{b}.

@example
(%i2) beta_incomplete(a,2,z);
                                               a
                              (a (1 - z) + 1) z
(%o2)                         ------------------
                                  a (a + 1)
@end example

Vereinfachung f@"ur positive ganzzahlige Argumente @var{a} und @var{b}.

@example
(%i3) beta_incomplete(3,2,z);
                                               3
                              (3 (1 - z) + 1) z
(%o3)                         ------------------
                                      12
@end example

@var{a} ist eine negative ganze Zahl mit @math{b <= (-a)}.  Maxima vereinfacht
f@"ur diesem Fall.

@example
(%i4) beta_incomplete(-3,1,z);
                                       1
(%o4)                              - ----
                                        3
                                     3 z
@end example

F@"ur die speziellen Werte @math{z=0} und @math{z=1} vereinfacht Maxima.

@example
(%i5) assume(a>0,b>0)$
(%i6) beta_incomplete(a,b,0);
(%o6)                                 0
(%i7) beta_incomplete(a,b,1);
(%o7)                            beta(a, b)
@end example

Numerische Berechnung f@"ur reelle Argumente.

@example
(%i8) beta_incomplete(0.25,0.50,0.9);
(%o8)                          4.594959440269333
(%i9)  fpprec:25$
(%i10) beta_incomplete(0.25,0.50,0.9b0);
(%o10)                    4.594959440269324086971203b0
@end example

F@"ur @math{abs(z) > 1} ist das Ergebnis komplex.

@example
(%i11) beta_incomplete(0.25,0.50,1.7);
(%o11)              5.244115108584249 - 1.45518047787844 %i
@end example

Numerische Ergebnisse f@"ur komplexe Argumente.

@example
(%i14) beta_incomplete(0.25+%i,1.0+%i,1.7+%i);
(%o14)             2.726960675662536 - .3831175704269199 %i
(%i15) beta_incomplete(1/2,5/4*%i,2.8+%i);
(%o15)             13.04649635168716 %i - 5.802067956270001
(%i16) 
@end example

Entwicklung, wenn @code{beta_expand} den Wert @code{true} hat.

@example
(%i23) beta_incomplete(a+1,b,z),beta_expand:true;
                                                       b  a
                   a beta_incomplete(a, b, z)   (1 - z)  z
(%o23)             -------------------------- - -----------
                             b + a                 b + a

(%i24) beta_incomplete(a-1,b,z),beta_expand:true;
                                                           b  a - 1
           beta_incomplete(a, b, z) (- b - a + 1)   (1 - z)  z
(%o24)     -------------------------------------- - ---------------
                           1 - a                         1 - a
@end example
 
Ableitung und Integral der unvollst@"andigen Betafunktion.

@example
(%i34) diff(beta_incomplete(a, b, z), z);
                              b - 1  a - 1
(%o34)                 (1 - z)      z
(%i35) integrate(beta_incomplete(a, b, z), z);
              b  a
       (1 - z)  z
(%o35) ----------- + beta_incomplete(a, b, z) z
          b + a
                                       a beta_incomplete(a, b, z)
                                     - --------------------------
                                                 b + a
(%i36) factor(diff(%, z));
(%o36)              beta_incomplete(a, b, z)
@end example
@end deffn

@c --- 09.07.2011 DK -----------------------------------------------------------
@anchor{beta_incomplete_regularized}
@deffn {Funktion} beta_incomplete_regularized (@var{a}, @var{b}, @var{z})

@c The regularized incomplete beta function A&S 6.6.2, defined as

Die regularisierte unvollst@"andige Beta Funktion (A & S 6.6.2), die definiert
ist als

@example
              beta_incomplete(a, b, z)
              ------------------------
                     beta(a, b)
@end example

@c As for @code{beta_incomplete} this definition is not complete.  See
@c functions.wolfram.com for a complete definition of
@c @code{beta_incomplete_regularized}.

Wie bei der Funktion @mref{beta_incomplete} ist diese Definition nicht
vollst@"andig.  Siehe @url{functions.wolfram.com} f@"ur eine vollst@"andige
Definition der Funktion.

@c @code{beta_incomplete_regularized} simplifies @var{a} or @var{b} a positive 
@c integer.
@c For @math{z=0} and @math{realpart(a)>0}, @code{beta_incomplete_regularized}
@c has the specific value 0. For @var{z=1} and @math{realpart(b)>0}, 
@c @code{beta_incomplete_regularized} simplifies to 1.

@code{beta_incomplete_regularized} vereinfacht, wenn das Argument @var{a} oder
@var{b} eine positive ganze Zahl ist.  F@"ur Argumente @code{@var{z} = 0} und
@code{realpart(@var{a}) > 0} vereinfacht die Funktion
@code{beta_incomplete_regularized} zu @code{0}.  F@"ur @code{@var{z} = 1} und
@code{realpart(@var{b}) > 0} vereinfacht die Funktion
@code{beta_incomplete_regularized} zu @code{1}.

@c Maxima can evaluate @code{beta_incomplete_regularized} for real and complex 
@c arguments in float and bigfloat precision.

Maxima berechnet @code{beta_incomplete_regularized} f@"ur reelle und komplexe
Gleitkommazahlen als Argumente numerisch.

When @code{beta_expand} is @code{true}, Maxima expands 
@code{beta_incomplete_regularized} for arguments @math{a+n} or @math{a-n}, 
where n is an integer.

Hat die Optionsvariable @mref{beta_expand} den Wert @code{true}, expandiert
Maxima @code{beta_incomplete_regularized} f@"ur Argumente @math{a+n} oder
@math{a-n}, wobei @var{n} eine ganze Zahl ist.

@c Maxima knows the derivatives of @code{beta_incomplete_regularized} with
@c respect to the variables @var{a}, @var{b}, and @var{z} and the integral with
@c respect to the variable @var{z}.

Maxima kennt die Ableitung der Funktion @code{beta_incomplete_regularized}
nach den Argumenten @var{a}, @var{b} und @var{z} sowie das Integral f@"ur das
Argument @var{z}.

Beispiele:

@c Simplification for @var{a} or @var{b} a positive integer:

Vereinfachung, wenn die Argumente @var{a} oder @var{b} ganze Zahlen sind.

@example
(%i1) beta_incomplete_regularized(2,b,z);
                                b
(%o1)                1 - (1 - z)  (b z + 1)
(%i2) beta_incomplete_regularized(a,2,z);
                                        a
(%o2)                  (a (1 - z) + 1) z
(%i3) beta_incomplete_regularized(3,2,z);
                                        3
(%o3)                  (3 (1 - z) + 1) z
@end example

@c For the specific values @math{z=0} and @math{z=1}, Maxima simplifies:

F@"ur die speziellen Werte @math{z=0} und @math{z=1} vereinfacht Maxima.

@example
(%i4) assume(a>0,b>0)$

(%i5) beta_incomplete_regularized(a,b,0);
(%o5)                           0
(%i6) beta_incomplete_regularized(a,b,1);
(%o6)                           1
@end example

@c Numerical evaluation for real and complex arguments in float and bigfloat 
@c precision:

Numerische Berechnung f@"ur reelle und komplexe Argumente.

@example
(%i7) beta_incomplete_regularized(0.12,0.43,0.9);
(%o7)                   .9114011367359802
(%i8) fpprec:32$

(%i9) beta_incomplete_regularized(0.12,0.43,0.9b0);
(%o9)         9.1140113673598075519946998779975b-1
(%i10) beta_incomplete_regularized(1+%i,3/3,1.5*%i);
(%o10)      .2865367499935405 %i - .1229959633346841
(%i11) fpprec:20$

(%i12) beta_incomplete_regularized(1+%i,3/3,1.5b0*%i);
(%o12) 2.8653674999354036142b-1 %i - 1.2299596333468400163b-1
@end example

@c Expansion, when @code{beta_expand} is @code{true}:

Expansion, wenn @code{beta_expand} den Wert @code{true} hat.

@example
(%i13) beta_incomplete_regularized(a+1,b,z);
                                                     b  a
                                              (1 - z)  z
(%o13) beta_incomplete_regularized(a, b, z) - ------------
                                              a beta(a, b)
(%i14) beta_incomplete_regularized(a-1,b,z);
@group
(%o14) beta_incomplete_regularized(a, b, z)
                                                     b  a - 1
                                              (1 - z)  z
                                         - ----------------------
                                           beta(a, b) (b + a - 1)
@end group
@end example

@c The derivative and the integral wrt @var{z}:

Die Ableitung und das Integral der Funktion.

@example
(%i15) diff(beta_incomplete_regularized(a,b,z),z);
                              b - 1  a - 1
                       (1 - z)      z
(%o15)                 -------------------
                           beta(a, b)
(%i16) integrate(beta_incomplete_regularized(a,b,z),z);
(%o16) beta_incomplete_regularized(a, b, z) z
                                                           b  a
                                                    (1 - z)  z
          a (beta_incomplete_regularized(a, b, z) - ------------)
                                                    a beta(a, b)
        - -------------------------------------------------------
                                   b + a
@end example
@end deffn

@c --- 11.07.2011 DK -----------------------------------------------------------
@anchor{beta_incomplete_generalized}
@deffn {Funktion} beta_incomplete_generalized (@var{a}, @var{b}, @var{z1}, @var{z2})

@c The basic definition of the generalized incomplete beta function is

Die Definition der verallgemeinerten unvollst@"andigen Betafunktion ist

@example
                      z2
                     /
                     [          b - 1  a - 1
                     I   (1 - t)      t      dt
                     ]
                     /
                      z1
@end example

@c Maxima simplifies @code{beta_incomplete_regularized} for @var{a} and @var{b}
@c a positive integer.

Maxima vereinfacht @code{beta_incomplete_refularized} f@"ur positive ganzzahlige
Argumente @var{a} und @var{b}.

@c For @math{realpart(a)>0} and @math{z1=0} or @math{z2=0}, Maxima simplifies
@c @code{beta_incomplete_generalized} to @code{beta_incomplete}. For
@c @math{realpart(b)>0} and @math{z1=1} or @var{z2=1}, Maxima simplifies to an
@c expression with @code{beta} and @code{beta_incomplete}.

Ist @math{realpart(a)>0} und @math{z1=0} oder @math{z2=0}, vereinfacht Maxima
@code{beta_incomplete_generalized} zu der Funktion
@mrefdot{beta_incomplete}  Ist @math{realpart(b)>0} und @math{z1=1} oder
@var{z2=1}, vereinfacht Maxima zu einem Ausdruck mit der Funktion
@mref{beta} und @mrefdot{beta_incomplete}

@c Maxima evaluates @code{beta_incomplete_regularized} for real and complex
@c values in float and bigfloat precision.

Maxima berechnet @code{beta_incomplete_regularized} numerisch f@"ur reelle und
komplexe Gleitkommazahlen in doppelter und beliebiger Genauigkeit.

@c When @code{beta_expand} is @code{true}, Maxima expands
@c @code{beta_incomplete_generalized} for @math{a+n} and @math{a-n}, @var{n} a
@c positive integer.

Hat die Optionsvariable @mref{beta_expand} den Wert @code{true}, dann expandiert
Maxima @code{beta_incomplete_generalized} f@"ur Argumente @math{a+n} und
@math{a-n}, wobei @var{n} eine positive ganze Zahl ist.

@c Maxima knows the derivative of @code{beta_incomplete_generalized} with
@c respect to the variables @var{a}, @var{b}, @var{z1}, and @var{z2} and the
@c integrals with respect to the variables @var{z1} and @var{z2}.

Maxima kennt die Ableitung der Funktion @code{beta_incomplete_generalized} nach
den Variablen @var{a}, @var{b}, @var{z1} und @var{z2} sowie die Integrale
f@"ur die Integrationsvariablen  @var{z1} und @var{z2}.

Beispiele:

@c Maxima simplifies @code{beta_incomplete_generalized} for @var{a} and @var{b}
@c a positive integer:

Maxima vereinfacht @code{beta_incomplete_generalized}, wenn @var{a} und @var{b}
positive ganze Zahlen sind.

@example
(%i1) beta_incomplete_generalized(2,b,z1,z2);
@group
                   b                      b
           (1 - z1)  (b z1 + 1) - (1 - z2)  (b z2 + 1)
(%o1)      -------------------------------------------
                            b (b + 1)
@end group
(%i2) beta_incomplete_generalized(a,2,z1,z2);
@group
                              a                      a
           (a (1 - z2) + 1) z2  - (a (1 - z1) + 1) z1
(%o2)      -------------------------------------------
                            a (a + 1)
@end group
(%i3) beta_incomplete_generalized(3,2,z1,z2);
              2      2                       2      2
      (1 - z1)  (3 z1  + 2 z1 + 1) - (1 - z2)  (3 z2  + 2 z2 + 1)
(%o3) -----------------------------------------------------------
                                  12
@end example

@c Simplification for specific values @math{z1=0}, @math{z2=0}, @math{z1=1}, or
@c @math{z2=1}:

Vereinfachung f@"ur die speziellen Werte @math{z1=0}, @math{z2=0}, @math{z1=1}
und @math{z2=1}.

@example
(%i4) assume(a > 0, b > 0)$
(%i5) beta_incomplete_generalized(a,b,z1,0);
(%o5)                    - beta_incomplete(a, b, z1)

(%i6) beta_incomplete_generalized(a,b,0,z2);
(%o6)                    - beta_incomplete(a, b, z2)

(%i7) beta_incomplete_generalized(a,b,z1,1);
(%o7)              beta(a, b) - beta_incomplete(a, b, z1)

(%i8) beta_incomplete_generalized(a,b,1,z2);
(%o8)              beta_incomplete(a, b, z2) - beta(a, b)
@end example

@c Numerical evaluation for real arguments in float or bigfloat precision:

Numerische Berechnung f@"ur reelle Argumente in doppelter und beliebiger
Gleitkommagenauigkeit.

@example
(%i9) beta_incomplete_generalized(1/2,3/2,0.25,0.31);
(%o9)                        .09638178086368676

(%i10) fpprec:32$
(%i10) beta_incomplete_generalized(1/2,3/2,0.25,0.31b0);
(%o10)               9.6381780863686935309170054689964b-2
@end example

@c Numerical evaluation for complex arguments in float or bigfloat precision:

Numerische Berechnung f@"ur komplexe Argumente in doppelter und beliebiger
Gleitkommagenauigkeit.

@example
(%i11) beta_incomplete_generalized(1/2+%i,3/2+%i,0.25,0.31);
(%o11)           - .09625463003205376 %i - .003323847735353769
(%i12) fpprec:20$
(%i13) beta_incomplete_generalized(1/2+%i,3/2+%i,0.25,0.31b0);
(%o13)     - 9.6254630032054178691b-2 %i - 3.3238477353543591914b-3
@end example

@c Expansion for @math{a+n} or @math{a-n}, @var{n} a positive integer, when
@c @code{beta_expand} is @code{true}:

Expansion f@"ur @math{a+n} oder @math{a-n} und @var{n} eine positive ganze Zahl,
wenn @code{beta_expand} den Wert @code{true} hat.

@example
(%i14) beta_expand:true$

(%i15) beta_incomplete_generalized(a+1,b,z1,z2);
@group
               b   a           b   a
       (1 - z1)  z1  - (1 - z2)  z2
(%o15) -----------------------------
                   b + a
                      a beta_incomplete_generalized(a, b, z1, z2)
                    + -------------------------------------------
                                         b + a
@end group
(%i16) beta_incomplete_generalized(a-1,b,z1,z2);

       beta_incomplete_generalized(a, b, z1, z2) (- b - a + 1)
(%o16) -------------------------------------------------------
                                1 - a
                                    b   a - 1           b   a - 1
                            (1 - z2)  z2      - (1 - z1)  z1
                          - -------------------------------------
                                            1 - a
@end example

@c Derivative wrt the variable @var{z1} and integrals wrt @var{z1} and @var{z2}:

Ableitung nach der Variablen @var{z1} und die Integrale f@"ur die
Integrationsvariablen @var{z1} und @var{z2}.

@example
(%i17) diff(beta_incomplete_generalized(a,b,z1,z2),z1);
                               b - 1   a - 1
(%o17)               - (1 - z1)      z1
(%i18) integrate(beta_incomplete_generalized(a,b,z1,z2),z1);
(%o18) beta_incomplete_generalized(a, b, z1, z2) z1
                                  + beta_incomplete(a + 1, b, z1)
(%i19) integrate(beta_incomplete_generalized(a,b,z1,z2),z2);
(%o19) beta_incomplete_generalized(a, b, z1, z2) z2
                                  - beta_incomplete(a + 1, b, z2)
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{beta_expand}
@defvr {Optionsvariable} beta_expand
Standardwert: @code{false}

@c When @code{beta_expand} is @code{true}, @code{beta(a,b)} and related 
@c functions are expanded for arguments like @math{a+n} or @math{a-n}, 
@c where @math{n} is an integer.

Hat die Optionsvariable @code{beta_expand} den Wert @code{true}, werden
@code{beta(a,b)} und verwandte Funktionen f@"ur Argumente @math{a+n} oder
@math{a-n} entwickelt, wobei @var{n} eine positive ganze Zahl ist.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{beta_args_sum_to_integer}
@defvr {Optionsvariable} beta_args_sum_to_integer
Standardwert: @code{false}

@c When @code{beta_args_sum_to_integer} is @code{true}, Maxima simplifies 
@c @code{beta(a,b)}, when the arguments @var{a} and @var{b} sum to an integer.

Hat die Optionsvariable @code{beta_args_sum_to_integer} den Wert @code{true},
vereinfacht Maxima die Funktion @code{beta(a,b)}, wenn sich die Argumente
@var{a} und @var{b} zu einer ganzen Zahlen summieren.  Siehe auch @mrefdot{beta}
@end defvr

@c NEED INFO HERE ABOUT THE SUBSCRIPTED FORM psi[n](x)
@c I (rtoy) don't think there is a plain psi(x) function anymore.
@c @deffn {Function} psi (@var{x})
@c @deffnx {Function} psi [@var{n}](@var{x})

@c --- 11.07.2011 DK -----------------------------------------------------------
@anchor{psi}
@deffn {Funktion} psi [@var{n}](@var{x})

@c The derivative of @code{log (gamma (@var{x}))} of order @code{@var{n}+1}.
@c Thus, @code{psi[0](@var{x})} is the first derivative,
@c @code{psi[1](@var{x})} is the second derivative, etc.

Ist definiert als die Ableitung der Funktion @code{log(gamma(@var{x}))} der
Ordnung @code{@var{n}+1}.  @code{psi[0](@var{x})} ist die erste Ableitung,
@code{psi[1](@var{x})} ist die zweite Ableitung, usw.

@c Maxima does not know how, in general, to compute a numerical value of
@c @code{psi}, but it can compute some exact values for rational args.
@c Several variables control what range of rational args @code{psi} will
@c return an exact value, if possible.  See @code{maxpsiposint},
@c @code{maxpsinegint}, @code{maxpsifracnum}, and @code{maxpsifracdenom}.
@c That is, @var{x} must lie between @code{maxpsinegint} and
@c @code{maxpsiposint}.  If the absolute value of the fractional part of
@c @var{x} is rational and has a numerator less than @code{maxpsifracnum}
@c and has a denominator less than @code{maxpsifracdenom}, @code{psi}
@c will return an exact value.

Maxima kann numerische Werte f@"ur reelle Gleitkommazahlen berechnen.  Weiterhin
kann Maxima die Funktion @code{psi} f@"ur rationale Argumente zu exakten Werten
vereinfachen.  Die Optionsvariablen @mrefcomma{maxpsiposint}@w{}
@mrefcomma{maxpsinegint} @mref{maxpsifracnum} und @code{maxpsifracdenom}@w{}
kontrollieren, den Wertebereich der Argumente f@"ur den die Funktion @code{psi}
vereinfacht.

@c The function @code{bfpsi} in the @code{bffac} package can compute
@c numerical values.

Die Funktion @mref{bfpsi} des @code{bffac}-Package kann numerische Werte der
Funktion @code{psi} berechnen.
@end deffn

@c --- 11.07.2011 DK -----------------------------------------------------------
@anchor{maxpsiposint}
@defvr {Optionsvariable} maxpsiposint
Standardwert: @code{20}

Die Optionsvariable @code{maxpsiposint} kontrolliert die Vereinfachung der
Funktion @mref{psi} und enth@"alt eine obere positive Schranke.  Ist das
Argument @var{x} der Funktion @code{psi} gr@"o@ss{}er als @code{maxpsiposint},
dann versucht Maxima nicht @code{psi[@var{n}](@var{x})} zu vereinfachen.

Siehe auch @mrefcomma{maxpsifracdenom} @mref{maxpsifracnum} und
@mrefdot{maxpsinegint}

Beispiele:

@example
(%o1)                          20
(%i2) psi[0](20);
                       275295799
(%o2)                  --------- - %gamma
                       77597520
(%i3) maxpsiposint:10;
(%o3)                          10
(%i4) psi[0](20);
(%o4)                       psi (20)
                               0
(%i5) psi[0](10);
                          7129
(%o5)                     ---- - %gamma
                          2520
@end example
@end defvr

@c --- 11.07.2011 DK -----------------------------------------------------------
@anchor{maxpsinegint}
@defvr {Optionsvariable} maxpsinegint
Standardwert: @code{-10}

Die Optionsvariable @code{maxpsinegint} kontrolliert die Vereinfachung der
Funktion @mref{psi} und enth@"alt eine untere negative Schranke.  Ist das
Argument @var{x} der Funktion @code{psi} kleiner als @code{maxpsinegint},
dann versucht Maxima nicht @code{psi[@var{n}](@var{x})} zu vereinfachen.

Siehe auch @mrefcomma{maxpsifracdenom} @mref{maxpsifracnum} und
@mrefdot{maxpsiposint}

Beispiele:

@example
(%i1) maxpsinegint:-10;
(%o1)                         - 10
(%i2) psi[0](-3/2);
                                           8
(%o2)                - 2 log(2) - %gamma + -
                                           3
(%i3) maxpsinegint:-1;
(%o3)                          - 1
(%i4) psi[0](-3/2);
                                   3
(%o4)                       psi (- -)
                               0   2
(%i5) psi[0](-1/2);
(%o5)                - 2 log(2) - %gamma + 2
@end example
@end defvr

@c --- 11.07.2011 DK -----------------------------------------------------------
@anchor{maxpsifracnum}
@defvr {Optionsvariable} maxpsifracnum
Standardwert: @code{6}

Die Optionsvariable @code{maxpsifracnum} kontrolliert die Vereinfachung der
Funktion @mrefdot{psi}  Ist das Argument @var{x} der Funktion @code{psi} eine
rationale Zahl kleiner als eins mit @code{p/q} und ist der Z@"ahler @code{p}
gr@"o@ss{}er als @code{maxpsifracnum}, dann versucht Maxima nicht
@code{psi[@var{n}](@var{x})} zu vereinfachen.

Siehe auch @mrefcomma{maxpsifracdenom} @mref{maxpsiposint} und
@mrefdot{maxpsinegint}

Beispiele:

@example
(%i1) maxpsifracnum: 6;
(%o1)                           6
(%i2) psi[0](5/6);
            3 log(3)              sqrt(3) %pi
(%o2)     - -------- - 2 log(2) + ----------- - %gamma
               2                       2
(%i3) maxpsifracnum: 3;
(%o3)                           3
(%i4) psi[0](5/6);
                                  5
(%o4)                        psi (-)
                                0 6
@end example
@end defvr

@c --- 11.07.2011 DK -----------------------------------------------------------
@anchor{maxpsifracdenom}
@defvr {Optionsvariable} maxpsifracdenom
Standardwert: @code{6}

Die Optionsvariable @code{maxpsifracdenom} kontrolliert die Vereinfachung der
Funktion @mrefdot{psi}  Ist das Argument @var{x} der Funktion @code{psi} eine
rationale Zahl kleiner als eins mit @code{p/q} und ist der Nenner @code{q}
gr@"o@ss{}er als @code{maxpsifracdenom}, dann versucht Maxima nicht
@code{psi[@var{n}](@var{x})} zu vereinfachen.

Siehe auch @mrefcomma{maxpsifracnum} @mref{maxpsiposint} und
@mrefdot{maxpsinegint}

Beispiele:

@example
(%i1) maxpsifracdenom: 6;
(%o1)                           6
(%i2) psi[0](1/6);
            3 log(3)              sqrt(3) %pi
(%o2)     - -------- - 2 log(2) - ----------- - %gamma
               2                       2
(%i3) maxpsifracdenom: 4;
(%o3)                           4
(%i4) psi[0](1/6);
@group
                                  1
(%o4)                        psi (-)
                                0 6
@end group
(%i5) psi[0](1/5);
                                  1
(%o5)                        psi (-)
                                0 5
(%i6) psi[0](1/4);
                                 %pi
(%o6)               - 3 log(2) - --- - %gamma
                                  2
@end example
@end defvr

@c NEED CROSS REFS HERE
@c NEED EXAMPLES HERE

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{makefact}
@deffn {Funktion} makefact (@var{expr})

Ersetzt Binomial-, Gamma- und Beta-Funktionen, die im Ausdruck @var{expr}
auftreten, durch Fakult@"aten.

Siehe auch die Funktion @mrefdot{makegamma}
@end deffn

@c TODO: GEHOERT DIESE FUNKTION HIERHER?
@c AREN'T THERE OTHER FUNCTIONS THAT DO ESSENTIALLY THE SAME THING ??

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{numfactor}
@deffn {Funktion} numfactor (@var{expr})

Gibt einen numerischen Faktor des Produktes @var{expr} zur@"uck.  Ist @var{expr}
kein Produkt oder enth@"alt das Produkt keinen numerischen Faktor ist die
R@"uckgabe @code{1}.

Beispiel:

@example
(%i1) gamma (7/2);
                          15 sqrt(%pi)
(%o1)                     ------------
                               8
(%i2) numfactor (%);
                               15
(%o2)                          --
                               8
@end example
@end deffn

@c -----------------------------------------------------------------------------
@node Exponentielle Integrale, Fehlerfunktionen, Gammafunktionen und verwandte Funktionen, Spezielle Funktionen
@section Exponentielle Integrale
@c -----------------------------------------------------------------------------

Die Exponentiellen Integrale und verwandte Funktionen sind definiert in
Abramowitz und Stegun, @i{Handbook of Mathematical Functions}, Kapitel 5.

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{expintegral_e1}
@deffn {Funktion} expintegral_e1 (@var{z})

Das Exponentielle Integral @code{E1(z)} (A&S 5.1.1).
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{expintegral_ei}
@deffn {Funktion} expintegral_ei (@var{z})

Das Exponentielle Integral @code{Ei(z)} (A&S 5.1.2).
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{expintegral_li}
@deffn {Funktion} expintegral_li (@var{n},@var{z})

Das Exponentielle Integral @code{Li(z)} (A&S 5.1.3).
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{expintegral_e}
@deffn {Funktion} expintegral_e (@var{n}, @var{z})

Das Exponentielle Integral @code{E[n](z)} (A&S 5.1.4).
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{expintegral_si}
@deffn {Funktion} expintegral_si (@var{z})

Das Exponentielle Integral @code{Si(z)} (A&S 5.2.1).
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{expintegral_ci}
@deffn {Funktion} expintegral_ci (@var{z})

Das Exponentielle Integral @code{Ci(z)} (A&S 5.2.2).
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{expintegral_shi}
@deffn {Funktion} expintegral_shi (@var{z})

Das Exponentielle Integral @code{Shi(z)} (A&S 5.2.3).
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{expintegral_chi}
@deffn {Funktion} expintegral_chi (@var{z})

Das Exponentielle Integral @code{Chi(z)} (A&S 5.2.4).
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{expintrep}
@defvr {Optionsvariable} expintrep
Standardwert: @code{false}

Wechselt die Darstellung eines Exponentiellen Integrals in eine der anderen
Funktionen @mrefcomma{gamma_incomplete} @mrefcomma{expintegral_e1}@w{}
@mrefcomma{expintegral_ei} @mrefcomma{expintegral_li}@w{}
@mrefcomma{expintegral_si} @mrefcomma{expintegral_ci}@w{}
@mrefcomma{expintegral_shi} oder @mrefdot{expintegral_chi}
@end defvr

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{expintexpand}
@defvr {Optionsvariable} expintexpand
Standardwert: @code{false}

Expandiert das Exponentielle Integral @code{E[n](z)} f@"ur halbzahlige, gerade
Ordnung @var{n} nach den Funktionen @mref{erfc} und @mrefdot{erf} sowie f@"ur
positive ganze Zahlen nach der Funktion @mrefdot{expintegral_ei}
@end defvr

@c -----------------------------------------------------------------------------
@node Fehlerfunktionen, Elliptische Funktionen und Integrale, Exponentielle Integrale, Spezielle Funktionen
@section Fehlerfunktionen
@c -----------------------------------------------------------------------------

Die Fehlerfunktion und verwandte Funktionen sind definiert in Abramowitz
und Stegun, @i{Handbook of Mathematical Functions}, Kapitel 7.

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{erf}
@deffn {Funktion} erf (@var{z})

Die Fehlerfunktion @code{erf(z)} (A&S 7.1.1).

Siehe auch die Optionsvariable @mrefdot{erfflag}
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{erfc}
@deffn {Function} erfc (@var{z})

Die komplement@"are Fehlerfunktion @code{erfc(z) = 1 - erf(z)} (A & S 7.1.2).
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{erfi}
@deffn {Funktion} erfi (@var{z})

Die imagin@"are Fehlerfunktion @code{erfi(z) = -%i*erf(%i*z)}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{erf_generalized}
@deffn {Funktion} erf_generalized (@var{z1}, @var{z2})

Die verallgemeinerte Fehlerfunktion @math{Erf(z1, z2)}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{fresnel_c}
@deffn {Funktion} fresnel_c (@var{z})

Das Fresnel-Integral, das definiert ist als (A & S 7.3.1):

@example
           z
          /           2
          [      %pi t
   C(z) = I  cos(------) dt
          ]        2
          /
           0
@end example

Hat die Optionsvariable @mref{trigsign} den Wert @code{true}, vereinfacht
Maxima @code{fresnel_c(-x)} zu @code{-fresnel_c(x)}.

Hat die Optionsvariable @mref{%iargs} den Wert @code{true}, vereinfacht 
Maxima @code{fresnel_c(%i*x)} zu @code{%i*fresnel_c(x)}.

Siehe auch die Optionsvariable @mrefcomma {hypergeometric_representation} um
die Fresnelfunktion in eine hypergeometrische Darstellung zu transformieren,
und die Optionsvariable @mref{erf_representation} f@"ur eine Darstellung als
Fehlerfunktion.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{fresnel_s}
@deffn {Funktion} fresnel_s (@var{z})

Das Fresnel-Integral, das definiert ist als (A & S 7.3.2):

@example
           z
          /           2
          [      %pi t
   S(z) = I  sin(------) dt
          ]        2
          /
           0
@end example

Hat die Optionsvariable @mref{trigsign} den Wert @code{true}, vereinfacht
Maxima @code{fresnel_s(-x)} zu @code{-fresnel_s(x)}.

Hat die Optionsvariable @mref{%iargs} den Wert @code{true}, vereinfacht 
Maxima @code{fresnel_s(%i*x)} zu @code{%i*fresnel_s(x)}.

Siehe auch die Optionsvariable @mrefcomma {hypergeometric_representation} um
die Fresnelfunktion in eine hypergeometrische Darstellung zu transformieren,
und die Optionsvariable @mref{erf_representation} f@"ur eine Darstellung als
Fehlerfunktion.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{erf_representation}
@defvr {Optionsvariable} erf_representation
Standarwert: @code{false}

Hat die Optionsvariable @code{erf_representation} den Wert @code{true}, werden
die Funktionen @mrefcomma{erfc} @mrefcomma{erfi}@w{}
@mrefcomma{erf_generalized} @mref{fresnel_s} und @mref{fresnel_c} in eine
Darstellung mit der Funktion @mref{erf} transformiert.
@end defvr

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{hypergeometric_representation}
@defvr {Optionsvariable} hypergeometric_representation
Standardwert: @code{false}

Hat die Optionsvariable @code{hypergeometric_representation} den Wert
@code{true}, werden die Funktionen @mref{fresnel_s} und @mref{fresnel_c} in
eine hypergeometrische Funktion transformiert.
@end defvr

@c -----------------------------------------------------------------------------
@node Elliptische Funktionen und Integrale, Hypergeometrische Funktionen, Fehlerfunktionen, Spezielle Funktionen
@section Elliptische Funktionen und Integrale
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in Elliptische Funktionen und Integrale::
* Funktionen und Variablen f@"ur Elliptische Funktionen::
* Funktionen und Variablen f@"ur Elliptische Integrale::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in Elliptische Funktionen und Integrale, Funktionen und Variablen f@"ur Elliptische Funktionen, Elliptische Funktionen und Integrale, Elliptische Funktionen und Integrale
@subsection Einf@"uhrung in Elliptische Funktionen und Integrale
@c -----------------------------------------------------------------------------

@c Maxima includes support for Jacobian elliptic functions and for
@c complete and incomplete elliptic integrals.  This includes symbolic
@c manipulation of these functions and numerical evaluation as well.
@c Definitions of these functions and many of their properties can by
@c found in Abramowitz and Stegun, Chapter 16--17.  As much as possible,
@c we use the definitions and relationships given there.

Maxima unterst@"utzt die Jacobischen elliptische Funktionen sowie die
vollst@"andigen und unvollst@"andigen elliptischen Integrale.  Die Funktionen
sind f@"ur das symbolische und numerische Rechnen geeignet.  Die Definition der
Funktionen und viele ihrer Eigenschaften sind in Abramowitz and Stegun,
Kapitel 16 und 17 enthalten.  Die dort beschriebenen Definitionen und
Beziehungen werden so weit als m@"oglich verwendet.

@c In particular, all elliptic functions and integrals use the parameter
@c @math{m} instead of the modulus @math{k} or the modular angle
@c @math{\alpha}.  This is one area where we differ from Abramowitz and
@c Stegun who use the modular angle for the elliptic functions.  The
@c following relationships are true:

Im besonderen nutzen alle elliptischen Funktionen und Integrale den Parameter
@math{m} anstatt den Modulus @math{k} oder den modularen Winkel @math{\alpha}.
Dies ist ein Unterschied zu der Definition von Abramowitz und Stegun.  Es
gelten die folgenden Beziehungen:
@ifinfo
@math{m = k^2} und @math{k = \sin(\alpha)}
@end ifinfo
@tex
$$m = k^2$$ und $$k = \sin\alpha $$
@end tex

@c The elliptic functions and integrals are primarily intended to support
@c symbolic computation.  Therefore, most of derivatives of the functions
@c and integrals are known.  However, if floating-point values are given,
@c a floating-point result is returned.

Die elliptischen Funktionen und Integrale sind zuallererst f@"ur das symbolische
Rechnen gedacht.  Daher sind die Ableitungen und Integrale der Funktionen im
wesentlichen in Maxima bekannt.  Maxima unterst@"utzt jedoch auch die
numerische Berechnung, wenn die Argumente Gleitkommazahlen sind.

@c Support for most of the other properties of elliptic functions and
@c integrals other than derivatives has not yet been written.

Viele bekannte Eigenschaften der Elliptischen Funktionen und Integrale sind
noch nicht in Maxima implementiert.

@c Some examples of elliptic functions:

Einige Beispiele f@"ur elliptische Funktionen.

@example
(%i1) jacobi_sn (u, m);
(%o1)                    jacobi_sn(u, m)
(%i2) jacobi_sn (u, 1);
(%o2)                        tanh(u)
(%i3) jacobi_sn (u, 0);
(%o3)                        sin(u)
(%i4) diff (jacobi_sn (u, m), u);
(%o4)            jacobi_cn(u, m) jacobi_dn(u, m)
(%i5) diff (jacobi_sn (u, m), m);
(%o5) jacobi_cn(u, m) jacobi_dn(u, m)

      elliptic_e(asin(jacobi_sn(u, m)), m)
 (u - ------------------------------------)/(2 m)
                     1 - m

            2
   jacobi_cn (u, m) jacobi_sn(u, m)
 + --------------------------------
              2 (1 - m)
@end example

@c Some examples of elliptic integrals:

Einige Beispiele f@"ur elliptische Integrale.

@example
(%i1) elliptic_f (phi, m);
(%o1)                  elliptic_f(phi, m)
(%i2) elliptic_f (phi, 0);
(%o2)                          phi
(%i3) elliptic_f (phi, 1);
                               phi   %pi
(%o3)                  log(tan(--- + ---))
                                2     4
(%i4) elliptic_e (phi, 1);
(%o4)                       sin(phi)
(%i5) elliptic_e (phi, 0);
(%o5)                          phi
(%i6) elliptic_kc (1/2);
                                     1
(%o6)                    elliptic_kc(-)
                                     2
(%i7) makegamma (%);
@group
                                 2 1
                            gamma (-)
                                   4
(%o7)                      -----------
                           4 sqrt(%pi)
@end group
(%i8) diff (elliptic_f (phi, m), phi);
                                1
(%o8)                 ---------------------
                                    2
                      sqrt(1 - m sin (phi))
(%i9) diff (elliptic_f (phi, m), m);
       elliptic_e(phi, m) - (1 - m) elliptic_f(phi, m)
(%o9) (-----------------------------------------------
                              m

                                 cos(phi) sin(phi)
                             - ---------------------)/(2 (1 - m))
                                             2
                               sqrt(1 - m sin (phi))
@end example

@c Support for elliptic functions and integrals was written by Raymond
@c Toy.  It is placed under the terms of the General Public License (GPL)
@c that governs the distribution of Maxima.

Die Implementierung der elliptischen Funktionen und Integrale wurde von 
Raymond Toy geschrieben.  Der Code steht wie Maxima unter der General Public
License (GPL).

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Elliptische Funktionen, Funktionen und Variablen f@"ur Elliptische Integrale, Einf@"uhrung in Elliptische Funktionen und Integrale, Elliptische Funktionen und Integrale
@subsection Funktionen und Variablen f@"ur Elliptische Funktionen
@c -----------------------------------------------------------------------------

@c --- 10.07.2011 DK -----------------------------------------------------------
@deffn {Funktion} jacobi_sn (@var{u}, @var{m})

Die Jacobische elliptische Funktion @math{sn(u,m)}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@deffn {Funktion} jacobi_cn (@var{u}, @var{m})

Die Jacobische elliptische Funktion @math{cn(u,m)}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@deffn {Funktion} jacobi_dn (@var{u}, @var{m})

Die Jacobische elliptische Funktion @math{dn(u,m)}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@deffn {Funktion} jacobi_ns (@var{u}, @var{m})

Die Jacobische elliptische Funktion @math{ns(u,m) = 1/sn(u,m)}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@deffn {Funktion} jacobi_sc (@var{u}, @var{m})

Die Jacobische elliptische Funktion @math{sc(u,m) = sn(u,m)/cn(u,m)}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@deffn {Funktion} jacobi_sd (@var{u}, @var{m})

Die Jacobische elliptische Funktion @math{sd(u,m) = sn(u,m)/dn(u,m)}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@deffn {Funktion} jacobi_nc (@var{u}, @var{m})

Die Jacobische elliptische Funktion @math{nc(u,m) = 1/cn(u,m)}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@deffn {Funktion} jacobi_cs (@var{u}, @var{m})

Die Jacobische elliptische Funktion @math{cs(u,m) = cn(u,m)/sn(u,m)}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@deffn {Funktion} jacobi_cd (@var{u}, @var{m})

Die Jacobische elliptische Funktion @math{cd(u,m) = cn(u,m)/dn(u,m)}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@deffn {Funktion} jacobi_nd (@var{u}, @var{m})

Die Jacobische elliptische Funktion @math{nc(u,m) = 1/cn(u,m)}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@deffn {Funktion} jacobi_ds (@var{u}, @var{m})

Die Jacobische elliptische Funktion @math{ds(u,m) = dn(u,m)/sn(u,m)}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@deffn {Funktion} jacobi_dc (@var{u}, @var{m})

Die Jacobische elliptische Funktion @math{dc(u,m) = dn(u,m)/cn(u,m)}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@deffn {Funktion} inverse_jacobi_sn (@var{u}, @var{m})

Die inverse Jacobische elliptische Funktion @math{sn(u,m)}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@deffn {Funktion} inverse_jacobi_cn (@var{u}, @var{m})

Die inverse Jacobische elliptische Funktion @math{cn(u,m)}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@deffn {Funktion} inverse_jacobi_dn (@var{u}, @var{m})

Die inverse Jacobische elliptische Funktion @math{dn(u,m)}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@deffn {Funktion} inverse_jacobi_ns (@var{u}, @var{m})

Die inverse Jacobische elliptische Funktion @math{ns(u,m)}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@deffn {Funktion} inverse_jacobi_sc (@var{u}, @var{m})

Die inverse Jacobische elliptische Funktion @math{sc(u,m)}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@deffn {Funktion} inverse_jacobi_sd (@var{u}, @var{m})

Die inverse Jacobische elliptische Funktion @math{sd(u,m)}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@deffn {Funktion} inverse_jacobi_nc (@var{u}, @var{m})

Die inverse Jacobische elliptische Funktion @math{nc(u,m)}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@deffn {Funktion} inverse_jacobi_cs (@var{u}, @var{m})

Die inverse Jacobische elliptische Funktion @math{cs(u,m)}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@deffn {Funktion} inverse_jacobi_cd (@var{u}, @var{m})

Die inverse Jacobische elliptische Funktion @math{cd(u,m)}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@deffn {Funktion} inverse_jacobi_nd (@var{u}, @var{m})

Die inverse Jacobische elliptische Funktion @math{nc(u,m)}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@deffn {Funktion} inverse_jacobi_ds (@var{u}, @var{m})

Die inverse Jacobische elliptische Funktion @math{ds(u,m)}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@deffn {Funktion} inverse_jacobi_dc (@var{u}, @var{m})

Die inverse Jacobische elliptische Funktion @math{dc(u,m)}.
@end deffn

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Elliptische Integrale, , Funktionen und Variablen f@"ur Elliptische Funktionen, Elliptische Funktionen und Integrale
@subsection Funktionen und Variablen f@"ur Elliptische Integrale
@c -----------------------------------------------------------------------------

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{elliptic_f}
@deffn {Funktion} elliptic_f (@var{phi}, @var{m})

Das unvollst@"andige elliptische Integral der ersten Art, das definiert ist als

@ifhtml
@math{integrate(1/sqrt(1 - m*sin(x)^2), x, 0, phi)}
@end ifhtml
@ifinfo
@math{integrate(1/sqrt(1 - m*sin(x)^2), x, 0, phi)}
@end ifinfo

@tex
$$\int_0^\phi {{d\theta}\over{\sqrt{1 - m\sin^2\theta}}}$$
@end tex

Siehe auch @mref{elliptic_e} und @mrefdot{elliptic_kc}
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{elliptic_e}
@deffn {Funktion} elliptic_e (@var{phi}, @var{m})

Das unvollst@"andige elliptische Integral der zweiten Art, das definiert ist als

@ifhtml
@math{elliptic_e(phi, m) = integrate(sqrt(1 - m*sin(x)^2), x, 0, phi)}
@end ifhtml
@ifinfo
@math{elliptic_e(phi, m) = integrate(sqrt(1 - m*sin(x)^2), x, 0, phi)}
@end ifinfo
@tex
$$\int_0^\phi \sqrt{1 - m\sin^2\theta} d\theta$$
@end tex

Siehe auch @mref{elliptic_e} und @mrefdot{elliptic_ec}
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{elliptic_eu}
@deffn {Funktion} elliptic_eu (@var{u}, @var{m})

Das unvollst@"andige elliptische Integral der zweiten Art, das definiert ist als

@ifhtml
@math{integrate(dn(v,m)^2,v,0,u) = integrate(sqrt(1-m*t^2)/sqrt(1-t^2), t, 0, tau)}

mit @math{tau = sn(u,m)}.
@end ifhtml
@ifinfo
@math{integrate(dn(v,m)^2,v,0,u) = integrate(sqrt(1-m*t^2)/sqrt(1-t^2), t, 0, tau)}

mit @math{tau = sn(u,m)}.
@end ifinfo
@tex
$$\int_0^u {\rm dn}(v, m) dv  = \int_0^\tau \sqrt{{1-m t^2}\over{1-t^2}} dt$$

mit $\tau = {\rm sn}(u, m)$.
@end tex

Dieses Integral steht in Beziehung zum elliptischen Integral @code{elliptiec_e}

@ifhtml
@math{elliptic_eu(u, m) = elliptic_e(asin(sn(u,m)),m)}
@end ifhtml
@ifinfo
@math{elliptic_eu(u, m) = elliptic_e(asin(sn(u,m)),m)}
@end ifinfo
@tex
$$E(u,m) = E(\phi, m)$$

mit $\phi = \sin^{-1} {\rm sn}(u, m)$.
@end tex

Siehe auch @mrefdot{elliptic_e}
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{elliptic_pi}
@deffn {Funktion} elliptic_pi (@var{n}, @var{phi}, @var{m})

Das unvollst@"andige elliptische Integral der dritten Art, das definiert ist als

@ifhtml
@math{integrate(1/(1-n*sin(x)^2)/sqrt(1 - m*sin(x)^2), x, 0, phi)}
@end ifhtml
@ifinfo
@math{integrate(1/(1-n*sin(x)^2)/sqrt(1 - m*sin(x)^2), x, 0, phi)}
@end ifinfo
@tex
$$\int_0^\phi {{d\theta}\over{(1-n\sin^2 \theta)\sqrt{1 - m\sin^2\theta}}}$$
@end tex

Maxima kennt nur die Ableitung nach der Variablen @var{phi}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{elliptic_kc}
@deffn {Funktion} elliptic_kc (@var{m})

Das vollst@"andige elliptische Integral der ersten Art, das definiert ist als

@ifhtml
@math{integrate(1/sqrt(1 - m*sin(x)^2), x, 0, %pi/2)}
@end ifhtml
@ifinfo
@math{integrate(1/sqrt(1 - m*sin(x)^2), x, 0, %pi/2)}
@end ifinfo

@tex
$$\int_0^{{\pi}\over{2}} {{d\theta}\over{\sqrt{1 - m\sin^2\theta}}}$$
@end tex

F@"ur einige spezielle Argumente @var{m} kennt Maxima Werte mit der
Gammafunktion @mrefdot{gamma}  Die Werte k@"onnen mit der Funktion
@mref{makegamma} berechnet werden.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{elliptic_ec}
@deffn {Funktion} elliptic_ec (@var{m})

Das vollst@"andige elliptische Integral der zweiten Art, das definiert ist als

@ifhtml
@math{integrate(sqrt(1 - m*sin(x)^2), x, 0, %pi/2)}
@end ifhtml
@ifinfo
@math{integrate(sqrt(1 - m*sin(x)^2), x, 0, %pi/2)}
@end ifinfo

@tex
$$\int_0^{{\pi}\over{2}} \sqrt{1 - m\sin^2\theta} d\theta$$
@end tex

F@"ur einige spezielle Argumente @var{m} kennt Maxima Werte mit der
Gammafunktion @mrefdot{gamma}  Die Werte k@"onnen mit der Funktion
@mref{makegamma} berechnet werden.
@end deffn

@c -----------------------------------------------------------------------------
@node Hypergeometrische Funktionen, Weitere spezielle Funktionen, Elliptische Funktionen und Integrale, Spezielle Funktionen
@section Hypergeometrische Funktionen
@c -----------------------------------------------------------------------------

@c The Hypergeometric Functions are defined in Abramowitz and Stegun,
@c @i{Handbook of Mathematical Functions}, Chapters 13 and 15.

@c Maxima has very limited knowledge of these functions.  They
@c can be returned from function @code{hgfred}.

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{%m}
@deffn {Funktion} %m [@var{k}, @var{u}] (@var{z})

Ist die Whittaker M Funktion
@code{M[k,u](z) = exp(-z/2) * z^(1/2+u) * M(1/2+u-k, 1+2*u, z)}.
Siehe A & S 13.1.32 f@"ur die Definition.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{%w}
@deffn {Funktion} %w [@var{k}, @var{u}] (@var{z})

Ist die Whittaker W Funktion.  Siehe A & S 13.1.33 f@"ur die Definition.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{%f}
@deffn {Funktion} %f [@var{p},@var{q}] (@var{[a], [b], z}) 

@c The pFq(a1,a2,..ap;b1,b2,..bq;z) hypergeometric function,
@c where @code{a} a list of length @code{p} and 
@c @code{b} a list of length @code{q}.

Ist die hypergeometrische Funktion
@code{F[p,q](a_1, ..., a_p; b_1,..., b_q; z)}.  Das Argument @var{a} ist eine
Liste mit den @var{p}-Elementen @var{a_i} und das Argument @var{b} die Liste
mit den @var{q}-Elementen @var{b_i}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{hypergeometric}
@deffn {Funktion} hypergeometric ([@var{a_1}, @dots{}, @var{a_p}], [@var{b_1}, @dots{} ,@var{b_q}], z)

@c The hypergeometric function. Unlike Maxima's @code{%f} hypergeometric
@c function, the function @code{hypergeometric} is a simplifying
@c function; also, @code{hypergeometric} supports complex double and
@c big floating point evaluation. For the Gauss hypergeometric function,
@c that is @math{p = 2} and @math{q = 1}, floating point evaluation
@c outside the unit circle is supported, but in general, it is not
@c supported.

Ist die hypergeometrische Funktion.  Im Unterschied zu den Funktionen
@mref{%f} und @mrefcomma{hgfred} ist die Funktion @code{hypergeometric} eine
vereinfachende Funktion.  @code{hypergeometric} unterst@"utzt die Berechnung
von numerischen Werten f@"ur reelle und komplexe Gleitkommazahlen in doppelter
und mit beliebiger Genauigkeit.  F@"ur die Gau@ss{}sche hypergeometrische
Funktion ist @math{p = 2} und @math{q = 1}.  In diesem Fall wird auch die
numerische Berechnung au@ss{}erhalb des Einheitskreises unterst@"utzt.

@c When the option variable @code{expand_hypergeometric} is true (default
@c is false) and one of the arguments @code{a1} through @code{ap} is a
@c negative integer (a polynomial case), @code{hypergeometric} returns an
@c expanded polynomial.

Hat die Optionsvariable @code{expand_hypergeometric} den Wert @code{true}, das
ist der Standardwert, und eines der Argumente @code{a_1}, @dots{}, @code{a_p}
ist eine negative ganze Zahl, gibt @code{hypergeometric} ein Polynom zur@"uck.

Beispiel:

@example
 (%i1)  hypergeometric([],[],x);
 (%o1) %e^x
@end example

@c Polynomial cases automatically expand when @code{expand_hypergeometric} is
@c true:

Expansion in ein Polynom f@"ur eine negative ganze Zahl, wenn die
Optionsvariable @code{expand_hypergeometric} den Wert @code{true} hat.

@example
 (%i2) hypergeometric([-3],[7],x);
 (%o2) hypergeometric([-3],[7],x)

 (%i3) hypergeometric([-3],[7],x), expand_hypergeometric : true;
 (%o3) -x^3/504+3*x^2/56-3*x/7+1
@end example

@c Both double float and big float evaluation is supported:

Numerische Berechnung in doppelter und beliebiger Gleitkommagenauigkeit.

@example
(%i4) hypergeometric([5.1],[7.1 + %i],0.42);
(%o4)       1.346250786375334 - 0.0559061414208204 %i
(%i5) hypergeometric([5,6],[8], 5.7 - %i);
(%o5)     .007375824009774946 - .001049813688578674 %i
(%i6) hypergeometric([5,6],[8], 5.7b0 - %i), fpprec : 30;
(%o6) 7.37582400977494674506442010824b-3
                          - 1.04981368857867315858055393376b-3 %i
@end example
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{parabolic_cylinder_d}
@deffn {Funktion} parabolic_cylinder_d (@var{v}, @var{z})

@c The parabolic cylinder function @code{parabolic_cylinder_d(v,z)}.
@c (A&s 19.3.1)

Die parabolische Zylinderfunktion @code{parabolic_cylinder_d(v,z)}.

@c The Parabolic Cylinder Functions are defined in Abramowitz and Stegun,
@c @i{Handbook of Mathematical Functions}, Chapter 19.

Die parabolischen Zylinderfunktionen sind in Abramowitz and Stegun,
@i{Handbook of Mathematical Functions}, Kapitel 19 definiert.

@c Maxima has very limited knowledge of these functions.  They
@c can be returned from function @code{hgfred}.

Die parabolischen Zylinderfunktionen k@"onnen als Ergebnis der Funktion
@mref{hgfred} auftreten.  Maxima kennt keine weiteren Eigenschaften.
@end deffn

@c -----------------------------------------------------------------------------
@node Weitere spezielle Funktionen,  , Hypergeometrische Funktionen, Spezielle Funktionen
@section Weitere spezielle Funktionen
@c -----------------------------------------------------------------------------

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{li}
@deffn {Funktion} li [@var{s}] (@var{z})

@c Represents the polylogarithm function of order @var{s} and argument @var{z},
@c defined by the infinite series

Ist der Polylogarithmus der Ordnung @var{s} mit dem Argument @var{z}.  Der
Polylogarithmus wird durch die folgende Reihe definiert werden:

@tex
$${\rm Li}_s \left(z\right) = \sum_{k=1}^\infty {z^k \over k^s}$$
@end tex
@ifnottex
@example
                                 inf
                                 ====   k
                                 \     z
                        Li (z) =  >    --
                          s      /      s
                                 ====  k
                                 k = 1
@end example
@end ifnottex

@c @code{li [1]} is @code{- log (1 - z)}. @code{li [2]} and @code{li [3]} are 
@c the dilogarithm and trilogarithm functions, respectively.

F@"ur @var{s=1} geht der Polylogarithmus in die gew@"ohnliche
Logarithmusfunktion @"uber und man erh@"alt @code{-log(1-z)}.  F@"ur @var{s=2}
oder @var{s=3} spricht man vom Dilogarithmus oder Trilogarithmus.

@c When the order is 1, the polylogarithm simplifies to @code{- log (1 - z)},
@c which in turn simplifies to a numerical value if @var{z} is a real or complex
@c floating point number or the @code{numer} evaluation flag is present.

Maxima vereinfacht f@"ur @var{s=1} sofort zum gew@"ohnlichen Logarithmus.
F@"ur negative ganze Zahlen @var{s} einschlie@ss{}lich der Null vereinfacht
Maxima den Polylogarithmus zu einer rationalen Funktion.

@c When the order is 2 or 3, the polylogarithm simplifies to a numerical value
@c if @var{z} is a real floating point number or the @code{numer} evaluation 
@c flag is present.

Ist @var{s=2} oder @var{s=3} und das Argument @var{z} eine Gleitkommazahl, 
vereinfacht Maxima den Di- oder Trilogarithmus zu einer Gleitkommazahl.

Beispiele:

@example
(%i1) assume (x > 0);
(%o1)                        [x > 0]
(%i2) integrate ((log (1 - t)) / t, t, 0, x);
(%o2)                       - li (x)
                                2
(%i3) li [2] (7);
(%o3)                        li (7)
                               2
(%i4) li [2] (7), numer;
(%o4)        1.24827317833392 - 6.113257021832577 %i
(%i5) li [3] (7);
(%o5)                        li (7)
                               3
(%i6) li [2] (7), numer;
(%o6)        1.24827317833392 - 6.113257021832577 %i
(%i7) L : makelist (i / 4.0, i, 0, 8);
(%o7)   [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0]
(%i8) map (lambda ([x], li [2] (x)), L);
(%o8) [0, .2676526384986274, .5822405249432515, 
.9784693966661848, 1.64493407, 2.190177004178597
 - .7010261407036192 %i, 2.374395264042415
 - 1.273806203464065 %i, 2.448686757245154
 - 1.758084846201883 %i, 2.467401098097648
 - 2.177586087815347 %i]
(%i9) map (lambda ([x], li [3] (x)), L);
(%o9) [0, .2584613953442624, 0.537213192678042, 
.8444258046482203, 1.2020569, 1.642866878950322
 - .07821473130035025 %i, 2.060877505514697
 - .2582419849982037 %i, 2.433418896388322
 - .4919260182322965 %i, 2.762071904015935
 - .7546938285978846 %i]
@end example
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{specint}
@deffn {Funktion} specint (exp(- s*@var{t}) * @var{expr}, @var{t})

@c Compute the Laplace transform of @var{expr} with respect to the variable
@c @var{t}. The integrand @var{expr} may contain special functions.

Berechnet die Laplace-Transformation des Ausdrucks @var{expr} f@"ur die
Integrationsvariable @var{t}.  @var{s} ist der Parameter der
Laplace-Transformation.  Der Integrand @var{expr} kann spezielle
Funktionen der Mathematik enthalten.

@c The following special functions are handled by @code{specint}: incomplete
@c gamma function, error functions (but not the error function @code{erfi}, it
@c is easy to transform @code{erfi} e.g. to the error function @code{erf}),
@c exponential integrals, bessel functions (including products of bessel
@c functions), hankel functions, hermite and the laguerre polynomials.
@c Furthermore, @code{specint} can handle the hypergeometric function 
@c @code{%f[p,q]([],[],z)}, the whittaker function of the first kind 
@c @code{%m[u,k](z)} and of the second kind @code{%w[u,k](z)}.

Die folgenden speziellen Funktionen k@"onnen als Integrand auftreten: die
un@-voll@-st@"an@-di@-ge Gammafunkion @mrefcomma{gamma_incomplete} die
Fehlerfunktionen @mref{erf} und @mrefcomma{erfc} nicht jedoch die Funktion
@mrefcomma{erfi} die jedoch in eine andere Fehlerfunktion transformiert werden
kann, die Exponentiellen Integrale wie zum Beispiel @mrefcomma{expintegral_e1}
die Bessel-Funktionen wie zum Beispiel @mrefcomma{bessel_j} einschlie@ss{}lich
der Produkte von Bessel-Funktionen, Hankel-Funktionen wie zum Beispiel
@mrefcomma{hankel_1} Hermite @mref{hermite} und Laguerre Polynome
@mrefdot{laguerre}  Weiterhin kann @code{specint} Integranden mit der
Hypergeometrische Funktion @code{%f[p,q]([],[],z)}, die Whittaker Funktion der
ersten Art @code{%m[u,k](z)} und die der zweiten Art @code{%w[u,k](z)}
integrieren.

@c The result may be in terms of special functions and can include unsimplified
@c hypergeomtric functions.

Das Ergebnis kann spezielle Funktionen und die Hypergeometrische Funktion
enthalten.

@c When @code{laplace} fails to find a Laplace transform, @code{specint} is
@c called.  Because @code{laplace} knows more general rules for Laplace
@c transforms, it is preferable to use @code{laplace} and not @code{specint}.

Kann die Funktion @mref{laplace} keine Laplace-Transformation finden, wird
@code{specint} aufgerufen.  Da die Funktion @code{laplace} einige allgemeine
Regeln kennt, um die Laplace-Transformation zu finden, ist es von Vorteil
die Laplace-Transformation mit der Funktion @code{laplace} zu berechnen.

@c @code{demo(hypgeo)} displays several examples of Laplace transforms computed
@c by @code{specint}.

@code{demo(hypgeo)} zeigt einige Beispiele f@"ur Laplace-Transformationen mit
der Funktion @code{specint}.

Beispiele:

@example
(%i1) assume (p > 0, a > 0)$
(%i2) specint (t^(1/2) * exp(-a*t/4) * exp(-p*t), t);
                           sqrt(%pi)
(%o2)                     ------------
                                 a 3/2
                          2 (p + -)
                                 4
@group
(%i3) specint (t^(1/2) * bessel_j(1, 2 * a^(1/2) * t^(1/2))
              * exp(-p*t), t);
@end group
@group
                                   - a/p
                         sqrt(a) %e
(%o3)                    ---------------
                                2
                               p
@end group
@end example

@c Examples for exponential integrals:

Beispiel mit Exponentiellen Integralen.

@example
(%i4) assume(s>0,a>0,s-a>0)$
(%i5) ratsimp(specint(%e^(a*t)
                      *(log(a)+expintegral_e1(a*t))*%e^(-s*t),t));
@group
                             log(s)
(%o5)                        ------
                             s - a
@end group
(%i6) logarc:true$
(%i7) gamma_expand:true$

radcan(specint((cos(t)*expintegral_si(t)
                     -sin(t)*expintegral_ci(t))*%e^(-s*t),t));
                             log(s)
(%o8)                        ------
                              2
                             s  + 1
ratsimp(specint((2*t*log(a)+2/a*sin(a*t)
                      -2*t*expintegral_ci(a*t))*%e^(-s*t),t));
                               2    2
                          log(s  + a )
(%o9)                     ------------
                                2
                               s
@end example

@c Results when using the expansion of @code{gamma_incomplete} and when changing
@c the representation to @code{expintegral_e1}:

Entwicklung der unvollst@"andigen Gammafunktion und Wechsel in eine Darstellung
mit dem Exponentiellen Integral @code{expintegral_e1}.

@example
(%i10) assume(s>0)$
(%i11) specint(1/sqrt(%pi*t)*unit_step(t-k)*%e^(-s*t),t);
                                            1
                            gamma_incomplete(-, k s)
                                            2
(%o11)                      ------------------------
                               sqrt(%pi) sqrt(s)

(%i12) gamma_expand:true$
(%i13) specint(1/sqrt(%pi*t)*unit_step(t-k)*%e^(-s*t),t);
                              erfc(sqrt(k) sqrt(s))
(%o13)                        ---------------------
                                     sqrt(s)

(%i14) expintrep:expintegral_e1$
(%i15) ratsimp(specint(1/(t+a)^2*%e^(-s*t),t));
                              a s
                        a s %e    expintegral_e1(a s) - 1
(%o15)                - ---------------------------------
                                        a
@end example
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{hgfred}
@deffn {Funktion} hgfred (@var{a}, @var{b}, @var{z})

@c Simplify the generalized hypergeometric function in terms of other,
@c simpler, forms.  @var{a} is a list of numerator parameters and @var{b}
@c is a list of the denominator parameters.

Vereinfacht die Hypergeometrische Funktion zu einfacheren Funktionen, wie
Polynome und spezielle Funktionen.  Die Hypergeometrische Funktion ist die
verallgemeinerte geometrische Reihe und ist wie folgt definiert:

@example
@group
   F    (a_1, ... a_p; b_1, ..., b_q; z) =
    p, q

             inf      p                    q                k
             ====   /===\ gamma(k + a )  /===\   gamma(b ) z
             \       ! !             i    ! !           j
           =  >      ! !  -------------   ! !  ----------------
             /       ! !    gamma(a )     ! !  k! gamma(k + b )
             ====   i = 1          i     j = 1               j
             k = 0
@end group
@end example

Die Argumente @var{a} und @var{b} sind Listen mit den Parametern der 
Hypergeometrischen Funktion @code{a_1}, @dots{}, @code{a_p} sowie
@code{b_1}, @dots{}, @code{b_p}.  Die Liste @var{a} enth@"alt die
@code{p}-Elemente @var{a_i} und die Liste @var{b} enth@"alt die
@var{q}-Elemente @var{b_i}.

@c If @code{hgfred} cannot simplify the hypergeometric function, it returns
@c an expression of the form @code{%f[p,q]([a], [b], x)} where @var{p} is
@c the number of elements in @var{a}, and @var{q} is the number of elements
@c in @var{b}.  This is the usual @code{pFq} generalized hypergeometric
@c function

Kann @code{hgfred} die Hypergeomentrische Funktion nicht vereinfachen, wird
eine Substantivform @code{%f[p,q]([a], [b], z)} zur@"uckgegeben.

Beispiele:

@example
(%i1) assume(not(equal(z,0)));
(%o1)                          [notequal(z, 0)]
(%i2) hgfred([v+1/2],[2*v+1],2*%i*z);

                     v/2                               %i z
                    4    bessel_j(v, z) gamma(v + 1) %e
(%o2)               ---------------------------------------
                                       v
                                      z
(%i3) hgfred([1,1],[2],z);

                                   log(1 - z)
(%o3)                            - ----------
                                       z
(%i4) hgfred([a,a+1/2],[3/2],z^2);
@group

                               1 - 2 a          1 - 2 a
                        (z + 1)        - (1 - z)
(%o4)                   -------------------------------
                                 2 (1 - 2 a) z
@end group
@end example
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{lambert_w}
@deffn {Funktion} lambert_w (@var{z})

Der Hauptzweig der Lambert W Funktion, die L@"osung von
@code{z = W(z) * exp(W(z))}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{nzeta}
@deffn {Funktion} nzeta (@var{z})

Die Plasma Dispersion Funktion
@code{nzeta(z) = %i*sqrt(%pi)*exp(-z^2)*(1-erf(-%i*z))}.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{nzetar}
@deffn {Funktion} nzetar (@var{z})

Gibt  @code{realpart(nzeta(z))} zur@"uck.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{nzetai}
@deffn {Funktion} nzetai (@var{z})

Gibt @code{imagpart(nzeta(z))} zur@"uck.
@end deffn

@c --- 10.07.2011 DK -----------------------------------------------------------
@anchor{%s}
@deffn {Funktion} %s [@var{u},@var{v}] (@var{z})

Lommels kleine Funktion @code{s[u,v](z)}.  Siehe Gradshteyn & Ryzhik 8.570.1.
@end deffn

@c --- End of file Special.de.texi ---------------------------------------------

