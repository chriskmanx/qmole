@c -----------------------------------------------------------------------------
@c File        : Translator.de.texi
@c License     : GNU General Public License (GPL)
@c Language    : German
@c Original    : New file
@c Translation : Dr. Dieter Kaiser
@c Date        : 28.12.2010
@c Revision    : 01.10.2011
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in den @"Ubersetzer::
* Funktionen und Variablen des @"Ubersetzers::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in den @"Ubersetzer, Funktionen und Variablen des @"Ubersetzers, @"Ubersetzer, @"Ubersetzer
@section Einf@"uhrung in den @"Ubersetzer
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen des @"Ubersetzers, , Einf@"uhrung in den @"Ubersetzer, @"Ubersetzer
@section Funktionen und Variablen des @"Ubersetzers
@c -----------------------------------------------------------------------------

@c --- 01.10.2011 DK -----------------------------------------------------------
@anchor{compfile}
@deffn  {Funktion} compfile (@var{filename}, @var{f_1}, @dots{}, @var{f_n})
@deffnx {Funktion} compfile (@var{filename}, functions)
@deffnx {Funktion} compfile (@var{filename}, all)

@c Translates Maxima functions into Lisp and writes the translated code into the
@c file @var{filename}.
@c @code{compfile(@var{filename}, @var{f_1}, ..., @var{f_n})} translates the
@c specified functions. @code{compfile(@var{filename}, functions)} and 
@c @code{compfile(@var{filename}, all)} translate all user-defined functions.

@"Ubersetzt Maxima-Funktionen nach Lisp und schreibt den @"ubersetzten Code in 
die Datei @var{filename}.  Mit dem Kommando @code{compfile(@var{filename}
@var{f_1}, ..., @var{f_n})} werden die als Argument angegebenen Funktionen
@var{f_1}, @dots{}, @var{f_n} @"ubersetzt.  Die Kommandos
@code{compfile(@var{filename}, functions)} oder @code{compfile(@var{filename},
all)} @"ubersetzen dagegen alle vom Nutzer definierten Funktionen.

@c The Lisp translations are not evaluated, nor is the output file processed by 
@c the Lisp compiler.
   @c SO LET'S CONSIDER GIVING THIS FUNCTION A MORE ACCURATE NAME.
@c @code{translate} creates and evaluates Lisp translations. @code{compile_file}
@c translates Maxima into Lisp, and then executes the Lisp compiler. 

Die Lisp-@"Ubersetzungen werden nicht ausgewertet.  Auch wird die Ausgabedatei
nicht kompiliert.  @code{translate} generiert und wertet Lisp-@"Ubersetzungen
aus.  Die Funktion @code{compile_file} @"ubersetzt Maxima nach Lisp und f@"uhrt
dann den Lisp-Compiler aus.

@c See also @code{translate}, @code{translate_file}, and @code{compile_file}.

Siehe auch die Funktionen @mrefcomma{translate} @mref{translate_file} und
@mrefdot{compile_file}
@end deffn

@c THIS VARIABLE IS OBSOLETE: ASSIGNING compgrind: true CAUSES compfile
@c TO EVENTUALLY CALL AN OBSOLETE FUNCTION SPRIN1.
@c RECOMMENDATION IS TO CUT THIS ITEM, AND CUT $compgrind FROM src/transs.lisp
@c @defvar compgrind
@c Default value: @code{false}
@c 
@c When @code{compgrind} is @code{true}, function definitions printed by
@c @code{compfile} are pretty-printed.
@c 
@c @end defvar

@c --- 28.12.2010 DK -----------------------------------------------------------
@anchor{compile}
@deffn  {Funktion} compile (@var{f_1}, @dots{}, @var{f_n})
@deffnx {Funktion} compile (functions)
@deffnx {Funktion} compile (all)

@c Translates Maxima functions @var{f_1}, ..., @var{f_n} into Lisp, evaluates 
@c the Lisp translations, and calls the Lisp function @code{COMPILE} on each 
@c translated function. @code{compile} returns a list of the names of the 
@c compiled functions.

@"Ubersetzt die Maxima-Funktionen @var{f_1}, @dots{}, @var{f_n} nach Lisp, 
wertet die Lisp-@"Ubersetzungen aus und ruft den Lisp-Compiler f@"ur jede 
@"ubersetzte Funktion auf.  @code{compile} gibt eine Liste mit den Namen der 
kompilierten Funktionen zur@"uck.

@c @code{compile (all)} or @code{compile (functions)} compiles all user-defined
@c functions.

@code{compile(all)} oder @code{compile(funtions)} kompiliert alle
nutzerdefinierten Funktionen.

@c @code{compile} quotes its arguments;  the quote-quote operator @code{'@w{}'}
@c defeats quotation.

@code{compile} wertet die Argumente nicht aus.  Der
@nxref{'', Quote-Quote-Operator} @code{''} erzwingt die Auswertung.

@end deffn

@c --- 28.12.2010 DK -----------------------------------------------------------
@anchor{compile_file}
@deffn  {Funktion} compile_file (@var{filename})
@deffnx {Funktion} compile_file (@var{filename}, @var{compiled_filename})
@deffnx {Funktion} compile_file (@var{filename}, @var{compiled_filename}, @var{lisp_filename})

@c Translates the Maxima file @var{filename} into Lisp, executes the Lisp 
@c compiler, and, if the translation and compilation succeed, loads the compiled
@c code into Maxima.

@"Ubersetzt die Maxima-Datei @var{filename} nach Lisp, ruft den Lisp-Compiler 
auf und l@"adt falls erfolgreich den kompilierten Code in Maxima.

@c @code{compile_file} returns a list of the names of four files: the original 
@c Maxima file, the Lisp translation, notes on translation, and the compiled 
@c code. If the compilation fails, the fourth item is @code{false}.

@code{compile_file} gibt eine Liste mit den Namen von vier Dateien zur@"uck:
die urspr@"ungliche Maxima-Datei, die Lisp-@"Ubersetzung, eine Datei mit Notizen
zur @"Ubersetzungen und eine Datei mit dem kompilierten Code.  Schl@"agt die
Kompilierung fehlt, ist der vierte Eintrag @code{false}.

@c Some declarations and definitions take effect as soon as the Lisp code is 
@c compiled (without loading the compiled code). These include functions defined
@c with the @code{:=} operator, macros define with the @code{::=} operator, 
   @c HEDGE -- DON'T KNOW IF THERE IS ANOTHER WAY
@c @code{alias}, @code{declare}, @code{define_variable},  @code{mode_declare},
@c and @code{infix}, @code{matchfix}, @code{nofix}, @code{postfix}, 
@c @code{prefix}, and @code{compfile}.

Einige Deklarationen und Definitionen sind bereits vorhanden, nachdem der 
Lisp-Code kompiliert ist und ohne das dieser geladen wurde.  Dies schlie@ss{}t
Funktionsdefinitionen mit dem Operator @code{:=}, Makros definiert mit dem
Operator @code{::=} sowie Definitionen der folgenden Funktionen @code{alias}, 
@code{declare}, @code{define_variable}, @code{mode_declare}, @code{infix}, 
@code{matchfix}, @code{nofix}, @code{postfix}, @code{prefix} und 
@code{compfile} ein.

@c Assignments and function calls are not evaluated until the compiled code is 
@c loaded. In particular, within the Maxima file, assignments to the translation
@c flags (@code{tr_numer}, etc.) have no effect on the translation.

Zuweisungen und Funktionsaufrufe werden nicht ausgwertet bevor der komplierte
Code geladen wird.  Im besonderen haben Zuweisungen an die 
@"Ubersetzungsschalter wie @code{tr_numer} und andere, die in der Maxima-Datei
aufgef@"uhrt sind, keinen Effekt auf die @"Ubersetzung.

@c @code{compile_file} may mistake warnings for errors and
@c return @code{false} as the name of the compiled code when, in fact,
@c the compilation succeeded. This is a bug. 
   @c REPORTED AS SOURCEFORGE BUG # 1103722.

@code{compile_file} kann Fehler oder Warnungen ausgegeben und @code{false}
zur@"uckgegeben, obwohl die Kompilierung erfolgreich ist.  Dies ist ein
Programmfehler

@c @var{filename} may not contain @code{:lisp} statements.

Die Datei @var{filename} darf keine @code{:lisp}-Anweisungen enthalten.

@c @code{compile_file} evaluates its arguments.

@code{compile_file} wertet die Argumente aus.

@end deffn

@c --- 28.12.2010 DK -----------------------------------------------------------
@anchor{declare_translated}
@deffn {Funktion} declare_translated (@var{f_1}, @var{f_2}, @dots{})

@c When translating a file of Maxima code to Lisp, it is important for the 
@c translator to know which functions it sees in the file are to be called as 
@c translated or compiled functions, and which ones are just Maxima functions or
@c undefined. Putting this declaration at the top of the file, lets it know that
@c although a symbol does which does not yet have a Lisp function value, will 
@c have one at call time. @code{(MFUNCTION-CALL fn arg1 arg2 ...)} is generated 
@c when the translator does not know @code{fn} is going to be a Lisp function.

Bei der @"Ubersetzung einer Datei von Maxima-Code nach Lisp-Code ist es f@"ur 
den @"Ubersetzer wichtig zu wissen, welche Funktionen der Datei bereits 
@"ubersetzte oder kompilierte Funktionen sind und welche Funktionen 
Maxima-Funktionen oder undefiniert sind.  Mit der Deklaration 
@code{declare_translated} am Anfang der zu @"ubersetzenden Datei wird dem 
@"Ubersetzer mitgeteilt, dass die als Argumente aufgef@"uhrten Funktionen 
@var{f_1}, @var{f_2}, @dots{} zur Laufzeit des Programms eine Lisp-Funktion 
repr@"asentieren.  Fehlt dem @"Ubersetzer diese Information wird das Kommando 
@code{(MFUNCTION-CALL fn arg1 arg2 ...)} generiert.

@end deffn

@c --- 28.12.2010 DK -----------------------------------------------------------
@anchor{mode_checkp}
@defvr {Optionsvariable} mode_checkp
Standardwert: @code{true}

   @c WHAT DOES THIS MEAN ??
@c When @code{mode_checkp} is @code{true}, @code{mode_declare} checks the modes
@c of bound variables.

Hat die Optionsvariable @code{mode_checkp} den Wert @code{true} und wird
mit @code{mode_declare} f@"ur eine Variable, die bereits einen Wert hat, ein Typ 
festgelegt, dann pr@"uft Maxima, ob der vorgesehene Typ zum vorliegenden Wert 
passt.

Beispiel:

Im folgenden hat die Variable @var{n} den Wert 2.0.  Wird @var{n} mit
@code{mode_declare} als eine ganze Zahl definiert, gibt Maxima eine Warnung aus,
wenn @code{mode_checkp} den Wert @code{true} hat.

@example
(%i1) n: 2.0;
(%o1)                          2.0
(%i2) mode_checkp:true;
(%o2)                         true
(%i3) mode_declare(n,fixnum);
warning: n was declared with mode fixnum, but it has value: 2.0
(%o3)                          [n]
(%i4) mode_checkp:false;
(%o4)                         false
(%i5) mode_declare(n,fixnum);
(%o5)                          [n]
@end example

@end defvr

@c --- 28.12.21010 DK ----------------------------------------------------------
@anchor{mode_check_errorp}
@defvr {Optionsvariable} mode_check_errorp
Standardwert: @code{false}

   @c WHAT DOES THIS MEAN ??
@c When @code{mode_check_errorp} is @code{true}, @code{mode_declare} calls 
@c error.

Hat @code{mode_check_errorp} den Wert @code{true}, bricht @code{mode_declare}
mit einer Fehlermeldung ab, wenn f@"ur eine Variable die bereits einen Wert hat,
mit @code{mode_declare} ein verschiedener Typ deklariert werden soll.  Damit
diese Optionsvariable wirksam ist, muss @code{mode_checkp} den Wert @code{true}
haben.  Siehe @mrefdot{mode_checkp}

@example
(%i1) n: 2.0;
(%o1)                          2.0
(%i2) mode_checkp:true;
(%o2)                         true
(%i3) mode_check_errorp:true;
(%o3)                         true
(%i4) mode_declare(n,fixnum);

Error: n was declared mode fixnum, has value: 2.0
 -- an error. To debug this try: debugmode(true);
@end example

@end defvr

@c --- 28.12.2010 DK -----------------------------------------------------------
@anchor{mode_check_warnp}
@defvr {Optionsvariable} mode_check_warnp
Standardwert: @code{true}

   @c WHAT DOES THIS MEAN ??
@c When @code{mode_check_warnp} is @code{true}, mode errors are described.

Hat @code{mode_check_warnp} den Wert @code{true}, gibt @code{mode_declare}
eine Warnung aus, wenn f@"ur eine Variable die bereits einen Wert hat,
mit @code{mode_declare} ein verschiedener Typ deklariert werden soll.  Damit
diese Optionsvariable wirksam ist, muss @code{mode_checkp} den Wert @code{true}
haben.  Siehe @mref{mode_checkp} und @mrefdot{mode_check_errorp}

@end defvr

@c NEEDS CLARIFICATION AND EXAMPLES

@c --- 02.01.2011 DK -----------------------------------------------------------
@anchor{mode_declare}
@deffn {Funktion} mode_declare (@var{y_1}, @var{mode_1}, @dots{}, @var{y_n}, @var{mode_n})

@c @code{mode_declare} is used to declare the modes of variables and functions 
@c for subsequent translation or compilation of functions. @code{mode_declare} 
@c is typically placed at the beginning of a function definition, at the 
@c beginning of a Maxima script, or executed at the interactive prompt.

@code{mode_declare} deklariert den Typ von Variablen und Funktionen f@"ur den
@"Ubersetzer und den Kompilierer.  Typischerweise wird @code{mode_declare} am
Anfang einer Funktion oder einer Datei mit Maxima-Code ausgef@"uhrt.

@c The arguments of @code{mode_declare} are pairs consisting of a variable and a
@c mode which is one of @code{boolean}, @code{fixnum}, @code{number}, 
@c @code{rational}, or @code{float}. Each variable may also be a list of 
@c variables all of which are declared to have the same mode.

Die Argumente werden paarweise angegeben und bezeichnen jeweils den Namen einer
Variablen sowie deren Typ.  Folgende Typen k@"onnen die Variablen erhalten:
@code{boolean}, @code{fixnum}, @code{number}, @code{rational} oder @code{float}.
Anstatt dem Namen einer Variablen kann auch eine Liste mit den Namen von
Variablen angegeben werden.  In diesem Fall erhalten alle Variablen der Liste
den angegebenen Typ.

   @c WHAT DOES THE FOLLOWING STATEMENT MEAN ???
@c If a variable is an array, and if every element of the array which is
@c referenced has a value then @code{array (yi, complete, dim1, dim2, ...)}
@c rather than
@c @example
@c array(yi, dim1, dim2, ...)
@c @end example
@c should be used when first declaring the bounds of the array.
   @c WHAT DOES THE FOLLOWING STATEMENT MEAN ???
@c If all the elements of the array are of mode @code{fixnum} (@code{float}), 
@c use @code{fixnum} (@code{float}) instead of @code{complete}.

Ein Array sollte bereits bei seiner Deklaration einen Typ f@"ur die Elemente
erhalten.  Haben alle Elemente des Arrays einen Wert sollte das Array mit der
Option @code{complete} deklariert werden, zum Beispiel
@code{array(a, complete, dim1, dim2, ...)}.  Sind die Elemente des Arrays
ganze Zahlen oder Gleitkommazahlen sollte der Typ als @code{fixnum} oder
@code{flonum} deklariert werden.

   @c WHAT DOES THE FOLLOWING STATEMENT MEAN ???
@c Also if every element of the array is of the same mode, say @code{m}, then
@c @example
@c mode_declare (completearray (yi), m))
@c @end example
@c should be used for efficient translation.
@c Numeric code using arrays might run faster by declaring the expected size of 
@c the array, as in:
@c @example
@c mode_declare (completearray (a [10, 10]), float)
@c @end example
@c for a floating point number array which is 10 x 10.

Mit der Funktion @code{mode_declare} kann dann der Typ des Arrays f@"ur den
@"Ubersetzer oder Kompilierer festgelegt werden.  Ein Array der Gr@"o@ss{}e 
10 @code{x} 10 mit Gleitkommazahlen erh@"alt die Deklaration
@code{mode_declare(completearray(a[10, 10], float)}.

@c One may declare the mode of the result of a function by using @code{function 
@c (f_1, f_2, ...)} as an argument; here @code{f_1}, @code{f_2}, ... are the 
@c names of functions.  For example the expression,
@c @example
@c mode_declare ([function (f_1, f_2, ...)], fixnum)
@c @end example
@c declares that the values returned by @code{f_1}, @code{f_2}, @dots{} are 
@c single-word integers.

Der Typ von Funktionen wird mit dem Argument @code{function(f_1, f2, ...)}
deklariert.  Hier sind @code{f_1}, @code{f_2}, @dots{} die Funktionen.  Mit
@code{mode_declare([function (f_1, f_2, ...)], fixnum)} werden die 
R@"uckgabewerte der Funktionen @code{f_1}, @code{f_2}, @dots{} als ganze Zahlen 
definiert.

@c @code{modedeclare} is a synonym for @code{mode_declare}.

@code{modedeclare} ist ein Alias-Name der Funktion @code{mode_declare}.

@end deffn

@c WHAT IS THIS ABOUT ??
@c NEEDS CLARIFICATION AND EXAMPLES

@c --- 02.01.2011 DK -----------------------------------------------------------
@anchor{mode_identity}
@deffn {Funktion} mode_identity (@var{mode}, @var{expr})

@c A special form used with @code{mode_declare} and @code{macros} to declare, 
@c e.g., a list of lists of flonums, or other compound data object.  The first 
@c argument to @code{mode_identity} is a primitive value mode name as given to 
@c @code{mode_declare} (i.e., one of @code{float}, @code{fixnum}, @code{number},
@c @code{list}, or @code{any}), and the second argument is an expression which 
@c is evaluated and returned as the value of @code{mode_identity}.  However, if 
@c the return value is not allowed by the mode declared in the first argument, 
@c an error or warning is signalled.  The important thing is that the mode of 
@c the expression as determined by the Maxima to Lisp translator, will be that 
@c given as the first argument, independent of anything that goes on in the 
@c second argument. E.g., @code{x: 3.3; mode_identity (fixnum, x);} yields an 
@c error. @code{mode_identity (flonum, x)} returns 3.3 . This has a number of 
@c uses, e.g., if you knew that @code{first (l)} returned a number then you 
@c might write @code{mode_identity (number, first (l))}.  However, a more 
@c efficient way to do it would be to define a new primitive,
@c @example
@c firstnumb (x) ::= buildq ([x], mode_identity (number, x));
@c @end example
@c and use @code{firstnumb} every time you take the first of a list of numbers.

Mit der Funktion @code{mode_identity} wird der Typ @var{mode} f@"ur das
Ergebnis des Ausdrucks @var{expr} festgelegt.  Hat das Ergebnis einen anderen 
Typ wird in Abh@"angigkeit von den Werten der Optionsvariablen 
@code{mode_checkp}, @code{mode_check_warnp} und @code{mode_check_errorp} eine
Warnung ausgegeben oder das Programm abgebrochen.

Beispiel:

@c ===beg===
@c mode_identity(flonum, sin(1.0));
@c mode_identity(integer, sin(1.0));
@c mode_identity(integer, sin(a));
@c ===end===
@example
(%i1) mode_identity(flonum, sin(1.0));
(%o1)                   .8414709848078965
(%i2) mode_identity(integer, sin(1.0));
warning: sin(1.0) was declared with mode fixnum
                            , but it has value: .8414709848078965
(%o2)                   .8414709848078965
(%i3) mode_identity(integer, sin(a));
warning: sin(a) was declared with mode fixnum, but it has value: 
                                                           sin(a)
(%o3)                        sin(a)
@end example

@end deffn

@c --- 02.01.2011 DK -----------------------------------------------------------
@anchor{savedef}
@defvr {Optionsvariable} savedef
Standardwert: @code{true}

@c When @code{savedef} is @code{true}, the Maxima version of a user function is 
@c preserved when the function is translated. This permits the definition to be 
@c displayed by @code{dispfun} and allows the function to be edited.

Hat @code{savedef} den Wert @code{true}, wird die Maxima-Definition einer
Funktion nicht gel@"oscht, wenn die Funktion @"ubersetzt wird.  Damit kann die
Definition der Funktion weiterhin mit @code{dispfun} angzeigt werden. 

@c When @code{savedef} is @code{false}, the names of translated functions are
@c removed from the @code{functions} list.

Hat @code{savedef} den Wert @code{false} wird die Maxima-Definition der Funktion
gel@"oscht, wenn die Funktion @"ubersetzt wird.

Beispiele:

@code{savedef} hat den Wert @code{true}.  Die Funktion @code{f} kann auch nach
der @"Ubersetzung angzeigt werden und ist in der Liste @code{functions}
enthalten.

@c ===beg===
@c savedef:true;
@c f(x):=x^2+sin(x);
@c translate(f);
@c dispfun(f);
@c functions;
@c ===end===
@example
(%i1) savedef:true;
(%o1)                         true
(%i2) f(x):=x^2+sin(x);
                                2
(%o2)                  f(x) := x  + sin(x)
(%i3) translate(f);
(%o3)                          [f]
(%i4) dispfun(f);
                                2
(%t4)                  f(x) := x  + sin(x)

(%o4)                         [%t4]
(%i5) functions;
(%o5)                        [f(x)]
@end example

Dasselbe f@"ur eine Funktion @code{g} mit dem Wert @code{false} f@"ur 
@code{savedef}.

@c ===beg===
@c savedef:false;
@c g(x):=sqrt(x)+cos(x)$
@c translate(g);
@c dispfun(g);
@c functions;
@c ===end===
@example
(%i6) savedef:false;
(%o6)                         false
(%i7) g(x):=sqrt(x)+cos(x)$

(%i8) translate(g);
(%o8)                          [g]
(%i9) dispfun(g);

fundef: no such function: g
 -- an error. To debug this try: debugmode(true);
(%i10) functions;
(%o10)                       [f(x)]
@end example

@end defvr

@c IS THERE ANY REASON TO SET transcompile: false ??
@c MAYBE THIS VARIABLE COULD BE PERMANENTLY SET TO true AND STRUCK FROM 
@c THE DOCUMENTATION.

@c --- 03.01.2011 DK -----------------------------------------------------------
@anchor{transcompile}
@defvr {Optionsvariable} transcompile
Standardwert: @code{true}

@c When @code{transcompile} is @code{true}, @code{translate} and 
@c @code{translate_file} generate declarations to make the translated code more 
@c suitable for compilation.
   @c BUT THE DECLARATIONS DON'T SEEM TO BE NECESSARY, SO WHAT'S THE POINT 
   @c AGAIN ??

Hat @code{transcompile} den Wert @code{true}, generieren die Funktionen
@code{translate} und @code{translate_file} Deklarationen, die das Kompilieren
des Codes verbessern.

@c @code{compfile} sets @code{transcompile: true} for the duration.

@code{compfile} setzt den Wert von @code{transcompile} zu @code{true}.

@end defvr

@c --- 03.01.2011 DK -----------------------------------------------------------
@anchor{translate}
@deffn  {Funktion} translate (@var{f_1}, @dots{}, @var{f_n})
@deffnx {Funktion} translate (functions)
@deffnx {Funktion} translate (all)

@c Translates the user-defined functions @var{f_1}, ..., @var{f_n} from the 
@c Maxima language into Lisp and evaluates the Lisp translations.  Typically the 
@c translated functions run faster than the originals.

Die vom Nutzer definierten Maxima-Funktionen @var{f_1}, @dots{}, @var{f_n} 
werden nach Lisp @"ubersetzt.  Typischerweise sind die @"ubersetzten Funktionen 
schneller als die Maxima-Funktionen.

@c @code{translate (all)} or @code{translate (functions)} translates all 
@c user-defined functions.

@code{translate(all)} oder @code{translate(functions)} @"ubersetzt alle vom
Benutzer definierten Funktionen.

@c Functions to be translated should include a call to @code{mode_declare} at 
@c the beginning when possible in order to produce more efficient code.  For
@c example:
@c where the @var{x_1}, @var{x_2}, ...  are the parameters to the function and 
@c the @var{v_1}, @var{v_2}, ... are the local variables.

Funktionen, die @"ubersetzt werden sollen, sollten mit @code{mode_declare} den
Typ von Variablen und Funktionen deklarieren, um effizienteren Code zu erhalten.
Im Folgenden Beispiel sind @var{x_1}, @var{x_2}, @dots{} die Argumente der 
Funktion und @var{v_1}, @var{v_2}, @dots{} sind die lokalen Variablen.

@example
f (x_1, x_2, ...) := block ([v_1, v_2, ...],
    mode_declare (v_1, mode_1, v_2, mode_2, ...), ...)
@end example

@c The names of translated functions are removed from the @code{functions} list 
@c if @code{savedef} is @code{false} (see below) and are added to the 
@c @code{props} lists.

Die Namen von @"ubersetzten Funktionen werden von der Informationsliste
@code{functions} entfernt, wenn die Optionsvariable @code{savedef} den Wert
@code{false} hat.  Sie werden der Informationsliste @code{props} hinzugef@"ugt.

@c Functions should not be translated unless they are fully debugged.

Funktionen sollten erst @"ubersetzt werden, wenn sie vollst@"andig von Fehlern
befreit wurden.

@c Expressions are assumed simplified; if they are not, correct but non-optimal 
@c code gets generated.  Thus, the user should not set the @code{simp} switch to 
@c @code{false} which inhibits simplification of the expressions to be 
@c translated.

Ausdr@"ucke werden als vereinfacht angenommen.  Sind sie es nicht, wird zwar
korrekter, aber nicht optimierter Code erzeugt.  Daher sollte der Schalter
@code{simp} nicht den Wert @code{false} haben, wodurch die Vereinfachung von
Ausdr@"ucken unterdr@"uckt w@"are.

@c The switch @code{translate}, if @code{true}, causes automatic translation of 
@c a user's function to Lisp.

Hat der Schalter @code{translate} den Wert @code{true}, werden nutzerdefinierte
Funktionen automatisch nach Lisp @"ubersetzt.

@c Note that translated functions may not run identically to the way they did 
@c before translation as certain incompatabilities may exist between the Lisp
@c and Maxima versions.  Principally, the @code{rat} function with more than
@c one argument and the @code{ratvars} function should not be used if any
@c variables are @code{mode_declare}'d canonical rational expressions (CRE).
@c Also the @code{prederror: false} setting will not translate.
   @c WHAT ABOUT % AND %% ???

Das Laufzeitverhalten von @"ubersetzten Funktionen kann sich von dem 
nicht-@"ubersetzter Funktionen unterscheiden.  Grunds@"atzlich sollte die 
Funktion @code{rat} nicht mit mehr als zwei Argumenten und die Funktion 
@code{ratvars} nicht genutzt werden, wenn irgendeine der Variablen eine CRE-Form
mit Deklaration mit @code{mode_declare} aufweisen.  Auch wird 
@code{prederror:false} nicht @"ubersetzt.

@c @code{savedef} - if @code{true} will cause the Maxima version of a user
@c function to remain when the function is @code{translate}'d.  This permits the
@c definition to be displayed by @code{dispfun} and allows the function to be
@c edited.
@c @code{transrun} - if @code{false} will cause the interpreted version of all
@c functions to be run (provided they are still around) rather than the 
@c translated version.

Hat die Optionsvariable @code{savedef} den Wert @code{true}, wird die
Originalversion einer Funktion nicht entfernt.  Siehe @mrefdot{savedef}  Mit
dem Wert @code{false} f@"ur @code{transrun} werden, wenn noch vorhanden, die 
Originalversionen der @"ubersetzten Funktion ausgef@"uhrt.

@c The result returned by @code{translate} is a list of the names of the
@c functions translated.

Das Ergebnis der Funktion @code{translate} ist eine Liste der Namen der
@"ubersetzten Funktionen.

@end deffn

@c --- 03.01.2011 DK -----------------------------------------------------------
@anchor{translate_file}
@deffn  {Funktion} translate_file (@var{maxima_filename})
@deffnx {Funktion} translate_file (@var{maxima_filename}, @var{lisp_filename})

@c Translates a file of Maxima code into a file of Lisp code. 
@c @code{translate_file} returns a list of three filenames: the name of the
@c Maxima file, the name of the Lisp file, and the name of file containing 
@c additional information about the translation. @code{translate_file} evaluates 
@c its arguments.

@"Ubersetzt eine Datei mit Maxima-Code in eine Datei mit Lisp-Code.
@code{translate_file} gibt eine Liste mit drei Dateien zur@"uck, die den
Namen der Maxima-Datei, den Namen der Lisp-Datei und den Namen einer Datei
mit Informationen zur @"Ubersetzung enth@"alt.  @code{translate_file} wertet die
Argumente aus.

@c @code{translate_file ("foo.mac"); load("foo.LISP")} is the same as
@c @code{batch ("foo.mac")} except for certain restrictions, the use of 
@c @code{'@w{}'} and @code{%}, for example.
   @c FIGURE OUT WHAT THE RESTRICTIONS ARE AND STATE THEM

Die Kommandos @code{translate_file("foo.mac")} und @code{load("foo.LISP")} 
haben bis auf wenige Ausnahmen dieselbe Wirkung wie @code{batch("foo.mac")}.  
Zum Beispiel funktionieren @code{'@w{}'} und @code{%} unterschiedlich.

@c @code{translate_file (@var{maxima_filename})} translates a Maxima file 
@c @var{maxima_filename} into a similarly-named Lisp file. For example, 
@c @code{foo.mac} is translated into @code{foo.LISP}. The Maxima filename may 
@c include a directory name or names, in which case the Lisp output file is 
@c written to the same directory from which the Maxima input comes.

@code{translate_file(@var{maxima_filename})} @"ubersetzt die Maxima-Datei
@var{maxima_filename} in ein Lisp-Datei mit einem vergleichbaren Namen.  Zum
Beispiel wird die Maxima-Datei @code{foo.mac} zu @code{foo.LISP}.  Der Name der 
Maxima-Datei kann Pfadangaben enthalten.  In diesem Fall wird die Lisp-Datei
in dasselbe Verzeichnis wie die Maxima-Datei geschrieben.

@c @code{translate_file (@var{maxima_filename}, @var{lisp_filename})} translates
@c a Maxima file @var{maxima_filename} into a Lisp file @var{lisp_filename}.
@c @code{translate_file} ignores the filename extension, if any, of 
@c @code{lisp_filename}; the filename extension of the Lisp output file is 
@c always @code{LISP}. The Lisp filename may include a directory name or names,
@c in which case the Lisp output file is written to the specified directory.

@code{translate_file(@var{maxima_filename}, @var{lisp_filename})} @"ubersetzt
die Maxima-Datei @var{maxima_filename} in eine Lisp-Datei mit dem Namen
@code{lisp_filename}.  @code{translate_file} ignoriert eine angegebene 
Dateiendung des Dateinamenes @code{lisp_filename}.  Die Dateiendung ist immer
@code{.LISP}.  Der Name der Lisp-Datei kann Pfadangaben enthalten, um die
Lisp-Datei in das gew@"unschte Verzeichnis zu schreiben.

@c @code{translate_file} also writes a file of translator warning messages of 
@c various degrees of severity. The filename extension of this file is 
@c @code{UNLISP}. This file may contain valuable information, though possibly 
@c obscure, for tracking down bugs in translated code. The @code{UNLISP} file is
@c always written to the same directory from which the Maxima input comes.

@code{translate_file} schreibt eine Ausgabedatei mit Meldungen des 
@"Ubersetzers.  Die Dateiendung der Ausgabedatei ist @code{.UNILISP}.  Die 
Informationen dieser Datei k@"onnen f@"ur die Fehlersuche genutzt werden.  Die 
Datei wird immer in das Verzeichnis geschrieben, das die Maxima-Datei enth@"alt.

@c @code{translate_file} emits Lisp code which causes some declarations and 
@c definitions to take effect as soon as the Lisp code is compiled. See 
@c @code{compile_file} for more on this topic.

@code{translate_file} generiert Lisp-Code mit Deklarationen und Definitionen,
die bereits beim Kompilieren des Codes wirksam werden.  Siehe 
@mref{compile_file} f@"ur mehr Informationen.

   @c CHECK ALL THESE AND SEE WHICH ONES ARE OBSOLETE

@c See also @code{tr_array_as_ref},

Siehe auch die folgenden Optionsvariablen:

@flushleft
@code{tr_array_as_ref},
@c tr_bind_mode_hook EXISTS BUT IT APPEARS TO BE A GROTESQUE UNDOCUMENTED 
@c HACK WE DON'T. WANT TO MENTION IT.
@c @code{tr_bind_mode_hook}, 
@code{tr_bound_function_applyp},
@c tr_exponent EXISTS AND WORKS AS ADVERTISED IN src/troper.lisp
@c NOT OTHERWISE DOCUMENTED; ITS EFFECT SEEMS TOO WEAK TO MENTION
@code{tr_exponent},
@code{tr_file_tty_messagesp}, 
@code{tr_float_can_branch_complex},
@code{tr_function_call_default}, 
@code{tr_numer},
@code{tr_optimize_max_loop}, 
@code{tr_semicompile},
@code{tr_state_vars}, 
@code{tr_warnings_get},
@code{tr_warn_bad_function_calls},
@code{tr_warn_fexpr}, 
@code{tr_warn_meval},
@code{tr_warn_mode},
@code{tr_warn_undeclared},
und @code{tr_warn_undefined_variable}.
@end flushleft

@end deffn

@c --- 03.01.2011 DK -----------------------------------------------------------
@anchor{transrun}
@defvr {Optionsvariable} transrun
Standardwert: @code{true}

@c When @code{transrun} is @code{false} will cause the interpreted version of 
@c all functions to be run (provided they are still around) rather than the 
@c translated version.

Hat @code{transrun} den Wert @code{false}, werden die nicht-@"ubersetzten 
Versionen ausgef@"uhrt, falls diese noch vorhanden sind.  
Siehe @mrefdot{savedef}

@end defvr

@c IN WHAT CONTEXT IS tr_array_as_ref: false APPROPRIATE ??? NOT SEEING THE 
@c USEFULNESS HERE. ALSO, I GUESS WE SHOULD HAVE AN ITEM FOR 
@c translate_fast_arrays, ANOTHER CONFUSING FLAG ...

@c --- 05.01.2011 DK -----------------------------------------------------------
@anchor{tr_array_as_ref}
@defvr {Optionsvariable} tr_array_as_ref
Standardwert: @code{true}

@c If @code{translate_fast_arrays} is @code{false}, array references in Lisp 
@c code emitted by @code{translate_file} are affected by @code{tr_array_as_ref}.
@c When @code{tr_array_as_ref} is @code{true}, array names are evaluated,
@c otherwise array names appear as literal symbols in translated code.

Hat @code{translate_fast_arrays} den Wert @code{false}, werden Referenzen auf
Arrays in Lisp-Code von der Variablen @code{tr_array_as_ref} kontrolliert.  Hat
@code{tr_array_as_ref} den Wert @code{true}, werden Array-Namen ausgewertet.

@c @code{tr_array_as_ref} has no effect if @code{translate_fast_arrays} is 
@c @code{true}.

@code{tr_array_as_ref} hat keinen Effekt, wenn @code{translate_fast_arrays} den
Wert @code{true} hat.

@end defvr

@c WHY IS THIS FLAG NEEDED ??? UNDER WHAT CIRCUMSTANCES CAN TRANSLATION
@c OF A BOUND VARIABLE USED AS A FUNCTION GO WRONG ???

@c --- 05.01.2011 DK -----------------------------------------------------------
@anchor{tr_bound_function_applyp}
@defvr {Optionsvariable} tr_bound_function_applyp
Standardwert: @code{true}

@c When @code{tr_bound_function_applyp} is @code{true}, Maxima gives a warning 
@c if a bound variable (such as a function argument) is found being used as a 
@c function.
   @c WHAT DOES THIS MEAN ??
@c @code{tr_bound_function_applyp} does not affect the code generated in such 
@c cases.

Hat @code{tr_bound_function_applyp} den Wert @code{true}, gibt Maxima eine
Warnung aus, wenn versucht wird, eine gebundene Variable als eine Funktion
verwendet werden soll.  @code{tr_bound_function_applyp} hat keinen Effekt auf
den generierten Code.

@c For example, an expression such as @code{g (f, x) := f (x+1)} will trigger
@c the warning message.

Zum Beispiel gibt ein Ausdruck der Form  @code{g (f, x) := f (x+1)} eine 
Warnung.

@end defvr

@c --- 05.01.2011 DK -----------------------------------------------------------
@anchor{tr_file_tty_messagep}
@defvr {Optionsvariable} tr_file_tty_messagesp
Standardwert: @code{false}

@c When @code{tr_file_tty_messagesp} is @code{true}, messages generated by 
@c @code{translate_file} during translation of a file are displayed on the 
@c console and inserted into the UNLISP file. When @code{false}, messages about 
@c translation of the file are only inserted into the UNLISP file.

Hat @code{tr_file_tty_messagesp} den Wert @code{true}, werden Meldungen die
von der Funktion @code{translate_file} w@"ahrend einer @"Ubersetzung generiert 
werden auch auf der Konsole ausgegeben.  Ansonsten werden Meldungen nur in die
Datei @code{.UNILISP} geschrieben.

@end defvr

@c THIS FLAG APPEARS TO HAVE NO EFFECT. SHOULD CUT OUT THIS ITEM AND RELATED 
@c CODE. NOTE THAT THERE IS CODE IN src/transf.lisp WHICH USES THIS FLAG BUT THE
@c MODE FLAG IS LOST SOMEWHERE ALONG THE WAY TO THE LISP OUTPUT FILE.

@c --- 05.01.2011 DK -----------------------------------------------------------
@anchor{tr_float_can_branch_complex}
@defvr {Optionsvariable} tr_float_can_branch_complex
Standardwert: @code{true}

@c Tells the Maxima-to-Lisp translator to assume that the functions @code{acos},
@c @code{asin}, @code{asec}, and @code{acsc} can return complex results.

Erkl@"art dem @"Ubersetzer, dass die Funktionen @code{acos}, @code{asin}, 
@code{asec} und @code{acsc} komplexe Werte zur@"uckgegeben k@"onnen.

@c TODO: DAS FOLGENDE NICHT UEBERSETZT.

@c The ostensible effect of @code{tr_float_can_branch_complex} is the following.
@c However, it appears that this flag has no effect on the translator output.

@c When it is @code{true} then @code{acos(x)} is of mode @code{any} even if 
@c @code{x} is of mode @code{float} (as set by @code{mode_declare}). When 
@c @code{false} then @code{acos(x)} is of mode @code{float} if and only if 
@c @code{x} is of mode @code{float}.

@end defvr

@c --- 05.01.2011 DK -----------------------------------------------------------
@anchor{tr_function_call_default}
@defvr {Optionsvariable} tr_function_call_default
Standardwert: @code{general}

@c @code{false} means give up and call @code{meval}, @code{expr} means assume 
@c Lisp fixed arg function.  @code{general}, the default gives code good for 
@c @code{mexprs} and @code{mlexprs} but not @code{macros}. @code{general} 
@c assures variable bindings are correct in compiled code.  In @code{general} 
@c mode, when translating F(X), if F is a bound variable, then it assumes that 
@c @code{apply (f, [x])} is meant, and translates a such, with apropriate 
@c warning. There is no need to turn this off.  With the default settings, no 
@c warning messages implies full compatibility of translated and compiled code 
@c with the Maxima interpreter.

@c TODO: DIE WERTE FALSE UND EXPR SIND NICHT WIRKLICH KLAR.

@code{false} bedeutet, gebe auf und rufe @code{meval} auf, @code{expr} bedeutet,
nehme Lisp-Argumente an.  @code{general}, der Standardwert, gibt Code der f@"ur
@code{MEXPRS}-Funktionen geeignet ist.  Wird Maxima-Code mit dem Standardwert
@code{general} @"ubersetzt, ohne dass Warnmeldungen ausgegeben werden, kann davon
ausgegangen werden, dass der @"ubersetzte und komplilierte Code kompatibel mit der
urspr@"unglichen Funktion ist.

@end defvr

@c --- 05.01.2011 DK -----------------------------------------------------------
@anchor{tr_numer}
@defvr {Optionsvariable} tr_numer
Standardwert: @code{false}

@c When @code{tr_numer} is @code{true}, @code{numer} properties are used for
@c atoms which have them, e.g. @code{%pi}.

Hat @code{tr_numer} den Wert @code{true}, wird die @code{numer}-Eigenschaft
von Symbolen vom @"Ubersetzer angewendet.

@end defvr

@c --- 05.01.2011 DK -----------------------------------------------------------
@anchor{tr_optimize_max_loop}
@defvr {Optionsvariable} tr_optimize_max_loop
Standardwert: 100

@c @code{tr_optimize_max_loop} is the maximum number of times the
@c macro-expansion and optimization pass of the translator will loop in
@c considering a form.  This is to catch macro expansion errors, and
@c non-terminating optimization properties.

@code{tr_optimize_max_loop} enth@"alt die maximale Anzahl an Durchg@"angen, um
Makros zu expandieren und den Code zu optimieren.  Damit werden unendliche
Schleifen des @"Ubersetzers vermieden.

@end defvr

@c --- 05.01.2011 DK -----------------------------------------------------------
@anchor{tr_semicompile}
@defvr {Optionsvariable} tr_semicompile
Standardwert: @code{false}

@c When @code{tr_semicompile} is @code{true}, @code{translate_file} and 
@c @code{compfile} output forms which will be macroexpanded but not compiled 
@c into machine code by the Lisp compiler.

Hat @code{tr_semicompile} den Wert @code{true}, geben die Funktionen 
@code{translate_file} und @code{compfile} Code aus, in dem Makrofunktionen
expandiert sind, der aber nicht kompliliert ist.

@end defvr

@c ARE ANY OF THESE OBSOLETE ??

@c --- 05.01.2011 DK -----------------------------------------------------------
@anchor{tr_state_vars}
@defvr {Systemvariable} tr_state_vars
Standardwert:
@verbatim
[transcompile, tr_semicompile, tr_warn_undeclared, tr_warn_meval,
tr_warn_fexpr, tr_warn_mode, tr_warn_undefined_variable,
tr_function_call_default, tr_array_as_ref,tr_numer]
@end verbatim

@c The list of the switches that affect the form of the translated output.
   @c DOES THE GENERAL USER REALLY CARE ABOUT DEBUGGING THE TRANSLATOR ???
@c This information is useful to system people when trying to debug the 
@c translator.  By comparing the translated product to what should have been 
@c produced for a given state, it is possible to track down bugs.

Enth@"alt eine Liste der Schalter, die die @"Ubersetzung kontrollieren.

@end defvr

@c tr_warnings_get EXISTS AND FUNCTIONS AS ADVERTISED (SORT OF) -- 
@c RETURNS *tr-runtime-warned* WHICH HAS ONLY A FEW KINDS OF WARNINGS PUSHED 
@c ONTO IT; IT'S CERTAINLY NOT COMPREHENSIVE 
@c DO WE REALLY NEED THIS SLIGHTLY WORKING FUNCTION ??

@c --- 05.01.2011 DK -----------------------------------------------------------
@anchor{tr_warnings_get}
@deffn {Funktion} tr_warnings_get ()

@c Prints a list of warnings which have been given by the translator during the 
@c current translation.

Gebe die Liste der Warnungen aus, welche bei der letzten @"Ubersetzung erzeugt 
wurden.

@end deffn

@c --- 05.01.2011 DK -----------------------------------------------------------
@anchor{tr_warn_bad_function_calls}
@defvr {Optionsvariable} tr_warn_bad_function_calls
Standardwert: @code{true}

@c Gives a warning when function calls are being made which may not be correct 
@c due to improper declarations that were made at translate time.

Gebe Warnungen aus, wenn Funktionsaufrufe generiert werden, die m@"oglicherweise
nicht korrekt sind, aufgrund von ungeeigneten Deklarationen f@"ur die 
@"Ubersetzung.

@end defvr

@c --- 05.01.2011 DK -----------------------------------------------------------
@anchor{tr_warn_fexpr}
@defvr {Optionsvariable} tr_warn_fexpr
Standardwert: @code{compfile}

@c Gives a warning if any FEXPRs are encountered.  FEXPRs should not normally 
@c be output in translated code, all legitimate special program forms are 
@c translated.

Gebe Warnungen aus, wenn @code{FEXPR}-Ausdr@"ucke im @"ubersetzten Code 
auftreten.

@end defvr

@c --- 05.01.2011 DK -----------------------------------------------------------
@anchor{tr_warn_meval}
@defvr {Optionsvariable} tr_warn_meval
Standardwert: @code{compfile}

@c Gives a warning if the function @code{meval} gets called.  If @code{meval} 
@c is called that indicates problems in the translation.

Gebe Warnungen aus, wenn die Funktion @code{meval} aufgerufen wird.  Dies
signalisiert Probleme bei der @"Ubersetzung.

@end defvr

@c --- 05.01.2011 DK -----------------------------------------------------------
@anchor{tr_warn_mode}
@defvr {Optionsvariable} tr_warn_mode
Standardwert: @code{all}

@c Gives a warning when variables are assigned values inappropriate for their 
@c mode.

Gebe Warnungen aus, wenn Variablen Werte zugewiesen werden, die nicht zu dem
deklarierten Typ passen.

@end defvr

@c --- 05.01.2011 DK -----------------------------------------------------------
@anchor{tr_warn_undeclared}
@defvr {Optionsvariable} tr_warn_undeclared
Standardwert: @code{compile}

@c Determines when to send warnings about undeclared variables to the TTY.

Kontrolliert, wann Warnungen @"uber nicht-deklarierte Variablen angezeigt werden
sollen.

@end defvr

@c --- 05.01.2011 DK -----------------------------------------------------------
@anchor{tr_warn_undedined_variable}
@defvr {Optionsvariable} tr_warn_undefined_variable
Standardwert: @code{all}

@c Gives a warning when undefined global variables are seen.

Gebe eine Warnung aus, wenn undefinierte globale Variablen auftreten.

@end defvr

@c --- End of file Translator.de.texi ------------------------------------------

