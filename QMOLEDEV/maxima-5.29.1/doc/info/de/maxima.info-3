This is maxima.info, produced by makeinfo version 4.13 from
/home/robert/maxima/maxima-git/maxima-code/doc/info/de//include-maxima.de.texi.

Das ist ein Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Ein Computer Algebra System.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Funktionen und Variablen für die TeX-Ausgabe,  Next: Funktionen und Variablen für die Fortran-Ausgabe,  Prev: Funktionen und Variablen für die Eingabe und Ausgabe,  Up: Eingabe und Ausgabe

13.4 Funktionen und Variablen für die TeX-Ausgabe
=================================================

 -- Function: tex (<expr>)
 -- Function: tex (<expr>, <destination>)
 -- Function: tex (<expr>, false)
 -- Function: tex (<label>)
 -- Function: tex (<label>, <destination>)
 -- Function: tex (<label>, false)
     Prints a representation of an expression suitable for the TeX
     document preparation system. The result is a fragment of a
     document, which can be copied into a larger document but not
     processed by itself.

     `tex (<expr>)' prints a TeX representation of <expr> on the
     console.

     `tex (<label>)' prints a TeX representation of the expression
     named by <label> and assigns it an equation label (to be displayed
     to the left of the expression). The TeX equation label is the same
     as the Maxima label.

     <destination> may be an output stream or file name. When
     <destination> is a file name, `tex' appends its output to the
     file. The functions `openw' and `opena' create output streams.

     `tex (<expr>, false)' and `tex (<label>, false)' return their TeX
     output as a string.

     `tex' evaluates its first argument after testing it to see if it
     is a label. Quote-quote `''' forces evaluation of the argument,
     thereby defeating the test and preventing the label.

     See also `texput'.

     Examples:

          (%i1) integrate (1/(1+x^3), x);
                                              2 x - 1
                            2            atan(-------)
                       log(x  - x + 1)        sqrt(3)    log(x + 1)
          (%o1)      - --------------- + ------------- + ----------
                              6             sqrt(3)          3
          (%i2) tex (%o1);
          $$-{{\log \left(x^2-x+1\right)}\over{6}}+{{\arctan \left({{2\,x-1
           }\over{\sqrt{3}}}\right)}\over{\sqrt{3}}}+{{\log \left(x+1\right)
           }\over{3}}\leqno{\tt (\%o1)}$$
          (%o2)                          (\%o1)
          (%i3) tex (integrate (sin(x), x));
          $$-\cos x$$
          (%o3)                           false
          (%i4) tex (%o1, "foo.tex");
          (%o4)                          (\%o1)

     `tex (<expr>, false)' returns its TeX output as a string.

          (%i1) S : tex (x * y * z, false);
          (%o1) $$x\,y\,z$$
          (%i2) S;
          (%o2) $$x\,y\,z$$

 -- Function: tex1 (<e>)
     Returns a string which represents the TeX output for the
     expressions <e>.  The TeX output is not enclosed in delimiters for
     an equation or any other environment.

     Examples:

          (%i1) tex1 (sin(x) + cos(x));
          (%o1)                     \sin x+\cos x

 -- Function: texput (<a>, <s>)
 -- Function: texput (<a>, <f>)
 -- Function: texput (<a>, <s>, <operator_type>)
 -- Function: texput (<a>, [<s_1>, <s_2>], matchfix)
 -- Function: texput (<a>, [<s_1>, <s_2>, <s_3>], matchfix)
     Assign the TeX output for the atom <a>, which can be a symbol or
     the name of an operator.

     `texput (<a>, <s>)' causes the `tex' function to interpolate the
     string <s> into the TeX output in place of <a>.

     `texput (<a>, <f>)' causes the `tex' function to call the function
     <f> to generate TeX output. <f> must accept one argument, which is
     an expression which has operator <a>, and must return a string
     (the TeX output). <f> may call `tex1' to generate TeX output for
     the arguments of the input expression.

     `texput (<a>, <s>, <operator_type>)', where <operator_type> is
     `prefix', `infix', `postfix', `nary', or `nofix', causes the `tex'
     function to interpolate <s> into the TeX output in place of <a>,
     and to place the interpolated text in the appropriate position.

     `texput (<a>, [<s_1>, <s_2>], matchfix)' causes the `tex' function
     to interpolate <s_1> and <s_2> into the TeX output on either side
     of the arguments of <a>. The arguments (if more than one) are
     separated by commas.

     `texput (<a>, [<s_1>, <s_2>, <s_3>], matchfix)' causes the `tex'
     function to interpolate <s_1> and <s_2> into the TeX output on
     either side of the arguments of <a>, with <s_3> separating the
     arguments.

     Examples:

     Assign TeX output for a variable.

          (%i1) texput (me,"\\mu_e");
          (%o1)                         \mu_e
          (%i2) tex (me);
          $$\mu_e$$
          (%o2)                         false

     Assign TeX output for an ordinary function (not an operator).

          (%i1) texput (lcm, "\\mathrm{lcm}");
          (%o1)                     \mathrm{lcm}
          (%i2) tex (lcm (a, b));
          $$\mathrm{lcm}\left(a , b\right)$$
          (%o2)                         false

     Call a function to generate TeX output.

          (%i1) texfoo (e) := block ([a, b], [a, b] : args (e),
            concat ("\\left[\\stackrel{", tex1 (b),
                    "}{", tex1 (a), "}\\right]"))$
          (%i2) texput (foo, texfoo);
          (%o2)                        texfoo
          (%i3) tex (foo (2^x, %pi));
          $$\left[\stackrel{\pi}{2^{x}}\right]$$
          (%o3)                         false

     Assign TeX output for a prefix operator.

          (%i1) prefix ("grad");
          (%o1)                         grad
          (%i2) texput ("grad", " \\nabla ", prefix);
          (%o2)                        \nabla
          (%i3) tex (grad f);
          $$ \nabla f$$
          (%o3)                         false

     Assign TeX output for an infix operator.

          (%i1) infix ("~");
          (%o1)                           ~
          (%i2) texput ("~", " \\times ", infix);
          (%o2)                        \times
          (%i3) tex (a ~ b);
          $$a \times b$$
          (%o3)                         false

     Assign TeX output for a postfix operator.

          (%i1) postfix ("##");
          (%o1)                          ##
          (%i2) texput ("##", "!!", postfix);
          (%o2)                          !!
          (%i3) tex (x ##);
          $$x!!$$
          (%o3)                         false

     Assign TeX output for a nary operator.

          (%i1) nary ("@@");
          (%o1)                          @@
          (%i2) texput ("@@", " \\circ ", nary);
          (%o2)                         \circ
          (%i3) tex (a @@ b @@ c @@ d);
          $$a \circ b \circ c \circ d$$
          (%o3)                         false

     Assign TeX output for a nofix operator.

          (%i1) nofix ("foo");
          (%o1)                          foo
          (%i2) texput ("foo", "\\mathsc{foo}", nofix);
          (%o2)                     \mathsc{foo}
          (%i3) tex (foo);
          $$\mathsc{foo}$$
          (%o3)                         false

     Assign TeX output for a matchfix operator.

          (%i1) matchfix ("<<", ">>");
          (%o1)                          <<
          (%i2) texput ("<<", [" \\langle ", " \\rangle "], matchfix);
          (%o2)                [ \langle ,  \rangle ]
          (%i3) tex (<<a>>);
          $$ \langle a \rangle $$
          (%o3)                         false
          (%i4) tex (<<a, b>>);
          $$ \langle a , b \rangle $$
          (%o4)                         false
          (%i5) texput ("<<", [" \\langle ", " \\rangle ", " \\, | \\,"],
                matchfix);
          (%o5)           [ \langle ,  \rangle ,  \, | \,]
          (%i6) tex (<<a>>);
          $$ \langle a \rangle $$
          (%o6)                         false
          (%i7) tex (<<a, b>>);
          $$ \langle a \, | \,b \rangle $$
          (%o7)                         false

 -- Function: get_tex_environment (<op>)
 -- Function: set_tex_environment (<op>, <before>, <after>)
     Customize the TeX environment output by `tex'.  As maintained by
     these functions, the TeX environment comprises two strings: one is
     printed before any other TeX output, and the other is printed
     after.

     Only the TeX environment of the top-level operator in an expression
     is output; TeX environments associated with other operators are
     ignored.

     `get_tex_environment' returns the TeX enviroment which is applied
     to the operator <op>; returns the default if no other environment
     has been assigned.

     `set_tex_environment' assigns the TeX environment for the operator
     <op>.

     Examples:

          (%i1) get_tex_environment (":=");
          (%o1) [
          \begin{verbatim}
          , ;
          \end{verbatim}
          ]
          (%i2) tex (f (x) := 1 - x);

          \begin{verbatim}
          f(x):=1-x;
          \end{verbatim}

          (%o2)                         false
          (%i3) set_tex_environment (":=", "$$", "$$");
          (%o3)                       [$$, $$]
          (%i4) tex (f (x) := 1 - x);
          $$f(x):=1-x$$
          (%o4)                         false

 -- Function: get_tex_environment_default ()
 -- Function: set_tex_environment_default (<before>, <after>)
     Customize the TeX environment output by `tex'.  As maintained by
     these functions, the TeX environment comprises two strings: one is
     printed before any other TeX output, and the other is printed
     after.

     `get_tex_environment_default' returns the TeX environment which is
     applied to expressions for which the top-level operator has no
     specific TeX environment (as assigned by `set_tex_environment').

     `set_tex_environment_default' assigns the default TeX environment.

     Examples:

          (%i1) get_tex_environment_default ();
          (%o1)                       [$$, $$]
          (%i2) tex (f(x) + g(x));
          $$g\left(x\right)+f\left(x\right)$$
          (%o2)                         false
          (%i3) set_tex_environment_default ("\\begin{equation}
          ", "
          \\end{equation}");
          (%o3) [\begin{equation}
          ,
          \end{equation}]
          (%i4) tex (f(x) + g(x));
          \begin{equation}
          g\left(x\right)+f\left(x\right)
          \end{equation}
          (%o4)                         false


File: maxima.info,  Node: Funktionen und Variablen für die Fortran-Ausgabe,  Prev: Funktionen und Variablen für die TeX-Ausgabe,  Up: Eingabe und Ausgabe

13.5 Funktionen und Variablen für die Fortran-Ausgabe
=====================================================

 -- Option variable: fortindent
     Default value: `0'

     `fortindent' controls the left margin indentation of expressions
     printed out by the `fortran'  command.  `0' gives normal printout
     (i.e., 6 spaces), and positive values will causes the expressions
     to be printed farther to the right.

 -- Function: fortran (<expr>)
     Prints <expr> as a Fortran statement.  The output line is indented
     with spaces.  If the line is too long, `fortran' prints
     continuation lines.  `fortran' prints the exponentiation operator
     `^' as `**', and prints a complex number `a + b %i' in the form
     `(a,b)'.

     <expr> may be an equation. If so, `fortran' prints an assignment
     statement, assigning the right-hand side of the equation to the
     left-hand side.  In particular, if the right-hand side of <expr>
     is the name of a matrix, then `fortran' prints an assignment
     statement for each element of the matrix.

     If <expr> is not something recognized by `fortran', the expression
     is printed in `grind'  format without complaint.  `fortran' does
     not know about lists, arrays, or functions.

     `fortindent' controls the left margin of the printed lines.  `0'
     is the normal margin (i.e., indented 6 spaces). Increasing
     `fortindent' causes expressions to be printed further to the right.

     When `fortspaces'  is `true', `fortran' fills out each printed
     line with spaces to 80 columns.

     `fortran' evaluates its arguments; quoting an argument defeats
     evaluation.  `fortran' always returns `done'.

     See also the function `f90'  for printing one or more expressions
     as a Fortran 90 program.

     Examples:

     (%i1) expr: (a + b)^12$
     (%i2) fortran (expr);
           (b+a)**12
     (%o2)                         done
     (%i3) fortran ('x=expr);
           x = (b+a)**12
     (%o3)                         done
     (%i4) fortran ('x=expand (expr));
           x = b**12+12*a*b**11+66*a**2*b**10+220*a**3*b**9+495*a**4*b**8+792
          1   *a**5*b**7+924*a**6*b**6+792*a**7*b**5+495*a**8*b**4+220*a**9*b
          2   **3+66*a**10*b**2+12*a**11*b+a**12
     (%o4)                         done
     (%i5) fortran ('x=7+5*%i);
           x = (7,5)
     (%o5)                         done
     (%i6) fortran ('x=[1,2,3,4]);
           x = [1,2,3,4]
     (%o6)                         done
     (%i7) f(x) := x^2$
     (%i8) fortran (f);
           f
     (%o8)                         done

 -- Option variable: fortspaces
     Default value: `false'

     When `fortspaces' is `true', `fortran' fills out each printed line
     with spaces to 80 columns.


File: maxima.info,  Node: Mengen,  Next: Summen Produkte und Reihen,  Prev: Eingabe und Ausgabe,  Up: Top

14 Mengen
*********

* Menu:

* Einführung in Mengen::
* Funktionen und Variablen für Mengen::


File: maxima.info,  Node: Einführung in Mengen,  Next: Funktionen und Variablen für Mengen,  Prev: Mengen,  Up: Mengen

14.1 Einführung in Mengen
=========================

Maxima hat Funktionen wie den Schnitt und die Vereinigung von endlichen
Mengen, die durch eine explizite Aufzählung definiert werden können.
Listen und Mengen sind in Maxima unterschiedliche Objekte und können
selbst Elemente von Mengen sein.  Siehe auch *note Listen::.

Neben den Funktionen für Mengen, enthält dieses Kapitel weitere
Funktionen der Kombinatorik.  Darunter die Stirling-Zahlen der ersten
und zweiten Art, die Bellschen Zahlen, Multinomialverteilungen,
Partitionsfunktionen oder die Kronecker-Delta-Funktion.

14.1.1 Anwendung
----------------

Mit `set(a_1, ..., a_n)' oder `{a_1, ..., a_n}' wird eine Menge mit den
Elementen `a_1, ..., a_n' konstruiert.  Die leere Menge wird mit
`set()' oder `{}' angegeben.  Mengen werden immer mit geschweiften
Klammern angezeigt.  Werden Elemente mehrmals angegeben, werden die
doppelten Elemente aus der Menge entfernt.

Beispiele:

     (%i1) set();
     (%o1)                          {}
     (%i2) set(a, b, a);
     (%o2)                        {a, b}
     (%i3) set(a, set(b));
     (%o3)                       {a, {b}}
     (%i4) set(a, [b]);
     (%o4)                       {a, [b]}
     (%i5) {};
     (%o5)                          {}
     (%i6) {a, b, a};
     (%o6)                        {a, b}
     (%i7) {a, {b}};
     (%o7)                       {a, {b}}
     (%i8) {a, [b]};
     (%o8)                       {a, [b]}

Zwei Elemente <x> und <y> werden als gleich angesehen, wenn `is(<x> =
<y>)' das Ergebnis `true' hat.  Die Elemente sind dann syntaktisch
gleich.  Es ist zu beachten, dass `is(equal(<x>, <y>))' das Ergebnis
`true' haben kann, jedoch der Ausdruck `is(<x> = <y>)' das Ergebnis
`false' liefert.

     (%i1) x: a/c + b/c;
                                   b   a
     (%o1)                         - + -
                                   c   c
     (%i2) y: a/c + b/c;
                                   b   a
     (%o2)                         - + -
                                   c   c
     (%i3) z: (a + b)/c;
                                   b + a
     (%o3)                         -----
                                     c
     (%i4) is (x = y);
     (%o4)                         true
     (%i5) is (y = z);
     (%o5)                         false
     (%i6) is (equal (y, z));
     (%o6)                         true
     (%i7) y - z;
                                b + a   b   a
     (%o7)                    - ----- + - + -
                                  c     c   c
     (%i8) ratsimp (%);
     (%o8)                           0
     (%i9) {x, y, z};
                               b + a  b   a
     (%o9)                    {-----, - + -}
                                 c    c   c

Mit der Funktion `setify'  kann eine Menge aus einer Liste konstruiert
werden.

     (%i1) setify ([b, a]);
     (%o1)                        {a, b}

Die Elemente `x' und `y' einer Menge sind gleich, wenn der Ausdruck
`is(x = y)' das Ergebnis `true' hat.  Daher werden zum Beispiel
`rat(x)' und `x' als gleich betrachtet.

     (%i1) {x, rat(x)};
     (%o1)                          {x}

Da der Ausdruck `is((x - 1)*(x + 1) = x^2 - 1)' das Ergebnis `false'
hat, werden `(x - 1)*(x + 1)' und `x^2 - 1' als verschiedene Elemente
angenommen.

     (%i1) {(x - 1)*(x + 1), x^2 - 1};
                                            2
     (%o1)               {(x - 1) (x + 1), x  - 1}

Um die Menge des letzten Beispiels auf ein Element zu reduzieren, kann
die Funktion `rat'  auf die Elemente der Menge angewendet werden.

     (%i1) {(x - 1)*(x + 1), x^2 - 1};
                                            2
     (%o1)               {(x - 1) (x + 1), x  - 1}
     (%i2) map (rat, %);
                                   2
     (%o2)/R/                    {x  - 1}

Um redundante Elemente von Mengen zu entfernen, können Funktionen für
die Vereinfachung von Ausdrücken angewendet werden.  In diesem Beispiel
wird die Funktion `trigsimp'  auf die Elemente der Menge angewendet.

     (%i1) {1, cos(x)^2 + sin(x)^2};
                                 2         2
     (%o1)                {1, sin (x) + cos (x)}
     (%i2) map (trigsimp, %);
     (%o2)                          {1}

Hat eine Menge redundante Elemente, wird sie vereinfacht und sortiert.
Die Ordnung der Elemente wird von der Funktion `orderlessp'  bestimmt.
Einige Operationen auf Mengen, wie zum Beispiel Substitutionen
erzwingen die Vereinfachung von Mengen.

     (%i1) s: {a, b, c}$
     (%i2) subst (c=a, s);
     (%o2)                        {a, b}
     (%i3) subst ([a=x, b=x, c=x], s);
     (%o3)                          {x}
     (%i4) map (lambda ([x], x^2), set (-1, 0, 1));
     (%o4)                        {0, 1}

Maxima behandelt Listen und Mengen als verschiedene Objekte.
Funktionen wie `union'  oder `intersection'  geben eine Fehlermeldung,
wenn die Argumente keine Mengen sind.  Um eine Funktion für Mengen auf
eine Liste anzuwenden, kann diese mit der Funktion `setify'  in eine
Menge umgewandelt werden.

     (%i1) union ([1, 2], {a, b});
     Function union expects a set, instead found [1,2]
      -- an error.  Quitting.  To debug this try debugmode(true);
     (%i2) union (setify ([1, 2]), {a, b});
     (%o2)                     {1, 2, a, b}

Mit der Funktion `subset'  kann eine Teilmenge ermittelt werden, deren
Elemente für eine Aussagefunktion das Ergebnis `true' haben.  Um die
Gleichungen einer Menge zu finden, die nicht von der Variablen `z'
abhängen, wird im Folgenden die Aussagefunktion `freeof'  verwendet.

     (%i1) subset ({x + y + z, x - y + 4, x + y - 5},
                                         lambda ([e], freeof (z, e)));
     (%o1)               {- y + x + 4, y + x - 5}

In *note Funktionen und Variablen für Mengen:: sind die Funktionen
dokumentiert, die Maxima für Mengen kennt.

14.1.2 Iteration über Mengen
----------------------------

Es gibt zwei Möglichkeiten, über die Elemente einer Menge zu iterieren.
Im ersten Fall wird die Funktion `map'  genutzt.

     (%i1) map (f, {a, b, c});
     (%o1)                  {f(a), f(b), f(c)}

Eine weitere Möglichkeit ist, eine `for' -Schleife einzusetzen.

     (%i1) s: {a, b, c};
     (%o1)                       {a, b, c}
     (%i2) for si in s do print (concat (si, 1));
     a1
     b1
     c1
     (%o2)                         done

Die Funktionen `first'  und `rest'  funktionieren auch für Mengen.
Wird die Funktion `first' auf eine Menge angewendet, ist das Ergebnis
das erste Element, wie es in der Anzeige erscheint.  Ist `s' eine Menge,
dann ist der Ausdruck `rest(s)' äquivalent zu `disjoin(first(s), s)'.
Siehe die Funktion `disjoin'.

14.1.3 Programmfehler
---------------------

Die Möglichkeit mit den Funktionen `orderless'  und `ordergreat'

eine neue Ordnung für Variablen zu definieren, ist nicht kompatibel mit
den Funktionen für Mengen.  Wird eine der Funktionen `orderless' oder
`ordergreat' benötigt, sollten diese vor der Konstruktion der ersten
Menge ausgeführt werden.  Die Funktion `unorder'  sollte nicht
ausgeführt werden.

14.1.4 Autoren
--------------

Stavros Macrakis aus Cambridge, Massachusetts und Barton Willis von der
Universität Nebraska in Kearney (UNK) haben die Funktionen und die
Dokumentation für Mengen geschrieben.


File: maxima.info,  Node: Funktionen und Variablen für Mengen,  Prev: Einführung in Mengen,  Up: Mengen

14.2 Funktionen und Variablen für Mengen
========================================

 -- Funktion: adjoin (<x>, <a>)
     Vereinigt die Menge <a> mit `{<x>}' und gibt die vereinigte Menge
     als Ergebnis zurück.

     `adjoin' gibt eine Fehlermeldung, wenn das Argument <a> keine Menge
     ist.

     `adjoin(<x>, <a>)' und `union(set(<x>), <a>)' sind äquivalent.
     Die Funktion `adjoin' kann etwas schneller als die Funktion `union'
     sein.

     Siehe auch die Funktion `disjoin'.

     Beispiele:

          (%i1) adjoin (c, {a, b});
          (%o1)                       {a, b, c}
          (%i2) adjoin (a, {a, b});
          (%o2)                        {a, b}

 -- Funktion: belln (<n>)
     Repräsentiert die n-te Bellsche Zahl.

     Ist das Argument <n> eine nicht-negative ganze Zahl, vereinfacht
     `belln(<n>)' zu der n-ten Bellschen Zahl.  Für andere Argumente
     vereinfacht die Funktion `belln' nicht.

     Ist das Argument der Funktion `belln' eine Liste, Menge, Matrix
     oder eine Gleichung, wird die Funktion auf die Elemente oder beide
     Seiten der Gleichung angewendet.

     Beispiele:

     Anwendung der Funktion `belln' auf nicht-negative ganze Zahlen.

          (%i1) makelist (belln (i), i, 0, 6);
          (%o1)               [1, 1, 2, 5, 15, 52, 203]
          (%i2) is (cardinality (set_partitions ({})) = belln (0));
          (%o2)                         true
          (%i3) is (cardinality (set_partitions ({1, 2, 3, 4, 5, 6})) =
                                 belln (6));
          (%o3)                         true

     Anwendung der Funktion `belln' auf andere Argumente als
     nicht-negative ganze Zahlen.

          (%i1) [belln (x), belln (sqrt(3)), belln (-9)];
          (%o1)        [belln(x), belln(sqrt(3)), belln(- 9)]

 -- Funktion: cardinality (<a>)
     Gibt die Mächtigkeit (Kardinalität) einer Menge zurück.  Für
     endliche Mengen ist die Mächtigkeit die Anzahl der Elemente der
     Menge.

     Die Funktion `cardinality' ignoriert redundante Elemente einer
     Menge auch dann, wenn die Vereinfachung abgeschaltet ist.

     Beispiele:

          (%i1) cardinality ({});
          (%o1)                           0
          (%i2) cardinality ({a, a, b, c});
          (%o2)                           3
          (%i3) simp : false;
          (%o3)                         false
          (%i4) cardinality ({a, a, b, c});
          (%o4)                           3

 -- Funktion: cartesian_product (<b_1>, ..., <b_n>)
     Gibt das kartesische Produkt der Mengen <b_1>, ..., <b_n> zurück.
     Das kartesische Produkt ist die Menge der geordneten Paare.

     Das Ergebnis ist eine Menge mit Listen der Form `[<x_1>, ...,
     <x_n>]', wobei <x_1>, ..., <x_n> die Elemente der Mengen <b_1>,
     ..., <b_n> sind.

     Die Funktion `cartesian_product' gibt eine Fehlermeldung, wenn
     eines der Argumente keine Menge ist.

     Beispiele:

          (%i1) cartesian_product ({0, 1});
          (%o1)                      {[0], [1]}
          (%i2) cartesian_product ({0, 1}, {0, 1});
          (%o2)           {[0, 0], [0, 1], [1, 0], [1, 1]}
          (%i3) cartesian_product ({x}, {y}, {z});
          (%o3)                      {[x, y, z]}
          (%i4) cartesian_product ({x}, {-1, 0, 1});
          (%o4)              {[x, - 1], [x, 0], [x, 1]}

 -- Funktion: disjoin (<x>, <a>)
     Entfernt das Element <x> aus der Menge <a> und gibt das Ergebnis
     zurück.

     `disjoin' gibt eine Fehlermeldung, wenn das Argument <a> keine
     Menge ist.

     Die Ausdrücke `disjoin(<x>, <a>)', `delete(<x>, <a>)' und
     `setdifference(<a>, set(<x>))' sind äquivalent.  Von diesen
     Möglichkeiten ist im Allgemeinen die Funktion `disjoin' am
     schnellsten.

     Siehe auch die Funktion `adjoin'  sowie die Funktionen `delete'
     und `setdifference'.

     Beispiele:

          (%i1) disjoin (a, {a, b, c, d});
          (%o1)                       {b, c, d}
          (%i2) disjoin (a + b, {5, z, a + b, %pi});
          (%o2)                      {5, %pi, z}
          (%i3) disjoin (a - b, {5, z, a + b, %pi});
          (%o3)                  {5, %pi, b + a, z}

 -- Funktion: disjointp (<a>, <b>)
     `disjointp' hat das Ergebnis `true', wenn die Mengen <a> und <b>
     disjunkt sind.  Zwei Mengen sind disjunkt, wenn sie kein
     gemeinsames Element besitzen.

     `disjointp' gibt eine Fehlermeldung, wenn eines der Argumente keine
     Menge ist.

     Beispiele:

          (%i1) disjointp ({a, b, c}, {1, 2, 3});
          (%o1)                         true
          (%i2) disjointp ({a, b, 3}, {1, 2, 3});
          (%o2)                         false

 -- Funktion: divisors (<n>)
     Gibt die Menge der Teiler der Zahl <n> zurück.

     Ist das Argument <n> eine von Null verschiedene ganze Zahl,
     vereinfacht `divisors(<n>)' zu einer Menge mit ganzen Zahlen, die
     Teiler des Argumentes <n> sind.  Ist das Argument <n> eine
     negative Zahl wird der Betrag des Argumentes genommen.  Das
     Ergebnis enthält die Elemente <1> und <n>.

     Ist das Argument der Funktion `divisors' eine Liste, Menge, Matrix
     oder eine Gleichung, wird die Funktion auf die Elemente oder beide
     Seiten der Gleichung angewendet.

     Beispiele:

     Das Beispiel zeigt, dass 28 eine perfekte Zahl ist, die gleich die
     Summe ihrer Teiler außer sich selbst ist.

          (%i1) s: divisors(28);
          (%o1)                 {1, 2, 4, 7, 14, 28}
          (%i2) lreduce ("+", args(s)) - 28;
          (%o2)                          28

     `divisors' ist eine vereinfachende Funktion.  In diesem Beispiel
     braucht daher der Ausdruck nach der Substitution nicht erneut
     ausgewertet werden.

          (%i1) divisors (a);
          (%o1)                      divisors(a)
          (%i2) subst (8, a, %);
          (%o2)                     {1, 2, 4, 8}

     Anwendung der Funktion `divisors' auf Gleichungen, Listen,
     Matrizen oder Mengen.

          (%i1) divisors (a = b);
          (%o1)               divisors(a) = divisors(b)
          (%i2) divisors ([a, b, c]);
          (%o2)        [divisors(a), divisors(b), divisors(c)]
          (%i3) divisors (matrix ([a, b], [c, d]));
                            [ divisors(a)  divisors(b) ]
          (%o3)             [                          ]
                            [ divisors(c)  divisors(d) ]
          (%i4) divisors ({a, b, c});
          (%o4)        {divisors(a), divisors(b), divisors(c)}

 -- Funktion: elementp (<x>, <a>)
     Gibt `true' zurück, wenn das Argument <x> Element der Menge <a>
     ist.

     `elementp' gibt eine Fehlermeldung, wenn das Argument <a> keine
     Menge ist.

     Beispiele:

          (%i1) elementp (sin(1), {sin(1), sin(2), sin(3)});
          (%o1)                         true
          (%i2) elementp (sin(1), {cos(1), cos(2), cos(3)});
          (%o2)                         false

 -- Funktion: emptyp (<a>)
     Gibt `true' zurück, wenn das Argument <a> die leere Menge oder eine
     leere Liste ist.

     Beispiele:

          (%i1) map (emptyp, [{}, []]);
          (%o1)                     [true, true]
          (%i2) map (emptyp, [a + b, {{}}, %pi]);
          (%o2)                 [false, false, false]

 -- Funktion: equiv_classes (<s>, <F>)
     Gibt die Menge der Äquivalenzklassen der Menge <s> für die
     Äquivalenzrelation `F' zurück.

     Die Äquivalenzrelation `F' ist eine Funktion mit zwei Argumenten
     definiert auf dem Kartesischen Produkt der Menge <s> mit <s>.  Die
     Rückgabe der Funktion `F' ist `true' oder `false' oder ein
     Ausdruck <expr>, so dass `is(<expr>)' das Ergebnis `true' oder
     `false' hat.

     Ist <F> keine Äquivalenzrelation, wird die Funktion von
     `equiv_classes' ohne Fehlermeldung akzeptiert.  Das Ergebnis ist
     jedoch im Allgemeinen nicht korrekt.

     Beispiele:

     Die Äquivalenzrelation ist ein Lambda-Ausdruck mit den Ergebnissen
     `true' oder `false'.

          (%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0},
                                  lambda ([x, y], is (equal (x, y))));
          (%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}

     Die Äquivalenzrelation ist der Name einer relationalen Funktion,
     die von `is' zu `true' oder `false' ausgewertet wird.

          (%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0}, equal);
          (%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}

     Die Äquivalenzklassen sind Mengen mit Zahlen, die sich um ein
     Vielfaches von 3 voneinander unterscheiden.

          (%i1) equiv_classes ({1, 2, 3, 4, 5, 6, 7},
                               lambda ([x, y], remainder (x - y, 3) = 0));
          (%o1)              {{1, 4, 7}, {2, 5}, {3, 6}}

 -- Funktion: every (<f>, <s>)
 -- Funktion: every (<f>, <L_1>, ..., <L_n>)
     Gibt das Ergebnis `true' zurück, wenn die Aussage `f' das Ergebnis
     `true' für alle Elemente der Menge <s> hat.

     Ist das zweite Argument eine Menge, dann gibt `every(<f>, <s>)'
     den Wert `true' zurück, wenn `is(<f>(<a_i>))' das Ergebnis `true'
     für alle Elemente <a_i> der Menge <s> hat.  `every' wertet <f>
     nicht notwendigerweise für alle Elemente <a_i> aus, wenn das
     Ergebnis bereits feststeht.  Da Mengen nicht geordnet sind, kann
     die Funktion `every' die Ausdrücke `<f>(<a_i>)' in irgendeiner
     Reihenfolge auswerten.

     Sind die Argumente eine oder mehrere Listen, dann gibt `every(<f>,
     <L_1>, ..., <L_n>)' den Wert `true' zurück, wenn `is(<f>(<x_1>,
     ..., <x_n>))' das Ergebnis `true' für alle <x_1>, ..., <x_n> der
     Listen <L_1>, ..., <L_n> hat.  `every' wertet <f> wird nicht
     notwendigerweise für alle Kombinationen <x_1>, ..., <x_n> aus,
     wenn das Ergebnis bereits feststeht.  `every' wertet die Listen in
     der Reihenfolge des steigenden Index aus.

     Ist die leere Menge oder leere Liste ein Argument der Funktion
     `every', dann ist das Ergebnis immer `false'.

     Hat die Optionsvariable `maperror'  den Wert `true', müssen alle
     Listen <L_1>, ..., <L_n> die gleiche Länge haben.  Hat die
     Optionsvariable `maperror' den Wert `false', werden die Listen auf
     die Länge der kürzesten Liste abgeschnitten.

     Kann die Aussagefunktion <f> von der Funktion `is' nicht zu `true'
     oder `false' ausgewertet werden, hängt das Ergebnis von der
     Optionsvariablen `prederror'  ab.  Hat die Optionsvariable
     `prederror' den Wert `true', werden solche Werte als `false'
     behandelt und die Funktion `every' hat das Ergebnis `false'.  Hat
     `prederror' den Wert `false', werden solche Werte als `unknown'
     behandelt und die Funktion `every' hat das Ergebnis `unknown'.

     Beispiele:

     `every' angewendet auf eine Menge.  Die Aussagefunktion hat ein
     Argument.

          (%i1) every (integerp, {1, 2, 3, 4, 5, 6});
          (%o1)                         true
          (%i2) every (atom, {1, 2, sin(3), 4, 5 + y, 6});
          (%o2)                         false

     `every' angewendet auf zwei Listen.  Die Aussagefunktion hat zwei
     Argumente entsprechend der Anzahl der Listen.

          (%i1) every ("=", [a, b, c], [a, b, c]);
          (%o1)                         true
          (%i2) every ("#", [a, b, c], [a, b, c]);
          (%o2)                         false

     Kann die Aussagefunktion <f> nicht zu `true' oder `false'
     ausgewertet werden, hängt das Ergebnis von `every' von der
     Optionsvariablen `prederror' ab.

          (%i1) prederror : false;
          (%o1)                         false
          (%i2) map (lambda ([a, b], is (a < b)), [x, y, z],
                             [x^2, y^2, z^2]);
          (%o2)              [unknown, unknown, unknown]
          (%i3) every ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o3)                        unknown
          (%i4) prederror : true;
          (%o4)                         true
          (%i5) every ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o5)                         false

 -- Funktion: extremal_subset (<s>, <f>, max)
 -- Funktion: extremal_subset (<s>, <f>, min)
     Gibt die Teilmenge von <s> zurück, für die die Funktion <f>
     maximale oder minimale Ergebnisse hat.

     `extremal_subset(<s>, <f>, max)' gibt die Teilmenge der Liste oder
     Menge <s> zurück, für die die Funktion <f> ihre maximalen Werte
     annimmt.

     `extremal_subset(<s>, <f>, min)' gibt die Teilmenge der Liste oder
     Menge <s> zurück, für die die Funktion <f> ihre minimalen Werte
     annimmt.

     Beispiele:

          (%i1) extremal_subset ({-2, -1, 0, 1, 2}, abs, max);
          (%o1)                       {- 2, 2}
          (%i2) extremal_subset ({sqrt(2), 1.57, %pi/2}, sin, min);
          (%o2)                       {sqrt(2)}

 -- Funktion: flatten (<expr>)
     Sammelt die Argumente von allen Teilausdrücken, die denselben
     Operator wie der Ausdruck <expr> haben und konstruiert einen
     Ausdruck mit dem Operator des Ausdrucks <expr> und den Argumenten.
     Ein einfaches Beispiel ist eine verschachtelte Liste.  `flatten'
     konstruiert in diesem Fall eine Liste aus den Elementen aller
     Teillisten.

     Teilausdrücke, deren Operator sich von dem Hauptoperator des
     Ausdrucks <expr> unterscheidet, werden als ein Argument
     betrachtet, auch wenn der Teilausdrück wiederum Teilausdrücke des
     Hauptoperators enthält.

     Es ist möglich, dass `flatten' Ausdrücke konstruiert, in denen die
     Anzahl der Argumente nicht der erforderlichen Anzahl an Argumenten
     des Operators entspricht.  Dies kann zu Fehlermeldungen bei der
     Auswertung oder Vereinfachung führen.  `flatten' kontrolliert
     nicht, ob die konstruierten Ausdrücke gültig sind.

     Ausdrücke mit speziellen Darstellungen, wie zum Beispiel
     CRE-Ausdrücke, können von `flatten' nicht verarbeitet werden.  In
     diesem Fällen gibt `flatten' das Argument unverändert zurück.

     Beispiele:

     Wird `flatten' auf eine Liste angewendet, werden die Elemente aller
     Teillisten zu einer Liste zusammengefügt.

          (%i1) flatten ([a, b, [c, [d, e], f], [[g, h]], i, j]);
          (%o1)            [a, b, c, d, e, f, g, h, i, j]

     Wird `flatten' auf eine Menge angewendet, werden die Elemente aller
     Teilmengen zu einer Menge zusammengefügt.

          (%i1) flatten ({a, {b}, {{c}}});
          (%o1)                       {a, b, c}
          (%i2) flatten ({a, {[a], {a}}});
          (%o2)                       {a, [a]}

     Die Funktionsweise von `flatten' ist vergleichbar mit der
     Deklaration eines Operators als ein N-ary-Operator.  Im
     Unterschied zu einer Deklaration hat `flatten' keinen Einfluss auf
     Teilausdrücke, die einen vom Hauptoperator verschiedenen Operator
     haben.

          (%i1) expr: flatten (f (g (f (f (x)))));
          (%o1)                     f(g(f(f(x))))
          (%i2) declare (f, nary);
          (%o2)                         done
          (%i3) ev (expr);
          (%o3)                      f(g(f(x)))

     `flatten' kann Ausdrücke mit indizierte Funktionen vereinfachen.

          (%i1) flatten (f[5] (f[5] (x, y), z));
          (%o1)                      f (x, y, z)
                                      5

     Es ist möglich, dass `flatten' einen Ausdruck konstruiert, der
     nicht die korrekte Anzahl an Argumenten eines Operators enthält.

          (%i1) 'mod (5, 'mod (7, 4));
          (%o1)                   mod(5, mod(7, 4))
          (%i2) flatten (%);
          (%o2)                     mod(5, 7, 4)
          (%i3) ''%, nouns;
          Wrong number of arguments to mod
           -- an error.  Quitting.  To debug this try debugmode(true);

 -- Funktion: full_listify (<a>)
     Ersetzt jedes Auftreten des Operators für Mengen in dem Ausdruck
     <a> durch den Operator für Listen.  Die Ersetzung wird auch in
     verschachtelten Teilausdrücken ausgeführt, deren Operator nicht
     der Operator für Mengen ist.

     Die Funktion `listify'  ersetzt nur den Hauptoperator eines
     Ausdrucks.

     Beispiele:

          (%i1) full_listify ({a, b, {c, {d, e, f}, g}});
          (%o1)               [a, b, [c, [d, e, f], g]]
          (%i2) full_listify (F (G ({a, b, H({c, d, e})})));
          (%o2)              F(G([a, b, H([c, d, e])]))

 -- Funktion: fullsetify (<a>)
     Ist <a> eine Liste, wird der Operator für Listen durch den
     Operator für Mengen ersetzt.  Dann wird `fullsetify' auf alle
     Argumente der Liste angewendet.  Ist ein Argument keine Liste,
     wenn das Argument unverändert zurückgegeben.

     Die Funktion `setify'  ersetzt nur den Hauptoperator eines
     Ausdrucks.

     Beispiele:

     Im zweiten Beispiel wird das Argument der Funktion `f' nicht in
     eine Menge konvertiert, da der Operator des Teilausdrucks keine
     Liste ist.

          (%i1) fullsetify ([a, [a]]);
          (%o1)                       {a, {a}}
          (%i2) fullsetify ([a, f([b])]);
          (%o2)                      {a, f([b])}

 -- Funktion: identity (<x>)
     Gibt für jedes Argument <x> das Argument selbst zurück.

     Beispiele:

     `identity' kann als eine Aussagefunktion genutzt werden, wenn die
     Argumente boolesche Werte sind.

          (%i1) every (identity, [true, true]);
          (%o1)                         true

 -- Funktion: integer_partitions (<n>)
 -- Funktion: integer_partitions (<n>, <len>)
     Ermittelt die Zerlegung einer ganzen Zahl <n> in ganze Zahlen, die
     <n> als Summe haben.

     `integer_partitions(<n>)' gibt eine Menge aller Zerlegungen der
     ganzen Zahl <n> zurück.  Jede Zerlegung ist eine Liste mit den
     ganzen Zahlen, die <n> als Summe haben.  Die Listen sind nach der
     Größe sortiert.

     `integer_partitions(<n>, <len>)' gibt eine Menge aller Zerlegungen
     der ganzen Zahl <n> zurück, deren Listen `len' oder weniger
     Elemente haben.  Listen die weniger als `len' Elemente haben,
     werden mit Nullen aufgefüllt.

     Siehe auch die Funktionen `num_partitions'  und
     `num_distinct_partitions'.

     Beispiele:

          (%i1) integer_partitions (3);
          (%o1)               {[1, 1, 1], [2, 1], [3]}
          (%i2) s: integer_partitions (25)$
          (%i3) cardinality (s);
          (%o3)                         1958
          (%i4) map (lambda ([x], apply ("+", x)), s);
          (%o4)                         {25}
          (%i5) integer_partitions (5, 3);
          (%o5) {[2, 2, 1], [3, 1, 1], [3, 2, 0], [4, 1, 0], [5, 0, 0]}
          (%i6) integer_partitions (5, 2);
          (%o6)               {[3, 2], [4, 1], [5, 0]}

     Um alle Zerlegungen zu finden, die eine Bedingung erfüllen, kann
     die Funktion `subset'  genutzt werden.  In diesem Beispiel werden
     alle Zerlegungen der Zahl 10 ermittelt, die nur Primzahlen
     enthalten.

          (%i1) s: integer_partitions (10)$
          (%i2) cardinality (s);
          (%o2)                          42
          (%i3) xprimep(x) := integerp(x) and (x > 1) and primep(x)$
          (%i4) subset (s, lambda ([x], every (xprimep, x)));
          (%o4) {[2, 2, 2, 2, 2], [3, 3, 2, 2], [5, 3, 2], [5, 5], [7, 3]}

 -- Funktion: intersect (<a_1>, ..., <a_n>)
     `intersect' ist identisch mit der Funktion `intersection'.


 -- Funktion: intersection (<a_1>, ..., <a_n>)
     Gibt die Schnittmenge der Mengen <a_1>, ..., <a_n> zurück.  Die
     Schnittmenge enthält die Elemente, die den Mengen gemeinsam sind.

     `intersection' gibt eine Fehlermeldung, wenn eines der Argumente
     keine Menge ist.

     Beispiele:

          (%i1) S_1 : {a, b, c, d};
          (%o1)                     {a, b, c, d}
          (%i2) S_2 : {d, e, f, g};
          (%o2)                     {d, e, f, g}
          (%i3) S_3 : {c, d, e, f};
          (%o3)                     {c, d, e, f}
          (%i4) S_4 : {u, v, w};
          (%o4)                       {u, v, w}
          (%i5) intersection (S_1, S_2);
          (%o5)                          {d}
          (%i6) intersection (S_2, S_3);
          (%o6)                       {d, e, f}
          (%i7) intersection (S_1, S_2, S_3);
          (%o7)                          {d}
          (%i8) intersection (S_1, S_2, S_3, S_4);
          (%o8)                          {}

 -- Funktion: kron_delta (<x_1>, <x_2>, ..., <x_p>)
     Ist die Kronecker-Delta-Funktion.

     `kron_delta' vereinfacht zu `1', wenn die Argumente <x_i> und
     <y_i> für alle Paare gleich sind, und zu `0', wenn <x_i> und <y_i>
     nicht gleich sind für irgendein Paar der Argumente.  Die Gleichheit
     wird festgestellt mit `is(equal(xi,xj))' und die Ungleichheit mit
     `is(notequal(xi,xj))'.  Wird nur ein Argument angegeben,
     signalisiert die Funktion `kron_delta' einen Fehler.

     Beispiele:

          (%i1) kron_delta(a,a);
          (%o1)                                  1
          (%i2) kron_delta(a,b,a,b);
          (%o2)                          kron_delta(a, b)
          (%i3) kron_delta(a,a,b,a+1);
          (%o3)                                  0
          (%i4) assume(equal(x,y));
          (%o4)                            [equal(x, y)]
          (%i5) kron_delta(x,y);
          (%o5)                                  1

 -- Funktion: listify (<a>)
     Ist das Argument <a> eine Menge, werden die Elemente der Menge als
     eine Liste zurückgegeben.  Ansonsten wird <a> zurückgegeben.

     Siehe die Funktion `full_listify',  um auch Mengen in
     Teilausdrücken von <a> durch Listen zu ersetzen.

     Beispiele:

          (%i1) listify ({a, b, c, d});
          (%o1)                     [a, b, c, d]
          (%i2) listify (F ({a, b, c, d}));
          (%o2)                    F({a, b, c, d})

 -- Funktion: lreduce (<F>, <s>)
 -- Funktion: lreduce (<F>, <s>, <s_0>)
     Wendet eine Funktion <F>, die zwei Argumente hat, auf die Elemente
     einer Liste <s> an, indem die Funktionsaufrufe verkettet werden.

     Das Kommando `lreduce(<F>, <s>)' bildet den Ausdruck `F(...
     F(F(s_1, s_2), s_3), ... s_n)'.  Ist das optionale Argument <s_0>
     vorhanden, dann ist das Ergebnis äquivalent zu `lreduce(<F>,
     cons(<s_0>, <s>))'.

     Siehe auch `rreduce',  `xreduce'  und `tree_reduce'.

     Beispiele:

     `lreduce' ohne das optionale Argument.

          (%i1) lreduce (f, [1, 2, 3]);
          (%o1)                     f(f(1, 2), 3)
          (%i2) lreduce (f, [1, 2, 3, 4]);
          (%o2)                  f(f(f(1, 2), 3), 4)

     `lreduce' mit dem optionalen Argument.

          (%i1) lreduce (f, [1, 2, 3], 4);
          (%o1)                  f(f(f(4, 1), 2), 3)

     `lreduce' mit den binären Operatoren der Exponentiation "^" und der
     Division "/".

          (%i1) lreduce ("^", args ({a, b, c, d}));
                                         b c d
          (%o1)                       ((a ) )
          (%i2) lreduce ("/", args ({a, b, c, d}));
                                          a
          (%o2)                         -----
                                        b c d

 -- Funktion: makeset (<expr>, <x>, <s>)
     Generiert eine Menge, indem der Ausdruck <expr> ausgewertet wird,
     wobei das Argument <x> eine Liste mit Variablen des Ausdrucks und
     <s> eine Menge oder eine Liste mit Listen ist.  Ein Element der
     Menge wird generiert, indem die Variablen in <x> nacheinander an
     die Elemente in <s> gebunden werden.

     Jedes Element des Argumentes <s> muss dieselbe Länge wie <x> haben.
     Die Liste der Variablen <x> muss eine List mit Symbolen sein.
     Indizierte Variablen sind nicht möglich.  Auch wenn nur eine
     Variable angegeben wird, muss diese Element einer Liste sein und
     jedes Element von <s> muss eine Liste mit einem Element sein.

     Siehe auch die Funktion `makelist',  um eine Liste zu generieren.

     Beispiele:

          (%i1) makeset (i/j, [i, j], [[1, a], [2, b], [3, c], [4, d]]);
                                     1  2  3  4
          (%o1)                     {-, -, -, -}
                                     a  b  c  d
          (%i2) S : {x, y, z}$
          (%i3) S3 : cartesian_product (S, S, S);
          (%o3) {[x, x, x], [x, x, y], [x, x, z], [x, y, x], [x, y, y],
          [x, y, z], [x, z, x], [x, z, y], [x, z, z], [y, x, x],
          [y, x, y], [y, x, z], [y, y, x], [y, y, y], [y, y, z],
          [y, z, x], [y, z, y], [y, z, z], [z, x, x], [z, x, y],
          [z, x, z], [z, y, x], [z, y, y], [z, y, z], [z, z, x],
          [z, z, y], [z, z, z]}
          (%i4) makeset (i + j + k, [i, j, k], S3);
          (%o4) {3 x, 3 y, y + 2 x, 2 y + x, 3 z, z + 2 x, z + y + x,
                                                 z + 2 y, 2 z + x, 2 z + y}
          (%i5) makeset (sin(x), [x], {[1], [2], [3]});
          (%o5)               {sin(1), sin(2), sin(3)}

 -- Funktion: moebius (<n>)
     Ist die Möbiusfunktion.

     Ist die natürliche Zahl <n> quadratfrei, dann vereinfacht die
     Möbiusfunktion zu `-1^k', wobei <k> die Anzahl der Primfaktoren der
     Zahl <n> ist.  Eine Zahl ist quadratfrei, wenn sie nur voneinander
     verschiedene Primfaktoren hat.  Für `<n> = 1' vereinfacht die
     Möbiusfunktion zu `1' und für alle anderen positiven ganzen Zahlen
     zum Wert `0'.  Für andere Argumente wird eine Substantivform als
     Ergebnis zurückgegeben.

     Ist das Argument der Funktion `moebius' eine Liste, Menge, Matrix
     oder eine Gleichung, wird die Funktion auf die Elemente oder beide
     Seiten der Gleichung angewendet.

     Beispiele:

          (%i1) moebius (1);
          (%o1)                           1
          (%i2) moebius (2 * 3 * 5);
          (%o2)                          - 1
          (%i3) moebius (11 * 17 * 29 * 31);
          (%o3)                           1
          (%i4) moebius (2^32);
          (%o4)                           0
          (%i5) moebius (n);
          (%o5)                      moebius(n)
          (%i6) moebius (n = 12);
          (%o6)                    moebius(n) = 0
          (%i7) moebius ([11, 11 * 13, 11 * 13 * 15]);
          (%o7)                      [- 1, 1, 1]
          (%i8) moebius (matrix ([11, 12], [13, 14]));
                                     [ - 1  0 ]
          (%o8)                      [        ]
                                     [ - 1  1 ]
          (%i9) moebius ({21, 22, 23, 24});
          (%o9)                      {- 1, 0, 1}

 -- Funktion: multinomial_coeff (<a_1>, ..., <a_n>)
 -- Funktion: multinomial_coeff ()
     Gibt den Multinomialkoeffizienten zurück.  Im Spezialfall `<k> = 2'
     ergibt sich die Binomialverteilung.  Siehe `binomial'.

     Enthält das Ergebnis Fakultäten, kann das Ergebnis möglicherweise
     mit der Funktion `minfactorial'  weiter vereinfacht werden.

     Beispiele:

          (%i1) multinomial_coeff (1, 2, x);
                                      (x + 3)!
          (%o1)                       --------
                                        2 x!
          (%i2) minfactorial (%);
                               (x + 1) (x + 2) (x + 3)
          (%o2)                -----------------------
                                          2
          (%i3) multinomial_coeff (-6, 2);
                                       (- 4)!
          (%o3)                       --------
                                      2 (- 6)!
          (%i4) minfactorial (%);
          (%o4)                          10

 -- Funktion: num_distinct_partitions (<n>)
 -- Funktion: num_distinct_partitions (<n>, list)
     Gibt die Anzahl der Möglichkeiten an, eine natürliche Zahl <n> in
     Summanden zu zerlegen, wobei jeder Summand nur einmal vorkommt.
     Ist <n> keine natürliche Zahl wird eine Substantivform als
     Ergebnis zurückgegeben.

     `num_distinct_partitions(<n>, list)' gibt eine Liste mit der Anzahl
     der voneinander verschiedenen Partitionen der natürlichen Zahlen
     1, 2, 3, ..., <n> zurück.

     Siehe auch die Funktionen `num_partitions'  und
     `integer_partitions'.

     Beispiele:

          (%i1) num_distinct_partitions (12);
          (%o1)                          15
          (%i2) num_distinct_partitions (12, list);
          (%o2)      [1, 1, 1, 2, 2, 3, 4, 5, 6, 8, 10, 12, 15]
          (%i3) num_distinct_partitions (n);
          (%o3)              num_distinct_partitions(n)

 -- Funktion: num_partitions (<n>)
 -- Funktion: num_partitions (<n>, list)
     Gibt die Anzahl der Möglichkeiten an, eine natürliche Zahl <n> in
     Summanden zu zerlegen.  Ist <n> keine natürliche Zahl wird eine
     Substantivform als Ergebnis zurückgegeben.

     `num_partitions(<n>, list)' gibt eine Liste mit der Anzahl der
     Partitionen der natürlichen Zahlen 1, 2, 3, ..., <n> zurück.

     Das Kommando `num_partitions(<n>)' ist für eine natürliche Zahl
     <n> äquivalent zu `cardinality(integer_partitions(<n>))'.  Da die
     Funktion `num_partitions' die Menge nicht konstruiert, ist diese
     Funktion deutlich schneller.

     Siehe auch die Funktionen `num_distinct_partitions'  und
     `integer_partitions'.

     Beispiele:

          (%i1) num_partitions (5) = cardinality (integer_partitions (5));
          (%o1)                         7 = 7
          (%i2) num_partitions (8, list);
          (%o2)            [1, 1, 2, 3, 5, 7, 11, 15, 22]
          (%i3) num_partitions (n);
          (%o3)                   num_partitions(n)

 -- Funktion: partition_set (<a>, <f>)
     Zerlegt eine Menge <a> mit der Aussagefunktion <f>.

     `partition_set' gibt eine Liste mit zwei Elementen zurück.  Das
     erste Element ist die Menge der Elemente, für die die
     Aussagefunktion <f> zu `false' ausgewertet wird.  Das zweite
     Element ist die Menge aller anderen Elemente.  `partition_set'
     wendet nicht die Funktion `is' auf das Ergebnis der
     Aussagefunktion <f> an.

     `partition_set' gibt eine Fehlermeldung, wenn <a> keine Menge ist.

     Siehe auch die Funktion `subset'.

     Beispiele:

          (%i1) partition_set ({2, 7, 1, 8, 2, 8}, evenp);
          (%o1)                   [{1, 7}, {2, 8}]
          (%i2) partition_set ({x, rat(y), rat(y) + z, 1},
                               lambda ([x], ratp(x)));
          (%o2)/R/              [{1, x}, {y, y + z}]

 -- Funktion: permutations (<a>)
     Gibt eine Menge mit allen voneinander verschiedenen Permutationen
     der Elemente der Liste oder Menge <a> zurück.  Die Permutationen
     sind Listen.

     Ist das Argument <a> eine Liste, werden auch doppelte Elemente in
     die möglichen Permutationen eingeschlossen.

     `permutations' gibt eine Fehlermeldung, wenn <a> keine Liste oder
     Menge ist.

     Siehe auch die Funktion `random_permutation'.

     Beispiele:

          (%i1) permutations ([a, a]);
          (%o1)                       {[a, a]}
          (%i2) permutations ([a, a, b]);
          (%o2)           {[a, a, b], [a, b, a], [b, a, a]}

 -- Funktion: powerset (<a>)
 -- Funktion: powerset (<a>, <n>)
     Gibt die Menge aller Teilmengen der Menge <a> oder eine Teilmenge
     dieser Menge zurück.

     `powerset(<a>)' gibt die Menge aller Teilmengen der Menge <a>
     zurück.  Die Ergebnismenge hat `2^cardinality(<a>)' Elemente.

     `powerset(<a>, <n>)' gibt die Menge aller Teilmengen der Menge <a>
     zurück, die die Mächtigkeit <n> haben.

     `powerset' gibt eine Fehlermeldung, wenn <a> keine Menge oder <n>
     keine natürliche Zahl ist.

     Beispiele:

          (%i1) powerset ({a, b, c});
          (%o1) {{}, {a}, {a, b}, {a, b, c}, {a, c}, {b}, {b, c}, {c}}
          (%i2) powerset ({w, x, y, z}, 4);
          (%o2)                    {{w, x, y, z}}
          (%i3) powerset ({w, x, y, z}, 3);
          (%o3)     {{w, x, y}, {w, x, z}, {w, y, z}, {x, y, z}}
          (%i4) powerset ({w, x, y, z}, 2);
          (%o4)   {{w, x}, {w, y}, {w, z}, {x, y}, {x, z}, {y, z}}
          (%i5) powerset ({w, x, y, z}, 1);
          (%o5)                 {{w}, {x}, {y}, {z}}
          (%i6) powerset ({w, x, y, z}, 0);
          (%o6)                         {{}}

 -- Funktion: random_permutation (<a>)
     Gibt eine zufällige Permutation der Menge oder Liste <a> zurück,
     die mit dem Knuth-Misch-Algorithmus generiert wird.

     Die Rückgabe ist eine neue Liste, die verschieden vom Argument <a>.
     Jedoch werden nicht die Elemente kopiert.

     Beispiele:

          (%i1) random_permutation ([a, b, c, 1, 2, 3]);
          (%o1)                  [c, 1, 2, 3, a, b]
          (%i2) random_permutation ([a, b, c, 1, 2, 3]);
          (%o2)                  [b, 3, 1, c, a, 2]
          (%i3) random_permutation ({x + 1, y + 2, z + 3});
          (%o3)                 [y + 2, z + 3, x + 1]
          (%i4) random_permutation ({x + 1, y + 2, z + 3});
          (%o4)                 [x + 1, y + 2, z + 3]

 -- Funktion: rreduce (<F>, <s>)
 -- Funktion: rreduce (<F>, <s>, <s_{n + 1}>)
     Wendet eine Funktion <F>, die zwei Argumente hat, auf die Elemente
     einer Liste <s> an, indem die Funktionsaufrufe verkettet werden.

     Das Kommando `rreduce(<F>, <s>)' bildet den Ausdruck `F(s_1, ...
     F(s_{n - 2}, F(s_{n - 1}, s_n)))'.  Ist das optionale Argument
     <s_0> vorhanden, dann ist das Ergebnis äquivalent zu `rreduce(<F>,
     endcons(<s_{n + 1}>, <s>))'.

     Siehe auch `lreduce',  `xreduce'  und `tree_reduce'.

     Beispiele:

     `rreduce' ohne das optionale Argument.

          (%i1) rreduce (f, [1, 2, 3]);
          (%o1)                     f(1, f(2, 3))
          (%i2) rreduce (f, [1, 2, 3, 4]);
          (%o2)                  f(1, f(2, f(3, 4)))

     `rreduce' mit dem optionalen Argument.

          (%i1) rreduce (f, [1, 2, 3], 4);
          (%o1)                  f(1, f(2, f(3, 4)))

     `rreduce' mit den binären Operatoren der Exponentiation "^" und der
     Division "/".

          (%i1) rreduce ("^", args ({a, b, c, d}));
                                           d
                                          c
                                         b
          (%o1)                         a
          (%i2) rreduce ("/", args ({a, b, c, d}));
                                         a c
          (%o2)                          ---
                                         b d

 -- Funktion: setdifference (<a>, <b>)
     Gibt eine Menge mit den Elementen zurück, die in der Menge <a>,
     aber nicht in der Menge <b> enthalten sind.

     `setdifference' gibt eine Fehlermeldung, wenn die Argumente <a>
     oder <b> keine Mengen sind.

     Beispiele:

          (%i1) S_1 : {a, b, c, x, y, z};
          (%o1)                  {a, b, c, x, y, z}
          (%i2) S_2 : {aa, bb, c, x, y, zz};
          (%o2)                 {aa, bb, c, x, y, zz}
          (%i3) setdifference (S_1, S_2);
          (%o3)                       {a, b, z}
          (%i4) setdifference (S_2, S_1);
          (%o4)                     {aa, bb, zz}
          (%i5) setdifference (S_1, S_1);
          (%o5)                          {}
          (%i6) setdifference (S_1, {});
          (%o6)                  {a, b, c, x, y, z}
          (%i7) setdifference ({}, S_1);
          (%o7)                          {}

 -- Funktion: setequalp (<a>, <b>)
     Gibt das Ergebnis `true' zurück, wenn die Mengen <a> und <b>
     dieselbe Anzahl an Elementen haben und der Ausdruck `is(<x> = <y>)'
     das Ergebnis `true' für alle Elemente <x> der Menge <a> und <y>
     der Menge <b> hat.  Dabei haben die Elemente eine Ordnung wie sie
     von der Funktion `listify' generiert wird.  Ansonsten ist das
     Ergebnis `false'.

     Beispiele:

          (%i1) setequalp ({1, 2, 3}, {1, 2, 3});
          (%o1)                         true
          (%i2) setequalp ({a, b, c}, {1, 2, 3});
          (%o2)                         false
          (%i3) setequalp ({x^2 - y^2}, {(x + y) * (x - y)});
          (%o3)                         false

 -- Funktion: setify (<a>)
     Konstruiert eine Menge aus den Elementen der Liste <a>.  Doppelte
     Elemente der Liste <a> werden entfernt und die Elemente werden mit
     der Aussagefunktion `orderlessp'  sortiert.

     `setify' gibt eine Fehlermeldung, wenn <a> keine Liste ist.

     Beispiele:

          (%i1) setify ([1, 2, 3, a, b, c]);
          (%o1)                  {1, 2, 3, a, b, c}
          (%i2) setify ([a, b, c, a, b, c]);
          (%o2)                       {a, b, c}
          (%i3) setify ([7, 13, 11, 1, 3, 9, 5]);
          (%o3)                {1, 3, 5, 7, 9, 11, 13}

 -- Funktion: setp (<a>)
     Gibt das Ergebnis `true' zurück, wenn das Argument <a> eine Menge
     ist.

     `setp' gibt `true' auch für Mengen zurück, die noch nicht
     vereinfacht sind, also möglicherweise doppelte Elemente enthalten.

     `setp' ist äquivalent zu dem Kommando `setp(a) := not atom(a) and
     op(a) = 'set'.

     Beispiele:

          (%i1) simp : false;
          (%o1)                         false
          (%i2) {a, a, a};
          (%o2)                       {a, a, a}
          (%i3) setp (%);
          (%o3)                         true

 -- Funktion: set_partitions (<a>)
 -- Funktion: set_partitions (<a>, <n>)
     Gibt die Menge aller Partitionen der Menge <a> oder eine Teilmenge
     dieser Menge zurück.

     `set_partitions(<a>, <n>)' gibt eine Menge aller Zerlegungen der
     Menge <a> in <n> nicht-leere voneinander disjunkte Teilmengen
     zurück.

     `set_partitions(<a>)' gibt die Menge aller Zerlegungen zurück.

     `stirling2'  gibt die Mächtigkeit einer Menge zurück, die alle
     Zerlegungen einer Menge enthält.

     Eine Menge mit Zerlegungen P ist eine Zerlegung der Menge S, wenn

       1. jedes Elemente der Menge P eine nicht-leere Menge ist,

       2. verschiedene Elemente der Menge P voneinander disjunkt sind,

       3. die Vereinigung von Elementen der Menge P gleich der Menge S
          ist.

     Beispiele:

     Die leere Menge ist eine Zerlegung von sich selbst.

          (%i1) set_partitions ({});
          (%o1)                         {{}}

     Die Mächtigkeit der Menge der Zerlegungen einer Menge kann mit der
     Funktion `stirling2' ermittelt werden.

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) cardinality(p) = stirling2 (6, 3);
          (%o3)                        90 = 90

     Jedes Element der Menge `p' hat 3 Elemente.

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) map (cardinality, p);
          (%o3)                          {3}

     Für jedes Element der Menge `p', ist die Vereinigung ihrer Elemente
     gleich der Menge `s'.

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) map (lambda ([x], apply (union, listify (x))), p);
          (%o3)                 {{0, 1, 2, 3, 4, 5}}

 -- Funktion: some (<f>, <a>)
 -- Funktion: some (<f>, <L_1>, ..., <L_n>)
     Gibt das Ergebnis `true' zurück, wenn die Aussage <f> das Ergebnis
     `true' für eines oder mehrere Argumente hat.

     Ist eine Menge <a> als Argument gegeben, gibt `some(<f>, <s>)' das
     Ergebnis `true' zurück, wenn `is(<f>(<a_i>))' das Ergebnis `true'
     für eines oder mehrere Elemente <a_i> der Menge <a> hat.  `some'
     wertet <f> nicht notwendigerweise für alle Elemente <a_i> aus,
     wenn das Ergebnis bereits feststeht.  Da Mengen nicht geordnet
     sind, kann die Funktion `some' die Ausdrücke `<f>(<a_i>)' in
     irgendeiner Reihenfolge auswerten.

     Sind die Argumente eine oder mehrere Listen, dann gibt `some(<f>,
     <L_1>, ..., <L_n>)' den Wert `true' zurück, wenn `is(<f>(<x_1>,
     ..., <x_n>))' das Ergebnis `true' für eines oder mehrere Elemente
     <x_1>, ..., <x_n> der Listen <L_1>, ..., <L_n> hat.  `some' wertet
     <f> wird nicht notwendigerweise für alle Kombinationen <x_1>, ...,
     <x_n> aus, wenn das Ergebnis bereits feststeht.  `some' wertet die
     Listen in der Reihenfolge des steigenden Index aus.

     Ist die leere Menge `{}' oder die leere Liste  `[]' unter den
     Argumenten, ist das Ergebnis immer `false'.

     Hat die Optionsvariable `maperror'  den Wert `true', müssen alle
     Listen <L_1>, ..., <L_n> die gleiche Länge haben.  Hat die
     Optionsvariable `maperror' den Wert `false', werden Listen auf die
     Länge der kürzesten Liste abgeschnitten.

     Kann die Aussagefunktion <f> von der Funktion `is' nicht zu `true'
     oder `false' ausgewertet werden, hängt das Ergebnis von der
     Optionsvariablen `prederror'  ab.  Hat die Optionsvariable
     `prederror' den Wert `true', werden solche Werte als `false'
     behandelt.  Hat `prederror' den Wert `false', werden solche Werte
     als `unknown' behandelt.

     Beispiele:

     `some' für eine Menge als Argument.  Die Aussage ist eine Funktion
     mit einem Argument.

          (%i1) some (integerp, {1, 2, 3, 4, 5, 6});
          (%o1)                         true
          (%i2) some (atom, {1, 2, sin(3), 4, 5 + y, 6});
          (%o2)                         true

     `some' angewendet auf zwei Listen.  Die Aussage ist eine Funktion
     mit zwei Argumenten.

          (%i1) some ("=", [a, b, c], [a, b, c]);
          (%o1)                         true
          (%i2) some ("#", [a, b, c], [a, b, c]);
          (%o2)                         false

     Ergebnisse der Aussage <f>, die zu einem Ergebnis verschieden von
     `true' oder `false' auswerten,  werden von der Optionsvariablen
     `prederror' kontrolliert.

          (%i1) prederror : false;
          (%o1)                         false
          (%i2) map (lambda ([a, b], is (a < b)), [x, y, z],
                     [x^2, y^2, z^2]);
          (%o2)              [unknown, unknown, unknown]
          (%i3) some ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o3)                        unknown
          (%i4) some ("<", [x, y, z], [x^2, y^2, z + 1]);
          (%o4)                         true
          (%i5) prederror : true;
          (%o5)                         true
          (%i6) some ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o6)                         false
          (%i7) some ("<", [x, y, z], [x^2, y^2, z + 1]);
          (%o7)                         true

 -- Funktion: stirling1 (<n>, <m>)
     Berechnet Stirling-Zahlen der ersten Art.

     Sind die Argumente <n> und <m> natürliche Zahlen, ist der Wert von
     `stirling1(<n>, <m>)' die Anzahl der Permutationen einer Menge mit
     <n> Elementen, die <m> Zyklen hat.  Für Details siehe Graham,
     Knuth und Patashnik in Conrecte Mathematics.  Maxima nutzt eine
     Rekursion, um `stirling1(<n>, <m>)' für <m> kleiner als `0' zu
     berechnen.  Die Funktion ist nicht definiert für `n' kleiner als
     `0' und für Argumente die keine ganze Zahlen sind.

     `stirling1' ist eine vereinfachende Funktion.  Maxima kennt die
     folgenden Beziehungen (siehe [1]).

        * `stirling1(0, n) = kron_delta(0, n)'

        * `stirling1(n, n) = 1'

        * `stirling1(n, n - 1) = binomial(n, 2)'

        * `stirling1(n + 1, 0) = 0'

        * `stirling1(n + 1, 1) = n!'

        * `stirling1(n + 1, 2) = 2^n  - 1'

     Diese Beziehungen werden angewendet, wenn die Argumente ganze
     Zahlen oder Symbole sind, die als ganze Zahlen deklariert sind,
     und das erste Argument keine negative Zahl ist.  `stirling1'
     vereinfacht nicht für Argumente, die keine ganzen Zahlen sind.

     Referenz:

     [1] Donald Knuth, The Art of Computer Programming, third edition,
     Volume 1, Section 1.2.6, Equations 48, 49, and 50.

     Beispiele:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling1 (n, n);
          (%o3)                           1

     `stirling1' vereinfacht nicht für Argumente, die keine ganzen
     Zahlen sind.

          (%i1) stirling1 (sqrt(2), sqrt(2));
          (%o1)              stirling1(sqrt(2), sqrt(2))

     Maxima kennt Vereinfachungen der Funktion `stirling1'.

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling1 (n + 1, n);
                                      n (n + 1)
          (%o3)                       ---------
                                          2
          (%i4) stirling1 (n + 1, 1);
          (%o4)                          n!

 -- Funktion: stirling2 (<n>, <m>)
     Berechnet Stirling-Zahlen der zweiten Art.

     Sind die Argumente <n> und <m> natürliche Zahlen, ist der Wert von
     `stirling2(<n>, <m>)' die Anzahl der Möglichkeiten, mit der eine
     Menge der Mächtigkeit <n> in <m> disjunkte Mengen zerlegt werden
     kann.  Maxima nutzt eine Rekursion, um `stirling2(<n>, <m>)' für
     <m> kleiner als `0' zu berechnen.  Die Funktion ist nicht
     definiert für `n' kleiner als `0' und für Argumente, die keine
     ganze Zahlen sind.

     `stirling2' ist eine vereinfachende Funktion.  Maxima kennt die
     folgenden Beziehungen (siehe [1], [2], [3]).

        * `stirling2(0, n) = kron_delta(0, n)'

        * `stirling2(n, n) = 1'

        * `stirling2(n, n - 1) = binomial(n, 2)'

        * `stirling2(n + 1, 1) = 1'

        * `stirling2(n + 1, 2) = 2^n  - 1'

        * `stirling2(n, 0) = kron_delta(n, 0)'

        * `stirling2(n, m) = 0' für `m > n'

        * `stirling2(n, m) = sum((-1)^(m - k) binomial(m k) k^n,i,1,m)
          / m!', wenn m und n ganze Zahlen und n eine natürliche Zahl
          ist.

     Diese Beziehungen werden angewendet, wenn die Argumente ganze
     Zahlen oder Symbole sind, die als ganze Zahlen deklariert sind,
     und das erste Argument keine negative Zahl ist.  `stirling2'
     vereinfacht nicht für Argumente, die keine ganzen Zahlen sind.

     Referenzen:

     [1] Donald Knuth.  The Art of Computer Programming,     third
     edition, Volume 1, Section 1.2.6, Equations 48, 49, and 50.

     [2] Graham, Knuth, and Patashnik.  Concrete Mathematics, Table 264.

     [3] Abramowitz and Stegun.  Handbook of Mathematical Functions,
     Section 24.1.4.

     Beispiele:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling2 (n, n);
          (%o3)                           1

     `stirling2' vereinfacht nicht, wenn die Argumente keine ganze
     Zahlen sind.

          (%i1) stirling2 (%pi, %pi);
          (%o1)                  stirling2(%pi, %pi)

     Maxima kennt Vereinfachungen der Funktion `stirling2'.

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling2 (n + 9, n + 8);
                                   (n + 8) (n + 9)
          (%o3)                    ---------------
                                          2
          (%i4) stirling2 (n + 1, 2);
                                        n
          (%o4)                        2  - 1

 -- Funktion: subset (<a>, <f>)
     Gibt eine Teilmenge der Menge <a> zurück, deren Elemente der
     Bedingung <f> genügen.

     `subset' gibt eine Menge zurück, die alle Elemente der Menge <a>
     enthält, die für die Bedingung <f> ein von `false' verschiedenes
     Ergebnis haben.  `subset' wendet nicht die Funktion `is' auf das
     Ergebnis der Bedingung `f' an.

     `subset' gibt eine Fehlermeldung, wenn das Argument <a> keine Menge
     ist.

     Siehe auch die Funktion `partition_set'.

     Beispiele:

          (%i1) subset ({1, 2, x, x + y, z, x + y + z}, atom);
          (%o1)                     {1, 2, x, z}
          (%i2) subset ({1, 2, 7, 8, 9, 14}, evenp);
          (%o2)                      {2, 8, 14}

 -- Funktion: subsetp (<a>, <b>)
     Gibt das Ergebnis `true' zurück, wenn die Menge <a> einer Teilmenge
     der Menge <b> ist.

     `subsetp' gibt eine Fehlermeldung, wenn eines der Argumente keine
     Menge ist.

     Beispiele:

          (%i1) subsetp ({1, 2, 3}, {a, 1, b, 2, c, 3});
          (%o1)                         true
          (%i2) subsetp ({a, 1, b, 2, c, 3}, {1, 2, 3});
          (%o2)                         false

 -- Funktion: symmdifference (<a_1>, ..., <a_n>)
     Gibt die symmetrische Differenz der Mengen `<a_1>, ..., <a_n>'
     zurück.  Für zwei Argumente ist die symmetrische Differenz
     äquivalent zu `union(setdifference(<a>, <b>), setdifference(<b>,
     <a>))'.

     `symmdifference' gibt eine Fehlermeldung, wenn eines der Argumente
     keine Menge ist.

     Beispiele:

          (%i1) S_1 : {a, b, c};
          (%o1)                       {a, b, c}
          (%i2) S_2 : {1, b, c};
          (%o2)                       {1, b, c}
          (%i3) S_3 : {a, b, z};
          (%o3)                       {a, b, z}
          (%i4) symmdifference ();
          (%o4)                          {}
          (%i5) symmdifference (S_1);
          (%o5)                       {a, b, c}
          (%i6) symmdifference (S_1, S_2);
          (%o6)                        {1, a}
          (%i7) symmdifference (S_1, S_2, S_3);
          (%o7)                        {1, b, z}
          (%i8) symmdifference ({}, S_1, S_2, S_3);
          (%o8)                        {1,b, z}

 -- Funktion: tree_reduce (<F>, <s>)
 -- Funktion: tree_reduce (<F>, <s>, <s_0>)
     Wendet eine Funktion <F>, die zwei Argumente hat, auf die Elemente
     einer Liste oder Menge <s> an, indem die Funktionsaufrufe
     verkettet werden.

     `tree_reduce' führt folgende Operationen aus: Die Funktion <F> wird
     auf Paare von Elementen der Liste <s> angewendet, wodurch die neue
     Liste `[<F>(<s_1>, <s_2>), <F>(<s_3>, <s_4>), ...]' entsteht.  Hat
     die Liste eine ungerade Anzahl an Elementen, bleibt das letzte
     Element unverändert.  Dann wird das Verfahren solange wiederholt,
     bis nur noch ein einziges Element übrig ist.  Dieses wird als
     Ergebnis zurückgegeben.

     Ist das optionale Argument <s_0> vorhanden, dann ist das Ergebnis
     äquivalent zu `tree_reduce(<F>, cons(<s_0>, <s>)'.

     Werden Gleitkommazahlen addiert, dann kann `tree_reduce' ein
     Ergebnis mit einem kleineren Rundungsfehler als `lreduce'  oder
     `rreduce'

     liefern.

     Siehe auch `lreduce',  `rreduce'  und `xreduce'.

     Beispiele:

     `tree_reduce' angewendet auf eine Liste mit einer geraden Anzahl an
     Elementen.

          (%i1) tree_reduce (f, [a, b, c, d]);
          (%o1)                  f(f(a, b), f(c, d))

     `tree_reduce' angewendet auf eine List mit einer ungeraden Anzahl
     an Elementen.

          (%i1) tree_reduce (f, [a, b, c, d, e]);
          (%o1)               f(f(f(a, b), f(c, d)), e)

 -- Funktion: union (<a_1>, ..., <a_n>)
     Gibt die Vereinigung der Mengen <a_1>, ..., <a_n> zurück.  Wird
     `union' ohne ein Argument aufgerufen, wird die leere Menge
     zurückgegeben.

     `union' gibt eine Fehlermeldung, wenn eines der Argumente keine
     Menge ist.

     Beispiele:

          (%i1) S_1 : {a, b, c + d, %e};
          (%o1)                   {%e, a, b, d + c}
          (%i2) S_2 : {%pi, %i, %e, c + d};
          (%o2)                 {%e, %i, %pi, d + c}
          (%i3) S_3 : {17, 29, 1729, %pi, %i};
          (%o3)                {17, 29, 1729, %i, %pi}
          (%i4) union ();
          (%o4)                          {}
          (%i5) union (S_1);
          (%o5)                   {%e, a, b, d + c}
          (%i6) union (S_1, S_2);
          (%o6)              {%e, %i, %pi, a, b, d + c}
          (%i7) union (S_1, S_2, S_3);
          (%o7)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}
          (%i8) union ({}, S_1, S_2, S_3);
          (%o8)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}

 -- Funktion: xreduce (<F>, <s>)
 -- Funktion: xreduce (<F>, <s>, <s_0>)
     Wendet eine Funktion <F>, die zwei Argumente hat, auf die Elemente
     einer Liste oder Menge <s> an, indem die Funktionsaufrufe
     verkettet werden.  Ist die Funktion eine N-ary-Funktion wird die
     Funktion <F> auf die Liste angewendet.  Ist die Funktion <F> keine
     N-ary_Funktion ist `xreduce' äquivalent zu `lreduce'.

     Folgende N-ary-Funktionen und Operatoren kennt `xreduce': Addition
     `"+"', Multiplikation `"*"', `and', `or', `max', `min' und
     `append'.  Funktionen und Operatoren können mit der Funktion
     `declare'  als `nary'  deklariert werden.  Für diese Funktionen
     ist `xreduce' schneller als `lreduce'  oder `rreduce'.

     Ist das optionale Argument <s_0> vorhanden, dann ist das Ergebnis
     äquivalent zu `xreduce(<s>, cons(<s_0>, <s>))'.

     Siehe auch `lreduce',  `rreduce'  und `tree_reduce'.

     Beispiele:

     `xreduce' angewendet mit einer N-ary-Funktion.  `F' wird einmal mit
     allen Argumenten aufgerufen.

          (%i1) declare (F, nary);
          (%o1)                         done
          (%i2) F ([L]) := L;
          (%o2)                      F([L]) := L
          (%i3) xreduce (F, [a, b, c, d, e]);
          (%o3)         [[[[[("[", simp), a], b], c], d], e]

     `xreduce' angewendet mit einer Funktion, die nicht die Eigenschaft
     `nary' hat.

          (%i1) G ([L]) := L;
          (%o1)                      G([L]) := L
          (%i2) xreduce (G, [a, b, c, d, e]);
          (%o2)         [[[[[("[", simp), a], b], c], d], e]
          (%i3) lreduce (G, [a, b, c, d, e]);
          (%o3)                 [[[[a, b], c], d], e]


File: maxima.info,  Node: Summen Produkte und Reihen,  Next: Analysis,  Prev: Mengen,  Up: Top

15 Summen, Produkte und Reihen
******************************

* Menu:

* Summen und Produkte::
* Einführung in Reihen::
* Funktionen und Variablen für Reihen::
* Poisson Reihen::
* Kettenbrüche::


File: maxima.info,  Node: Summen und Produkte,  Next: Einführung in Reihen,  Prev: Summen Produkte und Reihen,  Up: Summen Produkte und Reihen

15.1 Summen und Produkte
========================

 -- Funktion: bashindices (<expr>)
     Transformiert einen Ausdruck <expr>, der mehrere Summen oder
     Produkte enthält so, dass alle Summen und Produkte einen
     unterschiedlichen Index haben.  Dies erleichtert zum Beispiel
     Substitutionen mit der Funktion `changevar'.    Die neuen Indizes
     werden mit `j<nummer>' bezeichnet, wobei die Zahl <nummer> der
     Wert der Optionsvariablen `gensumnum'  ist.

     Beispiel:

          (%i1) sum(1/k^2,k,0,inf)+sum(1/k,k,0,inf);
                                 inf       inf
                                 ====      ====
                                 \     1   \     1
          (%o1)                   >    - +  >    --
                                 /     k   /      2
                                 ====      ====  k
                                 k = 0     k = 0
          (%i2) bashindices(%);
                               inf         inf
                               ====        ====
                               \      1    \       1
          (%o2)                 >     -- +  >     ---
                               /      j2   /        2
                               ====        ====   j1
                               j2 = 0      j1 = 0

 -- Optionsvariable: cauchysum
     Standardwert: `false'

     Werden zwei Reihen miteinander multipliziert und die
     Optionsvariablen `sumexpand'  sowie `cauchysum' haben beide den
     Wert `true', dann wird die Cauchy-Produktformel angewendet.

     Beispiele:

          (%i1) sumexpand: false$
          (%i2) cauchysum: false$
          (%i3) s: sum (f(i), i, 0, inf) * sum (g(j), j, 0, inf);
                                inf         inf
                                ====        ====
                                \           \
          (%o3)                ( >    f(i))  >    g(j)
                                /           /
                                ====        ====
                                i = 0       j = 0
          (%i4) sumexpand: true$
          (%i5) cauchysum: true$
          (%i6) ''s;
                           inf     i1
                           ====   ====
                           \      \
          (%o6)             >      >     g(i1 - i2) f(i2)
                           /      /
                           ====   ====
                           i1 = 0 i2 = 0

 -- Optionsvariable: genindex
     Standardwert: `i'

     `genindex' enthält das Zeichen für den Präfix, der verwendet wird,
     um einen neuen Index für eine Summe oder ein Produkt zu
     generieren.  Siehe auch `gensumnum'.


 -- Optionsvariable: gensumnum
     Standardwert: 0

     `gensumnum' enthält die Nummer, die an den Präfix `genindex'
     angehängt wird, um den nächsten Index für eine Summe oder ein
     Produkt zu generieren.  Hat `gensumnum' den Wert `false', wird der
     Index nur aus dem Zeichen `genindex' gebildet.  Siehe auch
     `genindex'.


 -- Funktion: intosum (<expr>)
     Multipliziert Faktoren in eine Summe herein.  Tritt der Index der
     Summe als ein Faktor außerhalb der Summe auf, wird von der
     Funktion `intosum' ein neuer Index gebildet.  Summen haben die
     Eigenschaft `outative',  so dass Faktoren bei der Vereinfachung
     aus der Summe herausgezogen werden.  Mit der Funktion `intosum'
     wird diese Vereinfachung rückgängig gemacht.

     Beispiel:

          (%i1) sum(2*x^2*n^k, k , 0, inf);
                                         inf
                                         ====
                                       2 \      k
          (%o1)                     2 x   >    n
                                         /
                                         ====
                                         k = 0
          (%i2) intosum(%);
                                    inf
                                    ====
                                    \        k  2
          (%o2)                      >    2 n  x
                                    /
                                    ====
                                    k = 0

 -- Funktion: lsum (<expr>, <i>, <L>)
     Bildet die Summe für den Ausdruck <expr> zum Index <i> für alle
     Elemente der Liste <L>.  Kann das Argument <L> nicht zu einer Liste
     ausgewertet werden, wird eine Substantivform zurückgegeben.  Siehe
     auch `sum'.

     Beispiele:

          (%i1) lsum (x^i, i, [1, 2, 7]);
                                      7    2
          (%o1)                      x  + x  + x
          (%i2) lsum (i^2, i, rootsof (x^3 - 1));
                               ====
                               \      2
          (%o2)                 >    i
                               /
                               ====
                                             3
                               i in rootsof(x  - 1)

 -- Funktion: niceindices (<expr>)
     Gibt den Indizes von Summen und Produkten im Ausdruck <expr> einen
     neuen Namen.  `niceindices' benennt die Indizes nacheinander mit
     den Namen, die in der Liste der Optionsvariablen `niceindicespref'
     enthalten sind.  Die Standardnamen sind `[i, j, k, l, m, n]'.
     Sind nicht genügend Namen in der Liste vorhanden, werden weitere
     Indizes durch das Anhängen einer Nummer gebildet.

     `niceindices' wertet das Argument aus.

     Beispiele:

          (%i1) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                           inf    inf
                          /===\   ====
                           ! !    \
          (%o1)            ! !     >      f(bar i j + foo)
                           ! !    /
                          bar = 1 ====
                                  foo = 1
          (%i2) niceindices (%);
                               inf  inf
                              /===\ ====
                               ! !  \
          (%o2)                ! !   >    f(i j l + k)
                               ! !  /
                              l = 1 ====
                                    k = 1

 -- Optionsvariable: niceindicespref
     Standardwert: `[i, j, k, l, m, n]'

     `niceindicespref' ist die Liste mit den Namen, die die Funktion
     `niceindices'  nutzt, um die Indizes von Summen und Produkte
     umzubenennen.

     Beispiele:

          (%i1) niceindicespref: [p, q, r, s, t, u]$
          (%i2) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                           inf    inf
                          /===\   ====
                           ! !    \
          (%o2)            ! !     >      f(bar i j + foo)
                           ! !    /
                          bar = 1 ====
                                  foo = 1
          (%i3) niceindices (%);
                               inf  inf
                              /===\ ====
                               ! !  \
          (%o3)                ! !   >    f(i j q + p)
                               ! !  /
                              q = 1 ====
                                    p = 1

 -- Funktion: nusum (<expr>, <i>, <i_0>, <i_1>)
     Wendet den Gosper-Algorithmus der unbestimmten Summation für den
     Ausdruck <expr> und dem Index <i> an.  Der Index <i> läuft von
     <i_0> bis <i_1>.  Der Ausdruck <expr> und das Ergebnis der
     Summation müssen als Produkte von ganzzahligen Exponentiationen,
     Fakultäten, Binomialen und rationalen Funktionen darstellbar sein.

     Die Funktionen `nusum' und `unsum' wenden einige Regeln für die
     Vereinfachung von Summen und Differenzen von endlichen Produkten
     an.  Siehe auch `unsum'.

     Beispiele:

          (%i1) nusum (n*n!, n, 0, n);

          Dependent equations eliminated:  (1)
          (%o1)                     (n + 1)! - 1
          (%i2) nusum (n^4*4^n/binomial(2*n,n), n, 0, n);
                               4        3       2              n
                2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
          (%o2) ------------------------------------------------ - ------
                              693 binomial(2 n, n)                 3 11 7
          (%i3) unsum (%, n);
                                        4  n
                                       n  4
          (%o3)                   ----------------
                                  binomial(2 n, n)
          (%i4) unsum (prod (i^2, i, 1, n), n);
                              n - 1
                              /===\
                               ! !   2
          (%o4)              ( ! !  i ) (n - 1) (n + 1)
                               ! !
                              i = 1
          (%i5) nusum (%, n, 1, n);

          Dependent equations eliminated:  (2 3)
                                      n
                                    /===\
                                     ! !   2
          (%o5)                      ! !  i  - 1
                                     ! !
                                    i = 1

 -- Funktion: product (<expr>, <i>, <i_0>, <i_1>)
     Bildet das Produkt des Ausdrucks <expr> zum Index <i> in den
     Grenzen <i_0> bis <i_1>.  `product' wertet <expr> sowie die untere
     Grenze <i_0> und obere Grenze <i_1> aus.  Der Index <i> wird nicht
     ausgewertet.

     Ist die Differenz der oberen und unteren Grenze eine ganze Zahl,
     wird <expr> für jeden Wert des Index <i> ausgewertet.  Das
     Ergebnis ist ein explizites Produkt.  Andernfalls ist der Bereich
     des Index unbestimmt.  Maxima wendet einige einfache Regeln an, um
     das Produkt zu vereinfachen.  Hat die Optionsvariable `simpproduct'
     den Wert `true', wendet Maxima weitere Regeln an, um Produkte zu
     vereinfachen.

     Siehe auch `nouns'  und `evflag'  für die Auswertung von
     Ausdrücken, die die Substantivform eines Produktes enthalten.

     Beispiele:

          (%i1) product (x + i*(i+1)/2, i, 1, 4);
          (%o1)           (x + 1) (x + 3) (x + 6) (x + 10)
          (%i2) product (i^2, i, 1, 7);
          (%o2)                       25401600
          (%i3) product (a[i], i, 1, 7);
          (%o3)                 a  a  a  a  a  a  a
                                 1  2  3  4  5  6  7
          (%i4) product (a(i), i, 1, 7);
          (%o4)          a(1) a(2) a(3) a(4) a(5) a(6) a(7)
          (%i5) product (a(i), i, 1, n);
                                       n
                                     /===\
                                      ! !
          (%o5)                       ! !  a(i)
                                      ! !
                                     i = 1
          (%i6) product (k, k, 1, n);
                                         n
                                       /===\
                                        ! !
          (%o6)                         ! !  k
                                        ! !
                                       k = 1
          (%i7) product (k, k, 1, n), simpproduct;
          (%o7)                          n!
          (%i8) product (integrate (x^k, x, 0, 1), k, 1, n);
                                       n
                                     /===\
                                      ! !    1
          (%o8)                       ! !  -----
                                      ! !  k + 1
                                     k = 1
          (%i9) product (if k <= 5 then a^k else b^k, k, 1, 10);
                                        15  40
          (%o9)                        a   b

 -- Optionsvariable: simpproduct
     Standardwert: `false'

     Hat `simpproduct' den Wert `true', versucht Maxima ein Produkt
     weiter zu vereinfachen.  Die Vereinfachung kann eine geschlossene
     Form liefern.  Hat `simpproduct' den Wert `false' oder wird das
     Produkt als Substantivform `'product' definiert, werden nur einige
     einfache Regeln von Maxima für die Vereinfachung angewendet.
     `simpproduct' ist auch ein Auswertungsschalter.  Siehe `evflag'.

     Siehe auch `product'  für ein Beispiel.


 -- Optionsvariable: simpsum
     Standardwert: `false'

     Hat `simpsum' den Wert `true', versucht Maxima eine Summe oder
     Reihe weiter zu vereinfachen.  Die Vereinfachung kann eine
     geschlossene Form liefern.  Hat `simpsum' den Wert `false' oder
     die Summe oder Reihe liegt als Substantivform `'sum' vor, werden
     nur einige einfache Regeln von Maxima für die Vereinfachung
     angewendet.  `simpsum' ist auch ein Auswertungsschalter.  Siehe
     `evflag'.

     Siehe auch `sum'  für ein Beispiel.


 -- Funktion: sum (<expr>, <i>, <i_0>, <i_1>)
     Bildet die Summe des Ausdrucks <expr> zum Index <i> in den Grenzen
     <i_0> bis <i_1>.  Die Funktion `sum' wertet <expr> sowie die
     untere Grenze <i_0> und obere Grenze <i_1> aus.  Der Index <i> wird
     nicht ausgewertet.

     Ist die Differenz der oberen und unteren Grenze eine ganze Zahl,
     wird <expr> für jeden Wert des Index <i> ausgewertet.  Das
     Ergebnis ist eine explizite Summe.  Andernfalls ist der Bereich
     des Index unbestimmt.  Maxima wendet einige einfache Regeln an, um
     die Summe zu vereinfachen.  Hat die Optionsvariable `simpsum'  den
     Wert `true', wendet Maxima weitere Regeln an, um Summen zu
     vereinfachen.

     Werden zwei unendliche Reihen miteinander multipliziert und die
     Optionsvariablen `sumexpand'  sowie `cauchysum'  haben beide den
     Wert `true', dann wird die Cauchy-Produktformel angewendet.

     Die Optionsvariable `genindex'  enthält das Zeichen, das der Präfix
     eines automatisch generierten Index ist.  `gensumnum'  enthält
     eine ganze Zahl, die an den Präfix `genindex' angehängt wird, um
     einen automatischen Index zu generieren.  `gensumnum' wird von
     Maxima automatisch erhöht.  Hat `gensumnum' den Wert `false', wird
     keine Zahl an den Präfix angehängt.

     Das Paket `simplify_sum' enthält die Funktion `simplify_sum',  mit
     der Summen zu einer geschlossenen Form vereinfacht werden können.

     Siehe auch `sumcontract',   `sumexpand',

     `intosum',  `bashindices',  `niceindices',

     `cauchysum'  und `zeilberger'.

     Beispiele:

          (%i1) sum (i^2, i, 1, 7);
          (%o1)                          140
          (%i2) sum (a[i], i, 1, 7);
          (%o2)           a  + a  + a  + a  + a  + a  + a
                           7    6    5    4    3    2    1
          (%i3) sum (a(i), i, 1, 7);
          (%o3)    a(7) + a(6) + a(5) + a(4) + a(3) + a(2) + a(1)
          (%i4) sum (a(i), i, 1, n);
                                      n
                                     ====
                                     \
          (%o4)                       >    a(i)
                                     /
                                     ====
                                     i = 1
          (%i5) sum (2^i + i^2, i, 0, n);
                                    n
                                   ====
                                   \       i    2
          (%o5)                     >    (2  + i )
                                   /
                                   ====
                                   i = 0
          (%i6) sum (2^i + i^2, i, 0, n), simpsum;
                                        3      2
                             n + 1   2 n  + 3 n  + n
          (%o6)             2      + --------------- - 1
                                            6
          (%i7) sum (1/3^i, i, 1, inf);
                                      inf
                                      ====
                                      \     1
          (%o7)                        >    --
                                      /      i
                                      ====  3
                                      i = 1
          (%i8) sum (1/3^i, i, 1, inf), simpsum;
                                          1
          (%o8)                           -
                                          2
          (%i9) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf);
                                        inf
                                        ====
                                        \     1
          (%o9)                      30  >    --
                                        /      2
                                        ====  i
                                        i = 1
          (%i10) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum;
                                            2
          (%o10)                       5 %pi
          (%i11) sum (integrate (x^k, x, 0, 1), k, 1, n);
                                      n
                                     ====
                                     \       1
          (%o11)                      >    -----
                                     /     k + 1
                                     ====
                                     k = 1
          (%i12) sum (if k <= 5 then a^k else b^k, k, 1, 10);
                    10    9    8    7    6    5    4    3    2
          (%o12)   b   + b  + b  + b  + b  + a  + a  + a  + a  + a

 -- Funktion: sumcontract (<expr>)
     Fasst alle Summen in dem Ausdruck <expr> zusammen, die sich in
     ihrem oberen und unterem Index nur um eine Konstante voneinander
     unterscheiden.  Das Ergebnis ist eine Ausdruck mit einer Summe,
     für die Summen, die zusammengefasst werden können und weiteren
     Termen, die hinzu addiert werden müssen, um einen äquivalenten
     Ausdruck zu erhalten.

     Es kann notwendig sein zunächst das Kommando `intosum(<expr>)'
     auszuführen.  Siehe `intosum'.

     Beispiel:

          (%i1) 'sum(1/l,l,1,n)+'sum(k,k,1,n+2);
                                   n        n + 2
                                  ====      ====
                                  \     1   \
          (%o1)                    >    - +  >    k
                                  /     l   /
                                  ====      ====
                                  l = 1     k = 1
          (%i2) sumcontract(%);
                                      n
                                     ====
                                     \          1
          (%o2)                2 n +  >    (l + -) + 3
                                     /          l
                                     ====
                                     l = 1

 -- Optionsvariable: sumexpand
     Standardwert: `false'

     Hat die Optionsvariable `sumexpand' den Wert `true', werden
     Produkte von Summen und Potenzen von Summen zu verschachtelten
     Summen vereinfacht.  Siehe auch `cauchysum'.

     Beispiele:

          (%i1) sumexpand: true$
          (%i2) sum (f (i), i, 0, m) * sum (g (j), j, 0, n);
                               m      n
                              ====   ====
                              \      \
          (%o2)                >      >     f(i1) g(i2)
                              /      /
                              ====   ====
                              i1 = 0 i2 = 0
          (%i3) sum (f (i), i, 0, m)^2;
                               m      m
                              ====   ====
                              \      \
          (%o3)                >      >     f(i3) f(i4)
                              /      /
                              ====   ====
                              i3 = 0 i4 = 0

 -- Funktion: unsum (<f>, <n>)
     Gibt die erste Rückwärtsdifferenz `<f>(<n>) - <f>(<n>-1)' zurück.
     Siehe auch `nusum'.

     Beispiele:

          (%i1) g(p) := p*4^n/binomial(2*n,n);
                                               n
                                            p 4
          (%o1)               g(p) := ----------------
                                      binomial(2 n, n)
          (%i2) g(n^4);
                                        4  n
                                       n  4
          (%o2)                   ----------------
                                  binomial(2 n, n)
          (%i3) nusum (%, n, 0, n);
                               4        3       2              n
                2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
          (%o3) ------------------------------------------------ - ------
                              693 binomial(2 n, n)                 3 11 7
          (%i4) unsum (%, n);
                                        4  n
                                       n  4
          (%o4)                   ----------------
                                  binomial(2 n, n)


File: maxima.info,  Node: Einführung in Reihen,  Next: Funktionen und Variablen für Reihen,  Prev: Summen und Produkte,  Up: Summen Produkte und Reihen

15.2 Einführung in Reihen
=========================

Maxima kennt die Funktionen `taylor'  und `powerseries',  um die
Reihenentwicklung von differenzierbaren Funktionen zu finden.  Maxima
hat weiterhin Funktionen wie `nusum',  um geschlossene Formen von
Reihen zu finden.  Operationen wie die Addition und Multiplikation
arbeiten wie gewohnt für Reihen.  Das folgende Kapitel beschreibt die
Variablen und Funktionen für eine Reihenentwicklung.


File: maxima.info,  Node: Funktionen und Variablen für Reihen,  Next: Poisson Reihen,  Prev: Einführung in Reihen,  Up: Summen Produkte und Reihen

15.3 Funktionen und Variablen für Reihen
========================================

 -- Funktion: deftaylor (<f_1>(<x_1>), <expr_1>, ..., <f_n>(<x_n>),
          <expr_n>)
     Für eine Funktion <f_i> einer Variablen <x_i> definiert
     `deftaylor' den Ausdruck <expr_i> als die Taylorreihe um den
     Nullpunkt.  <expr_i> ist typischerweise ein Polynom in der
     Variablen <x_i> oder eine Summe.  `deftaylor' akzeptiert aber auch
     allgemeinere Ausdrücke.

     `powerseries(<f_i>(<x_i>), <x_i>, 0)' gibt die Reihe zurück, die
     mit `deftaylor' definiert wurde.

     `deftaylor' gibt eine Liste der Funktionen <f_1>, ..., <f_n>
     zurück.  `deftaylor' wertet die Argumente aus.

     Siehe auch `taylor'  und `powerseries'.

     Beispiele:

          (%i1) deftaylor (f(x), x^2 + sum(x^i/(2^i*i!^2), i, 4, inf));
          (%o1)                          [f]
          (%i2) powerseries (f(x), x, 0);
                                inf
                                ====      i1
                                \        x         2
          (%o2)                  >     -------- + x
                                /       i1    2
                                ====   2   i1!
                                i1 = 4
          (%i3) taylor (exp (sqrt (f(x))), x, 0, 4);
                                2         3          4
                               x    3073 x    12817 x
          (%o3)/T/     1 + x + -- + ------- + -------- + . . .
                               2     18432     307200

 -- Optionsvariable: maxtayorder
     Standardwert: `true'

     Hat `maxtayorder' den Wert `true', werden bei der algebraischen
     Manipulation von Taylor-Reihen, von der Funktion `taylor'  so viele
     Terme wie möglich mitgeführt.

 -- Funktion: pade (<taylor_series>, <numer_deg_bound>,
          <denom_deg_bound>)
     Gibt eine Liste aller rationalen Funktionen zurück, die die
     angegebene Taylor-Reihenentwicklung haben und deren Summe des
     Nennergrads und des Zählergrads kleiner oder gleich des Grads der
     Reihenentwicklung ist.

     Das Argument <taylor_series> ist eine Taylor-Reihe in einer
     Variablen.  Die Argumente <numer_deg_bound> und <denom_deg_bound>
     sind positive ganze Zahlen, die eine Grenze für den Nennergrad und
     den Zählergrad der rationalen Funktion angeben.

     Die Taylor-Reihe kann auch eine Laurent-Reihe sein und die Grenzen
     für den Grad können `inf' sein.

     Siehe auch `taylor'.

     Beispiele:

          (%i1) taylor (1 + x + x^2 + x^3, x, 0, 3);
                                        2    3
          (%o1)/T/             1 + x + x  + x  + . . .
          (%i2) pade (%, 1, 1);
                                           1
          (%o2)                       [- -----]
                                         x - 1
          (%i3) t: taylor(-(83787*x^10 - 45552*x^9 - 187296*x^8
                             + 387072*x^7 + 86016*x^6 - 1507328*x^5
                             + 1966080*x^4 + 4194304*x^3 - 25165824*x^2
                             + 67108864*x - 134217728)
                   /134217728, x, 0, 10);
                              2    3       4       5       6        7
                       x   3 x    x    15 x    23 x    21 x    189 x
          (%o3)/T/ 1 - - + ---- - -- - ----- + ----- - ----- - ------
                       2    16    32   1024    2048    32768   65536

                                            8         9          10
                                      5853 x    2847 x    83787 x
                                    + ------- + ------- - --------- + . . .
                                      4194304   8388608   134217728
          (%i4) pade (t, 4, 4);
          (%o4)                          []

     Es gibt keine rationale Funktion des Grads 4 im Zähler und Nenner
     für die oben angegebene Taylor-Reihenentwicklung.  Die Summe des
     Zählergrads und des Nennergrads müssen mindestens gleich dem Grad
     der Reihenentwicklung sein.  In diesem Fall ist der Grad der
     Taylor-Reihenentwicklung `10'.

          (%i5) pade (t, 5, 5);
                               5                4                 3
          (%o5) [- (520256329 x  - 96719020632 x  - 489651410240 x

                            2
           - 1619100813312 x  - 2176885157888 x - 2386516803584)

                         5                 4                  3
          /(47041365435 x  + 381702613848 x  + 1360678489152 x

                            2
           + 2856700692480 x  + 3370143559680 x + 2386516803584)]

 -- Funktion: powerseries (<expr>, <x>, <a>)
     Gibt eine geschlossene Form für die Reihenentwicklung des
     Ausdrucks <expr> in der Variablen <x> um den Punkt <a> zurück.
     Das Argument <a> kann die Werte `inf' oder `infinity' haben.  Die
     Reihenentwicklung für eine Funktion `f(x)' hat die allgemeine Form:
                            inf
                            ====
                            \               n
                 f(x) =      >    b  (x - a)
                            /      n
                            ====
                            n = 0

     Mit den Koeffzienten:
                               !
                      d        !
                      -- (f(x))!
                      dn       !
                               !x = a
                 b  = ---------------
                  n         n!

     Kann die Funktion `powerseries' keine Reihenentwicklung für den
     Ausdruck <expr> finden, können möglicherweise mit der Funktion
     `taylor'  die ersten Terme der Reihenentwicklung berechnet werden.

     Hat die Optionsvariable `verbose'  den Wert `true', werden
     Meldungen zu den verwendeten Algorithmen von der Funktion
     `powerseries' angezeigt.

     Beispiel:

          (%i1) verbose: true$

          (%i2) powerseries (log(sin(x)/x), x, 0);
          trigreduce: can't expand
                           log(sin(x))

          trigreduce: try again after applying the rule:
                                           d
                                         / -- (sin(x))
                                         [ dx
                           log(sin(x)) = I ----------- dx
                                         ]   sin(x)
                                         /


          powerseries: first simplification returned
                                          /
                                          [
                               - log(x) + I cot(x) dx
                                          ]
                                          /

                     inf
                     ====        i1  - 1 + 2 i1             2 i1
                     \      (- 1)   2           bern(2 i1) x
          (%o2)       >     ------------------------------------
                     /                   i1 (2 i1)!
                     ====
                     i1 = 1

 -- Option variable: psexpand
     Default value: `false'

     When `psexpand' is `true', an extended rational function
     expression is displayed fully expanded.  The switch `ratexpand'
     has the same effect.

     When `psexpand' is `false', a multivariate expression is displayed
     just as in the rational function package.

     When `psexpand' is  `multi', then terms with the same total degree
     in the variables are grouped together.

 -- Funktion: revert (<expr>, <x>)
 -- Funktion: revert2 (<expr>, <x>, <n>)
     Die Funktion `revert' berechnet eine Taylorreihe in der Variablen
     <x> um den Entwicklungspunkt Null, die der Taylorreihe der
     inversen Funktion entspricht, die von der Taylorreihe <expr>
     repräsentiert wird.  Das Ergebnis ist ein Polynom in einer
     CRE-Darstellung mit dem Grad der höchsten Potenz im Ausdruck
     <expr>.

     Die Funktion `revert2' entspricht der Funktion `revert' mit dem
     Unterschied, dass mit dem dritten Argument <n> der Grad der neuen
     Taylorreihe explizit angegeben werden kann.  Dieser kann kleiner
     oder größer als der Grad der Taylorreihe <expr> sein.

     Mit dem Kommando `load(revert)' werden die Funktionen geladen.

     Siehe auch die Funktion `taylor'.

     Beispiel:

     Die Inverse der Funktion `exp(x) - 1' ist die Funktion `log(x+1)'.
     Mit dem Kommando `revert(taylor(exp(x) - 1, x, 0, 6), x)' wird die
     Taylorreihe der Inversen `log(x+1)' berechnet.

          (%i1) load (revert)$
          (%i2) t: taylor (exp(x) - 1, x, 0, 6);
                             2    3    4    5     6
                            x    x    x    x     x
          (%o2)/T/      x + -- + -- + -- + --- + --- + . . .
                            2    6    24   120   720
          (%i3) revert (t, x);
                         6       5       4       3       2
                     10 x  - 12 x  + 15 x  - 20 x  + 30 x  - 60 x
          (%o3)/R/ - --------------------------------------------
                                          60
          (%i4) ratexpand (%);
                               6    5    4    3    2
                              x    x    x    x    x
          (%o4)             - -- + -- - -- + -- - -- + x
                              6    5    4    3    2
          (%i5) taylor (log(x+1), x, 0, 6);
                              2    3    4    5    6
                             x    x    x    x    x
          (%o5)/T/       x - -- + -- - -- + -- - -- + . . .
                             2    3    4    5    6
          (%i6) ratsimp (revert (t, x) - taylor (log(x+1), x, 0, 6));
          (%o6)                           0
          (%i7) revert2 (t, x, 4);
                                    4    3    2
                                   x    x    x
          (%o7)                  - -- + -- - -- + x
                                   4    3    2

 -- Funktion: taylor (<expr>, <x>, <a>, <n>)
 -- Funktion: taylor (<expr>, [<x_1>, <x_2>, ...], <a>, <n>)
 -- Funktion: taylor (<expr>, [<x>, <a>, <n>, 'asymp])
 -- Funktion: taylor (<expr>, [<x_1>, <x_2>, ...], [<a_1>, <a_2>, ...],
          [<n_1>, <n_2>, ...])
 -- Funktion: taylor (<expr>, [<x_1>, <a_1>, <n_1>], [<x_2>, <a_2>,
          <n_2>], ...)
     `taylor(<expr>, <x>, <a>, <n>)' entwickelt den Ausdruck <expr> in
     eine Taylor- oder Laurent-Reihenwicklung in der Variablen <x> um
     den Punkt <a>, die die Terme bis zur Ordnung `(<x> - <a>)^<n>'
     enthält.

     Hat der Ausdruck <expr> die Form `<f>(<x>)/<g>(<x>)' und hat
     `<g>(<x>)' keine Terme bis zur Ordnung <n>, dann versucht `taylor'
     den Ausdruck `<g>(<x>)' bis zur Ordnung `2 <n>' zu entwickeln.
     Treten in der Entwicklung weiterhin keine von Null verschiedenen
     Terme auf, verdoppelt `taylor' die Ordnung der Entwicklung für
     `<g>(<x>)' so lange, wie die Ordnung kleiner oder gleich `<n>
     2^taylordepth' ist.  Siehe auch `taylordepth'.

     `taylor(<expr>, [<x_1>, <x_2>, ...], <a>, <n>)' gibt die
     Reihenentwicklung der Ordnung <n> in allen Variablen <x_1>, <x_2>,
     ... um den Punkt <a> zurück.

     Die beiden folgenden äquivalenten Kommandos `taylor(<expr>,
     [<x_1>, <a_1>, <n_1>], [<x_2>, <a_2>, <n_2>], ...)' und
     `taylor(<expr>, [<x_1>, <x_2>, ...], [<a_1>, <a_2>, ...], [<n_1>,
     <n_2>, ...])' geben eine Reihenentwicklung für die Variablen
     <x_1>, <x_2>, ... um den Punkt `(<a_1>, <a_2>, ...)' mit den
     Ordnungen <n_1>, <n_2>, ... zurück.

     `taylor(<expr>, [<x>, <a>, <n>, 'asymp])' entwickelt den Ausdruck
     <expr> in negativen Potenzen von `<x> - <a>'.  Der Term mit der
     größten Ordnung ist `(<x> - <a>)^<-n>'.

     Folgende Optionsvariablen kontrollieren die Berechnung einer
     Taylorreihe:

    `maxtayorder'
          Hat `maxtayorder'  den Wert `true', werden bei der
          algebraischen Manipulation von Taylor-Reihen, von der
          Funktion `taylor' so viele Terme wie möglich mitgeführt.

    `taylordepth'
          Findet `taylor' keine von Null verschiedenen Terme in der
          Reihenentwicklung, wird die Ordnung der Entwicklung solange
          erhöht wie sie kleiner oder gleich `2^taylordepth' ist.

    `taylor_logexpand'
          Die Optionsvariable `taylor_logexpand'  kontrolliert die
          Entwicklung von Logarithmusfunktionen, die bei der
          Reihenentwicklung auftreten.  Der Standardwert ist `true' und
          die Logarithmusfunktionen in einer Reihenentwicklung werden
          vollständig entwickelt.

    `taylor_order_coefficients'
          Die Optionsvariable `taylor_order_coefficients'  kontrolliert
          die Anordung von Termen in einer Reihenentwicklung.  Der
          Standardwert ist `true' und die Anordung entspricht der
          kanonischen Darstellung eines Ausdrucks.

    `taylor_truncate_polynomials'
          Hat die Optionsvariable `taylor_truncate_polynomials'  den
          Wert `false', wird das Ergebnis der Reihenentwicklung eines
          Polynoms als exakt angenommen.

    `taylor_simplifier'
          Die Funktion zur Vereinfachung der Koeffizienten einer
          Entwicklung ist in der Optionsvariablen `taylor_simplifier'
          enthalten.  Der Standardwert ist `simplify'.  Der Variablen
          kann eine nutzerdefinierte Funktion zugewiesen werden.

     Mit der Funktion `taylorp'  kann getestet werden, ob ein Ausdruck
     eine Taylorreihe repräsentiert.  Die Funktion `taylorinfo'  gibt
     Informationen zu einer Taylorreihe aus.  Die spezielle CRE-Form
     einer Taylorreihe wird mit der Funktion `taytorat'  in eine
     Standardform gebracht.  Mit den Funktionen `revert'  und `revert2'
     kann die Taylorreihe einer inversen Funktion berechnet werden.

     Beispiele:

          (%i1) taylor (sqrt (sin(x) + a*x + 1), x, 0, 3);
                                     2             2
                       (a + 1) x   (a  + 2 a + 1) x
          (%o1)/T/ 1 + --------- - -----------------
                           2               8

                                             3      2             3
                                         (3 a  + 9 a  + 9 a - 1) x
                                       + -------------------------- + . . .
                                                     48
          (%i2) %^2;
                                              3
                                             x
          (%o2)/T/           1 + (a + 1) x - -- + . . .
                                             6
          (%i3) taylor (sqrt (x + 1), x, 0, 5);
                                 2    3      4      5
                            x   x    x    5 x    7 x
          (%o3)/T/      1 + - - -- + -- - ---- + ---- + . . .
                            2   8    16   128    256
          (%i4) %^2;
          (%o4)/T/                  1 + x + . . .
          (%i5) product ((1 + x^i)^2.5, i, 1, inf)/(1 + x^2);
                                   inf
                                  /===\
                                   ! !    i     2.5
                                   ! !  (x  + 1)
                                   ! !
                                  i = 1
          (%o5)                   -----------------
                                        2
                                       x  + 1
          (%i6) ev (taylor(%, x,  0, 3), keepfloat);
                                         2           3
          (%o6)/T/    1 + 2.5 x + 3.375 x  + 6.5625 x  + . . .
          (%i7) taylor (1/log (x + 1), x, 0, 3);
                                         2       3
                           1   1   x    x    19 x
          (%o7)/T/         - + - - -- + -- - ----- + . . .
                           x   2   12   24    720
          (%i8) taylor (cos(x) - sec(x), x, 0, 5);
                                          4
                                     2   x
          (%o8)/T/                - x  - -- + . . .
                                         6
          (%i9) taylor ((cos(x) - sec(x))^3, x, 0, 5);
          (%o9)/T/                    0 + . . .
          (%i10) taylor (1/(cos(x) - sec(x))^3, x, 0, 5);
                                                         2          4
                      1     1       11      347    6767 x    15377 x
          (%o10)/T/ - -- + ---- + ------ - ----- - ------- - --------
                       6      4        2   15120   604800    7983360
                      x    2 x    120 x

                                                                    + . . .
          (%i11) taylor (sqrt (1 - k^2*sin(x)^2), x, 0, 6);
                         2  2       4      2   4
                        k  x    (3 k  - 4 k ) x
          (%o11)/T/ 1 - ----- - ----------------
                          2            24

                                              6       4       2   6
                                         (45 k  - 60 k  + 16 k ) x
                                       - -------------------------- + . . .
                                                    720
          (%i12) taylor ((x + 1)^n, x, 0, 4);
                                2       2     3      2         3
                              (n  - n) x    (n  - 3 n  + 2 n) x
          (%o12)/T/ 1 + n x + ----------- + --------------------
                                   2                 6

                                         4      3       2         4
                                       (n  - 6 n  + 11 n  - 6 n) x
                                     + ---------------------------- + . . .
                                                    24
          (%i13) taylor (sin (y + x), x, 0, 3, y, 0, 3);
                         3                 2
                        y                 y
          (%o13)/T/ y - -- + . . . + (1 - -- + . . .) x
                        6                 2

                              3                       2
                         y   y            2      1   y            3
                    + (- - + -- + . . .) x  + (- - + -- + . . .) x  + . . .
                         2   12                  6   12
          (%i14) taylor (sin (y + x), [x, y], 0, 3);
                               3        2      2      3
                              x  + 3 y x  + 3 y  x + y
          (%o14)/T/   y + x - ------------------------- + . . .
                                          6
          (%i15) taylor (1/sin (y + x), x, 0, 3, y, 0, 3);
                    1   y              1    1               1            2
          (%o15)/T/ - + - + . . . + (- -- + - + . . .) x + (-- + . . .) x
                    y   6               2   6                3
                                       y                    y

                                                     1            3
                                                + (- -- + . . .) x  + . . .
                                                      4
                                                     y
          (%i16) taylor (1/sin (y + x), [x, y], 0, 3);
                                       3         2       2        3
                      1     x + y   7 x  + 21 y x  + 21 y  x + 7 y
          (%o16)/T/ ----- + ----- + ------------------------------- + . . .
                    x + y     6                   360

 -- Optionsvariable: taylordepth
     Standardwert: 3

     Findet die Funktion `taylor' keine von Null verschiedenen Terme in
     der Reihenentwicklung, wird die Ordnung der Entwicklung solange
     erhöht wie sie kleiner oder gleich `2^taylordepth' ist.

     Siehe auch `taylor'.


 -- Funktion: taylorinfo (<expr>)
     Gibt Informationen über die Taylorreihe <expr> zurück.  Die
     Rückgabe ist eine Liste, die Listen mit den Namen der Variablen,
     den Entwicklungspunkten und den Ordnungen der Entwicklung
     enthalten.

     Ist <expr> keine Taylorreihe, ist die Rückgabe `false'.

     Beispiele:

          (%i1) taylor ((1 - y^2)/(1 - x), x, 0, 3, [y, a, inf]);
                            2                       2
          (%o1)/T/ - (y - a)  - 2 a (y - a) + (1 - a )

                   2                        2
           + (1 - a  - 2 a (y - a) - (y - a) ) x

                   2                        2   2
           + (1 - a  - 2 a (y - a) - (y - a) ) x

                   2                        2   3
           + (1 - a  - 2 a (y - a) - (y - a) ) x  + . . .
          (%i2) taylorinfo(%);
          (%o2)               [[y, a, inf], [x, 0, 3]]

 -- Funktion: taylorp (<expr>)
     Hat den Rückgabewert `true', wenn das Argument <expr> eine
     Taylorreihe ist.  Ansonsten ist der Rückgabewert `false'.

 -- Optionsvariable: taylor_logexpand
     Standardwert: `true'

     `taylor_logexpand' kontrolliert die Entwicklung von Logarithmen in
     einer Taylorreihe.  Der Standardwert ist `true' und die
     Logarithmusfunktionen in einer Reihenentwicklung werden
     vollständig entwickelt.  Ansonsten werden Logarithmusfunktionen so
     weit entwickelt, wie es notwendig ist, um eine formale
     Reihenentwicklung zu erhalten.

 -- Optionsvariable: taylor_order_coefficients
     Standardwert: `true'

     Die Optionsvariable `taylor_order_coefficients' kontrolliert die
     Ordnung der Koeffizienten einer Taylorreihenentwicklung.  Hat
     `taylor_order_coefficients' den Wert `true', werden die
     Koeffizienten kanonisch angeordnet.

 -- Optionsvariable: taylor_simplifier
     Standardwert: `SIMPLIFY'

     Die Optionsvariable `taylor_simplifier' enthält den Namen der
     Funktion, die für die Vereinfachung der Koeffizienten einer
     Taylorreihenentwicklung von `taylor'  aufgerufen wird.  Der
     Standardwert ist die Lisp-Funktion `SIMPLIFY'.

 -- Optionsvariable: taylor_truncate_polynomials
     Standardwert: `true'

     Hat die Optionsvariable `taylor_truncate_polynomials' den Wert
     `false', wird das Ergebnis der Reihenentwicklung eines Polynoms
     als exakt angenommen.

     Beispiel:

          (%i1) taylor(x^6+x^4+x^2,x,0,4),taylor_truncate_polynomials:true;
                                    2    4
          (%o1)/T/                 x  + x  + . . .
          (%i2) taylor(x^6+x^4+x^2,x,0,4),taylor_truncate_polynomials:false;
                                        2    4
          (%o2)/T/                     x  + x

 -- Funktion: taytorat (<expr>)
     Konvertiert den Ausdruck <expr> von der speziellen Darstellung
     einer Taylorreihenentwicklung in eine CRE-Form.

     Beispiel:

          (%i1) taylor(atan(x),x,0,5);
                                      3    5
                                     x    x
          (%o1)/T/               x - -- + -- + . . .
                                     3    5
          (%i2) taytorat(%);
                                    5      3
                                 3 x  - 5 x  + 15 x
          (%o2)/R/               ------------------
                                         15

 -- Funktion: trunc (<expr>)
     Die Rückgabe der Funktion `trunc' ist ein Ausdruck, der das
     Argument <expr> in der Ausgabe wie eine Taylorreihenentwicklung
     anzeigt.  Der Ausdruck <expr> wird ansonsten nicht modifiziert.

     Beispiel:

          (%i1) expr: x^2 + x + 1;
                                      2
          (%o1)                      x  + x + 1
          (%i2) trunc (expr);
                                          2
          (%o2)                  1 + x + x  + . . .
          (%i3) is (expr = trunc (expr));
          (%o3)                         true

 -- Optionsvariable: verbose
     Standardwert: `false'

     Hat die Optionsvariable `verbose' den Wert `true', werden von der
     Funktion `powerseries'  Meldungen über die verwendeten Algorithmen
     ausgegeben.


File: maxima.info,  Node: Poisson Reihen,  Next: Kettenbrüche,  Prev: Funktionen und Variablen für Reihen,  Up: Summen Produkte und Reihen

15.4 Poisson Reihen
===================

 -- Function: intopois (<a>)
     Converts <a> into a Poisson encoding.

 -- Function: outofpois (<a>)
     Converts <a> from Poisson encoding to general representation.  If
     <a> is not in Poisson form, `outofpois' carries out the
     conversion, i.e., the return value is `outofpois (intopois
     (<a>))'. This function is thus a canonical simplifier for sums of
     powers of sine and cosine terms of a particular type.

 -- Function: poisdiff (<a>, <b>)
     Differentiates <a> with respect to <b>. <b> must occur only in the
     trig arguments or only in the coefficients.

 -- Function: poisexpt (<a>, <b>)
     Functionally identical to `intopois (<a>^<b>)'. <b> must be a
     positive integer.

 -- Function: poisint (<a>, <b>)
     Integrates in a similarly restricted sense (to `poisdiff').
     Non-periodic terms in <b> are dropped if <b> is in the trig
     arguments.

 -- Option variable: poislim
     Default value: 5

     `poislim' determines the domain of the coefficients in the
     arguments of the trig functions.  The initial value of 5
     corresponds to the interval [-2^(5-1)+1,2^(5-1)], or [-15,16], but
     it can be set to [-2^(n-1)+1, 2^(n-1)].

 -- Function: poismap (<series>, <sinfn>, <cosfn>)
     will map the functions <sinfn> on the sine terms and <cosfn> on the
     cosine terms of the Poisson series given. <sinfn> and <cosfn> are
     functions of two arguments which are a coefficient and a
     trigonometric part of a term in series respectively.

 -- Function: poisplus (<a>, <b>)
     Is functionally identical to `intopois (a + b)'.

 -- Function: poissimp (<a>)
     Converts <a> into a Poisson series for <a> in general
     representation.

 -- Special symbol: poisson
     The symbol `/P/' follows the line label of Poisson series
     expressions.

 -- Function: poissubst (<a>, <b>, <c>)
     Substitutes <a> for <b> in <c>.  <c> is a Poisson series.

     (1) Where <B> is a variable <u>, <v>, <w>, <x>, <y>, or <z>, then
     <a> must be an expression linear in those variables (e.g., `6*u +
     4*v').

     (2) Where <b> is other than those variables, then <a> must also be
     free of those variables, and furthermore, free of sines or cosines.

     `poissubst (<a>, <b>, <c>, <d>, <n>)' is a special type of
     substitution which operates on <a> and <b> as in type (1) above,
     but where <d> is a Poisson series, expands `cos(<d>)' and
     `sin(<d>)' to order <n> so as to provide the result of substituting
     `<a> + <d>' for <b> in <c>.  The idea is that <d> is an expansion
     in terms of a small parameter.  For example, `poissubst (u, v,
     cos(v), %e, 3)' yields `cos(u)*(1 - %e^2/2) - sin(u)*(%e -
     %e^3/6)'.

 -- Function: poistimes (<a>, <b>)
     Is functionally identical to `intopois (<a>*<b>)'.

 -- Function: poistrim ()
     is a reserved function name which (if the user has defined it)
     gets applied during Poisson multiplication.  It is a predicate
     function of 6 arguments which are the coefficients of the <u>,
     <v>, ..., <z> in a term.  Terms for which `poistrim' is `true'
     (for the coefficients of that term) are eliminated during
     multiplication.

 -- Function: printpois (<a>)
     Prints a Poisson series in a readable format.  In common with
     `outofpois', it will convert <a> into a Poisson encoding first, if
     necessary.


File: maxima.info,  Node: Kettenbrüche,  Prev: Poisson Reihen,  Up: Summen Produkte und Reihen

15.5 Kettenbrüche
=================

 -- Function: cf (<expr>)
     Converts <expr> into a continued fraction. <expr> is an expression
     comprising continued fractions and square roots of integers.
     Operands in the expression may be combined with arithmetic
     operators. Aside from continued fractions and square roots,
     factors in the expression must be integer or rational numbers.
     Maxima does not know about operations on continued fractions
     outside of `cf'.

     `cf' evaluates its arguments after binding `listarith' to `false'.
     `cf' returns a continued fraction, represented as a list.

     A continued fraction `a + 1/(b + 1/(c + ...))' is represented by
     the list `[a, b, c, ...]'. The list elements `a', `b', `c', ...
     must evaluate to integers. <expr> may also contain `sqrt (n)' where
     `n' is an integer. In this case `cf' will give as many terms of the
     continued fraction as the value of the variable `cflength' times
     the period.

     A continued fraction can be evaluated to a number by evaluating
     the arithmetic representation returned by `cfdisrep'. See also
     `cfexpand' for another way to evaluate a continued fraction.

     See also `cfdisrep', `cfexpand', and `cflength'.

     Examples:

        * <expr> is an expression comprising continued fractions and
          square roots of integers.

               (%i1) cf ([5, 3, 1]*[11, 9, 7] + [3, 7]/[4, 3, 2]);
               (%o1)               [59, 17, 2, 1, 1, 1, 27]
               (%i2) cf ((3/17)*[1, -2, 5]/sqrt(11) + (8/13));
               (%o2)        [0, 1, 1, 1, 3, 2, 1, 4, 1, 9, 1, 9, 2]

        * `cflength' controls how many periods of the continued fraction
          are computed for algebraic, irrational numbers.

               (%i1) cflength: 1$
               (%i2) cf ((1 + sqrt(5))/2);
               (%o2)                    [1, 1, 1, 1, 2]
               (%i3) cflength: 2$
               (%i4) cf ((1 + sqrt(5))/2);
               (%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
               (%i5) cflength: 3$
               (%i6) cf ((1 + sqrt(5))/2);
               (%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]

        * A continued fraction can be evaluated by evaluating the
          arithmetic representation returned by `cfdisrep'.

               (%i1) cflength: 3$
               (%i2) cfdisrep (cf (sqrt (3)))$
               (%i3) ev (%, numer);
               (%o3)                   1.731707317073171

        * Maxima does not know about operations on continued fractions
          outside of `cf'.

               (%i1) cf ([1,1,1,1,1,2] * 3);
               (%o1)                     [4, 1, 5, 2]
               (%i2) cf ([1,1,1,1,1,2]) * 3;
               (%o2)                  [3, 3, 3, 3, 3, 6]


 -- Function: cfdisrep (<list>)
     Constructs and returns an ordinary arithmetic expression of the
     form `a + 1/(b + 1/(c + ...))' from the list representation of a
     continued fraction `[a, b, c, ...]'.

          (%i1) cf ([1, 2, -3] + [1, -2, 1]);
          (%o1)                     [1, 1, 1, 2]
          (%i2) cfdisrep (%);
                                            1
          (%o2)                     1 + ---------
                                              1
                                        1 + -----
                                                1
                                            1 + -
                                                2

 -- Function: cfexpand (<x>)
     Returns a matrix of the numerators and denominators of the last
     (column 1) and next-to-last (column 2) convergents of the
     continued fraction <x>.

          (%i1) cf (rat (ev (%pi, numer)));

          `rat' replaced 3.141592653589793 by 103993/33102 =3.141592653011902
          (%o1)                  [3, 7, 15, 1, 292]
          (%i2) cfexpand (%);
                                   [ 103993  355 ]
          (%o2)                    [             ]
                                   [ 33102   113 ]
          (%i3) %[1,1]/%[2,1], numer;
          (%o3)                   3.141592653011902

 -- Option variable: cflength
     Default value: 1

     `cflength' controls the number of terms of the continued fraction
     the function `cf' will give, as the value `cflength' times the
     period.  Thus the default is to give one period.

          (%i1) cflength: 1$
          (%i2) cf ((1 + sqrt(5))/2);
          (%o2)                    [1, 1, 1, 1, 2]
          (%i3) cflength: 2$
          (%i4) cf ((1 + sqrt(5))/2);
          (%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
          (%i5) cflength: 3$
          (%i6) cf ((1 + sqrt(5))/2);
          (%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]


File: maxima.info,  Node: Analysis,  Next: Polynome,  Prev: Summen Produkte und Reihen,  Up: Top

16 Analysis
***********

* Menu:

* Funktionen und Variablen für Grenzwerte::
* Funktionen und Variablen der Differentiation::
* Integration::
* Differentialgleichungen::


File: maxima.info,  Node: Funktionen und Variablen für Grenzwerte,  Next: Funktionen und Variablen der Differentiation,  Prev: Analysis,  Up: Analysis

16.1 Funktionen und Variablen für Grenzwerte
============================================

 -- Optionsvariable: lhospitallim
     Standardwert: 4

     Die Optionsvariable `lhospitallim' enthält die maximale Zahl an
     Iterationen, für die die L'Hospitalsche Regel von der Funktion
     `limit'  angewendet wird.  Damit wird verhindert, dass die Funktion
     `limit' in eine unendliche Schleife gerät.

 -- Funktion: limit (<expr>, <x>, <val>, <dir>)
 -- Funktion: limit (<expr>, <x>, <val>)
 -- Funktion: limit (<expr>)
     Berechnet den Grenzwert des Ausdrucks <expr>, wenn die reelle
     Variable <x> gegen den Wert <val> in Richtung <dir> geht.  Die
     Richtung <dir> kann die Werte <plus> für einen Grenzwert von oben
     und <minus> für einen Grenzwert von unten haben.  Für einen
     zweiseitigen Grenzwert wird die Richtung <dir> nicht angegeben.

     Maxima verwendet die folgenden Symbole für unendliche und
     infinitesimale Größen sowie undefinierte und unbestimmte Größen,
     die als Ergebnis eines Grenzwertes oder als Wert für die
     Bestimmung eines Grenzwertes auftreten können:

    `inf'
          positiv unendlich

    `minf'
          negativ unendlich

    `infinity'
          komplex unendlich

    `zeroa'
          positiv unendlich klein

    `zerob'
          negativ unendlich klein

    `und'
          ein nicht definiertes Ergebnis

    `ind'
          ein unbestimmtes Ergebnis

     Die Optionsvariable `lhospitallim'  enthält die maximale Zahl an
     Iterationen, für die die L'Hospitalsche Regel von der Funktion
     `limit' angewendet wird.

     Hat `tlimswitch'  den Wert `true', nutzt die Funktion `limit' eine
     Taylor-Reihenentwicklung, wenn der Grenzwert nicht mit anderen
     Methoden bestimmt werden kann.

     Hat die Optionsvariable `limsubst' den Wert `false', wird die
     Ersetzung von `limit(f(g(x)),x,x0)' durch `f(limit(g(x),x,x0))' für
     eine unbekannte Funktion `f' verhindert.  Siehe auch `limsubst'.

     `limit' kann mit einem Argument aufgerufen werden, um Ausdrücke zu
     vereinfachen, die unendliche oder infinitesimale Größen enthalten.
     Zum Beispiel wird `limit(inf-1)' zu `inf' vereinfacht.

     Der Algorithmus ist in der folgenden Arbeit beschrieben: Wang, P.,
     "Evaluation of Definite Integrals by Symbolic Manipulation", Ph.D.
     thesis, MAC TR-92, October 1971.

     Beispiele:

          (%i1) limit(x*log(x),x,0,plus)
          (%o1)                           0
          (%i2) limit((x+1)^(1/x),x,0)
          (%o2)                          %e
          (%i3) limit(%e^x/x,x,inf)
          (%o3)                          inf
          (%i4) limit(sin(1/x),x,0)
          (%o4)                          ind

 -- Optionsvariable: limsubst
     Standardwert: `false'

     Ist eine Funktion `f' teil eines Ausdrucks für den Maxima den
     Grenzwert sucht, dann wird folgende Ersetzung ausgeführt:

             limit   f(g(x)) = f(limit   g(x))
             x -> x0             x -> x0

     Hat die Optionsvariable `limsubst' den Wert `false', führt `limit'
     die oben gezeigte Ersetzung nicht für unbekannte Funktionen `f'
     aus.  Dies vermeidet Fehler wie zum Beispiel ein Ergebnis von 1 für
     den Grenzwert `limit (f(n)/f(n+1), n, inf)'.  Hat `limsubst' den
     Wert `true', führt Maxima die oben gezeigte Ersetzung auch für
     unbekannte Funktionen `f' aus.

     Beispiele:

     Die Funktion `f' ist nicht definiert.  Maxima gibt im ersten Fall
     eine Substantivform zurück.  Im zweiten Fall nimmt Maxima den
     Grenzwert für die unbekannte Funktion als `f(10)' an.

          (%i1) limit(f(x),x,10),limsubst:false;
          (%o1)                     limit   f(x)
                                    x -> 10
          (%i2) limit(f(x),x,10),limsubst:true;
          (%o2)                         f(10)

 -- Funktion: tlimit (<expr>, <x>, <val>, <dir>)
 -- Funktion: tlimit (<expr>, <x>, <val>)
 -- Funktion: tlimit (<expr>)
     Bestimmt den Grenzwert mit Hilfe der Taylor-Reihenwicklung des
     Ausdrucks `expr', wenn die Variable <x> gegen den Wert `val' aus
     der Richtung <dir> geht.  Diese Methode wird von `limit'
     angewendet, wenn die Optionsvariable `tlimswitch'  den Wert `true'
     ist.  Das ist der Standardwert.

 -- Optionsvariable: tlimswitch
     Standardwert: `true'

     Hat `tlimswitch' den Wert `true', nutzt die Funktion `limit'  eine
     Taylor-Reihenentwicklung, wenn der Grenzwert nicht mit anderen
     Methoden bestimmt werden kann.


File: maxima.info,  Node: Funktionen und Variablen der Differentiation,  Next: Integration,  Prev: Funktionen und Variablen für Grenzwerte,  Up: Analysis

16.2 Funktionen und Variablen der Differentiation
=================================================

 -- Funktion: at (<expr>, [<eqn_1>, ..., <eqn_n>])
 -- Funktion: at (<expr>, <eqn>)
     Wertet den Ausdruck <expr> aus, wobei dessen Variablen die Werte
     annehmen, die in der Liste der Gleichungen `[<eqn_1>, ...,
     <eqn_n>]' oder in der einzelnen Gleichung <eqn> angegeben sind.

     Wenn ein Teilausdruck von einer Variablen abhängt, für die ein Wert
     angegeben ist, aber kein `atvalue', und er auch sonst nicht
     ausgewertet werden kann, dann wird von `at' eine Substantivform
     zurückgegeben.

     `at' führt mehrfache Ersetzungen parallel aus.

     Siehe auch `atvalue'.    Für andere Funktionen, die Ersetzungen
     ausführen, siehe weiterhin `subst'  und `ev'.

     Beispiele:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x, y)^2 - u(x, y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                   !
                        2              d           !
          (%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                                       dx          !
                                                   !x = 0, y = 1

 -- Funktion: antid (<expr>, <x>, <u(x)>)
     Gibt eine Liste mit zwei Elementen zurück aus denen die
     Stammfunktion des Ausdrucks <expr> mit der Variablen <x>
     konstruiert werden kann.  Der Ausdruck <expr> kann eine unbekannte
     Funktion <u> und deren Ableitungen enthalten.  Ist <L> das
     Ergebnis der Funktion `antid', dann ist der Ausdruck `<L>[1]+
     'integrate(<L>[2], <x>)' die gesuchte Stammfunktion des Ausdrucks
     <expr> mit der Variablen <x>.

     Kann `antid' die Stammfunktion vollständig bestimmen, ist das
     zweite Element der Liste Null.  Hat `antid' keinerlei Erfolg, ist
     das erste Element der Liste Null.  In anderen Fällen enthält das
     erste Elemente den integrierbaren Anteil des Ausdrucks <expr> und
     das zweite Element den nicht integrierbaren Anteil des Ausdrucks.

     Mit dem Kommando `load(antid)' wird die Funktion geladen.

     `antid' steht in folgender Beziehung zur Funktion `antidiff'.
     Ist <L> die Liste mit den Ergebnissen der Funktion `antid', dann
     hat die Funktion `antidiff' das Ergebnis `<L>[1] +
     'integrate(<L>[2], <x>)' mit <x> als der Variablen des Ausdrucks
     <expr>.

     Beispiele:

          (%i1) load ("antid")$
          (%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                                      z(x)  d
          (%o2)                y(x) %e     (-- (z(x)))
                                            dx
          (%i3) a1: antid (expr, x, z(x));
                                 z(x)      z(x)  d
          (%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                                 dx
          (%i4) a2: antidiff (expr, x, z(x));
                                      /
                               z(x)   [   z(x)  d
          (%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                                      ]         dx
                                      /
          (%i5) a2 - (first (a1) + 'integrate (second (a1), x));
          (%o5)                           0
          (%i6) antid (expr, x, y(x));
                                       z(x)  d
          (%o6)             [0, y(x) %e     (-- (z(x)))]
                                             dx
          (%i7) antidiff (expr, x, y(x));
                            /
                            [        z(x)  d
          (%o7)             I y(x) %e     (-- (z(x))) dx
                            ]              dx
                            /

 -- Funktion: antidiff (<expr>, <x>, <u>(<x>))
     Gibt die Stammfunktion des Ausdrucks <expr> mit der Variablen <x>
     zurück.  Der Ausdruck <expr> kann eine unbekannte Funktion <u> und
     deren Ableitungen enthalten.

     Kann `antidiff' die Stammfunktion nicht oder nur teilweise
     bestimmen, enthält das Ergebnis das Integral des nicht
     bestimmbaren Anteils.

     Mit dem Kommando `load(antid)' wird die Funktion geladen.

     `antidiff' steht in folgender Beziehung zur Funktion `antid'.
     Ist <L> die Liste mit den Ergebnissen der Funktion `antid', dann
     hat die Funktion `antidiff' das Ergebnis `<L>[1] +
     'integrate(<L>[2], <x>)' mit <x> als der Variablen des Ausdrucks
     <expr>.

     Für Beispiele und weitere Ausführungen siehe die Funktion `antid'.


 -- Eigenschaft: atomgrad
     Wird für ein Symbol eine Ableitung mit der Funktion `gradef'
     definiert, dann erhält das Symbol die Eigenschaft `atomgrad'.

 -- Funktion: atvalue (<expr>, [<x_1> = <a_1>, ..., <x_m> = <a_m>], <c>)
 -- Funktion: atvalue (<expr>, <x_1> = <a_1>, <c>)
     Dem Ausdruck <expr> wird der Wert <c> am Punkt `<x> = <a>'
     zugewiesen.  Typischerweise werden Randwerte mit der Funktion
     `atvalue' definiert.

     Der Ausdruck <expr> ist entweder eine Funktion `<f>(<x_1>, ...,
     <x_m>)' oder die Ableitung einer Funktion `diff(<f>(<x_1>, ...,
     <x_m>), <x_1>, <n_1>, ..., <x_n>, <n_m>)'.  Die Argumente müssen
     explizit auftreten.  <n_i> ist die Ordnung der Ableitung bezüglich
     der Variablen <x_i>.

     Die Randwerte werden durch die Liste `[<x_1> = <a_1>, ..., <x_m> =
     <a_m>]' definiert.  Eine einzelne Gleichung muss nicht als Liste
     angegeben werden.

     `printprops([<f_1>, <f_2>, ...], atvalue)' zeigt die Randwerte der
     Funktionen `<f_1>, <f_2>, ...' wie sie mit der Funktion `atvalue'
     definiert wurden.  `printprops (<f>, atvalue)' zeigt nur die
     Randwerte für die Funktion <f>.  `printprops (all, atvalue)' zeigt
     die Randwerte aller Funktionen.

     Die Symbole `@1', `@2', ... repräsentieren die Variablen <x_1>,
     <x_2>, ..., wenn die Randwerte angezeigt werden.

     `atvalue' wertet die Argumente aus.  `atvalue' gibt den Randwert
     <c> zurück.

     Beispiele:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x,y)^2 - u(x,y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                   !
                        2              d           !
          (%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                                       dx          !
                                                   !x = 0, y = 1

 -- Paket: cartan
     The exterior calculus of differential forms is a basic tool of
     differential geometry developed by Elie Cartan and has important
     applications in the theory of partial differential equations.  The
     `cartan' package implements the functions `ext_diff' and
     `lie_diff', along with the operators `~' (wedge product) and `|'
     (contraction of a form with a vector.)  Type `demo (tensor)' to
     see a brief description of these commands along with examples.

     `cartan' was implemented by F.B. Estabrook and H.D. Wahlquist.

 -- Funktion: del (<x>)
     `del(<x>)' repräsentiert das Differential der Variablen <x>.

     `diff' gibt Ausdrücke zurück, die Differentiale enthalten, wenn
     keine Variablen angegeben sind, nach denen abgeleitet werden soll.
     In diesem Fall gibt `diff' das totale Differential zurück.

     Beispiele:

          (%i1) diff (log (x));
                                       del(x)
          (%o1)                        ------
                                         x
          (%i2) diff (exp (x*y));
                               x y              x y
          (%o2)            x %e    del(y) + y %e    del(x)
          (%i3) diff (x*y*z);
          (%o3)         x y del(z) + x z del(y) + y z del(x)

 -- Funktion: delta (<t>)
     Die Diracsche Delta-Funktion.

     Maxima kennt die Delta-Funktion nur im Zusammenhang mit
     Laplace-Transformationen.  Siehe `laplace'.

     Beispiel:

          (%i1) laplace (delta (t - a) * sin(b*t), t, s);
          Is  a  positive, negative, or zero?

          p;
                                             - a s
          (%o1)                   sin(a b) %e

 -- Systemvariable: dependencies
     Standardwert: `[]'

     `dependencies' ist eine Liste der Symbole, für die eine
     Abhängigkeit mit den Funktionen `depends' oder `gradef' definiert
     wurde.  Siehe `depends'  und `gradef'.


 -- Funktion: depends (<f_1>, <x_1>, ..., <f_n>, <x_n>)
     Definiert die Abhängigkeit einer Funktion <f> von einer Variablen
     <x>.  Ist keine Abhängigkeit definiert, dann hat die Ableitung
     `diff(f, x)' das Ergebnis Null.  Wird mit dem Kommando `depends(f,
     x)' definiert, dass die Funktion <f> von der Variablen <x>
     abhängt, dann ist das Ergebnis der Ableitung die Substantivform
     `'diff(f,x,1)'.

     Jedes Argument <f_1>, <x_1>, ... kann der Name einer Variablen,
     eines Arrays oder eine Liste mit Namen sein.  Jedes Symbol <f_i>
     hängt ab von den Symbolen der Liste <x_i>.  Ist eines der Symbole
     <f_i> der Name eines Arrays, dann hängen alle Elemente des Arrays
     von <x_i> ab.

     `diff' erkennt indirekte Abhängigkeiten und wendet für diesen Fall
     die Kettenregel an.

     `remove(<f>, dependency)' entfernt alle Abhängigkeiten, die für
     <f> definiert wurden.

     `depends' gibt eine Liste der Abhängigkeiten zurück.  Die
     Abhängigkeiten werden in die Informationsliste `dependencies'
     eingetragen.  `depends' wertet die Argumente aus.

     Die Funktion `diff'  ist die einzige Maxima-Funktion, die
     Abhängigkeiten erkennt, die mit `depends' definiert wurden.
     Andere Funktionen wie `integrate'  oder `laplace'  erkennen keine
     Abhängigkeiten, die mit der `depends' definiert wurden.  Für diese
     Funktionen müssen die Abhängigkeiten explizit angegeben werden,
     zum Beispiel als `integrate(f(x), x)'.

     Beispiele:

          (%i1) depends ([f, g], x);
          (%o1)                     [f(x), g(x)]
          (%i2) depends ([r, s], [u, v, w]);
          (%o2)               [r(u, v, w), s(u, v, w)]
          (%i3) depends (u, t);
          (%o3)                        [u(t)]
          (%i4) dependencies;
          (%o4)      [f(x), g(x), r(u, v, w), s(u, v, w), u(t)]
          (%i5) diff (r.s, u);
                                   dr           ds
          (%o5)                    -- . s + r . --
                                   du           du

          (%i6) diff (r.s, t);
                                dr du           ds du
          (%o6)                 -- -- . s + r . -- --
                                du dt           du dt

          (%i7) remove (r, dependency);
          (%o7)                         done
          (%i8) diff (r.s, t);
                                          ds du
          (%o8)                       r . -- --
                                          du dt

 -- Optionsvariable: derivabbrev
     Standardwert: `false'

     Hat `derivabbrev' den Wert `true', werden symbolische Ableitungen
     mit einem tiefgestellten Index angezeigt.  Ansonsten werden
     Ableitungen als `dy/dx' angezeigt.

     Beispiel:

          (%i1) derivabbrev:false$

          (%i2) 'diff(y,x);
                                         dy
          (%o2)                          --
                                         dx
          (%i3) derivabbrev:true$

          (%i4) 'diff(y,x);
          (%o4)                          y
                                          x

 -- Funktion: derivdegree (<expr>, <y>, <x>)
     Gibt die höchste Ableitung des Arguments <y> in Bezug auf die
     Variable <x> zurück, die in dem Ausdruck <expr> enthalten ist.

     Beispiel:

          (%i1) 'diff (y, x, 2) + 'diff (y, z, 3) + 'diff (y, x) * x^2;
                                   3     2
                                  d y   d y    2 dy
          (%o1)                   --- + --- + x  --
                                    3     2      dx
                                  dz    dx
          (%i2) derivdegree (%, y, x);
          (%o2)                           2

 -- Auswertungsschalter: derivlist (<var_1>, ..., <var_k>)
     `derivlist' ist ein Auswertungsschalter für die Funktion `ev'.
     `ev' führt nur die Ableitungen in Bezug auf die angegebenen
     Variablen <var_1>, ..., <var_k> aus.  Siehe auch `ev'.


 -- Optionsvariable: derivsubst
     Standardwert: `false'

     Hat `derivsubst' den Wert `true', werden Substitutionen auch in
     Ausdrücke mit Ableitungen ausgeführt.  Zum Beispiel hat dann
     `subst(x, 'diff(y, t), 'diff(y, t, 2))' das Ergebnis `'diff(x, t)'.

 -- Funktion: diff (<expr>, <x_1>, <n_1>, ..., <x_m>, <n_m>)
 -- Funktion: diff (<expr>, <x>, <n>)
 -- Funktion: diff (<expr>, <x>)
 -- Funktion: diff (<expr>)
 -- Auswertungsschalter: diff
     Gibt die Ableitungen oder Differentiale des Ausdrucks <expr> in
     Bezug auf alle oder einige der Variablen des Ausdrucks zurück.

     `diff(<expr>, <x>, <n>)' gibt die n-te Ableitung des Ausdrucks
     <expr> in Bezug auf die Variable <x> zurück.

     `diff(<expr>, <x_1>, <n_1>, ..., <x_m>, <n_m>)' gibt die partielle
     Ableitung des Ausdrucks <expr> in Bezug auf die Variablen <x_1>,
     ..., <x_m> zurück.  Dies ist äquivalent zu `diff(...
     (diff(<expr>, <x_m>, <n_m>) ...), <x_1>, <n_1>)'.

     `diff(<expr>, <x>)' gibt die erste Ableitung des Ausdrucks <expr>
     in Bezug auf die Variable <x> zurück.

     `diff(<expr>)' gibt das totale Differential des Ausdrucks <expr>
     zurück.  Siehe auch `del'.

     Wenn die Ableitungen nicht ausgeführt werden sollen, kann der
     `Quote-Operator'  `'' verwendet werden, um eine Substantivform der
     Ableitung zu erhalten.

     Hat `derivabbrev'  den Wert `true', werden symbolische Ableitungen
     mit einem tiefgestelltem Index angezeigt.  Ansonsten werden
     Ableitungen als `dy/dy' angezeigt.

     `diff' ist auch ein Auswertungsschalter für die Funktion `ev'.  Das
     Kommando `ev(expr), diff' bewirkt, dass alle Ableitungen ausgeführt
     werden, die im Ausdruck <expr> enthalten sind.  Siehe auch die
     Funktion `ev'.

     `derivative' ist ein Alias-Name der Funktion `diff'.

     Beispiele:

          (%i1) diff (exp (f(x)), x, 2);
                               2
                        f(x)  d               f(x)  d         2
          (%o1)       %e     (--- (f(x))) + %e     (-- (f(x)))
                                2                   dx
                              dx
          (%i2) derivabbrev: true$
          (%i3) 'integrate (f(x, y), y, g(x), h(x));
                                   h(x)
                                  /
                                  [
          (%o3)                   I     f(x, y) dy
                                  ]
                                  /
                                   g(x)
          (%i4) diff (%, x);
                 h(x)
                /
                [
          (%o4) I     f(x, y)  dy + f(x, h(x)) h(x)  - f(x, g(x)) g(x)
                ]            x                     x                  x
                /
                 g(x)

     For the tensor package, the following modifications have been
     incorporated:

       1. The derivatives of any indexed objects in <expr> will have the
          variables <x_i> appended as additional arguments.  Then all
          the derivative indices will be sorted.

       2. The <x_i> may be integers from 1 up to the value of the
          variable `dimension' [default value: 4].  This will cause the
          differentiation to be carried out with respect to the
          <x_i>'th member of the list `coordinates' which should be set
          to a list of the names of the coordinates, e.g., `[x, y, z,
          t]'.  If `coordinates' is bound to an atomic variable, then
          that variable subscripted by <x_i> will be used for the
          variable of differentiation.  This permits an array of
          coordinate names or subscripted names like `X[1]', `X[2]',
          ... to be used.  If `coordinates' has not been assigned a
          value, then the variables will be treated as in (1) above.

 -- Funktion: gradef (<f>(<x_1>, ..., <x_n>), <g_1>, ..., <g_m>)
 -- Funktion: gradef (<a>, <x>, <expr>)
     Definiert eine partielle Ableitung der Funktion <f> oder Variablen
     <a>.

     Das Kommando `gradef(<f>(<x_1>, ..., <x_n>), <g_1>, ..., <g_m>)'
     definiert die partielle Ableitung `d<f>/d<x_i>' als <g_i>.  <g_i>
     ist ein Ausdruck.  <g_i> kann ein Funktionsaufruf sein, aber nicht
     der Name einer Funktion.  Die Anzahl der partiellen Ableitungen
     <m> kann kleiner als die Anzahl der Argumente <n> sein.

     `gradef(<a>, <x>, <expr>)' definiert die Ableitung der Variablen
     <a> in Bezug auf die Variable <x> als <expr>.  Wie mit der
     Funktion `depends' wird <a> als abhängig von <x> deklariert.  Die
     Abhängigkeit wird in die Liste `dependencies' eingetragen.  Siehe
     auch `depends'.

     Bis auf das erste Argument werden die Argumente der Funktion
     `gradef' ausgewertet.  `gradef' gibt die Funktion oder Variable
     zurück, für die eine partielle Ableitung definiert wurde.

     `gradef' kann die Ableitungen von vorhandenen Maxima-Funktionen neu
     definieren.  Zum Beispiel definiert `gradef(sin(x), sqrt (1 -
     sin(x)^2))' eine neue Ableitung der Sinusfunktion.

     `gradef' kann keine partiellen Ableitungen für indizierte
     Funktionen definieren.

     `printprops([<f_1>, ..., <f_n>], gradef)' zeigt die mit `gradef'
     definierten partiellen Ableitungen der Funktionen <f_1>, ...,
     <f_n> an und `printprops([<a_n>, ..., <a_n>], atomgrad)' zeigt die
     mit `gradef' definierten partiellen Ableitungen der Variablen
     <a_n>, ..., <a_n> an.  Siehe `printprops'.

     `gradefs'  ist eine Informationsliste, die die Funktionen enthält,
     für die mit `gradef' eine Ableitung definierte wurde.  Die Liste
     enthält keine Variablen, für die Ableitungen definiert wurden.

 -- Systemvariable: gradefs
     Standardwert: `[]'

     `gradefs' ist eine Liste der Funktionen, für die eine Ableitung
     mit der Funktion `gradef'  definiert wurde.


File: maxima.info,  Node: Integration,  Next: Differentialgleichungen,  Prev: Funktionen und Variablen der Differentiation,  Up: Analysis

16.3 Integration
================

* Menu:

* Einführung in die Integration::
* Funktionen und Variablen der Integration::
* Einführung in QUADPACK::
* Funktionen und Variablen für QUADPACK::


File: maxima.info,  Node: Einführung in die Integration,  Next: Funktionen und Variablen der Integration,  Prev: Integration,  Up: Integration

Integration

16.3.1 Einführung in die Integration
------------------------------------

Maxima hat verschiedene Algorithmen, um Integrale zu behandeln.  Die
Funktion `integrate'  nutzt diese.  Maxima hat ein Paket `antid' ,
welches Integrale mit einer unbekannten Funktion, deren Ableitung
bekannt ist, integrieren kann.  Für die numerische Berechnung von
Integralen hat Maxima das Paket `QUADPACK' mit Funktionen wie `quad_qag'
oder `quad_qags'.    Die Funktionen `laplace'  und `specint'  finden
die Laplacetransformation.  Wird das Paket `abs_integrate' geladen, kann
Maxima weitere Integrale lösen.  Dazu gehören insbesondere Integrale mit
der Betragsfunktion `abs'  und der Signum-Funktion `signum'.    Siehe
auch *note abs_integrate::.


File: maxima.info,  Node: Funktionen und Variablen der Integration,  Next: Einführung in QUADPACK,  Prev: Einführung in die Integration,  Up: Integration

16.3.2 Funktionen und Variablen der Integration
-----------------------------------------------

 -- Funktion: changevar (<expr>, <f(x,y)>, <y>, <x>)
     Führt eine Substitution der Integrationsvariablen, die als
     <f(x,y)=0> angegeben wird, für die Variable <x> in allen
     Integralen durch, die in <expr> enthalten sind.  Die neue Variable
     ist <y>.

          (%i1) assume(a > 0)$
          (%i2) 'integrate (%e**sqrt(a*y), y, 0, 4);
                                4
                               /
                               [    sqrt(a) sqrt(y)
          (%o2)                I  %e                dy
                               ]
                               /
                                0
          (%i3) changevar (%, y-z^2/a, z, y);
                                0
                               /
                               [                abs(z)
                             2 I            z %e       dz
                               ]
                               /
                                - 2 sqrt(a)
          (%o3)            - ----------------------------
                                          a

     Ein Ausdruck mit einem Integral in einer Substantivform
     `'integrate' wie im obigen Beispiel kann mit der Funktion `ev'
     und dem Auswertungsschalter `nouns'  ausgewertet werden.  Das
     Beispiel von oben kann zum Beispiel mit `ev(%o3, nouns)'
     ausgewertet werden.

     Mit `changevar' können auch die Indizes einer Summe oder eines
     Produktes substituiert werden.  Dabei muss beachtet werden, dass
     nur lineare Verschiebungen, wie zum Beispiel `i = j + ...', eine
     korrekte Substitution für Summen und Produkte sind.

          (%i4) sum (a[i]*x^(i-2), i, 0, inf);
                                   inf
                                   ====
                                   \         i - 2
          (%o4)                     >    a  x
                                   /      i
                                   ====
                                   i = 0
          (%i5) changevar (%, i-2-n, n, i);
                                  inf
                                  ====
                                  \               n
          (%o5)                    >      a      x
                                  /        n + 2
                                  ====
                                  n = - 2

 -- Funktion: dblint (<f>, <r>, <s>, <a>, <b>)
     Eine Routine, um ein bestimmtes doppeltes Integral mit der
     Simpsonschen Regel numerisch zu berechnen.

                b  s(x)
               /  /
               [  [
               I  I     f(x, y) dy dx
               ]  ]
               /  /
                a  r(x)

     Die Funktion <f> muss eine Funktion von zwei Variablen sein.  <r>
     und <s> müssen Funktionen einer Variablen sein.  <a> und <b> sind
     Gleitkommazahlen.  Die Optionsvariablen `dblint_x' und `dblint_y'
     kontrollieren die Anzahl der Unterteilungen des
     Integrationsintervalls für den Simpsonschen Algorithmus.  Der
     Standardwert ist jeweils 10.

     Das Kommando `demo(dblint)' zeigt ein Beispiel.

     Die numerischen Funktionen des Pakets `QUADPACK' sind gegenüber
     `dblint' zu bevorzugen.

 -- Funktion: defint (<expr>, <x>, <a>, <b>)
     Sucht das bestimmte Integral eines Ausdrucks <expr> für die
     Integrationsvariable <x> in den Grenzen <a> und <b>.  Diese
     Funktion wird ausgeführt, wenn ein bestimmtes Integral mit der
     Funktion `integrate'  gesucht wird.

     `defint' gibt einen symbolischen Ausdruck als Ergebnis zurück.
     Ist das Integral divergent, generiert Maxima eine Fehlermeldung.
     Kann `defint' keine Lösung finden, wird eine Substantivform
     zurückgegeben.

 -- Optionsvariable: erfflag
     Standardwert: `true'

     Hat `erfflag' den Wert `false', wird von der Funktion `risch'

     die Fehlerfunktion `erf'  nicht in die Lösung eingeführt.

 -- Funktion: ilt (<expr>, <s>, <t>)
     Berechnet die Inverse Laplace-Transformation des Ausdrucks <expr>
     für die Variable <s> und den Parameter <t>.  <expr> muss eine
     rationale Funktion sein, in deren Nenner nur lineare und
     quadratische Faktoren auftreten.  Mit den Funktionen `laplace'
     und `ilt' sowie den Funktionen `solve'  oder `linsolve'  können
     lineare Differentialgleichungen oder Systeme von linearen
     Differentialgleichungen gelöst werden.

          (%i1) 'integrate (sinh(a*x)*f(t-x), x, 0, t) + b*f(t) = t**2;
                        t
                       /
                       [                                    2
          (%o1)        I  f(t - x) sinh(a x) dx + b f(t) = t
                       ]
                       /
                        0
          (%i2) laplace (%, t, s);
                                         a laplace(f(t), t, s)   2
          (%o2)  b laplace(f(t), t, s) + --------------------- = --
                                                 2    2           3
                                                s  - a           s
          (%i3) linsolve ([%], ['laplace(f(t), t, s)]);
                                                  2      2
                                               2 s  - 2 a
          (%o3)     [laplace(f(t), t, s) = --------------------]
                                              5         2     3
                                           b s  + (a - a  b) s
          (%i4) ilt (rhs (first (%)), s, t);
          Is  a b (a b - 1)  positive, negative, or zero?

          pos;
                         sqrt(a b (a b - 1)) t
                  2 cosh(---------------------)       2
                                   b               a t
          (%o4) - ----------------------------- + -------
                        3  2      2               a b - 1
                       a  b  - 2 a  b + a

                                                                 2
                                                       + ------------------
                                                          3  2      2
                                                         a  b  - 2 a  b + a

 -- Optionsvariable: intanalysis
     Standardwert: `true'

     Hat `intanalysis' den Wert `true', sucht Maxima nach Polen in einem
     Integranden.  Existieren solche, wird der Cauchysche Hauptwert des
     Integrals bestimmt.  Hat `intanalysis' den Wert `false', wird die
     Integration unter der Annahme ausgeführt, dass das Integral keine
     Pole im Integrationsbereich hat.

     Siehe auch `ldefint'.

     Beispiele:

     Maxima kann das folgende Integral lösen, wenn `intanalysis' den
     Wert `false' hat.

          (%i1) integrate(1/(sqrt(x)+1),x,0,1);
                                          1
                                         /
                                         [       1
          (%o1)                          I  ----------- dx
                                         ]  sqrt(x) + 1
                                         /
                                          0

          (%i2) integrate(1/(sqrt(x)+1),x,0,1),intanalysis:false;
          (%o2)                            2 - 2 log(2)

          (%i3) integrate(cos(a)/sqrt((tan(a))^2 +1),a,-%pi/2,%pi/2);
          The number 1 isn't in the domain of atanh
           -- an error. To debug this try: debugmode(true);

          (%i4) intanalysis:false$
          (%i5) integrate(cos(a)/sqrt((tan(a))^2+1),a,-%pi/2,%pi/2);
                                                %pi
          (%o5)                                 ---
                                                 2

 -- Funktion: integrate (<expr>, <x>)
 -- Funktion: integrate (<expr>, <x>, <a>, <b>)
     Sucht die symbolische Lösung des Integrals für den Ausdruck <expr>
     und der Integrationsvariablen <x>.  `integrate(<expr>, <x>)' löst
     das unbestimmte Integral.

     `integrate(<expr>, <x>, <a>, <b>)' sucht die Lösung des bestimmten
     Integrals in den Integrationsgrenzen <a> und <b>.  Die
     Integrationsgrenzen dürfen die Integrationsvariable <x> nicht
     enthalten.  Für die Integrationsgrenzen muss nicht gelten <a> <
     <b>.  Sind die Integrationsgrenzen gleich, dann ist das Ergebnis
     der Integration Null.

     Für die numerische Lösung von Integralen siehe die Funktion
     `quad_qag'  und verwandte Funktionen.  Residuen eines Integranden
     können mit der Funktion `residue'  berechnet werden.  Einen
     alternativen Algorithmus für das Lösen von Integralen, die im
     Integranden eine unbekannte Funktion und deren Ableitung
     enthalten, bieten die Funktionen `antid'  und `antidiff'.

     Findet `integrate' keine Lösung wird eine Substantivform oder ein
     Ausdruck mit einer oder mehreren Substantivformen zurückgegeben.

     Soll das Integral nicht sofort berechnet werden, kann die
     Substantivform des Integrals angegeben werden, zum Beispiel
     `'integrate(<expr>, <x>)'.  Die Berechnung des Integrals ist dann
     mit Funktion `ev'  und dem Auswertungsschalter `nouns'  möglich.

     Die Abhängigkeit der Funktionen im Integranden von Variablen muss
     explizit zum Beispiel mit `f(x)' angegeben werden.  `integrate'
     beachtet keine Abhängigkeit die mit der Funktion `depends'
     definiert werden.

     Benötigt `integrate' Informationen zu einem Parameter, die nicht
     aus dem aktuellen Kontext abgeleitet werden können, wird der
     Nutzer nach den fehlenden Informationen gefragt.

     `integrate' ist standardmäßig nicht als linear deklariert.  Siehe
     `declare'  und `linear'.

     Nur in einigen speziellen Fällen wendet `integrate' die Methode der
     partiellen Integration an.

     Beispiele:

     Elementare unbestimmte und bestimme Integrale.

          (%i1) integrate (sin(x)^3, x);
                                     3
                                  cos (x)
          (%o1)                   ------- - cos(x)
                                     3
          (%i2) integrate (x/ sqrt (b^2 - x^2), x);
                                           2    2
          (%o2)                    - sqrt(b  - x )
          (%i3) integrate (cos(x)^2 * exp(x), x, 0, %pi);
                                         %pi
                                     3 %e      3
          (%o3)                      ------- - -
                                        5      5
          (%i4) integrate (x^2 * exp(-x^2), x, minf, inf);
                                      sqrt(%pi)
          (%o4)                       ---------
                                          2

     Gebrauch von `assume' und interaktive Fragen.

          (%i1) assume (a > 1)$
          (%i2) integrate (x**a/(x+1)**(5/2), x, 0, inf);
              2 a + 2
          Is  -------  an integer?
                 5

          no;
          Is  2 a - 3  positive, negative, or zero?

          neg;
                                             3
          (%o2)                  beta(a + 1, - - a)
                                             2

     Substitution der Integrationsvariablen.  In diesem Beispiel werden
     zwei verschiedene Substitutionen vorgenommen.  Zuerst wird eine
     Ableitung der Funktion mit der Funktion `gradef' definiert.  Die
     andere nutzt die Ableitung `diff(r(x))' einer unbekannten Funktion
     `r(x)'.

          (%i3) gradef (q(x), sin(x^2));
          (%o3)                         q(x)
          (%i4) diff (log (q (r (x))), x);
                                d               2
                               (-- (r(x))) sin(r (x))
                                dx
          (%o4)                ----------------------
                                      q(r(x))
          (%i5) integrate (%, x);
          (%o5)                     log(q(r(x)))

     Die Lösung enthält eine Substantivform für das Integral einer
     rationalen Funktion.  Siehe auch `integrate_use_rootsof'  für
     Informationen zu Integralen von rationalen Funktionen.

          (%i1) expand ((x-4) * (x^3+2*x+1));
                              4      3      2
          (%o1)              x  - 4 x  + 2 x  - 7 x - 4
          (%i2) integrate (1/%, x);
                                        /  2
                                        [ x  + 4 x + 18
                                        I ------------- dx
                                        ]  3
                           log(x - 4)   / x  + 2 x + 1
          (%o2)            ---------- - ------------------
                               73               73

     Definition einer Funktion als ein Integral.  Die rechte Seite einer
     Funktionsdefinition wird nicht ausgewertet.  Daher enthält die
     Funktionsdefinition das Integral in einer Substantivform.  Der
     `Quote-Quote-Operator'  `''' erzwingt die Auswertung der
     Substantivform.

          (%i1) f_1(a) := integrate (x^3, x, 1, a);
                                               3
          (%o1)           f_1(a) := integrate(x , x, 1, a)
          (%i2) ev(f_1 (7), nouns);
          (%o2)                          600
          (%i3) /* Note parentheses around integrate(...) here */
                f_2(a) := ''(integrate (x^3, x, 1, a));
                                             4
                                            a    1
          (%o3)                   f_2(a) := -- - -
                                            4    4
          (%i4) f_2(7);
          (%o4)                          600

 -- Optionsvariable: integration_constant
     Standardwert: `%c'

     Wird eine symbolische Integrationskonstante für die Lösung eines
     Integrals benötigt, erzeugt Maxima diese durch Verkettung des
     Symbols `integration_constant' mit einer laufenden Nummer, die der
     Wert der Optionsvariablen `integration_constant_counter'  ist.

     Der Optionsvariablen `integration_constant' kann ein beliebiges
     Symbol zugewiesen werden.

     Beispiele:

          (%i1) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o1)                     -- = x + %c1
                                    3
          (%i2) integration_constant : 'k;
          (%o2)                           k
          (%i3) integrate (x^2 = 1, x);
                                      3
                                     x
          (%o3)                      -- = x + k2
                                     3

 -- Systemvariable: integration_constant_counter
     Standardwert: 0

     Wird eine symbolische Integrationskonstante für die Lösung eines
     Integrals benötigt, erzeugt Maxima diese durch Verkettung des
     Symbols `integration_constant'  mit einer laufenden Nummer, die
     der Wert der Optionsvariablen `integration_constant_counter' ist.

     Der Wert der Systemvariablen `integration_constant_counter' wird
     vor der Erzeugung der Integrationskonstanten erhöht.

     Beispiele:

          (%i1) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o1)                     -- = x + %c1
                                    3
          (%i2) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o2)                     -- = x + %c2
                                    3
          (%i3) reset (integration_constant_counter);
          (%o3)            [integration_constant_counter]
          (%i4) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o4)                     -- = x + %c1
                                    3

 -- Optionsvariable: integrate_use_rootsof
     Standardwert: `false'

     Hat `integrate_use_rootsof' den Wert `true' und der Nenner einer
     rationalen Funktion kann nicht faktorisiert werden, dann gibt
     `integrate'  ein Integral zurück, das eine Summe über die
     unbekannten Wurzeln des Nenners enthält.

     Hat zum Beispiel `integrate_use_rootsof' den Wert `false', gibt
     `integrate' im Folgenden ein Lösung zurück, die eine Substantivform
     enthält.

          (%i1) integrate_use_rootsof: false$
          (%i2) integrate (1/(1+x+x^5), x);
                  /  2
                  [ x  - 4 x + 5
                  I ------------ dx                            2 x + 1
                  ]  3    2                2            5 atan(-------)
                  / x  - x  + 1       log(x  + x + 1)          sqrt(3)
          (%o2)   ----------------- - --------------- + ---------------
                          7                 14             7 sqrt(3)

     Mit dem Wert `true' für die Optionsvariable `integrate_use_rootsof'
     wird das ungelöste Integral als eine Summe über die Wurzeln des
     Nenners der rationalen Funktion zurückgegeben.

          (%i3) integrate_use_rootsof: true$
          (%i4) integrate (1/(1+x+x^5), x);
                ====        2
                \       (%r4  - 4 %r4 + 5) log(x - %r4)
                 >      -------------------------------
                /                    2
                ====            3 %r4  - 2 %r4
                                3    2
                %r4 in rootsof(x  - x  + 1)
          (%o4) ----------------------------------------------------------
                         7

                                                                2 x + 1
                                            2            5 atan(-------)
                                       log(x  + x + 1)          sqrt(3)
                                     - --------------- + ---------------
                                             14             7 sqrt(3)

     Alternativ kann der Nutzer die Wurzeln des Nenners separat
     berechnen und den Integranden mit Hilfe der Wurzeln ausdrücken.
     Zum Beispiel als `1/((x - a)*(x - b)*(x - c))' oder
     `1/((x^2-(a+b)*x + a*b)*(x - c))' für ein kubisches Polynom mit
     drei Nullstellen im Nenner.  Auf diese Weise kann Maxima in
     einigen Fällen eine Lösung für ein Integral finden.

 -- Funktion: laplace (<expr>, <t>, <s>)
     Sucht die Laplace-Transformation des Ausdrucks <expr> für die
     Integrationsvariable <x> und den Parameter <s>.

     `laplace' findet die Laplace-Transformation für Ausdrücke, die die
     Funktionen `delta',  `exp',  `log',  `sin',

     `cos',  `sinh',  `cosh'  und `erf'  sowie Ausdrücke mit
     `derivative',  `integrate',  `sum'  und `ilt'

     enthalten.

     Kann `laplace' die Laplace-Transformation nicht finden, wird die
     Funktion `specint'  aufgerufen.  `specint' kann die
     Laplace-Transformation für eine Vielzahl von speziellen Funktionen
     im Integranden berechnen.  Findet auch `specint' keine Lösung ist
     das Ergebnis eine Substantivform.

     `laplace' erkennt die Faltung von Funktionen der Form `integrate
     (f(x) * g(t - x), x, 0, t)'.  Andere Faltungen werden nicht
     erkannt.

     Funktionale Abhängigkeiten von Variablen müssen explizit angegeben
     werden.  `laplace' erkennt keine Abhängigkeiten, die mit der
     Funktion `depends'  definiert wurden.  Eine Funktion die von den
     Variablen <x> abhängt, muss als `f(x)' im Ausdruck <expr>
     auftreten.

     Siehe auch `ilt'  für die Inverse Laplace-Transformation.

     Beispiele:

          (%i1) laplace (exp (2*t + a) * sin(t) * t, t, s);
                                      a
                                    %e  (2 s - 4)
          (%o1)                    ---------------
                                     2           2
                                   (s  - 4 s + 5)
          (%i2) laplace ('diff (f (x), x), x, s);
          (%o2)             s laplace(f(x), x, s) - f(0)
          (%i3) diff (diff (delta (t), t), t);
                                    2
                                   d
          (%o3)                    --- (delta(t))
                                     2
                                   dt
          (%i4) laplace (%, t, s);
                                      !
                         d            !         2
          (%o4)        - -- (delta(t))!      + s  - delta(0) s
                         dt           !
                                      !t = 0
          (%i5) assume(a>0)$
          (%i6) laplace(gamma_incomplete(a,t),t,s),gamma_expand:true;
                                                        - a - 1
                                   gamma(a)   gamma(a) s
          (%o6)                    -------- - -----------------
                                      s            1     a
                                                  (- + 1)
                                                   s
          (%i7) factor(laplace(gamma_incomplete(1/2,t),t,s));
                                                        s + 1
                                sqrt(%pi) (sqrt(s) sqrt(-----) - 1)
                                                          s
          (%o7)                 -----------------------------------
                                          3/2      s + 1
                                         s    sqrt(-----)
                                                     s
          (%i8) assume(exp(%pi*s)>1)$
          (%i9) laplace(sum((-1)^n*unit_step(t-n*%pi)*sin(t),n,0,inf),t,s)
                  ,simpsum;
                                   %i                         %i
                        ------------------------ - ------------------------
                                        - %pi s                    - %pi s
                        (s + %i) (1 - %e       )   (s - %i) (1 - %e       )
          (%o9)         ---------------------------------------------------
                                                 2
          (%i9) factor(%);
                                                %pi s
                                              %e
          (%o9)                   -------------------------------
                                                       %pi s
                                  (s - %i) (s + %i) (%e      - 1)

 -- Funktion: ldefint (<expr>, <x>, <a>, <b>)
     Sucht die Lösung des bestimmten Integrals für den Integranden
     <expr>.  `ldefint' bestimmt die Stammfunktion und sucht die
     Grenzwerte mit der Funktion `limit' an den Integrationsgrenzen <a>
     und <b>.  Kann ein Grenzwert nicht ermittelt werden, enthält das
     Ergebnis die Substantivform des Grenzwertes.

     `ldefint' wird nicht von der Funktion `integrate' aufgerufen.
     Daher kann `ldefint' ein von `integrate' verschiedenes Ergebnis
     haben.  `ldefint' verwendet immer denselben Algorithmus, um eine
     Lösung zu finden.  Dagegen wendet `integrate' verschiedene
     Algorithmen an, um nach einer Lösung zu suchen.

 -- Funktion: residue (<expr>, <z>, <z_0>)
     Berechnet das Residuum für den Ausdruck <expr>, wenn die Variable
     <z> gegen den Wert <z_0> geht.

     Beispiele:

          (%i1) residue (s/(s**2+a**2), s, a*%i);
                                          1
          (%o1)                           -
                                          2
          (%i2) residue (sin(a*x)/x**4, x, 0);
                                           3
                                          a
          (%o2)                         - --
                                          6

 -- Funktion: risch (<expr>, <x>)
     Nutzt den transzendenten Risch-Algorithmus für die Integration des
     Ausdruck <expr> und der Integrationsvariable <x>.  Der algebraische
     Risch-Algorithmus ist nicht implementiert.  Der transzendente
     Risch-Algorithmus behandelt Integranden mit Exponential- und
     Logarithmusfunktionen.  Der Risch-Algorithmus wird von `integrate'
     aufgerufen, wenn `integrate' keine Stammfunktion finden kann.

     Hat `erfflag'  den Wert `false', werden von der Funktion `risch'
     keine Fehlerfunktionen `erf' in die Lösung eingeführt.

     Beispiele:

          (%i1) risch (x^2*erf(x), x);
                                                                  2
                       3                      2                - x
                  %pi x  erf(x) + (sqrt(%pi) x  + sqrt(%pi)) %e
          (%o1)   -------------------------------------------------
                                        3 %pi
          (%i2) diff(%, x), ratsimp;
                                       2
          (%o2)                       x  erf(x)

 -- Funktion: tldefint (<expr>, <x>, <a>, <b>)
     Entspricht der Funktion `ldefint' mit dem Wert `true' für die
     Optionsvariable `tlimswitch'.


File: maxima.info,  Node: Einführung in QUADPACK,  Next: Funktionen und Variablen für QUADPACK,  Prev: Funktionen und Variablen der Integration,  Up: Integration

16.3.3 Einführung in QUADPACK
-----------------------------

QUADPACK ist eine Sammlung von Funktionen für die numerische Berechnung
von eindimensionalen bestimmten Integralen.  QUADPACK hat den Ursprung
in einem Projekt von R. Piessens (1), E. de Doncker (2), C. Ueberhuber
(3), und D. Kahaner (4).

Die QUADPACK-Bibliothek, die in Maxima enthalten ist, ist eine
automatische Übersetzung des Fortran Quellcodes mit dem Programm `f2cl'
wie er in der SLATEC Common Mathematical Library, Version 4.1 (5)
vorliegt.  Die SLATEC Bibliothek datiert auf Juli 1993.  Die QUADPACK
Funktionen wurden bereits einige Jahre früher programmiert.  Es gibt
eine weitere Version von QUADPACK bei Netlib (6).  Es ist jedoch unklar
worin sich diese von der SLATEC Version unterscheidet.

Alle QUADPACK-Funktionen versuchen automatisch, ein bestimmtes Integral
numerisch innerhalb eine spezifizierten Genauigkeit zu berechnen.  Die
Übersetzung nach Lisp enthält einige weitere nicht-automatische
Funktionen, die jedoch nicht als Maxima Funktionen zur Verfügung stehen.

Weitere Informationen über das QUADPACK-Paket sind in dem QUADPACK-Buch
(7) enthalten.

Übersicht über die Integrationsroutinen
.......................................

`quad_qag'
     Integration einer allgemeinen Funktion über ein endliches
     Intervall.  `quad_qag'  implementiert einen globalen adaptiven
     Integrator auf Grundlage der Strategie von Aind (Piessens, 1973).
     Es kann aus 6 verschiedenen Paaren von
     Gauß-Kronrad-Quadraturformeln ausgewählt werden.  Die Formeln
     höheren Grades sind für stark oszillierende Integranden geeignet.

`quad_qags'
     Integration einer allgemeinen Funktion über ein endliches
     Intervall.  Die Funktion `quad_qags'  implementiert die Strategie
     einer globalen adaptiven Unterteilung des Integrationsintervalls
     mit Extrapolation (de Doncker, 1978).  Zusätzlich wird versucht,
     die Konvergenz der Integralapproximation mit Hilfe des
     Epsilon-Algorithmus (Wynn, 1956) zu beschleunigen.  Dies führt zum
     Beispiel bei Integranden mit Singularitäten, deren Lage und Typ
     unbekannt sind, zu einer Effizienzsteigerung.

`quad_qagi'
     Die Funktion `quad_qagi'  führt die Integration einer allgemeinen
     Funktion über ein unendliches oder halb-unendliches Intervall aus.
     Das Intervall wird auf ein endliches Intervall transformiert.  Das
     transformierte Integrationsproblem wird dann mit einer geringfügig
     modifizierten Algorithmus wie in `quad_qags'  gelöst.

`quad_qawo'
     Berechnung von Integralen mit den trigonometrischen
     Gewichtsfunktionen cos(omega x) f(x) oder sin(omega x) f(x) über
     ein endliches Intervall, wobei omega eine Konstante ist.  Der
     Algorithmus der Funktion `quad_qawo'  zur basiert auf eine
     modifizierte Clenshaw-Curtis-Technik.  `quad_qawo' wendet eine
     adaptive Unterteilung des Integrationsintervalls mit Extrapolation
     an, die vergleichbar mit dem Algorithmus von `quad_qags'  ist.
     Zusätzlich wird versucht, die Konvergenz der Integralapproximation
     mit Hilfe des Epsilon-Algorithmus (Wynn, 1956) zu beschleunigen.

`quad_qawf'
     Die Funktion `quad_qawf'  berechnet die Sinus- oder
     Kosinus-Fouriertransformation über ein halb-unendliches Intervall.
     Dabei wird die global adaptive Routine `quad_qawo'  sukzessive auf
     endliche Teilintervalle angewendet.  Zur Konvergenzbeschleunigung
     der resultierenden alternierenden Reihe wird der
     Epsilon-Algorithmus (Wynn, 1956) verwendet.

`quad_qaws'
     Integration von w(x) f(x) über ein endliches Intervall [a, b],
     wobei w eine Funktion der Form (x - a)^alpha (b - x)^beta v(x) ist
     und v(x) ist 1 oder log(x - a) oder log(b - x) oder log(x - a)
     log(b - x), und alpha > -1 und beta > -1.  `quad_qaws'  ist
     speziell für die effiziente Berechnung von Integralen über
     endliche Intervalle mit algebraischen oder
     algebraisch-logarithmischen Endpunktsingularitäten konzipiert.
     Eine globale adaptive Strategie mit Unterteilung des
     Integrationsintervalls wird angewendet.  Auf Teilintervalle die
     keinen Endpunkt des Integrationsintervalls enthalten, kommt ein
     Gauß-Kronrod-Formelpaar und auf Randintervallen kommen modifizierte
     Clenshaw-Curtis-Formeln zur Anwendung.

`quad_qawc'
     Die Funktion `quad_qawc'  berechnet den Cauchyschen Hauptwert von
     f(x)(x - c) über ein endliches Intervall (a, b) und dem Wert c.
     Es wird eine modifizierte Clenshaw-Curtis-Formel angewendet, wenn
     c im Teilbereich enthalten ist.  Andernfalls wird eine globale
     adaptive Strategie mit einem Gauß-Kronrod-Formelpaar angewendet.

`quad_qagp'
     Basically the same as `quad_qags' but points of singularity or
     discontinuity of the integrand must be supplied.  This makes it
     easier for the integrator to produce a good solution.

---------- Footnotes ----------

(1) Applied Mathematics and Programming Division, K.U. Leuven

(2) Applied Mathematics and Programming Division, K.U. Leuven

(3) Institut für Mathematik, T.U.  Wien

(4) National Bureau of Standards, Washington, D.C., U.S.A

(5) `http://www.netlib.org/slatec'

(6) `http://www.netlib.org/quadpack'

(7) R. Piessens, E. de Doncker-Kapenga, C.W. Uberhuber, and D.K.
Berlin: Springer-Verlag, 1983, ISBN 0387125531.


File: maxima.info,  Node: Funktionen und Variablen für QUADPACK,  Prev: Einführung in QUADPACK,  Up: Integration

16.3.4 Funktionen und Variablen für QUADPACK
--------------------------------------------

 -- Funktion: quad_qag (<f(x)>, <x>, <a>, <b>, <key>, [<epsrel>,
          <epsabs>, <limit>])
 -- Funktion: quad_qag (<f>, <x>, <a>, <b>, <key>, [<epsrel>, <epsabs>,
          <limit>])
     Die Funktion `quad_qag' berechnet das folgende Integral über ein
     endliches Intervall.

                b
               /
               [
               I  f(x) dx
               ]
               /
                a

     `quad_qag' implementiert einen globalen adaptiven Integrator auf
     Grundlage der Strategie von Aind (Piessens, 1973).  Es kann aus 6
     verschiedenen Paaren von Gauß-Kronrad-Quadraturformeln ausgewählt
     werden.  Die Formeln höheren Grades sind für stark oszillierende
     Integranden geeignet.

     Die Funktion <f(x)> mit der abhängigen Variablen <x> wird im
     Integrationsintervall <a> und <b> integriert.  <key> wählt den
     Grad der Gauß-Kronrod-Quadraturformel aus und kann Werte von 1 bis
     6 annehmen.  Ein größerer Grad ist geeignet für stark oszillierende
     Integranden.

     Der Integrand kann eine Maxima-Funktion, eine Lisp-Funktion, ein
     Operator, ein Maxima-Lambda-Ausdruck oder ein allgemeiner
     Maxima-Ausdruck sein.

     Die numerische Integration wird adaptiv ausgeführt.  Der
     Integrationsbereich wird solange geteilt, bis die gewünschte
     Genauigkeit erreicht wird.

     Die Schlüsselwortargumente sind optional und können in beliebiger
     Reihenfolge angegeben werden.  Sie haben die Form `key=val'.  Die
     Schlüsselwortargumente sind:

    `epsrel'
          Gewünschter relativer Fehler der Approximation.  Der
          Standardwert ist `1.0e-8'.

    `epsabs'
          Gewünschter absoluter Fehler der Approximation.  Der
          Standardwert ist `0'.

    `limit'
          Die maximale Zahl an Teilintervallen des adaptiven
          Algorithmus.  Der Standardwert ist `200'.

     `quad_qag' gibt eine Liste mit vier Elementen zurück:

        * eine numerische Näherung des Integrals,

        * geschätzer absoluter Fehler der Näherung,

        * Anzahl der Auswertungen des Integranden,

        * ein Fehlercode.

     Der Fehlercode kann die folgenden Werte annehmen:

        * `0', wenn kein Fehler aufgetreten ist,

        * `1', wenn zu viele Teilintervalle notwendig wurden,

        * `2', wenn übemäßiger Rundungsfehler aufgetreten sind,

        * `3', wenn ein extrem schlechtes Verhalten des Integranden
          vorliegt,

        * `6', wenn die Eingabe ungültig ist.

     Beispiele:

          (%i1) quad_qag (x^(1/2)*log(1/x), x, 0, 1, 3, 'epsrel=5d-8);
          (%o1)    [.4444444444492108, 3.1700968502883E-9, 961, 0]
          (%i2) integrate (x^(1/2)*log(1/x), x, 0, 1);
                                          4
          (%o2)                           -
                                          9

 -- Funktion: quad_qags (<f(x)>, <x>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])
 -- Funktion: quad_qags (<f>, <x>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])
     Die Funktion `quad_qags' berechnet das folgende Integral über ein
     endliches Intervall.

                b
               /
               [
               I  f(x) dx
               ]
               /
                a

     `quad_qags' implementiert die Strategie einer globalen adaptiven
     Unterteilung des Integrationsintervalls mit Extrapolation (de
     Doncker, 1978).  Zusätzlich wird versucht, die Konvergenz der
     Integralapproximation mit Hilfe des Epsilon-Algorithmus (Wynn,
     1956) zu beschleunigen.  Dies führt zum Beispiel bei Integranden
     mit Singularitäten, deren Lage und Typ unbekannt sind, zu einer
     Effizienzsteigerung.

     Die Funktion <f(x)> mit der abhängigen Variablen <x> wird im
     Integrationsintervall <a> und <b> integriert.

     Der Integrand kann eine Maxima-Funktion, eine Lisp-Funktion, ein
     Operator, ein Maxima-Lambda-Ausdruck oder ein allgemeiner
     Maxima-Ausdruck sein.

     Die Schlüsselwortargumente sind optional und können in beliebiger
     Reihenfolge angegeben werden.  Sie haben die Form `key=val'.  Die
     Schlüsselwortargumente sind:

    `epsrel'
          Gewünschter relativer Fehler der Approximation.  Der
          Standardwert ist `1.0e-8'.

    `epsabs'
          Gewünschter absoluter Fehler der Approximation.  Der
          Standardwert ist `0'.

    `limit'
          Die maximale Zahl an Teilintervallen des adaptiven
          Algorithmus.  Der Standardwert ist `200'.

     `quad_qag' gibt eine Liste mit vier Elementen zurück:

        * eine numerische Näherung des Integrals,

        * geschätzer absoluter Fehler der Näherung,

        * Anzahl der Auswertungen des Integranden,

        * ein Fehlercode.

     Der Fehlercode kann die folgenden Werte annehmen:

        * `0', wenn kein Fehler aufgetreten ist,

        * `1', wenn zu viele Teilintervalle notwendig wurden,

        * `2', wenn übemäßiger Rundungsfehler aufgetreten sind,

        * `3', wenn ein extrem schlechtes Verhalten des Integranden
          vorliegt,

        * `6', wenn die Eingabe ungültig ist.

     Beispiele:

     `quad_qags' ist genauer und effizienter als `quad_qag'  für das
     folgende Beispiel.

          (%i1) quad_qags (x^(1/2)*log(1/x), x, 0, 1, 'epsrel=1d-10);
          (%o1)   [.4444444444444448, 1.11022302462516E-15, 315, 0]

 -- Funktion: quad_qagi (<f(x)>, <x>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])
 -- Funktion: quad_qagi (<f>, <x>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])
     Die Funktion `quad_qagi' berechnet die folgenden Integrale über ein
     unendliches oder halb-unendliches Intervall.

                inf
               /
               [
               I    f(x) dx
               ]
               /
                a

                a
               /
               [
               I     f(x) dx
               ]
               /
                minf

                inf
               /
               [
               I     f(x) dx
               ]
               /
                minf

     Das Intervall wird auf ein endliches Intervall transformiert.  Das
     transformierte Integrationsproblem wird dann mit einem geringfügig
     modifizierten Algorithmus wie in `quad_qags'  gelöst.

     Die Funktion <f(x)> mit der abhängigen Variablen <x> wird über
     einen unendlichen Bereich integriert.

     Der Integrand kann eine Maxima-Funktion, eine Lisp-Funktion, ein
     Operator, ein Maxima-Lambda-Ausdruck oder ein allgemeiner
     Maxima-Ausdruck sein.

     Eine der Grenzen des Integrationsbereiches kann unendlich sein.
     Ist dies nicht der Fall gibt `quad_qagi' eine Substantivform
     zurück.

     Die Schlüsselwortargumente sind optional und können in beliebiger
     Reihenfolge angegeben werden.  Sie haben die Form `key=val'.  Die
     Schlüsselwortargumente sind:

    `epsrel'
          Gewünschter relativer Fehler der Approximation.  Der
          Standardwert ist `1.0e-8'.

    `epsabs'
          Gewünschter absoluter Fehler der Approximation.  Der
          Standardwert ist `0'.

    `limit'
          Die maximale Zahl an Teilintervallen des adaptiven
          Algorithmus.  Der Standardwert ist `200'.

     `quad_qag' gibt eine Liste mit vier Elementen zurück:

        * eine numerische Näherung des Integrals,

        * geschätzer absoluter Fehler der Näherung,

        * Anzahl der Auswertungen des Integranden,

        * ein Fehlercode.

     Der Fehlercode kann die folgenden Werte annehmen:

        * `0', wenn kein Fehler aufgetreten ist,

        * `1', wenn zu viele Teilintervalle notwendig wurden,

        * `2', wenn übemäßiger Rundungsfehler aufgetreten sind,

        * `3', wenn ein extrem schlechtes Verhalten des Integranden
          vorliegt,

        * `6', wenn die Eingabe ungültig ist.

     Beispiele:

          (%i1) quad_qagi (x^2*exp(-4*x), x, 0, inf, 'epsrel=1d-8);
          (%o1)        [0.03125, 2.95916102995002E-11, 105, 0]
          (%i2) integrate (x^2*exp(-4*x), x, 0, inf);
                                         1
          (%o2)                          --
                                         32

 -- Funktion: quad_qawc (<f(x)>, <x>, <c>, <a>, <b>, [<epsrel>,
          <epsabs>, <limit>])
 -- Funktion: quad_qawc (<f>, <x>, <c>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])
     Die Funktion `quad_qawc' berechnet den Cauchyschen Hauptwert von
     f(x)(x - c) über ein endliches Intervall (a, b) und dem Wert c.

                b
               /
               [  f(x)
               I  ----- dx
               ]  x - c
               /
                a

     Es wird eine modifizierte Clenshaw-Curtis-Formel angewendet, wenn
     c im Teilbereich enthalten ist, andernfalls wird eine globale
     adaptive Strategie mit einem Gauß-Kronrod-Formelpaar angewendet.

     Die Funktion `<f(x)>/(<x> - <c>)', die von der Variablen <x>
     abhängt, wird in den Grenzen <a> und <b> integriert.

     Der Integrand kann eine Maxima-Funktion, eine Lisp-Funktion, ein
     Operator, ein Maxima-Lambda-Ausdruck oder ein allgemeiner
     Maxima-Ausdruck sein.

     Die Schlüsselwortargumente sind optional und können in beliebiger
     Reihenfolge angegeben werden.  Sie haben die Form `key=val'.  Die
     Schlüsselwortargumente sind:

    `epsrel'
          Gewünschter relativer Fehler der Approximation.  Der
          Standardwert ist `1.0e-8'.

    `epsabs'
          Gewünschter absoluter Fehler der Approximation.  Der
          Standardwert ist `0'.

    `limit'
          Die maximale Zahl an Teilintervallen des adaptiven
          Algorithmus.  Der Standardwert ist `200'.

     `quad_qag' gibt eine Liste mit vier Elementen zurück:

        * eine numerische Näherung des Integrals,

        * geschätzer absoluter Fehler der Näherung,

        * Anzahl der Auswertungen des Integranden,

        * ein Fehlercode.

     Der Fehlercode kann die folgenden Werte annehmen:

        * `0', wenn kein Fehler aufgetreten ist,

        * `1', wenn zu viele Teilintervalle notwendig wurden,

        * `2', wenn übemäßiger Rundungsfehler aufgetreten sind,

        * `3', wenn ein extrem schlechtes Verhalten des Integranden
          vorliegt,

        * `6', wenn die Eingabe ungültig ist.

     Beispiele:

          (%i1) quad_qawc (2^(-5)*((x-1)^2+4^(-5))^(-1), x, 2, 0, 5,
                           'epsrel=1d-7);
          (%o1)    [- 3.130120337415925, 1.306830140249558E-8, 495, 0]
          (%i2) integrate (2^(-alpha)*(((x-1)^2 + 4^(-alpha))*(x-2))^(-1),
                           x, 0, 5);
          Principal Value
                                 alpha
                  alpha       9 4                 9
                 4      log(------------- + -------------)
                                alpha           alpha
                            64 4      + 4   64 4      + 4
          (%o2) (-----------------------------------------
                                  alpha
                               2 4      + 2

                 3 alpha                       3 alpha
                 -------                       -------
                    2            alpha/2          2          alpha/2
              2 4        atan(4 4       )   2 4        atan(4       )   alpha
            - --------------------------- - -------------------------)/2
                        alpha                        alpha
                     2 4      + 2                 2 4      + 2
          (%i3) ev (%, alpha=5, numer);
          (%o3)                    - 3.130120337415917

 -- Funktion: quad_qawf (<f(x)>, <x>, <a>, <omega>, <trig>, [<epsabs>,
          <limit>, <maxp1>, <limlst>])
 -- Funktion: quad_qawf (<f>, <x>, <a>, <omega>, <trig>, [<epsabs>,
          <limit>, <maxp1>, <limlst>])
     Die Funktion `quad_qawf' berechnet die Sinus- oder
     Kosinus-Fouriertransformation mit der Gewichtsfunktion w über ein
     halb-unendliches Intervall.

                inf
               /
               [
               I    f(x) w(x) dx
               ]
               /
                a

     Zur Berechnung des Integrals wird die global adaptive Routine
     `quad_qawo'  sukzessive auf endliche Teilintervalle angewendet.
     Zur Konvergenzbeschleunigung der resultierenden alternierenden
     Reihe wird der Epsilon-Algorithmus (Wynn, 1956) verwendet.

     Die Gewichtsfunktion w wird mit dem Schlüsselwort <trig>
     ausgewählt:

    `cos'
          w(x) = cos (omega x)

    `sin'
          w(x) = sin (omega x)

     Der Integrand kann eine Maxima-Funktion, eine Lisp-Funktion, ein
     Operator, ein Maxima-Lambda-Ausdruck oder ein allgemeiner
     Maxima-Ausdruck sein.

     Die Schlüsselwortargumente sind optional und können in beliebiger
     Reihenfolge angegeben werden.  Sie haben die Form `key=val'.  Die
     Schlüsselwortargumente sind:

    <epsabs>
          Gewünschter absoluter Fehler der Näherung.  Der Standardwert
          ist `1.0e-10'.

    <limit>
          `(<limit> - <limlst>)/2' ist die maximale Zahl an
          Teilintervallen des adaptiven Algorithmus.  Der Standardwert
          ist `200'.

    <maxp1>
          Die maximale Anzahl an Chebyshev-Gewichten.  Der Wert muss
          größer als 0 sein.  Der Standardwert ist `100'.

    <limlst>
          Obere Grenze für die Anzahl an Zyklen.  Der Wert muss größer
          oder gleich 3 sein.  Der Standardwert ist 10.

     `quad_qawf' gibt eine Liste mit vier Elementen zurück:

        * eine numerische Näherung des Integrals,

        * geschätzer absoluter Fehler der Näherung,

        * Anzahl der Auswertungen des Integranden,

        * ein Fehlercode.

     Der Fehlercode kann die folgenden Werte annehmen:

        * `0', wenn kein Fehler aufgetreten ist,

        * `1', wenn zu viele Teilintervalle notwendig wurden,

        * `2', wenn übemäßiger Rundungsfehler aufgetreten sind,

        * `3', wenn ein extrem schlechtes Verhalten des Integranden
          vorliegt,

        * `6', wenn die Eingabe ungültig ist.

     Beispiele:

          (%i1) quad_qawf (exp(-x^2), x, 0, 1, 'cos, 'epsabs=1d-9);
          (%o1)   [.6901942235215714, 2.84846300257552E-11, 215, 0]
          (%i2) integrate (exp(-x^2)*cos(x), x, 0, inf);
                                    - 1/4
                                  %e      sqrt(%pi)
          (%o2)                   -----------------
                                          2
          (%i3) ev (%, numer);
          (%o3)                   .6901942235215714

 -- Funktion: quad_qawo (<f(x)>, <x>, <a>, <b>, <omega>, <trig>,
          [<epsrel>, <epsabs>, <limit>, <maxp1>, <limlst>])
 -- Funktion: quad_qawo (<f>, <x>, <a>, <b>, <omega>, <trig>,
          [<epsrel>, <epsabs>, <limit>, <maxp1>, <limlst>])
     Die Funktion `quad_qawo' berechnet das folgende Integral mit den
     trigonometrischen Gewichtsfunktionen cos(omega x) f(x) oder
     sin(omega x) f(x) über ein endliches Intervall, wobei omega eine
     Konstante ist.

                b
               /
               [
               I  f(x) w(x) dx
               ]
               /
                a

     Der Algorithmus basiert auf eine modifizierte
     Clenshaw-Curtis-Technik.  `quad_qawo' wendet eine adaptive
     Unterteilung des Integrationsintervalls mit Extrapolation an, die
     vergleichbar mit dem Algorithmus von `quad_qags'  ist.  Zusätzlich
     wird versucht, die Konvergenz der Integralapproximation mit Hilfe
     des Epsilon-Algorithmus zu beschleunigen.

     Die Gewichtsfunktion w wird mit dem Schlüsselwort <trig>
     ausgewählt:

    `cos'
          w(x) = cos (omega x)

    `sin'
          w(x) = sin (omega x)

     Der Integrand kann eine Maxima-Funktion, eine Lisp-Funktion, ein
     Operator, ein Maxima-Lambda-Ausdruck oder ein allgemeiner
     Maxima-Ausdruck sein.

     Die Schlüsselwortargumente sind optional und können in beliebiger
     Reihenfolge angegeben werden.  Sie haben die Form `key=val'.  Die
     Schlüsselwortargumente sind:

    `epsrel'
          Gewünschter relativer Fehler der Näherung.  Der Standardwert
          ist `1.0e-8'

    `epsabs'
          Gewünschter absoluter Fehler der Näherung.  Der Standardwert
          ist `0'.

    `limit'
          `<limit>/2' ist die maximale Zahl an Teilintervallen des
          adaptiven Algorithmus.  Der Standardwert ist `200'.

    `maxp1'
          Die maximale Anzahl an Chebyshev-Gewichten.  Der Wert muss
          größer als 0 sein.  Der Standardwert ist `100'.

    `limlst'
          Obere Grenze für die Anzahl an Zyklen.  Der Wert muss größer
          oder gleich 3 sein.  Der Standardwert ist 10.

     `quad_qawo' gibt eine Liste mit vier Elementen zurück:

        * eine numerische Näherung des Integrals,

        * geschätzer absoluter Fehler der Näherung,

        * Anzahl der Auswertungen des Integranden,

        * ein Fehlercode.

     Der Fehlercode kann die folgenden Werte annehmen:

        * `0', wenn kein Fehler aufgetreten ist,

        * `1', wenn zu viele Teilintervalle notwendig wurden,

        * `2', wenn übemäßiger Rundungsfehler aufgetreten sind,

        * `3', wenn ein extrem schlechtes Verhalten des Integranden
          vorliegt,

        * `6', wenn die Eingabe ungültig ist.

     Beispiele:

          (%i1) quad_qawo (x^(-1/2)*exp(-2^(-2)*x), x, 1d-8, 20*2^2, 1, cos);
          (%o1)     [1.376043389877692, 4.72710759424899E-11, 765, 0]
          (%i2) rectform (integrate (x^(-1/2)*exp(-2^(-alpha)*x) * cos(x),
                          x, 0, inf));
                             alpha/2 - 1/2            2 alpha
                  sqrt(%pi) 2              sqrt(sqrt(2        + 1) + 1)
          (%o2)   -----------------------------------------------------
                                         2 alpha
                                   sqrt(2        + 1)
          (%i3) ev (%, alpha=2, numer);
          (%o3)                     1.376043390090716

 -- Funktion: quad_qaws (<f(x)>, <x>, <a>, <b>, <alpha>, <beta>,
          <wfun>, [<epsrel>, <epsabs>, <limit>])
 -- Funktion: quad_qaws (<f>, <x>, <a>, <b>, <alpha>, <beta>, <wfun>,
          [<epsrel>, <epsabs>, <limit>])
     Die Funktion `quad_qaws' berechnet das Integral von w(x) f(x) über
     ein endliches Intervall [a, b], wobei w eine Funktion der Form (x
     - a)^alpha (b - x)^beta v(x) ist und v(x) ist 1 oder log(x - a)
     oder log(b - x) oder log(x - a) log(b - x), und alpha > -1 und
     beta > -1.

                b
               /
               [
               I  f(x) w(x) dx
               ]
               /
                a

     `quad_qaws' ist speziell für die effiziente Berechnung von
     Integralen über endliche Intervalle mit algebraischen oder
     algebraisch-logarithmischen Endpunktsingularität konzipiert.  Eine
     globale adaptive Strategie mit Unterteilung des
     Integrationsintervalls wird angewendet.  Auf Teilintervalle, die
     keinen Endpunkt des Integrationsintervalls enthalten, kommt ein
     Gauß-Kronrod-Formelpaar und auf Randintervallen kommen modifizierte
     Clenshaw-Curtis-Formeln zur Anwendung.

     Die Gewichtsfunktion wird mit dem Schlüsselwort <wfun> ausgewählt:

    `1'
          w(x) = (x - a)^alpha (b - x)^beta

    `2'
          w(x) = (x - a)^alpha (b - x)^beta log(x - a)

    `3'
          w(x) = (x - a)^alpha (b - x)^beta log(b - x)

    `4'
          w(x) = (x - a)^alpha (b - x)^beta log(x - a) log(b - x)

     Der Integrand kann eine Maxima-Funktion, eine Lisp-Funktion, ein
     Operator, ein Maxima-Lambda-Ausdruck oder ein allgemeiner
     Maxima-Ausdruck sein.

     Die Schlüsselwortargumente sind optional und können in beliebiger
     Reihenfolge angegeben werden.  Sie haben die Form `key=val'.  Die
     Schlüsselwortargumente sind:

    <epsrel>
          Gewünschter relativer Fehler der Näherung.  Der Standardwert
          ist `1.0e-8'

    <epsabs>
          Gewünschter absoluter Fehler der Näherung.  Der Standardwert
          ist `0'.

    <limit>
          Maximale Anzahl der Teilintervalle des adaptiven Algorithmus.
          Der Standardwert ist `200'.

     `quad_qaws' gibt eine Liste mit vier Elementen zurück:

        * eine numerische Näherung des Integrals,

        * geschätzer absoluter Fehler der Näherung,

        * Anzahl der Auswertungen des Integranden,

        * ein Fehlercode.

     Der Fehlercode kann die folgenden Werte annehmen:

        * `0', wenn kein Fehler aufgetreten ist,

        * `1', wenn zu viele Teilintervalle notwendig wurden,

        * `2', wenn übemäßiger Rundungsfehler aufgetreten sind,

        * `3', wenn ein extrem schlechtes Verhalten des Integranden
          vorliegt,

        * `6', wenn die Eingabe ungültig ist.

     Beispiele:

          (%i1) quad_qaws (1/(x+1+2^(-4)), x, -1, 1, -0.5, -0.5, 1,
                           'epsabs=1d-9);
          (%o1)     [8.750097361672832, 1.24321522715422E-10, 170, 0]
          (%i2) integrate ((1-x*x)^(-1/2)/(x+1+2^(-alpha)), x, -1, 1);
                 alpha
          Is  4 2      - 1  positive, negative, or zero?

          pos;
                                    alpha         alpha
                             2 %pi 2      sqrt(2 2      + 1)
          (%o2)              -------------------------------
                                         alpha
                                      4 2      + 2
          (%i3) ev (%, alpha=4, numer);
          (%o3)                     8.750097361672829

 -- Function: quad_qagp (<f(x)>, <x>, <a>, <b>, <points>, [<epsrel>,
          <epsabs>, <limit>])
 -- Function: quad_qagp (<f>, <x>, <a>, <b>, <points>, [<epsrel>,
          <epsabs>, <limit>])
     Integration of a general function over a finite interval.
     `quad_qagp' implements globally adaptive interval subdivision with
     extrapolation (de Doncker, 1978) by the Epsilon algorithm (Wynn,
     1956).

     `quad_qagp' computes the integral

     integrate (f(x), x, a, b)

     The function to be integrated is <f(x)>, with dependent variable
     <x>, and the function is to be integrated between the limits <a>
     and <b>.

     The integrand may be specified as the name of a Maxima or Lisp
     function or operator, a Maxima lambda expression, or a general
     Maxima expression.

     To help the integrator, the user must supply a list of points where
     the integrand is singular or discontinous.

     The keyword arguments are optional and may be specified in any
     order.  They all take the form `key=val'.  The keyword arguments
     are:

    <epsrel>
          Desired relative error of approximation.  Default is 1d-8.

    <epsabs>
          Desired absolute error of approximation.  Default is 0.

    <limit>
          Size of internal work array.  <limit> is the maximum number
          of subintervals to use.  Default is 200.

     `quad_qagp' returns a list of four elements:

        * an approximation to the integral,

        * the estimated absolute error of the approximation,

        * the number integrand evaluations,

        * an error code.

     The error code (fourth element of the return value) can have the
     values:

    `0'
          no problems were encountered;

    `1'
          too many sub-intervals were done;

    `2'
          excessive roundoff error is detected;

    `3'
          extremely bad integrand behavior occurs;

    `4'
          failed to converge

    `5'
          integral is probably divergent or slowly convergent

    `6'
          if the input is invalid.

     Examples:

          (%i1) quad_qagp(x^3*log(abs((x^2-1)*(x^2-2))),x,0,3,[1,sqrt(2)]);
          (%o1)   [52.74074838347143, 2.6247632689546663e-7, 1029, 0]
          (%i2) quad_qags(x^3*log(abs((x^2-1)*(x^2-2))), x, 0, 3);
          (%o2)   [52.74074847951494, 4.088443219529836e-7, 1869, 0]

     The integrand has singularities at 1 and sqrt(2) so we supply these
     points to `quad_qagp'.  We also note that `quad_qagp' is more
     accurate and more efficient that `quad_qags'.

 -- Function: quad_control (<parameter>, [<value>])
     Control error handling for quadpack.  The parameter should be one
     of the following symbols:

    `current_error'
          The current error number

    `control'
          Controls if messages are printed or not.  If it is set to
          zero or less, messages are suppressed.

    `max_message'
          The maximum number of times any message is to be printed.

     If <value> is not given, then the current value of the <parameter>
     is returned.  If <value> is given, the value of <parameter> is set
     to the given value.


File: maxima.info,  Node: Differentialgleichungen,  Next: Einführung in Differentialgleichungen,  Prev: Integration,  Up: Analysis

16.4 Differentialgleichungen
============================

* Menu:

* Einführung in Differentialgleichungen::
* Funktionen und Variablen für Differentialgleichungen::


File: maxima.info,  Node: Einführung in Differentialgleichungen,  Next: Funktionen und Variablen für Differentialgleichungen,  Prev: Differentialgleichungen,  Up: Differentialgleichungen

16.4.1 Einführung in Differentialgleichungen
--------------------------------------------

Dieses Kapitel beschreibt die Funktionen, die in Maxima verfügbar sind,
um analytische Lösungen für verschiedene Typen von
Differentialgleichungen der 1. und 2. Ordnung zu erhalten.  Eine
numerische Lösung kann mit den Funktionen in *note dynamics:: berechnet
werden.  Für die graphische Darstellung von Differentialgleichungen
siehe das Paket in *note plotdf::.


File: maxima.info,  Node: Funktionen und Variablen für Differentialgleichungen,  Prev: Einführung in Differentialgleichungen,  Up: Differentialgleichungen

16.4.2 Funktionen und Variablen für Differentialgleichungen
-----------------------------------------------------------

 -- Funktion: bc2 (<solution>, <xval1>, <yval1>, <xval2>, <yval2>)
     Löst das Randwertproblem einer Differentialgleichung 2. Ordnung.
     Das Argument <solution> ist eine allgemeine Lösung, wie sie von
     der Funktion `ode2'  zurückgegeben wird.  <xval1> gibt den Wert
     der unabhängigen Variablen im ersten Randpunkt an.  Der Randwert
     wird als ein Ausdruck `<x> = <x1>' angegeben.  Das Argument
     <yval1> gibt den Wert der abhängigen Variablen in diesem Punkt an.
     Der Randwert wird als `<y> = <y1>' angegeben.  Mit den Argumenten
     <xval2> und <yval2> werden die entsprechenden Werte an einem
     zweiten Randpunkt angegeben.

     Siehe die Funktion `ode2'  für Beispiele.

 -- Funktion: desolve (<eqn>, <x>)
 -- Funktion: desolve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])
     Die Funktion `desolve' löst lineare Systeme gewöhnlicher
     Differentialgleichungen mit Hilfe der Methode der
     Laplacetransformation.  Die Argumente <eqn_i> sind die
     Differentialgleichungen mit den abhängigen Variablen <x_1>, ...,
     <x_n>.  Die funktionale Abhängigkeit der Variablen <x_1>, ...,
     <x_n> zum Beispiel von einer Variablen <x> muss explizit für die
     Variablen und ihrer Ableitungen angegeben werden.  Zum Beispiel
     ist sind die folgenden zwei Gleichungen keine korrekte Definition:

          eqn_1: 'diff(f,x,2) = sin(x) + 'diff(g,x);
          eqn_2: 'diff(f,x) + x^2 - f = 2*'diff(g,x,2);

     Eine korrekte Definition der zwei Gleichungen ist

          eqn_1: 'diff(f(x),x,2) = sin(x) + 'diff(g(x),x);
          eqn_2: 'diff(f(x),x) + x^2 - f(x) = 2*'diff(g(x),x,2);

     Die Funktion `desolve' wird dann folgendermaßen aufgerufen

          desolve([eqn_1, eqn_2], [f(x),g(x)]);

     Sind Anfangswerte für `x=0' bekannt, können diese mit der Funktion
     `atvalue'  vor dem Aufruf der Funktion `desolve' angegeben werden.

          (%i1) 'diff(f(x),x)='diff(g(x),x)+sin(x);
                           d           d
          (%o1)            -- (f(x)) = -- (g(x)) + sin(x)
                           dx          dx
          (%i2) 'diff(g(x),x,2)='diff(f(x),x)-cos(x);
                            2
                           d            d
          (%o2)            --- (g(x)) = -- (f(x)) - cos(x)
                             2          dx
                           dx
          (%i3) atvalue('diff(g(x),x),x=0,a);
          (%o3)                           a
          (%i4) atvalue(f(x),x=0,1);
          (%o4)                           1
          (%i5) desolve([%o1,%o2],[f(x),g(x)]);
                            x
          (%o5) [f(x) = a %e  - a + 1, g(x) =
                                                          x
                                             cos(x) + a %e  - a + g(0) - 1]
          (%i6) [%o1,%o2],%o5,diff;
                       x       x      x                x
          (%o6)   [a %e  = a %e , a %e  - cos(x) = a %e  - cos(x)]

     Kann `desolve' keine Lösung finden, ist die Rückgabe `false'.

 -- Funktion: ic1 (<solution>, <xval>, <yval>)
     Löst das Anfangswertproblem für eine Differentialgleichung 1.
     Ordnung.  Das Argument <solution> ist eine allgemeine Lösung der
     Differentialgleichung, wie sie von der Funktion `ode2'
     zurückgegeben wird.  Mit dem Argument <xval> wird der Anfangswert
     der unabhängigen Variablen in der Form `<x> = <x0>' angegeben.
     Mit dem Argument <yval> wird der Anfangswert der unabhängigen
     Variablen in der Form `<y> = <y0>' angegeben.

     Siehe die Funktion `ode2'  für ein Beispiel.

 -- Funktion: ic2 (<solution>, <xval>, <yval>, <dval>)
     Löst das Anfangswertproblem für eine Differentialgleichung 2.
     Ordnung.  Das Argument <solution> ist eine allgemeine Lösung der
     Differentialgleichung, wie sie von der Funktion `ode2'
     zurückgegeben wird.  Mit dem Argument <xval> wird der Anfangswert
     der unabhängigen Variablen in der Form `<x> = <x0>' angegeben.
     Mit dem Argument <yval> wird der Anfangswert der abhängigen
     Variablen in der Form `<y> = <y0>' angegeben.  Mit dem Argument
     <dval> wird der Anfangswert der ersten Ableitung der abhängigen
     Variablen nach der unabhängigen Variablen in der Form
     `diff(<y>,<x>) = <dy0>' angegeben.  Dem Symbol `diff' muss kein
     `Quote-Operator'  `'' vorangestellt werden.

     Siehe auch `ode2'  für ein Beispiel.

 -- Funktion: ode2 (<eqn>, <dvar>, <ivar>)
     Die Funktion `ode2' löst eine gewöhnliche Differentialgleichung der
     ersten oder zweiten Ordnung.  Die Funktion hat drei Argumente: die
     Differentialgleichung <eqn>, die abhängige Variable `dvar' und die
     unabhängige Variable `ivar'.  Ist die Funktion `ode2' erfolgreich
     wird eine explizite oder implizite Lösung für die abhängige
     Variable zurückgegeben.  Im Fall einer Differentialgleichung 1.
     Ordnung wird die Integrationskonstante mit `%c' bezeichnet.  Für
     eine Differentialgleichung 2. Ordnung werden die
     Integrationskonstanten mit `%k1' und `%k2' bezeichnet.  Die
     Abhängigkeit der abhängigen Variable von der unabhängigen
     Variablen muss nicht explizit, wie im Fall von `desolve'
     angegeben werden.

     Kann `ode2' keine Lösung finden, ist die Rückgabe `false'.
     Gegebenenfalls wird eine Fehlermeldung ausgegeben.  Folgende
     Methoden werden für das Lösen einer Differentialgleichung 1.
     Ordnung nacheinander angewendet: linear, separierbar, exakt - wenn
     notwendig unter Zuhilfenahme eines Integrationsfaktors, homogen,
     bernoullische Differentialgleichung und eine Methode für
     verallgemeinerte homogene Gleichungen.  Für eine
     Differentialgleichung 2. Ordnung kommen die folgenden Methoden zur
     Anwendung: konstante Koeffizienten, exakt, linear homogen mit
     nicht-konstanten Koeffizienten, die zu konstanten Koeffizienten
     transformiert werden können, eulersche Differentialgleichung,
     Variation der Parameter, Reduktion auf eine Differentialgleichung
     1. Ordnung, wenn die Differentialgleichung entweder frei von der
     unabhängigen oder der abhängigen Variablen ist.

     Im Laufe des Lösungsverfahrens werden zur Information des Nutzers
     globale Variablen gesetzt: `method' bezeichnet die Methode, die
     von `ode2' zum Auffinden der Lösung verwendet wurde.  `intfactor'
     bezeichnet einen verwendeten Integrationsfaktor.  `odeindex'
     bezeichnet den Index der bernoullischen Gleichung oder der
     verallgemeinerte Methode für eine homogene Differentialgleichung.
     `yp' bezeichnet eine partikuläre Lösung, wenn die Variation der
     Parameter angewendet wird.

     Für das Lösen von Anfangswertproblemen einer Differentialgleichung
     1. oder 2. Ordnung können die Funktionen `ic1'  und `ic2'
     verwendet werden.  Ein Randwertproblem für eine
     Differentialgleichung 2. Ordnung kann mit der Funktion `bc2'
     gelöst werden.

     Beispiele:

          (%i1) x^2*'diff(y,x) + 3*y*x = sin(x)/x;
                                2 dy           sin(x)
          (%o1)                x  -- + 3 x y = ------
                                  dx             x
          (%i2) ode2(%,y,x);
                                       %c - cos(x)
          (%o2)                    y = -----------
                                            3
                                           x
          (%i3) ic1(%o2,x=%pi,y=0);
                                        cos(x) + 1
          (%o3)                   y = - ----------
                                             3
                                            x
          (%i4) 'diff(y,x,2) + y*'diff(y,x)^3 = 0;
                                   2
                                  d y      dy 3
          (%o4)                   --- + y (--)  = 0
                                    2      dx
                                  dx
          (%i5) ode2(%,y,x);
                                3
                               y  + 6 %k1 y
          (%o5)                ------------ = x + %k2
                                    6
          (%i6) ratsimp(ic2(%o5,x=0,y=0,'diff(y,x)=2));
                                       3
                                    2 y  - 3 y
          (%o6)                   - ---------- = x
                                        6
          (%i7) bc2(%o5,x=0,y=1,x=1,y=3);
                                   3
                                  y  - 10 y       3
          (%o7)                   --------- = x - -
                                      6           2


File: maxima.info,  Node: Polynome,  Next: Gleichungen,  Prev: Analysis,  Up: Top

17 Polynome
***********

* Menu:

* Einführung in Polynome::
* Funktionen und Variablen für Polynome::


File: maxima.info,  Node: Einführung in Polynome,  Next: Funktionen und Variablen für Polynome,  Prev: Polynome,  Up: Polynome

17.1 Einführung in Polynome
===========================

Polynome werden in einer allgemeinen Darstellung oder in einer
kanonischen Darstellung (CRE - Cannonical Rational Expressions)
gespeichert.  Die CRE-Darstellung ist die Standardform für Operationen
mit Polynomen und wird intern von Funktionen wie `factor'  oder
`ratsimp'  verwendet.

Ausdrücke in einer CRE-Form sind besonders für die Darstellung von
Polynomen und rationalen Funktionen geeignet.  Die CRE-Form nimmt eine
Ordnung der Variablen an.  Polynome werden rekursiv als eine Liste
definiert, die als ersten Eintrag den Namen der Variablen und als
nächste Einträge die Exponenten und Koeffizienten der Variablen
enthalten.  Der Koeffizient kann eine Zahl oder wiederum ein Polynom
sein.  Zum Beispiel hat das Polynom `3*x^2-1' die Darstellung `(X 2 3 0
-1)' und das Polynom `2*x*y+x-3' die Darstellung `(Y 1 (X 1 2) 0 (X 1 1
0 -3))', wenn `y' die Hauptvariable des Polynoms ist.  Ist <x> die
Hauptvariable des Polynoms, dann ist die Darstellung `(X 1 (Y 1 2 0 1)
0 -3)'.

Die Ordnung der Variablen ist in der Regel umgekehrt alphabetisch.  Die
Variablen müssen keine Atome sein.  Alle Ausdrücke, die nicht die
Operatoren `+', `-', `*', `/' oder `^' enthalten, werden in einer
CRE-Darstellung als "Variable" angenommen.  Zum Beispiel sind `x',
`sqrt(x)' und `sin(x+1)' die CRE-Variablen des Ausdrucks
`x+sin(x+1)+2*SQRT(x)+1'.  Wird vom Nutzer keine abweichende Ordnung der
Variablen mit der Funktion `ratvars'  definiert, nimmt Maxima eine
alphabetische Ordnung der Variablen an.

Im Allgemeinen werden rationale Funktionen in einer CRE-Form
dargestellt, die keinen gemeinsamen Faktor im Zähler und Nenner haben.
Die interne Darstellung ist ein Paar von Polynomen, die jeweils den
Zähler und den Nenner darstellen.  Diesem Paar geht eine Liste mit der
Ordnung der Variablen im Ausdruck voraus.  Ein Ausdruck in einer
CRE-Form oder der CRE-Formen enthält, wird in der Ausgabe mit dem
Symbol `/R/' gekennzeichnet.  Mit der Funktion `rat'  können allgemeine
Ausdrücke in eine CRE-Form transformiert werden.  Umgekehrt wird ein
Ausdruck in einer CRE-Form mit der Funktion `ratdisrep'  in eine
allgemeine Form transformiert.

Für die Darstellung von Taylor-Polynomen der Funktion `taylor'  wird
eine erweiterte CRE-Form verwendet.  In dieser Darstellung können die
Exponenten von Polynomen auch rationale Zahlen sein.  Weiterhin können
die Koeffizienten rationale Funktionen sein.  Die erweiterte CRE-Form
enthält auch Informationen über den Grad des Polynoms.  In der Ausgabe
wird die erweiterte CRE-Form mit dem Symbol `/T/' bezeichnet.


File: maxima.info,  Node: Funktionen und Variablen für Polynome,  Prev: Einführung in Polynome,  Up: Polynome

17.2 Funktionen und Variablen für Polynome
==========================================

 -- Optionsvariable: algebraic
     Standardwert: `false'

     Hat die Optionsvariable `algebraic' den Wert `true', wird beim
     Umwandeln von Ausdrücken in die CRE-Form und beim Rechnen mit
     Ausdrücken in einer CRE-Form der Ausdruck so vereinfacht, dass der
     Nenner frei von algebraischen Zahlen (das sind Wurzeln von ganzen
     Zahlen) ist.

     Beispiele:

     Im zweiten Beispiel wird der Ausdruck automatisch mit `sqrt(2)'
     erweitert, um den Nenner frei von der algebraischen Zahl `sqrt(2)'
     zu machen.

          (%i1) algebraic:false;
          (%o1)                         false
          (%i2) rat(x^2+x)/sqrt(2);
                                        2
                                       x  + x
          (%o2)/R/                     -------
                                       sqrt(2)
          (%i3) algebraic:true;
          (%o3)                         true
          (%i4) rat(x^2+x)/sqrt(2);
                                        2
                               sqrt(2) x  + sqrt(2) x
          (%o4)/R/             ----------------------
                                         2

 -- Optionsvariable: berlefact
     Standardwert: `true'

     Hat die Optionsvariable `berlefact' den Wert `false', dann wird der
     Kronecker-Algorithmus von der Funktion `factor'  für die
     Faktorisierung genutzt.  Ansonsten wird der Berlekamp-Algorithmus
     genutzt.  Der Standardwert ist `true'.

 -- Funktion: bezout (<p1>, <p2>, <x>)
     Die Rückgabe ist die Sylvestermatrix der zwei Polynome <p1> und
     <p2> mit der unabhängigen Variablen <x>.  Die Determinante der
     Sylvestermatrix ist die Resultante der Polynome.  Die Resultante
     kann auch sofort mit der Funktion `resultant'  berechnet werden.

     Beispiele:

          (%i1) bezout(a*x+b, c*x^2+d, x);
                                   [ b c  - a d ]
          (%o1)                    [            ]
                                   [  a     b   ]
          (%i2) determinant(%);
                                      2      2
          (%o2)                      a  d + b  c
          (%i3) resultant(a*x+b, c*x^2+d, x);
                                      2      2
          (%o3)                      a  d + b  c

 -- Funktion: bothcoef (<expr>, <x>)
     Gibt eine Liste zurück, deren erstes Element der Koeffizient der
     Variablen <x> im Ausdruck <expr> und deren zweites Element der
     verbleibende Teil des Ausdrucks <expr> ist.  Das Ergebnis ist also
     `[A,B]' und es gilt `<expr> = A * <x> + B'.

     Die Funktion `bothcoef' hat den Alias-Namen `bothcoeff'.

     Siehe auch die Funktion `coeff'.

     Beispiele:

          (%i1) bothcoeff(a*x+2, x);
          (%o1)                        [a, 2]
          (%i2) bothcoeff(x^2+a*x+2, x);
                                          2
          (%o2)                      [a, x  + 2]

     Definition einer Funktion `islinear', die die Funktion `bothcoeff'
     nutzt, um den linearen Anteil eines Ausdrucks zu ermitteln.

          (%i1) islinear (expr, x) :=
                   block ([c],
                      c: bothcoef (rat (expr, x), x),
                      is (freeof (x, c) and c[1] # 0))$
          (%i2) islinear ((r^2 - (x - r)^2)/x, x);
          (%o2)                         true

 -- Funktion: coeff (<expr>, <x>, <n>)
 -- Funktion: coeff (<expr>, <x>)
     Gibt den Koeffizienten von `<x>^<n>' des Ausdrucks <expr> zurück.
     Das Argument <expr> ist ein Polynom in der Variablen <x>.

     Das Kommando `coeff(<expr>, <x>^<n>)' ist äquivalent zu
     `coeff(<expr>, <x>, <n>)'.  Das Kommando `coeff(<expr>, <x>, 0)'
     gibt den Teil des Ausdrucks <expr> zurück, der frei von der
     Variablen <x> ist.  Wenn nicht angegeben, wird das Argument <n>
     als `1' angenommen.

     Das Argument <x> kann auch eine indizierte Variable oder ein
     Teilausdruck von <expr> sein.

     `coeff' wendet weder die Funktion `expand' noch die Funktion
     `factor' an, um einen Ausdruck zu expandieren oder zu
     faktorisieren.  Daher kann es zu anderen Ergebnissen kommen, wenn
     zuvor diese Funktionen angewendet werden.

     Wird `coeff' auf Listen, Matrizen oder Gleichungen angewendet,
     wird die Funktion auf die Elemente oder beide Seiten der Gleichung
     angewendet.

     Siehe auch die Funktion `bothcoef'.

     Beispiele:

     `coeff' gibt den Koeffizienten von `<x>^<n>' des Ausdrucks <expr>
     zurück.

          (%i1) coeff(b^3*a^3 + b^2*a^2 + b*a + 1, a^3);
                                          3
          (%o1)                          b

     `coeff(<expr>, <x>^<n>)' ist äquivalent zu `coeff(<expr>, <x>,
     <n>)'.

          (%i1) coeff(c[4]*z^4 - c[3]*z^3 - c[2]*z^2 + c[1]*z, z, 3);
          (%o1)                         - c
                                           3
          (%i2) coeff(c[4]*z^4 - c[3]*z^3 - c[2]*z^2 + c[1]*z, z^3);
          (%o2)                         - c
                                           3

     `coeff(<expr>, <x>, 0)' gibt den Teil des Ausdrucks <expr> zurück,
     der frei von der Variablen <x> ist.

          (%i1) coeff(a*u + b^2*u^2 + c^3*u^3, b, 0);
                                      3  3
          (%o1)                      c  u  + a u

     <x> kann eine einfache Variable, eine indizierte Variable oder ein
     Teilausdruck des Ausdrucks <expr> sein.

          (%i1) coeff(h^4 - 2*%pi*h^2 + 1, h, 2);
          (%o1)                        - 2 %pi
          (%i2) coeff(v[1]^4 - 2*%pi*v[1]^2 + 1, v[1], 2);
          (%o2)                        - 2 %pi
          (%i3) coeff (sin(1+x)*sin(x) + sin(1+x)^3*sin(x)^3, sin(1+x)^3);
                                          3
          (%o3)                        sin (x)
          (%i4) coeff((d - a)^2*(b + c)^3 + (a + b)^4*(c - d), a + b, 4);
          (%o4)                         c - d

     `coeff' wendet die Funktionen `expand' und `factor' nicht an.

          (%i1) coeff(c*(a + b)^3, a);
          (%o1)                           0
          (%i2) expand(c*(a + b)^3);
                           3          2        2        3
          (%o2)           b  c + 3 a b  c + 3 a  b c + a  c
          (%i3) coeff(%, a);
                                          2
          (%o3)                        3 b  c
          (%i4) coeff(b^3*c + 3*a*b^2*c + 3*a^2*b*c + a^3*c, (a + b)^3);
          (%o4)                           0
          (%i5) factor(b^3*c + 3*a*b^2*c + 3*a^2*b*c + a^3*c);
                                            3
          (%o5)                      (b + a)  c
          (%i6) coeff(%, (a + b)^3);
          (%o6)                           c

     `coeff' wird bei Listen und Matrizen auf die Elemente und bei
     Gleichungen auf die beiden Seiten angewendet.

          (%i1) coeff([4*a, -3*a, 2*a], a);
          (%o1)                      [4, - 3, 2]
          (%i2) coeff(matrix ([a*x, b*x], [-c*x, -d*x]), x);
                                    [  a    b  ]
          (%o2)                     [          ]
                                    [ - c  - d ]
          (%i3) coeff(a*u - b*v = 7*u + 3*v, u);
          (%o3)                         a = 7

     Die folgende Definition der Funktion `coeff_list' liefert eine
     Liste mit den Koeffizienten, die in einem Polynom auftreten.
     Neben der Funktion `coeff' kommt die Funktion `hipow'  zum
     Einsatz, um den höchsten Koeffizienten zu ermitteln.  Die
     Funktionen `cons'  und `reverse'

     werden verwendet, um die Koeffizienten einer Liste hinzufügen und
     um die Liste zu invertieren.

          coeff_list(a,x) :=
             block([liste:[]],
                for i:0 thru hipow(a,x) do
                (
                  liste : cons(coeff(a,x,i),liste)
                ),
                reverse(liste)
             )$

          (%i1) coeff_list(2*x^4+3*x^2+1,x);
          (%o1)                    [1, 0, 3, 0, 2]

 -- Funktion: content (<p>, <x_1>, ..., <x_n>)
     Gibt eine Liste zurück, deren erstes Element der größte gemeinsame
     Teiler der Koeffizienten des Polynoms <p> in der Variablen <x_n>
     ist und dessen zweites Element das durch den größten gemeinsamen
     Teiler dividierte Polynom ist.  Die anderen Argumente <x_1>, ...,
     <x_n-1> haben dieselbe Bedeutung wie für die Funktion `ratvars'.

     Beispiel:

          (%i1) content(2*x*y + 4*x^2*y^2, y);
                                             2
          (%o1)                   [2 x, 2 x y  + y]

 -- Funktion: denom (<expr>)
     Gibt den Nenner des Ausdrucks <expr> zurück, wenn dieser ein
     Quotient ist.  Ist der Ausdruck <expr> kein Quotient wird <expr>
     zurückgegeben.

     Die Funktion `denom' wertet das Argument aus.  Siehe auch die
     Funktion `num'.

     Beispiel:

          (%i1) denom(x^2/(x+1));
          (%o1)                         x + 1

 -- Funktion: divide (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Berechnet den Quotienten und den Rest der Division des Polynom
     <p_1> durch das Polynom <p_2> für die Variable <x_n>.  Die anderen
     Argumente <x_1>, ..., <x_n-1> haben dieselbe Bedeutung wie für die
     Funktion `ratvars'.    Das Ergebnis ist eine Liste, wobei das
     erste Element der Quotient und das zweite Element der Rest ist.

     Die Argumente der Funktion `divide' können auch ganze Zahlen sein.

     Siehe auch die Funktionen `quotient'  und `remainder',  die jeweils
     den Quotienten und den Rest der Polynomdivision zurückgegeben.

     Beispiele:

     Im zweiten Beispiel ist `y' die Hauptvariable des Ausdrucks.

          (%i1) divide (x + y, x - y, x);
          (%o1)                       [1, 2 y]
          (%i2) divide (x + y, x - y);
          (%o2)                      [- 1, 2 x]

     Ein Beispiel für zwei Polynome in zwei Variablen.

          (%i1) poly1 : sum(x^k*y^(6-k), k, 1, 5);
                            5    2  4    3  3    4  2    5
          (%o1)          x y  + x  y  + x  y  + x  y  + x  y
          (%i2) poly2 : sum(2*k*x^k*y^(3-k), k, 1, 3);
                                    2      2        3
          (%o2)                2 x y  + 4 x  y + 6 x
          (%i3) divide(poly1, poly2, x);
                        3        2      2          5       2  4
                     4 y  + 3 x y  + 9 x  y  23 x y  + 16 x  y
          (%o3)     [----------------------, ------------------]
                               54                    27
          (%i4) expand(first(%)*poly2 + second(%));
                            5    2  4    3  3    4  2    5
          (%o4)          x y  + x  y  + x  y  + x  y  + x  y

 -- Optionsvariable: dontfactor
     Standardwert: `[]'

     Der Optionsvariablen `dontfactor' kann eine Liste mit den Variablen
     zugewiesen werden, bezüglich der ein Ausdruck nicht faktorisiert
     werden soll.  Weiterhin wird nicht bezüglich von Variablen
     faktorisiert, die gemäß der kanonischen Ordnung der Variablen von
     geringerer Bedeutung sind als die Variablen in der Liste
     `dontfactor'.

     Beispiel:

     Im zweiten Fall wird das Polynom nicht bezüglich der Variablen <x>
     faktorisiert.

          (%i1) expr:expand((x+1)^3*(y+2)^2);
                 3  2      2  2        2    2      3         2
          (%o1) x  y  + 3 x  y  + 3 x y  + y  + 4 x  y + 12 x  y + 12 x y
                                                       3       2
                                            + 4 y + 4 x  + 12 x  + 12 x + 4
          (%i2) factor(expr);
                                         3        2
          (%o2)                   (x + 1)  (y + 2)
          (%i3) dontfactor:[x];
          (%o3)                          [x]
          (%i4) factor(expr);
                             3      2                   2
          (%o4)            (x  + 3 x  + 3 x + 1) (y + 2)

 -- Funktion: eliminate ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_k>])
     Wendet ein Subresultanten-Verfahren an, um die Variablen <x_1>,
     ..., <x_k> aus den Gleichungen <eqn_1>, ..., <eqn_n> zu
     eliminieren.  Die Rückgabe ist ein Gleichungssystem mit `<n> - <k>'
     Gleichungen, wobei die <k>-Variablen <x_1>, ..., <x_k> eliminiert
     sind.

     Beispiel:

          (%i1) eqn1: 2*x^2 + y*x + z;
                                                2
          (%o1)                    z + x y + 2 x
          (%i2) eqn2: 3*x + 5*y - z - 1;
          (%o2)                  - z + 5 y + 3 x - 1
          (%i3) eqn3: z^2 + x - y^2 + 5;
                                    2    2
          (%o3)                    z  - y  + x + 5
          (%i4) eliminate([eqn1, eqn2, eqn3], [y,z]);
                        2      4      3       2
          (%o4)       [x  (45 x  + 3 x  + 11 x  + 81 x + 124)]

 -- Funktion: ezgcd (<p_1>, <p_2>, <p_3>, ...)
     Gibt eine Liste zurück, deren erstes Element der größte gemeinsame
     Teiler der Polynome <p_1>, ..., <p_n> ist und deren weitere
     Elemente die durch den größten gemeinsamen Teiler dividierten
     Polynome sind.  Der größte gemeinsame Teiler wird immer mit dem
     `ezgcd'-Algorithmus bestimmt.

     Siehe auch die Funktionen `gcd',  `gcdex'  `gcdivide'  und
     `poly_gcd'.

     Beispiel:

     Die drei Polynome haben den größten gemeinsamen Teiler `2*x-3'.
     Der größte gemeinsame Teiler wird zuerst mit der Funktion `gcd'
     berechnet.  Dann wird das Ergebnis der Funktion `ezgcd' gezeigt.

          (%i1) p1 : 6*x^3-17*x^2+14*x-3;
                                  3       2
          (%o1)                6 x  - 17 x  + 14 x - 3
          (%i2) p2 : 4*x^4-14*x^3+12*x^2+2*x-3;
                              4       3       2
          (%o2)            4 x  - 14 x  + 12 x  + 2 x - 3
          (%i3) p3 : -8*x^3+14*x^2-x-3;
                                    3       2
          (%o3)                - 8 x  + 14 x  - x - 3

          (%i4) gcd(p1, gcd(p2, p3));
          (%o4)                        2 x - 3

          (%i5) ezgcd(p1, p2, p3);
                             2               3      2           2
          (%o5) [2 x - 3, 3 x  - 4 x + 1, 2 x  - 4 x  + 1, - 4 x  + x + 1]

 -- Optionsvariable: facexpand
     Standardwert: `true'

     Die Optionsvariable `facexpand' kontrolliert, ob die irreduziblen
     Faktoren der Faktorisierung mit `factor'  in einer expandierten
     oder in einer rekursiven (CRE-Form) vorliegen.  Der Standard ist,
     dass die Faktoren expandiert werden.

 -- Funktion: factor (<expr>)
 -- Funktion: factor (<expr>, <p>)
     Faktorisiert den Ausdruck <expr>, der eine beliebige Zahl an
     Variablen oder Funktionen enthalten kann, in irreduzible Faktoren
     über die ganzen Zahlen.  `factor(<expr>, <p>' faktorisiert <expr>
     über den Körper der rationalen Zahlen, der um die Nullstellen des
     minimalen Polynoms <p> erweitert ist.

     `factor' ruft die Funktion `ifactors'  auf, um ganze Zahlen zu
     faktorisieren.

     Hat die Optionsvariable `factorflag'  den Wert `false', wird die
     Faktorisierung von ganzen Zahlen unterdrückt, die im Nenner einer
     rationalen Funktion auftreten.

     Der Optionsvariablen `dontfactor'  kann eine Liste mit den
     Variablen zugewiesen werden, bezüglich der ein Ausdruck nicht
     faktorisiert werden soll.  Weiterhin wird nicht bezüglich von
     Variablen faktorisiert, die gemäß der kanonischen Ordnung der
     Variablen von geringerer Bedeutung sind als die Variablen in der
     Liste `dontfactor'.

     Hat die Optionsvariable `savefactors'  den Wert `true', versuchen
     einige Funktionen bei der Vereinfachung eine bereits vorhandene
     Faktorisierung zu erhalten, um weitere Vereinfachungen zu
     beschleunigen.

     Hat die Optionsvariable `berlefact'  den Wert `false', dann wird
     der Kronecker-Algorithmus für die Faktorisierung genutzt.
     Ansonsten wird der Berlekamp-Algorithmus genutzt.  Der
     Standardwert ist `true'.

     Hat die Optionsvariable `intfaclim'  den Wert `true', gibt Maxima
     die Faktorisierung von ganzen Zahlen auf, wenn keine
     Faktorisierung durch Anwendung der Methode der Probedivision und
     der Pollard-Rho-Methode gefunden werden konnten.  Hat `intfaclim'
     den Wert `false', versucht Maxima eine ganze Zahl vollständig zu
     faktorisieren.  Der Wert der Optionsvariablen `intfaclim' wird von
     der Funktion `factor' beachtet.  Mit dem Setzen von `intfaclim'
     kann der Nutzer verhindern, dass Maxima beim Versuch sehr große
     ganze Zahlen zu faktorisieren, unnötig viel Zeit verbraucht.

     Beispiele:

          (%i1) factor (2^63 - 1);
                              2
          (%o1)              7  73 127 337 92737 649657
          (%i2) factor (-8*y - 4*x + z^2*(2*y + x));
          (%o2)               (2 y + x) (z - 2) (z + 2)
          (%i3) -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
                          2  2        2    2    2
          (%o3)          x  y  + 2 x y  + y  - x  - 2 x - 1
          (%i4) block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
                                 2
                               (x  + 2 x + 1) (y - 1)
          (%o4)                ----------------------
                                     36 (y + 1)
          (%i5) factor (1 + %e^(3*x));
                                x         2 x     x
          (%o5)              (%e  + 1) (%e    - %e  + 1)
          (%i6) factor (1 + x^4, a^2 - 2);
                              2              2
          (%o6)             (x  - a x + 1) (x  + a x + 1)
          (%i7) factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
                                 2
          (%o7)              - (y  + x) (z - x) (z + x)
          (%i8) (2 + x)/(3 + x)/(b + x)/(c + x)^2;
                                       x + 2
          (%o8)               ------------------------
                                                     2
                              (x + 3) (x + b) (x + c)
          (%i9) ratsimp (%);
                          4                  3
          (%o9) (x + 2)/(x  + (2 c + b + 3) x

               2                       2             2                   2
           + (c  + (2 b + 6) c + 3 b) x  + ((b + 3) c  + 6 b c) x + 3 b c )
          (%i10) partfrac (%, x);
                     2                   4                3
          (%o10) - (c  - 4 c - b + 6)/((c  + (- 2 b - 6) c

               2              2         2                2
           + (b  + 12 b + 9) c  + (- 6 b  - 18 b) c + 9 b ) (x + c))

                           c - 2
           - ---------------------------------
               2                             2
             (c  + (- b - 3) c + 3 b) (x + c)

                                   b - 2
           + -------------------------------------------------
                       2             2       3      2
             ((b - 3) c  + (6 b - 2 b ) c + b  - 3 b ) (x + b)

                                   1
           - ----------------------------------------------
                       2
             ((b - 3) c  + (18 - 6 b) c + 9 b - 27) (x + 3)
          (%i11) map ('factor, %);
                        2
                       c  - 4 c - b + 6                 c - 2
          (%o11) - ------------------------- - ------------------------
                          2        2                                  2
                   (c - 3)  (c - b)  (x + c)   (c - 3) (c - b) (x + c)

                                 b - 2                        1
                      + ------------------------ - ------------------------
                                       2                          2
                        (b - 3) (c - b)  (x + b)   (b - 3) (c - 3)  (x + 3)
          (%i12) ratsimp ((x^5 - 1)/(x - 1));
                                 4    3    2
          (%o12)                x  + x  + x  + x + 1
          (%i13) subst (a, x, %);
                                 4    3    2
          (%o13)                a  + a  + a  + a + 1
          (%i14) factor (%th(2), %);
                                 2        3        3    2
          (%o14)   (x - a) (x - a ) (x - a ) (x + a  + a  + a + 1)
          (%i15) factor (1 + x^12);
                                 4        8    4
          (%o15)               (x  + 1) (x  - x  + 1)
          (%i16) factor (1 + x^99);
                           2            6    3
          (%o16) (x + 1) (x  - x + 1) (x  - x  + 1)

             10    9    8    7    6    5    4    3    2
           (x   - x  + x  - x  + x  - x  + x  - x  + x  - x + 1)

             20    19    17    16    14    13    11    10    9    7    6
           (x   + x   - x   - x   + x   + x   - x   - x   - x  + x  + x

              4    3            60    57    51    48    42    39    33
           - x  - x  + x + 1) (x   + x   - x   - x   + x   + x   - x

              30    27    21    18    12    9    3
           - x   - x   + x   + x   - x   - x  + x  + 1)

     Das Polynom `x^4+1' lässt sich nicht über den Körper der ganzen
     Zahlen faktorisieren.  Wird der Körper um das minimale Polynom
     `a^2+1' erweitert, ist die Faktorisierung möglich.  Die
     Nullstellen des minimalen Polynoms sind die imaginäre Einheit `%i'
     und `-%i'.  Das Ergebnis entspricht der Faktorisierung mit der
     Funktion `gfactor'.

          (%i1) factor(x^4+1);
                                        4
          (%o1)                        x  + 1
          (%i2) factor(x^4+1, a^2+1);
                                    2        2
          (%o2)                   (x  - a) (x  + a)
          (%i3) gfactor(x^4+1);
                                   2         2
          (%o3)                  (x  - %i) (x  + %i)

 -- Optionsvariable: factorflag
     Standardwert: `false'

     Hat die Optionsvariable `factorflag' den Wert `false', wird die
     Faktorisierung von ganzen Zahlen unterdrückt, die im Nenner einer
     rationalen Funktion auftreten.

     Beispiel:

          (%i1) factorflag:false;
          (%o1)                         false
          (%i2) factor(1/6*(x^2+2*x+1));
                                             2
                                      (x + 1)
          (%o2)                       --------
                                         6
          (%i3) factorflag:true;
          (%o3)                         true
          (%i4) factor(1/6*(x^2+2*x+1));
                                             2
                                      (x + 1)
          (%o4)                       --------
                                        2 3

 -- Funktion: factorout (<expr>, <x_1>, <x_2>, ...)
     Gruppiert eine Summe <expr> in eine Summe mit Termen der Form
     `f(<x_1>, <x_2>, ...) * g', wobei `g' ein gemeinsamer Faktor des
     Polynoms `f' ist.

     Beispiele:

     Das Polynom wird zuerst nach der Variablen <x>, dann nach <y> und
     zuletzt nach beiden Variablen faktorisiert.

          (%i1) factorout(2*a*x^2+a*x+a+a*y, x);
                                           2
          (%o1)                a y + a (2 x  + x + 1)
          (%i2) factorout(2*a*x^2+a*x+a+a*y, y);
                                               2
          (%o2)               a (y + 1) + 2 a x  + a x
          (%i3) factorout(2*a*x^2+a*x+a+a*y, y, x);
                                          2
          (%o3)                 a (y + 2 x  + x + 1)

 -- Funktion: factorsum (<expr>)
     Versucht Terme in <expr> so zu gruppieren, dass die Teilsummen
     faktorisierbar sind.  `factorsum' kann zum Beispiel das expandierte
     Polynom `expand ((x + y)^2 + (z + w)^2)' wieder herstellen, nicht
     jedoch das expandierte Polynom `expand ((x + 1)^2 + (x + y)^2)',
     da die Terme gemeinsame Variablen enthalten.

     Beispiele:

          (%i1) expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
                     2      2                            2      2
          (%o1) a x z  + a z  + 2 a w x z + 2 a w z + a w  x + v  x

                                               2        2    2            2
                                  + 2 u v x + u  x + a w  + v  + 2 u v + u
          (%i2) factorsum(%);
                                             2          2
          (%o2)            (x + 1) (a (z + w)  + (v + u) )

 -- Funktion: fasttimes (<p_1>, <p_2>)
     Führt eine schnelle Multiplikation der Polynome <p_1> und <p_2> aus
     und gibt das Ergebnis zurück.  Der Algorithmus ist von Vorteil,
     wenn die Polynome mehrere Variablen haben und die Koeffizienten
     dicht besetzt sind.  Sind `n_1' und `n_2' jeweils der Grad der
     Polynome <p_1> und <p_2>, dann benötigt die schnelle Multiplikation
     `max(n_1, n_2)^1.585' Multiplikationen.

 -- Funktion: fullratsimp (<expr>)
 -- Funktion: fullratsimp (<expr>, <x_1>, ..., <x_n>)
     Die Funktion `fullratsimp' wendet die Funktion `ratsimp'  auf das
     Argument <expr> solange wiederholt an, bis sich das Ergebnis nicht
     mehr ändert.  Nach jeder Anwendung von `ratsimp' wird der Ausdruck
     zusätzlich vereinfacht.

     Sind nicht-rationale Ausdrücke in einem Ausdruck enthalten, kann
     der Ausdruck möglicherweise mit einem Aufruf von `ratsimp' nicht
     vollständig vereinfacht werden.  Dann kann der mehrfache Aufruf
     von `ratsimp' zu einem besser vereinfachten Resultat führen.  Die
     Funktion `fullratsimp' ist für solche Falle gedacht.

     Die weiteren Argumente <x_1>, ..., <x_n> entsprechen denen der
     Funktionen `ratsimp' und `rat'.

     Beispiele:

          (%i1) expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
                                 a/2     2   a/2     2
                               (x    - 1)  (x    + 1)
          (%o1)                -----------------------
                                        a
                                       x  - 1
          (%i2) ratsimp (expr);
                                    2 a      a
                                   x    - 2 x  + 1
          (%o2)                    ---------------
                                        a
                                       x  - 1
          (%i3) fullratsimp (expr);
                                        a
          (%o3)                        x  - 1
          (%i4) rat (expr);
                                 a/2 4       a/2 2
                               (x   )  - 2 (x   )  + 1
          (%o4)/R/             -----------------------
                                        a
                                       x  - 1

 -- Funktion: fullratsubst (<a>, <b>, <c>)
     Entspricht der Funktion `ratsubst'  mit dem Unterschied, dass die
     Funktion solange rekursiv ausgeführt wird, bis sich das Ergebnis
     nicht mehr ändert.  Diese Funktion kann nützlich sein, wenn der
     Ausdruck, der eingesetzt wird, und der zu ersetzende Ausdruck
     mehrere Variablen gemeinsam haben.

     `fullratsubst' akzeptiert auch Argumente im Format der Funktion
     `lratsubst'.    Das erste Argument kann also auch eine einzelne
     oder eine Liste von Gleichungen sein.  Das zweite Argument ist in
     diesem Fall der Ausdruck in dem die Ersetzungen durchgeführt
     werden.

     Mit dem Kommando `load(lrats)' werden die Funktionen `fullratsubst'
     und `lratsubst' geladen.

     Beispiele:

          (%i1) load ("lrats")$

     `subst'  kann mehrfache Substitutionen ausführen.  Die Funktion
     `lratsubst' funktioniert analog zu der Funktion `subst'.

          (%i2) subst ([a = b, c = d], a + c);
          (%o2)                         d + b
          (%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
          (%o3)                (d + a c) e + a d + b c

     Ist nur eine Substitution auszuführen, kann diese als eine
     einzelne Gleichung angegeben werden.

          (%i4) lratsubst (a^2 = b, a^3);
          (%o4)                          a b

     `fullratsubst' ist äquivalent zur Funktion `ratsubst' mit dem
     Unterschied, dass die Funktion solange rekursiv angewendet wird,
     bis sich das Ergebnis nicht mehr ändert.

          (%i5) ratsubst (b*a, a^2, a^3);
                                         2
          (%o5)                         a  b
          (%i6) fullratsubst (b*a, a^2, a^3);
                                           2
          (%o6)                         a b

     `fullratsubst' akzeptiert auch eine Liste mit Gleichungen oder eine
     Gleichung als erstes Argument.

          (%i7) fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
          (%o7)                           b
          (%i8) fullratsubst (a^2 = b*a, a^3);
                                           2
          (%o8)                         a b

     `fullratsubst' kann zu einer unendlichen Rekursion führen.

          (%i9) errcatch (fullratsubst (b*a^2, a^2, a^3));

          *** - Lisp stack overflow. RESET

 -- Funktion: gcd (<p_1>, <p_2>, <x_1>, ...)
 -- Optionsvariable: gcd
     Gibt den größten gemeinsamen Teiler der Polynome <p_1> und <p_2>
     zurück.  Die Argumente <x_1>, ... sind optional und haben dieselbe
     Bedeutung wie für die Funktion `ratvars'.    Die Optionsvariable
     `gcd' kontrolliert, welcher Algorithmus verwendet wird und kann die
     folgenden Werte annehmen:

    `ez'
          ezgcd-Alogrithmus

    `subres'
          Subresultanten-Algorithmus

    `red'
          Reduzierter modularer Algorithmus

    `spmod'
          Modularer Algorithmus

    `false'
          kein Algorithmus, die Rückgabe ist immer 1

     Siehe auch die `ezgcd',  `gcdex',  `gcdivide',  und `poly_gcd'.

     Beispiele:

          (%i1) p1:6*x^3+19*x^2+19*x+6;
                                  3       2
          (%o1)                6 x  + 19 x  + 19 x + 6
          (%i2) p2:6*x^5+13*x^4+12*x^3+13*x^2+6*x;
                            5       4       3       2
          (%o2)          6 x  + 13 x  + 12 x  + 13 x  + 6 x
          (%i3) gcd(p1, p2);
                                      2
          (%o3)                    6 x  + 13 x + 6
          (%i4) p1/gcd(p1, p2), ratsimp;
          (%o4)                         x + 1
          (%i5) p2/gcd(p1, p2), ratsimp;
                                        3
          (%o5)                        x  + x

     Die Funktion `ezgcd'  gibt als Ergebnis eine Liste zurück, die als
     erstes Element den größten gemeinsamen Teiler und als weitere
     Elemente die durch den größten gemeinsamen Teiler dividierten
     Polynome enthält.

          (%i6) ezgcd(p1, p2);
                              2                     3
          (%o6)           [6 x  + 13 x + 6, x + 1, x  + x]

 -- Funktion: gcdex (<p_1>, <p_2>)
 -- Funktion: gcdex (<p_1>, <p_2>, <x>)
     Wendet den erweiterten Euklidischen Algorithmus für die beiden
     Polynome <p_1> und <p_2> an und gibt eine Liste `[s, t, u]' mit den
     Parametern <u>, <s> und <t> als Ergebnis zurück.  Der Parameter
     <u> ist der größte gemeinsame Teiler der Polynome.  Die Parameter
     <s> und <t> sind die Bezoutkoeffizienten, so dass gilt `u = s *
     p_1 + t * p_2'.

     Die Rückgabe der Funktion `gcdex' ist in der CRE-Form.

     Siehe auch die Funktionen `ezgcd',  `gcd'  und `gcdivide'.

     Die Argumente <f> und <g> können ganze Zahlen sein.  In diesem
     Falle wird die Funktion `igcdex'  von der Funktion `gcdex'
     aufgerufen.

     Siehe auch die Funktionen `ezgcd',  `gcd',

     `gcdivide'  und `poly_gcd'.

     Beispiel:

          (%i1) gcdex (x^2 + 1, x^3 + 4);
                                 2
                                x  + 4 x - 1  x + 4
          (%o1)/R/           [- ------------, -----, 1]
                                     17        17
          (%i2) % . [x^2 + 1, x^3 + 4, -1];
          (%o2)/R/                        0

     Im folgenden Beispiel ist die unabhängige Variable explizit als <x>
     angegeben.  Ohne diese Angabe ist <y> die unabhängige Variable.

          (%i1) gcdex (x*(y + 1), y^2 - 1, x);
                                         1
          (%o1)/R/                 [0, ------, 1]
                                        2
                                       y  - 1

 -- Funktion: gcfactor (<g>)
     Faktorisiert die Gaußsche Zahl <g> über die Gaußsche Zahlen.  Eine
     Gaußsche Zahl `g' ist durch `g = a + b*%i' gegeben, wobei `a' und
     `b' ganze Zahlen sind.  Die Faktoren werden so normalisiert, dass
     <a> und <b> nicht negativ sind.

     Beispiele:

          (%i1) gcfactor(5);
          (%o1)               - %i (1 + 2 %i) (2 + %i)
          (%i2) expand(%);
          (%o2)                           5
          (%i3) gcfactor(5+%i);
          (%o3)               - %i (1 + %i) (2 + 3 %i)
          (%i4) expand(%);
          (%o4)                        %i + 5

 -- Funktion: gfactor (<expr>)
     Faktorisiert das Polynom <expr> über die Gaußschen Zahlen.  Das ist
     die Faktorisierung über den Körper der ganzen Zahlen, der um das
     Element <%i> erweitert ist.

     Die Faktorisierung der Funktion `gfactor' ist äquivalent zu
     `factor(<expr>), <a>^2+1)' mit dem minimalen Polynom `<a>^2+1',
     das die Nullstelle `%i' hat.  Siehe auch `factor'.

     Beispiel:

          (%i1) gfactor(x^4 - 1);
          (%o1)           (x - 1) (x + 1) (x - %i) (x + %i)
          (%i2) factor(x^4 - 1, a^2+1);
          (%o2)            (x - 1) (x + 1) (x - a) (x + a)

 -- Funktion: gfactorsum (<expr>)
     Entspricht der Funktion `factorsum'  mit den Unterschied, dass
     anstatt der Funktion `factor'  die Funktion `gfactor'  angewendet
     wird, um den Ausdruck <expr> zu faktorisieren.

 -- Funktion: hipow (<expr>, <x>)
     Gibt den größten Exponenten des Arguments <x> zurück, der im
     Ausdruck <expr> auftritt.  Treten symbolische Exponenten auf, wird
     ein Ausdruck mit `max' zurückgegeben.  Ist das Argument <x> nicht
     im Ausdruck vorhanden, ist die Rückgabe `0'.

     Die Funktion `hipow' betrachtet keine äquivalenten Ausdrücke.
     Daher können die Ausdrücke `expand(<expr>)' und <expr> ein
     verschiedenes Ergebnis haben.

     Siehe auch die Funktionen `lopow'  und `coeff'.

     Beispiele:

          (%i1) hipow (y^3 * x^2 + x * y^4, x);
          (%o1)                           2
          (%i2) hipow ((x + y)^5, x);
          (%o2)                           1
          (%i3) hipow (expand ((x + y)^5), x);
          (%o3)                           5
          (%i4) hipow ((x + y)^5, x + y);
          (%o4)                           5
          (%i5) hipow (expand ((x + y)^5), x + y);
          (%o5)                           0
          (%i1) hipow ((x+y)^2 + (x+y)^a, x+y);
          (%o1)                       max(2, a)

 -- Optionsvariable: intfaclim
     Standardwert: `true'

     Hat die Optionsvariable `intfaclim'  den Wert `true', gibt Maxima
     die Faktorisierung von ganzen Zahlen auf, wenn keine
     Faktorisierung durch Anwendung der Methode der Probedivision und
     der Pollard-Rho-Methode gefunden werden konnten.

     Hat `intfaclim' den Wert `false', versucht Maxima eine ganze Zahl
     vollständig zu faktorisieren.  `intfaclim' wird von den Funktionen
     `divisors',  `divsum'  und `totient'  auf den Wert `false' gesetzt.

     Der Wert der Optionsvariablen `intfaclim' wird von der Funktion
     `factor' beachtet.  Mit dem Setzen von `intfaclim' kann der Nutzer
     verhindern, dass Maxima beim Versuch sehr große ganze Zahlen zu
     faktorisieren, unnötig viel Zeit verbraucht.


 -- Optionsvariable: keepfloat
     Standardwert: `false'

     Hat die Optionsvariable `keepfloat' den Wert `true', werden
     Gleitkommazahlen nicht in rationale Zahlen umgewandelt, wenn
     Ausdrücke mit Gleitkommazahlen in eine CRE-Form umgewandelt werden.

     Die Funktion `solve'  und Funktionen, die `solve' aufrufen,
     beachten den Wert von `keepfloat' nicht.

     Beispiele:

          (%i1) rat(x/2.0);

          rat: replaced 0.5 by 1/2 = 0.5
                                          x
          (%o1)/R/                        -
                                          2
          (%i2) rat(x/2.0), keepfloat;
          (%o2)/R/                      0.5 x

     Die Funktion `solve' ignoriert den Wert der Optionsvariablen
     `keepfloat'.

          (%i3) solve(1.0-x,x), keepfloat;

          rat: replaced 1.0 by 1/1 = 1.0
          (%o3)                        [x = 1]

 -- Funktion: lopow (<expr>, <x>)
     Gibt den kleinsten Exponenten von <x> zurück, der im Ausdruck
     <expr> auftritt.  Treten symbolische Exponententen auf, wird ein
     Ausdruck mit `min' zurückgegeben.  Ist das Argument <x> nicht im
     Ausdruck enthalten, ist die Rückgabe 0.

     Die Funktion `lopow' betrachtet keine äquivalenten Ausdrücke.
     Daher können die Ausdrücke `expand(<expr>)' und <expr> ein
     verschiedenes Ergebnis haben.

     Siehe auch die Funktionen `hipow'  und `coeff'.

     Beispiele:

          (%i1) lopow ((x+y)^2 + (x+y)^a, x+y);
          (%o1)                       min(a, 2)

 -- Funktion: lratsubst (<L>, <expr>)
     Ist analog zum Kommando `subst (<L>, <expr>)' mit dem Unterschied,
     dass anstatt der Funktion `subst'  die Funktion `ratsubst'  genutzt
     wird.

     Das erste Argument der Funktion `lratsubst' ist eine Gleichung
     oder eine Liste mit Gleichungen, die dem Format der Funktion
     `subst' entsprechen.  Die Substitutionen werden in der Reihenfolge
     der Gleichungen der Liste von links nach rechts ausgeführt.

     Mit dem Kommando `lrats' werden die Funktionen `fullratsubst' und
     `lratsubst' geladen.  Siehe auch die Funktion `fullratsubst'.

     Beispiele:

          (%i1) load (lrats)$

     `subst' kann mehrfache Substitutionen ausführen.  `lratsubst' ist
     analog zu `subst'.

          (%i2) subst ([a = b, c = d], a + c);
          (%o2)                         d + b
          (%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
          (%o3)                (d + a c) e + a d + b c

     Soll nur eine Substitution ausgeführt werden, kann eine einzelne
     Gleichung als erstes Argument angegeben werden.

          (%i4) lratsubst (a^2 = b, a^3);
          (%o4)                          a b

 -- Optionsvariable: modulus
     Standardwert: `false'

     Hat die Optionsvariable `modulus' eine positive Zahl <p> als Wert,
     werden Operationen für rationale Zahlen, wie von der Funktion `rat'
     und verwandte Funktionen, modulo <p> ausgeführt.

     `<n>' mod <p> ist definiert als eine ganze Zahl, die für ungerade
     <p> die Werte `[-(<p>-1)/2, ..., 0, ..., (<p>-1)/2]' annimmt und
     für gerade <p> die Werte `[-(<p>/2 - 1), ..., 0, ...., <p>/2]', so
     dass  `<a> <p> + <k>' gleich <n> ist für eine ganze Zahl <a>.

     Liegt ein Ausdruck <expr> bereits in einer CRE-Form vor und wird
     der Wert der Optionsvariable `modulus' geändert, dann sollte der
     Ausdruck zum Beispiel mit dem Kommando `expr: rat (ratdisrep
     (expr))' zunächst in die Standardform gebracht werden, um dann
     erneut in die CRE-Form umgewandelt zu werden, um korrekte
     Ergebnisse zu erzielen.

     Typischerweise erhält die Optionsvariable `modulus' eine Primzahl
     als Wert.  Erhält `modulus' eine positive ganze Zahl als Wert, die
     nicht eine Primzahl ist, wird die Zuweisung akzeptiert, jedoch
     eine Warnung ausgegeben.  Wird Null oder eine negative Zahl
     zugewiesen signalisiert Maxima einen Fehler.

     Beispiele:

          (%i1) modulus:7;
          (%o1)                           7
          (%i2) polymod([0,1,2,3,4,5,6,7]);
          (%o2)            [0, 1, 2, 3, - 3, - 2, - 1, 0]
          (%i3) modulus:false;
          (%o3)                         false
          (%i4) poly:x^6+x^2+1;
                                      6    2
          (%o4)                      x  + x  + 1
          (%i5) factor(poly);
                                      6    2
          (%o5)                      x  + x  + 1
          (%i6) modulus:13;
          (%o6)                          13
          (%i7) factor(poly);
                                2        4      2
          (%o7)               (x  + 6) (x  - 6 x  - 2)
          (%i8) polymod(%);
                                      6    2
          (%o8)                      x  + x  + 1

 -- Funktion: num (<expr>)
     Gibt den Zähler des Ausdrucks <expr> zurück, wenn dieser ein
     Quotient ist.  Ist der Ausdruck <expr> kein Quotient wird <expr>
     zurückgegeben.

     Die Funktion `num' wertet das Argument aus.  Siehe auch die
     Funktion `denom'.

     Beispiel:

          (%i1) num(x^2/(x+1));
                                          2
          (%o1)                          x

 -- Funktion: partfrac (<expr>, <var>)
     Führt für den Ausdruck <expr> eine vollständige
     Partialbruchzerlegung aus.

          (%i1) 1/(1+x)^2 - 2/(1+x) + 2/(2+x);
                                2       2        1
          (%o1)               ----- - ----- + --------
                              x + 2   x + 1          2
                                              (x + 1)
          (%i2) ratsimp (%);
                                           x
          (%o2)                 - -------------------
                                   3      2
                                  x  + 4 x  + 5 x + 2
          (%i3) partfrac (%, x);
                                2       2        1
          (%o3)               ----- - ----- + --------
                              x + 2   x + 1          2
                                              (x + 1)

 -- Funktion: polydecomp (<p>, <x>)
     Zerlegt das Polynom <p> in der Variablen <x> in Polynome, die
     miteinander verkettet das ursprüngliche Polynom ergeben.
     `polydecomp' gibt eine Liste `[<p_1>, ..., <p_n>]' zurück, so dass
     der folgende Ausdruck gleich dem Polynom <p> ist:

          lambda ([x], p_1) (lambda ([x], p_2) (... (lambda ([x], p_n) (x))
            ...))

     Der Grad des Polynoms <p_i> ist größer als 1 für <i> kleiner als
     <n>.

     Eine solche Zerlegung ist nicht eindeutig.

     Beispiele:

          (%i1) polydecomp (x^210, x);
                                    7   5   3   2
          (%o1)                   [x , x , x , x ]
          (%i2) p : expand (subst (x^3 - x - 1, x, x^2 - a));
                          6      4      3    2
          (%o2)          x  - 2 x  - 2 x  + x  + 2 x - a + 1
          (%i3) polydecomp (p, x);
                                  2       3
          (%o3)                 [x  - a, x  - x - 1]

     Die folgende Funktion verkettet die Elemente der Liste `L = [e_1,
     ..., e_n]' zu einer Funktion in der Variablen <x>.  Diese Funktion
     ist die Inverse Operation zu der Funktion `polydecomp'.

          compose (L, x) :=
            block ([r : x], for e in L do r : subst (e, x, r), r) $

     Anwendung der Funktionen `compose' und `polydecomp'.

          (%i3) polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
                                  2       3
          (%o3)                 [x  - a, x  - x - 1]

     Während  `compose (polydecomp (<p>, <x>), <x>)' immer das Polynom
     <p> als Ergebnis hat, hat `polydecomp (compose ([<p_1>, ...,
     <p_n>], <x>), <x>)' nicht notwendigerweise das Ergebnis `[<p_1>,
     ..., <p_n>]'.

          (%i4) polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
                                    2       2
          (%o4)                   [x  + 2, x  + 1]
          (%i5) polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
                                2       2
                               x  + 3  x  + 5
          (%o5)               [------, ------, 2 x + 1]
                                 4       2

 -- Funktion: polymod (<p>)
 -- Funktion: polymod (<p>, <m>)
     Konvertiert das Polynom <p> in eine modulare Darstellung bezüglich
     dem aktuellen Modul.  Das Modul ist der Wert der Variablen
     `modulus'.

     `polymod(<p>, <m>' konvertiert das Polynom bezüglich dem Modul
     <m>, anstatt dem aktuellen Modul `modulus'.

     Siehe auch `modulus'.


 -- Funktion: powers (<expr>, <x>)
     Gibt eine Liste mit den Potenzen der Variablen <x> zurück, die im
     Ausdruck <expr> auftreten.

     Mit dem Kommando `load(powers)' wird die Funktion geladen.


 -- Funktion: quotient (<p_1>, <p_2>)
 -- Funktion: quotient (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Berechnet den Quotienten der Polynome <p_1> und <p_2> für die
     Variable <x_n>.  Die anderen Variablen <x_1>, ..., <x_n-1> haben
     dieselbe Bedeutung wie für die Funktion `ratvars'.

     `quotient' gibt das erste Element des Ergebnisses der Funktion
     `divide'  zurück.

     Siehe auch die Funktion `remainder'.

     Beispiel:

          (%i1) poly1 : x^3-2*x^2-5*x+7;
                                  3      2
          (%o1)                  x  - 2 x  - 5 x + 7
          (%i2) poly2 : x-1;
          (%o2)                         x - 1
          (%i3) quotient(poly1, poly2, x);
                                      2
          (%o3)                      x  - x - 6

 -- Funktion: rat (<expr>)
 -- Funktion: rat (<expr>, <x_1>, ..., <x_n>)
     Konvertiert einen Ausdruck <expr> in die CRE-Form.  Der Ausdruck
     wird so expandiert und gruppiert, dass alle Terme einen
     gemeinsamen Nenner haben und der größte gemeinsame Teiler gekürzt
     ist.  Weiterhin werden Gleitkommazahlen in rationale Zahlungen
     umgewandelt.  Die Toleranz der Umwandlung wird von der
     Optionsvariablen `ratepsilon'  kontrolliert.  Die Variablen im
     Ausdruck werden entsprechend der Funktion `ratvars'

     gemäß der angegebenen Argumente <x_1>, ..., <x_n> angeordnet.

     `rat' vereinfacht im Allgemeinen keine Ausdrücke bis auf die
     Addition `+', Subtraktion `-', Multiplikation `*', Division `/'
     und die Exponentiation `^' mit einer ganzen Zahl.  Dagegen führt
     die Funktion `ratsimp'  auch weitere Vereinfachungen aus.
     Variablen und Zahlen in einer CRE-Form sind nicht identisch mit
     denen in der Standardform.  Zum Beispiel hat `rat(x)- x' das
     Ergebnis `rat(0)', welches eine andere interne Darstellung als `0'
     hat.

     Hat die Optionsvariable `ratfac'  den Wert `true', wird ein
     Ausdruck von der Funktion `rat' nur teilweise faktorisiert.  Bei
     der Ausführung von Operationen wird bleibt der Ausdruck so
     vollständig als möglich in seiner faktorisierten Form, ohne dass
     eine Faktorisierung ausgeführt wird.  Damit kann Rechenzeit
     eingespart werden.

     Hat die Optionsvariable `ratprint'  den Wert `false', werden
     Meldungen unterdrückt, wenn eine Gleitkommazahl in eine rationale
     umgewandelt wird.

     Hat die Optionsvariable `keepfloat'  den Wert `true', werden
     Gleitkommazahlen nicht in rationale Zahlen umgewandelt.

     Siehe auch die Funktionen `ratexpand'  und `ratsimp',  um
     Ausdrücke zu vereinfachen, sowie die Funktion `ratdisrep',  um
     einen Ausdruck von einer CRE-Form in eine allgemeine Form zu
     transformieren.

     Beispiele:

          (%i1) ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x) /
                (4*y^2 + x^2);
                                                     4
                                            (x - 2 y)
                        (y + a) (2 y + x) (------------ + 1)
                                             2      2 2
                                           (x  - 4 y )
          (%o1)         ------------------------------------
                                        2    2
                                     4 y  + x
          (%i2) rat (%, y, a, x);
                                      2 a + 2 y
          (%o2)/R/                    ---------
                                       x + 2 y

 -- Optionsvariable: ratalgdenom
     Standardwert: `true'

     Hat die Optionsvariable `ratalgdenom' den Wert `true', versucht
     Maxima den Nenner beim Auftreten von Wurzeln rational zu machen.
     `ratalgdenom' wirkt sich nur aus, wenn die Optionsvariable
     `algebraic'  den Wert `true' hat und der Ausdruck in einer CRE-Form
     vorliegt.

     Beispiele:

          (%i1) algebraic:true$

          (%i2) ratalgdenom:false$

          (%i3) rat(sqrt(3)/sqrt(2));
                                       sqrt(3)
          (%o3)/R/                     -------
                                       sqrt(2)
          (%i4) ratalgdenom:true$

          (%i5) rat(sqrt(3)/sqrt(2));
                                   sqrt(2) sqrt(3)
          (%o5)/R/                 ---------------
                                          2
          (%i6) algebraic:false$

          (%i7) rat(sqrt(3)/sqrt(2));
                                       sqrt(3)
          (%o7)/R/                     -------
                                       sqrt(2)

 -- Funktion: ratcoef (<expr>, <x>, <n>)
 -- Funktion: ratcoef (<expr>, <x>)
     Gibt den Koeffizienten des Ausdrucks `<x>^<n>' in dem Argument
     <expr> zurück.  Wenn das Argument <n> nicht angegeben ist, wird
     der Wert zu `1' angenommen.

     Die Rückgabe ist frei von der Variablen <x>.  Existiert kein
     Koeffizient `<x>^<n>' dann ist die Rückgabe `0'.

     `ratcoef' expandiert und vereinfacht das Argument <expr>.  Daher
     kann `ratcoef' ein anderes Ergebnis als die Funktion `coeff'
     haben, die keine Vereinfachungen ausführt.  Daher `ratcoef((x +
     1)/y + x, x)' das Ergebnis `(y + 1)/y' und nicht das Ergebnis `1'
     wie es von der Funktion `coeff' zurückgegeben wird.

     `ratcoef(<expr>, <x>, 0)' gibt eine Summe der Terme zurück, die
     die Variable <x> nicht enthalten.

     Beispiele:

          (%i1) s: a*x + b*x + 5$
          (%i2) ratcoef (s, a + b);
          (%o2)                           x

 -- Funktion: ratdenom (<expr>)
     Gibt den Nenner des Argumentes <expr> zurück.  `ratdenom' wandelt
     den Ausdruck zuerst in eine CRE-Form um und gibt das Ergebnis in
     einer CRE-Form zurück.

     Das Argument <expr> wird von der Funktion `rat'  in eine CRE-Form
     gebracht, falls <expr> nicht bereits in einer CRE-Form vorliegt.
     Diese Transformation kann den Ausdruck <expr> verändern, da alle
     Terme über einen gemeinsamen Nenner zusammengefasst werden.

     Die Funktion `denom'  ist vergleichbar.  `denom' wandelt den
     Ausdruck jedoch nicht eine CRE-Form um und hat als Ergebnis einen
     Ausdruck in der Standardform.  Daher können sich die Ergebnisse
     von `ratdenom' und `denom' voneinander unterscheiden.

     Beispiel:

          (%i1) expr: expand((x^2+2*x+3)/(x-1));
                                  2
                                 x       2 x      3
          (%o1)                 ----- + ----- + -----
                                x - 1   x - 1   x - 1
          (%i2) ratdenom(expr);
          (%o2)/R/                      x - 1
          (%i3) denom(expr);
          (%o3)                           1

 -- Optionsvariable: ratdenomdivide
     Standardwert: `true'

     Hat die Optionsvariable `ratdenomdivide' den Wert `true',
     expandiert die Funktion `ratexpand'  einen Quotienten der im
     Zähler eine Summe hat, in eine Summe der Quotienten.  Ansonsten
     werden die Terme über einen gemeinsamen Nenner zusammengefasst.

     Beispiele:

          (%i1) expr: (x^2 + x + 1)/(y^2 + 7);
                                      2
                                     x  + x + 1
          (%o1)                      ----------
                                        2
                                       y  + 7
          (%i2) ratdenomdivide: true$
          (%i3) ratexpand (expr);
                                 2
                                x        x        1
          (%o3)               ------ + ------ + ------
                               2        2        2
                              y  + 7   y  + 7   y  + 7
          (%i4) ratdenomdivide: false$
          (%i5) ratexpand (expr);
                                      2
                                     x  + x + 1
          (%o5)                      ----------
                                        2
                                       y  + 7
          (%i6) expr2: a^2/(b^2 + 3) + b/(b^2 + 3);
                                               2
                                     b        a
          (%o6)                    ------ + ------
                                    2        2
                                   b  + 3   b  + 3
          (%i7) ratexpand (expr2);
                                            2
                                       b + a
          (%o7)                        ------
                                        2
                                       b  + 3

 -- Funktion: ratdiff (<expr>, <x>)
     Differenziert einen rationalen Ausdruck <expr> nach der Variablen
     <x>.  <expr> muss eine rationale Funktion oder ein Polynom in der
     Variablen <x> sein.  Das Argument <x> kann ein Teilausdruck des
     Argumentes <expr> sein.

     Das Ergebnis ist äquivalent zum Ergebnis der Funktion `diff',

     kann aber eine andere Form haben.  Für rationale Funktionen kann
     die Funktion `ratdiff' schneller sein.

     `ratdiff' gibt das Ergebnis in einer CRE-Form zurück, wenn das
     Argument in einer CRE-Form vorliegt.  Ansonsten ist das Ergebnis
     in der Standardform.

     `ratdiff' beachtet nur die Abhängigkeit des Ausdrucks von der
     Variablen <x>.  Abhängigkeiten die mit der Funktion `depends'
     definiert werden, werden von der Funktion `ratdiff' ignoriert.

     Beispiele:

          (%i1) expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
                                     3
                                  4 x  + 10 x - 11
          (%o1)                   ----------------
                                        5
                                       x  + 5
          (%i2) ratdiff (expr, x);
                              7       5       4       2
                           8 x  + 40 x  - 55 x  - 60 x  - 50
          (%o2)          - ---------------------------------
                                    10       5
                                   x   + 10 x  + 25
          (%i3) expr: f(x)^3 - f(x)^2 + 7;
                                   3       2
          (%o3)                   f (x) - f (x) + 7
          (%i4) ratdiff (expr, f(x));
                                     2
          (%o4)                   3 f (x) - 2 f(x)
          (%i5) expr: (a + b)^3 + (a + b)^2;
                                        3          2
          (%o5)                  (b + a)  + (b + a)
          (%i6) ratdiff (expr, a + b);
                              2                    2
          (%o6)            3 b  + (6 a + 2) b + 3 a  + 2 a

 -- Funktion: ratdisrep (<expr>)
     Gibt das Argument <expr> als einen allgemeinen Ausdruck zurück.
     Ist <expr> bereits ein allgemeiner Ausdruck, wird dieser
     unverändert zurückgegeben.

     Im Allgemeinen wird die Funktion `ratdisrep' aufgerufen, um einen
     Ausdruck von der CRE-Form in einen allgemeinen Ausdruck
     umzuwandeln.

     Siehe auch die Funktion `totaldisrep'.


 -- Funktion: ratexpand (<expr>)
 -- Optionsvariable: ratexpand
     Expandiert das Argument <expr> indem Produkte und Potenzen von
     Summen ausmultipliziert, Brüche über einen gemeinsamen Nenner
     dargestellt werden und der größte gemeinsamen Teiler heraus
     gekürzt wird.  Ist der Zähler eine Summe, wird er in seine Terme
     aufgespalten, die jeweils durch den Nenner dividiert werden.

     Die Rückgabe der Funktion `ratexpand' ist ein allgemeiner
     Ausdruck, auch wenn das Argument <expr> ein Ausdruck in der
     CRE-Form ist.

     Die Optionsvariable `ratexpand' kontrolliert die Vereinfachung der
     Funktion `ratsimp'.  Hat `ratexpand' den Wert `true', wird ein
     Ausdruck vollständig ausmultipliziert. Ist der Wert `false', wird
     der Ausdruck nur bezüglich der Hauptvariablen ausmultipliziert.
     Zum Beispiel hat `ratsimp((x+1)*(y+1))' das Ergebnis `x y + y + x
     + 1', wenn `ratexpand' den Wert `true' hat, ansonsten ist das
     Ergebnis `(x + 1) y + x + 1'.  Siehe auch die Funktion `ratsimp'.

     Hat die Optionsvariable `ratdenomdivide'  den Wert `true',
     expandiert die Funktion `ratexpand'  einen Quotienten der im
     Zähler eine Summe hat, in eine Summe der Quotienten.  Ansonsten
     werden die Terme über einen gemeinsamen Nenner zusammengefasst.

     Hat die Optionsvariable `keepfloat'  den Wert `true', werden
     Gleitkommazahlen im Argument <expr> nicht in rationale Zahlen
     umgewandelt, wenn der Ausdruck in eine CRE-Form umgewandelt wird.

     Beispiele:

          (%i1) ratexpand ((2*x - 3*y)^3);
                               3         2       2        3
          (%o1)          - 27 y  + 54 x y  - 36 x  y + 8 x
          (%i2) expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
                                   x - 1       1
          (%o2)                   -------- + -----
                                         2   x - 1
                                  (x + 1)
          (%i3) expand (expr);
                              x              1           1
          (%o3)          ------------ - ------------ + -----
                          2              2             x - 1
                         x  + 2 x + 1   x  + 2 x + 1
          (%i4) ratexpand (expr);
                                  2
                               2 x                 2
          (%o4)           --------------- + ---------------
                           3    2            3    2
                          x  + x  - x - 1   x  + x  - x - 1

 -- Optionsvariable: ratfac
     Standardwert: `false'

     Hat die Optionsvariable `ratfac' den Wert `true', werden Ausdrücke
     in einer CRE-Form nur teilweise faktorisiert.  Bei der Ausführung
     von Operationen bleibt der Ausdruck so vollständig als möglich in
     seiner faktorisierten Form, ohne dass eine Faktorisierung mit der
     Funktion `factor'  ausgeführt wird.  Auf diese Weise kann
     Rechenzeit eingespart werden.

     Der `ratweight' -Mechanismus ist nicht kompatibel mit dem Setzen
     der Variablen `ratfac'.


 -- Funktion: ratnumer (<expr>)
     Gibt den Zähler des Argumentes <expr> zurück.  `ratnumer' wandelt
     den Ausdruck zuerst in eine CRE-Form um und gibt das Ergebnis in
     einer CRE-Form zurück.

     Das Argument <expr> wird von der Funktion `rat'  in eine CRE-Form
     gebracht, falls <expr> nicht bereits in einer CRE-Form vorliegt.
     Diese Transformation kann den Ausdruck <expr> verändern, da alle
     Terme über einen gemeinsamen Nenner zusammengefasst werden.

     Die Funktion `num'  ist vergleichbar.  `num' wandelt den Ausdruck
     jedoch nicht eine CRE-Form um und hat als Ergebnis einen Ausdruck
     in der Standardform.  Daher können sich die Ergebnisse von
     `ratnumer' und `num' voneinander unterscheiden.


 -- Funktion: ratp (<expr>)
     Gibt das Ergebnis `true' zurück, wenn das Argument <expr> in einer
     CRE-Form oder einer erweiterten CRE-Form vorliegt.

     CRE-Formen werden von der Funktion `rat'  und verwandten
     Funktionen erzeugt.  Erweiterte CRE-Formen werden von der Funktion
     `taylor'  und verwandten Funktionen erzeugt.

 -- Optionsvariable: ratprint
     Standardwert: `true'

     Hat die Optionsvariable `ratprint' den Wert `true', gibt Maxima
     eine Meldung aus, wenn eine Gleitkommazahl in eine rationale Zahl
     umgewandelt wird.

     Beispiel:

          (%i1) ratprint:true;
          (%o1)                         true
          (%i2) rat(0.75*x);

          rat: replaced 0.75 by 3/4 = 0.75
                                         3 x
          (%o2)/R/                       ---
                                          4
          (%i3) ratprint:false;
          (%o3)                         false
          (%i4) rat(0.75*x);
                                         3 x
          (%o4)/R/                       ---
                                          4

 -- Funktion: ratsimp (<expr>)
 -- Funktion: ratsimp (<expr>, <x_1>, ..., <x_n>)
     Vereinfacht den Ausdruck <expr> und alle Teilausdrücke,
     einschließlich der nicht rationalen Anteile.  Das Ergebnis ist ein
     Quotient aus zwei Polynomen in einer rekursiven Form.  In der
     rekursiven Form ist das Polynom nach der Hauptvariablen
     vollständig ausmultipliziert und ein Polynom in allen anderen
     Variablen.  Variable können auch nicht-rationale Ausdrücke wie
     `sin(x^2 + 1)' sein.

     `ratsimp(<expr>, <x_1>, ..., <x_n>)' vereinfacht einen Ausdruck
     mit einer Ordnung der Variablen wie sie von der Funktion `ratvars'

     definiert wird.

     Hat die Optionsvariable `ratsimpexpons'  den Wert `true', wird
     `ratsimp' auch auf die Exponenten von Ausdrücke angewendet.

     Siehe auch die Funktion `ratexpand'.    Die Funktion `ratsimp' wird
     auch von einigen Schaltern kontrolliert, die Einfluss auf
     `ratexpand' haben.

     Beispiele:

          (%i1) sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
                                                   2      2
                             x         (log(x) + 1)  - log (x)
          (%o1)        sin(------) = %e
                            2
                           x  + x
          (%i2) ratsimp (%);
                                       1          2
          (%o2)                  sin(-----) = %e x
                                     x + 1
          (%i3) ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
                                 3/2
                          (x - 1)    - sqrt(x - 1) (x + 1)
          (%o3)           --------------------------------
                               sqrt((x - 1) (x + 1))
          (%i4) ratsimp (%);
                                     2 sqrt(x - 1)
          (%o4)                    - -------------
                                           2
                                     sqrt(x  - 1)
          (%i5) x^(a + 1/a), ratsimpexpons: true;
                                         2
                                        a  + 1
                                        ------
                                          a
          (%o5)                        x

 -- Optionsvariable: ratsimpexpons
     Standardwert: `false'

     Hat die Optionsvariable `ratsimpexpons' den Wert `true', wird
     `ratsimp' auch auf die Exponenten von Ausdrücke angewendet.

     Beispiel:

          (%i1) expr: x^(a+1/a);
                                       a + 1/a
          (%o1)                       x
          (%i2) ratsimpexpons: false;
          (%o2)                         false
          (%i3) ratsimp(expr);
                                       a + 1/a
          (%o3)                       x
          (%i4) ratsimpexpons: true;
          (%o4)                         true
          (%i5) ratsimp(expr);
                                         2
                                        a  + 1
                                        ------
                                          a
          (%o5)                        x

 -- Optionsvariable: radsubstflag
     Standardwert: `false'

     Hat `radsubstflag' den Wert `true', werden Wurzeln von der Funktion
     `ratsubst'  auch dann substituiert, wenn diese nicht explizit im
     Ausdruck enthalten sind.

     Beispiel:

          (%i1) radsubstflag: false$
          (%i2) ratsubst (u, sqrt(x), x);
          (%o2)                           x
          (%i3) radsubstflag: true$
          (%i4) ratsubst (u, sqrt(x), x);
                                          2
          (%o4)                          u

 -- Funktion: ratsubst (<a>, <b>, <c>)
     Substituiert <a> für <b> in den Ausdruck <c> und gibt das Ergebnis
     der Substitution zurück.

     Im Unterschied zu `subst'  kann `ratsubst' auch Teilausdrücke im
     Ausdruck <c> substituieren.  So hat `subst(a, x + y, x + y + z)'
     das Ergebnis `x + y + z' und `ratsubst' das Ergebnis `z + a'.

     Hat `radsubstflag' den Wert `true', werden Wurzeln von der Funktion
     `ratsubst' auch dann substituiert, wenn diese nicht explizit im
     Ausdruck enthalten sind.

     Beispiel:

          (%i1) ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
                                        3      4
          (%o1)                      a x  y + a
          (%i2) cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
                         4         3         2
          (%o2)       cos (x) + cos (x) + cos (x) + cos(x) + 1
          (%i3) ratsubst (1 - sin(x)^2, cos(x)^2, %);
                      4           2                     2
          (%o3)    sin (x) - 3 sin (x) + cos(x) (2 - sin (x)) + 3
          (%i4) ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
                                  4           2
          (%o4)                cos (x) - 2 cos (x) + 1
          (%i5) radsubstflag: false$
          (%i6) ratsubst (u, sqrt(x), x);
          (%o6)                           x
          (%i7) radsubstflag: true$
          (%i8) ratsubst (u, sqrt(x), x);
                                          2
          (%o8)                          u

 -- Funktion: ratvars (<x_1>, ..., <x_n>)
 -- Funktion: ratvars ()
 -- Systemvariable: ratvars
     Deklariert die Variablen <x_1>, ..., <x_n> zu Hauptvariablen einer
     rationalen Funktion.  Ist die Variable <x_n> in einem Ausdruck
     vorhanden, wird diese zur Hauptvariablen.  Ist <x_n> nicht im
     Ausdruck vorhanden, wird einer der vorhergehenden Variablen <x_i>
     zur Hauptvariablen.

     Eine Variable einer rationalen Funktion, die nicht unter den
     <x_1>, ..., <x_n> ist, erhält eine geringe Priorität als <x_1>.

     Die Argumente der Funktion `ratvars' können auch nicht-rationale
     Ausdrücke wie `sin(x)' sein.

     Die Systemvariable `ratvars' enthält die Liste der zuletzt mit der
     Funktion `ratvars' zu Hauptvariablen erklärten Variablen.  Jeder
     Aufruf der Funktion `ratvars' setzt diese Liste zurück.  Der
     Aufruf ohne Argumente `ratvars()' löscht die Systemvariable
     `ratvars'.

 -- Funktion: ratweight (<x_1>, <w_1>, ..., <x_n>, <w_n>)
 -- Funktion: ratweight ()
     Weist der Variablen <x_i> ein Gewicht <w_i> zu.  Hat ein Term einer
     rationalen Funktion ein größeres Gewicht als der Wert der Variablen
     `ratwtlvl'  wird der Term durch `0' ersetzt.  Das Gewicht eines
     Terms wird anhand der mit `ratweight' den Variablen zugewiesenen
     Gewichte ermittelt.  Die Gewichte der Variablen in einem Term
     werden mit der Potenz der Variablen multipliziert und dann
     addiert.  Zum Beispiel hat der Term `3 x_1^2 x_2' das Gewicht `2
     w_1 + w_2'.  Terme die den Wert von `ratwtlvl' übersteigen, werden
     nur dann entfernt, wenn rationale Funktionen in einer CRE-Form
     multipliziert oder potenziert werden.

     `ratweight()' gibt die Liste der zugewiesenen Gewichte zurück.

     Der `ratweight' -Mechanismus ist nicht kompatibel mit dem Setzen
     der Variablen `ratfac'.

     Beispiele:

          (%i1) ratweight (a, 1, b, 1);
          (%o1)                     [a, 1, b, 1]
          (%i2) expr1: rat(a + b + 1)$
          (%i3) expr1^2;
                            2                  2
          (%o3)/R/         b  + (2 a + 2) b + a  + 2 a + 1
          (%i4) ratwtlvl: 1$
          (%i5) expr1^2;
          (%o5)/R/                  2 b + 2 a + 1

 -- System variable: ratweights
     Standardwert: `[]'

     Die Systemvariable `ratweights' enthält die Liste der Gewichte die
     Variablen mit der Funktion `ratweights'  zugewiesen sind.

     Die Gewichte können mit dem Kommando `kill(ratweights)' gelöscht
     werden.

 -- Optionsvariable: ratwtlvl
     Standardwert: `false'

     Die Optionsvariable wird im Zusammenhang mit den `ratweight'
     -Mechanismus genutzt und kontrolliert das Entfernen von Termen
     einer rationalen Funktion in einer CRE-Form, wenn deren Gewicht
     den Wert von `ratwtlvl' übersteigt.  Mit dem Standardwert `false'
     werden keine Terme entfernt.

 -- Funktion: remainder (<p_1>, <p_2>)
 -- Funktion: remainder (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Berechnet den Rest der Polynomdivision von <p_1> und <p_2> für die
     Variable <x_n>.  Die anderen Variablen <x_1>, ..., <x_n-1> haben
     dieselbe Bedeutung wie für die Funktion `ratvars'.

     `remainder' gibt das zweite Element des Ergebnisses der Funktion
     `divide'  zurück.

     Siehe auch die Funktion `quotient'.

     Beispiel:

          (%i1) poly1 : x^3-2*x^2-5*x+7;
                                  3      2
          (%o1)                  x  - 2 x  - 5 x + 7
          (%i2) poly2 : x^2+1;
                                        2
          (%o2)                        x  + 1
          (%i3) remainder(poly1, poly2, x);
          (%o3)                        9 - 6 x

 -- Funktion: resultant (<p_1>, <p_2>, <x>)
     Berechnet die Resultante der Polynome <p_1> und <p_2> und
     eliminiert die unabhängige Variable <x>.  Die Resultante ist die
     Determinante der Sylvestermatrix für die beiden Polynome.  Das
     Ergebnis ist Null, wenn die beiden Polynome <p_1> und <p_2> einen
     gemeinsamen Faktor haben.

     Können die Polynome <p_1> oder <p_2> faktorisiert werden, kann es
     von Vorteil sein, die Faktorisierung zuvor auszuführen.

     Die Optionsvariable `resultant' kontrolliert, welcher Algorithmus
     für die Berechnung der Resultante von Maxima genutzt wird.  Siehe
     die Optionsvariable `resultant'.

     Die Funktion `bezout'  berechnet die Sylvestermatrix der Polynome
     <p_1> und <p_2>.  Die Determinante der Sylvestermatrix ist die
     Resultante.

     Beispiele:

          (%i1) resultant(2*x^2+3*x+1, 2*x^2+x+1, x);
          (%o1)                           8
          (%i2) resultant(x+1, x+1, x);
          (%o2)                           0
          (%i3) resultant((x+1)*x, (x+1), x);
          (%o3)                           0
          (%i4) resultant(a*x^2+b*x+1, c*x + 2, x);
                                   2
          (%o4)                   c  - 2 b c + 4 a

          (%i5) bezout(a*x^2+b*x+1, c*x+2, x);
                                  [ 2 a  2 b - c ]
          (%o5)                   [              ]
                                  [  c      2    ]
          (%i6) determinant(%);
          (%o6)                   4 a - (2 b - c) c

 -- Optionsvariable: resultant
     Standardwert: `subres'

     Die Optionsvariable `resultant' kontrolliert, welcher Algorithmus
     für die Berechnung der Resultante mit der Funktion `resultant'
     von Maxima genutzt wird.  Die möglichen Werte sind:

    `subres'
          Subresultanten-Algorithmus

    `mod'
          Modularer Resultanten-Algorithmus

    `red'
          Reduzierter Subresultanten-Algorithmus

     Der Standwert `subres' ist für die meisten Probleme geeignet.  Für
     große Polynome in einer oder zwei Variablen kann `mod' besser sein.

 -- Optionsvariable: savefactors
     Standardwert: `false'

     Hat die Optionsvariable `savefactors' den Wert `true', versuchen
     einige Funktionen bei der Vereinfachung eine bereits vorhandene
     Faktorisierung zu erhalten, um weitere Vereinfachungen zu
     beschleunigen.

 -- Funktion: showratvars (<expr>)
     Gibt eine Liste mit den Variablen des Ausdrucks <expr> zurück.  Der
     Ausdruck liegt in einer CRE-Form vor.

     Siehe auch die Funktion `ratvars'.


 -- Funktion: sqfr (<expr>)
     Entspricht der Funktion `factor'  mit dem Unterschied, dass
     faktorisierte Polynome quadratfrei sind.

     Beispiel:

          (%i1) sqfr (4*x^4 + 4*x^3 - 3*x^2 - 4*x - 1);
                                          2   2
          (%o1)                  (2 x + 1)  (x  - 1)

 -- Funktion: tellrat (<p_1>, ..., <p_n>)
 -- Funktion: tellrat ()
     Fügt dem Ring der ganzen Zahlen, die algebraische Zahlen hinzu,
     die Lösungen der minimalen Polynome <p_1>, ..., <p_n> sind.  Jedes
     Argument <p_i> ist ein Polynom, dessen Koeffizienten ganze Zahlen
     sind.

     `tellrat(<x>)' bedeutet, dass in einer rationalen Funktion die
     Variable <x> mit dem Wert `0' substituiert wird.

     `tellrat()' gibt eine Liste der minimalen Polynome zurück.

     Die Optionsvariable `algebraic'  muss den Wert `true' haben, damit
     die Vereinfachungen von algebraischen Zahlen ausgeführt wird.

     Maxima kennt bereits die Erweiterungen um die Imaginäre Einheit
     `%i' und die Wurzeln der ganzen Zahlen.

     Die Funktion `untellrat'  entfernt die Eigenschaften, die mit der
     Funktion `tellrat' definiert wurden.

     Hat ein minimales Polynom mehrere Variablen, wie zum Beispiel in
     `tellrat(x^2 - y^2)', dann entsteht eine Mehrdeutigkeit, da Maxima
     nicht ermitteln kann, ob <x^2> für <y^2> zu ersetzten ist, oder
     umgekehrt.  In diesem Fall kann die Syntax `tellrat (y^2 = x^2)'
     genutzt werden, die besagt, dass <y^2> durch <x^2> zu ersetzen ist.

     Beispiele:

          (%i1) 10*(%i + 1)/(%i + 3^(1/3));
                                     10 (%i + 1)
          (%o1)                      -----------
                                            1/3
                                      %i + 3
          (%i2) ev (ratdisrep (rat(%)), algebraic);
                       2/3      1/3              2/3      1/3
          (%o2)    (4 3    - 2 3    - 4) %i + 2 3    + 4 3    - 2
          (%i3) tellrat (1 + a + a^2);
                                      2
          (%o3)                     [a  + a + 1]
          (%i4) 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
                                1                 a
          (%o4)           ------------- + -----------------
                          sqrt(2) a - 1   sqrt(3) + sqrt(2)
          (%i5) ev (ratdisrep (rat(%)), algebraic);
                   (7 sqrt(3) - 10 sqrt(2) + 2) a - 2 sqrt(2) - 1
          (%o5)    ----------------------------------------------
                                         7
          (%i6) tellrat (y^2 = x^2);
                                  2    2   2
          (%o6)                 [y  - x , a  + a + 1]

 -- Funktion: totaldisrep (<expr>)
     Konvertiert alle Teilausdrücke im Ausdruck <expr> von der CRE-Form
     in die allgemeine Form und gibt das Ergebnis zurück.  Ist <expr>
     selbst eine CRE-Form, dann entspricht `totaldisrep' der Funktion
     `ratdisrep'.

     `totaldisrep' ist insbesondere hilfreich, wenn Gleichungen, Listen
     oder Matrizen in eine allgemeine Form zu konvertieren sind.


 -- Funktion: untellrat (<x_1>, ..., <x_n>)
     Entfernt Eigenschaften von den Symbolen <x_1>, ..., <x_n>, die mit
     der Funktion `tellrat' zugewiesen wurden.



File: maxima.info,  Node: Gleichungen,  Next: Lineare Algebra,  Prev: Polynome,  Up: Top

18 Gleichungen
**************

* Menu:

* Funktionen und Variablen für Gleichungen::


File: maxima.info,  Node: Funktionen und Variablen für Gleichungen,  Prev: Gleichungen,  Up: Gleichungen

18.1 Funktionen und Variablen für Gleichungen
=============================================

 -- Optionsvariable: %rnum
     Standardwert: `0'

     Wenn notwendig erzeugen die Funktionen `solve'  und `algsys'  freie
     Parameter, die in die Lösungen eingesetzt werden.  Die Parameter
     haben den Namen `%r<<num>>'.  Die Optionsvariable `%rnum' enthält
     die Nummer <num>, die an den Präfix `%r' angehängt wird.  Maxima
     erhöht `%rnum' automatisch.  Siehe auch die Systemvariable
     `%rnum_list'  für eine Liste der Parameter einer Lösung.

 -- Systemvariable: %rnum_list
     Standardwert: `[]'

     `%rnum_list' ist die Liste der freien Parameter, die von `solve'
     und `algsys'  in Lösungen eingesetzt werden.  Die Parameter werden
     der Liste `%rnum_list' in der Reihenfolge hinzugefügt, in der sie
     erzeugt werden.

     Beispiele:

          (%i1) solve ([x + y = 3], [x,y]);
          (%o1)              [[x = 3 - %r1, y = %r1]]
          (%i2) %rnum_list;
          (%o2)                       [%r1]
          (%i3) sol : solve ([x + 2*y + 3*z = 4], [x,y,z]);
          (%o3)   [[x = - 2 %r3 - 3 %r2 + 4, y = %r3, z = %r2]]
          (%i4) %rnum_list;
          (%o4)                     [%r2, %r3]
          (%i5) for i : 1 thru length (%rnum_list) do
                  sol : subst (t[i], %rnum_list[i], sol)$
          (%i6) sol;
          (%o6)     [[x = - 2 t  - 3 t  + 4, y = t , z = t ]]
                               2      1           2       1

 -- Optionsvariable: algexact
     Standardwert: `false'

     Die Optionsvariable `algexact' kontrolliert die Funktion `algsys'

     folgendermaßen:

        * Hat `algexact' den Wert `true', wird von der Funktion `algsys'
          stets `solve'  aufgerufen.  Findet `solve' keine Lösung, wird
          die Funktion `realroots'  aufgerufen.

        * Hat `algexact' den Wert `false', wird die Funktion `solve' nur
          für Gleichungen aufgerufen, die von mehr als einer Variablen
          abhängen und für quadratische oder kubische Gleichungen.

     Der Wert `true' für `algexact' garantiert nicht, dass `algsys' nur
     exakte Lösungen findet.  Findet `algsys' keine exakten Lösungen,
     versucht `solve' immer Näherungslösungen zu finden.

     Beispiele:

          (%i1) algexact:true$

          (%i2) algsys([x^5-1],[x]);
                                                sqrt(5)   5
                                         sqrt(- ------- - -)
                               sqrt(5)             2      2    1
          (%o2) [[x = 1], [x = ------- + ------------------- - -],
                                  4               2            4
                                sqrt(5)   5
                         sqrt(- ------- - -)
               sqrt(5)             2      2    1
          [x = ------- - ------------------- - -],
                  4               2            4
                                sqrt(5)   5
                           sqrt(------- - -)
                 sqrt(5)           2      2    1
          [x = - ------- + ----------------- - -],
                    4              2           4
                                sqrt(5)   5
                           sqrt(------- - -)
                 sqrt(5)           2      2    1
          [x = - ------- - ----------------- - -]]
                    4              2           4

          (%i3) algexact:false$

          (%i4) algsys([x^5-1],[x]);
          (%o4) [[x = 1], [x = - .5877852522924731 %i
           - .8090169943749475], [x = .5877852522924731 %i
           - .8090169943749475], [x = .3090169943749475
           - .9510565162951535 %i], [x = .9510565162951535 %i
           + .3090169943749475]]

     Auch wenn die Optionsvariable `algexact' den Wert `true' hat, gibt
     `algsys' numerische Näherungslösungen zurück, wenn `solve' keine
     Lösungen finden kann.

          (%i5) algexact:true$

          (%i6) algsys([x^5-x^3+1],[x]);
          (%o6) [[x = - 1.236505681818182],
          [x = - 0.785423103049449 %i - .3407948661970064],
          [x = 0.785423103049449 %i - .3407948661970064],
          [x = .9590477178927559 - .4283659562541893 %i],
          [x = .4283659562541893 %i + .9590477178927559]]

          (%i7) solve([x^5-x^3+1],[x]);
                                        5    3
          (%o7)                   [0 = x  - x  + 1]

     Für eine quadratische Gleichung wird immer eine exakte Lösung
     zurückgeben.

          (%i8) algsys:true$

          (%i9) algsys([x^2+x-1],[x]);
                           sqrt(5) - 1          sqrt(5) + 1
          (%o9)      [[x = -----------], [x = - -----------]]
                                2                    2
          (%i11) algsys:false$

          (%i12) algsys([x^2+x-1],[x]);
                            sqrt(5) - 1          sqrt(5) + 1
          (%o12)      [[x = -----------], [x = - -----------]]
                                 2                    2

 -- Optionsvariable: algepsilon
     Standardwert: `10^8'

     Kontrolliert die Genauigkeit einer numerischen Lösung der Funktion
     `algsys'  für den Fall, dass die Optionsvariable `realonly'  den
     Wert `true' hat, also nur die reellen Lösungen gesucht werden.

     Beispiele:

     Numerische Lösung der Gleichung `x^3-2' für zwei verschiedene Wert
     für `algepsilon'.

          (%i1) realonly:true$
          (%i2) algepsilon:10^2;
          (%o2)                          100
          (%i3) algsys([x^3-2],[x]);
          (%o3)                  [[x = 1.26171875]]
          (%i4) algepsilon: 10^8;
          (%o4)                       100000000
          (%i5) algsys([x^3-2],[x]);
          (%o5)               [[x = 1.259921095381759]]

     `algepsilon' hat keinen Einfluss auf die Genauigkeit der Lösung,
     wenn auch die komplexen Lösungen gesucht werden.

          (%i6) realonly:false$
          (%i7) algepsilon: 10^2;
          (%o7)                          100
          (%i8) algsys([x^3-2],[x]);
          (%o8) [[x = - 1.091123635971721 %i - .6299605249474366],
          [x = 1.091123635971721 %i - .6299605249474366],
          [x = 1.259921095381759]]

 -- Funktion: algsys ([<expr_1>, ..., <expr_m>], [<x_1>, ..., <x_n>])
 -- Funktion: algsys ([<eqn_1>, ..., <eqn_m>], [<x_1>, ..., <x_n>])
     Löst ein Gleichungssystem mit den Polynomen <expr_1>, ...,
     <expr_m> oder den Gleichungen <eqn_1>, ..., <eqn_m> für die
     Variablen <x_1>, ..., <x_n>.  Werden Polynome <expr_i> als
     Argument übergeben, werden diese als Gleichungen `expr_i = 0'
     interpretiert.  Die Anzahl der Gleichungen und Variablen kann
     verschieden sein.

     `algsys' gibt eine Liste mit den Lösungen zurück.  Jede Lösung ist
     wiederum eine Liste mit den Lösungen für die einzelnen Variablen
     <x_i>, die als Gleichungen angegeben sind.  Kann `algsys' keine
     Lösung finden, wird eine leere Liste `[]' zurückgegeben.

     Haben die Lösungen freie Parameter, setzt `algsys' die Symbole
     `%r1', `%r2', ... in die Lösungen ein.  Die freien Parameter
     werden der Liste `%rnum_list' hinzugefügt.  Siehe `%rnum_list'.

     Die Funktion `algsys' führt die folgenden Schritte aus, um Lösungen
     eines Gleichungssystems zu finden:

       1. Die Gleichungen werden faktorisiert und in Teilsysteme <S_i>
          aufgeteilt.

       2. Für jedes Teilsystem <S_i> werden eine Gleichung <E>, die den
          niedrigsten von Null verschiedenen Grad hat und eine Variable
          <x> ausgewählt.  Dann wird die Resultante der Gleichungen <E>
          und <E_j> für die Variable <x> sowie allen verbleibenden
          Gleichungen <E_j> des Teilsystems <S_i> berechnet.  Dieses
          Verfahren eliminiert die Variable <x> und hat ein neues
          Teilsystem <S_i'> als Ergebnis.  Der Algorithmus wiederholt
          dann den 1. Schritt.

       3. Besteht das Teilsystem nur noch aus einer Gleichung, hat
          diese Gleichung mehrere Variablen und enthält diese keine
          Gleitkommazahlen, dann wird `solve'  aufgerufen, um eine
          exakte Lösung zu finden.

          Es kann sein, dass `solve' keine Lösung oder einen sehr großen
          Ausdruck als Lösung findet.

          Auch für Gleichungen, die nur eine Variable enthalten und die
          entweder linear, quadratisch oder quartisch sind sowie keine
          Gleitkommazahlen enthalten, wird `solve' aufgerufen, um eine
          exakte Lösung zu finden.  Trifft dies nicht zu, wird in dem
          Fall, dass die `realonly'  den Wert `true' hat, die Funktion
          `realroots'.    Ansonsten wird die Funktion `allroots'

          aufgerufen.  Die Funktion `realroots' sucht reelle Lösungen
          der Gleichung, während die Funktion `allroots' auch komplex
          Lösungen sucht.

          Für den Fall, dass `realonly' den Wert `true' hat, wird die
          Genauigkeit einer numerischen Lösung von der Optionsvariablen
          `algepsilon'  kontrolliert.

          Hat die Optionsvariable `algexact'  den Wert `true', wird
          immer die Funktion `solve' aufgerufen.

       4. Zuletzt werden die erhaltenen Lösungen in das betrachtete
          Teilsystem eingesetzt und der Lösungsalgorithmus mit dem 1.
          Schritt fortgesetzt.

     Tritt beim Lösen des Gleichungssystems eine Gleichung auf, die von
     mehreren Variablen abhängt und Gleitkommazahlen enthält, dann wird
     der Algorithmus mit der Meldung `algsys cannot solve - system too
     complicated."' abgebrochen.  Ein Näherung mit Gleitkommazahlen
     kann in vorgehenden Schritten auftreten, wenn keine exakten
     Lösungen auffindbar sind.

     Ist das Argument der Funktion `allroots'  kein Polynom, gibt
     Maxima eine Fehlermeldung aus.  Die Lösungen eines
     Gleichungssystems können sehr große Ausdrücke sein.  Obwohl die
     Lösung reell ist, kann die imaginäre Einheit `%i' in den Lösungen
     enthalten sein.  Für die weitere Bearbeitung der Lösungen können
     die Funktionen `pickapart'  oder `reveal'  hilfreich sein.

     Beispiele:

          (%i1) e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
          (%o1)              2 (1 - a1) x - 2 a2 (x - 1)
          (%i2) e2: a2 - a1;
          (%o2)                        a2 - a1
          (%i3) e3: a1*(-y - x^2 + 1);
                                             2
          (%o3)                   a1 (- y - x  + 1)
          (%i4) e4: a2*(y - (x - 1)^2);
                                                 2
          (%o4)                   a2 (y - (x - 1) )
          (%i5) algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
          (%o5) [[x = 0, y = %r1, a1 = 0, a2 = 0],

                                            [x = 1, y = 0, a1 = 1, a2 = 1]]
          (%i6) e1: x^2 - y^2;
                                        2    2
          (%o6)                        x  - y
          (%i7) e2: -1 - y + 2*y^2 - x + x^2;
                                   2        2
          (%o7)                 2 y  - y + x  - x - 1
          (%i8) algsys ([e1, e2], [x, y]);
                           1            1
          (%o8) [[x = - -------, y = -------],
                        sqrt(3)      sqrt(3)

                  1              1             1        1
          [x = -------, y = - -------], [x = - -, y = - -], [x = 1, y = 1]]
               sqrt(3)        sqrt(3)          3        3

 -- Funktion: allroots (<expr>)
 -- Funktion: allroots (<eqn>)
     Berechnet numerische Näherungen der reellen und komplexen Wurzeln
     des Polynoms <expr> oder der Polynomgleichung <eqn> mit einer
     Variablen.

     Hat der Schalter `polyfactor'  den Wert `true', wird das Polynom
     über die reellen oder komplexen Zahlen faktorisiert.

     Für den Fall mehrfacher Wurzeln kann `allroots' ungenaue Ergebnisse
     liefern.  Ist das Polynom reell, kann es sein, dass
     `allroots(%i*<p>)') genauere Approximationen liefern als `allroots
     (<p>)', da `allroots' in diesem Fall einen anderen Algorithmus
     verwendet.

     Der Zähler des Arguments der Funktion `allroots' muss nach
     Anwendung der Funktion `rat' ein Polynom sein und darf im Nenner
     höchstens eine komplexe Zahl enthalten.  Ist das Argument der
     Funktion `allroots' kein Polynom, gibt Maxima eine Fehlermeldung.
     Daher wird von der Funktion `allroots' immer ein äquivalenter,
     jedoch faktorisierter Ausdruck zurückgegeben, wenn die
     Optionsvariable `polyfactor'  den Wert `true' hat.

     Für komplexe Polynome wird ein Algorithmus von Jenkins und Traub
     verwendet (Algorithm 419, Comm. ACM, vol. 15, (1972), p. 97).  Für
     reelle Polynome wird ein Algorithmus von Jenkins verwendet
     (Algorithm 493, ACM TOMS,vol. 1, (1975), p.178).

     Beispiele:

          (%i1) eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
                                      3          5
          (%o1)              (2 x + 1)  = 13.5 (x  + 1)
          (%i2) soln: allroots (eqn);
          (%o2) [x = .8296749902129361, x = - 1.015755543828121,

          x = .9659625152196369 %i - .4069597231924075,

          x = - .9659625152196369 %i - .4069597231924075, x = 1.0]
          (%i3) for e in soln
                  do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
                                - 3.5527136788005E-15

                               - 5.32907051820075E-15

                   4.44089209850063E-15 %i - 4.88498130835069E-15

                  - 4.44089209850063E-15 %i - 4.88498130835069E-15

                                 3.5527136788005E-15

          (%o3)                         done
          (%i4) polyfactor: true$
          (%i5) allroots (eqn);
          (%o5) - 13.5 (x - 1.0) (x - .8296749902129361)

                                     2
           (x + 1.015755543828121) (x  + .8139194463848151 x

           + 1.098699797110288)

 -- Funktion: bfallroots (<expr>)
 -- Funktion: bfallroots (<eqn>)
     Berechnet numerische Näherungen der reellen und komplexen Wurzeln
     des Polynoms <expr> oder der Polynomgleichung <eqn> in einer
     Variable.

     `bfallroots' entspricht der Funktion `allroots' mit dem
     Unterschied, dass die Funktion `bfallroots' die Näherungen mit
     großen Gleitkommazahlen berechnet.  Siehe `allroots'.

     Beispiel:

     Dasselbe Beispiel wie fÃ¼r die Funktion `allroots'.  Die Ergebnisse
     sind große Gleitkommazahlen.

          (%i1) eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
                                      3          5
          (%o1)              (2 x + 1)  = 13.5 (x  + 1)
          (%i2) soln: bfallroots(eqn);
          (%o2) [x = 8.296749902129362b-1, x = - 1.015755543828121b0,
          x = 9.65962515219637b-1 %i - 4.069597231924075b-1,
          x = - 9.65962515219637b-1 %i - 4.069597231924075b-1, x = 1.0b0]

 -- Optionsvariable: backsubst
     Standardwert: `true'

     Hat `backsubst' den Wert `false', werden die Lösungen der Funktion
     `linsolve'  nicht rücksubstituiert.  Dies kann hilfreich sein,
     wenn die Rücksubstitution zu sehr großen Ausdrücken führt.

     Beispiele:

          (%i1) eq1 : x + y + z = 6$
          (%i2) eq2 : x - y + z = 2$
          (%i3) eq3 : x + y - z = 0$
          (%i4) backsubst : false$
          (%i5) linsolve ([eq1, eq2, eq3], [x,y,z]);
          (%o5)             [x = z - y, y = 2, z = 3]
          (%i6) backsubst : true$
          (%i7) linsolve ([eq1, eq2, eq3], [x,y,z]);
          (%o7)               [x = 1, y = 2, z = 3]

 -- Optionsvariable: breakup
     Standardwert: `true'

     Hat die Optionsvariablen `programmode'  den Wert `false' und die
     Optionsvariable `breakup' den Wert `true', dann werden für
     gemeinsame Terme in Lösungen von kubischen und quartischen
     Gleichungen Zwischenmarken erzeugt.

     Beispiele:

          (%i1) programmode: false$
          (%i2) breakup: true$
          (%i3) solve (x^3 + x^2 - 1);

                                  sqrt(23)    25 1/3
          (%t3)                  (--------- + --)
                                  6 sqrt(3)   54
          Solution:

                                                sqrt(3) %i   1
                                                ---------- - -
                          sqrt(3) %i   1            2        2   1
          (%t4)    x = (- ---------- - -) %t3 + -------------- - -
                              2        2            9 %t3        3

                                                sqrt(3) %i   1
                                              - ---------- - -
                        sqrt(3) %i   1              2        2   1
          (%t5)    x = (---------- - -) %t3 + ---------------- - -
                            2        2             9 %t3         3

                                             1     1
          (%t6)                  x = %t3 + ----- - -
                                           9 %t3   3
          (%o6)                    [%t4, %t5, %t6]
          (%i6) breakup: false$
          (%i7) solve (x^3 + x^2 - 1);
          Solution:

                       sqrt(3) %i   1
                       ---------- - -
                           2        2        sqrt(23)    25 1/3
          (%t7) x = --------------------- + (--------- + --)
                       sqrt(23)    25 1/3    6 sqrt(3)   54
                    9 (--------- + --)
                       6 sqrt(3)   54

                                                        sqrt(3) %i   1    1
                                                     (- ---------- - -) - -
                                                            2        2    3

                     sqrt(23)    25 1/3  sqrt(3) %i   1
          (%t8) x = (--------- + --)    (---------- - -)
                     6 sqrt(3)   54          2        2

                                                      sqrt(3) %i   1
                                                    - ---------- - -
                                                          2        2      1
                                                + --------------------- - -
                                                     sqrt(23)    25 1/3   3
                                                  9 (--------- + --)
                                                     6 sqrt(3)   54

                      sqrt(23)    25 1/3             1             1
          (%t9)  x = (--------- + --)    + --------------------- - -
                      6 sqrt(3)   54          sqrt(23)    25 1/3   3
                                           9 (--------- + --)
                                              6 sqrt(3)   54
          (%o9)                    [%t7, %t8, %t9]

 -- Funktion: dimension (<eqn>)
 -- Funktion: dimension (<eqn_1>, ..., <eqn_n>)
     `dimen' ist ein Paket für die Dimensionsanalyse.  `load(dimen)'
     lädt dieses Paket.  `demo(dimen)' zeigt eine kleine Demonstration.

 -- Optionsvariable: dispflag
     Standardwert: `true'

     Hat `dispflag' den Wert `false', werden Ausgaben der Funktion
     `solve' unterdrückt.

 -- Funktion: funcsolve (<eqn>, <g>(<t>))
     Das Argument <eqn> ist eine Gleichung, die ein Polynom erster
     Ordnung in den Funktionen `<g>(<t>)' und `<g>(<t+1>)' ist.
     `funcsolve' sucht die rationale Funktion `<g>(<t>)', die Lösung
     der Gleichung <eqn> ist.

     Warnung: Die Funktion ist nur sehr rudimentär implementiert.
     Offensichtliche Verallgemeinerungen fehlen.

     Beispiel:

          (%i1) eqn: (n + 1)*f(n) - (n + 3)*f(n + 1)/(n + 1) =
                (n - 1)/(n + 2);
                                      (n + 3) f(n + 1)   n - 1
          (%o1)        (n + 1) f(n) - ---------------- = -----
                                           n + 1         n + 2
          (%i2) funcsolve (eqn, f(n));

          Dependent equations eliminated:  (4 3)
                                             n
          (%o2)                f(n) = ---------------
                                      (n + 1) (n + 2)

 -- Optionsvariable: globalsolve
     Standardwert: `false'

     Hat `globalsolve' den Wert `true', werden den unbekannten Variablen
     eines linearen Gleichungssystems die Werte der Lösungen der
     Funktionen `linsolve'  und `solve'  zugewiesen.

     Hat `globalsolve' den Wert `false', werden den unbekannten
     Variablen eines linearen Gleichungssystems keine Werte zugewiesen.
     Die Lösungen werden als Gleichungen mit den unbekannten Variablen
     ausgedrückt.

     Für andere als lineare Gleichungssysteme wird der Wert von
     `globalsolve' ignoriert.  Die Funktion `algsys'  ignoriert
     `globalsolve' immer.

     Beispiele:

          (%i1) globalsolve: true$
          (%i2) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t2)                        x : --
                                           7

                                             1
          (%t3)                        y : - -
                                             7
          (%o3)                     [[%t2, %t3]]
          (%i3) x;
                                         17
          (%o3)                          --
                                         7
          (%i4) y;
                                           1
          (%o4)                          - -
                                           7
          (%i5) globalsolve: false$
          (%i6) kill (x, y)$
          (%i7) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t7)                        x = --
                                           7

                                             1
          (%t8)                        y = - -
                                             7
          (%o8)                     [[%t7, %t8]]
          (%i8) x;
          (%o8)                           x
          (%i9) y;
          (%o9)                           y

 -- Funktion: ieqn (<ie>, <unk>, <tech>, <n>, <guess>)
     `inteqn' ist ein Paket zur Lösung von Integralgleichungen zweiter
     Art der Form

                                 b(x)
                                /
                                [
              p(x) = q(x, p(x), I     w(x, u, p(x), p(u)) du)
                                ]
                                /
                                 a(x)

     und von Integralgleichungen erster Art der Form

                      b(x)
                     /
                     [
              f(x) = I     w(x, u, p(u)) du
                     ]
                     /
                      a(x)

     Das Kommando `load(inteqn)' lädt das Paket.

     Das erste Argument <ie> ist die Integralgleichung und das Argument
     <unk> die unbekannte Funktion.  Mit dem Argument <tech> wird die
     Methode angegeben, die zur Lösung der Integralgleichung angewendet
     werden soll.  Erhält das Argument <tech> den Wert `first', wird
     das Ergebnis der ersten erfolgreichen Methode zurückgegeben.  Mit
     `all' werden alle Methoden angewendet.  Das Argument <n> gibt die
     maximale Anzahl an Termen an, die von den Methoden `taylor',
     `neumann', `firstkindseries' oder `fredseries' verwendet werden.
     <n> ist auch die maximale Tiefe der Rekursion für der
     Differentiationsmethode.  Das Argument <guess> ist der Startwert
     der Methoden `neumann' oder `firstkindseries'.

     Die Standardwerte der Argumente sind:

    <unk>
          `<p>(<x>)', wobei <p> die erste im Integranden aufgefundene
          Funktion ist, die Maxima unbekannt ist, und <x> die Variable
          ist, die im Falle einer Integralgleichung der zweiten Art als
          Argument der Funktion <p> außerhalb des Integrals vorgefunden
          wird, oder im Falle einer Integralgleichung der ersten Art
          die einzige andere Variable neben der Integrationsvariable
          ist.  Wenn der Versuch fehlschlägt, die Variable <x> zu
          finden, wird der Nutzer nach der unabhängigen Variablen
          gefragt.

    <tech>
          `first'

    <n>
          `1'

    <guess>
          `none', bewirkt, dass der Ansatz `<f>(<x>)' als Startwert der
          Lösungsmethoden `neumann' und `firstkindseries' verwendet
          wird.

     Siehe `share/integequations/inteqn.usg' für weitere Informationen.

 -- Optionsvariable: ieqnprint
     Standardwert: `true'

     `ieqnprint' kontrolliert die Ausgabe des Ergebnisses der Funktion
     `ieqn'.    Hat die Optionsvariable `ieqnprint' den Wert `true',
     dann hat das Ergebnis der Funktion `ieqn' die Form `[<solution>,
     <technique used>, <nterms>, <flag>]'.  Ist die Lösung exakt, tritt
     das Element `<flag>' nicht auf.  Ansonsten erhält das Element
     `<flag>' den Wert `approximate' für eine nicht exakte Lösung und
     den Wert `incomplete' für eine nicht geschlossene Lösung.  Wurde
     die Lösung mit einer Methode gefunden, die einen Reihenansatz
     verwendet, enthält <nterms> die Anzahl der Terme der Entwicklung.

 -- Funktion: lhs (<expr>)
     Gibt die linke Seite des Ausdrucks <expr> zurück, wenn der
     Operator von <expr> einer der relationalen Operatoren `< <= = #
     equal notequal >= >', einer der Zuweisungsoperatoren `:= ::= : ::'
     oder ein nutzerdefinierter binärer Infix-Operator ist, der mit der
     Funktion `infix'  deklariert wurde.  Die linke Seite des Ausdrucks
     ist für die hier genannten Operatoren das erste Argument.

     Wenn <expr> ein Atom ist oder sein Operator ein anderer als oben
     aufgelistet, gibt `lhs' den Ausdruck <expr> zurück.  Siehe auch
     `rhs'.

     Beispiele:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [lhs (aa < bb), lhs (aa <= bb), lhs (aa >= bb),
                 lhs (aa > bb)];
          (%o4)                   [aa, aa, aa, aa]
          (%i5) [lhs (aa = bb), lhs (aa # bb), lhs (equal (aa, bb)),
                 lhs (notequal (aa, bb))];
          (%o5)                   [aa, aa, aa, aa]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [lhs (e1), lhs (e2), lhs (e3), lhs (e4)];
          (%o10)               [foo(x), bar(y), x, x]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) lhs (aa ][ bb);
          (%o12)                         aa

 -- Funktion: linsolve ([<expr_1>, ..., <expr_m>], [<x_1>, ..., <x_n>])
     Löst das lineare Gleichungssystem mit den Gleichungen oder
     Polynomen [<expr_1>, ..., <expr_m>] und den Variablen [<x_1>, ...,
     <x_n>].  Jede Gleichung muss ein Polynom in den angegebenen
     Variablen sein.

     Hat die Optionsvariable `globalsolve'  den Wert `true', werden die
     Lösungen des Gleichungssystems den angegebenen Variablen
     zugewiesen.

     Hat die Optionsvariable `backsubst'  den Wert `false', führt
     `linsolve' keine Rücksubstitutionen aus.  Dies kann hilfreich
     sein, wenn die Rücksubstitution zu sehr großen Ausdrücken führt.

     Hat die Optionsvariable `linsolve_params'  den Wert `true', setzt
     `linsolve' für ein unterbestimmtes Gleichungssystem freie
     Parameter in die Lösungen ein, die mit `%r'-Symbolen bezeichnet
     werden.  Siehe auch `%rnum'  und `%rnum_list'.

     Hat die Optionsvariable `programmode'  den Wert `false', werden die
     Lösungen von `linsolve' Zwischenmarken `%t' zugewiesen.  Die
     Zwischenmarken werden als Liste zurückgegeben.

     Beispiele:

          (%i1) e1: x + z = y;
          (%o1)                       z + x = y
          (%i2) e2: 2*a*x - y = 2*a^2;
                                                 2
          (%o2)                   2 a x - y = 2 a
          (%i3) e3: y - 2*z = 2;
          (%o3)                      y - 2 z = 2
          (%i4) [globalsolve: false, programmode: true];
          (%o4)                     [false, true]
          (%i5) linsolve ([e1, e2, e3], [x, y, z]);
          (%o5)            [x = a + 1, y = 2 a, z = a - 1]
          (%i6) [globalsolve: false, programmode: false];
          (%o6)                    [false, false]
          (%i7) linsolve ([e1, e2, e3], [x, y, z]);
          Solution

          (%t7)                       z = a - 1

          (%t8)                        y = 2 a

          (%t9)                       x = a + 1
          (%o9)                    [%t7, %t8, %t9]
          (%i9) ''%;
          (%o9)            [z = a - 1, y = 2 a, x = a + 1]
          (%i10) [globalsolve: true, programmode: false];
          (%o10)                    [true, false]
          (%i11) linsolve ([e1, e2, e3], [x, y, z]);
          Solution

          (%t11)                      z : a - 1

          (%t12)                       y : 2 a

          (%t13)                      x : a + 1
          (%o13)                 [%t11, %t12, %t13]
          (%i13) ''%;
          (%o13)           [z : a - 1, y : 2 a, x : a + 1]
          (%i14) [x, y, z];
          (%o14)                 [a + 1, 2 a, a - 1]
          (%i15) [globalsolve: true, programmode: true];
          (%o15)                    [true, true]
          (%i16) linsolve ([e1, e2, e3], '[x, y, z]);
          (%o16)           [x : a + 1, y : 2 a, z : a - 1]
          (%i17) [x, y, z];
          (%o17)                 [a + 1, 2 a, a - 1]

 -- Optionsvariable: linsolvewarn
     Standardwert: `true'

     Hat `linsolvewarn' den Wert `true', gibt die Funktion `linsolve'
     gegebenenfalls die Meldung `Dependent equations eliminated' aus.

 -- Optionsvariable: linsolve_params
     Standardwert: `true'

     Hat `linsolve_params' den Wert `true', setzt die Funktion
     `linsolve'  für ein unterbestimmtes Gleichungssystem freie
     Parameter in die Lösungen ein, die mit `%r'-Symbolen bezeichnet
     werden.  Siehe auch `%rnum'  und `%rnum_list'.


 -- Systemvariable: multiplicities
     Standardwert: `not_set_yet'

     `multiplicities' ist die Liste der Vielfachheiten der Lösungen,
     die von `solve',  `realroots'  oder `allroots'

     zurückgegeben werden.

     Beispiel:

          (%i1) solve(x^2*(x+1)^2, x);
          (%o1)                   [x = - 1, x = 0]
          (%i2) multiplicities;
          (%o2)                        [2, 2]

 -- Funktion: nroots (<p>, <low>, <high>)
     Gibt die Anzahl der reellen Wurzeln des reellen univariaten
     Polynoms <p> im halboffenen Intervall `(<low>, <high>]' zurück.
     Die Grenzen des Intervalls können auch negativ unendlich `minf'
     oder positiv unendlich `inf' sein.

     `nroots' verwendet die Methode der Sturm-Sequenzen.

     Beispiel:

          (%i1) p: x^10 - 2*x^4 + 1/2$
          (%i2) nroots (p, -6, 9.1);
          (%o2)                           4

 -- Funktion: nthroot (<p>, <n>)
     Das Argument <p> ist ein Polynom mit ganzzahligen Koeffizienten
     und das Argument <n> eine positive ganze Zahl.  `nthroot' gibt ein
     Polynom q über die ganzen Zahlen zurück, so dass q^n = p gilt.
     Existiert kein derartiges Polynom <q> gibt Maxima eine
     Fehlermeldung aus.  `nthroot' ist wesentlich schneller als die
     Funktionen `factor'  oder `sqfr'.


 -- Optionsvariable: polyfactor
     Standardwert: `false'

     Hat die Optionsvariable `polyfactor' den Wert `true', werden die
     Lösungen der Funktionen `allroots' und `bfallroots' über die
     reellen Zahlen faktorisiert, wenn das Polynom reell ist, und über
     die komplexen Zahlen, wenn das Polynome komplex ist.

     Siehe `allroots'  für ein Beispiel.

 -- Optionsvariable: programmode
     Standardwert: `true'

     Hat `programmode' den Wert `true', geben die Funktionen `solve',
     `realroots',  `allroots',

     `bfallroots'  und `linsolve'  die Lösungen als Elemente einer Liste
     zurück.

     Hat `programmode' den Wert `false', werden die Lösungen der oben
     genannten Funktionen Zwischenmarken `%t' zugewiesen.  Die Rückgabe
     der Funktionen ist in diesem Fall eine Liste der Zwischenmarken.

 -- Optionsvariable: realonly
     Standardwert: `false'

     Hat `realonly' den Wert `true', gibt `algsys'  nur Lösungen
     zurück, die nicht die imaginäre Einheit `%i' enthalten.

 -- Funktion: realroots (<expr>, <bound>)
 -- Funktion: realroots (<eqn>, <bound>)
 -- Funktion: realroots (<expr>)
 -- Funktion: realroots (<eqn>)
     Computes rational approximations of the real roots of the
     polynomial <expr> or polynomial equation <eqn> of one variable, to
     within a tolerance of <bound>.  Coefficients of <expr> or <eqn>
     must be literal numbers; symbol constants such as `%pi' are
     rejected.

     `realroots' assigns the multiplicities of the roots it finds to
     the global variable `multiplicities'.

     `realroots' constructs a Sturm sequence to bracket each root, and
     then applies bisection to refine the approximations.  All
     coefficients are converted to rational equivalents before
     searching for roots, and computations are carried out by exact
     rational arithmetic.  Even if some coefficients are floating-point
     numbers, the results are rational (unless coerced to floats by the
     `float' or `numer' flags).

     When <bound> is less than 1, all integer roots are found exactly.
     When <bound> is unspecified, it is assumed equal to the global
     variable `rootsepsilon'.

     When the global variable `programmode' is `true', `realroots'
     returns a list of the form `[x = <x_1>, x = <x_2>, ...]'.  When
     `programmode' is `false', `realroots' creates intermediate
     expression labels `%t1', `%t2', ..., assigns the results to them,
     and returns the list of labels.

     Examples:

          (%i1) realroots (-1 - x + x^5, 5e-6);
                                         612003
          (%o1)                     [x = ------]
                                         524288
          (%i2) ev (%[1], float);
          (%o2)                 x = 1.167303085327148
          (%i3) ev (-1 - x + x^5, %);
          (%o3)                - 7.396496210176905E-6

          (%i1) realroots (expand ((1 - x)^5 * (2 - x)^3 * (3 - x)), 1e-20);
          (%o1)                 [x = 1, x = 2, x = 3]
          (%i2) multiplicities;
          (%o2)                       [5, 3, 1]

 -- Funktion: rhs (<expr>)
     Gibt die rechte Seite des Ausdrucks <expr> zurück, wenn der
     Operator von <expr> einer der relationalen Operatoren `< <= = #
     equal notequal >= >', einer der Zuweisungsoperatoren `:= ::= : ::'
     oder ein nutzerdefinierter binärer Infixoperator ist, der mit der
     Funktion `infix' deklariert wurde.  Die rechte Seite des Ausdrucks
     ist für die hier genannten Operatoren das zweite Argument.

     Ist <expr> ein Atom oder hat der Ausdruck <expr> einen anderen
     Operator als oben angegeben, dann ist das Ergebnis `0'.  Siehe
     auch `lhs'.

     Beispiele:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [rhs (aa < bb), rhs (aa <= bb), rhs (aa >= bb),
                 rhs (aa > bb)];
          (%o4)                   [bb, bb, bb, bb]
          (%i5) [rhs (aa = bb), rhs (aa # bb), rhs (equal (aa, bb)),
                 rhs (notequal (aa, bb))];
          (%o5)                   [bb, bb, bb, bb]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [rhs (e1), rhs (e2), rhs (e3), rhs (e4)];
          (%o10)                  [2 x, 3 y, y, y]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) rhs (aa ][ bb);
          (%o12)                         bb

 -- Optionsvariable: rootsepsilon
     Standardwert: `1.0e-7'

     `rootsepsilon' ist die Toleranz, die den Vertrauensbereich für die
     von der Funktion `realroots'  gefundenen Wurzeln festsetzt.

 -- Funktion: solve (<expr>, <x>)
 -- Funktion: solve (<expr>)
 -- Funktion: solve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])
     Löst eine algebraische Gleichung <expr> nach der Variablen <x> auf.
     Wenn <expr> keine Gleichung ist, wird die Gleichung `<expr> = 0'
     angenommen.  <x> kann eine Funktion wie zum Beispiel `f(x)') sein
     oder ein allgemeiner Ausdruck.  Ausgenommen sind Summen und
     Produkte.  Hat die Gleichung nur eine Variable, braucht diese
     nicht angegeben zu werden.  <expr> kann ein rationaler Ausdruck
     sein und trigonometrische Funktionen, Exponentialfunktionen und
     andere Funktionen enthalten.  Zur Lösung wird die folgende Methode
     verwendet:

       1. Sei <E> ein Ausdruck und <X> die Variable.  Ist <E> linear in
          <X>, dann kann die Gleichung sofort nach der Variablen `X'
          aufgelöst werden.  Hat <E> die Form `A*X^N + B', dann ist das
          Ergebnis `(-B/A)^1/N)' multipliziert mit der `N'-ten
          Einheitswurzel.

       2. Ist <E> nicht linear in <X>, wird der größte gemeinsame Teiler
          <N> der Exponenten der Variable <X> bestimmt.  Die Exponenten
          der Variablen werden durch <N> dividiert und die
          Multiplizität der Lösungen mit <N> multipliziert.  `solve'
          wird erneut für den Ausdruck aufgerufen.  Kann <E>
          faktorisiert werden, wird `solve' für jeden Faktor
          aufgerufen.  Zuletzt prüft `solve', ob einer der Algorithmen
          für quadratische, kubische oder quartische Gleichungen
          angewendet werden kann.

       3. Ist <E> ein Polynom in einer Funktion `F(X)' mit <X> als der
          Variablen, wird zunächst die Lösung des Polynoms für `F(X)'
          gesucht.  Ist <C> eine solche Lösung, kann die Gleichung
          `F(X)=C' gelöst werden, wenn die Umkehrfunktion zu `F(X)'
          bekannt ist.

     Hat die Optionsvariable `breakup'  den Wert `false', werden die
     Lösungen von kubischen und quartischen Gleichungen nicht in
     gemeinsame Teilausdrücke zerlegt.

     Die Systemvariable `multiplicities'  enthält eine Liste mit den
     Vielfachheiten der einzelnen Lösungen.

     `solve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])' löst ein
     Gleichungssystem mit den Polynomen <eqn_1>, ..., <eqn_n> für die
     Variablen <x_1>, ..., <x_n>.  Die Polynome können linear oder
     nichtlinear sein.  Um das System zu lösen, werden die Funktionen
     `linsolve'  oder `algsys'  aufgerufen.  Das Ergebnis ist eine
     Liste mit den Lösungen.  Ist die Anzahl der Gleichungen gleich der
     Anzahl der Variablen des Systems, kann das Argument mit der Liste
     der Variablen entfallen.

     Hat die Optionsvariable `programmode'  den Wert `false' ist, zeigt
     `solve' die Lösungen mit Hilfe von Zwischenmarken (`%t') an und
     gibt die Liste der Marken zurück.

     Hat die Optionsvariable `globalsolve'  den Wert `true', werden den
     unbekannten Variablen eines linearen Gleichungssystems die Werte
     der Lösung der Funktionen `linsolve'  und `solve' zugewiesen.

     Beispiele:

          (%i1) solve (asin (cos (3*x))*(f(x) - 1), x);

          SOLVE is using arc-trig functions to get a solution.
          Some solutions will be lost.
                                      %pi
          (%o1)                  [x = ---, f(x) = 1]
                                       6
          (%i2) ev (solve (5^f(x) = 125, f(x)), solveradcan);
                                          log(125)
          (%o2)                   [f(x) = --------]
                                           log(5)
          (%i3) [4*x^2 - y^2 = 12, x*y - x = 2];
                                2    2
          (%o3)             [4 x  - y  = 12, x y - x = 2]
          (%i4) solve (%, [x, y]);
          (%o4) [[x = 2, y = 2], [x = .5202594388652008 %i

           - .1331240357358706, y = .0767837852378778

           - 3.608003221870287 %i], [x = - .5202594388652008 %i

           - .1331240357358706, y = 3.608003221870287 %i

           + .0767837852378778], [x = - 1.733751846381093,

          y = - .1535675710019696]]
          (%i5) solve (1 + a*x + x^3, x);
                                                 3
                        sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (%o5) [x = (- ---------- - -) (--------------- - -)
                            2        2      6 sqrt(3)      2

                  sqrt(3) %i   1
                 (---------- - -) a
                      2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                                    3
           sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (---------- - -) (--------------- - -)
               2        2      6 sqrt(3)      2

                   sqrt(3) %i   1
                (- ---------- - -) a
                       2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2
                   3
           sqrt(4 a  + 27)   1 1/3               a
          (--------------- - -)    - --------------------------]
              6 sqrt(3)      2                  3
                                        sqrt(4 a  + 27)   1 1/3
                                     3 (--------------- - -)
                                           6 sqrt(3)      2
          (%i6) solve (x^3 - 1);
                       sqrt(3) %i - 1        sqrt(3) %i + 1
          (%o6)   [x = --------------, x = - --------------, x = 1]
                             2                     2
          (%i7) solve (x^6 - 1);
                     sqrt(3) %i + 1      sqrt(3) %i - 1
          (%o7) [x = --------------, x = --------------, x = - 1,
                           2                   2

                               sqrt(3) %i + 1        sqrt(3) %i - 1
                         x = - --------------, x = - --------------, x = 1]
                                     2                     2
          (%i8) ev (x^6 - 1, %[1]);
                                                6
                                (sqrt(3) %i + 1)
          (%o8)                 ----------------- - 1
                                       64
          (%i9) expand (%);
          (%o9)                           0
          (%i10) x^2 - 1;
                                        2
          (%o10)                       x  - 1
          (%i11) solve (%, x);
          (%o11)                  [x = - 1, x = 1]
          (%i12) ev (%th(2), %[1]);
          (%o12)                          0

     Die Symbole `%r' bezeichnen freie Konstanten einer Lösung.  Siehe
     `algsys'  und `%rnum_list'  für mehr Informationen.

          (%i1) solve([x+y=1,2*x+2*y=2],[x,y]);

          solve: dependent equations eliminated: (2)
          (%o1)                      [[x = 1 - %r1, y = %r1]]

 -- Optionsvariable: solvedecomposes
     Standardwert: `true'

     Hat `solvedecomposes' den Wert `true', ruft `solve'  die Funktion
     `polydecomp'  auf, um Polynome zu zerlegen.

 -- Optionsvariable: solveexplicit
     Standardwert: `false'

     Hat `solveexplicit' den Wert `true', gibt die Funktion `solve'
     keine impliziten Lösungen der Form `F(x) = 0' zurück.

     Beispiel:

          (%i1) solveexplicit:false;
          (%o1)                         false
          (%i2) solve(gamma(x)*x^3-1);
                                     3      1
          (%o2)                    [x  = --------]
                                         gamma(x)
          (%i3) solveexplicit:true;
          (%o3)                         true
          (%i4) solve(gamma(x)*x^3-1);
          (%o4)                          []

 -- Optionsvariable: solvefactors
     Standardwert: `true'

     Hat `solvefactors' den Wert `false', versucht die Funktion `solve'
     nicht, den Ausdruck zu faktorisieren.  Das Setzen der
     Optionsvariable `solvefactors' auf den Wert `false' kann notwendig
     sein, wenn die Faktorisierung nicht benötigt wird, damit `solve'
     eine Lösung findet.

 -- Optionsvariable: solvenullwarn
     Standardwert: `true'

     Hat `solvenullwarn' den Wert `true', gibt die Funktion `solve'
     eine Warnmeldung aus, wenn keine Gleichungen oder keine Variablen
     als Argument übergeben wurden.

     Beispiel:

          (%i1) solvenullwarn:true;
          (%o1)                         true
          (%i2) solve(x^2*y+1,[]);

          solve: variable list is empty, continuing anyway.
          (%o2)                          []
          (%i3) solvenullwarn:false;
          (%o3)                         false
          (%i4) solve(x^2*y+1,[]);
          (%o4)                          []

 -- Optionsvariable: solveradcan
     Standardwert: `false'

     Hat `solveradcan' den Wert `true', ruft `solve'  die Funktion
     `radcan'  auf, um Ausdrücke zu vereinfachen, die
     Exponentialfunktionen und Logarithmen enthalten.

 -- Optionsvariable: solvetrigwarn
     Standardwert: `true'

     Hat `solvetrigwarn' den Wert `true', gibt die Funktion `solve'
     eine Warnung aus, wenn inverse trigonometrische Funktionen genutzt
     werden, um Lösungen zu finden.  In diesem Fall können Lösungen
     verloren gehen.

     Beispiel:

          (%i1) solvetrigwarn:true;
          (%o1)                         true
          (%i2) solve(cos(x)+1);

          solve: using arc-trig functions to get a solution.
          Some solutions will be lost.
          (%o2)                       [x = %pi]
          (%i3) solvetrigwarn:false;
          (%o3)                         false
          (%i4) solve(cos(x)+1);
          (%o4)                       [x = %pi]



Local Variables:
coding: iso-8859-1
End:
