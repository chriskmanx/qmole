This is maxima.info, produced by makeinfo version 4.13 from
/home/robert/maxima/maxima-git/maxima-code/doc/info/de//include-maxima.de.texi.

Das ist ein Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Ein Computer Algebra System.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: cobyla,  Next: contrib_ode,  Prev: bode,  Up: Top

37 cobyla
*********

* Menu:

* Introduction to cobyla::
* Functions and Variables for cobyla::
* Examples for cobyla::


File: maxima.info,  Node: Introduction to cobyla,  Next: Functions and Variables for cobyla,  Prev: cobyla,  Up: cobyla

37.1 Introduction to cobyla
===========================

`fmin_cobyla' is a Common Lisp translation (via `f2cl') of the Fortran
constrained optimization routine COBYLA by Powell[1][2][3].

COBYLA minimizes an objective function F(X) subject to M inequality
constraints of the form g(X) >= 0 on X, where X is a vector of
variables that has N components.

Equality constraints g(X)=0 can often be implemented by a pair of
inequality constraints g(X)>=0 and -g(X)>= 0.  Maxima's interface to
COBYLA allows equality constraints and internally converts the equality
constraints to a pair of inequality constraints.

The algorithm employs linear approximations to the objective and
constraint functions, the approximations being formed by linear
interpolation at N+1 points in the space of the variables.  The
interpolation points are regarded as vertices of a simplex.  The
parameter RHO controls the size of the simplex and it is reduced
automatically from RHOBEG to RHOEND.  For each RHO the subroutine tries
to achieve a good vector of variables for the current size, and then
RHO is reduced until the value RHOEND is reached.  Therefore RHOBEG and
RHOEND should be set to reasonable initial changes to and the required
accuracy in the variables respectively, but this accuracy should be
viewed as a subject for experimentation because it is not guaranteed.
The routine treats each constraint individually when calculating a
change to the variables, rather than lumping the constraints together
into a single penalty function.  The name of the subroutine is derived
from the phrase Constrained Optimization BY Linear Approximations.

References:

[1] Fortran Code is from `http://plato.asu.edu/sub/nlores.html#general'

[2] M. J. D. Powell, "A direct search optimization method that models
the objective and constraint functions by linear interpolation," in
Advances in Optimization and Numerical Analysis, eds. S. Gomez and
J.-P. Hennart (Kluwer Academic: Dordrecht, 1994), p. 51-67.

[3] M. J. D. Powell, "Direct search algorithms for optimization
calculations," Acta Numerica 7, 287-336 (1998).  Also available as
University of Cambridge, Department of Applied Mathematics and
Theoretical Physics,  Numerical Analysis Group, Report NA1998/04 from
`http://www.damtp.cam.ac.uk/user/na/reports.html'


File: maxima.info,  Node: Functions and Variables for cobyla,  Next: Examples for cobyla,  Prev: Introduction to cobyla,  Up: cobyla

37.2 Functions and Variables for cobyla
=======================================

 -- Function: fmin_cobyla (<F>, <X>, <Y>)
 -- Function: fmin_cobyla (<F>, <X>, <Y>, optional_args)
     Returns an approximate minimum of the expression <F> with respect
     to the variables <X>, subject to an optional set of constraints.
     <Y> is a list of initial guesses for <X>.

     <F> must be an ordinary expressions, not names of functions or
     lambda expressions.

     `optional_args' represents additional arguments, specified as
     `<symbol> = <value>'.  The optional arguments recognized are:

    `constraints'
          List of inequality and equality constraints that must be
          satisfied by <X>.  The inequality constraints must be actual
          inequalities of the form `g(<X>) >= h(<X>)' or `g(<X>) <=
          h(<X>)'.  The equality constraints must be of the form
          `g(<X>) = h(<X>)'.

    `rhobeg'
          Initial value of the internal RHO variable which controls the
          size of simplex.  (Defaults to 1.0)

    `rhoend'
          The desired final value rho parameter.  It is approximately
          the accuracy in the variables.  (Defaults to 1d-6.)

    `iprint'
          Verbose output level.  (Defaults to 0)
             * 0 - No output

             * 1 - Summary at the end of the calculation

             * 2 - Each new value of RHO and SIGMA is printed, including
               the vector of variables, some function information when
               RHO is reduced.

             * 3 - Like 2, but information is printed when F(X) is
               computed.

    `maxfun'
          The maximum number of function evaluations.  (Defaults to
          1000).

     On return, a vector is given:

       1. The value of the variables giving the minimum.  This is a
          list of elements of the form `<var> = <value>' for each of the
          variables listed in <X>.

       2. The minimized function value

       3. The number of function evaluations.

       4. Return code with the following meanings
            1.  0 - No errors.

            2.  1 - Limit on maximum number of function evaluations
               reached.

            3.  2 - Rounding errors inhibiting progress.

     `load(fmin_cobyla)' loads this function.

 -- Function: bf_fmin_cobyla (<F>, <X>, <Y>)
 -- Function: bf_fmin_cobyla (<F>, <X>, <Y>, optional_args)
     This function is identical to `fmin_cobyla', except that bigfloat
     operations are used, and the default value for <rhoend> is
     `10^(fpprec/2)'.

     See `fmin_cobyla' for more information.

     `load(fmin_cobyla)' loads this function.


File: maxima.info,  Node: Examples for cobyla,  Prev: Functions and Variables for cobyla,  Up: cobyla

37.3 Examples for cobyla
========================

Minimize x1*x2 with 1-x1^2-x2^2 >= 0.  The theoretical solution is x1 =
1/sqrt(2), x2 = -1/sqrt(2).

     (%i1) load(fmin_cobyla)$

     (%i2) fmin_cobyla(x1*x2, [x1, x2], [1,1],
                              constraints = [x1^2+x2^2<=1], iprint=1);

        Normal return from subroutine COBYLA

        NFVALS =   66   F =-5.000000E-01    MAXCV = 1.999956E-12
        X = 7.071058E-01  -7.071077E-01
     (%o2) [[x1 = .7071058493484819, x2 = - .7071077130247994],
                                           - .499999999999263

There are additional examples in the share/cobyla/ex directory.


File: maxima.info,  Node: contrib_ode,  Next: Package descriptive,  Prev: cobyla,  Up: Top

38 contrib_ode
**************

* Menu:

* Introduction to contrib_ode::
* Functions and Variables for contrib_ode::
* Possible improvements to contrib_ode::
* Test cases for contrib_ode::
* References for contrib_ode::


File: maxima.info,  Node: Introduction to contrib_ode,  Next: Functions and Variables for contrib_ode,  Prev: contrib_ode,  Up: contrib_ode

38.1 Introduction to contrib_ode
================================

Maxima's ordinary differential equation (ODE) solver `ode2' solves
elementary linear ODEs of first and second order.  The function
`contrib_ode' extends `ode2' with additional methods for linear and
non-linear first order ODEs and linear homogeneous second order ODEs.
The code is still under development and the calling sequence may change
in future releases.  Once the code has stabilized it may be moved from
the contrib directory and integrated into Maxima.

This package must be loaded with the command `load('contrib_ode)'
before use.

The calling convention for `contrib_ode' is identical to `ode2'.  It
takes three arguments: an ODE (only the left hand side need be given if
the right hand side is 0), the dependent variable, and the independent
variable.  When successful, it returns a list of solutions.

The form of the solution differs from `ode2'.  As non-linear equations
can have multiple solutions, `contrib_ode' returns a list of solutions.
Each solution can have a number of forms:

   * an explicit solution for the dependent variable,

   * an implicit solution for the dependent variable,

   * a parametric solution in terms of variable `%t', or

   * a tranformation into another ODE in variable `%u'.

`%c' is used to represent the constant of integration for first order
equations.  `%k1' and `%k2' are the constants for second order
equations.  If `contrib_ode' cannot obtain a solution for whatever
reason, it returns `false', after perhaps printing out an error message.

It is necessary to return a list of solutions, as even first order
non-linear ODEs can have multiple solutions.  For example:

     (%i1) load('contrib_ode)$
     (%i2) eqn:x*'diff(y,x)^2-(1+x*y)*'diff(y,x)+y=0;

                         dy 2             dy
     (%o2)            x (--)  - (x y + 1) -- + y = 0
                         dx               dx
     (%i3) contrib_ode(eqn,y,x);
                                                  x
     (%o3)             [y = log(x) + %c, y = %c %e ]
     (%i4) method;
     (%o4)                        factor

Nonlinear ODEs can have singular solutions without constants of
integration, as in the second solution of the following example:

     (%i1) load('contrib_ode)$
     (%i2) eqn:'diff(y,x)^2+x*'diff(y,x)-y=0;
                            dy 2     dy
     (%o2)                 (--)  + x -- - y = 0
                            dx       dx
     (%i3) contrib_ode(eqn,y,x);
                                                2
                                      2        x
     (%o3)              [y = %c x + %c , y = - --]
                                               4
     (%i4) method;
     (%o4)                       clairault

The following ODE has two parametric solutions in terms of the dummy
variable `%t'.  In this case the parametric solutions can be manipulated
to give explicit solutions.

     (%i1) load('contrib_ode)$
     (%i2) eqn:'diff(y,x)=(x+y)^2;

                               dy          2
     (%o2)                     -- = (y + x)
                               dx
     (%i3) contrib_ode(eqn,y,x);
     (%o3) [[x = %c - atan(sqrt(%t)), y = - x - sqrt(%t)],
                          [x = atan(sqrt(%t)) + %c, y = sqrt(%t) - x]]
     (%i4) method;
     (%o4)                       lagrange

The following example (Kamke 1.112) demonstrates an implicit solution.

     (%i1) load('contrib_ode)$
     (%i2) assume(x>0,y>0);
     (%o2)                    [x > 0, y > 0]
     (%i3) eqn:x*'diff(y,x)-x*sqrt(y^2+x^2)-y;

                          dy           2    2
     (%o3)              x -- - x sqrt(y  + x ) - y
                          dx
     (%i4) contrib_ode(eqn,y,x);
                                       y
     (%o4)                  [x - asinh(-) = %c]
                                       x
     (%i5) method;
     (%o5)                          lie

The following Riccati equation is transformed into a linear second
order ODE in the variable `%u'.  Maxima is unable to solve the new ODE,
so it is returned unevaluated.

     (%i1) load('contrib_ode)$
     (%i2) eqn:x^2*'diff(y,x)=a+b*x^n+c*x^2*y^2;

                         2 dy      2  2      n
     (%o2)              x  -- = c x  y  + b x  + a
                           dx
     (%i3) contrib_ode(eqn,y,x);

                    d%u
                    ---                            2
                    dx        2     n - 2   a     d %u
     (%o3)  [[y = - ----, %u c  (b x      + --) + ---- c = 0]]
                    %u c                     2      2
                                            x     dx
     (%i4) method;
     (%o4)                        riccati

For first order ODEs `contrib_ode' calls `ode2'.  It then tries the
following methods: factorization, Clairault, Lagrange, Riccati, Abel
and Lie symmetry methods.  The Lie method is not attempted on Abel
equations if the Abel method fails, but it is tried if the Riccati
method returns an unsolved second order ODE.

For second order ODEs `contrib_ode' calls `ode2' then `odelin'.

Extensive debugging traces and messages are displayed if the command
`put('contrib_ode,true,'verbose)' is executed.


File: maxima.info,  Node: Functions and Variables for contrib_ode,  Next: Possible improvements to contrib_ode,  Prev: Introduction to contrib_ode,  Up: contrib_ode

38.2 Functions and Variables for contrib_ode
============================================

 -- Function: contrib_ode (<eqn>, <y>, <x>)
     Returns a list of solutions of the ODE <eqn> with independent
     variable <x> and dependent variable <y>.

 -- Function: odelin (<eqn>, <y>, <x>)
     `odelin' solves linear homogeneous ODEs of first and second order
     with independent variable <x> and dependent variable <y>.  It
     returns a fundamental solution set of the ODE.

     For second order ODEs, `odelin' uses a method, due to Bronstein and
     Lafaille, that searches for solutions in terms of given special
     functions.

          (%i1) load('contrib_ode);

          (%i2) odelin(x*(x+1)*'diff(y,x,2)+(x+5)*'diff(y,x,1)+(-4)*y,y,x);
          ...trying factor method
          ...solving 7 equations in 4 variables
          ...trying the Bessel solver
          ...solving 1 equations in 2 variables
          ...trying the F01 solver
          ...solving 1 equations in 3 variables
          ...trying the spherodial wave solver
          ...solving 1 equations in 4 variables
          ...trying the square root Bessel solver
          ...solving 1 equations in 2 variables
          ...trying the 2F1 solver
          ...solving 9 equations in 5 variables
                 gauss_a(- 6, - 2, - 3, - x)  gauss_b(- 6, - 2, - 3, - x)
          (%o2) {---------------------------, ---------------------------}
                              4                            4
                             x                            x

 -- Function: ode_check (<eqn>, <soln>)
     Returns the value of ODE <eqn> after substituting a possible
     solution <soln>.  The value is equivalent to zero if <soln> is a
     solution of <eqn>.

          (%i1) load('contrib_ode)$
          (%i2) eqn:'diff(y,x,2)+(a*x+b)*y;

                                   2
                                  d y
          (%o2)                   --- + (a x + b) y
                                    2
                                  dx
          (%i3) ans:[y = bessel_y(1/3,2*(a*x+b)^(3/2)/(3*a))*%k2*sqrt(a*x+b)
                   +bessel_j(1/3,2*(a*x+b)^(3/2)/(3*a))*%k1*sqrt(a*x+b)];

                                            3/2
                              1  2 (a x + b)
          (%o3) [y = bessel_y(-, --------------) %k2 sqrt(a x + b)
                              3       3 a
                                                    3/2
                                      1  2 (a x + b)
                           + bessel_j(-, --------------) %k1 sqrt(a x + b)]
                                      3       3 a
          (%i4) ode_check(eqn,ans[1]);
          (%o4)                           0

 -- System variable: method
     The variable `method' is set to the successful solution method.

 -- Variable: %c
     `%c' is the integration constant for first order ODEs.

 -- Variable: %k1
     `%k1' is the first integration constant for second order ODEs.

 -- Variable: %k2
     `%k2' is the second integration constant for second order ODEs.

 -- Function: gauss_a (<a>, <b>, <c>, <x>)
     `gauss_a(a,b,c,x)' and `gauss_b(a,b,c,x)' are 2F1 geometric
     functions.  They represent any two independent solutions of the
     hypergeometric differential equation `x(1-x) diff(y,x,2) +
     [c-(a+b+1)x diff(y,x) - aby = 0' (A&S 15.5.1).

     The only use of these functions is in solutions of ODEs returned by
     `odelin' and `contrib_ode'.  The definition and use of these
     functions may change in future releases of Maxima.

     See also `gauss_b', `dgauss_a' and `gauss_b'.

 -- Function: gauss_b (<a>, <b>, <c>, <x>)
     See `gauss_a'.

 -- Function: dgauss_a (<a>, <b>, <c>, <x>)
     The derivative with respect to <x> of `gauss_a(<a>, <b>, <c>,
     <x>)'.

 -- Function: dgauss_b (<a>, <b>, <c>, <x>)
     The derivative with respect to <x> of `gauss_b(<a>, <b>, <c>,
     <x>)'.

 -- Function: kummer_m (<a>, <b>, <x>)
     Kummer's M function, as defined in Abramowitz and Stegun, Handbook
     of Mathematical Functions, Section 13.1.2.

     The only use of this function is in solutions of ODEs returned by
     `odelin' and `contrib_ode'.  The definition and use of this
     function may change in future releases of Maxima.

     See also `kummer_u', `dkummer_m' and `dkummer_u'.

 -- Function: kummer_u (<a>, <b>, <x>)
     Kummer's U function, as defined in Abramowitz and Stegun, Handbook
     of Mathematical Functions, Section 13.1.3.

     See `kummer_m'.

 -- Function: dkummer_m (<a>, <b>, <x>)
     The derivative with respect to <x> of `kummer_m(<a>, <b>, <x>)'.

 -- Function: dkummer_u (<a>, <b>, <x>)
     The derivative with respect to <x> of `kummer_u(<a>, <b>, <x>)'.


File: maxima.info,  Node: Possible improvements to contrib_ode,  Next: Test cases for contrib_ode,  Prev: Functions and Variables for contrib_ode,  Up: contrib_ode

38.3 Possible improvements to contrib_ode
=========================================

These routines are work in progress.  I still need to:

   * Extend the FACTOR method `ode1_factor' to work for multiple roots.

   * Extend the FACTOR method `ode1_factor' to attempt to solve higher
     order factors.  At present it only attemps to solve linear factors.

   * Fix the LAGRANGE routine `ode1_lagrange' to prefer real roots over
      complex roots.

   * Add additional methods for Riccati equations.

   * Improve the detection of Abel equations of second kind.  The
     exisiting   pattern matching is weak.

   * Work on the Lie symmetry group routine `ode1_lie'.  There are
     quite a   few problems with it: some parts are unimplemented; some
     test cases   seem to run forever; other test cases crash; yet
     others return very   complex "solutions".  I wonder if it really
     ready for release yet.

   * Add more test cases.


File: maxima.info,  Node: Test cases for contrib_ode,  Next: References for contrib_ode,  Prev: Possible improvements to contrib_ode,  Up: contrib_ode

38.4 Test cases for contrib_ode
===============================

The routines have been tested on a approximately one thousand  test
cases from Murphy, Kamke, Zwillinger and elsewhere.  These are included
in the tests subdirectory.

   * The Clairault routine `ode1_clairault' finds all known solutions,
     including singular solutions, of the Clairault equations in Murphy
     and   Kamke.

   * The other routines often return a single solution when multiple
     solutions exist.

   * Some of the "solutions" from `ode1_lie' are overly complex and
     impossible to check.

   * There are some crashes.


File: maxima.info,  Node: References for contrib_ode,  Prev: Test cases for contrib_ode,  Up: contrib_ode

38.5 References for contrib_ode
===============================

  1. E. Kamke, Differentialgleichungen Losungsmethoden und Losungen,
     Vol 1,     Geest & Portig, Leipzig, 1961

  2. G. M. Murphy, Ordinary Differential Equations and Their Solutions,
        Van Nostrand, New York, 1960

  3. D. Zwillinger, Handbook of Differential Equations, 3rd edition,
     Academic Press, 1998

  4. F. Schwarz, Symmetry Analysis of Abel's Equation, Studies in
     Applied Mathematics, 100:269-294 (1998)

  5. F. Schwarz, Algorithmic Solution of Abel's Equation,     Computing
     61, 39-49 (1998)

  6. E. S. Cheb-Terrab, A. D. Roche, Symmetries and First Order     ODE
     Patterns, Computer Physics Communications 113 (1998), p 239.
     (`http://lie.uwaterloo.ca/papers/ode_vii.pdf')

  7. E. S. Cheb-Terrab, T. Kolokolnikov,  First Order ODEs,
     Symmetries and Linear Transformations, European Journal of
     Applied Mathematics, Vol. 14, No. 2, pp. 231-246 (2003).
     (`http://arxiv.org/abs/math-ph/0007023',
     `http://lie.uwaterloo.ca/papers/ode_iv.pdf')
  8. G. W. Bluman, S. C. Anco, Symmetry and Integration Methods for
     Differential Equations, Springer, (2002)

  9. M. Bronstein, S. Lafaille, Solutions of linear ordinary
     differential equations in terms of special functions, Proceedings
     of ISSAC 2002, Lille, ACM Press, 23-28.


File: maxima.info,  Node: Package descriptive,  Next: diag,  Prev: contrib_ode,  Up: Top

39 Package descriptive
**********************

* Menu:

* Introduction to descriptive::
* Functions and Variables for data manipulation::
* Functions and Variables for descriptive statistics::
* Functions and Variables for specific multivariate descriptive statistics::
* Functions and Variables for statistical graphs::


File: maxima.info,  Node: Introduction to descriptive,  Next: Functions and Variables for data manipulation,  Prev: Package descriptive,  Up: Package descriptive

39.1 Introduction to descriptive
================================

Package `descriptive' contains a set of functions for making descriptive
statistical computations and graphing.  Together with the source code
there are three data sets in your Maxima tree: `pidigits.data',
`wind.data' and `biomed.data'.

Any statistics manual can be used as a reference to the functions in
package `descriptive'.

For comments, bugs or suggestions, please contact me at <'mario AT edu
DOT xunta DOT es'>.

Here is a simple example on how the descriptive functions in
`descriptive' do they work, depending on the nature of their arguments,
lists or matrices,

     (%i1) load (descriptive)$
     (%i2) /* univariate sample */   mean ([a, b, c]);
                                 c + b + a
     (%o2)                       ---------
                                     3
     (%i3) matrix ([a, b], [c, d], [e, f]);
                                 [ a  b ]
                                 [      ]
     (%o3)                       [ c  d ]
                                 [      ]
                                 [ e  f ]
     (%i4) /* multivariate sample */ mean (%);
                           e + c + a  f + d + b
     (%o4)                [---------, ---------]
                               3          3

Note that in multivariate samples the mean is calculated for each
column.

In case of several samples with possible different sizes, the Maxima
function `map' can be used to get the desired results for each sample,

     (%i1) load (descriptive)$
     (%i2) map (mean, [[a, b, c], [d, e]]);
                             c + b + a  e + d
     (%o2)                  [---------, -----]
                                 3        2

In this case, two samples of sizes 3 and 2 were stored into a list.

Univariate samples must be stored in lists like

     (%i1) s1 : [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];
     (%o1)           [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]

and multivariate samples in matrices as in

     (%i1) s2 : matrix ([13.17, 9.29], [14.71, 16.88], [18.50, 16.88],
                  [10.58, 6.63], [13.33, 13.25], [13.21,  8.12]);
                             [ 13.17  9.29  ]
                             [              ]
                             [ 14.71  16.88 ]
                             [              ]
                             [ 18.5   16.88 ]
     (%o1)                   [              ]
                             [ 10.58  6.63  ]
                             [              ]
                             [ 13.33  13.25 ]
                             [              ]
                             [ 13.21  8.12  ]

In this case, the number of columns equals the random variable
dimension and the number of rows is the sample size.

Data can be introduced by hand, but big samples are usually stored in
plain text files.  For example, file `pidigits.data' contains the first
100 digits of number `%pi':
           3
           1
           4
           1
           5
           9
           2
           6
           5
           3 ...

In order to load these digits in Maxima,

     (%i1) s1 : read_list (file_search ("pidigits.data"))$
     (%i2) length (s1);
     (%o2)                          100

On the other hand, file `wind.data' contains daily average wind speeds
at 5 meteorological stations in the Republic of Ireland (This is part
of a data set taken at 12 meteorological stations.  The original file
is freely downloadable from the StatLib Data Repository and its
analysis is discused in Haslett, J., Raftery, A. E. (1989) <Space-time
Modelling with Long-memory Dependence: Assessing Ireland's Wind Power
Resource, with Discussion>.  Applied Statistics 38, 1-50).  This loads
the data:

     (%i1) s2 : read_matrix (file_search ("wind.data"))$
     (%i2) length (s2);
     (%o2)                          100
     (%i3) s2 [%]; /* last record */
     (%o3)            [3.58, 6.0, 4.58, 7.62, 11.25]

Some samples contain non numeric data.  As an example, file
`biomed.data' (which is part of another bigger one downloaded from the
StatLib Data Repository) contains four blood measures taken from two
groups of patients, `A' and `B', of different ages,

     (%i1) s3 : read_matrix (file_search ("biomed.data"))$
     (%i2) length (s3);
     (%o2)                          100
     (%i3) s3 [1]; /* first record */
     (%o3)            [A, 30, 167.0, 89.0, 25.6, 364]

The first individual belongs to group `A', is 30 years old and his/her
blood measures were 167.0, 89.0, 25.6 and 364.

One must take care when working with categorical data.  In the next
example, symbol `a' is asigned a value in some previous moment and then
a sample with categorical value `a' is taken,

     (%i1) a : 1$
     (%i2) matrix ([a, 3], [b, 5]);
                                 [ 1  3 ]
     (%o2)                       [      ]
                                 [ b  5 ]


File: maxima.info,  Node: Functions and Variables for data manipulation,  Next: Functions and Variables for descriptive statistics,  Prev: Introduction to descriptive,  Up: Package descriptive

39.2 Functions and Variables for data manipulation
==================================================

 -- Function: continuous_freq (<list>)
 -- Function: continuous_freq (<list>, <m>)
     The argument of `continuous_freq' must be a list of numbers.
     Divides the range in intervals and counts how many values are
     inside them.  The second argument is optional and either equals
     the number of classes we want, `10' by default, or equals a list
     containing the class limits and the number of classes we want, or
     a list containing only the limits.  Argument <list> must be a list
     of (2 or 3) real numbers.  If sample values are all equal, this
     function returns only one class of amplitude 2.

     Examples:

     Optional argument indicates the number of classes we want.  The
     first list in the output contains the interval limits, and the
     second the corresponding counts: there are 16 digits inside the
     interval `[0, 1.8]', 24 digits in `(1.8, 3.6]', and so on.

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) continuous_freq (s1, 5);
          (%o3) [[0, 1.8, 3.6, 5.4, 7.2, 9.0], [16, 24, 18, 17, 25]]

     Optional argument indicates we want 7 classes with limits `-2' and
     `12':

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) continuous_freq (s1, [-2,12,7]);
          (%o3) [[- 2, 0, 2, 4, 6, 8, 10, 12], [8, 20, 22, 17, 20, 13, 0]]

     Optional argument indicates we want the default number of classes
     with limits `-2' and `12':

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) continuous_freq (s1, [-2,12]);
                          3  4  11  18     32  39  46  53
          (%o3)  [[- 2, - -, -, --, --, 5, --, --, --, --, 12],
                          5  5  5   5      5   5   5   5
                         [0, 8, 20, 12, 18, 9, 8, 25, 0, 0]]

 -- Function: discrete_freq (<list>)
     Counts absolute frequencies in discrete samples, both numeric and
     categorical.  Its unique argument is a list,

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) discrete_freq (s1);
          (%o3) [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
                                       [8, 8, 12, 12, 10, 8, 9, 8, 12, 13]]

     The first list gives the sample values and the second their
     absolute frequencies.  Commands `? col' and `? transpose' should
     help you to understand the last input.

 -- Function: subsample (<data_matrix>, <predicate_function>)
 -- Function: subsample (<data_matrix>, <predicate_function>,
          <col_num1>, <col_num2>, ...)
     This is a sort of variant of the Maxima `submatrix' function.  The
     first argument is the data matrix, the second is a predicate
     function and optional additional arguments are the numbers of the
     columns to be taken.  Its behaviour is better understood with
     examples.

     These are multivariate records in which the wind speed in the first
     meteorological station were greater than 18.  See that in the
     lambda expression the <i>-th component is refered to as `v[i]'.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) subsample (s2, lambda([v], v[1] > 18));
                        [ 19.38  15.37  15.12  23.09  25.25 ]
                        [                                   ]
                        [ 18.29  18.66  19.08  26.08  27.63 ]
          (%o3)         [                                   ]
                        [ 20.25  21.46  19.95  27.71  23.38 ]
                        [                                   ]
                        [ 18.79  18.96  14.46  26.38  21.84 ]

     In the following example, we request only the first, second and
     fifth components of those records with wind speeds greater or
     equal than 16 in station number 1 and less than 25 knots in
     station number 4.  The sample contains only data from stations 1,
     2 and 5.  In this case, the predicate function is defined as an
     ordinary Maxima function.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) g(x):= x[1] >= 16 and x[4] < 25$
          (%i4) subsample (s2, g, 1, 2, 5);
                               [ 19.38  15.37  25.25 ]
                               [                     ]
                               [ 17.33  14.67  19.58 ]
          (%o4)                [                     ]
                               [ 16.92  13.21  21.21 ]
                               [                     ]
                               [ 17.25  18.46  23.87 ]

     Here is an example with the categorical variables of `biomed.data'.
     We want the records corresponding to those patients in group `B'
     who are older than 38 years.

          (%i1) load (descriptive)$
          (%i2) s3 : read_matrix (file_search ("biomed.data"))$
          (%i3) h(u):= u[1] = B and u[2] > 38 $
          (%i4) subsample (s3, h);
                          [ B  39  28.0  102.3  17.1  146 ]
                          [                               ]
                          [ B  39  21.0  92.4   10.3  197 ]
                          [                               ]
                          [ B  39  23.0  111.5  10.0  133 ]
                          [                               ]
                          [ B  39  26.0  92.6   12.3  196 ]
          (%o4)           [                               ]
                          [ B  39  25.0  98.7   10.0  174 ]
                          [                               ]
                          [ B  39  21.0  93.2   5.9   181 ]
                          [                               ]
                          [ B  39  18.0  95.0   11.3  66  ]
                          [                               ]
                          [ B  39  39.0  88.5   7.6   168 ]

     Probably, the statistical analysis will involve only the blood
     measures,

          (%i1) load (descriptive)$
          (%i2) s3 : read_matrix (file_search ("biomed.data"))$
          (%i3) subsample (s3, lambda([v], v[1] = B and v[2] > 38),
                           3, 4, 5, 6);
                             [ 28.0  102.3  17.1  146 ]
                             [                        ]
                             [ 21.0  92.4   10.3  197 ]
                             [                        ]
                             [ 23.0  111.5  10.0  133 ]
                             [                        ]
                             [ 26.0  92.6   12.3  196 ]
          (%o3)              [                        ]
                             [ 25.0  98.7   10.0  174 ]
                             [                        ]
                             [ 21.0  93.2   5.9   181 ]
                             [                        ]
                             [ 18.0  95.0   11.3  66  ]
                             [                        ]
                             [ 39.0  88.5   7.6   168 ]

     This is the multivariate mean of `s3',

          (%i1) load (descriptive)$
          (%i2) s3 : read_matrix (file_search ("biomed.data"))$
          (%i3) mean (s3);
                 65 B + 35 A  317          6 NA + 8144.999999999999
          (%o3) [-----------, ---, 87.178, ------------------------,
                     100      10                     100
                                                              3 NA + 19587
                                                      18.123, ------------]
                                                                  100

     Here, the first component is meaningless, since `A' and `B' are
     categorical, the second component is the mean age of individuals
     in rational form, and the fourth and last values exhibit some
     strange behaviour.  This is because symbol `NA' is used here to
     indicate <non available> data, and the two means are nonsense.  A
     possible solution would be to take out from the matrix those rows
     with `NA' symbols, although this deserves some loss of information.

          (%i1) load (descriptive)$
          (%i2) s3 : read_matrix (file_search ("biomed.data"))$
          (%i3) g(v):= v[4] # NA and v[6] # NA $
          (%i4) mean (subsample (s3, g, 3, 4, 5, 6));
          (%o4) [79.4923076923077, 86.2032967032967, 16.93186813186813,
                                                                      2514
                                                                      ----]
                                                                       13


File: maxima.info,  Node: Functions and Variables for descriptive statistics,  Next: Functions and Variables for specific multivariate descriptive statistics,  Prev: Functions and Variables for data manipulation,  Up: Package descriptive

39.3 Functions and Variables for descriptive statistics
=======================================================

 -- Function: mean (<list>)
 -- Function: mean (<matrix>)
     This is the sample mean, defined as
                                 n
                               ====
                       _   1   \
                       x = -    >    x
                           n   /      i
                               ====
                               i = 1

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) mean (s1);
                                         471
          (%o3)                          ---
                                         100
          (%i4) %, numer;
          (%o4)                         4.71
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) mean (s2);
          (%o6)     [9.9485, 10.1607, 10.8685, 15.7166, 14.8441]

 -- Function: var (<list>)
 -- Function: var (<matrix>)
     This is the sample variance, defined as
                               n
                             ====
                     2   1   \          _ 2
                    s  = -    >    (x - x)
                         n   /       i
                             ====
                             i = 1

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) var (s1), numer;
          (%o3)                   8.425899999999999

     See also function `var1'.

 -- Function: var1 (<list>)
 -- Function: var1 (<matrix>)
     This is the sample variance, defined as
                               n
                             ====
                         1   \          _ 2
                        ---   >    (x - x)
                        n-1  /       i
                             ====
                             i = 1

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) var1 (s1), numer;
          (%o3)                    8.5110101010101
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) var1 (s2);
          (%o5) [17.39586540404041, 15.13912778787879, 15.63204924242424,
                                      32.50152569696971, 24.66977392929294]

     See also function `var'.

 -- Function: std (<list>)
 -- Function: std (<matrix>)
     This is the the square root of function `var', the variance with
     denominator n.

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) std (s1), numer;
          (%o3)                   2.902740084816414
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) std (s2);
          (%o5) [4.149928523480858, 3.871399812729241, 3.933920277534866,
                                      5.672434260526957, 4.941970881136392]

     See also functions `var' and `std1'.

 -- Function: std1 (<list>)
 -- Function: std1 (<matrix>)
     This is the the square root of function `var1', the variance with
     denominator n-1.

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) std1 (s1), numer;
          (%o3)                   2.917363553109228
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) std1 (s2);
          (%o5) [4.170835096721089, 3.89090320978032, 3.953738641137555,
                                      5.701010936401517, 4.966867617451963]

     See also functions `var1' and `std'.

 -- Function: noncentral_moment (<list>, <k>)
 -- Function: noncentral_moment (<matrix>, <k>)
     The non central moment of order k, defined as
                                 n
                               ====
                           1   \      k
                           -    >    x
                           n   /      i
                               ====
                               i = 1

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) noncentral_moment (s1, 1), numer; /* the mean */
          (%o3)                         4.71
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) noncentral_moment (s2, 5);
          (%o6) [319793.8724761505, 320532.1923892463,
                391249.5621381556, 2502278.205988911, 1691881.797742255]

     See also function `central_moment'.

 -- Function: central_moment (<list>, <k>)
 -- Function: central_moment (<matrix>, <k>)
     The central moment of order k, defined as
                              n
                            ====
                        1   \          _ k
                        -    >    (x - x)
                        n   /       i
                            ====
                            i = 1

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) central_moment (s1, 2), numer; /* the variance */
          (%o3)                   8.425899999999999
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) central_moment (s2, 3);
          (%o6) [11.29584771375004, 16.97988248298583, 5.626661952750102,
                                       37.5986572057918, 25.85981904394192]

     See also functions `central_moment' and `mean'.

 -- Function: cv (<list>)
 -- Function: cv (<matrix>)
     The variation coefficient is the quotient between the sample
     standard deviation (`std') and the `mean',

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) cv (s1), numer;
          (%o3)                   .6193977819764815
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) cv (s2);
          (%o5) [.4192426091090204, .3829365309260502, 0.363779605385983,
                                      .3627381836021478, .3346021393989506]

     See also functions `std' and `mean'.

 -- Function: mini (<list>)
 -- Function: mini (<matrix>)
     This is the minimum value of the sample <list>,

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) mini (s1);
          (%o3)                           0
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) mini (s2);
          (%o5)             [0.58, 0.5, 2.67, 5.25, 5.17]

     See also function `maxi'.

 -- Function: maxi (<list>)
 -- Function: maxi (<matrix>)
     This is the maximum value of the sample <list>,

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) maxi (s1);
          (%o3)                           9
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) maxi (s2);
          (%o5)          [20.25, 21.46, 20.04, 29.63, 27.63]

     See also function `mini'.

 -- Function: range (<list>)
 -- Function: range (<matrix>)
     The range is the difference between the extreme values.

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) range (s1);
          (%o3)                           9
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) range (s2);
          (%o5)          [19.67, 20.96, 17.37, 24.38, 22.46]

 -- Function: quantile (<list>, <p>)
 -- Function: quantile (<matrix>, <p>)
     This is the <p>-quantile, with <p> a number in [0, 1], of the
     sample <list>.  Although there are several definitions for the
     sample quantile (Hyndman, R. J., Fan, Y. (1996) <Sample quantiles
     in statistical packages>.  American Statistician, 50, 361-365),
     the one based on linear interpolation is implemented in package
     `descriptive'.

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) /* 1st and 3rd quartiles */
                   [quantile (s1, 1/4), quantile (s1, 3/4)], numer;
          (%o3)                      [2.0, 7.25]
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) quantile (s2, 1/4);
          (%o5)    [7.2575, 7.477500000000001, 7.82, 11.28, 11.48]

 -- Function: median (<list>)
 -- Function: median (<matrix>)
     Once the sample is ordered, if the sample size is odd the median
     is the central value, otherwise it is the mean of the two central
     values.

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) median (s1);
                                          9
          (%o3)                           -
                                          2
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) median (s2);
          (%o5)         [10.06, 9.855, 10.73, 15.48, 14.105]

     The median is the 1/2-quantile.

     See also function `quantile'.

 -- Function: qrange (<list>)
 -- Function: qrange (<matrix>)
     The interquartilic range is the difference between the third and
     first quartiles, `quantile(<list>,3/4) - quantile(<list>,1/4)',

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) qrange (s1);
                                         21
          (%o3)                          --
                                         4
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) qrange (s2);
          (%o5) [5.385, 5.572499999999998, 6.022500000000001,
                                      8.729999999999999, 6.649999999999999]

     See also function `quantile'.

 -- Function: mean_deviation (<list>)
 -- Function: mean_deviation (<matrix>)
     The mean deviation, defined as
                               n
                             ====
                         1   \          _
                         -    >    |x - x|
                         n   /       i
                             ====
                             i = 1

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) mean_deviation (s1);
                                         51
          (%o3)                          --
                                         20
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) mean_deviation (s2);
          (%o5) [3.287959999999999, 3.075342, 3.23907, 4.715664000000001,
                                                         4.028546000000002]

     See also function `mean'.

 -- Function: median_deviation (<list>)
 -- Function: median_deviation (<matrix>)
     The median deviation, defined as
                           n
                         ====
                     1   \
                     -    >    |x - med|
                     n   /       i
                         ====
                         i = 1
     where `med' is the median of <list>.

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) median_deviation (s1);
                                          5
          (%o3)                           -
                                          2
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) median_deviation (s2);
          (%o5)           [2.75, 2.755, 3.08, 4.315, 3.31]

     See also function `mean'.

 -- Function: harmonic_mean (<list>)
 -- Function: harmonic_mean (<matrix>)
     The harmonic mean, defined as
                            n
                         --------
                          n
                         ====
                         \     1
                          >    --
                         /     x
                         ====   i
                         i = 1

     Example:

          (%i1) load (descriptive)$
          (%i2) y : [5, 7, 2, 5, 9, 5, 6, 4, 9, 2, 4, 2, 5]$
          (%i3) harmonic_mean (y), numer;
          (%o3)                   3.901858027632205
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) harmonic_mean (s2);
          (%o5) [6.948015590052786, 7.391967752360356, 9.055658197151745,
                                      13.44199028193692, 13.01439145898509]

     See also functions `mean' and `geometric_mean'.

 -- Function: geometric_mean (<list>)
 -- Function: geometric_mean (<matrix>)
     The geometric mean, defined as
                           /  n      \ 1/n
                           | /===\   |
                           |  ! !    |
                           |  ! !  x |
                           |  ! !   i|
                           | i = 1   |
                           \         /

     Example:

          (%i1) load (descriptive)$
          (%i2) y : [5, 7, 2, 5, 9, 5, 6, 4, 9, 2, 4, 2, 5]$
          (%i3) geometric_mean (y), numer;
          (%o3)                   4.454845412337012
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) geometric_mean (s2);
          (%o5) [8.82476274347979, 9.22652604739361, 10.0442675714889,
                                      14.61274126349021, 13.96184163444275]

     See also functions `mean' and `harmonic_mean'.

 -- Function: kurtosis (<list>)
 -- Function: kurtosis (<matrix>)
     The kurtosis coefficient, defined as
                              n
                            ====
                      1     \          _ 4
                     ----    >    (x - x)  - 3
                        4   /       i
                     n s    ====
                            i = 1

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) kurtosis (s1), numer;
          (%o3)                  - 1.273247946514421
          (%i4) s2 : read_matrix (file_search ("wind.data"))$

          (%i5) kurtosis (s2);
          (%o5) [- .2715445622195385, 0.119998784429451,
             - .4275233490482861, - .6405361979019522, - .4952382132352935]

     See also functions `mean', `var' and `skewness'.

 -- Function: skewness (<list>)
 -- Function: skewness (<matrix>)
     The skewness coefficient, defined as
                              n
                            ====
                      1     \          _ 3
                     ----    >    (x - x)
                        3   /       i
                     n s    ====
                            i = 1

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) skewness (s1), numer;
          (%o3)                  .009196180476450424
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) skewness (s2);
          (%o5) [.1580509020000978, .2926379232061854, .09242174416107717,
                                      .2059984348148687, .2142520248890831]

     See also functions `mean', `var' and `kurtosis'.

 -- Function: pearson_skewness (<list>)
 -- Function: pearson_skewness (<matrix>)
     Pearson's skewness coefficient, defined as
                          _
                       3 (x - med)
                       -----------
                            s
     where <med> is the median of <list>.

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) pearson_skewness (s1), numer;
          (%o3)                   .2159484029093895
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) pearson_skewness (s2);
          (%o5) [- .08019976629211892, .2357036272952649,
                   .1050904062491204, .1245042340592368, .4464181795804519]

     See also functions `mean', `var' and `median'.

 -- Function: quartile_skewness (<list>)
 -- Function: quartile_skewness (<matrix>)
     The quartile skewness coefficient, defined as
                         c    - 2 c    + c
                          3/4      1/2    1/4
                         --------------------
                             c    - c
                              3/4    1/4
     where c_p is the <p>-quantile of sample <list>.

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) quartile_skewness (s1), numer;
          (%o3)                  .04761904761904762
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) quartile_skewness (s2);
          (%o5) [- 0.0408542246982353, .1467025572005382,
                 0.0336239103362392, .03780068728522298, .2105263157894735]

     See also function `quantile'.


File: maxima.info,  Node: Functions and Variables for specific multivariate descriptive statistics,  Next: Functions and Variables for statistical graphs,  Prev: Functions and Variables for descriptive statistics,  Up: Package descriptive

39.4 Functions and Variables for specific multivariate descriptive statistics
=============================================================================

 -- Function: cov (<matrix>)
     The covariance matrix of the multivariate sample, defined as
                        n
                       ====
                    1  \           _        _
                S = -   >    (X  - X) (X  - X)'
                    n  /       j        j
                       ====
                       j = 1
     where X_j is the j-th row of the sample matrix.

     Example:

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) fpprintprec : 7$  /* change precision for pretty output */
          (%i4) cov (s2);
                [ 17.22191  13.61811  14.37217  19.39624  15.42162 ]
                [                                                  ]
                [ 13.61811  14.98774  13.30448  15.15834  14.9711  ]
                [                                                  ]
          (%o4) [ 14.37217  13.30448  15.47573  17.32544  16.18171 ]
                [                                                  ]
                [ 19.39624  15.15834  17.32544  32.17651  20.44685 ]
                [                                                  ]
                [ 15.42162  14.9711   16.18171  20.44685  24.42308 ]

     See also function `cov1'.

 -- Function: cov1 (<matrix>)
     The covariance matrix of the multivariate sample, defined as
                        n
                       ====
                   1   \           _        _
             S  = ---   >    (X  - X) (X  - X)'
              1   n-1  /       j        j
                       ====
                       j = 1
     where X_j is the j-th row of the sample matrix.

     Example:

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) fpprintprec : 7$ /* change precision for pretty output */
          (%i4) cov1 (s2);
                [ 17.39587  13.75567  14.51734  19.59216  15.5774  ]
                [                                                  ]
                [ 13.75567  15.13913  13.43887  15.31145  15.12232 ]
                [                                                  ]
          (%o4) [ 14.51734  13.43887  15.63205  17.50044  16.34516 ]
                [                                                  ]
                [ 19.59216  15.31145  17.50044  32.50153  20.65338 ]
                [                                                  ]
                [ 15.5774   15.12232  16.34516  20.65338  24.66977 ]

     See also function `cov'.

 -- Function: global_variances (<matrix>)
 -- Function: global_variances (<matrix>, <logical_value>)
     Function `global_variances' returns a list of global variance
     measures:

        * <total variance>: `trace(S_1)',

        * <mean variance>: `trace(S_1)/p',

        * <generalized variance>: `determinant(S_1)',

        * <generalized standard deviation>: `sqrt(determinant(S_1))',

        * <efective variance> `determinant(S_1)^(1/p)', (defined in:
          Pea, D.  (2002) <Anlisis de datos multivariantes>;
          McGraw-Hill, Madrid.)

        * <efective standard deviation>: `determinant(S_1)^(1/(2*p))'.
     where <p> is the dimension of the multivariate random variable and
     S_1 the covariance matrix returned by `cov1'.

     Example:

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) global_variances (s2);
          (%o3) [105.338342060606, 21.06766841212119, 12874.34690469686,
                   113.4651792608501, 6.636590811800795, 2.576158149609762]

     Function `global_variances' has an optional logical argument:
     `global_variances (x, true)' tells Maxima that `x' is the data
     matrix, making the same as `global_variances(x)'.  On the other
     hand, `global_variances(x, false)' means that `x' is not the data
     matrix, but the covariance matrix, avoiding its recalculation,

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) s : cov1 (s2)$
          (%i4) global_variances (s, false);
          (%o4) [105.338342060606, 21.06766841212119, 12874.34690469686,
                   113.4651792608501, 6.636590811800795, 2.576158149609762]

     See also `cov' and `cov1'.

 -- Function: cor (<matrix>)
 -- Function: cor (<matrix>, <logical_value>)
     The correlation matrix of the multivariate sample.

     Example:

          (%i1) load (descriptive)$
          (%i2) fpprintprec : 7 $
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) cor (s2);
                [   1.0     .8476339  .8803515  .8239624  .7519506 ]
                [                                                  ]
                [ .8476339    1.0     .8735834  .6902622  0.782502 ]
                [                                                  ]
          (%o4) [ .8803515  .8735834    1.0     .7764065  .8323358 ]
                [                                                  ]
                [ .8239624  .6902622  .7764065    1.0     .7293848 ]
                [                                                  ]
                [ .7519506  0.782502  .8323358  .7293848    1.0    ]

     Function `cor' has an optional logical argument: `cor(x,true)'
     tells Maxima that `x' is the data matrix, making the same as
     `cor(x)'.  On the other hand, `cor(x,false)' means that `x' is not
     the data matrix, but the covariance matrix, avoiding its
     recalculation,

          (%i1) load (descriptive)$
          (%i2) fpprintprec : 7 $
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) s : cov1 (s2)$
          (%i5) cor (s, false); /* this is faster */
                [   1.0     .8476339  .8803515  .8239624  .7519506 ]
                [                                                  ]
                [ .8476339    1.0     .8735834  .6902622  0.782502 ]
                [                                                  ]
          (%o5) [ .8803515  .8735834    1.0     .7764065  .8323358 ]
                [                                                  ]
                [ .8239624  .6902622  .7764065    1.0     .7293848 ]
                [                                                  ]
                [ .7519506  0.782502  .8323358  .7293848    1.0    ]

     See also `cov' and `cov1'.

 -- Function: list_correlations (<matrix>)
 -- Function: list_correlations (<matrix>, <logical_value>)
     Function `list_correlations' returns a list of correlation
     measures:

        * <precision matrix>: the inverse of the covariance matrix S_1,
                      -1     ij
                     S   = (s  )
                      1         i,j = 1,2,...,p

        * <multiple correlation vector>:  (R_1^2, R_2^2, ..., R_p^2),
          with
                      2          1
                     R  = 1 - -------
                      i        ii
                              s   s
                                   ii
          being an indicator of the goodness of fit of the linear
          multivariate regression model on X_i when the rest of
          variables are used as regressors.

        * <partial correlation matrix>: with element (i, j) being
                                        ij
                                       s
                     r        = - ------------
                      ij.rest     / ii  jj\ 1/2
                                  |s   s  |
                                  \       /


     Example:

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) z : list_correlations (s2)$
          (%i4) fpprintprec : 5$ /* for pretty output */
          (%i5) z[1];  /* precision matrix */
                [  .38486   - .13856   - .15626   - .10239    .031179  ]
                [                                                      ]
                [ - .13856   .34107    - .15233    .038447   - .052842 ]
                [                                                      ]
          (%o5) [ - .15626  - .15233    .47296    - .024816  - .10054  ]
                [                                                      ]
                [ - .10239   .038447   - .024816   .10937    - .034033 ]
                [                                                      ]
                [ .031179   - .052842  - .10054   - .034033   .14834   ]
          (%i6) z[2];  /* multiple correlation vector */
          (%o6)      [.85063, .80634, .86474, .71867, .72675]
          (%i7) z[3];  /* partial correlation matrix */
                [  - 1.0     .38244   .36627   .49908   - .13049 ]
                [                                                ]
                [  .38244    - 1.0    .37927  - .19907   .23492  ]
                [                                                ]
          (%o7) [  .36627    .37927   - 1.0    .10911    .37956  ]
                [                                                ]
                [  .49908   - .19907  .10911   - 1.0     .26719  ]
                [                                                ]
                [ - .13049   .23492   .37956   .26719    - 1.0   ]

     Function `list_correlations' also has an optional logical argument:
     `list_correlations(x,true)' tells Maxima that `x' is the data
     matrix, making the same as `list_correlations(x)'.  On the other
     hand, `list_correlations(x,false)' means that `x' is not the data
     matrix, but the covariance matrix, avoiding its recalculation.

     See also `cov' and `cov1'.


File: maxima.info,  Node: Functions and Variables for statistical graphs,  Prev: Functions and Variables for specific multivariate descriptive statistics,  Up: Package descriptive

39.5 Functions and Variables for statistical graphs
===================================================

 -- Function: barsplot (<data1>, <data2>, ..., <option_1>, <option_2>,
          ...)
 -- Function: barsplot_description (...)
     Plots bars diagrams for discrete statistical variables, both for
     one or multiple samples.

     <data> can be a list of outcomes representing one sample, or a
     matrix of <m> rows and <n> columns, representing <n> samples of
     size <m> each.

     Available options are:

        * <box_width> (default, `3/4'): relative width of rectangles.
          This value must be in the range `[0,1]'.

        * <grouping> (default, `clustered'): indicates how multiple
          samples are shown.  Valid values are: `clustered' and
          `stacked'.

        * <groups_gap> (default, `1'): a positive integer number
          representing the gap between two consecutive groups of bars.

        * <bars_colors> (default, `[]'): a list of colors for multiple
          samples.  When there are more samples than specified colors,
          the extra necesary colors are chosen at random.  See `color'
          to learn more about them.

        * <frequency> (default, `absolute'): indicates the scale of the
          ordinates.  Possible values are:  `absolute', `relative', and
          `percent'.

        * <ordering> (default, `orderlessp'): possible values are
          `orderlessp' or `ordergreatp', indicating how statistical
          outcomes should be ordered on the `x'-axis.

        * <sample_keys> (default, `[]'): a list with the strings to be
          used in the legend.  When the list length is other than `0'
          or the number of samples, an error message is returned.

        * <start_at> (default, `0'): indicates where the plot begins to
          be plotted on the `x'-axis.

        * All global `draw' options, except `xtics', which is
          internally assigned by `barsplot'.  If you want to set your
          own values for this option or want to build complex scenes,
          make use of `barsplot_description'.  See example below.

        * The following local `draw' options: `key', `color',
          `fill_color', `fill_density' and `line_width'.  See also
          `bars'.


     Function `barsplot_description' creates a graphic object suitable
     for creating complex scenes, together with other graphic objects.
     There is also a function `wxbarsplot' for creating embedded
     histograms in interfaces wxMaxima and iMaxima.

     Examples:

     Univariate sample in matrix form.  Absolute frequencies.

          (%i1) load (descriptive)$
          (%i2) m : read_matrix (file_search ("biomed.data"))$
          (%i3) barsplot(
                  col(m,2),
                  title        = "Ages",
                  xlabel       = "years",
                  box_width    = 1/2,
                  fill_density = 3/4)$

     Two samples of different sizes, with relative frequencies and user
     declared colors.

          (%i1) load (descriptive)$
          (%i2) l1:makelist(random(10),k,1,50)$
          (%i3) l2:makelist(random(10),k,1,100)$
          (%i4) barsplot(
                  l1,l2,
                  box_width    = 1,
                  fill_density = 1,
                  bars_colors  = [black, grey],
                  frequency = relative,
                  sample_keys = ["A", "B"])$

     Four non numeric samples of equal size.

          (%i1) load (descriptive)$
          (%i2) barsplot(
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  title  = "Asking for something to four groups",
                  ylabel = "# of individuals",
                  groups_gap   = 3,
                  fill_density = 0.5,
                  ordering     = ordergreatp)$

     Stacked bars.

          (%i1) load (descriptive)$
          (%i2) barsplot(
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  title  = "Asking for something to four groups",
                  ylabel = "# of individuals",
                  grouping     = stacked,,
                  fill_density = 0.5,
                  ordering     = ordergreatp)$

     `barsplot' in a multiplot context.

          (%i1) load (descriptive)$
          (%i2) l1:makelist(random(10),k,1,50)$
          (%i3) l2:makelist(random(10),k,1,100)$
          (%i4) bp1 :
                  barsplot_description(
                   l1,
                   box_width = 1,
                   fill_density = 0.5,
                   bars_colors = [blue],
                   frequency = relative)$
          (%i5) bp2 :
                  barsplot_description(
                   l2,
                   box_width = 1,
                   fill_density = 0.5,
                   bars_colors = [red],
                   frequency = relative)$
          (%i6) draw(gr2d(bp1), gr2d(bp2))$

     For bars diagrams related options, see `bars'  of package `draw'.
     See also functions `histogram'  and `piechart'.


 -- Function: boxplot (<data>)
 -- Function: boxplot (<data>, <option_1>, <option_2>, ...)
 -- Function: boxplot_description (...)
     This function plots box-and-whishker diagrams.  Argument <data>
     can be a list, which is not of great interest, since these
     diagrams are mainly used for comparing different samples, or a
     matrix, so it is possible to compare two or more components of a
     multivariate statistical variable.  But it is also allowed <data>
     to be a list of samples with possible different sample sizes, in
     fact this is the only function in package `descriptive' that
     admits this type of data structure.

     Available options are:

        * <box_width> (default, `3/4'): relative width of boxes.  This
          value must be in the range `[0,1]'.

        * <box_orientation> (default, `vertical'): possible values:
          `vertical' and `horizontal'.

        * All `draw' options, except `points_joined', `point_size',
          `point_type', `xtics', `ytics', `xrange', and `yrange', which
          are internally assigned by `boxplot'.  If you want to set
          your own values for this options or want to build complex
          scenes, make use of `boxplot_description'.

        * The following local `draw' options: `key', `color', and
          `line_width'.


     Function `boxplot_description' creates a graphic object suitable
     for creating complex scenes, together with other graphic objects.
     There is also a function `wxboxplot' for creating embedded
     histograms in interfaces wxMaxima and iMaxima.

     Examples:

     Box-and-whishker diagram from a multivariate sample.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix(file_search("wind.data"))$
          (%i3) boxplot(s2,
                  box_width  = 0.2,
                  title      = "Windspeed in knots",
                  xlabel     = "Stations",
                  color      = red,
                  line_width = 2)$

     Box-and-whishker diagram from three samples of different sizes.

          (%i1) load (descriptive)$
          (%i2) A :
                 [[6, 4, 6, 2, 4, 8, 6, 4, 6, 4, 3, 2],
                  [8, 10, 7, 9, 12, 8, 10],
                  [16, 13, 17, 12, 11, 18, 13, 18, 14, 12]]$
          (%i3) boxplot (A, box_orientation = horizontal)$

 -- Function: histogram (<list>)
 -- Function: histogram (<list>, <option_1>, <option_2>, ...)
 -- Function: histogram (<one_column_matrix>)
 -- Function: histogram (<one_column_matrix>, <option_1>, <option_2>,
          ...)
 -- Function: histogram (<one_row_matrix>)
 -- Function: histogram (<one_row_matrix>, <option_1>, <option_2>, ...)
 -- Function: histogram_description (...)
     This function plots an histogram from a continuous sample.  Sample
     data must be stored in a list of numbers or a one dimensional
     matrix.

     Available options are:

        * <nclasses> (default, `10'): number of classes of the
          histogram, or a list indicating the limits of the classes and
          the number of them, or only the limits.

        * <frequency> (default, `absolute'): indicates the scale of the
          ordinates.  Possible values are:  `absolute', `relative', and
          `percent'.

        * <htics> (default, `auto'): format of the histogram tics.
          Possible values are: `auto', `endpoints', `intervals', or a
          list of labels.

        * All global `draw' options, except `xrange', `yrange', and
          `xtics', which are internally assigned by `histogram'.  If
          you want to set your own values for these options, make use of
          `histogram_description'.  See examples bellow.

        * The following local `draw' options: `key', `color',
          `fill_color', `fill_density' and `line_width'.  See also
          `bars'.

     Function `histogram_description' creates a graphic object suitable
     for creating complex scenes, together with other graphic objects.
     There is also a function `wxhistogram' for creating embedded
     histograms in interfaces wxMaxima and iMaxima.

     Examples:

     A simple with eight classes:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) histogram (
                     s1,
                     nclasses     = 8,
                     title        = "pi digits",
                     xlabel       = "digits",
                     ylabel       = "Absolute frequency",
                     fill_color   = grey,
                     fill_density = 0.6)$

     Setting the limits of the histogram to -2 and 12, with 3 classes.
     Also, we introduce predefined tics:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) histogram (
                     s1,
                     nclasses     = [-2,12,3],
                     htics        = ["A", "B", "C"],
                     terminal     = png,
                     fill_color   = "#23afa0",
                     fill_density = 0.6)$

     We make use of `histogram_description' for setting the `xrange'
     and adding an explicit curve into the scene:

          (%i1) load (descriptive)$
          (%i2) ( load("distrib"),
                  m: 14, s: 2,
                  s2: random_normal(m, s, 1000) ) $
          (%i3) draw2d(
                  grid   = true,
                  xrange = [5, 25],
                  histogram_description(
                    s2,
                    nclasses     = 9,
                    frequency    = relative,
                    fill_density = 0.5),
                  explicit(pdf_normal(x,m,s), x, m - 3*s, m + 3* s))$

 -- Function: piechart (<list>)
 -- Function: piechart (<list>, <option_1>, <option_2>, ...)
 -- Function: piechart (<one_column_matrix>)
 -- Function: piechart (<one_column_matrix>, <option_1>, <option_2>,
          ...)
 -- Function: piechart (<one_row_matrix>)
 -- Function: piechart (<one_row_matrix>, <option_1>, <option_2>, ...)
 -- Function: piechart_description (...)
     Similar to `barsplot',  but plots sectors instead of rectangles.

     Available options are:

        * <sector_colors> (default, `[]'): a list of colors for sectors.
          When there are more sectors than specified colors, the extra
          necesary colors are chosen at random.  See `color'  to learn
          more about them.

        * <pie_center> (default, `[0,0]'): diagram's center.

        * <pie_radius> (default, `1'): diagram's radius.

        * All global `draw' options, except `key', which is internally
          assigned by `piechart'.  If you want to set your own values
          for this option or want to build complex scenes, make use of
          `piechart_description'.

        * The following local `draw' options: `key', `color',
          `fill_density' and `line_width'.  See also `ellipse'.


     Function `piechart_description' creates a graphic object suitable
     for creating complex scenes, together with other graphic objects.
     There is also a function `wxpiechart' for creating embedded
     histograms in interfaces wxMaxima and iMaxima.

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) piechart(
                  s1,
                  xrange  = [-1.1, 1.3],
                  yrange  = [-1.1, 1.1],
                  title   = "Digit frequencies in pi")$

     See also function `barsplot'.


 -- Function: scatterplot (<list>)
 -- Function: scatterplot (<list>, <option_1>, <option_2>, ...)
 -- Function: scatterplot (<matrix>)
 -- Function: scatterplot (<matrix>, <option_1>, <option_2>, ...)
 -- Function: scatterplot_description (...)
     Plots scatter diagrams both for univariate (<list>) and
     multivariate (<matrix>) samples.

     Available options are the same admitted by `histogram'.

     Function `scatterplot_description' creates a graphic object
     suitable for creating complex scenes, together with other graphic
     objects.  There is also a function `wxscatterplot' for creating
     embedded histograms in interfaces wxMaxima and iMaxima.

     Examples:

     Univariate scatter diagram from a simulated Gaussian sample.

          (%i1) load (descriptive)$
          (%i2) load (distrib)$
          (%i3) scatterplot(
                  random_normal(0,1,200),
                  xaxis      = true,
                  point_size = 2,
                  dimensions = [600,150])$

     Two dimensional scatter plot.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) scatterplot(
                 submatrix(s2, 1,2,3),
                 title      = "Data from stations #4 and #5",
                 point_type = diamant,
                 point_size = 2,
                 color      = blue)$

     Three dimensional scatter plot.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) scatterplot(submatrix (s2, 1,2), nclasses=4)$

     Five dimensional scatter plot, with five classes histograms.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) scatterplot(
                  s2,
                  nclasses     = 5,
                  frequency    = relative,
                  fill_color   = blue,
                  fill_density = 0.3,
                  xtics        = 5)$

     For plotting isolated or line-joined points in two and three
     dimensions, see `points'.    See also `histogram'.


 -- Function: starplot (<data1>, <data2>, ..., <option_1>, <option_2>,
          ...)
 -- Function: starplot_description (...)
     Plots star diagrams for discrete statistical variables, both for
     one or multiple samples.

     <data> can be a list of outcomes representing one sample, or a
     matrix of <m> rows and <n> columns, representing <n> samples of
     size <m> each.

     Available options are:

        * <stars_colors> (default, `[]'): a list of colors for multiple
          samples.  When there are more samples than specified colors,
          the extra necesary colors are chosen at random.  See `color'
          to learn more about them.

        * <frequency> (default, `absolute'): indicates the scale of the
          radii.  Possible values are: `absolute' and `relative'.

        * <ordering> (default, `orderlessp'): possible values are
          `orderlessp' or `ordergreatp', indicating how statistical
          outcomes should be ordered.

        * <sample_keys> (default, `[]'): a list with the strings to be
          used in the legend.  When the list length is other than 0 or
          the number of samples, an error message is returned.

        * <star_center> (default, `[0,0]'): diagram's center.

        * <star_radius> (default, `1'): diagram's radius.

        * All global `draw' options, except `points_joined',
          `point_type', and `key', which are internally assigned by
          `starplot'.  If you want to set your own values for this
          options or want to build complex scenes, make use of
          `starplot_description'.

        * The following local `draw' option: `line_width'.

     Function `starplot_description' creates a graphic object suitable
     for creating complex scenes, together with other graphic objects.
     There is also a function `wxstarplot' for creating embedded
     histograms in interfaces wxMaxima and iMaxima.

     Example:

     Plot based on absolute frequencies.  Location and radius defined
     by the user.

          (%i1) load (descriptive)$
          (%i2) l1: makelist(random(10),k,1,50)$
          (%i3) l2: makelist(random(10),k,1,200)$
          (%i4) starplot(
                  l1, l2,
                  stars_colors = [blue,red],
                  sample_keys = ["1st sample", "2nd sample"],
                  star_center = [1,2],
                  star_radius = 4,
                  proportional_axes = xy,
                  line_width = 2 ) $

 -- Function: stemplot (<data>)
 -- Function: stemplot (<data>, <option>)
     Plots stem and leaf diagrams.  Unique available option is:

        * <leaf_unit> (default, `1'): indicates the unit of the leaves;
          must be a power of `10'.

     Example:

          (%i1) load (descriptive)$
          (%i2) load(distrib)$
          (%i3) stemplot(
                  random_normal(15, 6, 100),
                  leaf_unit = 0.1);
          -5|4
           0|37
           1|7
           3|6
           4|4
           5|4
           6|57
           7|0149
           8|3
           9|1334588
          10|07888
          11|01144467789
          12|12566889
          13|24778
          14|047
          15|223458
          16|4
          17|11557
          18|000247
          19|4467799
          20|00
          21|1
          22|2335
          23|01457
          24|12356
          25|455
          27|79
          key: 6|3 =  6.3
          (%o3)                  done


File: maxima.info,  Node: diag,  Next: Package distrib,  Prev: Package descriptive,  Up: Top

40 diag
*******

* Menu:

* Functions and Variables for diag::


File: maxima.info,  Node: Functions and Variables for diag,  Prev: diag,  Up: diag

40.1 Functions and Variables for diag
=====================================

 -- Function: diag (<lm>)
     Constructs a square matrix with the matrices of <lm> in the
     diagonal.  <lm> is a list of matrices or scalars.

     Example:

          (%i1) load("diag")$
          (%i2) a1:matrix([1,2,3],[0,4,5],[0,0,6])$
          (%i3) a2:matrix([1,1],[1,0])$
          (%i4) diag([a1,x,a2]);

                             [ 1  2  3  0  0  0 ]
                             [                  ]
                             [ 0  4  5  0  0  0 ]
                             [                  ]
                             [ 0  0  6  0  0  0 ]
          (%o4)              [                  ]
                             [ 0  0  0  x  0  0 ]
                             [                  ]
                             [ 0  0  0  0  1  1 ]
                             [                  ]
                             [ 0  0  0  0  1  0 ]

     To use this function write first `load("diag")'.

 -- Function: JF (<lambda>, <n>)
     Returns the Jordan cell of order <n> with eigenvalue <lambda>.

     Example:

          (%i1) load("diag")$
          (%i2) JF(2,5);

                              [ 2  1  0  0  0 ]
                              [               ]
                              [ 0  2  1  0  0 ]
                              [               ]
          (%o2)               [ 0  0  2  1  0 ]
                              [               ]
                              [ 0  0  0  2  1 ]
                              [               ]
                              [ 0  0  0  0  2 ]

          (%i3) JF(3,2);
                                   [ 3  1 ]
          (%o3)                    [      ]
                                   [ 0  3 ]

     To use this function write first `load("diag")'.

 -- Function: jordan (<mat>)
     Returns the Jordan form of matrix <mat>, but codified in a Maxima
     list.  To get the corresponding matrix, call function `dispJordan'
     using as argument the output of `jordan'.

     Example:

          (%i1) load("diag")$
          (%i3) a:matrix([2,0,0,0,0,0,0,0],
                         [1,2,0,0,0,0,0,0],
                         [-4,1,2,0,0,0,0,0],
                         [2,0,0,2,0,0,0,0],
                         [-7,2,0,0,2,0,0,0],
                         [9,0,-2,0,1,2,0,0],
                         [-34,7,1,-2,-1,1,2,0],
                         [145,-17,-16,3,9,-2,0,3])$
          (%i34) jordan(a);
          (%o4)             [[2, 3, 3, 1], [3, 1]]
          (%i5) dispJordan(%);
                          [ 2  1  0  0  0  0  0  0 ]
                          [                        ]
                          [ 0  2  1  0  0  0  0  0 ]
                          [                        ]
                          [ 0  0  2  0  0  0  0  0 ]
                          [                        ]
                          [ 0  0  0  2  1  0  0  0 ]
          (%o5)           [                        ]
                          [ 0  0  0  0  2  1  0  0 ]
                          [                        ]
                          [ 0  0  0  0  0  2  0  0 ]
                          [                        ]
                          [ 0  0  0  0  0  0  2  0 ]
                          [                        ]
                          [ 0  0  0  0  0  0  0  3 ]

     To use this function write first `load("diag")'. See also
     `dispJordan' and `minimalPoly'.

 -- Function: dispJordan (<l>)
     Returns the Jordan matrix associated to the codification given by
     the Maxima list <l>, which is the output given by function
     `jordan'.

     Example:

          (%i1) load("diag")$
          (%i2) b1:matrix([0,0,1,1,1],
                          [0,0,0,1,1],
                          [0,0,0,0,1],
                          [0,0,0,0,0],
                          [0,0,0,0,0])$
          (%i3) jordan(b1);
          (%o3)                  [[0, 3, 2]]
          (%i4) dispJordan(%);
                              [ 0  1  0  0  0 ]
                              [               ]
                              [ 0  0  1  0  0 ]
                              [               ]
          (%o4)               [ 0  0  0  0  0 ]
                              [               ]
                              [ 0  0  0  0  1 ]
                              [               ]
                              [ 0  0  0  0  0 ]

     To use this function write first `load("diag")'. See also `jordan'
     and `minimalPoly'.

 -- Function: minimalPoly (<l>)
     Returns the minimal polynomial associated to the codification
     given by the Maxima list <l>, which is the output given by
     function `jordan'.

     Example:

          (%i1) load("diag")$
          (%i2) a:matrix([2,1,2,0],
                         [-2,2,1,2],
                         [-2,-1,-1,1],
                         [3,1,2,-1])$
          (%i3) jordan(a);
          (%o3)               [[- 1, 1], [1, 3]]
          (%i4) minimalPoly(%);
                                      3
          (%o4)                (x - 1)  (x + 1)

     To use this function write first `load("diag")'. See also `jordan'
     and `dispJordan'.

 -- Function: ModeMatrix (<A>,<l>)
     Returns the matrix <M> such that (M^^-1).A.M=J, where <J> is the
     Jordan form of <A>. The Maxima list <l> is the codified form of
     the Jordan form as returned by function `jordan'.

     Example:

          (%i1) load("diag")$
          (%i2) a:matrix([2,1,2,0],
                    [-2,2,1,2],
                    [-2,-1,-1,1],
                    [3,1,2,-1])$

          (%i3) jordan(a);
          (%o3)               [[- 1, 1], [1, 3]]
          (%i4) M: ModeMatrix(a,%);

                            [  1    - 1   1   1 ]
                            [                   ]
                            [   1               ]
                            [ - -   - 1   0   0 ]
                            [   9               ]
                            [                   ]
          (%o4)             [   13              ]
                            [ - --   1   - 1  0 ]
                            [   9               ]
                            [                   ]
                            [  17               ]
                            [  --   - 1   1   1 ]
                            [  9                ]

          (%i5) is(  (M^^-1).a.M = dispJordan(%o3)  );
          (%o5)                      true

     Note that `dispJordan(%o3)' is the Jordan form of matrix `a'.

     To use this function write first `load("diag")'. See also `jordan'
     and `dispJordan'.

 -- Function: mat_function (<f>,<mat>)
     Returns f(mat), where <f> is an analytic function and <mat> a
     matrix. This computation is based on Cauchy's integral formula,
     which states that if `f(x)' is analytic and `mat =
     diag([JF(m1,n1), ..., JF(mk,nk)])', then `f(mat) = ModeMatrix *
     diag([f(JF(m1,n1)), ..., f(JF(mk,nk))]) * ModeMatrix^^(-1)'.  Note
     that there are about 6 or 8 other methods for this calculation.
     Some examples follow.

     To use this function write first `load(diag)'.

     Example 1:

          (%i1) load("diag")$
          (%i2) b2:matrix([0,1,0], [0,0,1], [-1,-3,-3])$
          (%i3) mat_function(exp,t*b2);
                         2   - t
                        t  %e          - t     - t
          (%o3) matrix([-------- + t %e    + %e   ,
                           2
                  - t     - t                           - t
           2    %e      %e        - t           - t   %e
          t  (- ----- - ----- + %e   ) + t (2 %e    - -----)
                  t       2                             t
                         t
                                   - t          - t     - t
                 - t       - t   %e        2  %e      %e
           + 2 %e   , t (%e    - -----) + t  (----- - -----)
                                   t            2       t
                         2   - t            - t     - t
               - t      t  %e        2    %e      %e        - t
           + %e   ], [- --------, - t  (- ----- - ----- + %e   ),
                           2                t       2
                                                   t
                  - t     - t      2   - t
             2  %e      %e        t  %e          - t
          - t  (----- - -----)], [-------- - t %e   ,
                  2       t          2
                  - t     - t                           - t
           2    %e      %e        - t           - t   %e
          t  (- ----- - ----- + %e   ) - t (2 %e    - -----),
                  t       2                             t
                         t
                - t     - t                 - t
           2  %e      %e            - t   %e
          t  (----- - -----) - t (%e    - -----)])
                2       t                   t

          (%i4) ratsimp(%);
                         [   2              - t ]
                         [ (t  + 2 t + 2) %e    ]
                         [ -------------------- ]
                         [          2           ]
                         [                      ]
                         [         2   - t      ]
          (%o4)  Col 1 = [        t  %e         ]
                         [      - --------      ]
                         [           2          ]
                         [                      ]
                         [     2          - t   ]
                         [   (t  - 2 t) %e      ]
                         [   ----------------   ]
                         [          2           ]

                   [      2        - t    ]
                   [    (t  + t) %e       ]
                   [                      ]
           Col 2 = [     2            - t ]
                   [ - (t  - t - 1) %e    ]
                   [                      ]
                   [     2          - t   ]
                   [   (t  - 3 t) %e      ]

                   [        2   - t       ]
                   [       t  %e          ]
                   [       --------       ]
                   [          2           ]
                   [                      ]
                   [      2          - t  ]
           Col 3 = [    (t  - 2 t) %e     ]
                   [  - ----------------  ]
                   [           2          ]
                   [                      ]
                   [   2              - t ]
                   [ (t  - 4 t + 2) %e    ]
                   [ -------------------- ]
                   [          2           ]

     Example 2:

          (%i5) b1:matrix([0,0,1,1,1],
                          [0,0,0,1,1],
                          [0,0,0,0,1],
                          [0,0,0,0,0],
                          [0,0,0,0,0])$

          (%i6) mat_function(exp,t*b1);
                            [              2     ]
                            [             t      ]
                            [ 1  0  t  t  -- + t ]
                            [             2      ]
                            [                    ]
          (%o6)             [ 0  1  0  t    t    ]
                            [                    ]
                            [ 0  0  1  0    t    ]
                            [                    ]
                            [ 0  0  0  1    0    ]
                            [                    ]
                            [ 0  0  0  0    1    ]
     (%i7) minimalPoly(jordan(b1));                              3
     (%o7)                       x
          (%i8) ident(5)+t*b1+1/2*(t^2)*b1^^2;
                            [              2     ]
                            [             t      ]
                            [ 1  0  t  t  -- + t ]
                            [             2      ]
                            [                    ]
          (%o8)             [ 0  1  0  t    t    ]
                            [                    ]
                            [ 0  0  1  0    t    ]
                            [                    ]
                            [ 0  0  0  1    0    ]
                            [                    ]
                            [ 0  0  0  0    1    ]

          (%i9) mat_function(exp,%i*t*b1);
                       [                           2 ]
                       [                          t  ]
                       [ 1  0  %i t  %i t  %i t - -- ]
                       [                          2  ]
                       [                             ]
          (%o9)        [ 0  1   0    %i t    %i t    ]
                       [                             ]
                       [ 0  0   1     0      %i t    ]
                       [                             ]
                       [ 0  0   0     1        0     ]
                       [                             ]
                       [ 0  0   0     0        1     ]
     (%i10) mat_function(cos,t*b1)+%i*mat_function(sin,t*b1);
                        [                           2 ]
                        [                          t  ]
                        [ 1  0  %i t  %i t  %i t - -- ]
                        [                          2  ]
                        [                             ]
          (%o10)        [ 0  1   0    %i t    %i t    ]
                        [                             ]
                        [ 0  0   1     0      %i t    ]
                        [                             ]
                        [ 0  0   0     1        0     ]
                        [                             ]
                        [ 0  0   0     0        1     ]

     Example 3:

          (%i11) a1:matrix([2,1,0,0,0,0],
                           [-1,4,0,0,0,0],
                           [-1,1,2,1,0,0],
                           [-1,1,-1,4,0,0],
                           [-1,1,-1,1,3,0],
                           [-1,1,-1,1,1,2])$
          (%i12) fpow(x):=block([k],declare(k,integer),x^k)$
          (%i13) mat_function(fpow,a1);

                          [  k      k - 1 ]         [      k - 1    ]
                          [ 3  - k 3      ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [  k      k - 1 ]
                          [  - k 3        ]         [ 3  + k 3      ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
          (%o13)  Col 1 = [               ] Col 2 = [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]

                   [       0       ]         [       0       ]
                   [               ]         [               ]
                   [       0       ]         [       0       ]
                   [               ]         [               ]
                   [  k      k - 1 ]         [      k - 1    ]
                   [ 3  - k 3      ]         [   k 3         ]
                   [               ]         [               ]
           Col 3 = [       k - 1   ] Col 4 = [  k      k - 1 ]
                   [  - k 3        ]         [ 3  + k 3      ]
                   [               ]         [               ]
                   [       k - 1   ]         [      k - 1    ]
                   [  - k 3        ]         [   k 3         ]
                   [               ]         [               ]
                   [       k - 1   ]         [      k - 1    ]
                   [  - k 3        ]         [   k 3         ]

                   [    0    ]
                   [         ]         [ 0  ]
                   [    0    ]         [    ]
                   [         ]         [ 0  ]
                   [    0    ]         [    ]
                   [         ]         [ 0  ]
           Col 5 = [    0    ] Col 6 = [    ]
                   [         ]         [ 0  ]
                   [    k    ]         [    ]
                   [   3     ]         [ 0  ]
                   [         ]         [    ]
                   [  k    k ]         [  k ]
                   [ 3  - 2  ]         [ 2  ]


File: maxima.info,  Node: Package distrib,  Next: draw,  Prev: diag,  Up: Top

41 Package distrib
******************

* Menu:

* Introduction to distrib::
* Functions and Variables for continuous distributions::
* Functions and Variables for discrete distributions::


File: maxima.info,  Node: Introduction to distrib,  Next: Functions and Variables for continuous distributions,  Prev: Package distrib,  Up: Package distrib

41.1 Introduction to distrib
============================

Package `distrib' contains a set of functions for making probability
computations on both discrete and continuous univariate models.

What follows is a short reminder of basic probabilistic related
definitions.

Let f(x) be the <density function> of an absolute continuous random
variable X.  The <distribution function> is defined as
                            x
                           /
                           [
                    F(x) = I     f(u) du
                           ]
                           /
                            minf
which equals the probability <Pr(X <= x)>.

The <mean> value is a localization parameter and is defined as
                          inf
                         /
                         [
                E[X]  =  I   x f(x) dx
                         ]
                         /
                          minf

The <variance> is a measure of variation,
                      inf
                     /
                     [                    2
              V[X] = I     f(x) (x - E[X])  dx
                     ]
                     /
                      minf
which is a positive real number.  The square root of the variance is the
<standard deviation>, D[X]=sqrt(V[X]), and it is another measure of
variation.

The <skewness coefficient> is a measure of non-symmetry,
                      inf
                     /
                 1   [                    3
       SK[X] = ----- I     f(x) (x - E[X])  dx
                   3 ]
               D[X]  /
                      minf

And the <kurtosis coefficient> measures the peakedness of the
distribution,
                      inf
                     /
                 1   [                    4
       KU[X] = ----- I     f(x) (x - E[X])  dx - 3
                   4 ]
               D[X]  /
                      minf
If X is gaussian, KU[X]=0.  In fact, both skewness and kurtosis are
shape parameters used to measure the non-gaussianity of a distribution.

If the random variable X is discrete, the density, or <probability>,
function f(x) takes positive values within certain countable set of
numbers x_i, and zero elsewhere.  In this case, the distribution
function is
                            ====
                            \
                     F(x) =  >    f(x )
                            /        i
                            ====
                           x <= x
                            i

The mean, variance, standard deviation, skewness coefficient and
kurtosis coefficient take the form
                            ====
                            \
                     E[X] =  >  x  f(x ) ,
                            /    i    i
                            ====
                             x
                              i

                     ====
                     \                     2
             V[X] =   >    f(x ) (x - E[X])  ,
                     /        i    i
                     ====
                      x
                       i

                    D[X] = sqrt(V[X]),

                          ====
                   1      \                     3
       SK[X] =  -------    >    f(x ) (x - E[X])
                D[X]^3    /        i    i
                          ====
                           x
                            i
and
                          ====
                   1      \                     4
       KU[X] =  -------    >    f(x ) (x - E[X])   - 3 ,
                D[X]^4    /        i    i
                          ====
                           x
                            i
respectively.

There is a naming convention in package `distrib'.  Every function name
has two parts, the first one makes reference to the function or
parameter we want to calculate,
     Functions:
        Density function            (pdf_*)
        Distribution function       (cdf_*)
        Quantile                    (quantile_*)
        Mean                        (mean_*)
        Variance                    (var_*)
        Standard deviation          (std_*)
        Skewness coefficient        (skewness_*)
        Kurtosis coefficient        (kurtosis_*)
        Random variate              (random_*)

The second part is an explicit reference to the probabilistic model,
     Continuous distributions:
        Normal              (*normal)
        Student             (*student_t)
        Chi^2               (*chi2)
        Noncentral Chi^2    (*noncentral_chi2)
        F                   (*f)
        Exponential         (*exp)
        Lognormal           (*lognormal)
        Gamma               (*gamma)
        Beta                (*beta)
        Continuous uniform  (*continuous_uniform)
        Logistic            (*logistic)
        Pareto              (*pareto)
        Weibull             (*weibull)
        Rayleigh            (*rayleigh)
        Laplace             (*laplace)
        Cauchy              (*cauchy)
        Gumbel              (*gumbel)

     Discrete distributions:
        Binomial             (*binomial)
        Poisson              (*poisson)
        Bernoulli            (*bernoulli)
        Geometric            (*geometric)
        Discrete uniform     (*discrete_uniform)
        hypergeometric       (*hypergeometric)
        Negative binomial    (*negative_binomial)
        Finite discrete      (*general_finite_discrete)

For example, `pdf_student_t(x,n)' is the density function of the Student
distribution with <n> degrees of freedom, `std_pareto(a,b)' is the
standard deviation of the Pareto distribution with parameters <a> and
<b> and `kurtosis_poisson(m)' is the kurtosis coefficient of the
Poisson distribution with mean <m>.

In order to make use of package `distrib' you need first to load it by
typing
     (%i1) load(distrib)$

For comments, bugs or suggestions, please contact the author at <'mario
AT edu DOT xunta DOT es'>.


File: maxima.info,  Node: Functions and Variables for continuous distributions,  Next: Functions and Variables for discrete distributions,  Prev: Introduction to distrib,  Up: Package distrib

41.2 Functions and Variables for continuous distributions
=========================================================

 -- Function: pdf_normal (<x>, <m>, <s>)
     Returns the value at <x> of the density function of a Normal(m,s)
     random variable, with s>0.  To make use of this function, write
     first `load(distrib)'.

 -- Function: cdf_normal (<x>, <m>, <s>)
     Returns the value at <x> of the distribution function of a
     Normal(m,s) random variable, with s>0.  This function is defined
     in terms of Maxima's built-in error function `erf'.

          (%i1) load (distrib)$
          (%i2) assume(s>0)$ cdf_normal(x,m,s);
                                       x - m
                                 erf(---------)
                                     sqrt(2) s    1
          (%o3)                  -------------- + -
                                       2          2

     See also `erf'.

 -- Function: quantile_normal (<q>, <m>, <s>)
     Returns the <q>-quantile of a Normal(m,s) random variable, with
     s>0; in other words, this is the inverse of `cdf_normal'.  Argument
     <q> must be an element of [0,1].  To make use of this function,
     write first `load(distrib)'.

          (%i1) load (distrib)$
          (%i2) quantile_normal(95/100,0,1);
                                                9
          (%o2)             sqrt(2) inverse_erf(--)
                                                10
          (%i3) float(%);
          (%o3)               1.644853626951472

 -- Function: mean_normal (<m>, <s>)
     Returns the mean of a Normal(m,s) random variable, with s>0,
     namely <m>.  To make use of this function, write first
     `load(distrib)'.

 -- Function: var_normal (<m>, <s>)
     Returns the variance of a Normal(m,s) random variable, with s>0,
     namely <s^2>.  To make use of this function, write first
     `load(distrib)'.

 -- Function: std_normal (<m>, <s>)
     Returns the standard deviation of a Normal(m,s) random variable,
     with s>0, namely <s>.  To make use of this function, write first
     `load(distrib)'.

 -- Function: skewness_normal (<m>, <s>)
     Returns the skewness coefficient of a Normal(m,s) random variable,
     with s>0, which is always equal to 0.  To make use of this
     function, write first `load(distrib)'.

 -- Function: kurtosis_normal (<m>, <s>)
     Returns the kurtosis coefficient of a Normal(m,s) random variable,
     with s>0, which is always equal to 0.  To make use of this
     function, write first `load(distrib)'.

 -- Function: random_normal (<m>, <s>)
 -- Function: random_normal (<m>, <s>, <n>)
     Returns a Normal(m,s) random variate, with s>0.  Calling
     `random_normal' with a third argument <n>, a random sample of size
     <n> will be simulated.

     This is an implementation of the Box-Mueller algorithm, as
     described in Knuth, D.E. (1981) <Seminumerical Algorithms.  The
     Art of Computer Programming.> Addison-Wesley.

     To make use of this function, write first `load(distrib)'.

 -- Function: pdf_student_t (<x>, <n>)
     Returns the value at <x> of the density function of a Student
     random variable t(n), with n>0 degrees of freedom.  To make use of
     this function, write first `load(distrib)'.

 -- Function: cdf_student_t (<x>, <n>)
     Returns the value at <x> of the distribution function of a Student
     random variable t(n), with n>0 degrees of freedom.

          (%i1) load (distrib)$
          (%i2) cdf_student_t(1/2, 7/3);
                                                   7  1  28
                       beta_incomplete_regularized(-, -, --)
                                                   6  2  31
          (%o2)    1 - -------------------------------------
                                         2
          (%i3) float(%);
          (%o3)                .6698450596140415

 -- Function: quantile_student_t (<q>, <n>)
     Returns the <q>-quantile of a Student random variable t(n), with
     n>0; in other words, this is the inverse of `cdf_student_t'.
     Argument <q> must be an element of [0,1].  To make use of this
     function, write first `load(distrib)'.

 -- Function: mean_student_t (<n>)
     Returns the mean of a Student random variable t(n), with n>0,
     which is always equal to 0.  To make use of this function, write
     first `load(distrib)'.

 -- Function: var_student_t (<n>)
     Returns the variance of a Student random variable t(n), with n>2.

          (%i1) load (distrib)$
          (%i2) assume(n>2)$  var_student_t(n);
                                          n
          (%o3)                         -----
                                        n - 2

 -- Function: std_student_t (<n>)
     Returns the standard deviation of a Student random variable t(n),
     with n>2.  To make use of this function, write first
     `load(distrib)'.

 -- Function: skewness_student_t (<n>)
     Returns the skewness coefficient of a Student random variable
     t(n), with n>3, which is always equal to 0.  To make use of this
     function, write first `load(distrib)'.

 -- Function: kurtosis_student_t (<n>)
     Returns the kurtosis coefficient of a Student random variable
     t(n), with n>4.  To make use of this function, write first
     `load(distrib)'.

 -- Function: random_student_t (<n>)
 -- Function: random_student_t (<n>, <m>)
     Returns a Student random variate t(n), with n>0.  Calling
     `random_student_t' with a second argument <m>, a random sample of
     size <m> will be simulated.

     The implemented algorithm is based on the fact that if <Z> is a
     normal random variable N(0,1) and S^2 is a chi square random
     variable with <n> degrees of freedom, Chi^2(n), then
                                     Z
                           X = -------------
                               /   2  \ 1/2
                               |  S   |
                               | ---  |
                               \  n   /
     is a Student random variable with <n> degrees of freedom, t(n).

     To make use of this function, write first `load(distrib)'.

 -- Function: pdf_noncentral_student_t (<x>, <n>, <ncp>)
     Returns the value at <x> of the density function of a noncentral
     Student random variable nc_t(n,ncp), with n>0 degrees of freedom
     and noncentrality parameter ncp.  To make use of this function,
     write first `load(distrib)'.

     Sometimes an extra work is necessary to get the final result.

          (%i1) load (distrib)$
          (%i2) expand(pdf_noncentral_student_t(3,5,0.1));
                 .01370030107589574 sqrt(5)
          (%o2)  --------------------------
                 sqrt(2) sqrt(14) sqrt(%pi)
             1.654562884111515E-4 sqrt(5)
           + ----------------------------
                      sqrt(%pi)
             .02434921505438663 sqrt(5)
           + --------------------------
                        %pi
          (%i3) float(%);
          (%o3)          .02080593159405669

 -- Function: cdf_noncentral_student_t (<x>, <n>, <ncp>)
     Returns the value at <x> of the distribution function of a
     noncentral Student random variable nc_t(n,ncp), with n>0 degrees
     of freedom and noncentrality parameter ncp.  This function has no
     closed form and it is numerically computed if the global variable
     `numer' equals `true' or at least one of the arguments is a float,
     otherwise it returns a nominal expression.

          (%i1) load (distrib)$
          (%i2) cdf_noncentral_student_t(-2,5,-5);
          (%o2) cdf_noncentral_student_t(- 2, 5, - 5)
          (%i3) cdf_noncentral_student_t(-2.0,5,-5);
          (%o3)          .9952030093319743

 -- Function: quantile_noncentral_student_t (<q>, <n>, <ncp>)
     Returns the <q>-quantile of a noncentral Student random variable
     nc_t(n,ncp), with n>0 degrees of freedom and noncentrality
     parameter ncp; in other words, this is the inverse of
     `cdf_noncentral_student_t'.  Argument <q> must be an element of
     [0,1].  To make use of this function, write first `load(distrib)'.

 -- Function: mean_noncentral_student_t (<n>, <ncp>)
     Returns the mean of a noncentral Student random variable
     nc_t(n,ncp), with n>1 degrees of freedom and noncentrality
     parameter ncp.  To make use of this function, write first
     `load(distrib)'.

          (%i1) load (distrib)$
          (%i2) (assume(df>1), mean_noncentral_student_t(df,k));
                             df - 1
                       gamma(------) sqrt(df) k
                               2
          (%o2)        ------------------------
                                        df
                          sqrt(2) gamma(--)
                                        2

 -- Function: var_noncentral_student_t (<n>, <ncp>)
     Returns the variance of a noncentral Student random variable
     nc_t(n,ncp), with n>2 degrees of freedom and noncentrality
     parameter ncp.  To make use of this function, write first
     `load(distrib)'.

 -- Function: std_noncentral_student_t (<n>, <ncp>)
     Returns the standard deviation of a noncentral Student random
     variable nc_t(n,ncp), with n>2 degrees of freedom and noncentrality
     parameter ncp.  To make use of this function, write first
     `load(distrib)'.

 -- Function: skewness_noncentral_student_t (<n>, <ncp>)
     Returns the skewness coefficient of a noncentral Student random
     variable nc_t(n,ncp), with n>3 degrees of freedom and noncentrality
     parameter ncp.  To make use of this function, write first
     `load(distrib)'.

 -- Function: kurtosis_noncentral_student_t (<n>, <ncp>)
     Returns the kurtosis coefficient of a noncentral Student random
     variable nc_t(n,ncp), with n>4 degrees of freedom and noncentrality
     parameter ncp.  To make use of this function, write first
     `load(distrib)'.

 -- Function: random_noncentral_student_t (<n>, <ncp>)
 -- Function: random_noncentral_student_t (<n>, <ncp>, <m>)
     Returns a noncentral Student random variate nc_t(n,ncp), with n>0.
     Calling `random_noncentral_student_t' with a third argument <m>, a
     random sample of size <m> will be simulated.

     The implemented algorithm is based on the fact that if <X> is a
     normal random variable N(ncp,1) and S^2 is a chi square random
     variable with <n> degrees of freedom, Chi^2(n), then
                                     X
                           U = -------------
                               /   2  \ 1/2
                               |  S   |
                               | ---  |
                               \  n   /
     is a noncentral Student random variable with <n> degrees of
     freedom and noncentrality parameter ncp, nc_t(n,ncp).

     To make use of this function, write first `load(distrib)'.

 -- Function: pdf_chi2 (<x>, <n>)
     Returns the value at <x> of the density function of a Chi-square
     random variable Chi^2(n), with n>0.

     The Chi^2(n) random variable is equivalent to the Gamma(n/2,2),
     therefore when Maxima has not enough information to get the
     result, a noun form based on the gamma density is returned.

          (%i1) load (distrib)$
          (%i2) pdf_chi2(x,n);
                                              n
          (%o2)                  pdf_gamma(x, -, 2)
                                              2
          (%i3) assume(x>0, n>0)$  pdf_chi2(x,n);
                                   n/2 - 1   - x/2
                                  x        %e
          (%o4)                   ----------------
                                    n/2       n
                                   2    gamma(-)
                                              2

 -- Function: cdf_chi2 (<x>, <n>)
     Returns the value at <x> of the distribution function of a
     Chi-square random variable Chi^2(n), with n>0.

          (%i1) load (distrib)$
          (%i2) cdf_chi2(3,4);
                                                         3
          (%o2)      1 - gamma_incomplete_regularized(2, -)
                                                         2
          (%i3) float(%);
          (%o3)               .4421745996289256

 -- Function: quantile_chi2 (<q>, <n>)
     Returns the <q>-quantile of a Chi-square random variable Chi^2(n),
     with n>0; in other words, this is the inverse of `cdf_chi2'.
     Argument <q> must be an element of [0,1].

     This function has no closed form and it is numerically computed if
     the global variable `numer' equals `true',  otherwise it returns a
     nominal expression based on the gamma quantile function, since the
     Chi^2(n) random variable is equivalent to the Gamma(n/2,2).

          (%i1) load (distrib)$
          (%i2) quantile_chi2(0.99,9);
          (%o2)                   21.66599433346194
          (%i3) quantile_chi2(0.99,n);
                                                  n
          (%o3)              quantile_gamma(0.99, -, 2)
                                                  2

 -- Function: mean_chi2 (<n>)
     Returns the mean of a Chi-square random variable Chi^2(n), with
     n>0.

     The Chi^2(n) random variable is equivalent to the Gamma(n/2,2),
     therefore when Maxima has not enough information to get the
     result, a noun form based on the gamma mean is returned.

          (%i1) load (distrib)$
          (%i2) mean_chi2(n);
                                             n
          (%o2)                   mean_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ mean_chi2(n);
          (%o4)                           n

 -- Function: var_chi2 (<n>)
     Returns the variance of a Chi-square random variable Chi^2(n), with
     n>0.

     The Chi^2(n) random variable is equivalent to the Gamma(n/2,2),
     therefore when Maxima has not enough information to get the
     result, a noun form based on the gamma variance is returned.

          (%i1) load (distrib)$
          (%i2) var_chi2(n);
                                             n
          (%o2)                    var_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ var_chi2(n);
          (%o4)                          2 n

 -- Function: std_chi2 (<n>)
     Returns the standard deviation of a Chi-square random variable
     Chi^2(n), with n>0.

     The Chi^2(n) random variable is equivalent to the Gamma(n/2,2),
     therefore when Maxima has not enough information to get the
     result, a noun form based on the gamma standard deviation is
     returned.

          (%i1) load (distrib)$
          (%i2) std_chi2(n);
                                             n
          (%o2)                    std_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ std_chi2(n);
          (%o4)                    sqrt(2) sqrt(n)

 -- Function: skewness_chi2 (<n>)
     Returns the skewness coefficient of a Chi-square random variable
     Chi^2(n), with n>0.

     The Chi^2(n) random variable is equivalent to the Gamma(n/2,2),
     therefore when Maxima has not enough information to get the
     result, a noun form based on the gamma skewness coefficient is
     returned.

          (%i1) load (distrib)$
          (%i2) skewness_chi2(n);
                                               n
          (%o2)                 skewness_gamma(-, 2)
                                               2
          (%i3) assume(n>0)$ skewness_chi2(n);
                                      2 sqrt(2)
          (%o4)                       ---------
                                       sqrt(n)

 -- Function: kurtosis_chi2 (<n>)
     Returns the kurtosis coefficient of a Chi-square random variable
     Chi^2(n), with n>0.

     The Chi^2(n) random variable is equivalent to the Gamma(n/2,2),
     therefore when Maxima has not enough information to get the
     result, a noun form based on the gamma kurtosis coefficient is
     returned.

          (%i1) load (distrib)$
          (%i2) kurtosis_chi2(n);
                                               n
          (%o2)                 kurtosis_gamma(-, 2)
                                               2
          (%i3) assume(n>0)$ kurtosis_chi2(n);
                                         12
          (%o4)                          --
                                         n

 -- Function: random_chi2 (<n>)
 -- Function: random_chi2 (<n>, <m>)
     Returns a Chi-square random variate Chi^2(n), with n>0.  Calling
     `random_chi2' with a second argument <m>, a random sample of size
     <m> will be simulated.

     The simulation is based on the Ahrens-Cheng algorithm.  See
     `random_gamma' for details.

     To make use of this function, write first `load(distrib)'.

 -- Function: pdf_noncentral_chi2 (<x>, <n>, <ncp>)
     Returns the value at <x> of the density function of a noncentral
     Chi-square random variable nc_Chi^2(n,ncp), with n>0 and
     noncentrality parameter ncp>=0.  To make use of this function,
     write first `load(distrib)'.

 -- Function: cdf_noncentral_chi2 (<x>, <n>, <ncp>)
     Returns the value at <x> of the distribution function of a
     noncentral Chi-square random variable nc_Chi^2(n,ncp), with n>0 and
     noncentrality parameter ncp>=0.  To make use of this function,
     write first `load(distrib)'.

 -- Function: quantile_noncentral_chi2 (<q>, <n>, <ncp>)
     Returns the <q>-quantile of a noncentral Chi-square random variable
     nc_Chi^2(n,ncp), with n>0 and noncentrality parameter ncp>=0; in
     other words, this is the inverse of `cdf_noncentral_chi2'.
     Argument <q> must be an element of [0,1].

     This function has no closed form and it is numerically computed if
     the global variable `numer' equals `true',  otherwise it returns a
     nominal expression.

 -- Function: mean_noncentral_chi2 (<n>, <ncp>)
     Returns the mean of a noncentral Chi-square random variable
     nc_Chi^2(n,ncp), with n>0 and noncentrality parameter ncp>=0.

 -- Function: var_noncentral_chi2 (<n>, <ncp>)
     Returns the variance of a noncentral Chi-square random variable
     nc_Chi^2(n,ncp), with n>0 and noncentrality parameter ncp>=0.

 -- Function: std_noncentral_chi2 (<n>, <ncp>)
     Returns the standard deviation of a noncentral Chi-square random
     variable nc_Chi^2(n,ncp), with n>0 and noncentrality parameter
     ncp>=0.

 -- Function: skewness_noncentral_chi2 (<n>, <ncp>)
     Returns the skewness coefficient of a noncentral Chi-square random
     variable nc_Chi^2(n,ncp), with n>0 and noncentrality parameter
     ncp>=0.

 -- Function: kurtosis_noncentral_chi2 (<n>, <ncp>)
     Returns the kurtosis coefficient of a noncentral Chi-square random
     variable nc_Chi^2(n,ncp), with n>0 and noncentrality parameter
     ncp>=0.

 -- Function: random_noncentral_chi2 (<n>, <ncp>)
 -- Function: random_noncentral_chi2 (<n>, <ncp>, <m>)
     Returns a noncentral Chi-square random variate nc_Chi^2(n,ncp),
     with n>0 and noncentrality parameter ncp>=0.  Calling
     `random_noncentral_chi2' with a third argument <m>, a random
     sample of size <m> will be simulated.

     To make use of this function, write first `load(distrib)'.

 -- Function: pdf_f (<x>, <m>, <n>)
     Returns the value at <x> of the density function of a F random
     variable F(m,n), with m,n>0.  To make use of this function, write
     first `load(distrib)'.

 -- Function: cdf_f (<x>, <m>, <n>)
     Returns the value at <x> of the distribution function of a F
     random variable F(m,n), with m,n>0.

          (%i1) load (distrib)$
          (%i2) cdf_f(2,3,9/4);
                                                   9  3  3
          (%o2)    1 - beta_incomplete_regularized(-, -, --)
                                                   8  2  11
          (%i3) float(%);
          (%o3)                 0.66756728179008

 -- Function: quantile_f (<q>, <m>, <n>)
     Returns the <q>-quantile of a F random variable F(m,n), with
     m,n>0; in other words, this is the inverse of `cdf_f'.  Argument
     <q> must be an element of [0,1].

     This function has no closed form and it is numerically computed if
     the global variable `numer' equals `true',  otherwise it returns a
     nominal expression.

          (%i1) load (distrib)$
          (%i2) quantile_f(2/5,sqrt(3),5);
                                         2
          (%o2)               quantile_f(-, sqrt(3), 5)
                                         5
          (%i3) %,numer;
          (%o3)                   0.518947838573693

 -- Function: mean_f (<m>, <n>)
     Returns the mean of a F random variable F(m,n), with m>0, n>2.  To
     make use of this function, write first `load(distrib)'.

 -- Function: var_f (<m>,<n>)
     Returns the variance of a F random variable F(m,n), with m>0, n>4.
     To make use of this function, write first `load(distrib)'.

 -- Function: std_f (<m>, <n>)
     Returns the standard deviation of a F random variable F(m,n), with
     m>0, n>4.  To make use of this function, write first
     `load(distrib)'.

 -- Function: skewness_f (<m>, <n>)
     Returns the skewness coefficient of a F random variable F(m,n),
     with m>0, n>6.  To make use of this function, write first
     `load(distrib)'.

 -- Function: kurtosis_f (<m>, <n>)
     Returns the kurtosis coefficient of a F random variable F(m,n),
     with m>0, n>8.  To make use of this function, write first
     `load(distrib)'.

 -- Function: random_f (<m>, <n>)
 -- Function: random_f (<m>, <n>, <k>)
     Returns a F random variate F(m,n), with m,n>0.  Calling `random_f'
     with a third argument <k>, a random sample of size <k> will be
     simulated.

     The simulation algorithm is based on the fact that if <X> is a
     Chi^2(m) random variable and Y is a Chi^2(n) random variable, then
                                  n X
                              F = ---
                                  m Y
     is a F random variable with <m> and <n> degrees of freedom, F(m,n).

     To make use of this function, write first `load(distrib)'.

 -- Function: pdf_exp (<x>, <m>)
     Returns the value at <x> of the density function of an
     Exponential(m) random variable, with m>0.

     The Exponential(m) random variable is equivalent to the
     Weibull(1,1/m), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull density is
     returned.

          (%i1) load (distrib)$
          (%i2) pdf_exp(x,m);
                                                  1
          (%o2)                 pdf_weibull(x, 1, -)
                                                  m
          (%i3) assume(x>0,m>0)$  pdf_exp(x,m);
                                          - m x
          (%o4)                       m %e

 -- Function: cdf_exp (<x>, <m>)
     Returns the value at <x> of the distribution function of an
     Exponential(m) random variable, with m>0.

     The Exponential(m) random variable is equivalent to the
     Weibull(1,1/m), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull distribution
     is returned.

          (%i1) load (distrib)$
          (%i2) cdf_exp(x,m);
                                                  1
          (%o2)                 cdf_weibull(x, 1, -)
                                                  m
          (%i3) assume(x>0,m>0)$  cdf_exp(x,m);
                                           - m x
          (%o4)                      1 - %e

 -- Function: quantile_exp (<q>, <m>)
     Returns the <q>-quantile of an Exponential(m) random variable, with
     m>0; in other words, this is the inverse of `cdf_exp'.  Argument
     <q> must be an element of [0,1].

     The Exponential(m) random variable is equivalent to the
     Weibull(1,1/m), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull quantile is
     returned.

          (%i1) load (distrib)$
          (%i2) quantile_exp(0.56,5);
          (%o2)                   .1641961104139661
          (%i3) quantile_exp(0.56,m);
                                                      1
          (%o3)             quantile_weibull(0.56, 1, -)
                                                      m

 -- Function: mean_exp (<m>)
     Returns the mean of an Exponential(m) random variable, with m>0.

     The Exponential(m) random variable is equivalent to the
     Weibull(1,1/m), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull mean is
     returned.

          (%i1) load (distrib)$
          (%i2) mean_exp(m);
                                                 1
          (%o2)                  mean_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  mean_exp(m);
                                          1
          (%o4)                           -
                                          m

 -- Function: var_exp (<m>)
     Returns the variance of an Exponential(m) random variable, with
     m>0.

     The Exponential(m) random variable is equivalent to the
     Weibull(1,1/m), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull variance is
     returned.

          (%i1) load (distrib)$
          (%i2) var_exp(m);
                                                 1
          (%o2)                   var_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  var_exp(m);
                                         1
          (%o4)                          --
                                          2
                                         m

 -- Function: std_exp (<m>)
     Returns the standard deviation of an Exponential(m) random
     variable, with m>0.

     The Exponential(m) random variable is equivalent to the
     Weibull(1,1/m), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull standard
     deviation is returned.

          (%i1) load (distrib)$
          (%i2) std_exp(m);
                                                 1
          (%o2)                   std_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  std_exp(m);
                                          1
          (%o4)                           -
                                          m

 -- Function: skewness_exp (<m>)
     Returns the skewness coefficient of an Exponential(m) random
     variable, with m>0.

     The Exponential(m) random variable is equivalent to the
     Weibull(1,1/m), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull skewness
     coefficient is returned.

          (%i1) load (distrib)$
          (%i2) skewness_exp(m);
                                                   1
          (%o2)                skewness_weibull(1, -)
                                                   m
          (%i3) assume(m>0)$  skewness_exp(m);
          (%o4)                           2

 -- Function: kurtosis_exp (<m>)
     Returns the kurtosis coefficient of an Exponential(m) random
     variable, with m>0.

     The Exponential(m) random variable is equivalent to the
     Weibull(1,1/m), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull kurtosis
     coefficient is returned.

          (%i1) load (distrib)$
          (%i2) kurtosis_exp(m);
                                                   1
          (%o2)                kurtosis_weibull(1, -)
                                                   m
          (%i3) assume(m>0)$  kurtosis_exp(m);
          (%o4)                           6

 -- Function: random_exp (<m>)
 -- Function: random_exp (<m>, <k>)
     Returns an Exponential(m) random variate, with m>0.  Calling
     `random_exp' with a second argument <k>, a random sample of size
     <k> will be simulated.

     The simulation algorithm is based on the general inverse method.

     To make use of this function, write first `load(distrib)'.

 -- Function: pdf_lognormal (<x>, <m>, <s>)
     Returns the value at <x> of the density function of a
     Lognormal(m,s) random variable, with s>0.  To make use of this
     function, write first `load(distrib)'.

 -- Function: cdf_lognormal (<x>, <m>, <s>)
     Returns the value at <x> of the distribution function of a
     Lognormal(m,s) random variable, with s>0.  This function is
     defined in terms of Maxima's built-in error function `erf'.

          (%i1) load (distrib)$
          (%i2) assume(x>0, s>0)$  cdf_lognormal(x,m,s);
                                     log(x) - m
                                 erf(----------)
                                     sqrt(2) s     1
          (%o3)                  --------------- + -
                                        2          2

     See also `erf'.

 -- Function: quantile_lognormal (<q>, <m>, <s>)
     Returns the <q>-quantile of a Lognormal(m,s) random variable, with
     s>0; in other words, this is the inverse of `cdf_lognormal'.
     Argument <q> must be an element of [0,1].  To make use of this
     function, write first `load(distrib)'.

          (%i1) load (distrib)$
          (%i2) quantile_lognormal(95/100,0,1);
                            sqrt(2) inverse_erf(9/10)
          (%o2)           %e
          (%i3) float(%);
          (%o3)               5.180251602233015

 -- Function: mean_lognormal (<m>, <s>)
     Returns the mean of a Lognormal(m,s) random variable, with s>0.
     To make use of this function, write first `load(distrib)'.

 -- Function: var_lognormal (<m>, <s>)
     Returns the variance of a Lognormal(m,s) random variable, with
     s>0.  To make use of this function, write first `load(distrib)'.

 -- Function: std_lognormal (<m>, <s>)
     Returns the standard deviation of a Lognormal(m,s) random
     variable, with s>0.  To make use of this function, write first
     `load(distrib)'.

 -- Function: skewness_lognormal (<m>, <s>)
     Returns the skewness coefficient of a Lognormal(m,s) random
     variable, with s>0.  To make use of this function, write first
     `load(distrib)'.

 -- Function: kurtosis_lognormal (<m>, <s>)
     Returns the kurtosis coefficient of a Lognormal(m,s) random
     variable, with s>0.  To make use of this function, write first
     `load(distrib)'.

 -- Function: random_lognormal (<m>, <s>)
 -- Function: random_lognormal (<m>, <s>, <n>)
     Returns a Lognormal(m,s) random variate, with s>0.  Calling
     `random_lognormal' with a third argument <n>, a random sample of
     size <n> will be simulated.

     Log-normal variates are simulated by means of random normal
     variates.  See `random_normal' for details.

     To make use of this function, write first `load(distrib)'.

 -- Function: pdf_gamma (<x>, <a>, <b>)
     Returns the value at <x> of the density function of a Gamma(a,b)
     random variable, with a,b>0.  To make use of this function, write
     first `load(distrib)'.

 -- Function: cdf_gamma (<x>, <a>, <b>)
     Returns the value at <x> of the distribution function of a
     Gamma(a,b) random variable, with a,b>0.

          (%i1) load (distrib)$
          (%i2) cdf_gamma(3,5,21);
                                                        1
          (%o2)     1 - gamma_incomplete_regularized(5, -)
                                                        7
          (%i3) float(%);
          (%o3)              4.402663157376807E-7

 -- Function: quantile_gamma (<q>, <a>, <b>)
     Returns the <q>-quantile of a Gamma(a,b) random variable, with
     a,b>0; in other words, this is the inverse of `cdf_gamma'.
     Argument <q> must be an element of [0,1].  To make use of this
     function, write first `load(distrib)'.

 -- Function: mean_gamma (<a>, <b>)
     Returns the mean of a Gamma(a,b) random variable, with a,b>0.  To
     make use of this function, write first `load(distrib)'.

 -- Function: var_gamma (<a>, <b>)
     Returns the variance of a Gamma(a,b) random variable, with a,b>0.
     To make use of this function, write first `load(distrib)'.

 -- Function: std_gamma (<a>, <b>)
     Returns the standard deviation of a Gamma(a,b) random variable,
     with a,b>0.  To make use of this function, write first
     `load(distrib)'.

 -- Function: skewness_gamma (<a>, <b>)
     Returns the skewness coefficient of a Gamma(a,b) random variable,
     with a,b>0. To make use of this function, write first
     `load(distrib)'.

 -- Function: kurtosis_gamma (<a>, <b>)
     Returns the kurtosis coefficient of a Gamma(a,b) random variable,
     with a,b>0.  To make use of this function, write first
     `load(distrib)'.

 -- Function: random_gamma (<a>, <b>)
 -- Function: random_gamma (<a>, <b>, <n>)
     Returns a Gamma(a,b) random variate, with a,b>0.  Calling
     `random_gamma' with a third argument <n>, a random sample of size
     <n> will be simulated.

     The implemented algorithm is a combination of two procedures,
     depending on the value of parameter <a>:

     For a>=1, Cheng, R.C.H. and Feast, G.M. (1979).  <Some simple
     gamma variate generators>. Appl. Stat., 28, 3, 290-295.

     For 0<a<1, Ahrens, J.H. and Dieter, U. (1974). <Computer methods
     for sampling from gamma, beta, poisson and binomial
     cdf_tributions>.  Computing, 12, 223-246.

     To make use of this function, write first `load(distrib)'.

 -- Function: pdf_beta (<x>, <a>, <b>)
     Returns the value at <x> of the density function of a Beta(a,b)
     random variable, with a,b>0.  To make use of this function, write
     first `load(distrib)'.

 -- Function: cdf_beta (<x>, <a>, <b>)
     Returns the value at <x> of the distribution function of a
     Beta(a,b) random variable, with a,b>0.

          (%i1) load (distrib)$
          (%i2) cdf_beta(1/3,15,2);
                                       11
          (%o2)                     --------
                                    14348907
          (%i3) float(%);
          (%o3)              7.666089131388195E-7

 -- Function: quantile_beta (<q>, <a>, <b>)
     Returns the <q>-quantile of a Beta(a,b) random variable, with
     a,b>0; in other words, this is the inverse of `cdf_beta'.  Argument
     <q> must be an element of [0,1].  To make use of this function,
     write first `load(distrib)'.

 -- Function: mean_beta (<a>, <b>)
     Returns the mean of a Beta(a,b) random variable, with a,b>0.  To
     make use of this function, write first `load(distrib)'.

 -- Function: var_beta (<a>, <b>)
     Returns the variance of a Beta(a,b) random variable, with a,b>0.
     To make use of this function, write first `load(distrib)'.

 -- Function: std_beta (<a>, <b>)
     Returns the standard deviation of a Beta(a,b) random variable, with
     a,b>0.  To make use of this function, write first `load(distrib)'.

 -- Function: skewness_beta (<a>, <b>)
     Returns the skewness coefficient of a Beta(a,b) random variable,
     with a,b>0.  To make use of this function, write first
     `load(distrib)'.

 -- Function: kurtosis_beta (<a>, <b>)
     Returns the kurtosis coefficient of a Beta(a,b) random variable,
     with a,b>0.  To make use of this function, write first
     `load(distrib)'.

 -- Function: random_beta (<a>, <b>)
 -- Function: random_beta (<a>, <b>, <n>)
     Returns a Beta(a,b) random variate, with a,b>0.  Calling
     `random_beta' with a third argument <n>, a random sample of size
     <n> will be simulated.

     The implemented algorithm is defined in Cheng, R.C.H. (1978).
     <Generating Beta Variates with Nonintegral Shape Parameters>.
     Communications of the ACM, 21:317-322

     To make use of this function, write first `load(distrib)'.

 -- Function: pdf_continuous_uniform (<x>, <a>, <b>)
     Returns the value at <x> of the density function of a Continuous
     Uniform(a,b) random variable, with a<b.  To make use of this
     function, write first `load(distrib)'.

 -- Function: cdf_continuous_uniform (<x>, <a>, <b>)
     Returns the value at <x> of the distribution function of a
     Continuous Uniform(a,b) random variable, with a<b.  To make use of
     this function, write first `load(distrib)'.

 -- Function: quantile_continuous_uniform (<q>, <a>, <b>)
     Returns the <q>-quantile of a Continuous Uniform(a,b) random
     variable, with a<b; in other words, this is the inverse of
     `cdf_continuous_uniform'.  Argument <q> must be an element of
     [0,1].  To make use of this function, write first `load(distrib)'.

 -- Function: mean_continuous_uniform (<a>, <b>)
     Returns the mean of a Continuous Uniform(a,b) random variable, with
     a<b.  To make use of this function, write first `load(distrib)'.

 -- Function: var_continuous_uniform (<a>, <b>)
     Returns the variance of a Continuous Uniform(a,b) random variable,
     with a<b.  To make use of this function, write first
     `load(distrib)'.

 -- Function: std_continuous_uniform (<a>, <b>)
     Returns the standard deviation of a Continuous Uniform(a,b) random
     variable, with a<b.  To make use of this function, write first
     `load(distrib)'.

 -- Function: skewness_continuous_uniform (<a>, <b>)
     Returns the skewness coefficient of a Continuous Uniform(a,b)
     random variable, with a<b.  To make use of this function, write
     first `load(distrib)'.

 -- Function: kurtosis_continuous_uniform (<a>, <b>)
     Returns the kurtosis coefficient of a Continuous Uniform(a,b)
     random variable, with a<b.  To make use of this function, write
     first `load(distrib)'.

 -- Function: random_continuous_uniform (<a>, <b>)
 -- Function: random_continuous_uniform (<a>, <b>, <n>)
     Returns a Continuous Uniform(a,b) random variate, with a<b.
     Calling `random_continuous_uniform' with a third argument <n>, a
     random sample of size <n> will be simulated.

     This is a direct application of the `random' built-in Maxima
     function.

     See also `random'.  To make use of this function, write first
     `load(distrib)'.

 -- Function: pdf_logistic (<x>, <a>, <b>)
     Returns the value at <x> of the density function of a Logistic(a,b)
     random variable, with b>0.  To make use of this function, write
     first `load(distrib)'.

 -- Function: cdf_logistic (<x>, <a>, <b>)
     Returns the value at <x> of the distribution function of a
     Logistic(a,b) random variable, with b>0.  To make use of this
     function, write first `load(distrib)'.

 -- Function: quantile_logistic (<q>, <a>, <b>)
     Returns the <q>-quantile of a Logistic(a,b) random variable , with
     b>0; in other words, this is the inverse of `cdf_logistic'.
     Argument <q> must be an element of [0,1].  To make use of this
     function, write first `load(distrib)'.

 -- Function: mean_logistic (<a>, <b>)
     Returns the mean of a Logistic(a,b) random variable, with b>0.  To
     make use of this function, write first `load(distrib)'.

 -- Function: var_logistic (<a>, <b>)
     Returns the variance of a Logistic(a,b) random variable, with b>0.
     To make use of this function, write first `load(distrib)'.

 -- Function: std_logistic (<a>, <b>)
     Returns the standard deviation of a Logistic(a,b) random variable,
     with b>0.  To make use of this function, write first
     `load(distrib)'.

 -- Function: skewness_logistic (<a>, <b>)
     Returns the skewness coefficient of a Logistic(a,b) random
     variable, with b>0.  To make use of this function, write first
     `load(distrib)'.

 -- Function: kurtosis_logistic (<a>, <b>)
     Returns the kurtosis coefficient of a Logistic(a,b) random
     variable, with b>0.  To make use of this function, write first
     `load(distrib)'.

 -- Function: random_logistic (<a>, <b>)
 -- Function: random_logistic (<a>, <b>, <n>)
     Returns a Logistic(a,b) random variate, with b>0.  Calling
     `random_logistic' with a third argument <n>, a random sample of
     size <n> will be simulated.

     The implemented algorithm is based on the general inverse method.

     To make use of this function, write first `load(distrib)'.

 -- Function: pdf_pareto (<x>, <a>, <b>)
     Returns the value at <x> of the density function of a Pareto(a,b)
     random variable, with a,b>0.  To make use of this function, write
     first `load(distrib)'.

 -- Function: cdf_pareto (<x>, <a>, <b>)
     Returns the value at <x> of the distribution function of a
     Pareto(a,b) random variable, with a,b>0.  To make use of this
     function, write first `load(distrib)'.

 -- Function: quantile_pareto (<q>, <a>, <b>)
     Returns the <q>-quantile of a Pareto(a,b) random variable, with
     a,b>0; in other words, this is the inverse of `cdf_pareto'.
     Argument <q> must be an element of [0,1].  To make use of this
     function, write first `load(distrib)'.

 -- Function: mean_pareto (<a>, <b>)
     Returns the mean of a Pareto(a,b) random variable, with a>1,b>0.
     To make use of this function, write first `load(distrib)'.

 -- Function: var_pareto (<a>, <b>)
     Returns the variance of a Pareto(a,b) random variable, with
     a>2,b>0.  To make use of this function, write first
     `load(distrib)'.

 -- Function: std_pareto (<a>, <b>)
     Returns the standard deviation of a Pareto(a,b) random variable,
     with a>2,b>0.  To make use of this function, write first
     `load(distrib)'.

 -- Function: skewness_pareto (<a>, <b>)
     Returns the skewness coefficient of a Pareto(a,b) random variable,
     with a>3,b>0.  To make use of this function, write first
     `load(distrib)'.

 -- Function: kurtosis_pareto (<a>, <b>)
     Returns the kurtosis coefficient of a Pareto(a,b) random variable,
     with a>4,b>0.  To make use of this function, write first
     `load(distrib)'.

 -- Function: random_pareto (<a>, <b>)
 -- Function: random_pareto (<a>, <b>, <n>)
     Returns a Pareto(a,b) random variate, with a>0,b>0.  Calling
     `random_pareto' with a third argument <n>, a random sample of size
     <n> will be simulated.

     The implemented algorithm is based on the general inverse method.

     To make use of this function, write first `load(distrib)'.

 -- Function: pdf_weibull (<x>, <a>, <b>)
     Returns the value at <x> of the density function of a Weibull(a,b)
     random variable, with a,b>0.  To make use of this function, write
     first `load(distrib)'.

 -- Function: cdf_weibull (<x>, <a>, <b>)
     Returns the value at <x> of the distribution function of a
     Weibull(a,b) random variable, with a,b>0.  To make use of this
     function, write first `load(distrib)'.

 -- Function: quantile_weibull (<q>, <a>, <b>)
     Returns the <q>-quantile of a Weibull(a,b) random variable, with
     a,b>0; in other words, this is the inverse of `cdf_weibull'.
     Argument <q> must be an element of [0,1].  To make use of this
     function, write first `load(distrib)'.

 -- Function: mean_weibull (<a>, <b>)
     Returns the mean of a Weibull(a,b) random variable, with a,b>0.
     To make use of this function, write first `load(distrib)'.

 -- Function: var_weibull (<a>, <b>)
     Returns the variance of a Weibull(a,b) random variable, with
     a,b>0.  To make use of this function, write first `load(distrib)'.

 -- Function: std_weibull (<a>, <b>)
     Returns the standard deviation of a Weibull(a,b) random variable,
     with a,b>0.  To make use of this function, write first
     `load(distrib)'.

 -- Function: skewness_weibull (<a>, <b>)
     Returns the skewness coefficient of a Weibull(a,b) random
     variable, with a,b>0.  To make use of this function, write first
     `load(distrib)'.

 -- Function: kurtosis_weibull (<a>, <b>)
     Returns the kurtosis coefficient of a Weibull(a,b) random
     variable, with a,b>0.  To make use of this function, write first
     `load(distrib)'.

 -- Function: random_weibull (<a>, <b>)
 -- Function: random_weibull (<a>, <b>, <n>)
     Returns a Weibull(a,b) random variate, with a,b>0.  Calling
     `random_weibull' with a third argument <n>, a random sample of size
     <n> will be simulated.

     The implemented algorithm is based on the general inverse method.

     To make use of this function, write first `load(distrib)'.

 -- Function: pdf_rayleigh (<x>, <b>)
     Returns the value at <x> of the density function of a Rayleigh(b)
     random variable, with b>0.

     The Rayleigh(b) random variable is equivalent to the
     Weibull(2,1/b), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull density is
     returned.

          (%i1) load (distrib)$
          (%i2) pdf_rayleigh(x,b);
                                                  1
          (%o2)                 pdf_weibull(x, 2, -)
                                                  b
          (%i3) assume(x>0,b>0)$ pdf_rayleigh(x,b);
                                              2  2
                                     2     - b  x
          (%o4)                   2 b  x %e

 -- Function: cdf_rayleigh (<x>, <b>)
     Returns the value at <x> of the distribution function of a
     Rayleigh(b) random variable, with b>0.

     The Rayleigh(b) random variable is equivalent to the
     Weibull(2,1/b), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull distribution
     is returned.

          (%i1) load (distrib)$
          (%i2) cdf_rayleigh(x,b);
                                                  1
          (%o2)                 cdf_weibull(x, 2, -)
                                                  b
          (%i3) assume(x>0,b>0)$ cdf_rayleigh(x,b);
                                             2  2
                                          - b  x
          (%o4)                     1 - %e

 -- Function: quantile_rayleigh (<q>, <b>)
     Returns the <q>-quantile of a Rayleigh(b) random variable, with
     b>0; in other words, this is the inverse of `cdf_rayleigh'.
     Argument <q> must be an element of [0,1].

     The Rayleigh(b) random variable is equivalent to the
     Weibull(2,1/b), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull quantile is
     returned.

          (%i1) load (distrib)$
          (%i2) quantile_rayleigh(0.99,b);
                                                      1
          (%o2)             quantile_weibull(0.99, 2, -)
                                                      b
          (%i3) assume(x>0,b>0)$ quantile_rayleigh(0.99,b);
                                  2.145966026289347
          (%o4)                   -----------------
                                          b

 -- Function: mean_rayleigh (<b>)
     Returns the mean of a Rayleigh(b) random variable, with b>0.

     The Rayleigh(b) random variable is equivalent to the
     Weibull(2,1/b), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull mean is
     returned.

          (%i1) load (distrib)$
          (%i2) mean_rayleigh(b);
                                                 1
          (%o2)                  mean_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ mean_rayleigh(b);
                                      sqrt(%pi)
          (%o4)                       ---------
                                         2 b

 -- Function: var_rayleigh (<b>)
     Returns the variance of a Rayleigh(b) random variable, with b>0.

     The Rayleigh(b) random variable is equivalent to the
     Weibull(2,1/b), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull variance is
     returned.

          (%i1) load (distrib)$
          (%i2) var_rayleigh(b);
                                                 1
          (%o2)                   var_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ var_rayleigh(b);
                                           %pi
                                       1 - ---
                                            4
          (%o4)                        -------
                                          2
                                         b

 -- Function: std_rayleigh (<b>)
     Returns the standard deviation of a Rayleigh(b) random variable,
     with b>0.

     The Rayleigh(b) random variable is equivalent to the
     Weibull(2,1/b), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull standard
     deviation is returned.

          (%i1) load (distrib)$
          (%i2) std_rayleigh(b);
                                                 1
          (%o2)                   std_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ std_rayleigh(b);
                                             %pi
                                    sqrt(1 - ---)
                                              4
          (%o4)                     -------------
                                          b

 -- Function: skewness_rayleigh (<b>)
     Returns the skewness coefficient of a Rayleigh(b) random variable,
     with b>0.

     The Rayleigh(b) random variable is equivalent to the
     Weibull(2,1/b), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull skewness
     coefficient is returned.

          (%i1) load (distrib)$
          (%i2) skewness_rayleigh(b);
                                                   1
          (%o2)                skewness_weibull(2, -)
                                                   b
          (%i3) assume(b>0)$ skewness_rayleigh(b);
                                   3/2
                                %pi      3 sqrt(%pi)
                                ------ - -----------
                                  4           4
          (%o4)                 --------------------
                                         %pi 3/2
                                    (1 - ---)
                                          4

 -- Function: kurtosis_rayleigh (<b>)
     Returns the kurtosis coefficient of a Rayleigh(b) random variable,
     with b>0.

     The Rayleigh(b) random variable is equivalent to the
     Weibull(2,1/b), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull kurtosis
     coefficient is returned.

          (%i1) load (distrib)$
          (%i2) kurtosis_rayleigh(b);
                                                   1
          (%o2)                kurtosis_weibull(2, -)
                                                   b
          (%i3) assume(b>0)$ kurtosis_rayleigh(b);
                                            2
                                       3 %pi
                                   2 - ------
                                         16
          (%o4)                    ---------- - 3
                                        %pi 2
                                   (1 - ---)
                                         4

 -- Function: random_rayleigh (<b>)
 -- Function: random_rayleigh (<b>, <n>)
     Returns a Rayleigh(b) random variate, with b>0.  Calling
     `random_rayleigh' with a second argument <n>, a random sample of
     size <n> will be simulated.

     The implemented algorithm is based on the general inverse method.

     To make use of this function, write first `load(distrib)'.

 -- Function: pdf_laplace (<x>, <a>, <b>)
     Returns the value at <x> of the density function of a Laplace(a,b)
     random variable, with b>0.  To make use of this function, write
     first `load(distrib)'.

 -- Function: cdf_laplace (<x>, <a>, <b>)
     Returns the value at <x> of the distribution function of a
     Laplace(a,b) random variable, with b>0. To make use of this
     function, write first `load(distrib)'.

 -- Function: quantile_laplace (<q>, <a>, <b>)
     Returns the <q>-quantile of a Laplace(a,b) random variable, with
     b>0; in other words, this is the inverse of `cdf_laplace'.
     Argument <q> must be an element of [0,1].  To make use of this
     function, write first `load(distrib)'.

 -- Function: mean_laplace (<a>, <b>)
     Returns the mean of a Laplace(a,b) random variable, with b>0.  To
     make use of this function, write first `load(distrib)'.

 -- Function: var_laplace (<a>, <b>)
     Returns the variance of a Laplace(a,b) random variable, with b>0.
     To make use of this function, write first `load(distrib)'.

 -- Function: std_laplace (<a>, <b>)
     Returns the standard deviation of a Laplace(a,b) random variable,
     with b>0.  To make use of this function, write first
     `load(distrib)'.

 -- Function: skewness_laplace (<a>, <b>)
     Returns the skewness coefficient of a Laplace(a,b) random
     variable, with b>0.  To make use of this function, write first
     `load(distrib)'.

 -- Function: kurtosis_laplace (<a>, <b>)
     Returns the kurtosis coefficient of a Laplace(a,b) random
     variable, with b>0.  To make use of this function, write first
     `load(distrib)'.

 -- Function: random_laplace (<a>, <b>)
 -- Function: random_laplace (<a>, <b>, <n>)
     Returns a Laplace(a,b) random variate, with b>0.  Calling
     `random_laplace' with a third argument <n>, a random sample of size
     <n> will be simulated.

     The implemented algorithm is based on the general inverse method.

     To make use of this function, write first `load(distrib)'.

 -- Function: pdf_cauchy (<x>, <a>, <b>)
     Returns the value at <x> of the density function of a Cauchy(a,b)
     random variable, with b>0.  To make use of this function, write
     first `load(distrib)'.

 -- Function: cdf_cauchy (<x>, <a>, <b>)
     Returns the value at <x> of the distribution function of a
     Cauchy(a,b) random variable, with b>0.  To make use of this
     function, write first `load(distrib)'.

 -- Function: quantile_cauchy (<q>, <a>, <b>)
     Returns the <q>-quantile of a Cauchy(a,b) random variable, with
     b>0; in other words, this is the inverse of `cdf_cauchy'.  Argument
     <q> must be an element of [0,1].  To make use of this function,
     write first `load(distrib)'.

 -- Function: random_cauchy (<a>, <b>)
 -- Function: random_cauchy (<a>, <b>, <n>)
     Returns a Cauchy(a,b) random variate, with b>0.  Calling
     `random_cauchy' with a third argument <n>, a random sample of size
     <n> will be simulated.

     The implemented algorithm is based on the general inverse method.

     To make use of this function, write first `load(distrib)'.

 -- Function: pdf_gumbel (<x>, <a>, <b>)
     Returns the value at <x> of the density function of a Gumbel(a,b)
     random variable, with b>0.  To make use of this function, write
     first `load(distrib)'.

 -- Function: cdf_gumbel (<x>, <a>, <b>)
     Returns the value at <x> of the distribution function of a
     Gumbel(a,b) random variable, with b>0.  To make use of this
     function, write first `load(distrib)'.

 -- Function: quantile_gumbel (<q>, <a>, <b>)
     Returns the <q>-quantile of a Gumbel(a,b) random variable, with
     b>0; in other words, this is the inverse of `cdf_gumbel'.  Argument
     <q> must be an element of [0,1].  To make use of this function,
     write first `load(distrib)'.

 -- Function: mean_gumbel (<a>, <b>)
     Returns the mean of a Gumbel(a,b) random variable, with b>0.

          (%i1) load (distrib)$
          (%i2) assume(b>0)$  mean_gumbel(a,b);
          (%o3)                     %gamma b + a

     where symbol `%gamma' stands for the Euler-Mascheroni constant.
     See also `%gamma'.

 -- Function: var_gumbel (<a>, <b>)
     Returns the variance of a Gumbel(a,b) random variable, with b>0.
     To make use of this function, write first `load(distrib)'.

 -- Function: std_gumbel (<a>, <b>)
     Returns the standard deviation of a Gumbel(a,b) random variable,
     with b>0.  To make use of this function, write first
     `load(distrib)'.

 -- Function: skewness_gumbel (<a>, <b>)
     Returns the skewness coefficient of a Gumbel(a,b) random variable,
     with b>0.

          (%i1) load (distrib)$
          (%i2) assume(b>0)$ skewness_gumbel(a,b);
                                 12 sqrt(6) zeta(3)
          (%o3)                  ------------------
                                           3
                                        %pi
          (%i4) numer:true$ skewness_gumbel(a,b);
          (%o5)                   1.139547099404649
     where `zeta' stands for the Riemann's zeta function.

 -- Function: kurtosis_gumbel (<a>, <b>)
     Returns the kurtosis coefficient of a Gumbel(a,b) random variable,
     with b>0.  To make use of this function, write first
     `load(distrib)'.

 -- Function: random_gumbel (<a>, <b>)
 -- Function: random_gumbel (<a>, <b>, <n>)
     Returns a Gumbel(a,b) random variate, with b>0.  Calling
     `random_gumbel' with a third argument <n>, a random sample of size
     <n> will be simulated.

     The implemented algorithm is based on the general inverse method.

     To make use of this function, write first `load(distrib)'.


File: maxima.info,  Node: Functions and Variables for discrete distributions,  Prev: Functions and Variables for continuous distributions,  Up: Package distrib

41.3 Functions and Variables for discrete distributions
=======================================================

 -- Function: pdf_general_finite_discrete (<x>, <v>)
     Returns the value at <x> of the probability function of a general
     finite discrete random variable, with vector probabilities v, such
     that `Pr(X=i) = v_i'.  Vector v can be a list of nonnegative
     expressions, whose components will be normalized to get a vector
     of probabilities.  To make use of this function, write first
     `load(distrib)'.

     Examples:

          (%i1) load (distrib)$
          (%i2) pdf_general_finite_discrete(2, [1/7, 4/7, 2/7]);
                                          4
          (%o2)                           -
                                          7
          (%i3) pdf_general_finite_discrete(2, [1, 4, 2]);
                                          4
          (%o3)                           -
                                          7

 -- Function: cdf_general_finite_discrete (<x>, <v>)
     Returns the value at <x> of the distribution function of a general
     finite discrete random variable, with vector probabilities v.

     See `pdf_general_finite_discrete'  for more details.

     Examples:

          (%i1) load (distrib)$
          (%i2) cdf_general_finite_discrete(2, [1/7, 4/7, 2/7]);
                                          5
          (%o2)                           -
                                          7
          (%i3) cdf_general_finite_discrete(2, [1, 4, 2]);
                                          5
          (%o3)                           -
                                          7
          (%i4) cdf_general_finite_discrete(2+1/2, [1, 4, 2]);
                                          5
          (%o4)                           -
                                          7

 -- Function: quantile_general_finite_discrete (<q>, <v>)
     Returns the <q>-quantile of a general finite discrete random
     variable, with vector probabilities v.

     See `pdf_general_finite_discrete'  for more details.

 -- Function: mean_general_finite_discrete (<v>)
     Returns the mean of a general finite discrete random variable,
     with vector probabilities v.

     See `pdf_general_finite_discrete'  for more details.

 -- Function: var_general_finite_discrete (<v>)
     Returns the variance of a general finite discrete random variable,
     with vector probabilities v.

     See `pdf_general_finite_discrete'  for more details.

 -- Function: std_general_finite_discrete (<v>)
     Returns the standard deviation of a general finite discrete random
     variable, with vector probabilities v.

     See `pdf_general_finite_discrete'  for more details.

 -- Function: skewness_general_finite_discrete (<v>)
     Returns the skewness coefficient of a general finite discrete
     random variable, with vector probabilities v.

     See `pdf_general_finite_discrete'  for more details.

 -- Function: kurtosis_general_finite_discrete (<v>)
     Returns the kurtosis coefficient of a general finite discrete
     random variable, with vector probabilities v.

     See `pdf_general_finite_discrete'  for more details.

 -- Function: random_general_finite_discrete (<v>)
 -- Function: random_general_finite_discrete (<v>, <m>)
     Returns a general finite discrete random variate, with vector
     probabilities v.  Calling `random_general_finite_discrete' with a
     second argument <m>, a random sample of size <m> will be simulated.

     See `pdf_general_finite_discrete'  for more details.

     Examples:

          (%i1) load (distrib)$
          (%i2) random_general_finite_discrete([1,3,1,5]);
          (%o2)                          4
          (%i3) random_general_finite_discrete([1,3,1,5], 10);
          (%o3)           [4, 2, 2, 3, 2, 4, 4, 1, 2, 2]

 -- Function: pdf_binomial (<x>, <n>, <p>)
     Returns the value at <x> of the probability function of a
     Binomial(n,p) random variable, with 0<p<1 and n a positive
     integer.  To make use of this function, write first
     `load(distrib)'.

 -- Function: cdf_binomial (<x>, <n>, <p>)
     Returns the value at <x> of the distribution function of a
     Binomial(n,p) random variable, with 0<p<1 and n a positive integer.

          (%i1) load (distrib)$
          (%i2) cdf_binomial(5,7,1/6);
                                      7775
          (%o2)                       ----
                                      7776
          (%i3) float(%);
          (%o3)               .9998713991769548

 -- Function: quantile_binomial (<q>, <n>, <p>)
     Returns the <q>-quantile of a Binomial(n,p) random variable, with
     0<p<1 and n a positive integer; in other words, this is the
     inverse of `cdf_binomial'.  Argument <q> must be an element of
     [0,1].  To make use of this function, write first `load(distrib)'.

 -- Function: mean_binomial (<n>, <p>)
     Returns the mean of a Binomial(n,p) random variable, with 0<p<1
     and n a positive integer.  To make use of this function, write
     first `load(distrib)'.

 -- Function: var_binomial (<n>, <p>)
     Returns the variance of a Binomial(n,p) random variable, with
     0<p<1 and n a positive integer.  To make use of this function,
     write first `load(distrib)'.

 -- Function: std_binomial (<n>, <p>)
     Returns the standard deviation of a Binomial(n,p) random variable,
     with 0<p<1 and n a positive integer.  To make use of this function,
     write first `load(distrib)'.

 -- Function: skewness_binomial (<n>, <p>)
     Returns the skewness coefficient of a Binomial(n,p) random
     variable, with 0<p<1 and n a positive integer.  To make use of this
     function, write first `load(distrib)'.

 -- Function: kurtosis_binomial (<n>, <p>)
     Returns the kurtosis coefficient of a Binomial(n,p) random
     variable, with 0<p<1 and n a positive integer.  To make use of this
     function, write first `load(distrib)'.

 -- Function: random_binomial (<n>, <p>)
 -- Function: random_binomial (<n>, <p>, <m>)
     Returns a Binomial(n,p) random variate, with 0<p<1 and n a
     positive integer.  Calling `random_binomial' with a third argument
     <m>, a random sample of size <m> will be simulated.

     The implemented algorithm is based on the one described in
     Kachitvichyanukul, V. and Schmeiser, B.W. (1988) <Binomial Random
     Variate Generation>.  Communications of the ACM, 31, Feb., 216.

     To make use of this function, write first `load(distrib)'.

 -- Function: pdf_poisson (<x>, <m>)
     Returns the value at <x> of the probability function of a
     Poisson(m) random variable, with m>0.  To make use of this
     function, write first `load(distrib)'.

 -- Function: cdf_poisson (<x>, <m>)
     Returns the value at <x> of the distribution function of a
     Poisson(m) random variable, with m>0.

          (%i1) load (distrib)$
          (%i2) cdf_poisson(3,5);
          (%o2)       gamma_incomplete_regularized(4, 5)
          (%i3) float(%);
          (%o3)               .2650259152973623

 -- Function: quantile_poisson (<q>, <m>)
     Returns the <q>-quantile of a Poisson(m) random variable, with
     m>0; in other words, this is the inverse of `cdf_poisson'.
     Argument <q> must be an element of [0,1].  To make use of this
     function, write first `load(distrib)'.

 -- Function: mean_poisson (<m>)
     Returns the mean of a Poisson(m) random variable, with  m>0.  To
     make use of this function, write first `load(distrib)'.

 -- Function: var_poisson (<m>)
     Returns the variance of a Poisson(m) random variable, with  m>0.
     To make use of this function, write first `load(distrib)'.

 -- Function: std_poisson (<m>)
     Returns the standard deviation of a Poisson(m) random variable,
     with m>0.  To make use of this function, write first
     `load(distrib)'.

 -- Function: skewness_poisson (<m>)
     Returns the skewness coefficient of a Poisson(m) random variable,
     with m>0.  To make use of this function, write first
     `load(distrib)'.

 -- Function: kurtosis_poisson (<m>)
     Returns the kurtosis coefficient of a Poisson random variable
     Poi(m), with m>0.  To make use of this function, write first
     `load(distrib)'.

 -- Function: random_poisson (<m>)
 -- Function: random_poisson (<m>, <n>)
     Returns a Poisson(m) random variate, with m>0.  Calling
     `random_poisson' with a second argument <n>, a random sample of
     size <n> will be simulated.

     The implemented algorithm is the one described in Ahrens, J.H. and
     Dieter, U. (1982) <Computer Generation of Poisson Deviates From
     Modified Normal Distributions>. ACM Trans. Math. Software, 8, 2,
     June,163-179.

     To make use of this function, write first `load(distrib)'.

 -- Function: pdf_bernoulli (<x>, <p>)
     Returns the value at <x> of the probability function of a
     Bernoulli(p) random variable, with 0<p<1.

     The Bernoulli(p) random variable is equivalent to the
     Binomial(1,p), therefore when Maxima has not enough information to
     get the result, a noun form based on the binomial probability
     function is returned.

          (%i1) load (distrib)$
          (%i2) pdf_bernoulli(1,p);
          (%o2)                 pdf_binomial(1, 1, p)
          (%i3) assume(0<p,p<1)$ pdf_bernoulli(1,p);
          (%o4)                           p

 -- Function: cdf_bernoulli (<x>, <p>)
     Returns the value at <x> of the distribution function of a
     Bernoulli(p) random variable, with 0<p<1.  To make use of this
     function, write first `load(distrib)'.

 -- Function: quantile_bernoulli (<q>, <p>)
     Returns the <q>-quantile of a Bernoulli(p) random variable, with
     0<p<1; in other words, this is the inverse of `cdf_bernoulli'.
     Argument <q> must be an element of [0,1].  To make use of this
     function, write first `load(distrib)'.

 -- Function: mean_bernoulli (<p>)
     Returns the mean of a Bernoulli(p) random variable, with 0<p<1.

     The Bernoulli(p) random variable is equivalent to the
     Binomial(1,p), therefore when Maxima has not enough information to
     get the result, a noun form based on the binomial mean is returned.

          (%i1) load (distrib)$
          (%i2) mean_bernoulli(p);
          (%o2)                  mean_binomial(1, p)
          (%i3) assume(0<p,p<1)$ mean_bernoulli(p);
          (%o4)                           p

 -- Function: var_bernoulli (<p>)
     Returns the variance of a Bernoulli(p) random variable, with 0<p<1.

     The Bernoulli(p) random variable is equivalent to the
     Binomial(1,p), therefore when Maxima has not enough information to
     get the result, a noun form based on the binomial variance is
     returned.

          (%i1) load (distrib)$
          (%i2) var_bernoulli(p);
          (%o2)                  var_binomial(1, p)
          (%i3) assume(0<p,p<1)$ var_bernoulli(p);
          (%o4)                       (1 - p) p

 -- Function: std_bernoulli (<p>)
     Returns the standard deviation of a Bernoulli(p) random variable,
     with 0<p<1.

     The Bernoulli(p) random variable is equivalent to the
     Binomial(1,p), therefore when Maxima has not enough information to
     get the result, a noun form based on the binomial standard
     deviation is returned.

          (%i1) load (distrib)$
          (%i2) std_bernoulli(p);
          (%o2)                  std_binomial(1, p)
          (%i3) assume(0<p,p<1)$ std_bernoulli(p);
          (%o4)                  sqrt(1 - p) sqrt(p)

 -- Function: skewness_bernoulli (<p>)
     Returns the skewness coefficient of a Bernoulli(p) random variable,
     with 0<p<1.

     The Bernoulli(p) random variable is equivalent to the
     Binomial(1,p), therefore when Maxima has not enough information to
     get the result, a noun form based on the binomial skewness
     coefficient is returned.

          (%i1) load (distrib)$
          (%i2) skewness_bernoulli(p);
          (%o2)                skewness_binomial(1, p)
          (%i3) assume(0<p,p<1)$ skewness_bernoulli(p);
                                       1 - 2 p
          (%o4)                  -------------------
                                 sqrt(1 - p) sqrt(p)

 -- Function: kurtosis_bernoulli (<p>)
     Returns the kurtosis coefficient of a Bernoulli(p) random variable,
     with 0<p<1.

     The Bernoulli(p) random variable is equivalent to the
     Binomial(1,p), therefore when Maxima has not enough information to
     get the result, a noun form based on the binomial kurtosis
     coefficient is returned.

          (%i1) load (distrib)$
          (%i2) kurtosis_bernoulli(p);
          (%o2)                kurtosis_binomial(1, p)
          (%i3) assume(0<p,p<1)$ kurtosis_bernoulli(p);
                                   1 - 6 (1 - p) p
          (%o4)                    ---------------
                                      (1 - p) p

 -- Function: random_bernoulli (<p>)
 -- Function: random_bernoulli (<p>, <n>)
     Returns a Bernoulli(p) random variate, with 0<p<1.  Calling
     `random_bernoulli' with a second argument <n>, a random sample of
     size <n> will be simulated.

     This is a direct application of the `random' built-in Maxima
     function.

     See also `random'. To make use of this function, write first
     `load(distrib)'.

 -- Function: pdf_geometric (<x>, <p>)
     Returns the value at <x> of the probability function of a
     Geometric(p) random variable, with 0<p<1.  To make use of this
     function, write first `load(distrib)'.

 -- Function: cdf_geometric (<x>, <p>)
     Returns the value at <x> of the distribution function of a
     Geometric(p) random variable, with 0<p<1.  To make use of this
     function, write first `load(distrib)'.

 -- Function: quantile_geometric (<q>, <p>)
     Returns the <q>-quantile of a Geometric(p) random variable, with
     0<p<1; in other words, this is the inverse of `cdf_geometric'.
     Argument <q> must be an element of [0,1].  To make use of this
     function, write first `load(distrib)'.

 -- Function: mean_geometric (<p>)
     Returns the mean of a Geometric(p) random variable, with 0<p<1.
     To make use of this function, write first `load(distrib)'.

 -- Function: var_geometric (<p>)
     Returns the variance of a Geometric(p) random variable, with
     0<p<1.  To make use of this function, write first `load(distrib)'.

 -- Function: std_geometric (<p>)
     Returns the standard deviation of a Geometric(p) random variable,
     with 0<p<1. To make use of this function, write first
     `load(distrib)'.

 -- Function: skewness_geometric (<p>)
     Returns the skewness coefficient of a Geometric(p) random
     variable, with 0<p<1.  To make use of this function, write first
     `load(distrib)'.

 -- Function: kurtosis_geometric (<p>)
     Returns the kurtosis coefficient of a geometric random variable
     Geo(p), with 0<p<1.  To make use of this function, write first
     `load(distrib)'.

 -- Function: random_geometric (<p>)
 -- Function: random_geometric (<p>, <n>)
     Returns a Geometric(p) random variate, with 0<p<1.  Calling
     `random_geometric' with a second argument <n>, a random sample of
     size <n> will be simulated.

     The algorithm is based on simulation of Bernoulli trials.

     To make use of this function, write first `load(distrib)'.

 -- Function: pdf_discrete_uniform (<x>, <n>)
     Returns the value at <x> of the probability function of a Discrete
     Uniform(n) random variable, with n a strictly positive integer.
     To make use of this function, write first `load(distrib)'.

 -- Function: cdf_discrete_uniform (<x>, <n>)
     Returns the value at <x> of the distribution function of a
     Discrete Uniform(n) random variable, with n a strictly positive
     integer.  To make use of this function, write first
     `load(distrib)'.

 -- Function: quantile_discrete_uniform (<q>, <n>)
     Returns the <q>-quantile of a Discrete Uniform(n) random variable,
     with n a strictly positive integer; in other words, this is the
     inverse of `cdf_discrete_uniform'.  Argument <q> must be an
     element of [0,1].  To make use of this function, write first
     `load(distrib)'.

 -- Function: mean_discrete_uniform (<n>)
     Returns the mean of a Discrete Uniform(n) random variable, with n
     a strictly positive integer.  To make use of this function, write
     first `load(distrib)'.

 -- Function: var_discrete_uniform (<n>)
     Returns the variance of a Discrete Uniform(n) random variable, with
     n a strictly positive integer.  To make use of this function, write
     first `load(distrib)'.

 -- Function: std_discrete_uniform (<n>)
     Returns the standard deviation of a Discrete Uniform(n) random
     variable, with n a strictly positive integer.  To make use of this
     function, write first `load(distrib)'.

 -- Function: skewness_discrete_uniform (<n>)
     Returns the skewness coefficient of a Discrete Uniform(n) random
     variable, with n a strictly positive integer.  To make use of this
     function, write first `load(distrib)'.

 -- Function: kurtosis_discrete_uniform (<n>)
     Returns the kurtosis coefficient of a Discrete Uniform(n) random
     variable, with n a strictly positive integer.  To make use of this
     function, write first `load(distrib)'.

 -- Function: random_discrete_uniform (<n>)
 -- Function: random_discrete_uniform (<n>, <m>)
     Returns a Discrete Uniform(n) random variate, with n a strictly
     positive integer.  Calling `random_discrete_uniform' with a second
     argument <m>, a random sample of size <m> will be simulated.

     This is a direct application of the `random' built-in Maxima
     function.

     See also `random'.  To make use of this function, write first
     `load(distrib)'.

 -- Function: pdf_hypergeometric (<x>, <n1>, <n2>, <n>)
     Returns the value at <x> of the probability function of a
     Hypergeometric(n1,n2,n) random variable, with <n1>, <n2> and <n>
     non negative integers and n<=n1+n2.  Being <n1> the number of
     objects of class A, <n2> the number of objects of class B, and <n>
     the size of the sample without replacement, this function returns
     the probability of event "exactly <x> objects are of class A".

     To make use of this function, write first `load(distrib)'.

 -- Function: cdf_hypergeometric (<x>, <n1>, <n2>, <n>)
     Returns the value at <x> of the distribution function of a
     Hypergeometric(n1,n2,n) random variable, with <n1>, <n2> and <n>
     non negative integers and n<=n1+n2.  See `pdf_hypergeometric'  for
     a more complete description.

     To make use of this function, write first `load(distrib)'.

 -- Function: quantile_hypergeometric (<q>, <n1>, <n2>, <n>)
     Returns the <q>-quantile of a Hypergeometric(n1,n2,n) random
     variable, with <n1>, <n2> and <n> non negative integers and
     n<=n1+n2; in other words, this is the inverse of
     `cdf_hypergeometric'.  Argument <q> must be an element of [0,1].
     To make use of this function, write first `load(distrib)'.

 -- Function: mean_hypergeometric (<n1>, <n2>, <n>)
     Returns the mean of a discrete uniform random variable
     Hyp(n1,n2,n), with <n1>, <n2> and <n> non negative integers and
     n<=n1+n2.  To make use of this function, write first
     `load(distrib)'.

 -- Function: var_hypergeometric (<n1>, <n2>, <n>)
     Returns the variance of a hypergeometric  random variable
     Hyp(n1,n2,n), with <n1>, <n2> and <n> non negative integers and
     n<=n1+n2.  To make use of this function, write first
     `load(distrib)'.

 -- Function: std_hypergeometric (<n1>, <n2>, <n>)
     Returns the standard deviation of a Hypergeometric(n1,n2,n) random
     variable, with <n1>, <n2> and <n> non negative integers and
     n<=n1+n2.  To make use of this function, write first
     `load(distrib)'.

 -- Function: skewness_hypergeometric (<n1>, <n2>, <n>)
     Returns the skewness coefficient of a Hypergeometric(n1,n2,n)
     random variable, with <n1>, <n2> and <n> non negative integers and
     n<=n1+n2.  To make use of this function, write first
     `load(distrib)'.

 -- Function: kurtosis_hypergeometric (<n1>, <n2>, <n>)
     Returns the kurtosis coefficient of a Hypergeometric(n1,n2,n)
     random variable, with <n1>, <n2> and <n> non negative integers and
     n<=n1+n2.  To make use of this function, write first
     `load(distrib)'.

 -- Function: random_hypergeometric (<n1>, <n2>, <n>)
 -- Function: random_hypergeometric (<n1>, <n2>, <n>, <m>)
     Returns a Hypergeometric(n1,n2,n) random variate, with <n1>, <n2>
     and <n> non negative integers and n<=n1+n2.  Calling
     `random_hypergeometric' with a fourth argument <m>, a random
     sample of size <m> will be simulated.

     Algorithm described in Kachitvichyanukul, V., Schmeiser, B.W.
     (1985) <Computer generation of hypergeometric random variates.>
     Journal of Statistical Computation and Simulation 22, 127-145.

     To make use of this function, write first `load(distrib)'.

 -- Function: pdf_negative_binomial (<x>, <n>, <p>)
     Returns the value at <x> of the probability function of a Negative
     Binomial(n,p) random variable, with 0<p<1 and n a positive
     integer.  To make use of this function, write first
     `load(distrib)'.

 -- Function: cdf_negative_binomial (<x>, <n>, <p>)
     Returns the value at <x> of the distribution function of a
     Negative Binomial(n,p) random variable, with 0<p<1 and n a
     positive integer.

          (%i1) load (distrib)$
          (%i2) cdf_negative_binomial(3,4,1/8);
                                      3271
          (%o2)                      ------
                                     524288
          (%i3) float(%);
          (%o3)              .006238937377929687

 -- Function: quantile_negative_binomial (<q>, <n>, <p>)
     Returns the <q>-quantile of a Negative Binomial(n,p) random
     variable, with 0<p<1 and n a positive integer; in other words,
     this is the inverse of `cdf_negative_binomial'.  Argument <q> must
     be an element of [0,1].  To make use of this function, write first
     `load(distrib)'.

 -- Function: mean_negative_binomial (<n>, <p>)
     Returns the mean of a Negative Binomial(n,p) random variable, with
     0<p<1 and n a positive integer.  To make use of this function,
     write first `load(distrib)'.

 -- Function: var_negative_binomial (<n>, <p>)
     Returns the variance of a Negative Binomial(n,p) random variable,
     with 0<p<1 and n a positive integer.  To make use of this function,
     write first `load(distrib)'.

 -- Function: std_negative_binomial (<n>, <p>)
     Returns the standard deviation of a Negative Binomial(n,p) random
     variable, with 0<p<1 and n a positive integer.  To make use of
     this function, write first `load(distrib)'.

 -- Function: skewness_negative_binomial (<n>, <p>)
     Returns the skewness coefficient of a Negative Binomial(n,p) random
     variable, with 0<p<1 and n a positive integer.  To make use of
     this function, write first `load(distrib)'.

 -- Function: kurtosis_negative_binomial (<n>, <p>)
     Returns the kurtosis coefficient of a Negative Binomial(n,p) random
     variable, with 0<p<1 and n a positive integer.  To make use of
     this function, write first `load(distrib)'.

 -- Function: random_negative_binomial (<n>, <p>)
 -- Function: random_negative_binomial (<n>, <p>, <m>)
     Returns a Negative Binomial(n,p) random variate, with 0<p<1 and n
     a positive integer.  Calling `random_negative_binomial' with a
     third argument <m>, a random sample of size <m> will be simulated.

     Algorithm described in Devroye, L. (1986) <Non-Uniform Random
     Variate Generation>. Springer Verlag, p. 480.

     To make use of this function, write first `load(distrib)'.


File: maxima.info,  Node: draw,  Next: drawdf,  Prev: Package distrib,  Up: Top

42 draw
*******

* Menu:

* Introduction to draw::
* Functions and Variables for draw::
* Functions and Variables for pictures::
* Functions and Variables for worldmap::


File: maxima.info,  Node: Introduction to draw,  Next: Functions and Variables for draw,  Prev: draw,  Up: draw

42.1 Introduction to draw
=========================

`draw' is a Maxima-Gnuplot interface.

There are three main functions to be used at Maxima level: `draw2d',
`draw3d' and `draw'.

Follow this link for more elaborated examples of this package:

`http://riotorto.users.sourceforge.net/gnuplot'

You need Gnuplot 4.2 or newer to run this program.


File: maxima.info,  Node: Functions and Variables for draw,  Next: Functions and Variables for pictures,  Prev: Introduction to draw,  Up: draw

42.2 Functions and Variables for draw
=====================================

42.2.1 Scenes
-------------

 -- Scene constructor: gr2d (<graphic option>, ..., <graphic object>,
          ...)
     Function `gr2d' builds an object describing a 2D scene.  Arguments
     are graphic options, graphic objects, or lists containing both
     graphic options and objects.  This scene is interpreted
     sequentially: graphic options affect those graphic objects placed
     on its right.  Some graphic options affect the global appearence
     of the scene.

     This is the list of graphic objects available for scenes in two
     dimensions:
     `bars',
     `ellipse',
     `explicit',
     `image',
     `implicit',
     `label',
     `parametric',
     `points',
     `polar',
     `polygon',
     `quadrilateral',
     `rectangle',
     `triangle',
     `vector', and
     `geomap' (this one defined in package `worldmap').

     See also `draw' and `draw2d'.  To make use of this object, write
     first `load(draw)'.

 -- Scene constructor: gr3d (<graphic option>, ..., <graphic object>,
          ...)
     Function `gr3d' builds an object describing a 3d scene.  Arguments
     are graphic options, graphic objects, or lists containing both
     graphic options and objects.  This scene is interpreted
     sequentially: graphic options affect those graphic objects placed
     on its right.  Some graphic options affect the global appearence
     of the scene.

     This is the list of graphic objects available for scenes in three
     dimensions:
     `cylindrical',
     `elevation_grid',
     `explicit',
     `implicit',
     `label',
     `mesh',
     `parametric',
     `parametric_surface',
     `points',
     `quadrilateral',
     `spherical',
     `triangle',
     `tube',
     `vector', and
     `geomap' (this one defined in package `worldmap').

     See also `draw' and `draw3d'.  To make use of this object, write
     first `load(draw)'.

42.2.2 Functions
----------------

 -- Function: draw (<gr2d>, ..., <gr3d>, ..., <options>, ...)
     Plots a series of scenes; its arguments are `gr2d' and/or `gr3d'
     objects, together with some options, or lists of scenes and
     options.  By default, the scenes are put together in one column.

     Function `draw' accepts the following global options: `terminal',
     `columns', `dimensions', `file_name' and `delay'.

     Functions `draw2d' and `draw3d' are short cuts to be used when
     only one scene is required, in two or three dimensions,
     respectively.

     See also `gr2d' and `gr3d'.  To make use of this function, write
     first `load(draw)'.

     Example:

          (%i1) load(draw)$
          (%i2) scene1: gr2d(title="Ellipse",
                             nticks=30,
                             parametric(2*cos(t),5*sin(t),t,0,2*%pi))$
          (%i3) scene2: gr2d(title="Triangle",
                             polygon([4,5,7],[6,4,2]))$
          (%i4) draw(scene1, scene2, columns = 2)$

     The two draw sentences are equivalent:

          (%i1) load(draw)$
          (%i2) draw(gr3d(explicit(x^2+y^2,x,-1,1,y,-1,1)));
          (%o2)                          [gr3d(explicit)]
          (%i3) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1));
          (%o3)                          [gr3d(explicit)]

     An animated gif file:

          (%i1) load(draw)$
          (%i2) draw(
                  delay     = 100,
                  file_name = "zzz",
                  terminal  = 'animated_gif,
                  gr2d(explicit(x^2,x,-1,1)),
                  gr2d(explicit(x^3,x,-1,1)),
                  gr2d(explicit(x^4,x,-1,1)));
          End of animation sequence
          (%o2)          [gr2d(explicit), gr2d(explicit), gr2d(explicit)]

     See also `gr2d', `gr3d', `draw2d' and `draw3d'.

 -- Function: draw2d (<option>, <graphic_object>, ...)
     This function is a short cut for `draw(gr2d(<options>, ...,
     <graphic_object>, ...))'.

     It can be used to plot a unique scene in 2d.

     To make use of this function, write first `load(draw)'.

     See also `draw' and `gr2d'.

 -- Function: draw3d (<option>, <graphic_object>, ...)
     This function is a short cut for `draw(gr3d(<options>, ...,
     <graphic_object>, ...))'.

     It can be used to plot a unique scene in 3d.

     To make use of this function, write first `load(draw)'.

     See also `draw' and `gr3d'.

 -- Function: draw_file (<graphic option>, ..., <graphic object>, ...)
     Saves the current plot into a file.  Accepted graphics options are:
     `terminal', `dimensions', `file_name' and `background_color'.

     Example:

          (%i1) load(draw)$
          (%i2) /* screen plot */
                draw(gr3d(explicit(x^2+y^2,x,-1,1,y,-1,1)))$
          (%i3) /* same plot in eps format */
                draw_file(terminal  = eps,
                          dimensions = [5,5]) $

 -- Function: multiplot_mode (<term>)
     This function enables Maxima to work in one-window multiplot mode
     with terminal <term>; accepted arguments for this function are
     `screen', `wxt', `aquaterm' and `none'.

     When multiplot mode is enabled, each call to `draw' sends a new
     plot to the same window, without erasing the previous ones.  To
     disable the multiplot mode, write `multiplot_mode(none)'.

     When multiplot mode is enabled, global option `terminal' is
     blocked and you have to disable this working mode before changing
     to another terminal.

     This feature does not work in Windows platforms.

     Example:

          (%i1) load(draw)$
          (%i2) set_draw_defaults(
                   xrange = [-1,1],
                   yrange = [-1,1],
                   grid   = true,
                   title  = "Step by step plot" )$
          (%i3) multiplot_mode(screen)$
          (%i4) draw2d(color=blue,  explicit(x^2,x,-1,1))$
          (%i5) draw2d(color=red,   explicit(x^3,x,-1,1))$
          (%i6) draw2d(color=brown, explicit(x^4,x,-1,1))$
          (%i7) multiplot_mode(none)$

 -- Function: set_draw_defaults (<graphic option>, ..., <graphic
          object>, ...)
     Sets user graphics options.  This function is useful for plotting
     a sequence of graphics with common graphics options.  Calling this
     function without arguments removes user defaults.

     Example:

          (%i1) load(draw)$
          (%i2) set_draw_defaults(
                   xrange = [-10,10],
                   yrange = [-2, 2],
                   color  = blue,
                   grid   = true)$
          (%i3) /* plot with user defaults */
                draw2d(explicit(((1+x)**2/(1+x*x))-1,x,-10,10))$
          (%i4) set_draw_defaults()$
          (%i5) /* plot with standard defaults */
                draw2d(explicit(((1+x)**2/(1+x*x))-1,x,-10,10))$

     To make use of this function, write first `load(draw)'.

42.2.3 Graphics options
-----------------------

 -- Graphic option: adapt_depth
     Default value: 10

     `adapt_depth' is the maximum number of splittings used by the
     adaptive plotting routine.

     This option is relevant only for 2d `explicit' functions.

 -- Graphic option: axis_3d
     Default value: `true'

     If `axis_3d' is `true', the <x>, <y> and <z> axis are shown in 3d
     scenes.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(axis_3d = false,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

     See also `axis_bottom',  `axis_left', `axis_top', and `axis_right'
     for axis in 2d.

 -- Graphic option: axis_bottom
     Default value: `true'

     If `axis_bottom' is `true', the bottom axis is shown in 2d scenes.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(axis_bottom = false,
                       explicit(x^3,x,-1,1))$

     See also `axis_left',  `axis_top', `axis_right', and `axis_3d'.

 -- Graphic option: axis_left
     Default value: `true'

     If `axis_left' is `true', the left axis is shown in 2d scenes.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(axis_left = false,
                       explicit(x^3,x,-1,1))$

     See also `axis_bottom',  `axis_top', `axis_right', and `axis_3d'.

 -- Graphic option: axis_right
     Default value: `true'

     If `axis_right' is `true', the right axis is shown in 2d scenes.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(axis_right = false,
                       explicit(x^3,x,-1,1))$

     See also `axis_bottom',  `axis_left', `axis_top', and `axis_3d'.

 -- Graphic option: axis_top
     Default value: `true'

     If `axis_top' is `true', the top axis is shown in 2d scenes.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(axis_top = false,
                       explicit(x^3,x,-1,1))$

     See also `axis_bottom',  `axis_left', `axis_right', and `axis_3d'.

 -- Graphic option: background_color
     Default value: `white'

     Sets the background color for terminals `gif', `png', `jpg', and
     `gif'.  Default background color is white.

     See also `color'.

 -- Graphic option: border
     Default value: `true'

     If `border' is `true', borders of polygons are painted according
     to `line_type' and `line_width'.

     This option affects the following graphic objects:
        * `gr2d': `polygon', `rectangle', and `ellipse'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(color       = brown,
                       line_width  = 8,
                       polygon([[3,2],[7,2],[5,5]]),
                       border      = false,
                       fill_color  = blue,
                       polygon([[5,2],[9,2],[7,5]]) )$

 -- Graphic option: cbrange
     Default value: `auto'

     If `cbrange' is `auto', the range for the values which are colored
     when `enhanced3d' is not `false' is computed automatically.
     Values outside of the color range use color of the nearest extreme.

     When `enhanced3d' or `colorbox' is `false', option `cbrange' has
     no effect.

     If the user wants a specific interval for the colored values, it
     must be given as a Maxima list, as in `cbrange=[-2, 3]'.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d (
                  enhanced3d     = true,
                  color          = green,
                  cbrange = [-3,10],
                  explicit(x^2+y^2, x,-2,2,y,-2,2)) $

     See also `enhanced3d', `colorbox' and `cbtics'.

 -- Graphic option: cbtics
     Default value: `auto'

     This graphic option controls the way tic marks are drawn on the
     colorbox when option `enhanced3d' is not `false'.

     When `enhanced3d' or `colorbox' is `false', option `cbtics' has no
     effect.

     See `xtics' for a complete description.

     Example :

          (%i1) load(draw)$
          (%i2) draw3d (
                  enhanced3d = true,
                  color      = green,
                  cbtics  = {["High",10],["Medium",05],["Low",0]},
                  cbrange = [0, 10],
                  explicit(x^2+y^2, x,-2,2,y,-2,2)) $

     See also `enhanced3d', `colorbox' and `cbrange'.

 -- Graphic option: color
     Default value: `blue'

     `color' specifies the color for plotting lines, points, borders of
     polygons and labels.

     Colors can be given as names or in hexadecimal rgb code.

     Available color names are: white            black            gray0            grey0
     gray10           grey10           gray20           grey20
     gray30           grey30           gray40           grey40
     gray50           grey50           gray60           grey60
     gray70           grey70           gray80           grey80
     gray90           grey90           gray100          grey100
     gray             grey             light_gray       light_grey
     dark_gray        dark_grey        red              light_red
     dark_red         yellow           light_yellow     dark_yellow
     green            light_green      dark_green       spring_green
     forest_green     sea_green        blue             light_blue
     dark_blue        midnight_blue    navy             medium_blue
     royalblue        skyblue          cyan             light_cyan
     dark_cyan        magenta          light_magenta    dark_magenta
     turquoise        light_turquoise  dark_turquoise   pink
     light_pink       dark_pink        coral            light_coral
     orange_red       salmon           light_salmon     dark_salmon
     aquamarine       khaki            dark_khaki       goldenrod
     light_goldenrod  dark_goldenrod   gold             beige
     brown            orange           dark_orange      violet
     dark_violet      plum             purple

     Cromatic componentes in hexadecimal code are introduced in the form
     `"#rrggbb"'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^2,x,_1,1), /* default is black */
                       color = red,
                       explicit(0.5 + x^2,x,-1,1),
                       color = blue,
                       explicit(1 + x^2,x,-1,1),
                       color = light_blue,
                       explicit(1.5 + x^2,x,-1,1),
                       color = "#23ab0f",
                       label(["This is a label",0,1.2])  )$

     See also `fill_color'.

 -- Graphic option: colorbox
     Default value: `true'

     If `colorbox' is `true', a color scale without label is drawn
     together with `image' 2D objects, or coloured 3d objects.  If
     `colorbox' is `false', no color scale is shown.  If `colorbox' is
     a string, a color scale with label is drawn.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

     Color scale and images.

          (%i1) load(draw)$
          (%i2) im: apply('matrix,
                           makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(colorbox = false, image(im,0,0,30,30))$

     Color scale and 3D coloured object.

          (%i1) load(draw)$
          (%i2) draw3d(
                  colorbox   = "Magnitude",
                  enhanced3d = true,
                  explicit(x^2+y^2,x,-1,1,y,-1,1))$

     See also `palette'.

 -- Graphic option: columns
     Default value: 1

     `columns' is the number of columns in multiple plots.

     Since this is a global graphics option, its position in the scene
     description does not matter.  It can be also used as an argument
     of function `draw'.

     Example:

          (%i1) load(draw)$
          (%i2) scene1: gr2d(title="Ellipse",
                             nticks=30,
                             parametric(2*cos(t),5*sin(t),t,0,2*%pi))$
          (%i3) scene2: gr2d(title="Triangle",
                             polygon([4,5,7],[6,4,2]))$
          (%i4) draw(scene1, scene2, columns = 2)$

 -- Graphic option: contour
     Default value: `none'

     Option `contour' enables the user to select where to plot contour
     lines.  Possible values are:

        * `none': no contour lines are plotted.

        * `base': contour lines are projected on the xy plane.

        * `surface': contour lines are plotted on the surface.

        * `both': two contour lines are plotted: on the xy plane and on
          the surface.

        * `map': contour lines are projected on the xy plane, and the
          view point is set just in the vertical.


     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = 15,
                       contour        = both,
                       surface_hide   = true) $

 -- Graphic option: contour_levels
     Default value: 5

     This graphic option controls the way contours are drawn.
     `contour_levels' can be set to a positive integer number, a list
     of three numbers or an arbitrary set of numbers:

        * When option `contour_levels' is bounded to positive integer
          <n>, <n> contour lines will be drawn at equal intervals.  By
          default, five equally spaced contours are plotted.

        * When option `contour_levels' is bounded to a list of length
          three of the form `[lowest,s,highest]', contour lines are
          plotted from `lowest' to `highest' in steps of `s'.

        * When option `contour_levels' is bounded to a set of numbers
          of the form `{n1, n2, ...}', contour lines are plotted at
          values `n1', `n2', ...

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Examples:

     Ten equally spaced contour lines.  The actual number of levels can
     be adjusted to give simple labels.

          (%i1) load(draw)$
          (%i2) draw3d(color = green,
                       explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = 10,
                       contour        = both,
                       surface_hide   = true) $

     From -8 to 8 in steps of 4.

          (%i1) load(draw)$
          (%i2) draw3d(color = green,
                       explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = [-8,4,8],
                       contour        = both,
                       surface_hide   = true) $

     Isolines at levels -7, -6, 0.8 and 5.

          (%i1) load(draw)$
          (%i2) draw3d(color = green,
                       explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = {-7, -6, 0.8, 5},
                       contour        = both,
                       surface_hide   = true) $

     See also `contour'.

 -- Graphic option: data_file_name
     Default value: `"data.gnuplot"'

     This is the name of the file with the numeric data needed by
     Gnuplot to build the requested plot.

     Since this is a global graphics option, its position in the scene
     description does not matter.  It can be also used as an argument
     of function `draw'.

     See example in `gnuplot_file_name'.

 -- Graphic option: delay
     Default value: 5

     This is the delay in 1/100 seconds of frames in animated gif files.

     Since this is a global graphics option, its position in the scene
     description does not matter.  It can be also used as an argument
     of function `draw'.

     Example:

          (%i1) load(draw)$
          (%i2) draw(
                  delay     = 100,
                  file_name = "zzz",
                  terminal  = 'animated_gif,
                  gr2d(explicit(x^2,x,-1,1)),
                  gr2d(explicit(x^3,x,-1,1)),
                  gr2d(explicit(x^4,x,-1,1)));
          End of animation sequence
          (%o2)          [gr2d(explicit), gr2d(explicit), gr2d(explicit)]

     Option `delay' is only active in animated gif's; it is ignored in
     any other case.

     See also `terminal', `dimensions'.

 -- Graphic option: dimensions
     Default value: `[600,500]'

     Dimensions of the output terminal.  Its value is a list formed by
     the width and the height.  The meaning of the two numbers depends
     on the terminal you are working with.

     With terminals `gif', `animated_gif', `png', `jpg', `svg',
     `screen', `wxt', and `aquaterm', the integers represent the number
     of points in each direction.  If they are not intergers, they are
     rounded.

     With terminals `eps', `eps_color', `pdf', and `pdfcairo', both
     numbers represent hundredths of cm, which means that, by default,
     pictures in these formats are 6 cm in width and 5 cm in height.

     Since this is a global graphics option, its position in the scene
     description does not matter.  It can be also used as an argument
     of function `draw'.

     Examples:

     Option `dimensions' applied to file output and to wxt canvas.

          (%i1) load(draw)$
          (%i2) draw2d(
                  dimensions = [300,300],
                  terminal   = 'png,
                  explicit(x^4,x,-1,1)) $
          (%i3) draw2d(
                  dimensions = [300,300],
                  terminal   = 'wxt,
                  explicit(x^4,x,-1,1)) $

     Option `dimensions' applied to eps output.  We want an eps file
     with A4 portrait dimensions.

          (%i1) load(draw)$
          (%i2) A4portrait: 100*[21, 29.7]$
          (%i3) draw3d(
                  dimensions = A4portrait,
                  terminal   = 'eps,
                  explicit(x^2-y^2,x,-2,2,y,-2,2)) $

 -- Graphic option: draw_realpart
     Default value: `true'

     When `true', functions to be drawn are considered as complex
     functions whose real part value should be plotted; when `false',
     nothing will be plotted when the function does not give a real
     value.

     This option affects objects `explicit'  and `parametric'  in 2D
     and 3D, and `parametric_surface'.

     Example:

     Option `draw_realpart' affects objects `explicit' and `parametric'.

          (%i1) load(draw)$
          (%i2) draw2d(
                  draw_realpart = false,
                  explicit(sqrt(x^2  - 4*x) - x, x, -1, 5),
                  color         = red,
                  draw_realpart = true,
                  parametric(x,sqrt(x^2  - 4*x) - x + 1, x, -1, 5) );

 -- Graphic option: enhanced3d
     Default value: `none'

     If `enhanced3d' is `none', surfaces are not colored in 3D plots.
     In order to get a colored surface, a list must be assigned to
     option `enhanced3d', where the first element is an expression and
     the rest are the names of the variables or parameters used in that
     expression.  A list such `[f(x,y,z), x, y, z]' means that point
     `[x,y,z]' of the surface is assigned number `f(x,y,z)', which will
     be colored according to the actual `palette'.  For those 3D
     graphic objects defined in terms of parameters, it is possible to
     define the color number in terms of the parameters, as in `[f(u),
     u]', as in objects `parametric' and `tube', or `[f(u,v), u, v]',
     as in object `parametric_surface'.  While all 3D objects admit the
     model based on absolute coordinates, `[f(x,y,z), x, y, z]', only
     two of them, namely `explicit' and `elevation_grid', accept also
     models defined on the `[x,y]' coordinates, `[f(x,y), x, y]'.  3D
     graphic object `implicit' accepts only the `[f(x,y,z), x, y, z]'
     model.  Object `points' accepts also the `[f(x,y,z), x, y, z]'
     model, but when points have a chronological nature, model `[f(k),
     k]' is also valid, being `k' an ordering parameter.

     When `enhanced3d' is assigned something different to `none',
     options `color' and `surface_hide' are ignored.

     The names of the variables defined in the lists may be different
     to those used in the definitions of the graphic objects.

     In order to maintain back compatibility, `enhanced3d = false' is
     equivalent to `enhanced3d = none', and `enhanced3d = true' is
     equivalent to `enhanced3d = [z, x, y, z]'.  If an expression is
     given to `enhanced3d', its variables must be the same used in the
     surface definition.  This is not necessary when using lists.

     See option `palette' to learn how palettes are specified.

     Examples:

     `explicit' object with coloring defined by the `[f(x,y,z), x, y,
     z]' model.

          (%i1) load(draw)$
          (%i2) draw3d(
                   enhanced3d = [x-z/10,x,y,z],
                   palette    = gray,
                   explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3))$

     `explicit' object with coloring defined by the `[f(x,y), x, y]'
     model.  The names of the variables defined in the lists may be
     different to those used in the definitions of the graphic objects;
     in this case, `r' corresponds to `x', and `s' to `y'.

          (%i1) load(draw)$
          (%i2) draw3d(
                   enhanced3d = [sin(r*s),r,s],
                   explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3))$

     `parametric' object with coloring defined by the `[f(x,y,z), x, y,
     z]' model.

          (%i1) load(draw)$
          (%i2) draw3d(
                   nticks = 100,
                   line_width = 2,
                   enhanced3d = [if y>= 0 then 1 else 0, x, y, z],
                   parametric(sin(u)^2,cos(u),u,u,0,4*%pi)) $

     `parametric' object with coloring defined by the `[f(u), u]' model.
     In this case, `(u-1)^2' is a shortcut for `[(u-1)^2,u]'.

          (%i1) load(draw)$
          (%i2) draw3d(
                   nticks = 60,
                   line_width = 3,
                   enhanced3d = (u-1)^2,
                   parametric(cos(5*u)^2,sin(7*u),u-2,u,0,2))$

     `elevation_grid' object with coloring defined by the `[f(x,y), x,
     y]' model.

          (%i1) load(draw)$
          (%i2) m: apply(
                     matrix,
                     makelist(makelist(cos(i^2/80-k/30),k,1,30),i,1,20)) $
          (%i3) draw3d(
                   enhanced3d = [cos(x*y*10),x,y],
                   elevation_grid(m,-1,-1,2,2),
                   xlabel = "x",
                   ylabel = "y");

     `tube' object with coloring defined by the `[f(x,y,z), x, y, z]'
     model.

          (%i1) load(draw)$
          (%i2) draw3d(
                   enhanced3d = [cos(x-y),x,y,z],
                   palette = gray,
                   xu_grid = 50,
                   tube(cos(a), a, 0, 1, a, 0, 4*%pi) )$

     `tube' object with coloring defined by the `[f(u), u]' model.
     Here, `enhanced3d = -a' would be the shortcut for `enhanced3d =
     [-foo,foo]'.

          (%i1) load(draw)$
          (%i2) draw3d(
                   tube_extremes = [open, closed],
                   palette = [26,15,-2],
                   enhanced3d = [-foo, foo],
                   tube(a, a, a^2, 1, a, -2, 2) )$

     `implicit' and `points' objects with coloring defined by the
     `[f(x,y,z), x, y, z]' model.

          (%i1) load(draw)$
          (%i2) draw3d(
                   enhanced3d = [x-y,x,y,z],
                   implicit((x^2+y^2+z^2-1)*(x^2+(y-1.5)^2+z^2-0.5)=0.015,
                            x,-1,1,y,-1.2,2.3,z,-1,1)) $
          (%i3) m: makelist([random(1.0),random(1.0),random(1.0)],k,1,2000)$
          (%i4) draw3d(
                   point_type = filled_circle,
                   point_size = 2,
                   enhanced3d = [u+v-w,u,v,w],
                   points(m) ) $

     When points have a chronological nature, model `[f(k), k]' is also
     valid, being `k' an ordering parameter.

          (%i1) load(draw)$
          (%i2) m:makelist([random(1.0), random(1.0), random(1.0)],k,1,5)$
          (%i3) draw3d(
                   enhanced3d = [sin(j), j],
                   point_size = 3,
                   point_type = filled_circle,
                   points_joined = true,
                   points(m)) $

 -- Graphic option: error_type
     Default value: `y'

     Depending on its value, which can be `x', `y', or `xy', graphic
     object `errors' will draw points with horizontal, vertical, or
     both, error bars.  When `error_type=boxes', boxes will be drawn
     instead of crosses.

     See also `errors'.

 -- Graphic option: file_name
     Default value: `"maxima_out"'

     This is the name of the file where terminals `png', `jpg', `gif',
     `eps', `eps_color', `pdf', `pdfcairo' and `svg' will save the
     graphic.

     Since this is a global graphics option, its position in the scene
     description does not matter.  It can be also used as an argument
     of function `draw'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(file_name = "myfile",
                       explicit(x^2,x,-1,1),
                       terminal  = 'png)$

     See also `terminal', `dimensions'.

 -- Graphic option: fill_color
     Default value: `"red"'

     `fill_color' specifies the color for filling polygons and 2d
     `explicit' functions.

     See `color' to learn how colors are specified.

 -- Graphic option: fill_density
     Default value: 0

     `fill_density' is a number between 0 and 1 that specifies the
     intensity of the `fill_color' in `bars' objects.

     See `bars' for examples.

 -- Graphic option: filled_func
     Default value: `false'

     Option `filled_func' controls how regions limited by functions
     should be filled.  When `filled_func' is `true', the region
     bounded by the function defined with object `explicit' and the
     bottom of the graphic window is filled with `fill_color'.  When
     `filled_func' contains a function expression, then the region
     bounded by this function and the function defined with object
     `explicit' will be filled.  By default, explicit functions are not
     filled.

     This option affects only the 2d graphic object `explicit'.

     Example:

     Region bounded by an `explicit' object and the bottom of the
     graphic window.
          (%i1) load(draw)$
          (%i2) draw2d(fill_color  = red,
                       filled_func = true,
                       explicit(sin(x),x,0,10) )$

     Region bounded by an `explicit' object and the function defined by
     option `filled_func'.  Note that the variable in `filled_func'
     must be the same as that used in `explicit'.

          (%i1) load(draw)$
          (%i2) draw2d(fill_color  = grey,
                       filled_func = sin(x),
                       explicit(-sin(x),x,0,%pi));

     See also `fill_color' and `explicit'.

 -- Graphic option: font
     Default value: `""' (empty string)

     This option can be used to set the font face to be used by the
     terminal.  Only one font face and size can be used throughout the
     plot.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     See also `font_size'

     Gnuplot doesn't handle fonts by itself, it leaves this task to the
     support libraries of the different terminals, each one with its own
     philosophy about it.  A brief summary follows:

        * x11: Uses the normal x11 font server mechanism.

          Example:
               (%i1) load(draw)$
               (%i2) draw2d(font      = "Arial",
                            font_size = 20,
                            label(["Arial font, size 20",1,1]))$

        * windows: The windows terminal doesn't support changing of
          fonts from inside the plot.  Once the plot has been
          generated, the font can be changed right-clicking on the menu
          of the graph window.

        * png, jpeg, gif: The libgd library uses the font path stored
          in the environment variable `GDFONTPATH'; in this case, it is
          only necessary to set option `font' to the font's name.  It
          is also possible to give the complete path to the font file.

          Examples:

          Option `font' can be given the complete path to the font file:
               (%i1) load(draw)$
               (%i2) path: "/usr/share/fonts/truetype/freefont/" $
               (%i3) file: "FreeSerifBoldItalic.ttf" $
               (%i4) draw2d(
                       font      = concat(path, file),
                       font_size = 20,
                       color     = red,
                       label(["FreeSerifBoldItalic font, size 20",1,1]),
                       terminal  = png)$

          If environment variable `GDFONTPATH' is set to the path where
          font files are allocated, it is possible to set graphic
          option `font' to the name of the font.

               (%i1) load(draw)$
               (%i2) draw2d(
                       font      = "FreeSerifBoldItalic",
                       font_size = 20,
                       color     = red,
                       label(["FreeSerifBoldItalic font, size 20",1,1]),
                       terminal  = png)$

        * Postscript: Standard Postscript fonts are:
          `"Times-Roman"',
          `"Times-Italic"',
          `"Times-Bold"',
          `"Times-BoldItalic"',
          `"Helvetica"',
          `"Helvetica-Oblique"',
          `"Helvetica-Bold"',
          `"Helvetic-BoldOblique"',
          `"Courier"',
          `"Courier-Oblique"',
          `"Courier-Bold"', and
          `"Courier-BoldOblique"'.

          Example:

               (%i1) load(draw)$
               (%i2) draw2d(
                       font      = "Courier-Oblique",
                       font_size = 15,
                       label(["Courier-Oblique font, size 15",1,1]),
                       terminal = eps)$

        * pdf: Uses same fonts as Postscript.

        * pdfcairo: Uses same fonts as wxt.

        * wxt: The pango library finds fonts via the `fontconfig'
          utility.

        * aqua: Default is `"Times-Roman"'.

     The gnuplot documentation is an important source of information
     about terminals and fonts.

 -- Graphic option: font_size
     Default value: 10

     This option can be used to set the font size to be used by the
     terminal.  Only one font face and size can be used throughout the
     plot.  `font_size' is active only when option `font' is not equal
     to the empty string.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     See also `font'.


 -- Graphic option: gnuplot_file_name
     Default value: `"maxout.gnuplot"'

     This is the name of the file with the necessary commands to be
     processed by Gnuplot.

     Since this is a global graphics option, its position in the scene
     description does not matter.  It can be also used as an argument
     of function `draw'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(
                 file_name = "my_file",
                 gnuplot_file_name = "my_commands_for_gnuplot",
                 data_file_name    = "my_data_for_gnuplot",
                 terminal          = png,
                 explicit(x^2,x,-1,1)) $

     See also `data_file_name'.

 -- Graphic option: grid
     Default value: `false'

     If `grid' is `true', a grid will be drawn on the <xy> plane.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(grid = true,
                       explicit(exp(u),u,-2,2))$

 -- Graphic option: head_angle
     Default value: 45

     `head_angle' indicates the angle, in degrees, between the arrow
     heads and the segment.

     This option is relevant only for `vector' objects.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,10],
                       yrange      = [0,9],
                       head_length = 0.7,
                       head_angle  = 10,
                       vector([1,1],[0,6]),
                       head_angle  = 20,
                       vector([2,1],[0,6]),
                       head_angle  = 30,
                       vector([3,1],[0,6]),
                       head_angle  = 40,
                       vector([4,1],[0,6]),
                       head_angle  = 60,
                       vector([5,1],[0,6]),
                       head_angle  = 90,
                       vector([6,1],[0,6]),
                       head_angle  = 120,
                       vector([7,1],[0,6]),
                       head_angle  = 160,
                       vector([8,1],[0,6]),
                       head_angle  = 180,
                       vector([9,1],[0,6]) )$

     See also `head_both', `head_length', and `head_type'.

 -- Graphic option: head_both
     Default value: `false'

     If `head_both' is `true', vectors are plotted with two arrow heads.
     If `false', only one arrow is plotted.

     This option is relevant only for `vector' objects.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,8],
                       yrange      = [0,8],
                       head_length = 0.7,
                       vector([1,1],[6,0]),
                       head_both   = true,
                       vector([1,7],[6,0]) )$

     See also `head_length', `head_angle', and `head_type'.

 -- Graphic option: head_length
     Default value: 2

     `head_length' indicates, in <x>-axis units, the length of arrow
     heads.

     This option is relevant only for `vector' objects.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,8],
                       vector([0,1],[5,5]),
                       head_length = 1,
                       vector([2,1],[5,5]),
                       head_length = 0.5,
                       vector([4,1],[5,5]),
                       head_length = 0.25,
                       vector([6,1],[5,5]))$

     See also `head_both', `head_angle', and `head_type'.

 -- Graphic option: head_type
     Default value: `filled'

     `head_type' is used to specify how arrow heads are plotted.
     Possible values are: `filled' (closed and filled arrow heads),
     `empty' (closed but not filled arrow heads), and `nofilled' (open
     arrow heads).

     This option is relevant only for `vector' objects.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,10],
                       head_length = 1,
                       vector([0,1],[5,5]), /* default type */
                       head_type = 'empty,
                       vector([3,1],[5,5]),
                       head_type = 'nofilled,
                       vector([6,1],[5,5]))$

     See also `head_both', `head_angle', and `head_length'.

 -- Graphic option: ip_grid
     Default value: `[50, 50]'

     `ip_grid' sets the grid for the first sampling in implicit plots.

     This option is relevant only for `implicit' objects.

 -- Graphic option: ip_grid_in
     Default value: `[5, 5]'

     `ip_grid_in' sets the grid for the second sampling in implicit
     plots.

     This option is relevant only for `implicit' objects.

 -- Graphic option: key
     Default value: `""' (empty string)

     `key' is the name of a function in the legend.  If `key' is an
     empty string, no key is assigned to the function.

     This option affects the following graphic objects:
        * `gr2d': `points', `polygon', `rectangle', `ellipse',
          `vector', `explicit', `implicit', `parametric', and `polar'.

        * `gr3d': `points', `explicit', `parametric', and
          `parametric_surface'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(key   = "Sinus",
                       explicit(sin(x),x,0,10),
                       key   = "Cosinus",
                       color = red,
                       explicit(cos(x),x,0,10) )$

 -- Graphic option: label_alignment
     Default value: `center'

     `label_alignment' is used to specify where to write labels with
     respect to the given coordinates.  Possible values are: `center',
     `left', and `right'.

     This option is relevant only for `label' objects.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(xrange          = [0,10],
                       yrange          = [0,10],
                       points_joined   = true,
                       points([[5,0],[5,10]]),
                       color           = blue,
                       label(["Centered alignment (default)",5,2]),
                       label_alignment = 'left,
                       label(["Left alignment",5,5]),
                       label_alignment = 'right,
                       label(["Right alignment",5,8]))$

     See also `label_orientation', and `color'.

 -- Graphic option: label_orientation
     Default value: `horizontal'

     `label_orientation' is used to specify orientation of labels.
     Possible values are: `horizontal', and `vertical'.

     This option is relevant only for `label' objects.

     Example:

     In this example, a dummy point is added to get an image.  Package
     `draw' needs always data to draw an scene.
          (%i1) load(draw)$
          (%i2) draw2d(xrange     = [0,10],
                       yrange     = [0,10],
                       point_size = 0,
                       points([[5,5]]),
                       color      = navy,
                       label(["Horizontal orientation (default)",5,2]),
                       label_orientation = 'vertical,
                       color             = "#654321",
                       label(["Vertical orientation",1,5]))$

     See also `label_alignment' and `color'.

 -- Graphic option: line_type
     Default value: `solid'

     `line_type' indicates how lines are displayed; possible values are
     `solid' and `dots'.

     This option affects the following graphic objects:
        * `gr2d': `points', `polygon', `rectangle', `ellipse',
          `vector', `explicit', `implicit', `parametric' and `polar'.

        * `gr3d': `points', `explicit', `parametric' and
          `parametric_surface'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(line_type = dots,
                       explicit(1 + x^2,x,-1,1),
                       line_type = solid, /* default */
                       explicit(2 + x^2,x,-1,1))$

     See also `line_width'.

 -- Graphic option: line_width
     Default value: 1

     `line_width' is the width of plotted lines.  Its value must be a
     positive number.

     This option affects the following graphic objects:
        * `gr2d': `points', `polygon', `rectangle', `ellipse',
          `vector', `explicit', `implicit', `parametric' and `polar'.

        * `gr3d': `points' and `parametric'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^2,x,-1,1), /* default width */
                       line_width = 5.5,
                       explicit(1 + x^2,x,-1,1),
                       line_width = 10,
                       explicit(2 + x^2,x,-1,1))$

     See also `line_type'.

 -- Graphic option: logcb
     Default value: `false'

     If `logcb' is `true', the tics in the colorbox will be drawn in the
     logarithmic scale.

     When `enhanced3d' or `colorbox' is `false', option `logcb' has no
     effect.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d (
                  enhanced3d = true,
                  color      = green,
                  logcb = true,
                  logz  = true,
                  palette = [-15,24,-9],
                  explicit(exp(x^2-y^2), x,-2,2,y,-2,2)) $

     See also `enhanced3d', `colorbox' and `cbrange'.

 -- Graphic option: logx
     Default value: `false'

     If `logx' is `true', the <x> axis will be drawn in the logarithmic
     scale.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(log(x),x,0.01,5),
                       logx = true)$

     See also `logy' and `logz'.

 -- Graphic option: logy
     Default value: `false'

     If `logy' is `true', the <y> axis will be drawn in the logarithmic
     scale.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(logy = true,
                       explicit(exp(x),x,0,5))$

     See also `logx' and `logz'.

 -- Graphic option: logz
     Default value: `false'

     If `logz' is `true', the <z> axis will be drawn in the logarithmic
     scale.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(logz = true,
                       explicit(exp(u^2+v^2),u,-2,2,v,-2,2))$

     See also `logx' and `logy'.

 -- Graphic option: nticks
     Default value: 29

     In 2d, `nticks' gives the initial number of points used by the
     adaptive plotting routine for explicit objects.  It is also the
     number of points that will be shown in parametric and polar curves.

     This option affects the following graphic objects:
        * `gr2d': `ellipse', `explicit', `parametric' and `polar'.

        * `gr3d': `parametric'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(transparent = true,
                       ellipse(0,0,4,2,0,180),
                       nticks = 5,
                       ellipse(0,0,4,2,180,180) )$

 -- Graphic option: palette
     Default value: `color'

     `palette' indicates how to map gray levels onto color components.
     It works together with option `enhanced3d'  in 3D graphics, who
     associates every point of a surfaces to a real number or gray
     level.  It also works with gray images.  With `palette', levels
     are transformed into colors.

     There are two ways for defining these transformations.

     First, `palette' can be a vector of length three with components
     ranging from -36 to +36; each value is an index for a formula
     mapping the levels onto red, green and blue colors, respectively:

           0: 0               1: 0.5           2: 1
           3: x               4: x^2           5: x^3
           6: x^4             7: sqrt(x)       8: sqrt(sqrt(x))
           9: sin(90x)       10: cos(90x)     11: |x-0.5|
          12: (2x-1)^2       13: sin(180x)    14: |cos(180x)|
          15: sin(360x)      16: cos(360x)    17: |sin(360x)|
          18: |cos(360x)|    19: |sin(720x)|  20: |cos(720x)|
          21: 3x             22: 3x-1         23: 3x-2
          24: |3x-1|         25: |3x-2|       26: (3x-1)/2
          27: (3x-2)/2       28: |(3x-1)/2|   29: |(3x-2)/2|
          30: x/0.32-0.78125 31: 2*x-0.84     32: 4x;1;-2x+1.84;x/0.08-11.5
          33: |2*x - 0.5|    34: 2*x          35: 2*x - 0.5
          36: 2*x - 1

     negative numbers mean negative colour component.  `palette = gray'
     and `palette = color' are short cuts for `palette = [3,3,3]' and
     `palette = [7,5,15]', respectively.

     Second, `palette' can be a user defined lookup table.  In this
     case, the format for building a lookup table of length `n' is
     `palette = [color_1, color_2, ..., color_n]', where `color_i' is a
     well formed color (see option `color' ), such that `color_1' is
     assigned to the lowest gray level and `color_n' to the highest.
     The rest of colors are interpolated.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Examples:

     It works together with option `enhanced3d' in 3D graphics.

          (%i1) load(draw)$
          (%i2) draw3d(
                  enhanced3d = [z-x+2*y,x,y,z],
                  palette = [32, -8, 17],
                  explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3))$

     It also works with gray images.

          (%i1) load(draw)$
          (%i2) im: apply(
                     'matrix,
                      makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) /* palette = color, default */
                draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(palette = gray, image(im,0,0,30,30))$
          (%i5) draw2d(palette = [15,20,-4],
                       colorbox=false,
                       image(im,0,0,30,30))$

     `palette' can be a user defined lookup table.  In this example,
     low values of `x' are colored in red, and higher values in yellow.

          (%i1) load(draw)$
          (%i2) draw3d(
                   palette = [red, blue, yellow],
                   enhanced3d = x,
                   explicit(x^2+y^2,x,-1,1,y,-1,1)) $

     See also `colorbox'  and `enhanced3d'.


 -- Graphic option: point_size
     Default value: 1

     `point_size' sets the size for plotted points.  It must be a non
     negative number.

     This option has no effect when graphic option `point_type' is set
     to `dot'.

     This option affects the following graphic objects:
        * `gr2d': `points'.

        * `gr3d': `points'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(points(makelist([random(20),random(50)],k,1,10)),
                  point_size = 5,
                  points(makelist(k,k,1,20),makelist(random(30),k,1,20)))$

 -- Graphic option: point_type
     Default value: 1

     `point_type' indicates how isolated points are displayed; the
     value of this option can be any integer index greater or equal
     than -1, or the name of a point style: `$none' (-1), `dot' (0),
     `plus' (1), `multiply' (2), `asterisk' (3), `square' (4),
     `filled_square' (5), `circle' (6), `filled_circle' (7),
     `up_triangle' (8), `filled_up_triangle' (9), `down_triangle' (10),
     `filled_down_triangle' (11), `diamant' (12) and `filled_diamant'
     (13).

     This option affects the following graphic objects:
        * `gr2d': `points'.

        * `gr3d': `points'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(xrange = [0,10],
                       yrange = [0,10],
                       point_size = 3,
                       point_type = diamant,
                       points([[1,1],[5,1],[9,1]]),
                       point_type = filled_down_triangle,
                       points([[1,2],[5,2],[9,2]]),
                       point_type = asterisk,
                       points([[1,3],[5,3],[9,3]]),
                       point_type = filled_diamant,
                       points([[1,4],[5,4],[9,4]]),
                       point_type = 5,
                       points([[1,5],[5,5],[9,5]]),
                       point_type = 6,
                       points([[1,6],[5,6],[9,6]]),
                       point_type = filled_circle,
                       points([[1,7],[5,7],[9,7]]),
                       point_type = 8,
                       points([[1,8],[5,8],[9,8]]),
                       point_type = filled_diamant,
                       points([[1,9],[5,9],[9,9]]) )$

 -- Graphic option: points_joined
     Default value: `false'

     When `points_joined' is `true', points are joined by lines; when
     `false', isolated points are drawn.  A third possible value for
     this graphic option is `impulses'; in such case, vertical segments
     are drawn from points to the x-axis (2D) or to the xy-plane (3D).

     This option affects the following graphic objects:
        * `gr2d': `points'.

        * `gr3d': `points'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(xrange        = [0,10],
                       yrange        = [0,4],
                       point_size    = 3,
                       point_type    = up_triangle,
                       color         = blue,
                       points([[1,1],[5,1],[9,1]]),
                       points_joined = true,
                       point_type    = square,
                       line_type     = dots,
                       points([[1,2],[5,2],[9,2]]),
                       point_type    = circle,
                       color         = red,
                       line_width    = 7,
                       points([[1,3],[5,3],[9,3]]) )$

 -- Graphic option: proportional_axes
     Default value: `none'

     When `proportional_axes' is equal to `xy' or `xyz', a 2D or 3D
     scene will be drawn with axes proportional to their relative
     lengths.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     This option works with Gnuplot version 4.2.6 or greater.

     Examples:

     Single 2D plot.

          (%i1) load(draw)$
          (%i2) draw2d(
                  ellipse(0,0,1,1,0,360),
                  transparent=true,
                  color = blue,
                  line_width = 4,
                  ellipse(0,0,2,1/2,0,360),
                  proportional_axes = xy) $

     Multiplot.

          (%i1) load(draw)$
          (%i2) draw(
                  terminal = wxt,
                  gr2d(proportional_axes = xy,
                       explicit(x^2,x,0,1)),
                  gr2d(explicit(x^2,x,0,1),
                       xrange = [0,1],
                       yrange = [0,2],
                       proportional_axes=xy),
                  gr2d(explicit(x^2,x,0,1))

 -- Graphic option: surface_hide
     Default value: `false'

     If `surface_hide' is `true', hidden parts are not plotted in 3d
     surfaces.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw(columns=2,
                     gr3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3)),
                     gr3d(surface_hide = true,
                          explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3)) )$

 -- Graphic option: terminal
     Default value: `screen'

     Selects the terminal to be used by Gnuplot; possible values are:
     `screen' (default), `png', `pngcairo', `jpg', `eps', `eps_color',
     `pdf', `pdfcairo', `gif', `animated_gif', `wxt', `svg', and
     `aquaterm'.

     Terminals `screen', `wxt' and `aquaterm' can be also defined as a
     list with two elements: the name of the terminal itself and a non
     negative integer number.  In this form, multiple windows can be
     opened at the same time, each with its corresponding number.  This
     feature does not work in Windows platforms.

     Since this is a global graphics option, its position in the scene
     description does not matter.  It can be also used as an argument
     of function `draw'.

     N.B. pdfcairo requires Gnuplot 4.3 or newer.  `pdf' requires
     Gnuplot to be compiled with the option `--enable-pdf' and libpdf
     must be installed.  The pdf library is available from:
     `http://www.pdflib.com/en/download/pdflib-family/pdflib-lite/'

     Examples:

          (%i1) load(draw)$
          (%i2) /* screen terminal (default) */
                draw2d(explicit(x^2,x,-1,1))$
          (%i3) /* png file */
                draw2d(terminal  = 'png,
                       explicit(x^2,x,-1,1))$
          (%i4) /* jpg file */
                draw2d(terminal   = 'jpg,
                       dimensions = [300,300],
                       explicit(x^2,x,-1,1))$
          (%i5) /* eps file */
                draw2d(file_name = "myfile",
                       explicit(x^2,x,-1,1),
                       terminal  = 'eps)$
          (%i6) /* pdf file */
                draw2d(file_name = "mypdf",
                       dimensions = 100*[12.0,8.0],
                       explicit(x^2,x,-1,1),
                       terminal  = 'pdf)$
          (%i7) /* wxwidgets window */
                draw2d(explicit(x^2,x,-1,1),
                       terminal  = 'wxt)$

     Multiple windows.

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^5,x,-2,2), terminal=[screen, 3])$
          (%i3) draw2d(explicit(x^2,x,-2,2), terminal=[screen, 0])$

     An animated gif file.

          (%i1) load(draw)$
          (%i2) draw(
                  delay     = 100,
                  file_name = "zzz",
                  terminal  = 'animated_gif,
                  gr2d(explicit(x^2,x,-1,1)),
                  gr2d(explicit(x^3,x,-1,1)),
                  gr2d(explicit(x^4,x,-1,1)));
          End of animation sequence
          (%o2)          [gr2d(explicit), gr2d(explicit), gr2d(explicit)]

     Option `delay' is only active in animated gif's; it is ignored in
     any other case.

     See also `file_name', `dimensions' and `delay'.


 -- Graphic option: title
     Default value: `""' (empty string)

     Option `title', a string, is the main title for the scene.  By
     default, no title is written.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(exp(u),u,-2,2),
                       title = "Exponential function")$


 -- Graphic option: transform
     Default value: `none'

     If `transform' is `none', the space is not transformed and graphic
     objects are drawn as defined.  When a space transformation is
     desired, a list must be assigned to option `transform'.  In case of
     a 2D scene, the list takes the form `[f1(x,y), f2(x,y), x, y]'.
     In case of a 3D scene, the list is of the form `[f1(x,y,z),
     f2(x,y,z), f3(x,y,z), x, y, z]'.

     The names of the variables defined in the lists may be different
     to those used in the definitions of the graphic objects.

     Examples:

     Rotation in 2D.

          (%i1) load(draw)$
          (%i2) th : %pi / 4$
          (%i3) draw2d(
                  color = "#e245f0",
                  proportional_axes = 'xy,
                  line_width = 8,
                  triangle([3,2],[7,2],[5,5]),
                  border     = false,
                  fill_color = yellow,
                  transform  = [cos(th)*x - sin(th)*y,
                                sin(th)*x + cos(th)*y, x, y],
                  triangle([3,2],[7,2],[5,5]) )$

     Translation in 3D.

          (%i1) load(draw)$
          (%i2) draw3d(
                  color     = "#a02c00",
                  explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3),
                  transform = [x+10,y+10,z+10,x,y,z],
                  color     = blue,
                  explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3) )$


 -- Graphic option: transparent
     Default value: `false'

     If `transparent' is `true', interior regions of polygons are
     filled according to `fill_color'.

     This option affects the following graphic objects:
        * `gr2d': `polygon', `rectangle', and `ellipse'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(polygon([[3,2],[7,2],[5,5]]),
                       transparent = true,
                       color       = blue,
                       polygon([[5,2],[9,2],[7,5]]) )$


 -- Graphic option: tube_extremes
     Default value: `[open, open]'

     A list with two possible elements, `open' and `closed', indicating
     whether the extremes of a graphic object `tube' remain open or
     must be closed.  By default, both extremes are left open.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(
                  tube_extremes = [open, closed],
                  tube(0, 0, a, 1,
                       a, 0, 8) )$

 -- Graphic option: unit_vectors
     Default value: `false'

     If `unit_vectors' is `true', vectors are plotted with module 1.
     This is useful for plotting vector fields.  If `unit_vectors' is
     `false', vectors are plotted with its original length.

     This option is relevant only for `vector' objects.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [-1,6],
                       yrange      = [-1,6],
                       head_length = 0.1,
                       vector([0,0],[5,2]),
                       unit_vectors = true,
                       color        = red,
                       vector([0,3],[5,2]))$

 -- Graphic option: user_preamble
     Default value: `""' (empty string)

     Expert Gnuplot users can make use of this option to fine tune
     Gnuplot's behaviour by writing settings to be sent before the
     `plot' or `splot' command.

     The value of this option must be a string or a list of strings
     (one per line).

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

     The dumb terminal is not supported by package `draw', but it is
     possible to set it by making use of option `user_preamble',
          (%i1) load(draw)$
          (%i2) draw2d(explicit(exp(x)-1,x,-1,1),
                       parametric(cos(u),sin(u),u,0,2*%pi),
                       user_preamble="set terminal dumb")$

 -- Graphic option: view
     Default value: `[60,30]'

     A pair of angles, measured in degrees, indicating the view
     direction in a 3D scene.  The first angle is the vertical rotation
     around the <x> axis, in the range [0, 180].  The second one is the
     horizontal rotation around the <z> axis, in the range [0, 360].

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(view = [170, 360],
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

 -- Graphic option: wired_surface
     Default value: `false'

     Indicates whether 3D surfaces in `enhanced3d'  mode show the grid
     joinning the points or not.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(
                  enhanced3d    = [sin(x),x,y],
                  wired_surface = true,
                  explicit(x^2+y^2,x,-1,1,y,-1,1)) $

 -- Graphic option: x_voxel
     Default value: 10

     `x_voxel' is the number of voxels in the x direction to be used by
     the marching cubes algorithm implemented by the 3d `implicit'
     object.  It is also used by graphic object `region'.


 -- Graphic option: xaxis
     Default value: `false'

     If `xaxis' is `true', the <x> axis is drawn.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_color = blue)$

     See also `xaxis_width', `xaxis_type' and `xaxis_color'.

 -- Graphic option: xaxis_color
     Default value: `"black"'

     `xaxis_color' specifies the color for the <x> axis.  See `color'
     to know how colors are defined.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_color = red)$

     See also `xaxis', `xaxis_width' and `xaxis_type'.

 -- Graphic option: xaxis_secondary
     Default value: `false'

     If `xaxis_secondary' is `true', function values can be plotted with
     respect to the second <x> axis, which will be drawn on top of the
     scene.

     Note that this is a local graphics option which only affects to 2d
     plots.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(
                   key   = "Bottom x-axis",
                   explicit(x+1,x,1,2),
                   color = red,
                   key   = "Above x-axis",
                   xtics_secondary = true,
                   xaxis_secondary = true,
                   explicit(x^2,x,-1,1)) $

     See also `xrange_secondary', `xtics_secondary',
     `xtics_rotate_secondary', `xtics_axis_secondary' and
     `xaxis_secondary'.

 -- Graphic option: xaxis_type
     Default value: `dots'

     `xaxis_type' indicates how the <x> axis is displayed; possible
     values are `solid' and `dots'.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_type  = solid)$

     See also `xaxis', `xaxis_width' and `xaxis_color'.

 -- Graphic option: xaxis_width
     Default value: 1

     `xaxis_width' is the width of the <x> axis.  Its value must be a
     positive number.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_width = 3)$

     See also `xaxis', `xaxis_type' and `xaxis_color'.

 -- Graphic option: xlabel
     Default value: `""' (empty string)

     Option `xlabel', a string, is the label for the <x> axis.  By
     default, no label is written.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(xlabel = "Time",
                       explicit(exp(u),u,-2,2),
                       ylabel = "Population")$

     See also `ylabel', and `zlabel'.

 -- Graphic option: xrange
     Default value: `auto'

     If `xrange' is `auto', the range for the <x> coordinate is
     computed automatically.

     If the user wants a specific interval for <x>, it must be given as
     a Maxima list, as in `xrange=[-2, 3]'.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(xrange = [-3,5],
                       explicit(x^2,x,-1,1))$

     See also `yrange' and `zrange'.

 -- Graphic option: xrange_secondary
     Default value: `auto'

     If `xrange_secondary' is `auto', the range for the second <x> axis
     is computed automatically.

     If the user wants a specific interval for the second <x> axis, it
     must be given as a Maxima list, as in `xrange_secondary=[-2, 3]'.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     See also `xrange', `yrange', `zrange' and `yrange_secondary'.

 -- Graphic option: xtics
     Default value: `auto'

     This graphic option controls the way tic marks are drawn on the
     <x> axis.

        * When option `xtics' is bounded to symbol <auto>, tic marks are
          drawn automatically.

        * When option `xtics' is bounded to symbol <none>, tic marks are
          not drawn.

        * When option `xtics' is bounded to a positive number, this is
          the distance between two consecutive tic marks.

        * When option `xtics' is bounded to a list of length three of
          the form `[start,incr,end]', tic marks are plotted from
          `start' to `end' at intervals of length `incr'.

        * When option `xtics' is bounded to a set of numbers of the
          form `{n1, n2, ...}', tic marks are plotted at values `n1',
          `n2', ...

        * When option `xtics' is bounded to a set of pairs of the form
          `{["label1", n1], ["label2", n2], ...}', tic marks
          corresponding to values `n1', `n2', ... are labeled with
          `"label1"', `"label2"', ..., respectively.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Examples:

     Disable tics.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = 'none,
                       explicit(x^3,x,-1,1)  )$

     Tics every 1/4 units.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = 1/4,
                       explicit(x^3,x,-1,1)  )$

     Tics from -3/4 to 3/4 in steps of 1/8.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = [-3/4,1/8,3/4],
                       explicit(x^3,x,-1,1)  )$

     Tics at points -1/2, -1/4 and 3/4.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = {-1/2,-1/4,3/4},
                       explicit(x^3,x,-1,1)  )$

     Labeled tics.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = {["High",0.75],["Medium",0],["Low",-0.75]},
                       explicit(x^3,x,-1,1)  )$

     See also `ytics', and `ztics'.

 -- Graphic option: xtics_axis
     Default value: `false'

     If `xtics_axis' is `true', tic marks and their labels are plotted
     just along the <x> axis, if it is `false' tics are plotted on the
     border.

     Since this is a global graphics option, its position in the scene
     description does not matter.

 -- Graphic option: xtics_rotate
     Default value: `false'

     If `xtics_rotate' is `true', tic marks on the <x> axis are rotated
     90 degrees.

     Since this is a global graphics option, its position in the scene
     description does not matter.

 -- Graphic option: xtics_rotate_secondary
     Default value: `false'

     If `xtics_rotate_secondary' is `true', tic marks on the secondary
     <x> axis are rotated 90 degrees.

     Since this is a global graphics option, its position in the scene
     description does not matter.

 -- Graphic option: xtics_secondary
     Default value: `auto'

     This graphic option controls the way tic marks are drawn on the
     second <x> axis.

     See `xtics' for a complete description.

 -- Graphic option: xtics_secondary_axis
     Default value: `false'

     If `xtics_secondary_axis' is `true', tic marks and their labels are
     plotted just along the secondary <x> axis, if it is `false' tics
     are plotted on the border.

     Since this is a global graphics option, its position in the scene
     description does not matter.

 -- Graphic option: xu_grid
     Default value: 30

     `xu_grid' is the number of coordinates of the first variable (`x'
     in explicit and `u' in parametric 3d surfaces) to build the grid
     of sample points.

     This option affects the following graphic objects:
        * `gr3d': `explicit' and `parametric_surface'.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(xu_grid = 10,
                       yv_grid = 50,
                       explicit(x^2+y^2,x,-3,3,y,-3,3) )$

     See also `yv_grid'.

 -- Graphic option: xy_file
     Default value: `""' (empty string)

     `xy_file' is the name of the file where the coordinates will be
     saved after clicking with the mouse button and hitting the 'x'
     key.  By default, no coordinates are saved.

     Since this is a global graphics option, its position in the scene
     description does not matter.

 -- Graphic option: xyplane
     Default value: `false'

     Allocates the xy-plane in 3D scenes.  When `xyplane' is `false',
     the xy-plane is placed automatically; when it is a real number,
     the xy-plane intersects the z-axis at this level.  This option has
     no effect in 2D scenes.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(xyplane = %e-2,
                       explicit(x^2+y^2,x,-1,1,y,-1,1))$

 -- Graphic option: y_voxel
     Default value: 10

     `y_voxel' is the number of voxels in the y direction to be used by
     the marching cubes algorithm implemented by the 3d `implicit'
     object.  It is also used by graphic object `region'.

 -- Graphic option: yaxis
     Default value: `false'

     If `yaxis' is `true', the <y> axis is drawn.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_color = blue)$

     See also `yaxis_width', `yaxis_type' and `yaxis_color'.

 -- Graphic option: yaxis_color
     Default value: `"black"'

     `yaxis_color' specifies the color for the <y> axis.  See `color'
     to know how colors are defined.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_color = red)$

     See also `yaxis', `yaxis_width' and `yaxis_type'.

 -- Graphic option: yaxis_secondary
     Default value: `false'

     If `yaxis_secondary' is `true', function values can be plotted with
     respect to the second <y> axis, which will be drawn on the right
     side of the scene.

     Note that this is a local graphics option which only affects to 2d
     plots.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(
                   explicit(sin(x),x,0,10),
                   yaxis_secondary = true,
                   ytics_secondary = true,
                   color = blue,
                   explicit(100*sin(x+0.1)+2,x,0,10));

     See also `yrange_secondary', `ytics_secondary',
     `ytics_rotate_secondary' and `ytics_axis_secondary'.

 -- Graphic option: yaxis_type
     Default value: `dots'

     `yaxis_type' indicates how the <y> axis is displayed; possible
     values are `solid' and `dots'.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_type  = solid)$

     See also `yaxis', `yaxis_width' and `yaxis_color'.

 -- Graphic option: yaxis_width
     Default value: 1

     `yaxis_width' is the width of the <y> axis.  Its value must be a
     positive number.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_width = 3)$

     See also `yaxis', `yaxis_type' and `yaxis_color'.

 -- Graphic option: ylabel
     Default value: `""' (empty string)

     Option `ylabel', a string, is the label for the <y> axis.  By
     default, no label is written.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(xlabel = "Time",
                       ylabel = "Population",
                       explicit(exp(u),u,-2,2) )$

     See also `xlabel', and `zlabel'.

 -- Graphic option: yrange
     Default value: `auto'

     If `yrange' is `auto', the range for the <y> coordinate is
     computed automatically.

     If the user wants a specific interval for <y>, it must be given as
     a Maxima list, as in `yrange=[-2, 3]'.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(yrange = [-2,3],
                       explicit(x^2,x,-1,1),
                       xrange = [-3,3])$

     See also `xrange', `yrange_secondary' and `zrange'.

 -- Graphic option: yrange_secondary
     Default value: `auto'

     If `yrange_secondary' is `auto', the range for the second <y> axis
     is computed automatically.

     If the user wants a specific interval for the second <y> axis, it
     must be given as a Maxima list, as in `yrange_secondary=[-2, 3]'.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(
                   explicit(sin(x),x,0,10),
                   yaxis_secondary = true,
                   ytics_secondary = true,
                   yrange = [-3, 3],
                   yrange_secondary = [-20, 20],
                   color = blue,
                   explicit(100*sin(x+0.1)+2,x,0,10)) $

     See also `xrange', `yrange' and `zrange'.

 -- Graphic option: ytics
     Default value: `auto'

     This graphic option controls the way tic marks are drawn on the
     <y> axis.

     See `xtics' for a complete description.

 -- Graphic option: ytics_axis
     Default value: `false'

     If `ytics_axis' is `true', tic marks and their labels are plotted
     just along the <y> axis, if it is `false' tics are plotted on the
     border.

     Since this is a global graphics option, its position in the scene
     description does not matter.

 -- Graphic option: ytics_rotate
     Default value: `false'

     If `ytics_rotate' is `true', tic marks on the <y> axis are rotated
     90 degrees.

     Since this is a global graphics option, its position in the scene
     description does not matter.

 -- Graphic option: ytics_rotate_secondary
     Default value: `false'

     If `ytics_rotate_secondary' is `true', tic marks on the secondary
     <y> axis are rotated 90 degrees.

     Since this is a global graphics option, its position in the scene
     description does not matter.

 -- Graphic option: ytics_secondary
     Default value: `auto'

     This graphic option controls the way tic marks are drawn on the
     second <y> axis.

     See `xtics' for a complete description.

 -- Graphic option: ytics_secondary_axis
     Default value: `false'

     If `ytics_secondary_axis' is `true', tic marks and their labels are
     plotted just along the secondary <y> axis, if it is `false' tics
     are plotted on the border.

     Since this is a global graphics option, its position in the scene
     description does not matter.

 -- Graphic option: yv_grid
     Default value: 30

     `yv_grid' is the number of coordinates of the second variable (`y'
     in explicit and `v' in parametric 3d surfaces) to build the grid
     of sample points.

     This option affects the following graphic objects:
        * `gr3d': `explicit' and `parametric_surface'.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(xu_grid = 10,
                       yv_grid = 50,
                       explicit(x^2+y^2,x,-3,3,y,-3,3) )$

     See also `xu_grid'.

 -- Graphic option: z_voxel
     Default value: 10

     `z_voxel' is the number of voxels in the z direction to be used by
     the marching cubes algorithm implemented by the 3d `implicit'
     object.

 -- Graphic option: zaxis
     Default value: `false'

     If `zaxis' is `true', the <z> axis is drawn in 3D plots.  This
     option has no effect in 2D scenes.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid,
                       zaxis_color = blue)$

     See also `zaxis_width', `zaxis_type' and `zaxis_color'.

 -- Graphic option: zaxis_color
     Default value: `"black"'

     `zaxis_color' specifies the color for the <z> axis.  See `color'
     to know how colors are defined.  This option has no effect in 2D
     scenes.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid,
                       zaxis_color = red)$

     See also `zaxis', `zaxis_width' and `zaxis_type'.

 -- Graphic option: zaxis_type
     Default value: `dots'

     `zaxis_type' indicates how the <z> axis is displayed; possible
     values are `solid' and `dots'.  This option has no effect in 2D
     scenes.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid)$

     See also `zaxis', `zaxis_width' and `zaxis_color'.

 -- Graphic option: zaxis_width
     Default value: 1

     `zaxis_width' is the width of the <z> axis.  Its value must be a
     positive number.  This option has no effect in 2D scenes.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid,
                       zaxis_width = 3)$

     See also `zaxis', `zaxis_type' and `zaxis_color'.

 -- Graphic option: zlabel
     Default value: `""' (empty string)

     Option `zlabel', a string, is the label for the <z> axis.  By
     default, no label is written.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(zlabel = "Z variable",
                       ylabel = "Y variable",
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2),
                       xlabel = "X variable" )$

     See also `xlabel', and `ylabel'.

 -- Graphic option: zrange
     Default value: `auto'

     If `zrange' is `auto', the range for the <z> coordinate is
     computed automatically.

     If the user wants a specific interval for <z>, it must be given as
     a Maxima list, as in `zrange=[-2, 3]'.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(yrange = [-3,3],
                       zrange = [-2,5],
                       explicit(x^2+y^2,x,-1,1,y,-1,1),
                       xrange = [-3,3])$

     See also `xrange' and `yrange'.

 -- Graphic option: ztics
     Default value: `auto'

     This graphic option controls the way tic marks are drawn on the
     <z> axis.

     See `xtics' for a complete description.

 -- Graphic option: ztics_axis
     Default value: `false'

     If `ztics_axis' is `true', tic marks and their labels are plotted
     just along the <z> axis, if it is `false' tics are plotted on the
     border.

     Since this is a global graphics option, its position in the scene
     description does not matter.

 -- Graphic option: ztics_rotate
     Default value: `false'

     If `ztics_rotate' is `true', tic marks on the <z> axis are rotated
     90 degrees.

     Since this is a global graphics option, its position in the scene
     description does not matter.

42.2.4 Graphics objects
-----------------------

 -- Graphic object: bars ([<x1>, <h1>, <w1>], [<x2>, <h2>, <w2>, ...])
     Draws vertical bars in 2D.

     2D

     `bars([<x1>, <h1>, <w1>], [<x2>, <h2>, <w2>, ...])' draws bars
     centered at values <x1>, <x2>, ... with heights <h1>, <h2>, ...
     and widths <w1>, <w2>, ...

     This object is affected by the following graphic options: `key',
     `fill_color', `fill_density' and `line_width'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(
                 key          = "Group A",
                 fill_color   = blue,
                 fill_density = 0.2,
                 bars([0.8,5,0.4],[1.8,7,0.4],[2.8,-4,0.4]),
                 key          = "Group B",
                 fill_color   = red,
                 fill_density = 0.6,
                 line_width   = 4,
                 bars([1.2,4,0.4],[2.2,-2,0.4],[3.2,5,0.4]),
                 xaxis = true);

 -- Graphic object: cylindrical (<radius>, <z>, <minz>, <maxz>, <azi>,
          <minazi>, <maxazi>)
     Draws 3D functions defined in cylindrical coordinates.

     3D

     `cylindrical(<radius>, <z>, <minz>, <maxz>, <azi>, <minazi>,
     <maxazi>)' plots function `<radius>(<z>, <azi>)' defined in
     cylindrical coordinates, with variable <z> taking values from
     <minz> to <maxz> and azimuth <azi> taking values from <minazi> to
     <maxazi>.

     This object is affected by the following graphic options:
     `xu_grid', `yv_grid', `line_type', `key', `wired_surface',
     `enhanced3d' and `color'.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(cylindrical(1,z,-2,2,az,0,2*%pi))$

 -- Graphic object: elevation_grid (<mat>, <x0>, <y0>, <width>,
          <height>)
     Draws matrix <mat> in 3D space.  <z> values are taken from <mat>,
     the abscissas range from <x0> to <x0> + <width> and ordinates from
     <y0> to <y0> + <height>.  Element a(1,1) is projected on point
     (x0,y0+height), a(1,n) on (x0+width,y0+height), a(m,1) on (x0,y0),
     and a(m,n) on (x0+width,y0).

     This object is affected by the following graphic options:
     `line_type', `line_width', `key', `wired_surface', `enhanced3d',
     and `color'.

     In older versions of Maxima, `elevation_grid' was called `mesh'.
     See also `mesh'.

     Example:

          (%i1) load(draw)$
          (%i2) m: apply(
                      matrix,
                      makelist(makelist(random(10.0),k,1,30),i,1,20)) $
          (%i3) draw3d(
                   color = blue,
                   elevation_grid(m,0,0,3,2),
                   xlabel = "x",
                   ylabel = "y",
                   surface_hide = true);

 -- Graphic object: ellipse (<xc>, <yc>, <a>, <b>, <ang1>, <ang2>)
     Draws ellipses and circles in 2D.

     2D

     `ellipse (<xc>, <yc>, <a>, <b>, <ang1>, <ang2>)' plots an ellipse
     centered at `[<xc>, <yc>]' with horizontal and vertical semi axis
     <a> and <b>, respectively, starting at angle <ang1> with an
     amplitude equal to angle <ang2>.

     This object is affected by the following graphic options: `nticks',
     `transparent', `fill_color', `border', `line_width', `line_type',
     `key' and `color'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(transparent = false,
                       fill_color  = red,
                       color       = gray30,
                       transparent = false,
                       line_width  = 5,
                       ellipse(0,6,3,2,270,-270),
                       /* center (x,y), a, b, start & end in degrees */
                       transparent = true,
                       color       = blue,
                       line_width  = 3,
                       ellipse(2.5,6,2,3,30,-90),
                       xrange      = [-3,6],
                       yrange      = [2,9] )$

 -- Graphic object: errors ([<x1>, <x2>, ...], [<y1>, <y2>, ...])
     Draws points with error bars, horizontally, vertically or both,
     depending on the value of option `error_type'.

     2D

     If `error_type = x', arguments to `errors' must be of the form
     `[x, y, xdelta]' or `[x, y, xlow, xhigh]'.  If `error_type = y',
     arguments must be of the form `[x, y, ydelta]' or `[x, y, ylow,
     yhigh]'.  If `error_type = xy' or `error_type = boxes', arguments
     to `errors' must be of the form `[x, y, xdelta, ydelta]' or `[x,
     y, xlow, xhigh, ylow, yhigh]'.

     See also `error_type'.

     This object is affected by the following graphic options:
     `error_type', `points_joined', `line_width', `key', `line_type',
     `color', `fill_density', `xaxis_secondary', and `yaxis_secondary'.

     Option `fill_density' is only relevant when `error_type=boxes'.

     Examples:

     Horizontal error bars.

          (%i1) load(draw)$
          (%i2) draw2d(
                  error_type = y,
                  errors([[1,2,1], [3,5,3], [10,3,1], [17,6,2]]))$

     Vertical and horizontal error bars.

          (%i1) load(draw)$
          (%i2) draw2d(
                  error_type = xy,
                  points_joined = true,
                  color = blue,
                  errors([[1,2,1,2], [3,5,2,1], [10,3,1,1], [17,6,1/2,2]]));

 -- Graphic object: explicit (<fcn>, <var>, <minval>, <maxval>)
 -- Graphic object: explicit (<fcn>, <var1>, <minval1>, <maxval1>,
          <var2>, <minval2>, <maxval2>)
     Draws explicit functions in 2D and 3D.

     2D

     `explicit(<fcn>,<var>,<minval>,<maxval>)' plots explicit function
     <fcn>, with variable <var> taking values from <minval> to <maxval>.

     This object is affected by the following graphic options: `nticks',
     `adapt_depth', `draw_realpart', `line_width', `line_type', `key',
     `filled_func', `fill_color' and `color'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(line_width = 3,
                       color      = blue,
                       explicit(x^2,x,-3,3) )$
          (%i3) draw2d(fill_color  = brown,
                       filled_func = true,
                       explicit(x^2,x,-3,3) )$

     3D

     `explicit (<fcn>, <var1>, <minval1>, <maxval1>, <var2>, <minval2>,
     <maxval2>)' plots the explicit function <fcn>, with the variable
     <var1> taking values from <minval1> to <maxval1> and the variable
     <var2> taking values from <minval2> to <maxval2>.

     This object is affected by the following graphic options:
     `draw_realpart', `xu_grid', `yv_grid', `line_type', `line_width',
     `key', `wired_surface', `enhanced3d', and `color'.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(key   = "Gauss",
                       color = "#a02c00",
                       explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3),
                       yv_grid     = 10,
                       color = blue,
                       key   = "Plane",
                       explicit(x+y,x,-5,5,y,-5,5),
                       surface_hide = true)$

     See also `filled_func' for filled functions.

 -- Graphic object: image (<im>, <x0>, <y0>, <width>, <height>)
     Renders images in 2D.

     2D

     `image(<im>, <x0>, <y0>, <width>, <height>)' plots image <im> in
     the rectangular region from vertex `(<x0>, <y0>)' to `(x0+<width>,
     y0+<height>)' on the real plane.  Argument <im> must be a matrix
     of real numbers, a matrix of vectors of length three or a
     <picture> object.

     If <im> is a matrix of real numbers or a <levels picture> object,
     pixel values are interpreted according to graphic option `palette',
     which is a vector of length three with components ranging from -36
     to +36; each value is an index for a formula mapping the levels
     onto red, green and blue colors, respectively:
           0: 0               1: 0.5           2: 1
           3: x               4: x^2           5: x^3
           6: x^4             7: sqrt(x)       8: sqrt(sqrt(x))
           9: sin(90x)       10: cos(90x)     11: |x-0.5|
          12: (2x-1)^2       13: sin(180x)    14: |cos(180x)|
          15: sin(360x)      16: cos(360x)    17: |sin(360x)|
          18: |cos(360x)|    19: |sin(720x)|  20: |cos(720x)|
          21: 3x             22: 3x-1         23: 3x-2
          24: |3x-1|         25: |3x-2|       26: (3x-1)/2
          27: (3x-2)/2       28: |(3x-1)/2|   29: |(3x-2)/2|
          30: x/0.32-0.78125                  31: 2*x-0.84
          32: 4x;1;-2x+1.84;x/0.08-11.5
          33: |2*x - 0.5|    34: 2*x          35: 2*x - 0.5
          36: 2*x - 1
     negative numbers mean negative colour component.

     `palette = gray' and `palette = color' are short cuts for `palette
     = [3,3,3]' and `palette = [7,5,15]', respectively.

     If <im> is a matrix of vectors of length three or an <rgb picture>
     object, they are interpreted as red, green and blue color
     components.

     Examples:

     If <im> is a matrix of real numbers, pixel values are interpreted
     according to graphic option `palette'.

          (%i1) load(draw)$
          (%i2) im: apply(
                     'matrix,
                      makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) /* palette = color, default */
                draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(palette = gray, image(im,0,0,30,30))$
          (%i5) draw2d(palette = [15,20,-4],
                       colorbox=false,
                       image(im,0,0,30,30))$

     See also `colorbox'.

     If <im> is a matrix of vectors of length three, they are
     interpreted as red, green and blue color components.
          (%i1) load(draw)$
          (%i2) im: apply(
                      'matrix,
                       makelist(
                         makelist([random(300),
                                   random(300),
                                   random(300)],i,1,30),i,1,30))$
          (%i3) draw2d(image(im,0,0,30,30))$

     Package `draw' automatically loads package `picture'.  In this
     example, a level picture object is built by hand and then rendered.
          (%i1) load(draw)$
          (%i2) im: make_level_picture([45,87,2,134,204,16],3,2);
          (%o2)       picture(level, 3, 2, {Array:  #(45 87 2 134 204 16)})
          (%i3) /* default color palette */
                draw2d(image(im,0,0,30,30))$
          (%i4) /* gray palette */
                draw2d(palette = gray,
                       image(im,0,0,30,30))$

     An xpm file is read and then rendered.
          (%i1) load(draw)$
          (%i2) im: read_xpm("myfile.xpm")$
          (%i3) draw2d(image(im,0,0,10,7))$

     See also `make_level_picture', `make_rgb_picture' and `read_xpm'.

     `http://www.telefonica.net/web2/biomates/maxima/gpdraw/image' contains more
     elaborated examples.

 -- Graphic object: implicit (<fcn>, <x>, <xmin>, <xmax>, <y>, <ymin>,
          <ymax>)
 -- Graphic object: implicit (<fcn>, <x>, <xmin>, <xmax>, <y>, <ymin>,
          <ymax>, <z>, <zmin>, <zmax>)
     Draws implicit functions in 2D and 3D.

     2D

     `implicit(<fcn>, <x>, <xmin>, <xmax>, <y>, <ymin>, <ymax>)' plots
     the implicit function defined by <fcn>, with variable <x> taking
     values from <xmin> to <xmax>, and variable <y> taking values from
     <ymin> to <ymax>.

     This object is affected by the following graphic options:
     `ip_grid', `ip_grid_in', `line_width', `line_type', `key' and
     `color'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(terminal  = eps,
                       grid      = true,
                       line_type = solid,
                       key       = "y^2=x^3-2*x+1",
                       implicit(y^2=x^3-2*x+1, x, -4,4, y, -4,4),
                       line_type = dots,
                       key       = "x^3+y^3 = 3*x*y^2-x-1",
                       implicit(x^3+y^3 = 3*x*y^2-x-1, x,-4,4, y,-4,4),
                       title     = "Two implicit functions" )$

     3D

     `implicit(<fcn>, <x>, <xmin>, <xmax>, <y>, <ymin>, <ymax>, <z>,
     <zmin>, <zmax>)' plots the implicit surface defined by <fcn>, with
     variable <x> taking values from <xmin> to <xmax>, variable <y>
     taking values from <ymin> to <ymax> and variable <z> taking values
     from <zmin> to <zmax>.  This object implements the marching cubes
     algorithm.

     This object is affected by the following graphic options:
     `x_voxel', `y_voxel', `z_voxel', `line_width', `line_type', `key',
     `wired_surface', `enhanced3d', and `color'.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(
                  color=blue,
                  implicit((x^2+y^2+z^2-1)*(x^2+(y-1.5)^2+z^2-0.5)=0.015,
                           x,-1,1,y,-1.2,2.3,z,-1,1),
                  surface_hide=true);

 -- Graphic object: label ([<string>, <x>, <y>], ...)
 -- Graphic object: label ([<string>, <x>, <y>, <z>], ...)
     Writes labels in 2D and 3D.

     Colored labels work only with Gnuplot 4.3.  This is a known bug in
     package `draw'.

     This object is affected by the following graphic options:
     `label_alignment', `label_orientation' and `color'.

     2D

     `label([<string>, <x>, <y>])' writes the <string> at point `[<x>,
     <y>]'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(yrange = [0.1,1.4],
                       color = red,
                       label(["Label in red",0,0.3]),
                       color = "#0000ff",
                       label(["Label in blue",0,0.6]),
                       color = light_blue,
                       label(["Label in light-blue",0,0.9],
                             ["Another light-blue",0,1.2])  )$

     3D

     `label([<string>, <x>, <y>, <z>])' writes the <string> at point
     `[<x>, <y>, <z>]'.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3),
                       color = red,
                       label(["UP 1",-2,0,3], ["UP 2",1.5,0,4]),
                       color = blue,
                       label(["DOWN 1",2,0,-3]) )$

 -- Graphic object: mesh (<row_1>, <row_2>, ...)
     Draws a quadrangular mesh in 3D.

     3D

     Argument <row_i> is a list of <n> 3D points of the form
     `[[x_i1,y_i1,z_i1], ...,[x_in,y_in,z_in]]', and all rows are of
     equal length.  All these points define an arbitrary surface in 3D
     and in some sense it's a generalization of the `elevation_grid'
     object.

     This object is affected by the following graphic options:
     `line_type', `line_width', `color', `key', `wired_surface',
     `enhanced3d', and `transform'.

     Examples:

     A simple example.

          (%i1) load(draw)$
          (%i2) draw3d(
                   mesh([[1,1,3],   [7,3,1],[12,-2,4],[15,0,5]],
                        [[2,7,8],   [4,3,1],[10,5,8], [12,7,1]],
                        [[-2,11,10],[6,9,5],[6,15,1], [20,15,2]])) $

     Plotting a triangle in 3D.

          (%i1) load(draw)$
          (%i2) draw3d(
                  line_width = 2,
                  mesh([[1,0,0],[0,1,0]],
                       [[0,0,1],[0,0,1]])) $

     Two quadrilaterals.

          (%i1) load(draw)$
          (%i2) draw3d(
                  surface_hide = true,
                  line_width   = 3,
                  color = red,
                  mesh([[0,0,0], [0,1,0]],
                       [[2,0,2], [2,2,2]]),
                  color = blue,
                  mesh([[0,0,2], [0,1,2]],
                       [[2,0,4], [2,2,4]])) $

 -- Graphic object: parametric (<xfun>, <yfun>, <par>, <parmin>,
          <parmax>)
 -- Graphic object: parametric (<xfun>, <yfun>, <zfun>, <par>,
          <parmin>, <parmax>)
     Draws parametric functions in 2D and 3D.

     This object is affected by the following graphic options: `nticks',
     `line_width', `line_type', `key', `color' and `enhanced3d'.

     2D

     `parametric(<xfun>, <yfun>, <par>, <parmin>, <parmax>)' plots the
     parametric function `[<xfun>, <yfun>]', with the parameter <par>
     taking values from <parmin> to <parmax>.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(exp(x),x,-1,3),
                       color = red,
                       key   = "This is the parametric one!!",
                       parametric(2*cos(rrr),rrr^2,rrr,0,2*%pi))$

     3D

     The command `parametric(<xfun>, <yfun>, <zfun>, <par>, <parmin>,
     <parmax>)' plots the parametric curve `[<xfun>, <yfun>, <zfun>]',
     with the parameter <par> taking values from <parmin> to <parmax>.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3),
                       color = royalblue,
                       parametric(cos(5*u)^2,sin(7*u),u-2,u,0,2),
                       color      = turquoise,
                       line_width = 2,
                       parametric(t^2,sin(t),2+t,t,0,2),
                       surface_hide = true,
                       title = "Surface & curves" )$

 -- Graphic object: parametric_surface (<xfun>, <yfun>, <zfun>, <par1>,
          <par1min>, <par1max>, <par2>, <par2min>, <par2max>)
     Draws parametric surfaces in 3D.

     3D

     `parametric_surface(<xfun>, <yfun>, <zfun>, <par1>, <par1min>,
     <par1max>, <par2>,
     <par2min>, <par2max>)' plots the parametric surface `[<xfun>,
     <yfun>, <zfun>]', with the parameter <par1> taking values from
     <par1min> to <par1max> and the parameter <par2> taking values from
     <par2min> to <par2max>.

     This object is affected by the following graphic options:
     `draw_realpart', `xu_grid', `yv_grid', `line_type', `line_width',
     `key', `wired_surface', `enhanced3d', and `color'.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(title          = "Sea shell",
                       xu_grid        = 100,
                       yv_grid        = 25,
                       view           = [100,20],
                       surface_hide   = true,
                       parametric_surface(0.5*u*cos(u)*(cos(v)+1),
                                     0.5*u*sin(u)*(cos(v)+1),
                                     u*sin(v) - ((u+3)/8*%pi)^2 - 20,
                                     u, 0, 13*%pi, v, -%pi, %pi) )$

 -- Graphic object: points ([[<x1>, <y1>], [<x2>, <y2>], ...])
 -- Graphic object: points ([<x1>, <x2>, ...], [<y1>, <y2>, ...])
 -- Graphic object: points ([<y1>, <y2>, ...])
 -- Graphic object: points ([[<x1>, <y1>, <z1>], [<x2>, <y2>, <z2>],
          ...])
 -- Graphic object: points ([<x1>, <x2>, ...], [<y1>, <y2>, ...],
          [<z1>, <z2>, ...])
 -- Graphic object: points (<matrix>)
 -- Graphic object: points (<1d_y_array>)
 -- Graphic object: points (<1d_x_array>, <1d_y_array>)
 -- Graphic object: points (<1d_x_array>, <1d_y_array>, <1d_z_array>)
 -- Graphic object: points (<2d_xy_array>)
 -- Graphic object: points (<2d_xyz_array>)
     Draws points in 2D and 3D.

     This object is affected by the following graphic options:
     `point_size', `point_type', `points_joined', `line_width', `key',
     `line_type' and `color'.  In 3D mode, it is also affected by
     `enhanced3d'.

     2D

     `points([[<x1>, <y1>], [<x2>, <y2>], ...])' or `points([<x1>,
     <x2>, ...], [<y1>, <y2>, ...])' plots points `[x1, y1]', `[x2,
     y2]', etc.  If abscissas are not given, they are set to
     consecutive positive integers, so that `points([<y1>, <y2>, ...])'
     draws points `[1, <y1>]', `[2, <y2>]', etc.  If <matrix> is a
     two-column or two-row matrix, `points (<matrix>)' draws the
     associated points.  If <matrix> is a one-column or one-row matrix,
     abscissas are assigned automatically.

     If <1d_y_array> is a 1D lisp array of numbers,
     `points(<1d_y_array>)' plots them setting abscissas to consecutive
     positive integers.  `points(<1d_x_array>, <1d_y_array>)' plots
     points with their coordinates taken from the two arrays passed as
     arguments.  If <2d_xy_array> is a 2D array with two columns, or
     with two rows, `points(<2d_xy_array>)' plots the corresponding
     points on the plane.

     Examples:

     Two types of arguments for `points', a list of pairs and two lists
     of separate coordinates.
          (%i1) load(draw)$
          (%i2) draw2d(
                  key = "Small points",
                  points(makelist([random(20),random(50)],k,1,10)),
                  point_type    = circle,
                  point_size    = 3,
                  points_joined = true,
                  key           = "Great points",
                  points(makelist(k,k,1,20),makelist(random(30),k,1,20)),
                  point_type    = filled_down_triangle,
                  key           = "Automatic abscissas",
                  color         = red,
                  points([2,12,8]))$

     Drawing impulses.
          (%i1) load(draw)$
          (%i2) draw2d(
                  points_joined = impulses,
                  line_width    = 2,
                  color         = red,
                  points(makelist([random(20),random(50)],k,1,10)))$

     Array with ordinates.
          (%i1) load(draw)$
          (%i2) a: make_array (flonum, 100) $
          (%i3) for i:0 thru 99 do a[i]: random(1.0) $
          (%i4) draw2d(points(a)) $

     Two arrays with separate coordinates.
          (%i1) load(draw)$
          (%i2) x: make_array (flonum, 100) $
          (%i3) y: make_array (fixnum, 100) $
          (%i4) for i:0 thru 99 do (
                  x[i]: float(i/100),
                  y[i]: random(10) ) $
          (%i5) draw2d(points(x, y)) $

     A two-column 2D array.
          (%i1) load(draw)$
          (%i2) xy: make_array(flonum, 100, 2) $
          (%i3) for i:0 thru 99 do (
                  xy[i, 0]: float(i/100),
                  xy[i, 1]: random(10) ) $
          (%i4) draw2d(points(xy)) $

     Drawing an array filled with function `read_array'.
          (%i1) load(draw)$
          (%i2) a: make_array(flonum,100) $
          (%i3) read_array (file_search ("pidigits.data"), a) $
          (%i4) draw2d(points(a)) $

     3D

     `points([[<x1>, <y1>, <z1>], [<x2>, <y2>, <z2>], ...])' or
     `points([<x1>, <x2>, ...], [<y1>, <y2>, ...], [<z1>, <z2>, ...])'
     plots points `[<x1>, <y1>, <z1>]', `[<x2>, <y2>, <z2>]', etc.  If
     <matrix> is a three-column or three-row matrix, `points
     (<matrix>)' draws the associated points.

     When arguments are lisp arrays, `points(<1d_x_array>, <1d_y_array>,
     <1d_z_array>)' takes coordinates from the three 1D arrays.  If
     <2d_xyz_array> is a 2D array with three columns, or with three
     rows, `points(<2d_xyz_array>)' plots the corresponding points.

     Examples:

     One tridimensional sample,

          (%i1) load(draw)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) draw3d(title = "Daily average wind speeds",
                       point_size = 2,
                       points(args(submatrix (s2, 4, 5))) )$

     Two tridimensional samples,

          (%i1) load(draw)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) draw3d(
                   title = "Daily average wind speeds. Two data sets",
                   point_size = 2,
                   key        = "Sample from stations 1, 2 and 3",
                   points(args(submatrix (s2, 4, 5))),
                   point_type = 4,
                   key        = "Sample from stations 1, 4 and 5",
                   points(args(submatrix (s2, 2, 3))) )$

     Unidimensional arrays,

          (%i1) load(draw)$
          (%i2) x: make_array (fixnum, 10) $
          (%i3) y: make_array (fixnum, 10) $
          (%i4) z: make_array (fixnum, 10) $
          (%i5) for i:0 thru 9 do (
                  x[i]: random(10),
                  y[i]: random(10),
                  z[i]: random(10) ) $
          (%i6) draw3d(points(x,y,z)) $

     Bidimensional colored array,

          (%i1) load(draw)$
          (%i2) xyz: make_array(fixnum, 10, 3) $
          (%i3) for i:0 thru 9 do (
                  xyz[i, 0]: random(10),
                  xyz[i, 1]: random(10),
                  xyz[i, 2]: random(10) ) $
          (%i4) draw3d(
                   enhanced3d = true,
                   points_joined = true,
                   points(xyz)) $

     Color numbers explicitly specified by the user.

          (%i1) load(draw)$
          (%i2) pts: makelist([t,t^2,cos(t)], t, 0, 15)$
          (%i3) col_num: makelist(k, k, 1, length(pts))$
          (%i4) draw3d(
                  enhanced3d = ['part(col_num,k),k],
                  point_size = 3,
                  point_type = filled_circle,
                  points(pts))$

 -- Graphic object: polar (<radius>, <ang>, <minang>, <maxang>)
     Draws 2D functions defined in polar coordinates.

     2D

     `polar(<radius>, <ang>, <minang>, <maxang>)' plots function
     `<radius>(<ang>)' defined in polar coordinates, with variable
     <ang> taking values from <minang> to <maxang>.

     This object is affected by the following graphic options: `nticks',
     `line_width', `line_type', `key' and `color'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(user_preamble = "set grid polar",
                       nticks        = 200,
                       xrange        = [-5,5],
                       yrange        = [-5,5],
                       color         = blue,
                       line_width    = 3,
                       title         = "Hyperbolic Spiral",
                       polar(10/theta,theta,1,10*%pi) )$

 -- Graphic object: polygon ([[<x1>, <y1>], [<x2>, <y2>], ...])
 -- Graphic object: polygon ([<x1>, <x2>, ...], [<y1>, <y2>, ...])
     Draws polygons in 2D.

     2D

     `polygon([[<x1>, <y1>], [<x2>, <y2>], ...])' or
     `polygon([<x1>, <x2>, ...], [<y1>,<y2>, ...])': plots on the plane
     a polygon with vertices `[<x1>, <y1>]', `[<x2>, <y2>]', etc.

     This object is affected by the following graphic options:
     `transparent', `fill_color', `border', `line_width', `key',
     `line_type' and `color'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(color      = "#e245f0",
                       line_width = 8,
                       polygon([[3,2],[7,2],[5,5]]),
                       border      = false,
                       fill_color  = yellow,
                       polygon([[5,2],[9,2],[7,5]]) )$

 -- Graphic object: quadrilateral (<point_1>, <point_2>, <point_3>,
          <point_4>)
     Draws a quadrilateral.

     2D

     `quadrilateral([<x1>, <y1>], [<x2>, <y2>], [<x3>, <y3>], [<x4>,
     <y4>])' draws a quadrilateral with vertices `[<x1>, <y1>]',
     `[<x2>, <y2>]', `[<x3>, <y3>]', and `[<x4>, <y4>]'.

     This object is affected by the following graphic options:
     `transparent', `fill_color', `border', `line_width',
     `key', `xaxis_secondary', `yaxis_secondary', `line_type',
     `transform' and `color'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(
                  quadrilateral([1,1],[2,2],[3,-1],[2,-2]))$

     3D

     `quadrilateral ([<x1>, <y1>, <z1>], [<x2>, <y2>, <z2>], [<x3>,
     <y3>, <z3>], [<x4>, <y4>, <z4>])'
     draws a quadrilateral with vertices `[<x1>, <y1>, <z1>]', `[<x2>,
     <y2>, <z2>]', `[<x3>, <y3>, <z3>]', and `[<x4>, <y4>, <z4>]'.

     This object is affected by the following graphic options:
     `line_type', `line_width', `color', `key', `enhanced3d', and
     `transform'.

 -- Graphic object: rectangle ([<x1>, <y1>], [<x2>, <y2>])
     Draws rectangles in 2D.

     2D

     `rectangle([<x1>, <y1>], [<x2>, <y2>])' draws a rectangle with
     opposite vertices `[<x1>, <y1>]' and `[<x2>, <y2>]'.

     This object is affected by the following graphic options:
     `transparent', `fill_color', `border', `line_width', `key',
     `line_type' and `color'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(fill_color  = red,
                       line_width  = 6,
                       line_type   = dots,
                       transparent = false,
                       fill_color  = blue,
                       rectangle([-2,-2],[8,-1]), /* opposite vertices */
                       transparent = true,
                       line_type   = solid,
                       line_width  = 1,
                       rectangle([9,4],[2,-1.5]),
                       xrange      = [-3,10],
                       yrange      = [-3,4.5] )$

 -- Graphic object: region (<expr>, <var1>, <minval1>, <maxval1>,
          <var2>, <minval2>, <maxval2>)
     Plots a region on the plane defined by inequalities.

     2D <expr> is an expression formed by inequalities and boolean
     operators `and', `or', and `not'. The region is bounded by the
     rectangle defined by [<minval1>, <maxval1>] and [<minval2>,
     <maxval2>].

     This object is affected by the following graphic options:
     `fill_color', `key', `x_voxel', and `y_voxel'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(
                  x_voxel = 30,
                  y_voxel = 30,
                  region(x^2+y^2<1 and x^2+y^2 > 1/2,
                         x, -1.5, 1.5, y, -1.5, 1.5));

 -- Graphic object: spherical (<radius>, <azi>, <minazi>, <maxazi>,
          <zen>, <minzen>, <maxzen>)
     Draws 3D functions defined in spherical coordinates.

     3D

     `spherical(<radius>, <azi>, <minazi>, <maxazi>, <zen>, <minzen>,
     <maxzen>)' plots function `<radius>(<azi>, <zen>)' defined in
     spherical coordinates, with azimuth <azi> taking values from
     <minazi> to <maxazi> and zenith <zen> taking values from <minzen>
     to <maxzen>.

     This object is affected by the following graphic options:
     `xu_grid', `yv_grid', `line_type', `key', `wired_surface',
     `enhanced3d', and `color'.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(spherical(1,a,0,2*%pi,z,0,%pi))$

 -- Graphic object: triangle (<point_1>, <point_2>, <point_3>)
     Draws a triangle.

     2D

     `triangle([<x1>, <y1>], [<x2>, <y2>], [<x3>, <y3>])' draws a
     triangle with vertices `[<x1>, <y1>]', `[<x2>, <y2>]', and
     `[<x3>,<y3>]'.

     This object is affected by the following graphic options:
     `transparent', `fill_color', `border', `line_width',
     `key', `xaxis_secondary', `yaxis_secondary', `line_type',
     `transform', and `color'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(
                  triangle([1,1],[2,2],[3,-1]))$

     3D

     `triangle([<x1>, <y1>, <z1>], [<x2>, <y2>, <z2>], [<x3>, <y3>,
     <z3>])' draws a triangle with vertices `[<x1>, <y1>, <z1>]',
     `[<x2>, <y2>, <z2>]', and `[<x3>, <y3>, <z3>]'.

     This object is affected by the following graphic options:
     `line_type', `line_width', `color', `key', `enhanced3d', and
     `transform'.

 -- Graphic object: tube (<xfun>, <yfun>, <zfun>, <rfun>, <p>, <pmin>,
          <pmax>)
     Draws a tube in 3D with varying diameter.

     3D

     `[<xfun>,<yfun>,<zfun>]' is the parametric curve with parameter
     <p> taking values from <pmin> to <pmax>. Circles of radius <rfun>
     are placed with their centers on the parametric curve and
     perpendicular to it.

     This object is affected by the following graphic options:
     `xu_grid', `yv_grid', `line_type', `line_width', `key',
     `wired_surface', `enhanced3d', `color', and `tube_extremes'.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(
                  enhanced3d = true,
                  xu_grid = 50,
                  tube(cos(a), a, 0, cos(a/10)^2,
                       a, 0, 4*%pi) )$

 -- Graphic object: vector ([<x>, <y>], [<dx>, <dy>])
 -- Graphic object: vector ([<x>, <y>, <z>], [<dx>, <dy>, <dz>])
     Draws vectors in 2D and 3D.

     This object is affected by the following graphic options:
     `head_both', `head_length', `head_angle', `head_type',
     `line_width', `line_type', `key' and `color'.

     2D

     `vector([<x>, <y>], [<dx>,<dy>])' plots vector `[<dx>, <dy>]' with
     origin in `[<x>, <y>]'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,10],
                       head_length = 1,
                       vector([0,1],[5,5]), /* default type */
                       head_type = 'empty,
                       vector([3,1],[5,5]),
                       head_both = true,
                       head_type = 'nofilled,
                       line_type = dots,
                       vector([6,1],[5,5]))$

     3D

     `vector([<x>, <y>, <z>], [<dx>, <dy>, <dz>])' plots vector
     `[<dx>,<dy>,<dz>]' with origin in `[<x>, <y>, <z>]'.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(color = cyan,
                       vector([0,0,0],[1,1,1]/sqrt(3)),
                       vector([0,0,0],[1,-1,0]/sqrt(2)),
                       vector([0,0,0],[1,1,-2]/sqrt(6)) )$



Local Variables:
coding: iso-8859-1
End:
