<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on Dezember, 10 2012 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Maxima Manual: 21. Zahlentheorie</title>

<meta name="description" content="Maxima Manual: 21. Zahlentheorie">
<meta name="keywords" content="Maxima Manual: 21. Zahlentheorie">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body
{
    color: black;
    background: white; 
    margin-left: 8%;
    margin-right: 13%;
}

h1
{
    margin-left: +8%;
    font-size: 150%;
    font-family: sans-serif
}

h2
{
    font-size: 125%;
    font-family: sans-serif
}

h3
{
    font-size: 100%;
    font-family: sans-serif
}

h2,h3,h4,h5,h6 { margin-left: +4%; }

div.textbox
{
    border: solid;
    border-width: thin;
    /* width: 100%; */
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em
}

div.titlebox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
    background: rgb(200,255,255);
    font-family: sans-serif
}

div.synopsisbox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
     background: rgb(255,220,255);
    /*background: rgb(200,255,255); */
    /* font-family: fixed */
}

pre.example
{
    border: 1px solid gray;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 1em;
    padding-right: 1em;
    /* background: rgb(247,242,180); */ /* kind of sandy */
    /* background: rgb(200,255,255); */ /* sky blue */
    background-color: #F1F5F9; /* light blue-gray */
    /* font-family: "Lucida Console", monospace */
}

div.spacerbox
{
    border: none;
    padding-top: 2em;
    padding-bottom: 2em
}

div.image
{
    margin: 0;
    padding: 1em;
    text-align: center;
}

div.categorybox
{
    border: 1px solid gray;
    padding-top: 0px;
    padding-bottom: 0px;
    padding-left: 1em;
    padding-right: 1em;
    background: rgb(247,242,220);
}


-->
</style>

<link rel="icon" href="http://maxima.sourceforge.net/favicon.ico"/>
</head>

<body lang="de" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Zahlentheorie"></a>
<a name="SEC160"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_20.html#SEC159" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC161" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_20.html#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_22.html#SEC162" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC409" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 21. Zahlentheorie </h1>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC161">21.1 Funktionen und Variablen der Zahlentheorie</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Funktionen-und-Variablen-der-Zahlentheorie"></a>
<a name="SEC161"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC160" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_22.html#SEC162" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC160" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC160" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_22.html#SEC162" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC409" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 21.1 Funktionen und Variablen der Zahlentheorie </h2>

<p><a name="bern"></a>
</p><dl>
<dt><u>Funktion:</u> <b>bern</b><i> (<var>n</var>)</i>
<a name="IDX1183"></a>
</dt>
<dd>
<p>Gibt die <var>n</var>-te Bernoulli-Zahl der ganzen Zahl <var>n</var> zur&uuml;ck. Hat die
Optionsvariable <code>zerobern</code> den Wert <code>false</code>, werden Bernoulli-Zahlen
unterdr&uuml;ckt, die Null sind.
</p>
<p>Siehe auch <code><a href="#burn">burn</a></code>.
</p>

<pre class="example">(%i1) zerobern: true$
(%i2) map (bern, [0, 1, 2, 3, 4, 5, 6, 7, 8]);
                  1  1       1      1        1
(%o2)       [1, - -, -, 0, - --, 0, --, 0, - --]
                  2  6       30     42       30
(%i3) zerobern: false$
(%i4) map (bern, [0, 1, 2, 3, 4, 5, 6, 7, 8]);
            1  1    1   5     691   7    3617  43867
(%o4) [1, - -, -, - --, --, - ----, -, - ----, -----]
            2  6    30  66    2730  6    510    798
</pre></dd></dl>

<p><a name="bernpoly"></a>
</p><dl>
<dt><u>Funktion:</u> <b>bernpoly</b><i> (<var>x</var>, <var>n</var>)</i>
<a name="IDX1184"></a>
</dt>
<dd>
<p>Gibt das <var>n</var>-te Bernoulli-Polynom in der Variablen <var>x</var> zur&uuml;ck.
</p></dd></dl>


<p><a name="bfzeta"></a>
</p><dl>
<dt><u>Function:</u> <b>bfzeta</b><i> (<var>s</var>, <var>n</var>)</i>
<a name="IDX1185"></a>
</dt>
<dd>
<p>Die Riemannsche Zeta-Funktion f&uuml;r das Argument <var>s</var>, die wie folgt 
definiert ist:
</p>
<pre class="example">                 inf
                 ====
                 \     1
     zeta(s) =    &gt;    --
                 /      s
                 ====  k
                 k = 1
</pre>
<p><code>bfzeta</code> gibt einen Wert als gro&szlig;e Gleitkommazahl zur&uuml;ck.  Die Anzahl 
der Stellen wird durch das Argument <var>n</var> angegeben.
</p>
<p>Anstatt der Funktion <code>bfzeta</code> ist die Funktion <code><a href="#zeta">zeta</a></code>
 zu bevorzugen,
die sowohl f&uuml;r reelle und komplexe Gleitkommazahlen und Gleitkommazahlen mit
eine beliebigen Genauigkeit die Riemannsche Zeta-Funktion berechnen kann.
</p></dd></dl>

<p><a name="bfhzeta"></a>
</p><dl>
<dt><u>Funktion:</u> <b>bfhzeta</b><i> (<var>s</var>, <var>h</var>, <var>n</var>)</i>
<a name="IDX1186"></a>
</dt>
<dd>

<p>Die Hurwitzsche Zeta-Funktion f&uuml;r die Argumente <var>s</var> und <var>h</var>, die wie
folgt definiert ist:
</p>
<pre class="example">                        inf
                        ====
                        \        1
         zeta (s,h)  =   &gt;    --------
                        /            s
                        ====  (k + h)
                        k = 0
</pre>
<p><code>bfhzeta</code> gibt einen Wert als gro&szlig;e Gleitkommazahl zur&uuml;ck.  Die 
Anzahl der Stellen wird durch das Argument <var>n</var> angegeben.
</p>
</dd></dl>

<p><a name="burn"></a>
</p><dl>
<dt><u>Funktion:</u> <b>burn</b><i> (<var>n</var>)</i>
<a name="IDX1187"></a>
</dt>
<dd>
<p>Gibt eine rational Zahl zur&uuml;ck, die eine N&auml;herung f&uuml;r die <var>n</var>-te 
Bernoulli Zahl f&uuml;r die ganze Zahl <var>n</var> ist.  <code>burn</code> berechnet eine 
N&auml;herung als gro&szlig;e Gleitkommatzahl mit der folgenden Beziehung:
</p>
<pre class="example">                   n - 1  1 - 2 n
              (- 1)      2        zeta(2 n) (2 n)!
     B(2 n) = ------------------------------------
                                2 n
                             %pi
</pre>

<p><code>burn</code> kann effizienter als die Funktion <code>bern</code> f&uuml;r gro&szlig;e, 
einzelne ganze Zahlen <var>n</var> sein, da <code>bern</code> zun&auml;chst alle Bernoulli 
Zahlen bis <var>n</var> berechnet.  <code>burn</code> ruft f&uuml;r ungerade ganze Zahlen und 
Zahlen die kleiner oder gleich 255 die Funktion <code>bern</code> auf.
</p>

<p>Das Kommando <code>load(bffac)</code> l&auml;dt die Funktion.  Siehe auch <code><a href="#bern">bern</a></code>.
</p>
</dd></dl>

<p><a name="chinese"></a>
</p><dl>
<dt><u>Funktion:</u> <b>chinese</b><i> ([<var>r_1</var>, &hellip;, <var>r_n</var>], [<var>m_1</var>, &hellip;, <var>m_n</var>])</i>
<a name="IDX1188"></a>
</dt>
<dd><p>L&ouml;st die simultanen Kongruenzen <code>x = r_1 mod m_1</code>, &hellip;, <code>x = r_n mod m_n</code>.
Die Reste <var>r_n</var> und die Moduli <var>m_n</var> m&uuml;ssen ganze Zahlen sein, 
die Moduli zus&auml;tzlich positiv und paarweise teilerfremd.
</p>
<pre class="example">(%i1) mods : [1000, 1001, 1003, 1007];
(%o1)                   [1000, 1001, 1003, 1007]
(%i2) lreduce('gcd, mods);
(%o2)                               1
(%i3) x : random(apply(&quot;*&quot;, mods));
(%o3)                         685124877004
(%i4) rems : map(lambda([z], mod(x, z)), mods);
(%o4)                       [4, 568, 54, 624]
(%i5) chinese(rems, mods);
(%o5)                         685124877004
(%i6) chinese([1, 2], [3, n]);
(%o6)                    chinese([1, 2], [3, n])
(%i7) %, n = 4;
(%o7)                              10
</pre></dd></dl>

<p><a name="divsum"></a>
</p><dl>
<dt><u>Funktion:</u> <b>divsum</b><i> (<var>n</var>, <var>k</var>)</i>
<a name="IDX1189"></a>
</dt>
<dt><u>Funktion:</u> <b>divsum</b><i> (<var>n</var>)</i>
<a name="IDX1190"></a>
</dt>
<dd>
<p><code>divsum(<var>n</var>, <var>k</var>)</code> potenziert die Teiler des Argumentes <var>n</var> 
mit dem Argument <var>k</var> und gibt die Summe als Ergebnis zur&uuml;ck.
</p>

<p><code>divsum(<var>n</var>)</code> gibt die Summe der Teiler der Zahl <var>n</var> zur&uuml;ck.
</p>
<pre class="example">(%i1) divsum (12);
(%o1)                          28
(%i2) 1 + 2 + 3 + 4 + 6 + 12;
(%o2)                          28
(%i3) divsum (12, 2);
(%o3)                          210
(%i4) 1^2 + 2^2 + 3^2 + 4^2 + 6^2 + 12^2;
(%o4)                          210
</pre></dd></dl>

<p><a name="euler"></a>
</p><dl>
<dt><u>Funktion:</u> <b>euler</b><i> (<var>n</var>)</i>
<a name="IDX1191"></a>
</dt>
<dd>
<p>Gibt die <var>n</var>-te Eulersche Zahl f&uuml;r eine nichtnegative ganze Zahl <var>n</var>
zur&uuml;ck.
</p>

<p>F&uuml;r die Euler-Mascheroni Konstante siehe <code><a href="maxima_5.html#g_t_0025gamma">%gamma</a></code>.
</p>

<p>Beispiele:
</p>
<pre class="example">(%i1) map (euler, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
(%o1)    [1, 0, - 1, 0, 5, 0, - 61, 0, 1385, 0, - 50521]
</pre></dd></dl>

<p><a name="fib"></a>
</p><dl>
<dt><u>Funktion:</u> <b>fib</b><i> (<var>n</var>)</i>
<a name="IDX1192"></a>
</dt>
<dd>
<p>Gibt die <var>n-te</var> Fibonacci-Zahl zur&uuml;ck.  Die Fibonacci-Folge ist rekursiv 
definiert:
</p>
<pre class="example">   fib(0) = 0
   fib(1) = 1
   fib(n) = fib(n-1) + fib(n-2)
</pre>
<p>F&uuml;r negative ganze Zahlen kann die Fibonacci-Folge erweitert wird mit:
</p>
<pre class="example">                   n + 1
   fib(- n) = (- 1)      f(n)
</pre>



<p>Nach einem Aufruf der Funktion <code>fib(n)</code>, enth&auml;lt die Systemvariable 
<code>prevfib</code> die zur Zahl <code>n</code> vorhergehende Fibonacci-Zahl.
</p>
<pre class="example">(%i1) map (fib, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
(%o1)         [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
</pre></dd></dl>

<p><a name="fibtophi"></a>
</p><dl>
<dt><u>Funktion:</u> <b>fibtophi</b><i> (<var>expr</var>)</i>
<a name="IDX1193"></a>
</dt>
<dd>
<p>Fibonacci-Zahlen im Ausdruck <var>expr</var> werden durch die Goldene Zahl 
<code>%phi</code> ausgedr&uuml;ckt.  Siehe <code><a href="maxima_5.html#g_t_0025phi">%phi</a></code>.
</p>

<p>Beispiele:
</p>
<pre class="example">(%i1) fibtophi (fib (n));
                           n             n
                       %phi  - (1 - %phi)
(%o1)                  -------------------
                           2 %phi - 1
(%i2) fib (n-1) + fib (n) - fib (n+1);
(%o2)          - fib(n + 1) + fib(n) + fib(n - 1)
(%i3) fibtophi (%);
            n + 1             n + 1       n             n
        %phi      - (1 - %phi)        %phi  - (1 - %phi)
(%o3) - --------------------------- + -------------------
                2 %phi - 1                2 %phi - 1
                                          n - 1             n - 1
                                      %phi      - (1 - %phi)
                                    + ---------------------------
                                              2 %phi - 1
(%i4) ratsimp (%);
(%o4)                           0
</pre></dd></dl>

<p><a name="ifactors"></a>
</p><dl>
<dt><u>Funktion:</u> <b>ifactors</b><i> (<var>n</var>)</i>
<a name="IDX1194"></a>
</dt>
<dd><p>Faktorisiert eine positive ganze Zahl <var>n</var>.  Sind <code>n = p1^e1 * ... * pk^nk</code> die
Faktoren der ganzen Zahl <var>n</var>, dann gibt <code>ifactor</code> das Ergebnis
<code>[[p1, e1], ..., [pk, ek]]</code> zur&uuml;ck.
</p>
<p>F&uuml;r die Faktorisierung kommen Probedivisionen mit Primzahlen bis 9973, 
Pollards Rho- und p-1-Methode oder Elliptischen Kurven zum Einsatz.
</p>
<p>Die R&uuml;ckgabe von ifactors wird von der Optionsvariablen <code>@ref{factors_only}</code>.
</p>  
<p>beeinflusst. 
Werden lediglich die Primfaktoren ohne ihre Multiplizit&auml;t ben&ouml;tigt, 
gen&uuml;gt es hierf&uuml;r, <code>factors_only : true</code> zu setzen.
</p>
<pre class="example">(%i1) ifactors(51575319651600);
(%o1)     [[2, 4], [3, 2], [5, 2], [1583, 1], [9050207, 1]]
(%i2) apply(&quot;*&quot;, map(lambda([u], u[1]^u[2]), %));
(%o2)                        51575319651600
(%i3) ifactors(51575319651600), factors_only : true;
(%o3)                   [2, 3, 5, 1583, 9050207]
</pre></dd></dl>

<p><a name="igcdex"></a>
</p><dl>
<dt><u>Funktion:</u> <b>igcdex</b><i> (<var>n</var>, <var>k</var>)</i>
<a name="IDX1195"></a>
</dt>
<dd><p>Gibt die Liste <code>[a, b, u]</code> zur&uuml;ck, in der <code>u</code> der 
gr&ouml;&szlig;te gemeinsame Teiler von <var>n</var> und <var>k</var> ist und in der zus&auml;tzlich 
gilt, dass <code>u = a * <var>n</var> + b * <var>k</var></code>. 
</p>
<p><code>igcdex</code> verwendet den Euklidischen Algorithmus.  Siehe auch <code><a href="maxima_17.html#gcdex">gcdex</a></code>.
.
</p>
<p>Die Eingabe <code>load(gcdex)</code> l&auml;dt diese Funktion.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) load(gcdex)$

(%i2) igcdex(30, 18);
(%o2)                      [- 1, 2, 6]
(%i3) igcdex(1526757668, 7835626735736);
(%o3)            [845922341123, - 164826435, 4]
(%i4) igcdex(fib(20), fib(21));
(%o4)                   [4181, - 2584, 1]
</pre></dd></dl>

<p><a name="inrt"></a>
</p><dl>
<dt><u>Funktion:</u> <b>inrt</b><i> (<var>x</var>, <var>n</var>)</i>
<a name="IDX1196"></a>
</dt>
<dd>
<p>Gibt die ganzzahlige <var>n</var>-te Wurzel des Betrags von <var>x</var> zur&uuml;ck.
</p>
<pre class="example">(%i1) l: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]$
(%i2) map (lambda ([a], inrt (10^a, 3)), l);
(%o2) [2, 4, 10, 21, 46, 100, 215, 464, 1000, 2154, 4641, 10000]
</pre></dd></dl>

<p><a name="inv_005fmod"></a>
</p><dl>
<dt><u>Funktion:</u> <b>inv_mod</b><i> (<var>n</var>, <var>m</var>)</i>
<a name="IDX1197"></a>
</dt>
<dd><p>Berechnet das modulare Inverse von <var>n</var> zum Modul <var>m</var>.  Das Argument
<var>n</var> muss eine ganze Zahl und der Modul <var>p</var> eine positive ganze Zahl 
sein.  <code>inv_mod(n, m)</code> gibt <code>false</code> zur&uuml;ck, wenn das modulare Inverse
nicht existiert.  Das modulare Inverse existiert, wenn <var>n</var> teilerfremd zum 
Modul <var>m</var> ist.
</p>
<p>Siehe auch die Funktionen <code><a href="#power_005fmod">power_mod</a></code>
 und <code><a href="#mod">mod</a></code>.
</p>

<p>Beispiele:
</p>
<pre class="example">(%i1) inv_mod(3, 41);
(%o1)                           14
(%i2) ratsimp(3^-1), modulus = 41;
(%o2)                           14
(%i3) inv_mod(3, 42);
(%o3)                          false
</pre></dd></dl>

<p><a name="isqrt"></a>
</p><dl>
<dt><u>Funktion:</u> <b>isqrt</b><i> (<var>x</var>)</i>
<a name="IDX1198"></a>
</dt>
<dd>
<p>Gibt die ganzzahlige Wurzel des Betrages von <var>x</var> zur&uuml;ck, wenn <var>x</var> eine
ganze Zahl ist.  Andernfalls wird eine Substantivform zur&uuml;ckgegeben.
</p></dd></dl>

<p><a name="jacobi"></a>
</p><dl>
<dt><u>Funktion:</u> <b>jacobi</b><i> (<var>p</var>, <var>q</var>)</i>
<a name="IDX1199"></a>
</dt>
<dd>
<p>Berechnet das Jacobi-Symbol f&uuml;r die Argumente <var>p</var> und <var>q</var>.
</p>
<pre class="example">(%i1) l: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]$
(%i2) map (lambda ([a], jacobi (a, 9)), l);
(%o2)         [1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0]
</pre></dd></dl>

<p><a name="lcm"></a>
</p><dl>
<dt><u>Funktion:</u> <b>lcm</b><i> (<var>expr_1</var>, &hellip;, <var>expr_n</var>)</i>
<a name="IDX1200"></a>
</dt>
<dd>
<p>Gibt das kleinste gemeinsame Vielfache der Argumente zur&uuml;ck.  Die Argumente 
k&ouml;nnen ganze Zahlen und allgemeine Ausdr&uuml;cke sein.
</p>

<p>Mit dem Kommando <code>load(functs)</code> wird die Funktion geladen.
</p></dd></dl>

<p><a name="mod"></a>
</p><dl>
<dt><u>Funktion:</u> <b>mod</b><i> (<var>x</var>, <var>p</var>)</i>
<a name="IDX1201"></a>
</dt>
<dd>
<p>Berechnet den Divisionsrest <code>x mod y</code> des Arguments <var>x</var> zum Modul <var>y</var>. 
<var>x</var> und <var>y</var> k&ouml;nnen ganze Zahlen, rationale Zahlen, Gleitkommazahlen 
oder allgemeine Ausdr&uuml;cke sein.
</p>
<p>Sind <var>x</var> und <var>y</var> reelle Zahlen und ist <var>y</var> ungleich Null, gibt 
<code>mod(<var>x</var>, <var>y</var>)</code> das Ergebnis von <code><var>x</var> - <var>y</var> * 
floor(<var>x</var> / <var>y</var>)</code> zur&uuml;ck.  Weiterhin gilt f&uuml;r alle reellen Zahlen
<code>mod(<var>x</var>, 0) = <var>x</var></code>.  F&uuml;r eine Diskussion dieser Definition siehe
Kapitel 3.4, &quot;Concrete Mathematics&quot; von Graham, Knuth, and Patashnik.  Die 
Funktion <code>mod(<var>x</var>, 1)</code> ist eine S&auml;gezahnfunktion mit der Periode 1 
mit <code>mod(1, 1) = 0</code> und <code>mod(0, 1) = 0</code>.
</p>

<p>Der Hauptwert einer komplexen Zahl, die im Intervall <code>(-%pi, %pi)</code> liegt,
kann mit <code>%pi - mod(%pi - <var>x</var>, 2*%pi)</code> bestimmt werden, wobei <var>x</var>
die komplexe Zahl ist.
</p>

<p>Sind <var>x</var> und <var>y</var> konstante Ausdr&uuml;cke, wie zum Beispiel <code>10 * %pi</code>,
verwendet <code>mod</code> dasselbe <code><a href="maxima_5.html#bfloat">bfloat</a></code>.
-Auswertungsschema wie <code>floor</code> 
und <code>ceiling</code>. Diese Umwandlung kann, wenn auch unwahrscheinlich, 
zu Fehlern f&uuml;hren.
</p>

<p>F&uuml;r nicht numerische Argumente <var>x</var> oder <var>y</var> kennt <code>mod</code>
verschiedene Vereinfachungen.
</p>
<p>Siehe auch die Funktionen <code><a href="#power_005fmod">power_mod</a></code>
 und <code><a href="#inv_005fmod">inv_mod</a></code>.
</p>

<p>Beispiele:
</p>
<p>Zeige f&uuml;r zwei gro&szlig;e ganze Zahlen, dass f&uuml;r das modulare Rechnen die 
Regel <code>mod(a+b, m) = mod(mod(a, m) + mod(b, m), m)</code> gilt.
</p>
<pre class="example">(%i1) a : random(10^20) + 10^19;
(%o1)                 72588919020045581148
(%i2) b : random(10^20) + 10^19;
(%o2)                 35463666253140008825
(%i3) m : random(10^20) + 10^19;
(%o3)                 39127433614020247557
(%i4) mod(a+b, m);
(%o4)                 29797718045145094859
(%i5) mod(mod(a, m) + mod(b, m), m);
(%o5)                 29797718045145094859
</pre>
<p>Vereinfachung f&uuml;r nicht numerische Argumente.
</p>
<pre class="example">(%i1) mod (x, 0);
(%o1)                           x
(%i2) mod (a*x, a*y);
(%o2)                      a mod(x, y)
(%i3) mod (0, x);
(%o3)                           0
</pre></dd></dl>

<p><a name="next_005fprime"></a>
</p><dl>
<dt><u>Funktion:</u> <b>next_prime</b><i> (<var>n</var>)</i>
<a name="IDX1202"></a>
</dt>
<dd>
<p>Gibt die kleinste Primzahl zur&uuml;ck, die der Zahl <var>n</var> folgt.
</p>
<pre class="example">(%i1) next_prime(27);
(%o1)                       29
</pre></dd></dl>

<p><a name="power_005fmod"></a>
</p><dl>
<dt><u>Funktion:</u> <b>power_mod</b><i> (<var>a</var>, <var>n</var>, <var>m</var>)</i>
<a name="IDX1203"></a>
</dt>
<dd><p>Verwendet einen modularen Algorithmus, um <code>a^n mod m</code> zu berechnen. 
Die Argumente <var>a</var> und <var>n</var> m&uuml;ssen ganze Zahlen und der Modul <var>m</var> 
eine positive ganze Zahl sein.  Ist <var>n</var> negativ, wird <code><a href="#inv_005fmod">inv_mod</a></code>
</p> 
<p>zur Berechnung des modularen Inversen aufgerufen.
</p>
<p><code>power_mod (<var>a</var>, <var>n</var>, <var>m</var>)</code> ist &auml;quivalent zu 
<code>mod(a^n, m)</code>.  Der Algorithmus von <code>power_mod</code> ist jedoch 
insbesondere f&uuml;r gro&szlig;e ganze Zahlen wesentlich effizienter.
</p>
<p>Siehe auch die Funktionen <code><a href="#inv_005fmod">inv_mod</a></code>
 und <code><a href="#mod">mod</a></code>.
</p>

<p>Beispiele:
</p>
<p><code>power_mod(a, n, m)</code> ist &auml;quivalent zu <code>mod(a^n, m</code>.  Das modulare
Inverse wird mit der Funktion <code>inv_mod</code> berechnet.
</p>
<pre class="example">(%i1) power_mod(3, 15, 5);
(%o1)                          2
(%i2) mod(3^15, 5);
(%o2)                          2
(%i3) power_mod(2, -1, 5);
(%o3)                          3
(%i4) inv_mod(2, 5);
(%o4)                          3
</pre>
<p>F&uuml;r gro&szlig;e ganze Zahlen ist <code>power_mod</code> effizienter.  Der folgende 
Wert kann in keiner vern&uuml;nftigen Zeit mit <code>mod(a^n, m)</code> berechnet
werden.
</p>
<pre class="example">(%i1) power_mod(123456789, 123456789, 987654321);
(%o1)                       598987215
</pre></dd></dl>

<p><a name="primep"></a>
</p><dl>
<dt><u>Funktion:</u> <b>primep</b><i> (<var>n</var>)</i>
<a name="IDX1204"></a>
</dt>
<dd><p>F&uuml;hrt einen Primzahltest f&uuml;r das Argument <var>n</var> durch.  Liefert
<code>primep</code> das Ergebnis <code>false</code>, ist <var>n</var> keine Primzahl.  Ist das
Ergebnis <code>true</code>, ist <var>n</var> mit sehr gro&szlig;er Wahrscheinlichkeit eine 
Primzahl.
</p>
<p>F&uuml;r ganze Zahlen <var>n</var> kleiner als 341550071728321 wird eine deterministische
Variante des Miller-Rabin-Tests angewandt.  Hat in diesem Fall <code>primep</code> den Wert
<code>true</code>, dann ist <var>n</var> mit Sicherheit eine Primzahl.
</p>
<p>F&uuml;r ganze Zahlen <var>n</var> gr&ouml;&szlig;er 341550071728321 f&uuml;hrt <code>primep</code>
<code><a href="#primep_005fnumber_005fof_005ftests">primep_number_of_tests</a></code>
 Pseudo-Primzahl-Tests nach Miller-Rabin und 
einen Pseudo-Primzahl-Test nach Lucas durch.  Die Wahrscheinlichkeit, dass 
eine zusammen gesetzte Zahl <var>n</var> einen Miller-Rabin-Test besteht, ist kleiner
als 1/4.  Mit dem Standardwert 25 <code>primpe_number_of_tests</code> sinkt diese 
Wahrscheinlichkeit damit unter einen Wert von 10^-15.
</p></dd></dl>

<p><a name="primep_005fnumber_005fof_005ftests"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>primep_number_of_tests</b>
<a name="IDX1205"></a>
</dt>
<dd><p>Standardwert: 25
</p>

<p>Die Anzahl der Pseudo-Primzahl-Tests nach Miller-Rabin in der Funktion 
<code><a href="#primep">primep</a></code>.
.
</p></dd></dl>

<p><a name="prev_005fprime"></a>
</p><dl>
<dt><u>Funktion:</u> <b>prev_prime</b><i> (<var>n</var>)</i>
<a name="IDX1206"></a>
</dt>
<dd>
<p>Gibt die gr&ouml;&szlig;te Primzahl zur&uuml;ck, die kleiner als die Zahl <var>n</var> ist.
</p>
<pre class="example">(%i1) prev_prime(27);
(%o1)                       23
</pre></dd></dl>

<p><a name="qunit"></a>
</p><dl>
<dt><u>Funktion:</u> <b>qunit</b><i> (<var>n</var>)</i>
<a name="IDX1207"></a>
</dt>
<dd>
<p>Findet f&uuml;r das Argument <var>n</var> L&ouml;sungen der Pellschen Gleichung 
<code>a^2 - <var>n</var> b^2 = 1</code>.
</p>
<pre class="example">(%i1) qunit (17);
(%o1)                     sqrt(17) + 4
(%i2) expand (% * (sqrt(17) - 4));
(%o2)                           1
</pre></dd></dl>

<p><a name="totient"></a>
</p><dl>
<dt><u>Funktion:</u> <b>totient</b><i> (<var>n</var>)</i>
<a name="IDX1208"></a>
</dt>
<dd><p>Gibt die Anzahl der ganzen Zahlen zur&uuml;ck, die kleiner oder gleich <var>n</var>
und teilerfremd zu <var>n</var> sind.
</p></dd></dl>

<p><a name="zerobern"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>zerobern</b>
<a name="IDX1209"></a>
</dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>zerobern</code> den Wert <code>false</code>, werden von den Funktionen <code>bern</code>
diejenigen Bernoulli-Zahlen und von <code>euler</code> diejenigen Euler-Zahlen 
ausgeschlossen, die gleich Null sind.  Siehe <code><a href="#bern">bern</a></code>
 und <code><a href="#euler">euler</a></code>.
</p>
</dd></dl>

<p><a name="zeta"></a>
</p><dl>
<dt><u>Funktion:</u> <b>zeta</b><i> (<var>n</var>)</i>
<a name="IDX1210"></a>
</dt>
<dd>
<p>Die Riemannsche Zeta-Funktion f&uuml;r <var>s</var>, die wie folgt definiert ist:
</p>
<pre class="example">                 inf
                 ====
                 \     1
     zeta(s) =    &gt;    --
                 /      s
                 ====  k
                 k = 1
</pre>
<p>F&uuml;r negative ganze Zahlen <var>n</var>, Null und positive gerade ganze Zahlen 
wird <code>zeta</code> zu einem exakten Ergebnis vereinfacht.  
Damit diese Vereinfachung f&uuml;r positive ganze Zahlen ausgef&uuml;hrt wird, 
muss die Optionsvariable <code>zeta%pi</code> den Wert <code>true</code> haben.  
Siehe <code><a href="#zeta_0025pi">zeta%pi</a></code>.
. F&uuml;r einfache und beliebig genaue Gleitkommazahlen 
(Typ <code>bfloat</code>) hat <code>zeta</code> ein numerisches Ergebnis.  
F&uuml;r alle anderen Argumente einschlie&szlig;lich der komplexen und 
rationalen Zahlen gibt <code>zeta</code> eine Substantivform zur&uuml;ck.  Hat die 
Optionsvariable <code>zeta%pi</code> den Wert <code>false</code>, gibt <code>zeta</code> auch 
f&uuml;r gerade ganze Zahlen eine Substantivform zur&uuml;ck.
</p>

<p><code>zeta(1)</code> ist nicht definiert.  Maxima kennt jedoch die einseitigen
Grenzwerte <code>limit(zeta(x), x, 1, plus</code> und 
<code>limit(zeta(x), x, 1, minus</code>.
</p>

<p>Die Riemannsche Zeta-Funktion wird auf die Argumente von Listen, Matrizen und 
Gleichungen angewendet, wenn die Optionsvariable <code>distribute_over</code>
den Wert <code>true</code> hat.
</p>

<p>Siehe auch <code><a href="#bfzeta">bfzeta</a></code>
 und <code><a href="#zeta_0025pi">zeta%pi</a></code>.
</p>

<p>Beispiele:
</p>
<pre class="example">(%i1) zeta([-2,-1,0,0.5,2,3,1+%i]);
                                             2
            1     1                       %pi
(%o1) [0, - --, - -, - 1.460354508809586, ----, zeta(3), 
            12    2                        6
                                                    zeta(%i + 1)]
(%i2) limit(zeta(x),x,1,plus);
(%o2)                          inf
(%i3) limit(zeta(x),x,1,minus);
(%o3)                         minf
</pre></dd></dl>

<p><a name="zeta_0025pi"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>zeta%pi</b>
<a name="IDX1211"></a>
</dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>zeta%pi</code> den Wert <code>true</code>, vereinfacht die Funktion <code>zeta(n)</code>
f&uuml;r gerade ganzen Zahlen <var>n</var> zu einem Ergebnis, das proportional zu 
<code>%pi^n</code> ist.  Ansonsten ist das Ergebnis von <code>zeta</code> eine 
Substantivform f&uuml;r gerade ganze Zahlen.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) zeta%pi: true$
(%i2) zeta (4);
                                 4
                              %pi
(%o2)                         ----
                               90
(%i3) zeta%pi: false$
(%i4) zeta (4);
(%o4)                        zeta(4)
</pre></dd></dl>

<p><a name="zn_005flog"></a>
</p><dl>
<dt><u>Funktion:</u> <b>zn_log</b><i> (<var>a</var>, <var>g</var>, <var>n</var>) </i>
<a name="IDX1212"></a>
</dt>
<dt><u>Funktion:</u> <b>zn_log</b><i> (<var>a</var>, <var>g</var>, <var>n</var>, [[<var>p1</var>, <var>e1</var>], &hellip;, [<var>pk</var>, <var>ek</var>]])</i>
<a name="IDX1213"></a>
</dt>
<dd><p>Berechnet den diskreten Logarithmus.  Sei (Z/<var>n</var>Z)* eine zyklische Gruppe, 
<var>g</var> eine Primitivwurzel modulo <var>n</var> und <var>a</var> ein Element dieser Gruppe.
Dann berechnet <code>zn_log (a, g, n)</code> eine L&ouml;sung der Kongruenz 
<code>g^x = a mod n</code>.
</p>
<p>Der verwendete Algorithmus ben&ouml;tigt die Primfaktorzerlegung des Totienten von <var>n</var>. 
Da diese Berechnung ebenfalls zeitaufw&auml;ndig ist, kann es eventuell sinnvoll 
sein, die Primfaktoren des Totienten vorab zu berechnen und <code>zn_log</code> als 
viertes Argument zu &uuml;bergeben. Die Form muss dabei der R&uuml;ckgabe von 
<code>ifactors(totient(n))</code> mit der Standardeinstellung <code>false</code> der 
Optionsvariable <code>factors_only</code> entsprechen. 
</p>
<p>Als Algorithmus wird die Pohlig-Hellman-Reduktion und das Rho-Verfahren von 
Pollard f&uuml;r den diskreten Logarithmus verwendet. Die Laufzeit von <code>zn_log</code> 
h&auml;ngt im Wesentlichen von der Bitl&auml;nge des gr&ouml;&szlig;ten Primfaktors des 
Totienten von <var>n</var> ab. 
</p>
<p>Siehe auch <code><a href="#zn_005fprimroot">zn_primroot</a></code>
, <code><a href="#zn_005forder">zn_order</a></code>
, <code><a href="#ifactors">ifactors</a></code>
, <code><a href="#totient">totient</a></code>
.
</p>
<p>Beispiele:
</p>
<p><code>zn_log (a, g, n)</code> findet eine L&ouml;sung der Kongruenz <code>g^x = a mod n</code>.
</p>
<pre class="example">(%i1) n : 22$
(%i2) g : zn_primroot(n);
(%o2)                               7
(%i3) ord_7 : zn_order(7, n);
(%o3)                              10
(%i4) powers_7 : makelist(power_mod(g, x, n), x, 0, ord_7 - 1);
(%o4)              [1, 7, 5, 13, 3, 21, 15, 17, 9, 19]
(%i5) zn_log(21, g, n);
(%o5)                               5
(%i6) map(lambda([x], zn_log(x, g, n)), powers_7);
(%o6)                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</pre>
<p>Das optionale vierte Argument muss der R&uuml;ckgabe von <code>ifactors(totient(n))</code> 
entsprechen. 
Die Laufzeit h&auml;ngt im Wesentlichen von der Bitl&auml;nge des gr&ouml;&szlig;ten
Primfaktors des Totienten ab.
</p>
<pre class="example">(%i1) (p : 2^127-1, primep(p));
(%o1)                             true
(%i2) ifs : ifactors(p - 1)$
(%i3) g : zn_primroot(p, ifs);
(%o3)                              43
(%i4) a : power_mod(g, 1234567890, p)$
(%i5) zn_log(a, g, p, ifs);
(%o5)                          1234567890
(%i6) time(%o5);  
(%o6)                            [1.204]
(%i7) f_max : last(ifs);
(%o7)                       [77158673929, 1]
(%i8) slength( printf(false, &quot;~b&quot;, f_max[1]) );
(%o8)                              37
</pre></dd></dl>

<p><a name="zn_005forder"></a>
</p><dl>
<dt><u>Funktion:</u> <b>zn_order</b><i> (<var>x</var>, <var>n</var>) </i>
<a name="IDX1214"></a>
</dt>
<dt><u>Funktion:</u> <b>zn_order</b><i> (<var>x</var>, <var>n</var>, [[<var>p1</var>, <var>e1</var>], &hellip;, [<var>pk</var>, <var>ek</var>]])</i>
<a name="IDX1215"></a>
</dt>
<dd><p>Ist <var>x</var> eine Einheit in der endlichen Gruppe (Z/<var>n</var>Z)*, so berechnet 
<code>zn_order</code> die Ordnung dieses Elements.  Andernfalls gibt <code>zn_order</code> 
<code>false</code> zur&uuml;ck.  <var>x</var> ist eine Einheit modulo <var>n</var>, falls <var>x</var> 
teilerfremd zu <var>n</var> ist.
</p>
<p>Der verwendete Algorithmus ben&ouml;tigt die Primfaktorzerlegung des Totienten von <var>n</var>. 
Da diese Berechnung manchmal recht zeitaufw&auml;ndig ist, kann es eventuell sinnvoll 
sein, die Primfaktoren des Totienten vorab zu berechnen und <code>zn_order</code> als 
drittes Argument zu &uuml;bergeben. Die Form muss dabei der R&uuml;ckgabe von 
<code>ifactors(totient(n))</code> mit der Standardeinstellung <code>false</code> der 
Optionsvariable <code>factors_only</code> entsprechen. 
</p>
<p>Siehe auch <code><a href="#zn_005fprimroot">zn_primroot</a></code>
, <code><a href="#ifactors">ifactors</a></code>
, <code><a href="#totient">totient</a></code>
.
</p>
<p>Beispiele:
</p>
<p><code>zn_order</code> berechnet die Ordnung einer Einheit <var>x</var> aus (Z/<var>n</var>Z)*.
</p>
<pre class="example">(%i1) n : 22$
(%i2) g : zn_primroot(n);
(%o2)                               7
(%i3) units_22 : sublist(makelist(i,i,1,21), lambda([x], gcd(x, n) = 1));
(%o3)              [1, 3, 5, 7, 9, 13, 15, 17, 19, 21]
(%i4) (ord_7 : zn_order(7, n)) = totient(n);
(%o4)                            10 = 10
(%i5) powers_7 : makelist(power_mod(g,i,n), i,0,ord_7 - 1);
(%o5)              [1, 7, 5, 13, 3, 21, 15, 17, 9, 19]
(%i6) map(lambda([x], zn_order(x, n)), powers_7);
(%o6)              [1, 10, 5, 10, 5, 2, 5, 10, 5, 10]
(%i7) map(lambda([x], ord_7/gcd(x, ord_7)), makelist(i, i,0,ord_7 - 1));
(%o7)              [1, 10, 5, 10, 5, 2, 5, 10, 5, 10]
(%i8) totient(totient(n));
(%o8)                               4
</pre>
<p>Das optionale dritte Argument muss der R&uuml;ckgabe von <code>ifactors(totient(n))</code> 
entsprechen. 
</p>
<pre class="example">(%i1) (p : 2^142 + 217, primep(p));
(%o1)                             true
(%i2) ifs : ifactors( totient(p) )$
(%i3) g : zn_primroot(p, ifs);
(%o3)                               3
(%i4) is( (ord_3 : zn_order(g, p, ifs)) = totient(p) );
(%o4)                             true
(%i5) map(lambda([x], ord_3/zn_order(x, p, ifs)), makelist(i,i,2,15));
(%o5)        [22, 1, 44, 10, 5, 2, 22, 2, 8, 2, 1, 1, 20, 1]
</pre></dd></dl>

<p><a name="zn_005fprimroot"></a>
</p><dl>
<dt><u>Funktion:</u> <b>zn_primroot</b><i> (<var>n</var>) </i>
<a name="IDX1216"></a>
</dt>
<dt><u>Funktion:</u> <b>zn_primroot</b><i> (<var>n</var>, [[<var>p1</var>, <var>e1</var>], &hellip;, [<var>pk</var>, <var>ek</var>]])</i>
<a name="IDX1217"></a>
</dt>
<dd><p>Ist die multiplikative Gruppe (Z/<var>n</var>Z)* zyklisch, berechnet <code>zn_primroot</code> 
die kleinste Primitivwurzel modulo <var>n</var>.  Dies ist der Fall, wenn <var>n</var> gleich 
<code>2</code>, <code>4</code>, <code>p^k</code> oder <code>2*p^k</code> ist, wobei <code>p</code> prim und 
gr&ouml;sser <code>2</code> und <code>k</code> eine nat&uuml;rliche Zahl ist.  <code>zn_primroot</code> 
f&uuml;hrt einen entsprechenden Pr&auml;test durch, wenn die Optionsvariable 
<code><a href="#zn_005fprimroot_005fpretest">zn_primroot_pretest</a></code>
 (Standardwert: <code>false</code>) <code>true</code> gesetzt wurde.
In jedem Fall wird die Suche durch die obere Schranke <code><a href="#zn_005fprimroot_005flimit">zn_primroot_limit</a></code>
 begrenzt.
</p>
<p>Ist (Z/<var>n</var>Z)* nicht zyklisch oder kann bis <code>zn_primroot_limit</code> 
keine Primitivwurzel modulo <var>n</var> gefunden werden, gibt <code>zn_primroot</code> 
<code>false</code> zur&uuml;ck. 
</p>
<p>Der verwendete Algorithmus ben&ouml;tigt die Primfaktorzerlegung des Totienten von <var>n</var>. 
Diese Berechnung kann zeitaufw&auml;ndig sein und es kann daher eventuell sinnvoll 
sein, die Primfaktoren des Totienten vorab zu berechnen und <code>zn_primroot</code> 
als zus&auml;tzliches Argument zu &uuml;bergeben. Die Form muss dabei der R&uuml;ckgabe  
von <code>ifactors(totient(n))</code> mit der Standardeinstellung <code>false</code> der 
Optionsvariable <code>factors_only</code> entsprechen. 
</p>
<p>Siehe auch <code><a href="#zn_005fprimroot_005fp">zn_primroot_p</a></code>
, <code><a href="#zn_005forder">zn_order</a></code>
, <code><a href="#ifactors">ifactors</a></code>
, <code><a href="#totient">totient</a></code>
.
</p>
<p>Beispiele:
</p>
<p><code>zn_primroot</code> berechnet die kleinste Primitivwurzel modulo <var>n</var> oder gibt 
<code>false</code> zur&uuml;ck.
</p>
<pre class="example">(%i1) n : 14$
(%i2) g : zn_primroot(n);
(%o2)                               3
(%i3) zn_order(g, n) = totient(n);
(%o3)                             6 = 6
(%i4) n : 15$
(%i5) zn_primroot(n);
(%o5)                             false
</pre>
<p>Das optionale zweite Argument muss der R&uuml;ckgabe von <code>ifactors(totient(n))</code> 
entsprechen. 
</p>
<pre class="example">(%i1) (p : 2^142 + 217, primep(p));
(%o1)                             true
(%i2) ifs : ifactors( totient(p) )$
(%i3) g : zn_primroot(p, ifs);
(%o3)                               3
(%i4) [time(%o2), time(%o3)];
(%o4)                    [[15.556972], [0.004]]
(%i5) is(zn_order(g, p, ifs) = p - 1);
(%o5)                             true
(%i6) n : 2^142 + 216$
(%i7) ifs : ifactors(totient(n))$
(%i8) zn_primroot(n, ifs), 
      zn_primroot_limit : 200, zn_primroot_verbose : true;
`zn_primroot' stopped at zn_primroot_limit = 200
(%o8)                             false
</pre></dd></dl>

<p><a name="zn_005fprimroot_005flimit"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>zn_primroot_limit</b>
<a name="IDX1218"></a>
</dt>
<dd><p>Standardwert: <code>1000</code> 
</p>
<p>Definiert die obere Schranke f&uuml;r die Suche von <code><a href="#zn_005fprimroot">zn_primroot</a></code>.
 nach einer 
Primitivwurzel.  Wurde die Optionsvariable <code><a href="#zn_005fprimroot_005fverbose">zn_primroot_verbose</a></code>.
</p>
<p>(Standardwert: <code>false</code>) <code>true</code> gesetzt, wird beim Erreichen von 
<code>zn_primroot_limit</code> ein entsprechender Hinweis ausgegeben.
</p></dd></dl>

<p><a name="zn_005fprimroot_005fp"></a>
</p><dl>
<dt><u>Funktion:</u> <b>zn_primroot_p</b><i> (<var>x</var>, <var>n</var>) </i>
<a name="IDX1219"></a>
</dt>
<dt><u>Funktion:</u> <b>zn_primroot_p</b><i> (<var>x</var>, <var>n</var>, [[<var>p1</var>, <var>e1</var>], &hellip;, [<var>pk</var>, <var>ek</var>]])</i>
<a name="IDX1220"></a>
</dt>
<dd><p>Testet, ob <var>x</var> eine Primitivwurzel in der multiplikativen Gruppe (Z/<var>n</var>Z)* 
ist. 
</p>
<p>Der verwendete Algorithmus ben&ouml;tigt die Primfaktorzerlegung des Totienten von  
<var>n</var>.  Wird dieser Test nacheinander auf mehrere Zahlen angewandt, 
kann es sinnvoll sein, die Primfaktoren des Totienten vorab zu berechnen 
und <code>zn_primroot_p</code> als zus&auml;tzliches drittes Argument zu &uuml;bergeben. 
Die Form muss dabei der R&uuml;ckgabe von <code>ifactors(totient(n))</code> mit der 
Standardeinstellung <code>false</code> der Optionsvariable <code>factors_only</code> 
entsprechen. 
</p>
<p>Siehe auch <code><a href="#zn_005fprimroot">zn_primroot</a></code>
, <code><a href="#zn_005forder">zn_order</a></code>
, <code><a href="#ifactors">ifactors</a></code>
, <code><a href="#totient">totient</a></code>
.
</p>
<p>Beispiele:
</p>
<p><code>zn_primroot_p</code> als Pr&auml;dikatfunktion.
</p>
<pre class="example">(%i1) n : 14$
(%i2) units_14 : sublist(makelist(i,i,1,13), lambda([i], gcd(i, n) = 1));
(%o2)                     [1, 3, 5, 9, 11, 13]
(%i3) zn_primroot_p(13, n);
(%o3)                            false
(%i4) sublist(units_14, lambda([x], zn_primroot_p(x, n)));
(%o4)                            [3, 5]
(%i5) map(lambda([x], zn_order(x, n)), units_14);
(%o5)                      [1, 6, 6, 3, 3, 2]
</pre>
<p>Das optionale dritte Argument muss der R&uuml;ckgabe von <code>ifactors(totient(n))</code> 
entsprechen. 
</p>
<pre class="example">(%i1) (p : 2^142 + 217, primep(p));
(%o1)                             true
(%i2) ifs : ifactors( totient(p) )$
(%i3) sublist(makelist(i,i,1,50), lambda([x], zn_primroot_p(x, p, ifs)));
(%o3)      [3, 12, 13, 15, 21, 24, 26, 27, 29, 33, 38, 42, 48]
(%i4) [time(%o2), time(%o3)];
(%o4)                   [[7.748484], [0.036002]]
</pre></dd></dl>

<p><a name="zn_005fprimroot_005fpretest"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>zn_primroot_pretest</b>
<a name="IDX1221"></a>
</dt>
<dd><p>Standardwert: <code>false</code> 
</p>
<p>Eine multiplikative Gruppe (Z/<code>n</code>Z)* ist zyklisch, wenn <code>n</code> gleich 
<code>2</code>, <code>4</code>, <code>p^k</code> oder <code>2*p^k</code> ist, wobei <code>p</code> prim und 
gr&ouml;sser <code>2</code> und <code>k</code> eine nat&uuml;rliche Zahl ist. 
</p>
<p><code>zn_primroot_pretest</code> entscheidet dar&uuml;ber, ob <code><a href="#zn_005fprimroot">zn_primroot</a></code>.
 vor 
der Berechnung der kleinsten Primitivwurzel in (Z/<code>n</code>Z)* &uuml;berpr&uuml;ft, 
ob auf <code>n</code> &uuml;berhaupt einer der oben genannten F&auml;lle zutrifft.  Nur wenn  
<code>zn_primroot_pretest</code> <code>true</code> ist, wird dieser Pr&auml;test ausgef&uuml;hrt.
</p></dd></dl>

<p><a name="zn_005fprimroot_005fverbose"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>zn_primroot_verbose</b>
<a name="IDX1222"></a>
</dt>
<dd><p>Standardwert: <code>false</code> 
</p>
<p>Entscheidet, ob <code><a href="#zn_005fprimroot">zn_primroot</a></code>.
 beim Erreichen von <code><a href="#zn_005fprimroot_005flimit">zn_primroot_limit</a></code>.
</p>
<p>einen Hinweis ausgibt.
</p></dd></dl>



<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC160" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_22.html#SEC162" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC409" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Robert</em> on <em>Dezember, 10 2012</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
