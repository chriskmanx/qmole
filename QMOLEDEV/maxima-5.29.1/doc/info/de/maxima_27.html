<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on Dezember, 10 2012 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Maxima Manual: 27. Programmierung</title>

<meta name="description" content="Maxima Manual: 27. Programmierung">
<meta name="keywords" content="Maxima Manual: 27. Programmierung">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body
{
    color: black;
    background: white; 
    margin-left: 8%;
    margin-right: 13%;
}

h1
{
    margin-left: +8%;
    font-size: 150%;
    font-family: sans-serif
}

h2
{
    font-size: 125%;
    font-family: sans-serif
}

h3
{
    font-size: 100%;
    font-family: sans-serif
}

h2,h3,h4,h5,h6 { margin-left: +4%; }

div.textbox
{
    border: solid;
    border-width: thin;
    /* width: 100%; */
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em
}

div.titlebox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
    background: rgb(200,255,255);
    font-family: sans-serif
}

div.synopsisbox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
     background: rgb(255,220,255);
    /*background: rgb(200,255,255); */
    /* font-family: fixed */
}

pre.example
{
    border: 1px solid gray;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 1em;
    padding-right: 1em;
    /* background: rgb(247,242,180); */ /* kind of sandy */
    /* background: rgb(200,255,255); */ /* sky blue */
    background-color: #F1F5F9; /* light blue-gray */
    /* font-family: "Lucida Console", monospace */
}

div.spacerbox
{
    border: none;
    padding-top: 2em;
    padding-bottom: 2em
}

div.image
{
    margin: 0;
    padding: 1em;
    text-align: center;
}

div.categorybox
{
    border: 1px solid gray;
    padding-top: 0px;
    padding-bottom: 0px;
    padding-left: 1em;
    padding-right: 1em;
    background: rgb(247,242,220);
}


-->
</style>

<link rel="icon" href="http://maxima.sourceforge.net/favicon.ico"/>
</head>

<body lang="de" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Programmierung"></a>
<a name="SEC196"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_26.html#SEC195" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC197" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC192" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC204" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC409" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 27. Programmierung </h1>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC197">27.1 Lisp und Maxima</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC202">27.2 Einf&uuml;hrung in die Programmierung</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC203">27.3 Funktionen und Variablen der Programmierung</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Lisp-und-Maxima"></a>
<a name="SEC197"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC196" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC202" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC196" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC196" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC204" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC409" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 27.1 Lisp und Maxima </h2>

<a name="SEC198"></a>
<h3 class="subheading"> Lisp- und Maxima-Bezeichner </h3>

<p>Maxima ist in Lisp programmiert.  Es ist einfach, Lisp-Funktionen und
Lisp-Variable in Maxima zu verwenden.  Umgekehrt k&ouml;nnen Maxima-Funktionen und
Maxima-Variablen in Lisp verwendet werden.  Ein Lisp-Symbol, das mit einem 
Dollarzeichen <code>$</code> beginnt, entspricht einem Maxima-Symbol ohne einem 
Dollarzeichen.  Umgekehrt entspricht einem Maxima-Symbol, das mit einem 
Fragezeichen <code>?</code> beginnt, ein Lisp-Symbol ohne das Fragezeichen.
Zum Beispiel entspricht dem Maxima-Symbol <code>foo</code> das Lisp-Symbol 
<code>$foo</code> und dem Maxima-Symbol <code>?foo</code> entspricht das Lisp-Symbol
<code>foo</code>.
</p>
<p>Speziellen Zeichen wie einem Trennstrich <code>-</code> oder einem Stern <code>*</code> in
Lisp-Symbolen muss ein Backslash <code>\</code> vorangestellt werden, um diese
in Maxima zu verwenden.  Zum Beispiel entspricht dem Lisp-Symbol 
<code>*foo-bar*</code> das Maxima-Symbol <code>?\*foo\-bar\*</code>.
</p>
<p>Im Gegensatz zu Lisp unterscheidet Maxima Gro&szlig;- und Kleinschreibung.  Es 
gibt einige Regeln, die eine &Uuml;bersetzung von Namen zwischen Lisp und Maxima 
betreffen:
</p>
<ol>
<li>
Ein Lisp-Bezeichner, der nicht von senkrechten Strichen eingeschlossen ist,
entspricht einem klein geschriebenen Maxima-Bezeichner.  Die Schreibweise des
Lisp-Bezeichners wird dabei ignoriert.  Zum Beispiel entspricht den folgenden
Lisp-Bezeichnern <code>$foo</code>, <code>$FOO</code> und <code>$Foo</code> jeweils der
Maxima-Bezeichner <code>foo</code>.

</li><li>
Ein Lisp-Bezeichner, der vollst&auml;ndig gro&szlig; oder klein geschrieben ist und 
von senkrechten Strichen eingeschlossen wird, entspricht einem Maxima-Bezeichner
in der umgekehrten Schreibweise.  Ein klein geschriebener Lisp-Bezeichner wird 
also zu einem gro&szlig;geschriebenen Maxima-Bezeichner und umgekehrt.  Zum 
Beispiel entsprechen den Lisp-Bezeichnern <code>|$FOO|</code> und <code>|$foo|</code> die
Maxima-Bezeichner <code>foo</code> und <code>FOO</code>.

</li><li>
Ein Lisp-Bezeichner in gemischter Schreibweise, der von senkrechten Strichen
eingeschlossen ist, entspricht einem Maxima-Bezeichner in der gleichen
Schreibweise.  Zum Beispiel entspricht dem Lisp-Bezeichner <code>|$Foo|</code> der
Maxima-Bezeichner <code>Foo</code>.
</li></ol>

<p>F&uuml;r die Syntax von Maxima-Bezeichnern siehe auch <a href="maxima_6.html#SEC42">Bezeichner</a>.
</p>
<a name="SEC199"></a>
<h3 class="subheading"> Ausf&uuml;hrung von Lisp-Code in Maxima </h3>

<p>Lisp-Code kann mit dem Unterbrechungskommando <code>:lisp</code> von einer
Maxima-Kommandozeile ausgef&uuml;hrt werden.  Siehe
<a href="maxima_29.html#SEC210">Debugger-Kommandos</a> f&uuml;r weitere Unterbrechungskommandos und deren
Beschreibung.
</p>
<p>Beispiele:
</p>
<p>Addiere die Werte der Maxima-Variablen <code>x</code> und <code>y</code> mit dem 
Lisp-Operator <code>+</code>.
</p>
<pre class="example">(%i1) x:10$ y:5$
(%i3) :lisp (+ $x $y)
15
</pre>
<p>Addiere die Symbole <code>a</code> und <code>b</code> mit der Lisp-Funktion <code>ADD</code>.  Das
Ergebnis wird der Variablen <code>$RES</code> zugewiesen.  Die Variable hat in Maxima
den Namen <code>res</code>.
</p>
<pre class="example">(%i3) :lisp (setq $res (add '$a '$b))
((MPLUS SIMP) $A $B)
(%i3) res;
(%o3)                         b + a
</pre>
<p>Das <code>:lisp</code>-Kommando ist n&uuml;tzlich, um zum Beispiel Lisp-Eigenschaften
von Maxima-Symbolen anzuzeigen, globale Lisp-Variablen wie
<code>*PRINT-CIRCLE*</code> zu setzen oder wie im letzten Beispiel die interne
Form von Maxima-Ausdr&uuml;cken anzuzeigen.
</p>
<pre class="example">(%i4) :lisp (symbol-plist 'mabs)
(TEXSYM ((\left| ) \right| ) TEX TEX-MATCHFIX REAL-VALUED T
        MAPS-INTEGERS-TO-INTEGERS T DIMENSION DIM-MABS TRANSLATE
        #&lt;FUNCTION (LAMBDA #) {972D045}&gt; FLOATPROG MABSBIGFLOAT INTEGRAL
        ((X) #&lt;FUNCTION ABS-INTEGRAL&gt;) OPERATORS SIMPABS DISTRIBUTE_OVER
        (MLIST $MATRIX MEQUAL) NOUN $ABS REVERSEALIAS $ABS GRAD
        ((X) ((MTIMES) X ((MEXPT) ((MABS) X) -1))))

(%i4) :lisp (setq *print-circle* nil)
NIL

(%i4) 'integrate(t*sin(t), t);
                          /
                          [
(%o4)                     I t sin(t) dt
                          ]
                          /
(%i5) :lisp $%
((%INTEGRATE SIMP) ((MTIMES SIMP) $T ((%SIN SIMP) $T)) $T)
</pre>
<p>Das Kommando <code>:lisp</code> kann in einer Kommandozeile und in Dateien verwendet
werden, die mit den Funktionen <code><a href="maxima_13.html#batch">batch</a></code>
 oder <code><a href="maxima_3.html#demo">demo</a></code>
 geladen werden.
Dagegen kann das Kommando <code>:lisp</code> nicht in Dateien verwendet werden, die 
mit den Funktionen <code><a href="maxima_13.html#load">load</a></code>,
 <code><a href="maxima_13.html#batchload">batchload</a></code>,

<code><a href="maxima_28.html#translate_005ffile">translate_file</a></code>
 oder <code><a href="maxima_28.html#compile_005ffile">compile_file</a></code>
 geladen werden.
</p>
<a name="SEC200"></a>
<h3 class="subheading"> Ausf&uuml;hrung von Maxima-Code in Lisp </h3>

<p>Das Lisp-Makro <code>#$</code> erlaubt die Nutzung von Maxima-Ausdr&uuml;cken in 
Lisp-Code.  <code>#$<var>expr</var>$</code> wird zu einem Lisp-Ausdruck expandiert, der
dem Maxima-Ausdruck <var>expr</var> entspricht.
</p>
<p>Beispiele:
</p>
<p>Die beiden folgenden Beispiele zeigen die Zuweisung an eine Variable <code>var</code>.
Im ersten Beispiel werden Lisp- und Maxima-Code gemischt.  F&uuml;r die Zuweisung
an die Variable wird die Lisp-Funktion <code>MSETQ</code> aufgerufen.  Das Makro
<code>#$</code> transformiert den Maxima Ausdruck <code>sin(x) + a^2</code> in die Lisp-Form
<code>((MPLUS SIMP) ((MEXPT SIMP) $A 2) ((%SIN SIMP) $X))</code>.  Dies entspricht
dem im zweiten Beispiel gezeigten Maxima-Kommando.
</p>
<pre class="example">(%i1) :lisp (msetq $var #$sin(x)+a^2$)
((MPLUS SIMP) ((MEXPT SIMP) $A 2) ((%SIN SIMP) $X))

(%i1) var: sin(x)+a^2;
                                     2
(%o1)                      sin(x) + a
</pre>
<p>In diesem Beispiel wird zun&auml;chst ein Maxima-Ausdruck der Variablen <code>$VAR</code>
zugewiesen und dann mit der Lisp-Funktion <code>DISPLA</code> ausgegeben.
</p>
<pre class="example">(%i1) :lisp (setq $var #$'integrate(f(x), x)$)
((%INTEGRATE SIMP) (($F SIMP) $X) $X)
(%i1) :lisp (displa $var)
/
[
I f(x) dx
]
/
NIL
</pre>
<p>Maxima-Funktionen sind keine Lisp-Funktionen.  Um eine Maxima-Funktion in 
Lisp-Code aufzurufen, kann die Lisp-Funktion <code>MFUNCALL</code> aufgerufen werden.
</p>
<pre class="example">(%i1) f(x,y) := x^2 + sin(y)$
(%i2) :lisp (mfuncall '$f '$a 10)
((MPLUS SIMP) ((%SIN SIMP) 10) ((MEXPT SIMP) $A 2))
</pre>
<a name="SEC201"></a>
<h3 class="subheading"> &Ouml;ffnen einer Lisp-Sitzung </h3>

<p>Mit dem Kommando <code>to_lisp()</code> kann von einer Maxima-Kommandozeile eine
Lisp-Sitzung ge&ouml;ffnet werden.  Mit dem Kommando <code>(TO-MAXIMA)</code> wird
die Lisp-Sitzung beendet und nach Maxima zur&uuml;ckgekehrt.  Siehe auch
<code><a href="maxima_4.html#to_005flisp">to_lisp</a></code>
 f&uuml;r ein Beispiel.
</p>
<p>Die folgenden Lisp-Funktionen k&ouml;nnen in Maxima nicht verwendet werden:
</p>
<p><code>complement</code>,
<code>continue</code>,
<code>/</code>,
<code>float</code>,
<code>functionp</code>,
<code>array</code>,
<code>exp</code>,
<code>listen</code>,
<code>signum</code>,
<code>atan</code>,
<code>asin</code>,
<code>acos</code>,
<code>asinh</code>,
<code>acosh</code>,
<code>atanh</code>,
<code>tanh</code>,
<code>cosh</code>,
<code>sinh</code>,
<code>tan</code>,
<code>break</code>,
und <code>gcd</code>.
</p>
<hr size="6">
<a name="Einf_00fchrung-in-die-Programmierung"></a>
<a name="SEC202"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC197" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC203" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC196" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC196" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC204" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC409" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 27.2 Einf&uuml;hrung in die Programmierung </h2>

<p>In Maxima k&ouml;nnen Programme geschrieben werden.  Alle Maxima-Funktionen und 
Maxima-Variablen k&ouml;nnen in Programmen verwendet werden.  Maxima hat einen
&Uuml;bersetzer, um Maxima-Programme in Lisp-Programme zu &uuml;bersetzen, und einen
Compiler, um die &uuml;bersetzten Programme zu kompilieren.  Siehe dazu das Kapitel
<a href="maxima_28.html#SEC204">&Uuml;bersetzer</a>.
</p>

<p>Maxima-Programme bestehen aus Funktionen und Makros, die im Kapitel 
<a href="maxima_25.html#SEC186">Funktionsdefinitionen</a>
 beschrieben sind.  Die Funktionen werden aus 
Ausdr&uuml;cken der Form <code>(expr_1, expr_2, ..., expr_n)</code> oder
<code><a href="#block">block</a></code>
-Anweisungen zusammengesetzt.  Mit der Anweisung <code><a href="#local">local</a></code>
 werden
Variablen definiert, deren Werte und Eigenschaften lokal zu einem Block sind.
</p>
<p>Konditionale Verzweigen werden mit der Anweisung <code><a href="#if">if</a></code>
 definiert und haben 
die Form <code>if ... then ... else</code>.
</p>
<p>Maxima kennt die sehr allgemeine Anweisung <code><a href="#for">for</a></code>,
 um Schleifen zu
programmieren.  Schl&uuml;sselworte f&uuml;r die Programmierung von Schleifen sind
<code><a href="#while">while</a></code>,
 <code><a href="#unless">unless</a></code>,
 <code><a href="#do">do</a></code>
 sowie <code>thru</code>, <code>step</code>,
<code>in</code>.
</p>
<p>Mit der Sprunganweisung <code><a href="#return">return</a></code>
 kann ein Block verlassen werden und mit
der Sprunganweisung <code><a href="#go">go</a></code>
 wird innerhalb eines Blockes zu eine Marke
verzweigt.  Nicht-lokale R&uuml;ckspr&uuml;nge aus Funktionen werden mit den 
Anweisungen <code><a href="#catch">catch</a></code>
 und <code><a href="#throw">throw</a></code>
 programmiert.
</p>
<p>Die Anweisung <code><a href="#errcatch">errcatch</a></code>
 f&auml;ngt Fehler ab, so dass die Ausf&uuml;hrung eines
Programms nicht abgebrochen wird.  Mit der Anweisungen <code><a href="#error">error</a></code>
 und
<code><a href="#break">break</a></code>
 wird ein Programm abgebrochen.  Im ersten Fall kann eine
Fehlermelung ausgegeben werden und das Programm kehrt zur Maxima-Kommandozeile
zur&uuml;ck.  Mit <code>break</code> wird der Maxima-Debugger gestartet.
</p>
<p>Maxima kennt die folgenden Anweisungen und Variablen um Programme zu definieren:
</p>
<pre class="verbatim">   backtrace    block        break
   catch        do           eval_when
   errcatch     error        error_size
   error_syms   errormsg     for
   go           if           local
   return       throw        unless
   while
</pre>
<hr size="6">
<a name="Funktionen-und-Variablen-der-Programmierung"></a>
<a name="SEC203"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC202" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC204" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC196" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC196" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC204" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC409" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 27.3 Funktionen und Variablen der Programmierung </h2>

<p><a name="backtrace"></a>
</p><dl>
<dt><u>Funktion:</u> <b>backtrace</b><i> ()</i>
<a name="IDX1437"></a>
</dt>
<dt><u>Funktion:</u> <b>backtrace</b><i> (<var>n</var>)</i>
<a name="IDX1438"></a>
</dt>
<dd><p>Gibt den Aufruf-Stack der Funktion zur&uuml;ck, die ausgef&uuml;hrt wird.
</p>
<p>Das Kommando <code>backtrace()</code> zeigt den gesamten Stack.
<code>backtrace(<var>n</var>)</code> zeigt die letzten <var>n</var> Funktionen
einschlie&szlig;lich der Funktion, die ausgef&uuml;hrt wird.
</p>
<p><code>backtrace</code> kann in einer Batch-Datei, die zum Beispiel mit der Funktion
<code><a href="maxima_13.html#batch">batch</a></code>
 geladen wird, in einer Funktion oder von einer Kommandozeile
aufgerufen werden.
</p>
<p>Beispiele:
</p>
<p><code>backtrace()</code> gibt den gesamten Stack aus.
</p>
<pre class="example">(%i1) h(x) := g(x/7)$
(%i2) g(x) := f(x-11)$
(%i3) f(x) := e(x^2)$
(%i4) e(x) := (backtrace(), 2*x + 13)$
(%i5) h(10);
#0: e(x=4489/49)
#1: f(x=-67/7)
#2: g(x=10/7)
#3: h(x=10)
                              9615
(%o5)                         ----
                               49
</pre>
<p><code>backtrace(<var>n</var>)</code> gibt die letzten <var>n</var> Funktionen aus.
</p>
<pre class="example">(%i1) h(x) := (backtrace(1), g(x/7))$
(%i2) g(x) := (backtrace(1), f(x-11))$
(%i3) f(x) := (backtrace(1), e(x^2))$
(%i4) e(x) := (backtrace(1), 2*x + 13)$
(%i5) h(10);
#0: h(x=10)
#0: g(x=10/7)
#0: f(x=-67/7)
#0: e(x=4489/49)
                              9615
(%o5)                         ----
                               49
</pre></dd></dl>

<p><a name="block"></a>
</p><dl>
<dt><u>Funktion:</u> <b>block</b><i> ([<var>v_1</var>, &hellip;, <var>v_m</var>], <var>expr_1</var>, &hellip;, <var>expr_n</var>)</i>
<a name="IDX1439"></a>
</dt>
<dt><u>Funktion:</u> <b>block</b><i> (<var>expr_1</var>, &hellip;, <var>expr_n</var>)</i>
<a name="IDX1440"></a>
</dt>
<dd><p>Mit der Anweisung <code>block</code> werden Ausdr&uuml;cke in einer lokalen Umgebung
zusammengefasst.  <code>block</code> wertet die Argument <var>expr_1</var>, <var>expr_2</var>,
&hellip;, <var>expr_n</var> nacheinander aus und gibt das Ergebnis des letzten
ausgewerteten Ausdrucks zur&uuml;ck.  Die Liste <code>[v_1, ..., v_m]</code> am Anfang
der <code>block</code>-Anweisung bezeichnet Variablen, die innerhalb der
<code>block</code>-Anweisung lokal sind.  Alle anderen Variablen, die in einem Block
verwendet werden, beziehen sich auf globale Variablen, die au√üerhalb des Block
definiert sind.  Dies kann ein weiterer Block oder die globale Maxima-Umgebung
sein.  <code>block</code> sichert die aktuellen Werte der Variablen <var>v_1</var>, 
&hellip;, <var>v_m</var>.  Wird <code>block</code> verlassen, werden diese Werte
wiederhergestellt.
</p>
<p>Die Deklaration <code>local(<var>v_1</var>, ..., <var>v_m</var>)</code> innerhalb der
<code>block</code>-Anweisung sichert nicht nur die Werte, sondern auch die
Eigenschaften der Variablen wie sie zum Beispiel mit den Funktionen
<code><a href="maxima_11.html#declare">declare</a></code>
 oder <code><a href="maxima_16.html#depends">depends</a></code>
 definiert werden.  Erhalten die mit
<code>local</code> deklarierten Variablen innerhalb der <code>block</code>-Anweisung
Eigenschaften, wirken sich diese nur lokal aus.  Beim Verlassen der
<code>block</code>-Anweisung werden die globalen Eigenschaften wiederhergestellt.
Siehe auch <code><a href="#local">local</a></code>.
</p>

<p>Die <code>block</code>-Anweisung kann verschachtelt werden.  Jeder Block kann
eigene lokale Variablen definieren.  Diese sind global zu jedem anderen Block
der sich innerhalb des Blockes befindet.  Ein Variable die nicht als lokal
definiert ist, hat den globalen Wert eines umgebenden Blocks oder den Wert der
globalen Maxima-Umgebung.
</p>
<p>Der R&uuml;ckgabewert eines Blocks ist der Wert des letzten Ausdrucks oder der 
Wert, der mit den <code>return</code>-Anweisung zur&uuml;ckgegeben wird.  Mit der 
<code>go</code>-Anweisung kann innerhalb eines Blocks zu einer Marke gesprungen 
werden.  Weiterhin kann mit der <code><a href="#throw">throw</a></code>
-Anweisung ein nicht-lokaler
R&uuml;cksprung zu einer entsprechenden <code><a href="#catch">catch</a></code>
-Anweisung erfolgen.
</p>
<p>Bl&ouml;cke erscheinen typischerweise auf der rechten Seite einer 
Funktionsdefinitionen.  Sie k&ouml;nnen aber auch an anderen Stellen verwendet
werden.
</p>
<p>Beispiel:
</p>
<p>Das Beispiel zeigt eine einfache Implementation des Newton-Algorithmus.  Der
Block definiert die lokalen Variablen <code>xn</code>, <code>s</code> und <var>numer</var>.
<code><a href="maxima_5.html#numer">numer</a></code>
 ist eine Optionsvariable, die im Block einen lokalen Wert erh&auml;lt.
Im Block ist das Tag <code>loop</code> definiert.  Zu diesem Tag wird mit der
Anweisung <code>go(loop)</code> gesprungen.  Der Block und damit die Funktion wird
mit der Anweisung <code>return(xn)</code> verlassen.  Der Wert der Variablen <code>xn</code>
ist das Ergebnis der Funktion <code>newton</code>.
</p>
<pre class="example">newton(exp,var,x0,eps):=
   block([xn,s,numer],
      numer:true,
      s:diff(exp,var),
      xn:x0,
   loop,
      if abs(subst(xn,var,exp))&lt;eps then return(xn),
      xn:xn-subst(xn,var,exp)/subst(xn,var,s),
      go(loop) )$
</pre></dd></dl>

<p><a name="break"></a>
</p><dl>
<dt><u>Funktion:</u> <b>break</b><i> (<var>expr_1</var>, &hellip;, <var>expr_n</var>)</i>
<a name="IDX1441"></a>
</dt>
<dd><p>Wertet die Ausdr&uuml;cke <var>expr_1</var>, &hellip;, <var>expr_n</var> aus, zeigt die 
Ergebnisse an und f&uuml;hrt dann eine Unterbrechung aus.  Mit dem Kommando 
<code>exit;</code> wird Maxima fortgesetzt.  Siehe das Kapitel
</p>
<p>Beispiel:
</p>
<p>Der Variablen <code>a</code> wird der Wert 2 zugewiesen.  Dann wird die Unterbrechung
ausgef&uuml;hrt.  Mit dem Kommando <code>exit;</code> wird Maxima fortgesetzt.
</p>
<pre class="example">(%i1) break(a:2);
2 

Entering a Maxima break point. Type 'exit;' to resume.
_a;
2
_exit;
(%o1)                           2
</pre></dd></dl>

<p><a name="catch"></a>
</p><dl>
<dt><u>Funktion:</u> <b>catch</b><i> (<var>expr_1</var>, &hellip;, <var>expr_n</var>)</i>
<a name="IDX1442"></a>
</dt>
<dd>
<p>Wertet die Ausdr&uuml;cke <var>expr_1</var>, &hellip;, <var>expr_n</var> nacheinander aus.
Wertet irgendeiner der Ausdr&uuml;cke zu <code>throw(arg)</code> aus, dann ist das 
Ergebnis der Wert von <code>throw(arg)</code> und es werden keine weiteren Ausdr&uuml;cke
ausgewertet.  Diese nicht-lokale R&uuml;ckgabe kehrt zu dem n&auml;chsten <code>catch</code>
in einer beliebigen Verschachtelungstiefe zur&uuml;ck.  Wird kein <code>catch</code> 
gefunden gibt Maxima eine Fehlermeldung aus.
</p>

<p>F&uuml;hrt die Auswertung der Argumente nicht zu einem <code>throw</code>, dann ist
die R&uuml;ckgabe das Ergebnis des letzten Ausdrucks <code>expr_n</code>.
</p>
<p>Beispiel:
</p>

<p>Die Funktion <code>g</code> gibt eine Liste mit den Werten des Lambda-Ausdrucks 
zur&uuml;ck.  Tritt ein negativer Wert auf, bricht die Funktion ab, in diesem 
Beispiel mit <code>throw(-3)</code>.
</p>
<pre class="example">(%i1) lambda ([x], if x &lt; 0 then throw(x) else f(x))$
(%i2) g(l) := catch (map (''%, l))$
(%i3) g ([1, 2, 3, 7]);
(%o3)               [f(1), f(2), f(3), f(7)]
(%i4) g ([1, 2, -3, 7]);
(%o4)                          - 3
</pre></dd></dl>

<p><a name="do"></a>
</p><dl>
<dt><u>Spezieller Operator:</u> <b>do</b>
<a name="IDX1443"></a>
</dt>
<dd>
<p>Die <code>do</code>-Anweisung erlaubt die Definition von Iterationen.  Aufgrund der
gro&szlig;en Allgemeinheit der <code>do</code>-Anweisung folgt die Beschreibung in zwei
Teilen.  Zun&auml;chst werden die bekannteren Formen beschrieben, wie sie auch in 
anderen Programmiersprachen vorhanden sind.  Dann folgen die weiteren 
M&ouml;glichkeiten.
</p>

<p>Es gibt drei Varianten der <code>do</code>-Anweisung, die sich nur durch die
Abbruchbedingung voneinander unterscheiden.  Diese sind:
</p>
<pre class="example"><b>for</b> <var>variable</var>: <var>initial_value</var> <b>step</b> <var>increment</var>
      <b>thru</b> <var>limit</var> <b>do</b> <var>body</var>

<b>for</b> <var>variable</var>: <var>initial_value</var> <b>step</b> <var>increment</var>
      <b>while</b> <var>condition</var> <b>do</b> <var>body</var>

<b>for</b> <var>variable</var>: <var>initial_value</var> <b>step</b> <var>increment</var>
      <b>unless</b> <var>condition</var> <b>do</b> <var>body</var>
</pre>
   

<p><var>initial_value</var>, <var>increment</var>, <var>limit</var> und <var>body</var> k&ouml;nnen 
beliebige Ausdr&uuml;cke sein.  Ist das Inkrement 1, kann <code>step</code> entfallen.
</p>

<p>Die Ausf&uuml;hrung der <code>do</code>-Anweisung beginnt mit der Zuweisung von
<code>initial_value</code> an die Kontrollvariable <var>variable</var>.  Dann folgen die 
Schritte: (1) Hat die Kontrollvariable den Wert einer <code>thru</code>-Anweisung
&uuml;berschritten oder hat die Bedingung einer <code>unless</code>-Anweisung den Wert
<code>true</code> oder hat die Bedingung einer <code>while</code>-Anweisung den Wert
<code>false</code>, dann endet die Ausf&uuml;hrung der <code>do</code>-Anweisung.  (2) Die
Ausdr&uuml;cke in <var>body</var> werden ausgewertet.  (3) Das Inkrement wird zu der
Kontrollvariablen hinzuaddiert.  Die Schritte (1) bis (3) werden solange 
ausgef&uuml;hrt, bis eine der Bedingungen f&uuml;r die Beendigung der 
<code>do</code>-Anweisung zutrifft.
</p>

<p>Im Allgemeinen ist der <code>thru</code>-Test erf&uuml;llt, wenn die Kontrollvariable 
gr&ouml;&szlig;er als <var>limit</var> ist, falls <var>increment</var> nicht negativ ist.  Oder 
wenn die Kontrollvariable kleiner als <code>limit</code> ist, f&uuml;r den Fall, dass das
Inkrement negativ ist.  <var>increment</var> und <var>limit</var> k&ouml;nnen Ausdr&uuml;cke 
sein, sofern die Bedingung zum Abbruch der <code>do</code>-Anweisung ausgewertet 
werden kann.  Soll <code>increment</code> zu einem negativen Wert auswerten und kann 
dies jedoch bei Eintritt in die Schleife von Maxima nicht festgestellt werden, 
so wird das Inkrement als positiv angenommen.  Dies kann dazu f&uuml;hren, dass die
Schleife nicht korrekt ausgef&uuml;hrt wird.
</p>

<p><var>limit</var>, <var>increment</var> und die Bedingung f&uuml;r den Abbruch der Schleife 
werden f&uuml;r jeden Durchgang durch die Schleife ausgewertet.  &Auml;ndern diese 
ihren Wert nicht, kann es daher effizienter sein, die Werte diese Ausdr&uuml;cke 
vor Eintritt in die Schleife zu berechnen und in Variablen abzulegen, die 
anstatt der Ausdr&uuml;cke in der Schleife verwendet werden.
</p>

<p>Die <code>do</code>-Anweisung hat den R&uuml;ckgabewert <code>done</code>.  Um einen anderen
Wert zur&uuml;ckzugeben, kann die <code>return</code>-Anweisung innerhalb von 
<code>body</code> genutzt werden.  Befindet sich die <code>do</code>-Anweisung innerhalb 
eines Blockes, so wird dieser nicht mit einer <code>return</code>-Anweisung verlassen,
die sich innerhalb der <code>do</code>-Anweisung befindet.  Auch kann nicht mit der
<code>go</code>-Anweisung in einen umgebenen Block gesprungen werden.
</p>

<p>Die Kontrollvariable ist immer lokal zur <code>do</code>-Anweisung.  Nach dem
Verlassen der <code>do</code>-Anweisung kann auf die Kontrollvariable nicht mehr 
zugegriffen werden.
</p>
<pre class="example">(%i1) for a:-3 thru 26 step 7 do display(a)$
                             a = - 3

                              a = 4

                             a = 11

                             a = 18

                             a = 25
</pre>

<p>Die Bedingung <code>while i &lt;= 10</code> ist &auml;quivalent zu den Bedingungen
<code>unless i &gt; 10</code> und <code>thru 10</code> ist.
</p>
<pre class="example">(%i1) s: 0$
(%i2) for i: 1 while i &lt;= 10 do s: s+i;
(%o2)                         done
(%i3) s;
(%o3)                          55
</pre>

<p>Berechne die ersten acht Terme einer Taylorreihe in einer <code>do</code>-Schleife.
</p>
<pre class="example">(%i1) series: 1$
(%i2) term: exp (sin (x))$
(%i3) for p: 1 unless p &gt; 7 do
          (term: diff (term, x)/p, 
           series: series + subst (x=0, term)*x^p)$
(%i4) series;
                  7    6     5    4    2
                 x    x     x    x    x
(%o4)            -- - --- - -- - -- + -- + x + 1
                 90   240   15   8    2
</pre>

<p>In diesem Beispiel wird die negative Wurzel von 10 mit einem 
Newton-Raphson-Algorithmus berechnet. 
</p>
<pre class="example">(%i1) poly: 0$
(%i2) for i: 1 thru 5 do
          for j: i step -1 thru 1 do
              poly: poly + i*x^j$
(%i3) poly;
                  5      4       3       2
(%o3)          5 x  + 9 x  + 12 x  + 14 x  + 15 x
(%i4) guess: -3.0$
(%i5) for i: 1 thru 10 do
          (guess: subst (guess, x, 0.5*(x + 10/x)),
           if abs (guess^2 - 10) &lt; 0.00005 then return (guess));
(%o5)                  - 3.162280701754386
</pre>

<p>Anstatt eines festes Inkrements mit <code>step</code> kann die Kontrollvariable auch 
mit <code>next</code> f&uuml;r jeden Schleifendurchgang berechnet werden.
</p>
<pre class="example">(%i6) for count: 2 next 3*count thru 20 do display (count)$
                            count = 2

                            count = 6

                           count = 18
</pre>
   
<p>Anstatt mit der Syntax <code>for <var>variable</var>: <var>value</var> ...</code> kann die
Kontrollvariable auch mit <code>for <var>variable</var> from <var>value</var> ...do...</code>
initialisiert werden.  Wird auch <code>from <var>value</var></code> fortgelassen, wird
die Kontrollvariable mit dem Wert 1 initialisiert.
</p>

<p>Manchmal kann es von Interesse sein, in einer Schleife keine Kontrollvariable
zu nutzen.  In diesem Fall gen&uuml;gt es allein die Bedingung f&uuml;r den Abbruch 
der Schleife anzugeben.  Im folgenden wird die Wurzel aus 5 mit dem 
Heron-Verfahren bestimmt.
</p>
<pre class="example">(%i1) x: 1000$
(%i2) thru 20 do x: 0.5*(x + 5.0/x)$
(%i3) x;
(%o3)                   2.23606797749979
(%i4) sqrt(5), numer;
(%o4)                   2.23606797749979
</pre>

<p>Auch die Abbruchbedingung kann fortgelassen werden.  Wird allein
<code>do <var>body</var></code> angegeben, wird die Schleife unendlich oft ausgef&uuml;hrt. 
Die Schleife kann mit der <code>return</code>-Anweisung verlassen werden.   Das 
folgende Beispiel zeigt eine Implementierung des Newton-Algorithmus.
</p>
<pre class="example">(%i1) newton (f, x):= ([y, df, dfx], df: diff (f ('x), 'x),
          do (y: ev(df), x: x - f(x)/y, 
              if abs (f (x)) &lt; 5e-6 then return (x)))$
(%i2) sqr (x) := x^2 - 5.0$
(%i3) newton (sqr, 1000);
(%o3)                   2.236068027062195
</pre>
   

<p>Eine weitere Syntax ist die folgende:
</p>
<pre class="example">for <var>variable</var> in <var>list</var> <var>end_tests</var> do <var>body</var>
</pre>

<p>Die Elemente der Liste <var>list</var> k&ouml;nnen beliebige Ausdr&uuml;cke sein, die
nacheinander der Kontrollvariablen zugewiesen werden.  Die Schleife bricht ab, 
wenn die optionale Abbruchbedingung <code>end_test</code> zutrifft, wenn die Liste
<var>list</var> keine weiteren Elemente enth&auml;lt oder wenn die Schleife zum Beispiel
mit der Funktion <code>return</code> verlassen wird.
</p>
<pre class="example">(%i1)  for f in [log, rho, atan] do ldisp(f(1))$
(%t1)                                  0
(%t2)                                rho(1)
                                     %pi
(%t3)                                 ---
                                      4
(%i4) ev(%t3,numer);
(%o4)                             0.78539816
</pre></dd></dl>

<p><a name="eval_005fwhen"></a>
</p><dl>
<dt><u>Funktion:</u> <b>eval_when</b><i> (<var>keyword</var>, <var>expr_1</var>, &hellip;, <var>expr_n</var>)</i>
<a name="IDX1444"></a>
</dt>
<dt><u>Funktion:</u> <b>eval_when</b><i> ([<var>keyword_1</var>, <var>keyword_2</var>, &hellip;], <var>expr_1</var>, &hellip;, <var>expr_n</var>)</i>
<a name="IDX1445"></a>
</dt>
<dd><p>Ein Ausdruck mit der Funktion <code>eval_when</code> wird an oberster Stelle in einer
Datei definiert und erlaubt die bedingte Auswertung von Ausdr&uuml;cken beim Laden,
&Uuml;bersetzen oder Kompilieren einer Datei.  Das Argument <var>keyword</var> ist eines
der Schl&uuml;sselworte <code>batch</code>, <code>translate</code>, <code>compile</code> oder
<code>loadfile</code>.  Das erste Argument kann ein einzelnes Schl&uuml;sselwort oder
ein Liste mit mehreren Schl&uuml;sselworten sein.  Trifft die mit dem
Schl&uuml;sselwort angegebene Bedingung zu, wird eine oder mehrere der folgenden
Aktionen ausgef&uuml;hrt:
</p>
<dl compact="compact">
<dt> <code>batch</code></dt>
<dd><p>Wird die Datei mit einer der Funktionen <code><a href="maxima_13.html#load">load</a></code>,
 <code><a href="maxima_13.html#batch">batch</a></code>,

<code><a href="maxima_13.html#batchload">batchload</a></code>
 oder <code><a href="maxima_3.html#demo">demo</a></code>
 geladen und ist <code>batch</code> in der Liste der
Schl&uuml;sselworte enthalten, dann werden die Ausdr&uuml;cke <var>expr1</var>, &hellip;,
<var>expr_n</var> genau einmal beim Laden der Datei ausgewertet.  Die R&uuml;ckgabe der
Funktion <code>eval_when</code> ist ein Ausdruck <code>evaluated_when(<var>result)</var></code>,
wobei <var>result</var> das Ergebnis der Auswertung ist.  Ist das Schl&uuml;sselwort
<code>batch</code> nicht vorhanden, ist die R&uuml;ckgabe das Symbol
<code>not_evaluated_when</code>.
</p>
</dd>
<dt> <code>translate</code></dt>
<dd><p>Wird die Datei mit dem Kommando <code><a href="maxima_28.html#translate_005ffile">translate_file</a></code>
 oder
<code><a href="maxima_28.html#compile_005ffile">compile_file</a></code>
 geladen und ist <code>translate</code> unter den
Schl&uuml;sselworten, dann werden die Ausdr&uuml;cke <var>expr_1</var>, &hellip;,
<var>expr_n</var> sofort ausgewertet.  Seiteneffekte wie Zuweisungen von Werten
an Optionsvariablen oder Deklarationen sind f&uuml;r die folgende &Uuml;bersetzung
der Datei nach Lisp wirksam.  Die Ausdr&uuml;cke sind jedoch nicht Teil des
&uuml;bersetzten Programms.
</p>
</dd>
<dt> <code>loadfile</code></dt>
<dd><p>Wird die Datei mit dem Kommando <code><a href="maxima_28.html#translate_005ffile">translate_file</a></code>
 oder dem Kommando
<code><a href="maxima_28.html#compile_005ffile">compile_file</a></code>
 geladen und ist <code>loadfile</code> unter den
Schl&uuml;sselworten, dann werden die Ausdr&uuml;cke <var>expr_1</var>, &hellip;,
<var>expr_n</var> nach Lisp &uuml;bersetzt und als Block der Form
<code>(PROGN EXPR_1 ... EXPR_N)</code> in das Lisp Programm eingesetzt.  Hier sind
die Anweisungen <var>EXPR_I</var> die nach Lisp &uuml;bersetzten Maxima-Ausdr&uuml;cke
<var>expr_i</var>.
</p>
</dd>
<dt> <code>compile</code></dt>
<dd><p>Wird die Datei mit dem Kommando <code><a href="maxima_28.html#translate_005ffile">translate_file</a></code>
 oder
<code><a href="maxima_28.html#compile_005ffile">compile_file</a></code>
 geladen und ist <code>compile</code> unter den
Schl&uuml;sselworten, dann werden die Ausdr&uuml;cke <var>expr_1</var>, &hellip;,
<var>expr_n</var> nach Lisp &uuml;bersetzt und als eine Lisp-Anweisung in das
Lisp-Programm eingesetzt, die die Form <code>(EVAL-WHEN (:COMPILE-TOPLEVEL)
(EXPR_1 ... EXPR_N))</code> hat.  Das Schl&uuml;sselwort <code>compile</code> kann nicht mit
dem Schl&uuml;sselwort <code>loadfile</code> in einem <code>eval_when</code>-Ausdruck
kombiniert werden.  In diesem Fall wird das Schl&uuml;sselwort <code>compile</code>
ignoriert.
</p></dd>
</dl>

<p>Beispiele:
</p>
<p>F&uuml;r die folgende Beispiele ist eine Datei mit den Namen
<code>eval_when.mac</code> definiert, die verschiedene <code>eval_when</code>-Anweisungen
enth&auml;lt.
</p>
<pre class="example">(%i1) file: file_search(&quot;eval_when.mac&quot;);
(%o1)        /home/dieter/.maxima/eval_when.mac
(%i2) printfile(file);

eval_when(batch,     print(&quot;called in mode BATCH&quot;));
eval_when(loadfile,  print(&quot;called in mode LOADFILE&quot;));
eval_when(compile,   print(&quot;called in mode COMPILE&quot;));
eval_when(translate, print(&quot;called in mode TRANSLATE&quot;));

(%o2)        /home/dieter/.maxima/eval_when.mac
</pre>
<p>Die Datei wird mit dem Kommando <code>load</code> geladen.  Die Anweisung mit
dem Schl&uuml;sselwort <code>batch</code> wird beim Laden einmal ausgef&uuml;hrt.
</p>
<pre class="example">(%i1) file: file_search(&quot;eval_when.mac&quot;);
(%o1)        /home/dieter/.maxima/eval_when.mac
(%i2) load(file);
called in mode BATCH
(%o2)        /home/dieter/.maxima/eval_when.mac
</pre>
<p>In diesem Fall wird die Datei mit dem Befehl <code>batch</code> geladen.  Die
Anweisung mit dem Schl&uuml;sselwort <code>batch</code> wird einmal ausgef&uuml;hrt.
Die anderen <code>eval_when</code>-Anweisungen werten jeweils zum Ergebnis
<code>not_evaluated_when</code> aus.
</p>
<pre class="example">(%i3) batch(file);

read and interpret file: /home/dieter/.maxima/eval_when.mac
(%i4)     eval_when(batch, print(called in mode BATCH))
called in mode BATCH 
(%o4)         evaluated_when(called in mode BATCH)
(%i5)  eval_when(loadfile, print(called in mode LOADFILE))
(%o5)                  not_evaluated_when
(%i6)   eval_when(compile, print(called in mode COMPILE))
(%o6)                  not_evaluated_when
(%i7) eval_when(translate, print(called in mode TRANSLATE))
(%o7)                  not_evaluated_when
(%o7)        /home/dieter/.maxima/eval_when.mac
</pre>
<p>Jetzt wird die Datei mit dem Kommando <code>translate_file</code> geladen und nach
Lisp &uuml;bersetzt.  Der Ausdruck mit dem Schl&uuml;sselwort <code>translate</code> wird
sofort ausgewertet.  Das &uuml;bersetzte Programm wird in die Ausgabedatei
<code>eval_when.LISP</code> geschrieben.  Die <code>eval_when</code>-Anweisung zum
Schl&uuml;sselwort wird nicht ausgewertet.
</p>
<pre class="example">(%i1) file: file_search(&quot;eval_when.mac&quot;);
(%o1)        /home/dieter/.maxima/eval_when.mac
(%i2) translate_file(file);
translator: begin translating /home/dieter/.maxima/eval_when.mac.
called in mode TRANSLATE 
(%o2) [/home/dieter/.maxima/eval_when.mac, 
/home/dieter/.maxima/eval_when.LISP, 
/home/dieter/.maxima/eval_when.UNLISP]
</pre>
<p>Dies ist der Inhalt der Ausgabedatei <code>eval_when.LISP</code>.  Die Ausgabedatei
enth&auml;lt eine <code>PROGN</code>-Anweisung mit dem Ausdruck
<code>($print '&quot;called in mode LOADFILE&quot;)</code> f&uuml;r den <code>eval_when</code>-Ausdruck
zum Schl&uuml;sselwort <code>loadfile</code> sowie eine <code>EVAL-WHEN</code>-Anweisung mit
dem Ausdruck <code>($print '&quot;called in mode COMPILE&quot;)</code> f&uuml;r den
<code>eval_when</code>-Ausdruck mit dem Schl&uuml;sselwort <code>compile</code>.
</p>
<pre class="verbatim">;;; -*- Mode: Lisp; package:maxima; syntax:common-lisp ;Base: 10 -*- ;;;
;;; Translated on: 2011-10-02 13:35:37+02:00
;;; Maxima version: 5.25post
;;; Lisp implementation: SBCL
;;; Lisp version: 1.0.45
(in-package :maxima)

[...]

nil
(progn ($print '&quot;called in mode LOADFILE&quot;))
(eval-when (:compile-toplevel) ($print '&quot;called in mode COMPILE&quot;))
nil
</pre></dd></dl>

<p><a name="errcatch"></a>
</p><dl>
<dt><u>Funktion:</u> <b>errcatch</b><i> (<var>expr_1</var>, &hellip;, <var>expr_n</var>)</i>
<a name="IDX1446"></a>
</dt>
<dd>
<p>Wertet die Ausdr&uuml;cke <var>expr_1</var>, &hellip;, <var>expr_n</var> nacheinander aus und
gibt das Ergebnis des letzten Ausdrucks als eine Liste <code>[<var>expr_n</var>]</code>
zur&uuml;ck, wenn kein Fehler bei der Auswertung auftritt.  Tritt ein Fehler
bei der Auswertung eines der Ausdr&uuml;cke auf, ist die R&uuml;ckgabe eine leere 
Liste <code>[]</code>.
</p>

<p><code>errcatch</code> ist n&uuml;tzlich in Batch-Dateien.  Mit <code>errcatch</code> kann ein
m&ouml;glicher Fehler abgefangen werden, ohne das die Verarbeitung der Batch-Datei
abbricht.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) errcatch(x:2,1/x);
                                1
(%o1)                          [-]
                                2
(%i2) errcatch(x:0,1/x);

Division by 0
(%o2)                          []
</pre></dd></dl>

<p><a name="error"></a>
</p><dl>
<dt><u>Funktion:</u> <b>error</b><i> (<var>expr_1</var>, &hellip;, <var>expr_n</var>)</i>
<a name="IDX1447"></a>
</dt>
<dt><u>Systemvariable:</u> <b>error</b>
<a name="IDX1448"></a>
</dt>
<dd>
<p>Wertet die Ausdr&uuml;cke <var>expr_1</var>, &hellip;, <var>expr_n</var> aus, gibt diese auf 
der Konsole aus und generiert einen Fehler, der zur obersten Ebene von Maxima 
f&uuml;hrt oder zu dem n&auml;chsten <code>errcatch</code>.
</p>

<p>Der Systemvariablen <code>error</code> wird eine Liste zugewiesen, die eine 
Beschreibung des Fehlers enth&auml;lt.  Das erste Element der Liste ist eine
Zeichenkette und die weiteren Elemente enthalten die Argumente die keine 
Zeichenkette sind.
</p>

<p><code>errormsg()</code> formatiert und gibt die Fehlermeldung in <code>error</code> aus.
Damit wird die letzte Fehlermeldung erneut ausgegeben.
</p>
<p>Beispiel:
</p>
<pre class="example">(%i1) f(x):= if x=0 then 
                error(&quot;Division durch&quot;, x, &quot;ist nicht gestattet.&quot;) 
             else 1/x$
(%i2) f(0);

Division durch 0 ist nicht gestattet.
#0: f(x=0)
 -- an error. To debug this try: debugmode(true);
(%i3) errormsg();

Division durch 0 ist nicht gestattet.
(%o3)                         done
(%i4) error;
(%o4)      [Division durch ~M ist nicht gestattet., 0]
</pre></dd></dl>

<p><a name="error_005fsize"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>error_size</b>
<a name="IDX1449"></a>
</dt>
<dd><p>Standardwert: 10
</p>

<p><code>error_size</code> kontrolliert die Ausgabe eines Ausdrucks der zu einem Fehler
gef&uuml;hrt hat.  Ist der Ausdruck gr&ouml;&szlig;er als <code>error_size</code> wird der 
Ausdruck bei der Ausgabe einer Fehlermeldung durch ein Symbol ersetzt und dem 
Symbol wird der Ausdruck zugewiesen.  Die Symbole werden aus der Liste 
<code>error_syms</code> ausgew&auml;hlt.
</p>

<p>Ist der Ausdruck kleiner als <code>error_size</code> wird dieser mit der Fehlermeldung
ausgegeben.
</p>

<p>Siehe auch <code><a href="#error">error</a></code>
 und <code><a href="#error_005fsyms">error_syms</a></code>.
</p>

<p>Beispiel:
</p>

<p>Die Gr&ouml;&szlig;e des Ausdrucks <code>U</code> ist 24.
</p>
<pre class="example">(%i1) U: (C^D^E + B + A)/(cos(X-1) + 1)$

(%i2) error_size: 20$

(%i3) error (&quot;Example expression is&quot;, U);

Example expression is errexp1
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) errexp1;
                            E
                           D
                          C   + B + A
(%o4)                    --------------
                         cos(X - 1) + 1
(%i5) error_size: 30$

(%i6) error (&quot;Example expression is&quot;, U);

                         E
                        D
                       C   + B + A
Example expression is --------------
                      cos(X - 1) + 1
 -- an error.  Quitting.  To debug this try debugmode(true);
</pre></dd></dl>

<p><a name="error_005fsyms"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>error_syms</b>
<a name="IDX1450"></a>
</dt>
<dd><p>Standardwert: <code>[errexp1, errexp2, errexp3]</code>
</p>

<p>In Fehlermeldungen werden Ausdr&uuml;cke, die gr&ouml;&szlig;er als <code>error_size</code> 
sind, durch Symbole ersetzt, denen der Ausdruck zugewiesen wird.  Die Symbole 
werden nacheinander der Liste <code>error_syms</code> entnommen.
</p>

<p>Sind keine Symbole mehr vorhanden, werden automatisch neue Symbole mit
<code>concat('errexp, <var>n</var>)</code> gebildet.
</p>

<p>Siehe auch <code><a href="#error">error</a></code>
 und <code><a href="#error_005fsize">error_size</a></code>.
</p>
</dd></dl>

<p><a name="errormsg"></a>
</p><dl>
<dt><u>Funktion:</u> <b>errormsg</b><i> ()</i>
<a name="IDX1451"></a>
</dt>
<dd>
<p>Gibt die letzte Fehlermeldung erneut aus.  Die Fehlermeldung ist in der
Systemvariablen <code>errormsg</code> enthalten.  Die Funktion <code>errormsg</code>
formatiert diese und gibt sie aus.
</p></dd></dl>

<p><a name="variable_005ferrormsg"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>errormsg</b>
<a name="IDX1452"></a>
</dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat die Optionsvariable <code>errormsg</code> den <code>false</code> wird die Ausgabe
von Fehlermeldungen unterdr&uuml;ckt.
</p>

<p>Der Optionsvariablen <code>errormsg</code> kann in einem Block kein lokaler Wert
zugewiesen werden.  Der globale Wert von <code>errormsg</code> ist stets pr&auml;sent.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) errormsg;
(%o1)                                true
(%i2) sin(a,b);
Wrong number of arguments to sin
 -- an error. To debug this try: debugmode(true);
(%i3) errormsg:false;
(%o3)                                false
(%i4) sin(a,b);

 -- an error. To debug this try: debugmode(true);
</pre>

<p>Der Optionsvariablen <code>errormsg</code> kann in einem Block kein lokaler Wert
zugewiesen werden.
</p>
<pre class="example">(%i1) f(bool):=block([errormsg:bool], 
                     print (&quot;value of errormsg is&quot;,errormsg))$
(%i2) errormsg:true;
(%o2)                                true
(%i3) f(false);
value of errormsg is true 
(%o3)                                true
(%i4) errormsg:false;
(%o4)                                false
(%i5) f(true);
value of errormsg is false 
(%o5)                                false
</pre></dd></dl>


<p><a name="for"></a>
</p><dl>
<dt><u>Spezieller Operator:</u> <b>for</b>
<a name="IDX1453"></a>
</dt>
<dd>
<p>Anweisung f&uuml;r Interationen.  Siehe die <code><a href="#do">do</a></code>
-Anweisung f&uuml;r eine 
Beschreibung der Iterationsm&ouml;glichkeiten von Maxima.
</p></dd></dl>

<p><a name="go"></a>
</p><dl>
<dt><u>Funktion:</u> <b>go</b><i> (<var>tag</var>)</i>
<a name="IDX1454"></a>
</dt>
<dd>
<p>Erlaubt einen Sprung innerhalb eines Blocks zu einer Marke mit dem Namen 
<code>tag</code>.  Um eine Anweisung mit einer Sprungmarke zu versehen, wird der
Anweisung die Marke vorangestellt.  Ein Beispiel ist:
</p>
<pre class="example">block ([x], x:1, loop, x+1, ..., go(loop), ...)
</pre>

<p>Das Argument der Funktion <code>go</code> muss der Name einer Marke sein, die in
demselben Block erscheint.  Es ist nicht m&ouml;glich in einen anderen Block zu
springen.
</p></dd></dl>


<p><a name="if"></a>
</p><dl>
<dt><u>Spezieller Operator:</u> <b>if</b>
<a name="IDX1455"></a>
</dt>
<dd>
<p>Ist die bedingte Anweisung.  Verschiedene Formen einer bedingten Anweisung sind
m&ouml;glich.
</p>

<p><code>if <var>cond_1</var> then <var>expr_1</var> else <var>expr_0</var></code> wertet zu 
<var>expr_1</var> aus, wenn die Bedingung <var>cond_1</var> den Wert <code>true</code> hat.
Ansonsten wertet der Ausdruck zu <var>expr_0</var> aus.
</p>

<p>Die zusammengesetzte bedingte Anweisung <code>if <var>cond_1</var> then <var>expr_1</var>
elseif <var>cond_2</var> then <var>expr_2</var> elseif ... else <var>expr_0</var></code> wertet 
zu <var>expr_k</var> aus, wenn die Bedingung <var>cond_k</var> den Wert <code>true</code> hat 
und alle vorhergehenden Bedingungen den Wert <code>false</code> haben.  Trifft keine 
der Bedingungen zu, wertet der Ausdruck zu <var>expr_0</var> aus.
</p>

<p>Fehlt die Anweisung <code>else</code>, wird diese zu <code>else false</code> angenommen.
<code>if <var>cond_1</var> then <var>expr_1</var></code> ist daher &auml;quivalent zu 
<code>if <var>cond_1</var> then <var>expr_1</var> else false</code> und <code>if <var>cond_1</var> 
then <var>expr_1</var> elseif ... elseif <var>cond_n</var> then <var>expr_n</var></code> ist 
&auml;quivalent zu <code>if <var>cond_1</var> then <var>expr_1</var> elseif ... elseif 
<var>cond_n</var> then <var>expr_n</var> else false</code>.
</p>

<p>Die Anweisungen <var>expr_0</var>, &hellip;, <var>expr_n</var> k&ouml;nnen beliebige 
Maxima-Ausdr&uuml;cke einschlie&szlig;lich weiterer <code>if</code>-Anweisungen sein.  
Die Anweisungen werden nicht vereinfacht oder ausgewertet, solange die 
dazugeh&ouml;rende Bedingung nicht das Ergebnis <code>true</code> hat.
</p>

<p>Die Bedingungen <var>cond_1</var>, &hellip;, <var>cond_n</var> sind Ausdr&uuml;cke, die zu 
<code>true</code> oder <code>false</code> ausgewertet werden k&ouml;nnen.  Kann eine Bedingung
nicht zu <code>true</code> oder <code>false</code> ausgewertet werden, h&auml;ngt die Reaktion
von der Optionsvariablen <code>prederror</code> ab.  Hat <code>prederror</code> den Wert
<code>true</code>, dann meldet Maxima einen Fehler, wenn eine Bedingung nicht zu
<code>true</code> oder <code>false</code> ausgewertet werden kann.  Ansonsten werden
Bedingungen akzeptiert, die nicht zu <code>true</code> oder <code>false</code> ausgewertet
werden k&ouml;nnen und das Ergebnis ist ein bedingter Ausdruck.
</p>

<p>Die Bedingungen k&ouml;nnen die folgenden Operatoren enthalten:
</p>
         
<pre class="example">Operation              Symbol      Typ
 
less than              &lt;           relational infix
less than              &lt;=
  or equal to                      relational infix
equality (syntactic)   =           relational infix
negation of =          #           relational infix
equality (value)       equal       relational function
negation of equal      notequal    relational function
greater than           &gt;=
  or equal to                      relational infix
greater than           &gt;           relational infix
and                    and         logical infix
or                     or          logical infix
not                    not         logical prefix
</pre></dd></dl>

<p><a name="local"></a>
</p><dl>
<dt><u>Funktion:</u> <b>local</b><i> (<var>v_1</var>, &hellip;, <var>v_n</var>)</i>
<a name="IDX1456"></a>
</dt>
<dd>
<p>Speichert alle Eigenschaften der Symbole <var>v_1</var>, &hellip;, <var>v_n</var>, entfernt
die Eigenschaften und stellt die abgespeicherten Eigenschaften nach dem Austritt
aus einem Block oder einem zusammengesetzten Ausdruck in dem <code>local</code>
auftritt wieder her.
</p>

<p>Einige Deklarationen sind als Eigenschaft eines Symbols implementiert.  Dazu
geh&ouml;ren Deklarationen mit <code>:=</code>, <code>array</code>, <code>dependencies</code>, 
<code>atvalue</code>, <code>matchdeclare</code>, <code>atomgrad</code>, <code>constant</code>, 
<code>nonscalar</code> oder <code>assume</code>.  Der Effekt von <code>local</code> ist, dass
solche Deklarationen nur lokal in dem Block wirksam sind.
</p>

<p><code>local</code> kann nur in <code>block</code>-Anweisungen oder in einer 
Funktionsdefinition oder in einem Lambda-Ausdruck verwendet werden. Weiterhin
darf <code>local</code> jeweils nur einmal auftreten.
</p>

<p><code>local</code> wertet die Argumente aus.  <code>local</code> hat die R&uuml;ckgabe 
<code>done</code>.
</p>
<p>Beispiel:
</p>
<p>Eine lokale Funktionsdefinition.
</p>
<pre class="example">(%i1) foo (x) := 1 - x;
(%o1)                    foo(x) := 1 - x
(%i2) foo (100);
(%o2)                         - 99
(%i3) block (local (foo), foo (x) := 2 * x, foo (100));
(%o3)                          200
(%i4) foo (100);
(%o4)                         - 99
</pre></dd></dl>

<p><a name="return"></a>
</p><dl>
<dt><u>Funktion:</u> <b>return</b><i> (<var>value</var>)</i>
<a name="IDX1457"></a>
</dt>
<dd>
<p>Die <code>return</code>-Anweisung wird in einem Block verwendet, um den Block mit dem
Ergebnis <var>value</var> zu verlassen.  Siehe <code><a href="#block">block</a></code>
 f&uuml;r mehr Informationen.
</p></dd></dl>

<p><a name="throw"></a>
</p><dl>
<dt><u>Funktion:</u> <b>throw</b><i> (<var>expr</var>)</i>
<a name="IDX1458"></a>
</dt>
<dd>
<p>Wertet den Ausdruck <var>expr</var> aus und generiert eine Ausnahme mit dem Ergebnis
der Auswertung, die von der letzten <code>catch</code>-Anweisung behandelt wird.
</p></dd></dl>

<p><a name="while"></a>
<a name="unless"></a>
</p><dl>
<dt><u>Spezieller Operator:</u> <b>while</b>
<a name="IDX1459"></a>
</dt>
<dt><u>Spezieller Operator:</u> <b>unless</b>
<a name="IDX1460"></a>
</dt>
<dd>
<p>Siehe den Operator <code><a href="#do">do</a></code>.
</p>
</dd></dl>



<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC196" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC204" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC409" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Robert</em> on <em>Dezember, 10 2012</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
