<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on diciembre, 10 2012 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual de Maxima: 11. Base de datos de Maxima</title>

<meta name="description" content="Manual de Maxima: 11. Base de datos de Maxima">
<meta name="keywords" content="Manual de Maxima: 11. Base de datos de Maxima">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body
{
    color: black;
    background: white; 
    margin-left: 8%;
    margin-right: 13%;
}

h1
{
    margin-left: +8%;
    font-size: 150%;
    font-family: sans-serif
}

h2
{
    font-size: 125%;
    font-family: sans-serif
}

h3
{
    font-size: 100%;
    font-family: sans-serif
}

h2,h3,h4,h5,h6 { margin-left: +4%; }

div.textbox
{
    border: solid;
    border-width: thin;
    /* width: 100%; */
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em
}

div.titlebox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
    background: rgb(200,255,255);
    font-family: sans-serif
}

div.synopsisbox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
     background: rgb(255,220,255);
    /*background: rgb(200,255,255); */
    /* font-family: fixed */
}

pre.example
{
    border: 1px solid gray;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 1em;
    padding-right: 1em;
    /* background: rgb(247,242,180); */ /* kind of sandy */
    /* background: rgb(200,255,255); */ /* sky blue */
    background-color: #F1F5F9; /* light blue-gray */
    /* font-family: "Lucida Console", monospace */
}

div.spacerbox
{
    border: none;
    padding-top: 2em;
    padding-bottom: 2em
}

div.image
{
    margin: 0;
    padding: 1em;
    text-align: center;
}

div.categorybox
{
    border: 1px solid gray;
    padding-top: 0px;
    padding-bottom: 0px;
    padding-left: 1em;
    padding-right: 1em;
    background: rgb(247,242,220);
}


-->
</style>

<link rel="icon" href="http://maxima.sourceforge.net/favicon.ico"/>
</head>

<body lang="es" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Base-de-datos-de-Maxima"></a>
<a name="SEC68"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_10.html#SEC67" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC69" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_10.html#SEC59" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_12.html#SEC75" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 11. Base de datos de Maxima </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC69">11.1 Introducci&oacute;n a la base de datos de Maxima</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC72">11.2 Funciones y variables para las propiedades</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC73">11.3 Funciones y variables para los hechos</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC74">11.4 Funciones y variables para los predicados</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>




<hr size="6">
<a name="Introducci_00f3n-a-la-base-de-datos-de-Maxima"></a>
<a name="SEC69"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC68" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC72" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC68" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_12.html#SEC75" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 11.1 Introducci&oacute;n a la base de datos de Maxima </h2>

<a name="SEC70"></a>
<h3 class="subheading"> Propiedades </h3>

<p>A las variables y funciones se les puede asignar propiedades con la funci&oacute;n 
<code>declare</code>. Estas propiedades son almacenadas en un <i>banco de datos</i> o
registradas en una <i>lista de propiedades</i> que proporciona Lisp. Con la funci&oacute;n
<code>featurep</code> se puede comprobar si un s&iacute;mbolo tiene una 
determinada propiedad y con la funci&oacute;n <code>properties</code> se pueden obtener
todas las propiedades asociadas a &eacute;l. A su vez, la funci&oacute;n <code>remove</code>
elimina una propiedad de la base de datos o de la lista de propiedades. En caso
de utilizar <code>kill</code> para borrar el valor asignado a una variable, tambi&eacute;n
ser&aacute;n borradas todas las propiedades asociadas a la misma.
</p>
<p>El usuario tiene la facultad de a&ntilde;adirle propiedades a un s&iacute;mbolo
con las funciones <code>put</code> y <code>qput</code>. Con la funci&oacute;n <code>get</code> podr&aacute;
leer sus propiedades y borrarlas con <code>rem</code>.
</p>
<p>Las variables pueden tener las siguientes propiedades a almacenar en el banco de
datos:
</p>
<pre class="verbatim">   constant
   integer        noninteger
   even           odd
   rational       irrational
   real           imaginary      complex
</pre>
<p>Las funciones pueden tener las siguientes propiedades a almacenar en el banco de
datos:
</p>
<pre class="verbatim">   increasing     decreasing
   posfun         integervalued
</pre>
<p>Las siguientes propiedades se pueden aplicar a funciones y se utilizan para
su correcta simplificaci&oacute;n. Estas propiedades se describen en el cap&iacute;tulo
dedicado a la simplificaci&oacute;n:
</p>
<pre class="verbatim">   linear         additive       multiplicative
   outative       commutative    symmetric      
   antisymmetric  nary           lassociativ
   rassociative   evenfun        oddfun
</pre>
<p>Otras propiedades aplicables a variables y funciones, y que se almacenan
en la lista de propiedades de Lisp, son:
</p>
<pre class="verbatim">   bindtest       feature        alphabetic
   scalar         nonscalar      nonarray
</pre>
<a name="SEC71"></a>
<h3 class="subheading"> Contextos </h3>

<p>Maxima administra contextos en los que se almacenan tanto las propiedades de las
variables y funciones como hechos o hip&oacute;tesis sobre las mismas. Los hechos se
establecen con la funci&oacute;n <code>assume</code> y se almacenan en el contexto actual.
Por ejemplo, con <code>assume(a&gt;10)</code> guarda Maxima la informaci&oacute;n sobre el
hecho de que la variable <code>a</code> es mayor que <code>10</code>. Con la funci&oacute;n
<code>forget</code> se borran los hechos de la base de datos. Cuando Maxima pregunta
al usuario sobre las propiedades de una variable, &eacute;stas son almacenadas en
un contexto.
</p>
<p>Cada contexto se identifica por un nombre. Al iniciarse Maxima, el contexto
actual recibe el nombre de <code>initial</code> y se puede definir un n&uacute;mero
arbitrario de contextos adicionales que pueden organizarse de forma jer&aacute;rquica.
As&iacute;, el contexto <code>initial</code> est&aacute; incluido en el contexto
<code>global</code>. Los hechos definidos en un contexto dado est&aacute;n siempre
activos en los contextos de nivel inferior. Por ejemplo, el contexto <code>global</code>
contiene hechos que se inicializan por el propio Maxima y estar&aacute;n activos,
por tanto, en el contexto <code>initial</code>.
</p>
<p>Los contextos pueden almacenar un n&uacute;mero arbitrario de hechos y pueden desactivarse
con la funci&oacute;n <code>deactivate</code>. Desactivar un contexto no implica la p&eacute;rdida de
los hechos almacenados, pudiendo ser posteriormente reactivado con la funci&oacute;n 
<code>activate</code>, estando los hechos siempre a disposici&oacute;n del usuario.
</p>







<hr size="6">
<a name="Funciones-y-variables-para-las-propiedades"></a>
<a name="SEC72"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC69" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC73" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC68" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_12.html#SEC75" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 11.2 Funciones y variables para las propiedades </h2>

<dl>
<dt><u>Propiedad:</u> <b>alphabetic</b>
<a name="IDX415"></a>
</dt>
<dd><p><code>alphabetic</code> es un tipo de propiedad reconocida por <code>declare</code>.
La expresi&oacute;n <code>declare(<var>s</var>, alphabetic)</code> le indica a Maxima que reconozca
como alfab&eacute;ticos todos los caracteres que haya en <var>s</var>, que debe ser una cadena de texto.
</p>
<p>V&eacute;ase tambi&eacute;n <code>Identifiers</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) xx\~yy\`\@ : 1729;
(%o1)                         1729
(%i2) declare (&quot;~`@&quot;, alphabetic);
(%o2)                         done
(%i3) xx~yy`@ + @yy`xx + `xx@@yy~;
(%o3)               `xx@@yy~ + @yy`xx + 1729
(%i4) listofvars (%);
(%o4)                  [@yy`xx, `xx@@yy~]
</pre></dd></dl>

<dl>
<dt><u>Propiedad:</u> <b>bindtest</b>
<a name="IDX416"></a>
</dt>
<dd><p>La sentencia <code>declare(<var>x</var>, bindtest</code> le indica a Maxima que devuelva un mensaje
de error cuando el s&iacute;mbolo <var>x</var> no tenga asociado valor alguno.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) aa + bb;
(%o1)                        bb + aa
(%i2) declare (aa, bindtest);
(%o2)                         done
(%i3) aa + bb;
aa unbound variable
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) aa : 1234;
(%o4)                         1234
(%i5) aa + bb;
(%o5)                       bb + 1234
</pre></dd></dl>


<dl>
<dt><u>Propiedad:</u> <b>constant</b>
<a name="IDX417"></a>
</dt>
<dd><p><code>declare(<var>a</var>, constant)</code> declara <var>a</var> como constante.  La declaraci&oacute;n
de un s&iacute;mbolo como constante no impide que se le asigne un valor no
constante al s&iacute;mbolo.
</p>
<p>V&eacute;anse <code>constantp</code> y <code>declare</code>
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) declare(c, constant);
(%o1)                         done
(%i2) constantp(c);
(%o2)                         true
(%i3) c : x;
(%o3)                           x
(%i4) constantp(c);
(%o4)                         false
</pre></dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>constantp</b><i> (<var>expr</var>)</i>
<a name="IDX418"></a>
</dt>
<dd><p>Devuelve <code>true</code> si <var>expr</var> es una expresi&oacute;n constante y
<code>false</code> en caso contrario.
</p>
<p>Una expresi&oacute;n se considera constante si sus argumentos son n&uacute;meros 
(incluidos los n&uacute;meros racionales que se muestran con <code>/R/</code>), 
constantes simb&oacute;licas como <code>%pi</code>, <code>%e</code> o <code>%i</code>, variables 
con valor constante o declarada como constante por <code>declare</code>,
o funciones cuyos argumentos son constantes.
</p>
<p>La funci&oacute;n <code>constantp</code> eval&uacute;a sus argumentos.
</p>
<p>Ejemplos:
</p>

<pre class="example">(%i1) constantp (7 * sin(2));
(%o1)                                true
(%i2) constantp (rat (17/29));
(%o2)                                true
(%i3) constantp (%pi * sin(%e));
(%o3)                                true
(%i4) constantp (exp (x));
(%o4)                                false
(%i5) declare (x, constant);
(%o5)                                done
(%i6) constantp (exp (x));
(%o6)                                true
(%i7) constantp (foo (x) + bar (%e) + baz (2));
(%o7)                                false
(%i8) 
</pre></dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>declare</b><i> (<var>a_1</var>, <var>f_1</var>, <var>a_2</var>, <var>f_2</var>, ...)</i>
<a name="IDX419"></a>
</dt>
<dd><p>Asigna al &aacute;tomo o lista de &aacute;tomos <var>a_i</var> la propiedad o lista de 
propiedades<var>p_i</var>. Si <var>a_i</var> y/o <var>p_i</var> son listas, cada uno de
los &aacute;tomos adquiere todas las propiedades.
</p>
<p>La funci&oacute;n <code>declare</code> no eval&uacute;a sus argumentos y siempre devuelve la
expresi&oacute;n <code>done</code>.
</p>
<p>La llamada <code>featurep (<var>object</var>, <var>feature</var>)</code> devuelve <code>true</code>
si <var>object</var> ha sido previamente declarado como poseedor de la propiedad
<var>feature</var>.
</p>
<p>V&eacute;ase tambi&eacute;n <code>features</code>.
</p>
<p>La funci&oacute;n <code>declare</code> reconoce las siguientes propiedades:
</p>
<dl compact="compact">
<dt> <code>additive</code></dt>
<dd><p>      Hace que Maxima simplifique las expresiones <var>a_i</var>
      haciendo uso de la sustituci&oacute;n 
      <code><var>a_i</var>(x + y + z + ...)</code> <code>--&gt;</code>
      <code><var>a_i</var>(x) + <var>a_i</var>(y) + <var>a_i</var>(z) + ...</code>.
      Tal sustituci&oacute;n se aplica &uacute;nicamente al primer argumento.
</p>
</dd>
<dt> <code>alphabetic</code></dt>
<dd><p>      Indica a Maxima que reconozca todos los caracteres de la cadena alfanum&eacute;rica
      <var>a_i</var> como caracteres alfab&eacute;ticos.
</p>
</dd>
<dt> <code>antisymmetric, commutative, symmetric</code></dt>
<dd><p>      Hace que Maxima reconozca a <var>a_i</var> como una funci&oacute;n sim&eacute;trica o
      antisim&eacute;trica. La propiedad <code>commutative</code> equivale a <code>symmetric</code>.
</p>
</dd>
<dt> <code>bindtest</code></dt>
<dd><p>      Hace que Maxima env&iacute;e un error si <var>a_i</var> es evaluado sin hab&eacute;rsele
      asignado un valor.
</p>
</dd>
<dt> <code>constant</code></dt>
<dd><p>      Hace que Maxima considere a <var>a_i</var> como una constante
      simb&oacute;lica.
</p>
</dd>
<dt> <code>even, odd</code></dt>
<dd><p>      Hace que Maxima reconozca a <var>a_i</var> como una variable entera par o impar.
</p>
</dd>
<dt> <code>evenfun, oddfun</code></dt>
<dd><p>      Hace que Maxima reconozca a <var>a_i</var> como una funci&oacute;n par o impar.
</p>
</dd>
<dt> <code>evflag</code></dt>
<dd><p>      Hace que <var>a_i</var> sea reconocida por <code>ev</code>, de manera que a <var>a_i</var> se le
      asigne el valor <code>true</code> durante la ejecuci&oacute;n de <code>ev</code> cuando <var>a_i</var> 
      aparezca como argumento de control de <code>ev</code>. V&eacute;ase tambi&eacute;n <code>evflag</code>.
</p>
</dd>
<dt> <code>evfun</code></dt>
<dd><p>      Hace que <var>a_i</var> sea reconocida por <code>ev</code>, de manera que la funci&oacute;n
      nombrada por <var>a_i</var> se aplique cuando <var>a_i</var> aparezca como argumento
      de control de <code>ev</code>. V&eacute;ase tambi&eacute;n <code>evfun</code>.
</p>
</dd>
<dt> <code>feature</code></dt>
<dd><p>      Hace que Maxima considere a <var>a_i</var> como el nombre de una propiedad.
      Otros &aacute;tomos podr&aacute;n ser declarados entonces como poseedores de
      la propiedad <var>a_i</var>.
</p>
</dd>
<dt> <code>increasing, decreasing</code></dt>
<dd><p>      Hace que Maxima reconozca a <var>a_i</var> como una funci&oacute;n creciente o decreciente.
</p>
</dd>
<dt> <code>integer, noninteger</code></dt>
<dd><p>      Hace que Maxima reconozca a <var>a_i</var> como una variable entera o no entera.
</p>
</dd>
<dt> <code>integervalued</code></dt>
<dd><p>      Hace que Maxima reconozca a <var>a_i</var> como una funci&oacute;n de valor entero.
</p>
</dd>
<dt> <code>lassociative, rassociative</code></dt>
<dd><p>      Hace que Maxima reconozca a <var>a_i</var> como una funci&oacute;n asociativa por la derecha o
      por la izquierda.
</p>
</dd>
<dt> <code>linear</code></dt>
<dd><p>      Equivale a declarar <var>a_i</var> conjuntamente como <code>outative</code> y <code>additive</code>.
</p>
</dd>
<dt> <code>mainvar</code></dt>
<dd><p>      Hace que Maxima considere a <var>a_i</var> como una &quot;variable principal&quot;,
      d&aacute;ndole prioridad frente a cualesquiera otras constantes o
      variables en la ordenaci&oacute;n can&oacute;nica de expresiones de Maxima,
      tal como determina <code>ordergreatp</code>.
</p>
</dd>
<dt> <code>multiplicative</code></dt>
<dd><p>      Hace que Maxima simplifique las expresiones <var>a_i</var>
      haciendo uso de la sustituci&oacute;n 
      <code><var>a_i</var>(x * y * z * ...)</code> <code>--&gt;</code> <code><var>a_i</var>(x) * <var>a_i</var>(y) * <var>a_i</var>(z) * ...</code>.
      Tal sustituci&oacute;n se aplica &uacute;nicamente al primer argumento.
</p>
</dd>
<dt> <code>nary</code></dt>
<dd><p>      Hace que Maxima reconozca a <var>a_i</var> como una funci&oacute;n n-aria.
</p>
<p>      La declaraci&oacute;n <code>nary</code> no es equivalente a la funci&oacute;n <code>nary</code>.
      El &uacute;nico efecto de <code>declare(foo, nary)</code> consiste en hacer que
      el simplificador de Maxima reduzca expresiones anidadas; por ejemplo, 
      para transformar <code>foo(x, foo(y, z))</code> a <code>foo(x, y, z)</code>.
</p>
</dd>
<dt> <code>nonarray</code></dt>
<dd><p>      Indica que Maxima no debe considerar <var>a_i</var> como un array. Esta declaraci&oacute;n
      evita la evaluaci&oacute;n m&uacute;ltiple de variables subindicadas.
</p>
</dd>
<dt> <code>nonscalar</code></dt>
<dd><p>      Hace que Maxima considere a <var>a_i</var> como una variable no escalar.
      Se aplica com&uacute;nmente para declarar una variable como un vector simb&oacute;lico
      o una matriz simb&oacute;lica.
</p>
</dd>
<dt> <code>noun</code></dt>
<dd><p>      Hace que Maxima considere a <var>a_i</var> como un nombre. El efecto
      que se obtiene es que se reemplazan todas las expresiones <var>a_i</var>
      por <code>'<var>a_i</var></code> o <code>nounify (<var>a_i</var>)</code>,
      dependiendo del contexto.
</p>
</dd>
<dt> <code>outative</code></dt>
<dd><p>      Hace que Maxima simplifique las expresiones <var>a_i</var>
      extrayendo los factores constantes del primer argumento.
</p>
<p>      Cuando <var>a_i</var> tenga un &uacute;nico argumento, un factor se considerar&aacute; constante
      si es una constante literal o declarada.
</p>
<p>      Cuando <var>a_i</var> tenga dos o m&aacute;s argumentos, un factor se considerar&aacute; constante
      si el segundo argumento es un s&iacute;mbolo y el factor no contiene al
      segundo argumento.
</p>
</dd>
<dt> <code>posfun</code></dt>
<dd><p>      Hace que Maxima reconozca a <var>a_i</var> como una funci&oacute;n positiva.
</p>
</dd>
<dt> <code>rational, irrational</code></dt>
<dd><p>      Hace que Maxima reconozca a <var>a_i</var> como una variable real racional o irracional.
</p>
</dd>
<dt> <code>real, imaginary, complex</code></dt>
<dd><p>      Hace que Maxima reconozca a <var>a_i</var> como una variable real, imaginaria o compleja.
</p>
</dd>
<dt> <code>scalar</code></dt>
<dd><p>      Hace que Maxima considere a <var>a_i</var> como una variable escalar.
</p>
</dd>
</dl>

<p>Ejemplos sobre el uso de estas propiedades est&aacute;n disponibles en la 
documentaci&oacute;n correspondiente a cada propiedad por separado.
</p></dd></dl>



<dl>
<dt><u>Propiedad:</u> <b>decreasing</b>
<a name="IDX420"></a>
</dt>
<dt><u>Propiedad:</u> <b>increasing</b>
<a name="IDX421"></a>
</dt>
<dd><p>Las instrucciones <code>declare(<var>f</var>, decreasing)</code> y
<code>declare(<var>f</var>, increasing</code> le indican a Maxima que reconozca la funci&oacute;n
<var>f</var> como una funci&oacute;n decreciente o creciente.
</p>
<p>V&eacute;ase tambi&eacute;n <code>declare</code> para m&aacute;s propiedades.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) assume(a &gt; b);
(%o1)                        [a &gt; b]
(%i2) is(f(a) &gt; f(b));
(%o2)                        unknown
(%i3) declare(f, increasing);
(%o3)                         done
(%i4) is(f(a) &gt; f(b));
(%o4)                         true
</pre></dd></dl>


<dl>
<dt><u>Propiedad:</u> <b>even</b>
<a name="IDX422"></a>
</dt>
<dt><u>Propiedad:</u> <b>odd</b>
<a name="IDX423"></a>
</dt>
<dd><p><code>declare(<var>a</var>, even)</code> y <code>declare(<var>a</var>, odd)</code> le indican a Maxima
que reconozca el s&iacute;mbolo <var>a</var> como entero par o impar.  Las
propiedades <code>even</code> y <code>odd</code> no son reconocidas por las funciones 
<code>evenp</code>, <code>oddp</code> y <code>integerp</code>.
</p>
<p>V&eacute;anse tambi&eacute;n <code>declare</code> y <code>askinteger</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) declare(n, even);
(%o1)                         done
(%i2) askinteger(n, even);
(%o2)                          yes
(%i3) askinteger(n);
(%o3)                          yes
(%i4) evenp(n);
(%o4)                         false
</pre></dd></dl>



<dl>
<dt><u>Propiedad:</u> <b>feature</b>
<a name="IDX424"></a>
</dt>
<dd><p>Maxima interpreta dos tipos diferentes de propiedades, del sistema y las que
se aplican a expresiones matem&aacute;ticas. V&eacute;ase <code>status</code> para obtener
informaci&oacute;n sobre propiedades del sistema, as&iacute; como
<code>features</code> y <code>featurep</code> para propiedades de las expresiones matem&aacute;ticas.
</p>
<p><code>feature</code> no es el nombre de ninguna funci&oacute;n o variable.
</p></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>featurep</b><i> (<var>a</var>, <var>f</var>)</i>
<a name="IDX425"></a>
</dt>
<dd><p>Intenta determinar si el objeto <var>a</var> tiene la propiedad <var>f</var> en base a los
hechos almacenados en la base de datos. En caso afirmativo, devuelve <code>true</code>,
o <code>false</code> en caso contrario.
</p>
<p>N&oacute;tese que <code>featurep</code> devuelve <code>false</code> cuando no se puedan verificar ni
<var>f</var> ni su negaci&oacute;n.
</p>
<p><code>featurep</code> eval&uacute;a su argumento.
</p>
<p>V&eacute;anse tambi&eacute;n <code>declare</code> y <code>features</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) declare (j, even)$
(%i2) featurep (j, integer);
(%o2)                           true
</pre></dd></dl>



<dl>
<dt><u>Declaraci&oacute;n:</u> <b>features</b>
<a name="IDX426"></a>
</dt>
<dd><p>Maxima reconoce ciertas propiedades matem&aacute;ticas sobre funciones y variables.
</p>
<p>La llamada <code>declare (<var>x</var>, <var>foo</var>)</code> asocia la propiedad <var>foo</var> a la funci&oacute;n o variable <var>x</var>.
</p>
<p>La llamada <code>declare (<var>foo</var>, feature)</code> declara una nueva propiedad <var>foo</var>. 
Por ejemplo, <code>declare ([rojo, verde, azul], feature)</code> declara tres nuevas propiedades, 
<code>rojo</code>, <code>verde</code> y <code>azul</code>.
</p>
<p>El predicado <code>featurep (<var>x</var>, <var>foo</var>)</code>
devuelve <code>true</code> si <var>x</var> goza de la propiedad <var>foo</var>, y <code>false</code> en caso contrario.
</p>
<p>La lista <code>features</code> contiene las propiedades que reconoce Maxima; a saber,
</p>
<pre class="verbatim">   integer        noninteger      even
   odd            rational        irrational
   real           imaginary       complex
   analytic       increasing      decreasing
   oddfun         evenfun         posfun
   commutative    lassociative    rassociative
   symmetric      antisymmetric
</pre>
<p>junto con las definidas por el usuario.
</p>
<p>La lista <code>features</code> s&oacute;lo contiene propiedades matem&aacute;ticas. 
Hay otra lista con propiedades no matem&aacute;ticas; V&eacute;ase <code>status</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) declare (FOO, feature);
(%o1)                         done
(%i2) declare (x, FOO);
(%o2)                         done
(%i3) featurep (x, FOO);
(%o3)                         true
</pre></dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>get</b><i> (<var>a</var>, <var>i</var>)</i>
<a name="IDX427"></a>
</dt>
<dd><p>Recupera la propiedad de usuario indicada por <var>i</var> asociada al &aacute;tomo <var>a</var> 
o devuelve <code>false</code> si <var>a</var> no tiene la propiedad <var>i</var>.
</p>
<p>La funci&oacute;n <code>get</code> eval&uacute;a sus argumentos.
</p>
<p>V&eacute;anse tambi&eacute;n <code>put</code> y <code>qput</code>.
</p>
<pre class="example">(%i1) put (%e, 'transcendental, 'type);
(%o1)                    transcendental
(%i2) put (%pi, 'transcendental, 'type)$
(%i3) put (%i, 'algebraic, 'type)$
(%i4) typeof (expr) := block ([q],
        if numberp (expr)
        then return ('algebraic),
        if not atom (expr)
        then return (maplist ('typeof, expr)),
        q: get (expr, 'type),
        if q=false
        then errcatch (error(expr,&quot;is not numeric.&quot;)) else q)$
(%i5) typeof (2*%e + x*%pi);
x is not numeric.
(%o5)  [[transcendental, []], [algebraic, transcendental]]
(%i6) typeof (2*%e + %pi);
(%o6)     [transcendental, [algebraic, transcendental]]
</pre></dd></dl>


<dl>
<dt><u>Propiedad:</u> <b>integer</b>
<a name="IDX428"></a>
</dt>
<dt><u>Propiedad:</u> <b>noninteger</b>
<a name="IDX429"></a>
</dt>
<dd><p><code>declare(<var>a</var>, integer)</code> o <code>declare(<var>a</var>, noninteger)</code> indica a
Maxima que reconozca <var>a</var> como una variable entera o no entera.
</p>
<p>V&eacute;ase tambi&eacute;n <code>declare</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) declare(n, integer, x, noninteger);
(%o1)                         done
(%i2) askinteger(n);
(%o2)                          yes
(%i3) askinteger(x);
(%o3)                          no
</pre></dd></dl>



<dl>
<dt><u>Propiedad:</u> <b>integervalued</b>
<a name="IDX430"></a>
</dt>
<dd><p><code>declare(<var>f</var>, integervalued)</code> indica a MAxima que reconozca <var>f</var> como
una funci&oacute;n que toma valores enteros.
</p>
<p>V&eacute;ase tambi&eacute;n <code>declare</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) exp(%i)^f(x);
                              %i f(x)
(%o1)                      (%e  )
(%i2) declare(f, integervalued);
(%o2)                         done
(%i3) exp(%i)^f(x);
                              %i f(x)
(%o3)                       %e
</pre></dd></dl>



<dl>
<dt><u>Propiedad:</u> <b>nonarray</b>
<a name="IDX431"></a>
</dt>
<dd><p>La instrucci&oacute;n <code>declare(a, nonarray)</code> le indica a Maxima que
no considere <var>a</var> como un array. Esta declaraci&oacute;n evita la 
evaluaci&oacute;n m&uacute;ltiple de <var>a</var>, si &eacute;sta es una variable subindicada.
</p>
<p>V&eacute;ase tambi&eacute;n <code>declare</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) a:'b$ b:'c$ c:'d$

(%i4) a[x];
(%o4)                          d
                                x
(%i5) declare(a, nonarray);
(%o5)                         done
(%i6) a[x];
(%o6)                          a
                                x
</pre></dd></dl>


<dl>
<dt><u>Propiedad:</u> <b>nonscalar</b>
<a name="IDX432"></a>
</dt>
<dd><p>Hace que los &aacute;tomos se comporten como hace una lista o matriz 
con respecto del operador <code>.</code> del la multiplicaci&oacute;n no conmutativa.
</p>
<p>V&eacute;ase tambi&eacute;n <code>declare</code>.
</p></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>nonscalarp</b><i> (<var>expr</var>)</i>
<a name="IDX433"></a>
</dt>
<dd><p>Devuelve <code>true</code> si <var>expr</var> no es escalar, es decir, 
si contiene &aacute;tomos declarados como no escalares, listas o matrices. 
</p></dd></dl>


<dl>
<dt><u>Declaraci&oacute;n:</u> <b>posfun</b>
<a name="IDX434"></a>
</dt>
<dd><p>La instrucci&oacute;n <code>declare (f, posfun)</code> declara a <code>f</code> como 
funci&oacute;n positiva, de forma que 
<code>is (f(x) &gt; 0)</code> devolver&aacute; <code>true</code>.
</p>
<p>V&eacute;ase tambi&eacute;n <code>declare</code>.
</p></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>printprops</b><i> (<var>a</var>, <var>i</var>)</i>
<a name="IDX435"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>printprops</b><i> ([<var>a_1</var>, ..., <var>a_n</var>], <var>i</var>)</i>
<a name="IDX436"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>printprops</b><i> (all, <var>i</var>)</i>
<a name="IDX437"></a>
</dt>
<dd><p>Muestra la propiedad con el indicador <var>i</var> asociado 
con el &aacute;tomo <var>a</var>. <var>a</var> puede ser tambi&eacute;n una lista de
&aacute;tomos o el &aacute;tomo <code>all</code> en cuyo caso todos los &aacute;tomos a los cuales se les haya dado esa propiedad ser&aacute;n usados. 
Por ejemplo, <code>printprops ([f, g], atvalue)</code>. <code>printprops</code> es 
para propiedades que no pueden ser mostradas de otra manera, i.e. para
<code>atvalue</code>, <code>atomgrad</code>, <code>gradef</code>, y <code>matchdeclare</code>.
</p>
</dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>properties</b><i> (<var>a</var>)</i>
<a name="IDX438"></a>
</dt>
<dd><p>Devuelve una lista con los nombres de todas las propiedades asociadas
al t'omo <var>a</var>.
</p></dd></dl>


<dl>
<dt><u>Variable del sistema:</u> <b>props</b>
<a name="IDX439"></a>
</dt>
<dd><p>Valor por defecto: <code>[]</code>
</p>
<p><code>props</code> son t'omos que tienen asociadas otras propiedades adem&aacute;s de las
expl&iacute;citamente mencionadas en <code>infolists</code>, tales como las
especificadas por <code>atvalue</code>, <code>matchdeclare</code> y la funci&oacute;n 
<code>declare</code>.
</p></dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>propvars</b><i> (<var>prop</var>)</i>
<a name="IDX440"></a>
</dt>
<dd><p>Devuelve la lista con los &aacute;tomos de la lista <code>props</code> que tienen
la propiedad indicada por <var>prop</var>. As&iacute;, <code>propvars (atvalue)</code> 
devuelve la lista con los &aacute;tomos a los que se les ha asociado valores con
<code>atvalue</code>.
</p></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>put</b><i> (<var>&aacute;tomo</var>, <var>valor</var>, <var>indicador</var>)</i>
<a name="IDX441"></a>
</dt>
<dd><p>Asigna el <var>valor</var> a la propiedad  (especificada por <var>indicador</var>) de <var>&aacute;tomo</var>;
<var>indicador</var> puede ser el nombre de cualquier propiedad y no solamente de aquellas definidas por el sistema.
</p>
<p><code>rem</code> deshace la asignaci&oacute;n realizada por <code>put</code>.
</p>
<p>La funci&oacute;n <code>put</code> eval&uacute;a sus argumentos y devuelve <var>valor</var>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) put (foo, (a+b)^5, expr);
                                   5
(%o1)                       (b + a)
(%i2) put (foo, &quot;Hello&quot;, str);
(%o2)                         Hello
(%i3) properties (foo);
(%o3)            [[user properties, str, expr]]
(%i4) get (foo, expr);
                                   5
(%o4)                       (b + a)
(%i5) get (foo, str);
(%o5)                         Hello
</pre>
</dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>qput</b><i> (<var>&aacute;tomo</var>, <var>valor</var>, <var>indicador</var>)</i>
<a name="IDX442"></a>
</dt>
<dd><p>Asigna <var>valor</var> a la propiedad de <var>&aacute;tomo</var> que especifique <var>indicador</var>.
Act&uacute;a del mismo modeo que <code>put</code>, excepto que sus argumentos no son evaluados.
</p>
<p>V&eacute;ase tambi&eacute;n <code>get</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) foo: aa$ 
(%i2) bar: bb$
(%i3) baz: cc$
(%i4) put (foo, bar, baz);
(%o4)                          bb
(%i5) properties (aa);
(%o5)                [[user properties, cc]]
(%i6) get (aa, cc);
(%o6)                          bb
(%i7) qput (foo, bar, baz);
(%o7)                          bar
(%i8) properties (foo);
(%o8)            [value, [user properties, baz]]
(%i9) get ('foo, 'baz);
(%o9)                          bar
</pre></dd></dl>




<dl>
<dt><u>Propiedad:</u> <b>rational</b>
<a name="IDX443"></a>
</dt>
<dt><u>Propiedad:</u> <b>irrational</b>
<a name="IDX444"></a>
</dt>
<dd><p><code>declare(<var>a</var>, rational)</code> o <code>declare(<var>a</var>, irrational)</code> indica a
Maxima que reconozca <var>a</var> como una variable real racional o irracional.
</p>
<p>V&eacute;ase tambi&eacute;n <code>declare</code>.
</p></dd></dl>



<dl>
<dt><u>Propiedad:</u> <b>real</b>
<a name="IDX445"></a>
</dt>
<dt><u>Propiedad:</u> <b>imaginary</b>
<a name="IDX446"></a>
</dt>
<dt><u>Propiedad:</u> <b>complex</b>
<a name="IDX447"></a>
</dt>
<dd><p><code>declare(<var>a</var>, real)</code>, <code>declare(<var>a</var>, imaginary)</code> o
<code>declare(<var>a</var>, complex)</code> indican a Maxima que reconozca <var>a</var> como variable real,
imaginaria puro o compleja, respectivamente.
</p>
<p>V&eacute;ase tambi&eacute;n <code>declare</code>.
</p></dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>rem</b><i> (<var>&aacute;tomo</var>, <var>indicador</var>)</i>
<a name="IDX448"></a>
</dt>
<dd><p>Elimina del <var>&aacute;tomo</var> la propiedad indicada por <var>indicador</var>.
<code>rem</code> deshace la asignaci&oacute;n realizada por <code>put</code>.
</p>
<p><code>rem</code> devuelve <code>done</code> si <var>&aacute;tomo</var> ten&iacute;a la 
propiedad <var>indicador</var> cuando <code>rem</code> fue invocado, devolviendo
<code>false</code> si carec&iacute;a tal propiedad.
</p>
</dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>remove</b><i> (<var>a_1</var>, <var>p_1</var>, ..., <var>a_n</var>, <var>p_n</var>)</i>
<a name="IDX449"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>remove</b><i> ([<var>a_1</var>, ..., <var>a_m</var>], [<var>p_1</var>, ..., <var>p_n</var>], ...)</i>
<a name="IDX450"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>remove</b><i> (&quot;<var>a</var>&quot;, operator)</i>
<a name="IDX451"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>remove</b><i> (<var>a</var>, transfun)</i>
<a name="IDX452"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>remove</b><i> (all, <var>p</var>)</i>
<a name="IDX453"></a>
</dt>
<dd><p>Elimina propiedades asociadas con &aacute;tomos.
</p>
<p>La llamada <code>remove (<var>a_1</var>, <var>p_1</var>, ..., <var>a_n</var>, <var>p_n</var>)</code>
elimina la propiedad <code>p_k</code> del &aacute;tomo <code>a_k</code>.
</p>
<p>La llamada <code>remove ([<var>a_1</var>, ..., <var>a_m</var>], [<var>p_1</var>, ..., <var>p_n</var>], ...)</code>
elimina las propiedades <code><var>p_1</var>, ..., <var>p_n</var></code> de los &aacute;tomos <var>a_1</var>, ..., <var>a_m</var>. Puede tener m&aacute;s de un par de listas.
</p>
<p>La llamada <code>remove (all, <var>p</var>)</code> elimina la propiedad <var>p</var> de todos los &aacute;tomos que la tengan.
</p>
<p>Las propiedades eliminadas pueden ser de las que define el sistema, como 
<code>function</code>, <code>macro</code> o <code>mode_declare</code>; <code>remove</code> no elimina
las propiedades definidas por <code>put</code>.
</p>
<p>La llamada <code>remove (&quot;<var>a</var>&quot;, operator)</code> o su equivalente <code>remove (&quot;<var>a</var>&quot;, op)</code> elimina de  <var>a</var> las propiedades de operador declaradas por <code>prefix</code>, <code>infix</code>, <code>nary</code>, <code>postfix</code>, <code>matchfix</code> o <code>nofix</code>. N&oacute;tese que el nombre del operador debe escribirse como cadena precedida de ap&oacute;strofo.
</p>
<p>La funci&oacute;n <code>remove</code> devuelve siempre <code>done</code> independientemente que haya alg&uacute;n &aacute;tomo con la propiedad especificada.
</p>
<p>La funci&oacute;n <code>remove</code> no eval&uacute;a sus argumentos.
</p></dd></dl>


<dl>
<dt><u>Propiedad:</u> <b>scalar</b>
<a name="IDX454"></a>
</dt>
<dd><p><code>declare(<var>a</var>, scalar)</code> indica a Maxima que considere a <var>a</var> como
una variable escalar.
</p>
<p>V&eacute;ase tambi&eacute;n <code>declare</code>.
</p></dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>scalarp</b><i> (<var>expr</var>)</i>
<a name="IDX455"></a>
</dt>
<dd><p>Devuelve <code>true</code> si <var>expr</var> es un n&uacute;mero, constante  o variable 
declarada como <code>scalar</code> con <code>declare</code>, o compuesta completamente de tales 
n&uacute;meros, constantes o variables, pero que no contengan matrices ni listas.
</p></dd></dl>







<hr size="6">
<a name="Funciones-y-variables-para-los-hechos"></a>
<a name="SEC73"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC72" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC74" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC68" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_12.html#SEC75" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 11.3 Funciones y variables para los hechos </h2>


<dl>
<dt><u>Funci&oacute;n:</u> <b>activate</b><i> (<var>context_1</var>, ..., <var>context_n</var>)</i>
<a name="IDX456"></a>
</dt>
<dd><p>Activa los contextos <var>context_1</var>, ..., <var>context_n</var>.
Los hechos en estos contextos est&aacute;n disponibles para hacer deducciones y extraer informaci&oacute;n.
Los hechos en estos contextos no se listan al invocar <code>facts ()</code>.
</p>
<p>La variable <code>activecontexts</code> es la lista de contextos que se han activado por medio de la funci&oacute;n <code>activate</code>.
</p>
</dd></dl>




<dl>
<dt><u>Variable del sistema:</u> <b>activecontexts</b>
<a name="IDX457"></a>
</dt>
<dd><p>Valor por defecto: <code>[]</code>
</p>
<p>La variable <code>activecontexts</code> es la lista de contextos que se han activado por medio de la funci&oacute;n <code>activate</code>, pero que no se han activado por ser subcontextos del contexto actual.
</p>
</dd></dl>






<dl>
<dt><u>Funci&oacute;n:</u> <b>askinteger</b><i> (<var>expr</var>, integer)</i>
<a name="IDX458"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>askinteger</b><i> (<var>expr</var>)</i>
<a name="IDX459"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>askinteger</b><i> (<var>expr</var>, even)</i>
<a name="IDX460"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>askinteger</b><i> (<var>expr</var>, odd)</i>
<a name="IDX461"></a>
</dt>
<dd><p>La llamada <code>askinteger (<var>expr</var>, integer)</code> intenta determinar a partir de la base de datos de <code>assume</code> si <var>expr</var> es un entero. La funci&oacute;n <code>askinteger</code> pide m&aacute;s informaci&oacute;n al usuario si no encuentra la respuesta,
tratando de almacenar la nueva informaci&oacute;n en la base de datos si es posible. La llamada 
<code>askinteger (<var>expr</var>)</code> equivale a <code>askinteger (<var>expr</var>, integer)</code>.
</p>
<p>La llamadas <code>askinteger (<var>expr</var>, even)</code> ay <code>askinteger (<var>expr</var>, odd)</code> intentan determinar si <var>expr</var> es un entero par o impar, respectivamente.
</p>
</dd></dl>




<dl>
<dt><u>Funci&oacute;n:</u> <b>asksign</b><i> (<var>expr</var>)</i>
<a name="IDX462"></a>
</dt>
<dd><p>Primero intenta determinar si la expresi&oacute;n especificada es positiva, negativa o cero.  Si no lo consigue, plantear&aacute; al usuario preguntas que le ayuden a conpletar la deducci&oacute;n. Las respuestas del usuario son almacenadas en la base de datos durante el tiempo que dure este c&aacute;lculo. El valor que al final devuelva <code>asksign</code> ser&aacute; <code>pos</code>, <code>neg</code> o <code>zero</code>.
</p>
</dd></dl>




<dl>
<dt><u>Funci&oacute;n:</u> <b>assume</b><i> (<var>pred_1</var>, ..., <var>pred_n</var>)</i>
<a name="IDX463"></a>
</dt>
<dd><p>A&ntilde;ade los predicados <var>pred_1</var>, ..., <var>pred_n</var> al contexto actual.
Si un predicado es inconsistente o redundante con los otros predicados
del contexto actual, entonces no es a&ntilde;adido al contexto. 
El contexto va acumulando predicados con cada llamada a <code>assume</code>.
</p>
<p>La funci&oacute;n <code>assume</code> devuelve una lista cuyos miembros son los 
predicados que han sido a&ntilde;adidos al contexto, o los &aacute;tomos 
<code>redundant</code> o <code>inconsistent</code> si fuere necesario.
</p>
<p>Los predicados <var>pred_1</var>, ..., <var>pred_n</var> tan solo pueden ser
expresiones formadas con los operadores relacionales <code>&lt; &lt;= equal notequal &gt;=</code>
y <code>&gt;</code>. Los predicados no pueden estar formados por expresiones que sean del
tipo igualdad <code>=</code> ni del tipo desigualdad <code>#</code>, ni tampoco pueden ser
funciones de predicado como <code>integerp</code>.
</p>
<p>En cambio, s&iacute; se reconocen predicados compuestos de la forma 
<code><var>pred_1</var> and ... and <var>pred_n</var></code>, pero no 
<code><var>pred_1</var> or ... or <var>pred_n</var></code>.
Tambi&eacute;n se reconoce <code>not <var>pred_k</var></code> si <var>pred_k</var> es un
predicado relacional. Expresiones de la forma <code>not (<var>pred_1</var> and <var>pred_2</var>)</code>
y <code>not (<var>pred_1</var> or <var>pred_2</var>)</code> no son reconocidas.
</p>
<p>El mecanismo deductivo de Maxima no es muy potente; existen muchas 
consecuencias que, siendo obvias, no pueden ser obtenidas por <code>is</code>.
Se trata de una debilidad reconocida.
</p>
<p><code>assume</code> no gestiona predicados con n&uacute;meros complejos. Si un
predicado contiene un n&uacute;mero complejo, <code>assume</code> devuelve
<code>inconsistent</code> o <code>redunant</code>.
</p>
<p>La funci&oacute;n <code>assume</code> eval&uacute;a sus argumentos.
</p>
<p>V&eacute;anse tambi&eacute;n <code>is</code>, <code>facts</code>, <code>forget</code>, <code>context</code> y <code>declare</code>.
</p>
<p>Ejemplos:
</p>

<pre class="example">(%i1) assume (xx &gt; 0, yy &lt; -1, zz &gt;= 0);
(%o1)              [xx &gt; 0, yy &lt; - 1, zz &gt;= 0]
(%i2) assume (aa &lt; bb and bb &lt; cc);
(%o2)                  [bb &gt; aa, cc &gt; bb]
(%i3) facts ();
(%o3)     [xx &gt; 0, - 1 &gt; yy, zz &gt;= 0, bb &gt; aa, cc &gt; bb]
(%i4) is (xx &gt; yy);
(%o4)                         true
(%i5) is (yy &lt; -yy);
(%o5)                         true
(%i6) is (sinh (bb - aa) &gt; 0);
(%o6)                         true
(%i7) forget (bb &gt; aa);
(%o7)                       [bb &gt; aa]
(%i8) prederror : false;
(%o8)                         false
(%i9) is (sinh (bb - aa) &gt; 0);
(%o9)                        unknown
(%i10) is (bb^2 &lt; cc^2);
(%o10)                       unknown
</pre>
</dd></dl>




<dl>
<dt><u>Variable opcional:</u> <b>assumescalar</b>
<a name="IDX464"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>La variable <code>assumescalar</code> ayuda a controlar si una expresi&oacute;n <code>expr</code> para la cual <code>nonscalarp (expr)</code> es <code>false</code> va a tener un comportamiento similar a un escalar bajo ciertas transformaciones.
</p>
<p>Sea <code>expr</code> cualquier expresi&oacute;n distinta de una lista o matriz, y sea tambi&eacute;n <code>[1, 2, 3]</code> una lista o una matriz. Entonces, <code>expr . [1, 2, 3]</code> dar&aacute; como resultado <code>[expr, 2 expr, 3 expr]</code> si <code>assumescalar</code> es <code>true</code>, o si <code>scalarp (expr)</code> es <code>true</code>, o si <code>constantp (expr)</code> es <code>true</code>.
</p>
<p>Si <code>assumescalar</code> vale <code>true</code>, la expresi&oacute;n se comportar&aacute; como un escalar s&oacute;lo en operaciones conmutativas, pero no en el caso de la multiplicaci&oacute;n no conmutativa o producto matricial <code>.</code>.
</p>
<p>Si <code>assumescalar</code> vale <code>false</code>, la expresi&oacute;n se comportar&aacute; como un no escalar.
</p>
<p>Si <code>assumescalar</code> vale <code>all</code>, la expresi&oacute;n se comportar&aacute; como un escalar para todas las operaciones.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>assume_pos</b>
<a name="IDX465"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>assume_pos</code> vale <code>true</code> y el signo de un par&aacute;metro <var>x</var> no puede ser determinado a partir del contexto actual o de otras consideraciones, <code>sign</code> y <code>asksign (<var>x</var>)</code> devolver&aacute;n <code>true</code>. Con esto se pueden evitar algunas preguntas al usuario que se generan autom&aacute;ticamente, como las que hacen <code>integrate</code> y otras funciones.
</p>
<p>By default, a parameter is <var>x</var> such that <code>symbolp (<var>x</var>)</code>
or <code>subvarp (<var>x</var>)</code>.
</p>
<p>Por defecto, un par&aacute;metro <var>x</var> es aquel para el que <code>symbolp (<var>x</var>)</code> o <code>subvarp (<var>x</var>)</code> devuelven <code>true</code>.
La clase de expresiones que se consideran par&aacute;metros se puede extender mediante la utilizaci&oacute;n de la variable <code>assume_pos_pred</code>.
</p>
<p>Las funciones <code>sign</code> y <code>asksign</code> intentan deducir el signo de una expresi&oacute;n a partir de los signos de los operandos que contiene. Por ejemplo, si <code>a</code> y <code>b</code> son ambos positivos, entonces <code>a + b</code> tambi&eacute;n es positivo.
</p>
<p>Sin embargo, no es posible obviar todas las preguntas que hace <code>asksign</code>. En particular, cuando el argumento de <code>asksign</code> es una diferencia <code><var>x</var> - <var>y</var></code> o un logaritmo <code>log(<var>x</var>)</code>, <code>asksign</code> siempre solicita una respuesta por parte del usuario, incluso cuando <code>assume_pos</code> vale <code>true</code> y <code>assume_pos_pred</code> es una funci&oacute;n que devuelve <code>true</code> para todos los argumentos.
</p>
</dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>assume_pos_pred</b>
<a name="IDX466"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Cuando a <code>assume_pos_pred</code> se le asigna el nombre de una funci&oacute;n o una expresi&oacute;n lambda de un &uacute;nico argumento <var>x</var>, &eacute;sta ser&aacute; invocada para determinar si <var>x</var> se considera un par&aacute;metro por <code>assume_pos</code>. La variable 
<code>assume_pos_pred</code> se ignora cuando <code>assume_pos</code> vale <code>false</code>.
</p>
<p>La funci&oacute;n <code>assume_pos_pred</code> es invocada por  <code>sign</code> y por <code>asksign</code> con un argumento <var>x</var>, el cual puede ser un &aacute;tomo, una variable subindicada o una expresi&oacute;n de llamada a una funci&oacute;n. Si la funci&oacute;n <code>assume_pos_pred</code> devuelve <code>true</code>, <var>x</var> ser&aacute; considerada como un par&aacute;metro por <code>assume_pos</code>.
</p>
<p>Por defecto, un par&aacute;metro <var>x</var> es aquel para el que <code>symbolp (<var>x</var>)</code> o <code>subvarp (<var>x</var>)</code> devuelven <code>true</code>.
</p>
<p>V&eacute;anse tambi&eacute;n <code>assume</code> y <code>assume_pos</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) assume_pos: true$
(%i2) assume_pos_pred: symbolp$
(%i3) sign (a);
(%o3)                          pos
(%i4) sign (a[1]);
(%o4)                          pnz
(%i5) assume_pos_pred: lambda ([x], display (x), true)$
(%i6) asksign (a);
                              x = a

(%o6)                          pos
(%i7) asksign (a[1]);
                             x = a
                                  1

(%o7)                          pos
(%i8) asksign (foo (a));
                           x = foo(a)

(%o8)                          pos
(%i9) asksign (foo (a) + bar (b));
                           x = foo(a)

                           x = bar(b)

(%o9)                          pos
(%i10) asksign (log (a));
                              x = a

Is  a - 1  positive, negative, or zero?

p;
(%o10)                         pos
(%i11) asksign (a - b);
                              x = a

                              x = b

                              x = a

                              x = b

Is  b - a  positive, negative, or zero?

p;
(%o11)                         neg
</pre>
</dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>context</b>
<a name="IDX467"></a>
</dt>
<dd><p>Valor por defecto: <code>initial</code>
</p>
<p>La variable <code>context</code> da nombre al conjunto de hechos establecidos desde <code>assume</code> y <code>forget</code>. La funci&oacute;n <code>assume</code> a&ntilde;ade nuevos hechos al conjunto nombrado por <code>context</code>, mientras que <code>forget</code> los va eliminando.
Asignando a <code>context</code> un nuevo nombre <var>foo</var> cambia el contexto actual a <var>foo</var>. Si el contexto <var>foo</var> no existe todav&iacute;a, se crea autom&aacute;ticamente mediante una llamada a <code>newcontext</code>.
</p>
<p>V&eacute;ase <code>contexts</code> para una descripci&oacute;n general del mecanismo que siguen los contextos.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>contexts</b>
<a name="IDX468"></a>
</dt>
<dd><p>Valor por defecto: <code>[initial, global]</code>
</p>
<p>La variable <code>contexts</code> es una lista que contiene los contextos existentes, incluyendo el actualmente activo.
</p>
<p>El mecanismo que siguen los contextos permiten al usuario agrupar y nombrar un conjunto de hechos, que recibe el nombre de contexto. Una vez hecho esto, el usuario puede hacer que Maxima tenga en cuenta o que olvide cualquier n&uacute;mero de hechos sin m&aacute;s que activar o desactivar su contexto.
</p>
<p>Cualquier &aacute;tomo simb&oacute;lico puede ser el nombre de un contexto, y los hechos contenidos en tal contexto pueden ser almacenados hasta que se destruyan uno a uno mediante llamadas a la funci&oacute;n <code>forget</code>, o que se destruyan conjuntamente invocando a <code>kill</code> para eliminar el contexto al que pertenecen.
</p>
<p>Los contextos tienen estructura jer&aacute;rquica, siendo su ra&iacute;z el contexto <code>global</code>, el cual contiene informaci&oacute;n sobre Maxima que necesitan algunas funciones. Cuando en un contexto todos los hechos est&aacute;n activos (lo que significa que est&aacute;n siendo utilizados en deducciones) lo estar&aacute;n tambi&eacute;n en cualquier subcontexto del contexto actual.
</p>
<p>Cuando se comienza una sesi&oacute;n de Maxima, el usuario estar&aacute; trabajando en un contexto llamado <code>initial</code>, el cual tiene un subcontexto de nombre <code>global</code>.
</p>
<p>V&eacute;anse tambi&eacute;n <code>facts</code>, <code>newcontext</code>, <code>supcontext</code>, <code>killcontext</code>, <code>activate</code>, <code>deactivate</code>, <code>assume</code> y <code>forget</code>.
</p>
</dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>deactivate</b><i> (<var>contexto_1</var>, ..., <var>contexto_n</var>)</i>
<a name="IDX469"></a>
</dt>
<dd><p>Desactiva los contextos especificados <var>contexto_1</var>, ..., <var>contexto_n</var>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>facts</b><i> (<var>item</var>)</i>
<a name="IDX470"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>facts</b><i> ()</i>
<a name="IDX471"></a>
</dt>
<dd><p>Si <var>item</var> es el nombre de un contexto,
<code>facts (<var>item</var>)</code> devuelve una lista
con los hechos asociados al contexto especificado.
</p>
<p>Si <var>item</var> no es el nombre de un contexto,
<code>facts (<var>item</var>)</code> devuelve una lista con los hechos conocidos acerca de <var>item</var> en el contexto actual. Los hechos que est&eacute;n activos en contextos diferentes no aparecen en la lista.
</p>
<p>La llamada <code>facts ()</code>, sin argumentos, muestra el contexto actual.
</p>
</dd></dl>




<dl>
<dt><u>Funci&oacute;n:</u> <b>forget</b><i> (<var>pred_1</var>, ..., <var>pred_n</var>)</i>
<a name="IDX472"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>forget</b><i> (<var>L</var>)</i>
<a name="IDX473"></a>
</dt>
<dd><p>Borra los predicados establecidos por <code>assume</code>. Los predicados pueden ser expresiones equivalentes, pero no necesariamente id&eacute;nticas, a las establecidas por <code>assume</code>.
</p>
<p>La llamada <code>forget (<var>L</var>)</code>, siendo <var>L</var> una lista de predicados, borra todos los predicados contenidos en ella.
</p>
</dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>is</b><i> (<var>expr</var>)</i>
<a name="IDX474"></a>
</dt>
<dd><p>Intenta determinar si el predicado <var>expr</var>  se puede deducir de los hechos almacenados en la base de datos gestionada por <code>assume</code>.
</p>
<p>Si el predicado se reduce a <code>true</code> o <code>false</code>,
<code>is</code> devuelve <code>true</code> o <code>false</code>, respectivamente.
En otro caso, el valor devuelto est&aacute; controlado por la variable global <code>prederror</code>.
Si <code>prederror</code> vale <code>true</code>, <code>is</code> emite un mensaje de error;
en caso contrario, <code>is</code> devuelve <code>unknown</code>.
</p>
<p>La instrucci&oacute;n <code>ev(<var>expr</var>, pred)</code>
(que puede escribirse como <code><var>expr</var>, pred</code> en el
modo interactivo) equivale a <code>is(<var>expr</var>)</code>.
</p>
<p>V&eacute;anse tambi&eacute;n <code>assume</code>, <code>facts</code> y <code>maybe</code>.
</p>
<p>Ejemplos:
</p>
<p><code>is</code> eval&uacute;a los predicados,
</p>
<pre class="example">(%i1) %pi &gt; %e;
(%o1)                       %pi &gt; %e
(%i2) is (%pi &gt; %e);
(%o2)                         true
</pre>
<p><code>is</code> intenta evaluar predicados a partir 
del conocimiento almacenado en la base de datos de <code>assume</code>.
</p>
<pre class="example">(%i1) assume (a &gt; b);
(%o1)                        [a &gt; b]
(%i2) assume (b &gt; c);
(%o2)                        [b &gt; c]
(%i3) is (a &lt; b);
(%o3)                         false
(%i4) is (a &gt; c);
(%o4)                         true
(%i5) is (equal (a, c));
(%o5)                         false
</pre>
<p>Si <code>is</code> no puede evaluar el valor l&oacute;gico del predicado 
a partir de la base de datos gestionada por <code>assume</code>,
la variable global  <code>prederror</code> controla el comportamiento de <code>is</code>.
</p>
<pre class="example">(%i1) assume (a &gt; b);
(%o1)                        [a &gt; b]
(%i2) prederror: true$
(%i3) is (a &gt; 0);
Maxima was unable to evaluate the predicate:
a &gt; 0
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) prederror: false$
(%i5) is (a &gt; 0);
(%o5)                        unknown
</pre>
</dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>killcontext</b><i> (<var>contexto_1</var>, ..., <var>contexto_n</var>)</i>
<a name="IDX475"></a>
</dt>
<dd><p>Elimina los contextos <var>contexto_1</var>, ..., <var>contexto_n</var>.
</p>
<p>Si alguno de estos contextos es el actual, el nuevo contexto activo ser&aacute; el primer subcontexto disponible del actual que no haya sido eliminado. Si el primer contexto no eliminado disponible es <code>global</code> entonces <code>initial</code> ser&aacute; usado en su lugar.  Si el contexto <code>initial</code> es eliminado, se crear&aacute; un nuevo contexto <code>initial</code> completamente vac&iacute;o.
</p>
<p>La funci&oacute;n <code>killcontext</code> no elimina un contexto actualmente activo si es un subcontexto del contexto actual, o si se hace uso de la funci&oacute;n <code>activate</code>.
</p>
<p>La funci&oacute;n <code>killcontext</code> eval&uacute;a sus argumentos y devuelve <code>done</code>.
</p>
</dd></dl>




<dl>
<dt><u>Funci&oacute;n:</u> <b>maybe</b><i> (<var>expr</var>)</i>
<a name="IDX476"></a>
</dt>
<dd><p>Intenta determinar si el predicado <var>expr</var>  se puede deducir de los hechos almacenados en la base de datos gestionada por <code>assume</code>.
</p>
<p>Si el predicado se reduce a <code>true</code> o <code>false</code>,
<code>maybe</code> devuelve <code>true</code> o <code>false</code>, respectivamente.
En otro caso, <code>maybe</code> devuelve <code>unknown</code>.
</p>
<p>La funci&oacute;n <code>maybe</code> es funcionalmente equivalente a <code>is</code> con <code>prederror: false</code>,
pero el resultado se calcula sin asignar valor alguno a <code>prederror</code>.
</p>
<p>V&eacute;anse tambi&eacute;n <code>assume</code>, <code>facts</code> y <code>is</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) maybe (x &gt; 0);
(%o1)                        unknown
(%i2) assume (x &gt; 1);
(%o2)                        [x &gt; 1]
(%i3) maybe (x &gt; 0);
(%o3)                         true
</pre>
</dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>newcontext</b><i> (<var>nombre</var>)</i>
<a name="IDX477"></a>
</dt>
<dd><p>Crea un nuevo contexto vac&iacute;o <var>nombre</var>, el cual tiene a <code>global</code> como su &uacute;nico subcontexto. El reci&eacute;n creado contexto pasa a ser el contexto actualmente activo.
</p>
<p>La funci&oacute;n <code>newcontext</code> eval&uacute;a sus argumentos y devuelve <var>nombre</var>.
</p>
</dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>sign</b><i> (<var>expr</var>)</i>
<a name="IDX478"></a>
</dt>
<dd><p>Intenta determinar el signo de <var>expr</var> en base a los hechos almacenados en la base de datos. Devuelve una de las siguientes respuestas: <code>pos</code> (positivo), <code>neg</code> (negativo), <code>zero</code> (cero), <code>pz</code>
(positivo o cero), <code>nz</code> (negativo o cero), <code>pn</code> (positivo o negativo),
o <code>pnz</code> (positivo, negativo o cero, lo que significa que el signo es desconocido).
</p>
</dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>supcontext</b><i> (<var>nombre</var>, <var>contexto</var>)</i>
<a name="IDX479"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>supcontext</b><i> (<var>nombre</var>)</i>
<a name="IDX480"></a>
</dt>
<dd><p>Crea un nuevo contexto <var>nombre</var>, que tiene a <var>contexto</var> como subcontexto. El argumento
<var>contexto</var> debe existir ya.
</p>
<p>Si no se especifica <var>context</var>, se tomar&aacute; como tal el actual.
</p>
</dd></dl>









<hr size="6">
<a name="Funciones-y-variables-para-los-predicados"></a>
<a name="SEC74"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC73" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_12.html#SEC75" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC68" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_12.html#SEC75" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 11.4 Funciones y variables para los predicados </h2>


<dl>
<dt><u>Funci&oacute;n:</u> <b>charfun</b><i> (<var>p</var>)</i>
<a name="IDX481"></a>
</dt>
<dd><p>Devuelve 0 cuando el predicado <var>p</var> toma el valor <code>false</code>, y devuelve
1 cuando vale <code>true</code>.  Si el predicado toma un valor diferente de <code>true</code> y <code>false</code> (desconocido), 
entonces devuelve una forma nominal.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) charfun(x&lt;1);
(%o1) charfun(x&lt;1)
(%i2) subst(x=-1,%);
(%o2) 1
(%i3) e : charfun('&quot;and&quot;(-1 &lt; x, x &lt; 1))$
(%i4) [subst(x=-1,e), subst(x=0,e), subst(x=1,e)];
(%o4) [0,1,0]
</pre>
</dd></dl>




<dl>
<dt><u>Funci&oacute;n:</u> <b>compare</b><i> (<var>x</var>, <var>y</var>)</i>
<a name="IDX482"></a>
</dt>
<dd><p>Devuelve un operador de comparaci&oacute;n <var>op</var>
(<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>=</code> o <code>#</code>) de manera que
<code>is (<var>x</var> <var>op</var> <var>y</var>)</code> tome el valor <code>true</code>;
cuando tanto <var>x</var> como <var>y</var> dependan de <code>%i</code> y
<code><var>x</var> # <var>y</var></code>, devuelve <code>notcomparable</code>;
cuando no exista tal operador o Maxima sea incapaz de determinarlo, devolver&aacute; <code>unknown</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) compare(1,2);
(%o1) &lt;
(%i2) compare(1,x);
(%o2) unknown
(%i3) compare(%i,%i);
(%o3) =
(%i4) compare(%i,%i+1);
(%o4) notcomparable
(%i5) compare(1/x,0);
(%o5) #
(%i6) compare(x,abs(x));
(%o6) &lt;=
</pre>
<p>La funci&oacute;n <code>compare</code> no intenta determinar si los dominios reales de sus argumentos son conjuntos no vac&iacute;os; as&iacute;,
</p>
<pre class="example">(%i1) compare(acos(x^2+1), acos(x^2+1) + 1);
(%o1) &lt;
</pre>
<p>Aqu&iacute;, el dominio real de <code>acos (x^2 + 1)</code> es el conjunto vac&iacute;o.
</p>
</dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>equal</b><i> (<var>a</var>, <var>b</var>)</i>
<a name="IDX483"></a>
</dt>
<dd><p>Representa la equivalencia, esto es, la igualdad de los valores.
</p>
<p>Por s&iacute; misma, <code>equal</code> no eval&uacute;a ni simplifica.
La funci&oacute;n <code>is</code> intenta evaluar <code>equal</code> a un resultado
booleano. La instrucci&oacute;n <code>is(equal(<var>a</var>, <var>b</var>))</code>
devuelve <code>true</code> (o <code>false</code>) si y s&oacute;lo si
<var>a</var> y <var>b</var> son iguales (o no iguales) para todos los posibles
valores de sus variables, tal como lo determina <code>ratsimp(<var>a</var> - <var>b</var>)</code>;
si <code>ratsimp</code> devuelve 0, las dos expresiones se consideran
equivalentes. Dos expresiones pueden ser equivalentes  sin
ser sint&aacute;cticamente iguales (es decir, id&eacute;nticas).
</p>
<p>Si <code>is</code> no consigue reducir <code>equal</code> a <code>true</code> o <code>false</code>,
el resultado est&aacute; controlado por la variable global <code>prederror</code>.
Si <code>prederror</code> vale <code>true</code>, <code>is</code> emite un mensaje
de error; en caso contrario, <code>is</code> devuelve <code>unknown</code>.
</p>
<p>Adem&aacute;s de <code>is</code>, otros operadores eval&uacute;an <code>equal</code> y <code>notequal</code>
a  <code>true</code> o <code>false</code>; a saber, <code>if</code>, <code>and</code>, <code>or</code> y <code>not</code>.
</p>
<p>La negaci&oacute;n de <code>equal</code> es <code>notequal</code>.
</p>
<p>Ejemplos:
</p>
<p>Por s&iacute; misma, <code>equal</code> no eval&uacute;a ni simplifica.
</p>
<pre class="example">(%i1) equal (x^2 - 1, (x + 1) * (x - 1));
                        2
(%o1)            equal(x  - 1, (x - 1) (x + 1))
(%i2) equal (x, x + 1);
(%o2)                    equal(x, x + 1)
(%i3) equal (x, y);
(%o3)                      equal(x, y)
</pre>
<p>La funci&oacute;n <code>is</code> intenta evaluar <code>equal</code> a un resultado
booleano. La instrucci&oacute;n <code>is(equal(<var>a</var>, <var>b</var>))</code>
devuelve <code>true</code> si <code>ratsimp(<var>a</var> - <var>b</var>)</code>
devuelve 0. Dos expresiones pueden ser equivalentes  sin
ser sint&aacute;cticamente iguales (es decir, id&eacute;nticas).
</p>
<pre class="example">(%i1) ratsimp (x^2 - 1 - (x + 1) * (x - 1));
(%o1)                           0
(%i2) is (equal (x^2 - 1, (x + 1) * (x - 1)));
(%o2)                         true
(%i3) is (x^2 - 1 = (x + 1) * (x - 1));
(%o3)                         false
(%i4) ratsimp (x - (x + 1));
(%o4)                          - 1
(%i5) is (equal (x, x + 1));
(%o5)                         false
(%i6) is (x = x + 1);
(%o6)                         false
(%i7) ratsimp (x - y);
(%o7)                         x - y
(%i8) is (equal (x, y));
(%o8)                        unknown
(%i9) is (x = y);
(%o9)                         false
</pre>
<p>Si <code>is</code> no consigue reducir <code>equal</code> a <code>true</code> o <code>false</code>,
el resultado est&aacute; controlado por la variable global <code>prederror</code>.
</p>
<pre class="example">(%i1) [aa : x^2 + 2*x + 1, bb : x^2 - 2*x - 1];
                    2             2
(%o1)             [x  + 2 x + 1, x  - 2 x - 1]
(%i2) ratsimp (aa - bb);
(%o2)                        4 x + 2
(%i3) prederror : true;
(%o3)                         true
(%i4) is (equal (aa, bb));
Maxima was unable to evaluate the predicate:
       2             2
equal(x  + 2 x + 1, x  - 2 x - 1)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) prederror : false;
(%o5)                         false
(%i6) is (equal (aa, bb));
(%o6)                        unknown
</pre>
<p>Otros operadores eval&uacute;an <code>equal</code> y <code>notequal</code>
a  <code>true</code> o <code>false</code>.
</p>
<pre class="example">(%i1) if equal (y, y - 1) then FOO else BAR;
(%o1)                          BAR
(%i2) eq_1 : equal (x, x + 1);
(%o2)                    equal(x, x + 1)
(%i3) eq_2 : equal (y^2 + 2*y + 1, (y + 1)^2);
                         2                   2
(%o3)             equal(y  + 2 y + 1, (y + 1) )
(%i4) [eq_1 and eq_2, eq_1 or eq_2, not eq_1];
(%o4)                  [false, true, true]
</pre>
<p>Debido a que <code>not <var>expr</var></code>
obliga a la evaluaci&oacute;n previa de <var>expr</var>, 
<code>not equal(<var>a</var>, <var>b</var>)</code> equivale a <code>is(notequal(<var>a</var>, <var>b</var>))</code>.
</p>
<pre class="example">(%i1) [notequal (2*z, 2*z - 1), not equal (2*z, 2*z - 1)];
(%o1)            [notequal(2 z, 2 z - 1), true]
(%i2) is (notequal (2*z, 2*z - 1));
(%o2)                         true
</pre></dd></dl>




<dl>
<dt><u>Funci&oacute;n:</u> <b>notequal</b><i> (<var>a</var>, <var>b</var>)</i>
<a name="IDX484"></a>
</dt>
<dd><p>Representa la negaci&oacute;n de <code>equal (<var>a</var>, <var>b</var>)</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) equal (a, b);
(%o1)                      equal(a, b)
(%i2) maybe (equal (a, b));
(%o2)                        unknown
(%i3) notequal (a, b);
(%o3)                    notequal(a, b)
(%i4) not equal (a, b);
(%o4)                    notequal(a, b)
(%i5) maybe (notequal (a, b));
(%o5)                        unknown
(%i6) assume (a &gt; b);
(%o6)                        [a &gt; b]
(%i7) equal (a, b);
(%o7)                      equal(a, b)
(%i8) maybe (equal (a, b));
(%o8)                         false
(%i9) notequal (a, b);
(%o9)                    notequal(a, b)
(%i10) maybe (notequal (a, b));
(%o10)                        true
</pre>
</dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>unknown</b><i> (<var>expr</var>)</i>
<a name="IDX485"></a>
</dt>
<dd><p>Devuelve <code>true</code> si y s&oacute;lo si <var>expr</var> contiene un operador o funci&oacute;n no reconocido por el simplificador de Maxima.
</p>
</dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>zeroequiv</b><i> (<var>expr</var>, <var>v</var>)</i>
<a name="IDX486"></a>
</dt>
<dd><p>Analiza si la expresi&oacute;n <var>expr</var> de variable <var>v</var> equivale a cero, devolviendo <code>true</code>, <code>false</code> o
<code>dontknow</code>.
</p>
<p>La funci&oacute;n <code>zeroequiv</code> tiene estas restricciones:
</p><ol>
<li>
No utilizar funciones que Maxima no sepa derivar y evaluar.
</li><li>
Si la expresi&oacute;n tiene polos en la recta real, pueden aparecer errores en el resultado, aunque es poco probable.
</li><li>
Si la expresi&oacute;n contiene funciones que no son soluciones de ecuaciones diferenciales ordinarias de primer orden (como las funciones de Bessel) pueden presentarse resultados incorrectos.
</li><li>
El algoritmo utiliza evaluaciones en puntos aleatoriamente seleccionados. Esto conlleva un riesgo,aunque el algoritmo intenta minimizar el error.
</li></ol>

<p>Por ejemplo, <code>zeroequiv (sin(2*x) - 2*sin(x)*cos(x), x)</code> devuelve
<code>true</code> y <code>zeroequiv (%e^x + x, x)</code> devuelve <code>false</code>.
Por otro lado <code>zeroequiv (log(a*b) - log(a) - log(b), a)</code> devuelve <code>dontknow</code> debido a la presencia del par&aacute;metro <code>b</code>.
</p>
</dd></dl>


<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_12.html#SEC75" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Robert</em> on <em>diciembre, 10 2012</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
