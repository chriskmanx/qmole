<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on diciembre, 10 2012 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual de Maxima: 14. Polinomios</title>

<meta name="description" content="Manual de Maxima: 14. Polinomios">
<meta name="keywords" content="Manual de Maxima: 14. Polinomios">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body
{
    color: black;
    background: white; 
    margin-left: 8%;
    margin-right: 13%;
}

h1
{
    margin-left: +8%;
    font-size: 150%;
    font-family: sans-serif
}

h2
{
    font-size: 125%;
    font-family: sans-serif
}

h3
{
    font-size: 100%;
    font-family: sans-serif
}

h2,h3,h4,h5,h6 { margin-left: +4%; }

div.textbox
{
    border: solid;
    border-width: thin;
    /* width: 100%; */
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em
}

div.titlebox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
    background: rgb(200,255,255);
    font-family: sans-serif
}

div.synopsisbox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
     background: rgb(255,220,255);
    /*background: rgb(200,255,255); */
    /* font-family: fixed */
}

pre.example
{
    border: 1px solid gray;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 1em;
    padding-right: 1em;
    /* background: rgb(247,242,180); */ /* kind of sandy */
    /* background: rgb(200,255,255); */ /* sky blue */
    background-color: #F1F5F9; /* light blue-gray */
    /* font-family: "Lucida Console", monospace */
}

div.spacerbox
{
    border: none;
    padding-top: 2em;
    padding-bottom: 2em
}

div.image
{
    margin: 0;
    padding: 1em;
    text-align: center;
}

div.categorybox
{
    border: 1px solid gray;
    padding-top: 0px;
    padding-bottom: 0px;
    padding-left: 1em;
    padding-right: 1em;
    background: rgb(247,242,220);
}


-->
</style>

<link rel="icon" href="http://maxima.sourceforge.net/favicon.ico"/>
</head>

<body lang="es" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Polinomios"></a>
<a name="SEC88"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_13.html#SEC87" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC89" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_13.html#SEC82" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_15.html#SEC91" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 14. Polinomios </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC89">14.1 Introducci&oacute;n a los polinomios</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC90">14.2 Funciones y variables para polinomios</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
</table>

<hr size="6">
<a name="Introducci_00f3n-a-los-polinomios"></a>
<a name="SEC89"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC88" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC90" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC88" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC88" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_15.html#SEC91" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 14.1 Introducci&oacute;n a los polinomios </h2>

<p>Los polinomios se almacenan en Maxima, bien en un formato general, bien en una forma conocida como can&oacute;nica (Cannonical Rational Expressions, CRE). La &uacute;ltima corresponde al formato est&aacute;ndar y se utiliza internamente para realizar operaciones como <code>factor</code>, <code>ratsimp</code> y dem&aacute;s.
</p>
<p>Las Expresiones Racionales Can&oacute;nicas (CRE) constituyen un tipo de representaci&oacute;n
que es especialmente apropiado para expandir polinomios y funciones racionales
(as&iacute; como para polinomios parcialmente factorizados y funciones racionales cuando a la variable <code>ratfac</code> se le asigna el valor <code>true</code>). En esta forma CRE las variables se ordenan de mayor a menor. Los polinomios se representan recursivamente como una lista compuesta por la variable principal seguida por una serie de pares de expresiones,
una por cada t&eacute;rmino del polinomio. El primer miembro
de cada par es el exponente de la variable principal en ese t&eacute;rmino y el
segundo miembro es el coeficiente de ese t&eacute;rmino, el cual puede ser un n&uacute;mero o
un polinomio en otra variable representado tambi&eacute;n de esta forma. As&iacute;,
la parte principal de la forma CRE de 3*X^2-1 es (X 2 3 0 -1) y la de
2*X*Y+X-3 es (Y 1 (X 1 2) 0 (X 1 1 0 -3)) asumiendo que Y es la variable principal, y ser&aacute; (X 1 (Y 1 2 0 1) 0 -3) si se asume que la variable principal es X. Qu&eacute; variable se considera &quot;principal&quot; se determinada en orden alfab&eacute;tico inverso.
Las &quot;variables&quot; de la expresi&oacute;n CRE no son necesariamente at&oacute;micas. De hecho
cualquier subexpresi&oacute;n cuyo operador principal no es + - * / ni ^ con potencia entera
puede ser considerada como una &quot;variable&quot; de la expresi&oacute;n (en forma CRE) en 
el cual aparezca. Por ejemplo las variables CRE de la expresi&oacute;n
X+SIN(X+1)+2*SQRT(X)+1 son X, SQRT(X)  y SIN(X+1).  Si el usuario no
especifica una ordenaci&oacute;n de las variables mediante la funci&oacute;n <code>ratvars</code> 
Maxima escoger&aacute; una alfab&eacute;ticamente. En general, laa CRE representan expresiones
racionales, esto es, fracciones de polinomios, donde el numerador y
el denominador  no tienen factores comunes, siendo el denominador es
positivo. La forma interna es esencialmente un par de polinomios (el
numerador y el denominador) precedida por la lista de variables ordenadas. Si
una expresi&oacute;n a ser mostrada est&aacute; en la forma CRE o contiene alguna
subexpresi&oacute;n en forma de CRE, el simbolo /R/ ser&aacute; seguido por la etiqueta de la l&iacute;nea de comando.
V&eacute;ase la funci&oacute;n <code>rat</code> para convertir una expresi&oacute;n a la forma CRE. Una
extensi&oacute;n de la forma CRE se utiliza para la representaci&oacute;n de las series de Taylor. La
noci&oacute;n de una expresi&oacute;n racional se extiende de manera que los exponentes de las
variables pueden ser n&uacute;meros racionales positivos o negativos y no s&oacute;lo
enteros positivos y los coeficientes pueden ser tambi&eacute;n expresiones
racionales y no s&oacute;lo polinomios. Estas expresiones se representan internamente por una forma polinomial recursiva que es similar a la forma CRE, pero que la generaliza, aportando informaci&oacute;n adicional como el grado de truncamiento. Como con la forma CRE, el s&iacute;mbolo /T/ sigue la etiqueta de l&iacute;nea de comando en la que se encuentra dicha expresi&oacute;n.
</p>







<hr size="6">
<a name="Funciones-y-variables-para-polinomios"></a>
<a name="SEC90"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC89" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_15.html#SEC91" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC88" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC88" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_15.html#SEC91" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 14.2 Funciones y variables para polinomios </h2>

<dl>
<dt><u>Variable opcional:</u> <b>algebraic</b>
<a name="IDX603"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>La variable <code>algebraic</code> debe valer <code>true</code> para que se pueda hacer la simplificaci&oacute;n de enteros algebraicos.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>berlefact</b>
<a name="IDX604"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>berlefact</code> vale <code>false</code> entonces se utiliza el algoritmo de factorizaci&oacute;n de Kronecker, en caso contrario se utilizar&aacute; el algoritmo de Berlekamp, que es el que se aplica por defecto.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>bezout</b><i> (<var>p1</var>, <var>p2</var>, <var>x</var>)</i>
<a name="IDX605"></a>
</dt>
<dd><p>Es una alternativa a la funci&oacute;n <code>resultant</code>.  Devuelve una matriz.
</p>
<pre class="example">(%i1) bezout(a*x+b, c*x^2+d, x);
                         [ b c  - a d ]
(%o1)                    [            ]
                         [  a     b   ]
(%i2) determinant(%);
                            2      2
(%o2)                      a  d + b  c
(%i3) resultant(a*x+b, c*x^2+d, x);
                            2      2
(%o3)                      a  d + b  c
</pre></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>bothcoef</b><i> (<var>expr</var>, <var>x</var>)</i>
<a name="IDX606"></a>
</dt>
<dd><p>Devuelve una lista cuyo primer miembro es el coeficiente de <var>x</var> en <var>expr</var> (que coincide con el que devuelve <code>ratcoef</code> si <var>expr</var> est&aacute; en formato CRE, o el que devuelve <code>coeff</code> si no est&aacute; en este formato) y cuyo segundo miembro es la parte restante de <var>expr</var>. Esto es, <code>[A, B]</code> donde <code><var>expr</var> = A*<var>x</var> + B</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) islinear (expr, x) := block ([c],
        c: bothcoef (rat (expr, x), x),
        is (freeof (x, c) and c[1] # 0))$
(%i2) islinear ((r^2 - (x - r)^2)/x, x);
(%o2)                         true
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>coeff</b><i> (<var>expr</var>, <var>x</var>, <var>n</var>)</i>
<a name="IDX607"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>coeff</b><i> (<var>expr</var>, <var>x</var>)</i>
<a name="IDX608"></a>
</dt>
<dd><p>Devuelve el coeficiente de <code><var>x</var>^<var>n</var></code> en <var>expr</var>,
donde <var>expr</var> es un polinomio o monomio en <var>x</var>.
</p>
<p><code>coeff(<var>expr</var>, <var>x</var>^<var>n</var>)</code> es equivalente a
<code>coeff(<var>expr</var>, <var>x</var>, <var>n</var>)</code>.
<code>coeff(<var>expr</var>, <var>x</var>, 0)</code> devuelve el resto de <var>expr</var>,
el cual no contiene a <var>x</var>. En caso de omisi&oacute;n, se entiende
que <var>n</var> es igual a 1.
</p>
<p><var>x</var> puede ser tanto el nombre de una variable simple como el
de una variable con sub&iacute;ndice, o tambi&eacute;n una
subexpresi&oacute;n de <var>expr</var> que contenga un operador junto con
todos sus argumentos.
</p>
<p>En ocasiones, es posible calcular los coeficientes de expresiones
equivalentes a <var>expr</var> aplicando <code>expand</code> o <code>factor</code>.
<code>coeff</code> no aplica ni <code>expand</code>, ni <code>factor</code>, ni ninguna otra
funci&oacute;n.
</p>
<p><code>coeff</code> se distribuye sobre listas, matrices y ecuaciones.
</p>
<p>Ejemplos:
</p>
<p><code>coeff</code> devuelve el coeficiente de <code><var>x</var>^<var>n</var></code> en <var>expr</var>.
</p>
<pre class="example">(%i1) coeff (b^3*a^3 + b^2*a^2 + b*a + 1, a^3);
                                3
(%o1)                          b
</pre>
<p><code>coeff(<var>expr</var>, <var>x</var>^<var>n</var>)</code> es equivalente
a <code>coeff(<var>expr</var>, <var>x</var>, <var>n</var>)</code>.
</p>
<pre class="example">(%i1) coeff (c[4]*z^4 - c[3]*z^3 - c[2]*z^2 + c[1]*z, z, 3);
(%o1)                         - c
                                 3
(%i2) coeff (c[4]*z^4 - c[3]*z^3 - c[2]*z^2 + c[1]*z, z^3);
(%o2)                         - c
                                 3
</pre>
<p><code>coeff(<var>expr</var>, <var>x</var>, 0)</code> devuelve el resto de <var>expr</var>,
el cual no contiene a <var>x</var>.
</p>
<pre class="example">(%i1) coeff (a*u + b^2*u^2 + c^3*u^3, b, 0);
                            3  3
(%o1)                      c  u  + a u
</pre>
<p><var>x</var> puede ser tanto el nombre de una variable simple como el
de una variable con sub&iacute;ndice, o tambi&eacute;n una
subexpresi&oacute;n de <var>expr</var> que contenga un operador junto con
todos sus argumentos.
</p>
<pre class="example">(%i1) coeff (h^4 - 2*%pi*h^2 + 1, h, 2);
(%o1)                        - 2 %pi
(%i2) coeff (v[1]^4 - 2*%pi*v[1]^2 + 1, v[1], 2);
(%o2)                        - 2 %pi
(%i3) coeff (sin(1 + x)*sin(x) + sin(1 + x)^3*sin(x)^3, sin(1 + x)^3);
                                3
(%o3)                        sin (x)
(%i4) coeff ((d - a)^2*(b + c)^3 + (a + b)^4*(c - d), a + b, 4);
(%o4)                         c - d
</pre>
<p><code>coeff</code> no aplica ni <code>expand</code>, ni <code>factor</code>, ni ninguna otra
funci&oacute;n.
</p>
<pre class="example">(%i1) coeff (c*(a + b)^3, a);
(%o1)                           0
(%i2) expand (c*(a + b)^3);
                 3          2        2        3
(%o2)           b  c + 3 a b  c + 3 a  b c + a  c
(%i3) coeff (%, a);
                                2
(%o3)                        3 b  c
(%i4) coeff (b^3*c + 3*a*b^2*c + 3*a^2*b*c + a^3*c, (a + b)^3);
(%o4)                           0
(%i5) factor (b^3*c + 3*a*b^2*c + 3*a^2*b*c + a^3*c);
                                  3
(%o5)                      (b + a)  c
(%i6) coeff (%, (a + b)^3);
(%o6)                           c
</pre>
<p><code>coeff</code> se distribuye sobre listas, matrices y ecuaciones.
</p>
<pre class="example">(%i1) coeff ([4*a, -3*a, 2*a], a);
(%o1)                      [4, - 3, 2]
(%i2) coeff (matrix ([a*x, b*x], [-c*x, -d*x]), x);
                          [  a    b  ]
(%o2)                     [          ]
                          [ - c  - d ]
(%i3) coeff (a*u - b*v = 7*u + 3*v, u);
(%o3)                         a = 7
</pre></dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>content</b><i> (<var>p_1</var>, <var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX609"></a>
</dt>
<dd><p>Devuelve una lista cuyo primer miembro es el m&aacute;ximo com&uacute;n divisor de los coeficientes de los t&eacute;rminos del polinomio <var>p_1</var> de variable <var>x_n</var> (este es el contenido) y cuyo segundo miembro es el polinomio <var>p_1</var> dividido por el contenido.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) content (2*x*y + 4*x^2*y^2, y);
                                   2
(%o1)                   [2 x, 2 x y  + y]
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>denom</b><i> (<var>expr</var>)</i>
<a name="IDX610"></a>
</dt>
<dd><p>Devuelve el denominador de la expresi&oacute;n racional <var>expr</var>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>divide</b><i> (<var>p_1</var>, <var>p_2</var>, <var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX611"></a>
</dt>
<dd><p>Calcula el cociente y el resto del polinomio <var>p_1</var> dividido por el polinomio <var>p_2</var>, siendo la variable principal <var>x_n</var>.
Las otras funciones son como en la funci&oacute;n <code>ratvars</code>. El resultado es una lista cuyo primer miembro es el cociente y el segundo miembro el resto.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) divide (x + y, x - y, x);
(%o1)                       [1, 2 y]
(%i2) divide (x + y, x - y);
(%o2)                      [- 1, 2 x]
</pre>

<p>N&oacute;tese que <code>y</code> es la variable principal en el segundo ejemplo.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>eliminate</b><i> ([<var>eqn_1</var>, ..., <var>eqn_n</var>], [<var>x_1</var>, ..., <var>x_k</var>])</i>
<a name="IDX612"></a>
</dt>
<dd><p>Elimina variables de ecuaciones (o de expresiones que se supone valen cero) tomando resultantes sucesivas. Devuelve una lista con <code><var>n</var> - <var>k</var></code> expresiones y <var>k</var> variables <var>x_1</var>, ..., <var>x_k</var> eliminadas.  Primero se elimina  <var>x_1</var> dando <code><var>n</var> - 1</code> expresiones, despu&eacute;s se elimina <code>x_2</code>, etc.  Si <code><var>k</var> = <var>n</var></code> entonces se devuelve una lista con una &uacute;nica expresi&oacute;n, libre de las variables <var>x_1</var>, ..., <var>x_k</var>. En este caso se llama a <code>solve</code> para resolver la &uacute;ltima resultante para la &uacute;ltima variable.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) expr1: 2*x^2 + y*x + z;
                                      2
(%o1)                    z + x y + 2 x
(%i2) expr2: 3*x + 5*y - z - 1;
(%o2)                  - z + 5 y + 3 x - 1
(%i3) expr3: z^2 + x - y^2 + 5;
                          2    2
(%o3)                    z  - y  + x + 5
(%i4) eliminate ([expr3, expr2, expr1], [y, z]);
             8         7         6          5          4
(%o4) [7425 x  - 1170 x  + 1299 x  + 12076 x  + 22887 x

                                    3         2
                            - 5154 x  - 1291 x  + 7688 x + 15376]
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>ezgcd</b><i> (<var>p_1</var>, <var>p_2</var>, <var>p_3</var>, ...)</i>
<a name="IDX613"></a>
</dt>
<dd><p>Devuelve una lista cuyo primer elemento es el m&aacute;ximo com&uacute;n divisor (mcd)
de los polinomios <var>p_1</var>, <var>p_2</var>, <var>p_3</var>, &hellip;,  siendo los 
miembros restantes los mismos polinomios divididos por el mcd. 
Se utiliza siempre el algoritmo <code>ezgcd</code>.
</p>
<p>V&eacute;anse tambi&eacute;n <code>gcd</code>, <code>gcdex</code>, <code>gcdivide</code> y <code>poly_gcd</code>.
</p>
<p>Ejemplos:
</p>
<p>Los tres polinomios tiene como m&aacute;ximo com&uacute;n divisor <code>2*x-3</code>,
el cual se calcula primero con la funci&oacute;n <code>gcd</code> y luego con
<code>ezgcd</code>.
</p>
<pre class="example">(%i1) p1 : 6*x^3-17*x^2+14*x-3;
                        3       2
(%o1)                6 x  - 17 x  + 14 x - 3
(%i2) p2 : 4*x^4-14*x^3+12*x^2+2*x-3;
                    4       3       2
(%o2)            4 x  - 14 x  + 12 x  + 2 x - 3
(%i3) p3 : -8*x^3+14*x^2-x-3;
                          3       2
(%o3)                - 8 x  + 14 x  - x - 3

(%i4) gcd(p1, gcd(p2, p3));
(%o4)                        2 x - 3

(%i5) ezgcd(p1, p2, p3);
                   2               3      2           2
(%o5) [2 x - 3, 3 x  - 4 x + 1, 2 x  - 4 x  + 1, - 4 x  + x + 1]
</pre>


</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>facexpand</b>
<a name="IDX614"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>La variable <code>facexpand</code> controla si los factores irreducibles devueltos por <code>factor</code> est&aacute;n en formato expandido (por defecto) o recursivo  (CRE normal).
</p>
</dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>factor</b><i> (<var>expr</var>)</i>
<a name="IDX615"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>factor</b><i> (<var>expr</var>, <var>p</var>)</i>
<a name="IDX616"></a>
</dt>
<dd><p>Factoriza la expresi&oacute;n <var>expr</var>, que puede contener
cualquier n&uacute;mero de variables o funciones, en factores 
irreducibles respecto de los enteros. La llamada 
<code>factor (<var>expr</var>, <var>p</var>)</code> factoriza <var>expr</var> 
en el campo de los racionales con un elemento a&ntilde;adido cuyo 
polinomio m&iacute;nimo es <var>p</var>.
</p>
<p>La funci&oacute;n <code>factor</code> utiliza a <code>ifactors</code> 
para factorizar enteros.
</p>
<p>Si la variable <code>factorflag</code> vale <code>false</code> suprime 
la factorizaci&oacute;n de los factores enteros en las expresiones racionales.
</p>
<p>La variable <code>dontfactor</code> puede contener una lista 
de variables con respecto a las cuales no se factorizar&aacute; 
(inicialmente est&aacute; vac&iacute;a). Tampoco se 
factorizar&aacute; respecto de cualesquiera otra variables que sean menos importantes (seg&uacute;n la ordenaci&oacute;n que se sigue en el formato CRE) que aquellas que se encuentran en la lista <code>dontfactor</code>.
</p>
<p>Si la variable <code>savefactors</code> vale <code>true</code>, los 
factores de una expresi&oacute;n en forma de producto se guardar&aacute;n 
por ciertas funciones a fin de acelerar posteriores factorizaciones 
de expresiones que contengan algunos de estos mismos factores.
</p>
<p>Si <code>berlefact</code> vale <code>false</code> entonces se utiliza el 
algoritmo de factorizaci&oacute;n de Kronecker, en caso contrario se 
utilizar&aacute; el algoritmo de Berlekamp, que es el que se aplica por defecto.
</p>
<p>Si la variable <code>intfaclim</code> vale <code>true</code>, Maxima desistir&aacute; de
factorizar enteros si no encuentra ning&uacute;n factor despu&eacute;s de las
divisiones tentativas y de aplicar el m&eacute;todo rho de Pollard. Si vale
<code>false</code> (este es el caso cuando el usuario invoca expl&iacute;citamente
a <code>factor</code>), se intentar&aacute; la factorizaci&oacute;n completa del entero. El valor
asignado a <code>intfaclim</code> se utiliza en llamadas internas a <code>factor</code>. As&iacute;,
se puede cambiar el valor de <code>intfaclim</code> para evitar que Maxima dedique
un tiempo prohibitivo a factorizar n&uacute;meros enteros grandes.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) factor (2^63 - 1);
                    2
(%o1)              7  73 127 337 92737 649657
(%i2) factor (-8*y - 4*x + z^2*(2*y + x));
(%o2)               (2 y + x) (z - 2) (z + 2)
(%i3) -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
                2  2        2    2    2
(%o3)          x  y  + 2 x y  + y  - x  - 2 x - 1
(%i4) block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
                       2
                     (x  + 2 x + 1) (y - 1)
(%o4)                ----------------------
                           36 (y + 1)
(%i5) factor (1 + %e^(3*x));
                      x         2 x     x
(%o5)              (%e  + 1) (%e    - %e  + 1)
(%i6) factor (1 + x^4, a^2 - 2);
                    2              2
(%o6)             (x  - a x + 1) (x  + a x + 1)
(%i7) factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
                       2
(%o7)              - (y  + x) (z - x) (z + x)
(%i8) (2 + x)/(3 + x)/(b + x)/(c + x)^2;
                             x + 2
(%o8)               ------------------------
                                           2
                    (x + 3) (x + b) (x + c)
(%i9) ratsimp (%);
                4                  3
(%o9) (x + 2)/(x  + (2 c + b + 3) x

     2                       2             2                   2
 + (c  + (2 b + 6) c + 3 b) x  + ((b + 3) c  + 6 b c) x + 3 b c )
(%i10) partfrac (%, x);
           2                   4                3
(%o10) - (c  - 4 c - b + 6)/((c  + (- 2 b - 6) c

     2              2         2                2
 + (b  + 12 b + 9) c  + (- 6 b  - 18 b) c + 9 b ) (x + c))

                 c - 2
 - ---------------------------------
     2                             2
   (c  + (- b - 3) c + 3 b) (x + c)

                         b - 2
 + -------------------------------------------------
             2             2       3      2
   ((b - 3) c  + (6 b - 2 b ) c + b  - 3 b ) (x + b)

                         1
 - ----------------------------------------------
             2
   ((b - 3) c  + (18 - 6 b) c + 9 b - 27) (x + 3)
(%i11) map ('factor, %);
              2
             c  - 4 c - b + 6                 c - 2
(%o11) - ------------------------- - ------------------------
                2        2                                  2
         (c - 3)  (c - b)  (x + c)   (c - 3) (c - b) (x + c)

                       b - 2                        1
            + ------------------------ - ------------------------
                             2                          2
              (b - 3) (c - b)  (x + b)   (b - 3) (c - 3)  (x + 3)
(%i12) ratsimp ((x^5 - 1)/(x - 1));
                       4    3    2
(%o12)                x  + x  + x  + x + 1
(%i13) subst (a, x, %);
                       4    3    2
(%o13)                a  + a  + a  + a + 1
(%i14) factor (%th(2), %);
                       2        3        3    2
(%o14)   (x - a) (x - a ) (x - a ) (x + a  + a  + a + 1)
(%i15) factor (1 + x^12);
                       4        8    4
(%o15)               (x  + 1) (x  - x  + 1)
(%i16) factor (1 + x^99);
                 2            6    3
(%o16) (x + 1) (x  - x + 1) (x  - x  + 1)

   10    9    8    7    6    5    4    3    2
 (x   - x  + x  - x  + x  - x  + x  - x  + x  - x + 1)

   20    19    17    16    14    13    11    10    9    7    6
 (x   + x   - x   - x   + x   + x   - x   - x   - x  + x  + x

    4    3            60    57    51    48    42    39    33
 - x  - x  + x + 1) (x   + x   - x   - x   + x   + x   - x

    30    27    21    18    12    9    3
 - x   - x   + x   + x   - x   - x  + x  + 1)
</pre>
</dd></dl>




<dl>
<dt><u>Variable opcional:</u> <b>factorflag</b>
<a name="IDX617"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>factorflag</code> vale <code>false</code> se evita la factorizaci&oacute;n de factores enteros de expresiones racionales.
</p></dd></dl>




<dl>
<dt><u>Funci&oacute;n:</u> <b>factorout</b><i> (<var>expr</var>, <var>x_1</var>, <var>x_2</var>, ...)</i>
<a name="IDX618"></a>
</dt>
<dd><p>Reorganiza la suma <var>expr</var> como una suma de t&eacute;rminos de la forma 
<code>f (<var>x_1</var>, <var>x_2</var>, ...)*g</code>, donde <code>g</code> es un producto 
de expresiones que no contienen ning&uacute;n <var>x_i</var> y <code>f</code> se factoriza.
</p>
<p>N&oacute;tese que <code>factorout</code> ignora la variable opcional <code>keepfloat</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) expand (a*(x+1)*(x-1)*(u+1)^2);
             2  2          2      2      2
(%o1)     a u  x  + 2 a u x  + a x  - a u  - 2 a u - a
(%i2) factorout(%,x);
         2
(%o2) a u  (x - 1) (x + 1) + 2 a u (x - 1) (x + 1)
                                              + a (x - 1) (x + 1)
</pre></dd></dl>




<dl>
<dt><u>Funci&oacute;n:</u> <b>factorsum</b><i> (<var>expr</var>)</i>
<a name="IDX619"></a>
</dt>
<dd><p>Intenta agrupar t&eacute;rminos en los factores de <var>expr</var> que son sumas en grupos de t&eacute;rminos tales que su suma sea factorizable. La funci&oacute;n <code>factorsum</code> puede restablecer el recuperar de <code>expand ((x + y)^2 + (z + w)^2)</code> pero no puede recuperar <code>expand ((x + 1)^2 + (x + y)^2)</code> porque los t&eacute;rminos tienen variables comunes.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
           2      2                            2      2
(%o1) a x z  + a z  + 2 a w x z + 2 a w z + a w  x + v  x

                                     2        2    2            2
                        + 2 u v x + u  x + a w  + v  + 2 u v + u
(%i2) factorsum (%);
                                   2          2
(%o2)            (x + 1) (a (z + w)  + (v + u) )
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>fasttimes</b><i> (<var>p_1</var>, <var>p_2</var>)</i>
<a name="IDX620"></a>
</dt>
<dd><p>Calcula el producto de los polinomios <var>p_1</var> y <var>p_2</var> utilizando un algoritmo especial. Los polinomios <code>p_1</code> y <code>p_2</code> deben ser multivariantes, densos y aproximadamente del mismo tama&ntilde;o. La multiplicaci&oacute;n cl&aacute;sica es de orden <code>n_1 n_2</code> donde <code>n_1</code> es el grado de  <code>p_1</code> y  <code>n_2</code> el grado de <code>p_2</code>. La funci&oacute;n <code>fasttimes</code> es de orden <code>max (n_1, n_2)^1.585</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>fullratsimp</b><i> (<var>expr</var>)</i>
<a name="IDX621"></a>
</dt>
<dd><p>Aplica repetidamente <code>ratsimp</code> a una expresi&oacute;n, seguida de simplificaciones no racionales, hasta que no se obtienen m&aacute;s transformaciones; entonces devuelve el resultado.
</p>
<p>En presencia de expresiones no racionales, una llamada a <code>ratsimp</code> seguida de una simplificaci&oacute;n no racional (&quot;general&quot;) puede no ser suficiente para conseguir un resultado simplificado. En ocasiones ser&aacute;n necesarias m&aacute;s de una llamada a <code>ratsimp</code>, que es lo que hace precisamente <code>fullratsimp</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
                       a/2     2   a/2     2
                     (x    - 1)  (x    + 1)
(%o1)                -----------------------
                              a
                             x  - 1
(%i2) ratsimp (expr);
                          2 a      a
                         x    - 2 x  + 1
(%o2)                    ---------------
                              a
                             x  - 1
(%i3) fullratsimp (expr);
                              a
(%o3)                        x  - 1
(%i4) rat (expr);
                       a/2 4       a/2 2
                     (x   )  - 2 (x   )  + 1
(%o4)/R/             -----------------------
                              a
                             x  - 1
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>fullratsubst</b><i> (<var>a</var>, <var>b</var>, <var>c</var>)</i>
<a name="IDX622"></a>
</dt>
<dd><p>Similar a <code>ratsubst</code> excepto por el hecho de que se llama a &iacute; misma recursivamente hasta que el resultado deja de cambiar. Esta funci&oacute;n es &uacute;til cuando la expresi&oacute;n a sustituir y la que la sustituye tienen variables comunes.
</p>
<p>La funci&oacute;n <code>fullratsubst</code> tambi&eacute;n acepta sus argumentos en el formato de <code>lratsubst</code>.
</p>
<p>Es necesario ejecutar <code>load (&quot;lrats&quot;)</code> para cargar <code>fullratsubst</code> y <code>lratsubst</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) load (&quot;lrats&quot;)$
</pre><ul>
<li>
<code>subst</code> puede hacer sustituciones m&uacute;ltiples;
<code>lratsubst</code> es an&aacute;loga a <code>subst</code>.
</li></ul>
<pre class="example">(%i2) subst ([a = b, c = d], a + c);
(%o2)                         d + b
(%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
(%o3)                (d + a c) e + a d + b c
</pre><ul>
<li>
Si s&oacute;lo se quiere una sustituci&oacute;n, entonces se puede dar una &uacute;nica ecuaci&oacute;n como primer argumento.
</li></ul>
<pre class="example">(%i4) lratsubst (a^2 = b, a^3);
(%o4)                          a b
</pre><ul>
<li>
<code>fullratsubst</code> equivale a <code>ratsubst</code>, 
excepto por el hecho de que se llama a &iacute; misma recursivamente hasta que el resultado deja de cambiar.
</li></ul>
<pre class="example">(%i5) ratsubst (b*a, a^2, a^3);
                               2
(%o5)                         a  b
(%i6) fullratsubst (b*a, a^2, a^3);
                                 2
(%o6)                         a b
</pre><ul>
<li>
<code>fullratsubst</code> tambi&eacute;n acepta una lista de ecuaciones o una s&oacute;la ecuaci&oacute;n como primer argumento.
</li></ul>
<pre class="example">(%i7) fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
(%o7)                           b
(%i8) fullratsubst (a^2 = b*a, a^3);
                                 2
(%o8)                         a b
</pre><ul>
<li>
<code>fullratsubst</code> puede caer en una recursi&oacute;n infinita.
</li></ul>
<pre class="example">(%i9) errcatch (fullratsubst (b*a^2, a^2, a^3));

*** - Lisp stack overflow. RESET
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>gcd</b><i> (<var>p_1</var>, <var>p_2</var>, <var>x_1</var>, ...)</i>
<a name="IDX623"></a>
</dt>
<dd><p>Devuelve el m&aacute;ximo com&uacute;n divisor de <var>p_1</var> y <var>p_2</var>.
La variable <code>gcd</code> determiona qu&eacute; algoritmo se va a utilizar.
Asign&aacute;ndole a <code>gcd</code> los valores <code>ez</code>, <code>subres</code>, <code>red</code>
o <code>spmod</code>, se seleccionan los algoritmos <code>ezgcd</code>, 
subresultante <code>prs</code>, reducido o modular, respectivamente.
Si <code>gcd</code> vale <code>false</code> entonces <code>gcd(<var>p_1</var>, 
<var>p_2</var>, <var>x</var>)</code> devolver&aacute; siempre 1 para cualquier <var>x</var>.
Muchas funciones (por ejemplo,  <code>ratsimp</code>, <code>factor</code>, etc.)
hacen uso de <code>gcd</code> impl&iacute;citamente.  
En caso de polinomios homog&eacute;neos se recomienda darle a 
<code>gcd</code> el valor <code>subres</code>.  Para calcular un m&aacute;ximo 
com&uacute;n divisor en presencia de ra&iacute;ces, como en
 <code>gcd (<var>x</var>^2 - 2*sqrt(2)*<var>x</var> + 2, <var>x</var> - sqrt(2))</code>,
la variable <code>algebraic</code> debe igualarse
a <code>true</code> y <code>gcd</code> no puede ser <code>ez</code>.
</p>
<p>Se recomienda utilizar el algoritmo <code>subres</code> en lugar de <code>red</code>,
por ser aqu&eacute;l m&aacute;s moderno.
</p>
<p>Si la variable <code>gcd</code>, cuyo valor por defecto es <code>spmod</code>,
vale <code>false</code>, no se calcular&aacute; el m&aacute;ximo com&uacute;n divisor 
cuando las expresiones se conviertan a su forma can&oacute;nica (CRE),
lo que redundar&aacute; en ocasiones en mayor rapidez de c&aacute;lculo.
</p>

</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>gcdex</b><i> (<var>f</var>, <var>g</var>)</i>
<a name="IDX624"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>gcdex</b><i> (<var>f</var>, <var>g</var>, <var>x</var>)</i>
<a name="IDX625"></a>
</dt>
<dd><p>Devuelve una lista <code>[<var>a</var>, <var>b</var>, <var>u</var>]</code> en la que <var>u</var> es el m&aacute;ximo com&uacute;n divisor (mcd) de <var>f</var> y <var>g</var>, e igual a <code><var>a</var> <var>f</var> + <var>b</var> <var>g</var></code>.
Los argumentos <var>f</var> y <var>g</var> deben ser polinomios univariantes, o indicarles la variable principal <var>x</var> en caso de ser multivariantes. 
</p>
<p>La funci&oacute;n <code>gcdex</code> implementa el algoritmo de Euclides, en el que tenemos una secuencia de <code>L[i]: [a[i], b[i], r[i]]</code> todos ellos ortogonales a <code>[f, g, -1]</code> siendo el siguiente calculado a partir de <code>q = quotient(r[i]/r[i+1])</code> y <code>L[i+2]: L[i] - q L[i+1]</code>; el proceso termina en <code>L[i+1]</code> cuando el resto <code>r[i+2]</code> se anula.
</p>

<pre class="example">(%i1) gcdex (x^2 + 1, x^3 + 4);
                       2
                      x  + 4 x - 1  x + 4
(%o1)/R/           [- ------------, -----, 1]
                           17        17
(%i2) % . [x^2 + 1, x^3 + 4, -1];
(%o2)/R/                        0
</pre>

</dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>gcfactor</b><i> (<var>n</var>)</i>
<a name="IDX626"></a>
</dt>
<dd><p>Factoriza el entero gaussiano <var>n</var> como producto, a su vez, de enteros gaussianos, (un entero gaussiano es de la forma<code><var>a</var> + <var>b</var> <code>%i</code></code> donde <var>a</var> y <var>b</var> son n&uacute;meros enteros). Los factores se normalizan de manera que tanto la parte real como imaginaria sean no negativas.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>gfactor</b><i> (<var>expr</var>)</i>
<a name="IDX627"></a>
</dt>
<dd><p>Factoriza el polinomio <var>expr</var> sobre los enteros gaussianos (un entero gaussiano es de la forma<code><var>a</var> + <var>b</var> <code>%i</code></code> donde <var>a</var> y <var>b</var> son n&uacute;meros enteros).
Es como <code>factor (<var>expr</var>, <var>a</var>^2+1)</code> donde <var>a</var> vale <code>%i</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) gfactor (x^4 - 1);
(%o1)           (x - 1) (x + 1) (x - %i) (x + %i)
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>gfactorsum</b><i> (<var>expr</var>)</i>
<a name="IDX628"></a>
</dt>
<dd><p>Esta funci&oacute;n es similar a <code>factorsum</code> pero aplica <code>gfactor</code> en lugar de <code>factor</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>hipow</b><i> (<var>expr</var>, <var>x</var>)</i>
<a name="IDX629"></a>
</dt>
<dd><p>Devuelve el mayor exponente expl&iacute;cito de  <var>x</var> en <var>expr</var>.
El argumento<var>x</var> puede ser una variable o una expresi&oacute;n general.
Si <var>x</var> no aparece en <var>expr</var>, <code>hipow</code> devuelve <code>0</code>.
</p>
<p>La funci&oacute;n <code>hipow</code> no tiene en cuenta expresiones equivalentes a <code>expr</code>.
En particular, <code>hipow</code> no expande <code>expr</code>, de manera que <code>hipow (<var>expr</var>, <var>x</var>)</code> y <code>hipow (expand (<var>expr</var>, <var>x</var>))</code> pueden dar resultados diferentes.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) hipow (y^3 * x^2 + x * y^4, x);
(%o1)                           2
(%i2) hipow ((x + y)^5, x);
(%o2)                           1
(%i3) hipow (expand ((x + y)^5), x);
(%o3)                           5
(%i4) hipow ((x + y)^5, x + y);
(%o4)                           5
(%i5) hipow (expand ((x + y)^5), x + y);
(%o5)                           0
</pre>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>intfaclim</b>
<a name="IDX630"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si vale <code>true</code>, Maxima  desistir&aacute; de
factorizar enteros si no encuentra ning&uacute;n factor despu&eacute;s de las
divisiones tentativas y de aplicar el m&eacute;todo rho de Pollard, por lo que 
la factorizaci&oacute;n puede quedar incompleta.
</p>
<p>Si vale <code>false</code> (este es el caso cuando el usuario invoca expl&iacute;citamente
a <code>factor</code>), se intentar&aacute; la factorizaci&oacute;n completa del entero. El valor
asignado a <code>intfaclim</code> se utiliza en llamadas internas a <code>factor</code>. A la variable
<code>intfaclim</code> se le asigna el valor <code>false</code> cuando se calculan factores desde las
funciones <code>divisors</code>, <code>divsum</code> y <code>totient</code>.
</p>
<p>Las llamadas internas a <code>factor</code> respetan el valor dado por el usuario a <code>intfaclim</code>.
Asignando a <code>intfaclim</code> el valor <code>true</code> se puede reducir  el tiempo que Maxima dedica a
factorizar enteros grandes.
</p>
</dd></dl>




<dl>
<dt><u>Variable opcional:</u> <b>keepfloat</b>
<a name="IDX631"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>keepfloat</code> vale <code>true</code>, los n&uacute;meros decimales en coma flotante no se racionalizan cuando las expresiones que los contienen se convierten al formato can&oacute;nico racional (CRE).
</p>
<p>N&oacute;tese que la funci&oacute;n <code>solve</code> y todas aquellas otras que la
invocan (por ejemplo, <code>eigenvalues</code>) ignoran esta variable, por
lo que hacen la conversi&oacute;n de los n&uacute;meros decimales.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) rat(x/2.0);

`rat' replaced 0.5 by 1/2 = 0.5
                                       x
(%o1)/R/                               -
                                       2
(%i2) rat(x/2.0), keepfloat;

(%o2)/R/                             0.5 x
</pre>
<p><code>solve</code> ignora <code>keepfloat</code>:
</p>
<pre class="example">(%i3) solve(1.0-x,x), keepfloat;

`rat' replaced 1.0 by 1/1 = 1.0
(%o3)                               [x = 1]
</pre></dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>lopow</b><i> (<var>expr</var>, <var>x</var>)</i>
<a name="IDX632"></a>
</dt>
<dd><p>Devuelve el menor exponente de <var>x</var> que aparece expl&iacute;citamente
en <var>expr</var>.
</p>
<pre class="example">(%i1) lopow ((x+y)^2 + (x+y)^a, x+y);
(%o1)                       min(a, 2)
</pre>
</dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>lratsubst</b><i> (<var>L</var>, <var>expr</var>)</i>
<a name="IDX633"></a>
</dt>
<dd><p>Esta funci&oacute;n es similar a <code>subst (<var>L</var>, <var>expr</var>)</code>, excepto por el hecho de que utiliza <code>ratsubst</code> en lugar de <code>subst</code>.
</p>
<p>El primer argumento de <code>lratsubst</code> es una ecuaci&oacute;n o lista de ecuaciones id&eacute;nticas en formato a las aceptadas por <code>subst</code>.  Las sustituciones se hacen en el orden dado por la lista de ecuaciones, esto es, de izquierda a derecha.
</p>
<p>La instrucci&oacute;n <code>load (&quot;lrats&quot;)</code> carga <code>fullratsubst</code> y <code>lratsubst</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) load (&quot;lrats&quot;)$
</pre><ul>
<li>
<code>subst</code> can carry out multiple substitutions.
<code>lratsubst</code> is analogous to <code>subst</code>.
</li></ul>
<pre class="example">(%i2) subst ([a = b, c = d], a + c);
(%o2)                         d + b
(%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
(%o3)                (d + a c) e + a d + b c
</pre><ul>
<li>
If only one substitution is desired, then a single
equation may be given as first argument.
</li></ul>
<pre class="example">(%i4) lratsubst (a^2 = b, a^3);
(%o4)                          a b
</pre>
</dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>modulus</b>
<a name="IDX634"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>modulus</code> es un n&uacute;mero positivo <var>p</var>, las operaciones con n&uacute;meros racionales
(como los devueltos por <code>rat</code> y funciones relacionadas) se realizan m&oacute;dulo <var>p</var>,
utilizando el llamado sistema de m&oacute;dulo balanceado, en el que <code><var>n</var> m&oacute;dulo <var>p</var></code>
se define como un entero <var>k</var> de <code>[-(<var>p</var>-1)/2, ..., 0, ..., (<var>p</var>-1)/2]</code>
si <var>p</var> es impar, o de <code>[-(<var>p</var>/2 - 1), ..., 0, ...., <var>p</var>/2]</code> si <var>p</var> es par,
de tal manera que <code><var>a</var> <var>p</var> + <var>k</var></code> es igual a <var>n</var> para alg&uacute;n entero <var>a</var>.
</p>
<p>Normalmente a <code>modulus</code> se le asigna un n&uacute;mero primo. Se acepta que a <code>modulus</code>
se le asigne un entero positivo no primo, pero se obtendr&aacute; un mensaje de aviso. Maxima 
responder&aacute; con un mensaje de error cuando se le asigne a <code>modulus</code> cero o un n&uacute;mero
negativo.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) modulus:7;
(%o1)                           7
(%i2) polymod([0,1,2,3,4,5,6,7]);
(%o2)            [0, 1, 2, 3, - 3, - 2, - 1, 0]
(%i3) modulus:false;
(%o3)                         false
(%i4) poly:x^6+x^2+1;
                            6    2
(%o4)                      x  + x  + 1
(%i5) factor(poly);
                            6    2
(%o5)                      x  + x  + 1
(%i6) modulus:13;
(%o6)                          13
(%i7) factor(poly);
                      2        4      2
(%o7)               (x  + 6) (x  - 6 x  - 2)
(%i8) polymod(%);
                            6    2
(%o8)                      x  + x  + 1
</pre></dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>num</b><i> (<var>expr</var>)</i>
<a name="IDX635"></a>
</dt>
<dd><p>Devuelve el numerador de <var>expr</var> si se trata de una fracci&oacute;n. Si <var>expr</var> no es una fracci&oacute;n, se devuelve <var>expr</var>.
</p>
<p>La funci&oacute;n <code>num</code> eval&uacute;a su argumento.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>polydecomp</b><i> (<var>p</var>, <var>x</var>)</i>
<a name="IDX636"></a>
</dt>
<dd><p>Descompone el polinomio <var>p</var> de variable <var>x</var> en una composici&oacute;n funcional de polinomios en <var>x</var>. 
La funci&oacute;n <code>polydecomp</code> devuelve una lista <code>[<var>p_1</var>, ..., <var>p_n</var>]</code> tal que 
</p>
<pre class="example">lambda([x],p_1)(lambda ([x],p_2)(...(lambda([x],p_n)(x))...))
</pre>
<p>es igual a  <var>p</var>.
El grado de <var>p_i</var> es mayor que 1 para <var>i</var> menor que <var>n</var>.
</p>
<p>Esta descomposici&oacute;n no es &uacute;nica.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) polydecomp (x^210, x);
                          7   5   3   2
(%o1)                   [x , x , x , x ]
(%i2) p : expand (subst (x^3 - x - 1, x, x^2 - a));
                6      4      3    2
(%o2)          x  - 2 x  - 2 x  + x  + 2 x - a + 1
(%i3) polydecomp (p, x);
                        2       3
(%o3)                 [x  - a, x  - x - 1]
</pre>
<p>La siguiente funci&oacute;n compone <code>L = [e_1, ..., e_n]</code> como funciones de <code>x</code>;
se trata de la inversa de <code>polydecomp</code>:
</p>
<pre class="example">compose (L, x) :=
  block ([r : x], for e in L do r : subst (e, x, r), r) $
</pre>
<p>Se vuelve a obtener el resultado del ejemplo de m&aacute;s arriba haciendo uso de <code>compose</code>:
</p>
<pre class="example">(%i3) polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
                        2       3
(%o3)                 [x  - a, x  - x - 1]
</pre>
<p>N&oacute;tese que aunque <code>compose (polydecomp (<var>p</var>, <var>x</var>), <var>x</var>)</code>
devuelve siempre <var>p</var> (sin expandir),
<code>polydecomp (compose ([<var>p_1</var>, ..., <var>p_n</var>], <var>x</var>), <var>x</var>)</code>  <i>no</i>
devuelve necesariamente <code>[<var>p_1</var>, ..., <var>p_n</var>]</code>:
</p>
<pre class="example">(%i4) polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
                          2       2
(%o4)                   [x  + 2, x  + 1]
(%i5) polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
                      2       2
                     x  + 3  x  + 5
(%o5)               [------, ------, 2 x + 1]
                       4       2
</pre>
</dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>polymod</b><i> (<var>p</var>)</i>
<a name="IDX637"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>polymod</b><i> (<var>p</var>, <var>m</var>)</i>
<a name="IDX638"></a>
</dt>
<dd><p>Convierte el polinomio <var>p</var> a una representaci&oacute;n modular respecto del m&oacute;dulo actual, que es el valor almacenado en la variable <code>modulus</code>.  
</p>
<p>La llamada <code>polymod (<var>p</var>, <var>m</var>)</code> especifica un m&oacute;dulo <var>m</var> para ser utilizado en lugar de valor almacenado en <code>modulus</code>.
</p>
<p>V&eacute;ase <code>modulus</code>.
</p></dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>powers</b><i> (<var>expr</var>, <var>x</var>)</i>
<a name="IDX639"></a>
</dt>
<dd><p>Devuelve las potencias de <var>x</var> dentro de <var>expr</var>.
</p>
<p>La instrucci&oacute;n <code>load (powers)</code> carga esta funci&oacute;n.
</p>

</dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>quotient</b><i> (<var>p_1</var>, <var>p_2</var>)</i>
<a name="IDX640"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>quotient</b><i> (<var>p_1</var>, <var>p_2</var>, <var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX641"></a>
</dt>
<dd><p>Devuelve el polinomio <var>p_1</var> dividido por el polinomio <var>p_2</var>. Los argumentos <var>x_1</var>, ..., <var>x_n</var> se interpretan como en la funci&oacute;n <code>ratvars</code>.
</p>
<p>La funci&oacute;n <code>quotient</code> devuelve el primer elemento de la lista devuelta por <code>divide</code>.
</p>
</dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>rat</b><i> (<var>expr</var>)</i>
<a name="IDX642"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>rat</b><i> (<var>expr</var>, <var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX643"></a>
</dt>
<dd><p>Convierte <var>expr</var> al formato can&oacute;nico racional (canonical rational expression o CRE) expandiendo y combinando todos los t&eacute;rminos sobre un denominador com&uacute;n y cancelando el m&aacute;ximo com&uacute;n divisor del numerador y denominador, as&iacute; como convirtiendo n&uacute;meros decimales en coma flotante a n&uacute;meros racionales dentro de la tolerancia indicada por <code>ratepsilon</code>. Las variables se ordenan de acuerdo a <var>x_1</var>, ..., <var>x_n</var> si se han especificado, como en la funci&oacute;n <code>ratvars</code>.
</p>
<p>En general, <code>rat</code> no simplifica otras funciones que no sean la suma <code>+</code>, resta <code>-</code>, multiplicaci&oacute;n <code>*</code>, divisi&oacute;n <code>/</code> y exponenciaci&oacute;n de exponente entero, mientras que <code>ratsimp</code> s&iacute; lo hace.
N&oacute;tese que los &aacute;tomos (n&uacute;meros y variables) en expresiones en formato CRE no son los mismos que en el formato general.
Por ejemplo, <code>rat(x)- x</code> devuelve <code>rat(0)</code>, que tiene una representaci&oacute;n interna diferente de 0.
</p>

<p>Si <code>ratprint</code> vale <code>false</code> no aparecer&aacute;n mensajes informando al usuario sobre la conversi&oacute;n de n&uacute;meros decimales en coma flotante a n&uacute;meros racionales.
</p>
<p>Si <code>keepfloat</code> vale <code>true</code> no se convertir&aacute;n n&uacute;meros decimales en coma flotante a n&uacute;meros racionales.
</p>
<p>V&eacute;anse tambi&eacute;n <code>ratexpand</code> y  <code>ratsimp</code>.
</p>
<p>Ejemplos:
</p><pre class="example">(%i1) ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x)
         / (4*y^2 + x^2);
                                           4
                                  (x - 2 y)
              (y + a) (2 y + x) (------------ + 1)
                                   2      2 2
                                 (x  - 4 y )
(%o1)         ------------------------------------
                              2    2
                           4 y  + x
(%i2) rat (%, y, a, x);
                            2 a + 2 y
(%o2)/R/                    ---------
                             x + 2 y
</pre>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>ratalgdenom</b>
<a name="IDX644"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>ratalgdenom</code> vale <code>true</code>, se permite la racionalizaci&oacute;n de denominadores eliminando radicales.
La variable <code>ratalgdenom</code> s&oacute;lo tiene efecto cuando expresiones en formato can&oacute;nico (CRE) est&aacute;n siendo utilizadas en modo algebraico.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>ratcoef</b><i> (<var>expr</var>, <var>x</var>, <var>n</var>)</i>
<a name="IDX645"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>ratcoef</b><i> (<var>expr</var>, <var>x</var>)</i>
<a name="IDX646"></a>
</dt>
<dd><p>Devuelve el coeficiente de la expresi&oacute;n <code><var>x</var>^<var>n</var></code> dentro de la expresi&oacute;n <var>expr</var>. Si se omite, <var>n</var> se considera igual a 1.
</p>
<p>El valor devuelto est&aacute; libre de las variables en <var>x</var>, excepto quiz&aacute;s en un sentido no racional. Si no existe un coeficiente de este tipo se devuelve 0.
</p>
<p>La funci&oacute;n <code>ratcoef</code> expande y simplifica racionalmente su primer argumento, por lo que puede dar una respuesta diferente a la dada por la funci&oacute;n <code>coeff</code>, la cual tiene un car&aacute;cter puramente sint&aacute;ctico.
As&iacute;, <code>ratcoef ((x + 1)/y + x, x)</code> devuelve <code>(y + 1)/y</code>, 
mientras que <code>coeff</code> devuelve 1.
</p>
<p>La llamada <code>ratcoef (<var>expr</var>, <var>x</var>, 0)</code>, siendo <var>expr</var> una suma, devuelve una suma formada por los t&eacute;rminos que no contienen <var>x</var>.
</p>
<p>Puesto que <var>expr</var> se simplifica racionalmente antes de ser examinada, algunos coeficientes puede que no aparezcan como en la expresi&oacute;n original.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) s: a*x + b*x + 5$
(%i2) ratcoef (s, a + b);
(%o2)                           x
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>ratdenom</b><i> (<var>expr</var>)</i>
<a name="IDX647"></a>
</dt>
<dd><p>Devuelve el denominador de <var>expr</var>, despu&eacute;s de transformar <var>expr</var> al formato can&oacute;nico (CRE). El valor retornado est&aacute; tambi&eacute;n en formato CRE.
</p>
<p>El argumento <var>expr</var> se transforma al formato CRE por la funci&oacute;n <code>rat</code>, a menos que ya est&eacute; en este formato.
Esta conversi&oacute;n puede cambiar la forma de <var>expr</var> colocando todos sus t&eacute;rminos sobre un denominador com&uacute;n.
</p>
<p>La funci&oacute;n <code>denom</code> es parecida, pero devuelve una expresi&oacute;n general en lugar de una CRE. Tampoco <code>denom</code> intenta colocar todos sus t&eacute;rminos sobre un denominador com&uacute;n, de manera que algunas expresiones que son consideradas como divisiones por <code>ratdenom</code>, no son tales para <code>denom</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>ratdenomdivide</b>
<a name="IDX648"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>ratdenomdivide</code> vale <code>true</code>, la funci&oacute;n <code>ratexpand</code> expande una fracci&oacute;n en la que el numerador es una suma en una suma de divisiones. En otro caso, <code>ratexpand</code> reduce una suma de divisiones a una &uacute;nica fracci&oacute;n, cuyo numerador es la suma de los denominadores de cada fracci&oacute;n.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) expr: (x^2 + x + 1)/(y^2 + 7);
                            2
                           x  + x + 1
(%o1)                      ----------
                              2
                             y  + 7
(%i2) ratdenomdivide: true$
(%i3) ratexpand (expr);
                       2
                      x        x        1
(%o3)               ------ + ------ + ------
                     2        2        2
                    y  + 7   y  + 7   y  + 7
(%i4) ratdenomdivide: false$
(%i5) ratexpand (expr);
                            2
                           x  + x + 1
(%o5)                      ----------
                              2
                             y  + 7
(%i6) expr2: a^2/(b^2 + 3) + b/(b^2 + 3);
                                     2
                           b        a
(%o6)                    ------ + ------
                          2        2
                         b  + 3   b  + 3
(%i7) ratexpand (expr2);
                                  2
                             b + a
(%o7)                        ------
                              2
                             b  + 3
</pre>
</dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>ratdiff</b><i> (<var>expr</var>, <var>x</var>)</i>
<a name="IDX649"></a>
</dt>
<dd><p>Deriva la expresi&oacute;n racional <var>expr</var> con respecto a <var>x</var>.
El argumento <var>expr</var> debe ser una fracci&oacute;n algebraica o un polinomio en <var>x</var>.
El argumento <var>x</var> puede ser una variable o una subexpresi&oacute;n de <var>expr</var>.
</p>
<p>El resultado equivale al devuelto por <code>diff</code>, aunque es posible que se obtenga en una forma diferente.
La funci&oacute;n <code>ratdiff</code> puede ser m&aacute;s r&aacute;pida que <code>diff</code> en expresiones racionales.
</p>
<p>La funci&oacute;n <code>ratdiff</code> devuelve una expresi&oacute;n en formato can&oacute;nico o CRE si <code>expr</code> es tambi&eacute;n una expresi&oacute;n CRE. En otro caso, <code>ratdiff</code> devuelve una expresi&oacute;n general.
</p>
<p>La funci&oacute;n <code>ratdiff</code> considera &uacute;nicamente la dependencia de <var>expr</var> respecto de <var>x</var>, ignorando cualquier dependencia establecida por <code>depends</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
                           3
                        4 x  + 10 x - 11
(%o1)                   ----------------
                              5
                             x  + 5
(%i2) ratdiff (expr, x);
                    7       5       4       2
                 8 x  + 40 x  - 55 x  - 60 x  - 50
(%o2)          - ---------------------------------
                          10       5
                         x   + 10 x  + 25
(%i3) expr: f(x)^3 - f(x)^2 + 7;
                         3       2
(%o3)                   f (x) - f (x) + 7
(%i4) ratdiff (expr, f(x));
                           2
(%o4)                   3 f (x) - 2 f(x)
(%i5) expr: (a + b)^3 + (a + b)^2;
                              3          2
(%o5)                  (b + a)  + (b + a)
(%i6) ratdiff (expr, a + b);
                    2                    2
(%o6)            3 b  + (6 a + 2) b + 3 a  + 2 a
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>ratdisrep</b><i> (<var>expr</var>)</i>
<a name="IDX650"></a>
</dt>
<dd><p>Devuelve su argumento como una expresi&oacute;n general.
Si <var>expr</var> es una expresi&oacute;n general, se devuelve sin cambios.
</p>
<p>Normalmente se invoca a <code>ratdisrep</code> a fin de convertir una expresi&oacute;n en formato can&oacute;nico (CRE) al formato general, lo que puede ser utilizado si se quiere parar el contagio que produce el formato CRE, o para utilizar funciones racionales en contextos no racionales.
</p>
<p>V&eacute;ase tambi&eacute;n <code>totaldisrep</code>.
</p>
</dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>ratexpand</b><i> (<var>expr</var>)</i>
<a name="IDX651"></a>
</dt>
<dt><u>Variable opcional:</u> <b>ratexpand</b>
<a name="IDX652"></a>
</dt>
<dd><p>Expande <var>expr</var> multiplicando productos de sumas y sumas con exponentes, combinando fracciones con com&uacute;n denominador, cancelando el m&aacute;ximo com&uacute;n divisor del numerador y del denominador y luego dividiendo los sumandos del numerador por el denominador.
</p>
<p>El valor que devuelve <code>ratexpand</code> es una expresi&oacute;n general, incluso cuando <var>expr</var> est&aacute; en formato can&oacute;nico o CRE.
</p>
<p>Si la variable <code>ratexpand</code> vale <code>true</code> har&aacute; que las expresiones CRE se expandan completamente cuando se conviertan al formato general o se muestren en el terminal, mientras que si vale <code>false</code> se mostrar&aacute;n de forma recursiva. V&eacute;ase tambi&eacute;n <code>ratsimp</code>.
</p>
<p>Si <code>ratdenomdivide</code> vale <code>true</code>,
<code>ratexpand</code> expande una fracci&oacute;n en la que el numerador es una suma en una suma de fracciones, todas ellas con denominador com&uacute;n. En otro caso, <code>ratexpand</code> reduce una suma de fracciones en una &uacute;nica fracci&oacute;n, cuyo numerador es la suma de los numeradores de cada fracci&oacute;n.
</p>
<p>Si <code>keepfloat</code> vale <code>true</code>, los n&uacute;meros decimales en coma flotante no se racionalizan cuando las expresiones que los contienen se convierten al formato can&oacute;nico racional (CRE).
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) ratexpand ((2*x - 3*y)^3);
                     3         2       2        3
(%o1)          - 27 y  + 54 x y  - 36 x  y + 8 x
(%i2) expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
                         x - 1       1
(%o2)                   -------- + -----
                               2   x - 1
                        (x + 1)
(%i3) expand (expr);
                    x              1           1
(%o3)          ------------ - ------------ + -----
                2              2             x - 1
               x  + 2 x + 1   x  + 2 x + 1
(%i4) ratexpand (expr);
                        2
                     2 x                 2
(%o4)           --------------- + ---------------
                 3    2            3    2
                x  + x  - x - 1   x  + x  - x - 1
</pre>
</dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>ratfac</b>
<a name="IDX653"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>ratfac</code> vale <code>true</code>, las expresiones can&oacute;nicas (CRE) se manipulan en una forma parcialmente factorizada.
</p>
<p>Durante las operaciones racionales, las expresiones se mantienen completamente factorizadas tanto como sea posible sin llamar a <code>factor</code>. Esto deber&iacute;a ahorrar espacio y tiempo en algunos c&aacute;lculos. El numerador y denominador se hacen primos relativos, por ejemplo <code>rat ((x^2 - 1)^4/(x + 1)^2)</code> devuelve <code>(x - 1)^4 (x + 1)^2)</code>, pero los factores dentro de cada parte pueden no ser primos relativos.
</p>
<p>En el paquete <code>ctensr</code> sobre manipulaci&oacute;n de tensores por componentes, los tensores de Ricci, Einstein, Riemann y Weyl y la curvatura escalar se factorizan autom&aacute;ticamente si <code>ratfac</code> vale <code>true</code>; 
<i><code>ratfac</code> debe activarse &uacute;nicamente en aquellos casos en los que se sabe que el n&uacute;mero de t&eacute;rminos de las componentes tensoriales es pequ&ntilde;o.</i>
</p>
<p>Nota: Los esquemas de comportamiento basados en <code>ratfac</code> y <code>ratweight</code> son incompatibles y no se debe  pretender usarlos al mismo tiempo.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>ratnumer</b><i> (<var>expr</var>)</i>
<a name="IDX654"></a>
</dt>
<dd><p>Devuelve el numerador de <var>expr</var>, despu&eacute;s de reducir <var>expr</var> a su forma can&oacute;nica (CRE).
El valor retornado est&aacute; tambi&eacute;n en formato CRE.
</p>
<p>El argumento <var>expr</var> se transforma al formato CRE por la funci&oacute;n <code>rat</code>, a menos que ya est&eacute; en este formato.
Esta conversi&oacute;n puede cambiar la forma de <var>expr</var> colocando todos sus t&eacute;rminos sobre un denominador com&uacute;n.
</p>
<p>Es parecida a la funci&oacute;n <code>num</code>, pero devuelve una expresi&oacute;n general en lugar de una CRE.
Adem&aacute;s, <code>num</code> no intenta colocar todos los t&eacute;rminos sobre un denominador com&uacute;n, de manera que algunas expresiones que son consideradas fracciones por <code>ratnumer</code> no se consideran como tales por <code>num</code>.
</p></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>ratp</b><i> (<var>expr</var>)</i>
<a name="IDX655"></a>
</dt>
<dd><p>Devuelve <code>true</code> si <var>expr</var> es una expresi&oacute;n can&oacute;nica racional (canonical rational expression o CRE) o una CRE extendida, en caso contrario devuelve <code>false</code>.
</p>
<p>Las expresiones CRE son creadas por <code>rat</code> y funciones asociadas. Las CRE extendidas son creadas por <code>taylor</code> y funciones asociadas.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>ratprint</b>
<a name="IDX656"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>ratprint</code> vale <code>true</code>, se muestra al usuario un mensaje dando cuenta de la conversi&oacute;n de n&uacute;meros decimales en coma flotante a formato racional.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>ratsimp</b><i> (<var>expr</var>)</i>
<a name="IDX657"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>ratsimp</b><i> (<var>expr</var>, <var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX658"></a>
</dt>
<dd><p>Simplifica la expresi&oacute;n <var>expr</var> y todas sus subexpresiones, incluyendo los argumentos de funciones no racionales. El resultado es un cociente de dos polinomios en una forma recursiva, esto es, los coeficientes de la variable principal son polinomios respecto de las otras variables. Las variables pueden incluir funciones no racionales, como <code>sin (x^2 + 1)</code>, y los argumentos de tales funciones son tambi&eacute;n racionalmente simplificados.
</p>
<p>La llamada <code>ratsimp (<var>expr</var>, <var>x_1</var>, ..., <var>x_n</var>)</code> permite la simplificaci&oacute;n racional con la especificaci&oacute;n del orden de las variables, como en <code>ratvars</code>.
</p>
<p>Si <code>ratsimpexpons</code> vale <code>true</code>, <code>ratsimp</code> se aplica a los exponentes de las expresiones durante la simplificaci&oacute;n.
</p>
<p>V&eacute;ase tambi&eacute;n <code>ratexpand</code>. N&oacute;tese que <code>ratsimp</code> se ve afectada por algunas de las variables globales que controlan a <code>ratexpand</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
                                         2      2
                   x         (log(x) + 1)  - log (x)
(%o1)        sin(------) = %e
                  2
                 x  + x
(%i2) ratsimp (%);
                             1          2
(%o2)                  sin(-----) = %e x
                           x + 1
(%i3) ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
                       3/2
                (x - 1)    - sqrt(x - 1) (x + 1)
(%o3)           --------------------------------
                     sqrt((x - 1) (x + 1))
(%i4) ratsimp (%);
                           2 sqrt(x - 1)
(%o4)                    - -------------
                                 2
                           sqrt(x  - 1)
(%i5) x^(a + 1/a), ratsimpexpons: true;
                               2
                              a  + 1
                              ------
                                a
(%o5)                        x
</pre>
</dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>ratsimpexpons</b>
<a name="IDX659"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>ratsimpexpons</code> vale <code>true</code>, <code>ratsimp</code> se aplica a los exponentes de las expresiones durante la simplificaci&oacute;n.
</p></dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>radsubstflag</b>
<a name="IDX660"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>radsubstflag</code> vale <code>true</code> se permite a <code>ratsubst</code> hacer la sustituci&oacute;n <code>u</code> por <code>sqrt (x)</code> in <code>x</code>.
</p>
</dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>ratsubst</b><i> (<var>a</var>, <var>b</var>, <var>c</var>)</i>
<a name="IDX661"></a>
</dt>
<dd><p>Sustituye <var>b</var> por <var>a</var> en <var>c</var> y devuelve la expresi&oacute;n resultante.
El argumento <var>b</var> puede ser una suma, un producto, una potencia, etc.
</p>
<p>La funci&oacute;n <code>ratsubst</code> reconoce el significado de las expresiones, mientras que <code>subst</code> tan solo realiza sustituciones sint&aacute;cticas. As&iacute; por ejemplo, <code>subst (a, x + y, x + y + z)</code> devuelve <code>x + y + z</code>
cuando <code>ratsubst</code> devuelve <code>z + a</code>.
</p>
<p>Si <code>radsubstflag</code> vale <code>true</code>,
<code>ratsubst</code> sustituye radicales en expresiones que no los contienen expl&iacute;citamente.
</p>
<p><code>ratsubst</code> ignora el valor <code>true</code> de la variable 
opcional <code>keepfloat</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
                              3      4
(%o1)                      a x  y + a
(%i2) cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
               4         3         2
(%o2)       cos (x) + cos (x) + cos (x) + cos(x) + 1
(%i3) ratsubst (1 - sin(x)^2, cos(x)^2, %);
            4           2                     2
(%o3)    sin (x) - 3 sin (x) + cos(x) (2 - sin (x)) + 3
(%i4) ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
                        4           2
(%o4)                cos (x) - 2 cos (x) + 1
(%i5) radsubstflag: false$
(%i6) ratsubst (u, sqrt(x), x);
(%o6)                           x
(%i7) radsubstflag: true$
(%i8) ratsubst (u, sqrt(x), x);
                                2
(%o8)                          u
</pre></dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>ratvars</b><i> (<var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX662"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>ratvars</b><i> ()</i>
<a name="IDX663"></a>
</dt>
<dt><u>Variable del sistema:</u> <b>ratvars</b>
<a name="IDX664"></a>
</dt>
<dd><p>Declara como variables principales <var>x_1</var>, ..., <var>x_n</var> en expresiones racionales. Si <var>x_n</var> est&aacute; presente en una expresi&oacute;n racional, se considerar&aacute; como variable principal. Si no est&aacute; presente, entonces se considerar&aacute; principal a la variable <var>x_[n-1]</var> si aparece en la expresi&oacute;n, se contin&uacute;a as&iacute; hasta <var>x_1</var>, que se considerar&aacute; como variable principal s&oacute;lo si ninguna de las variables que le siguen est&aacute; presente en la expresi&oacute;n.
</p>
<p>Si una variable de la expresi&oacute;n racional no est&aacute; presente en la lista <code>ratvars</code>, se le dar&aacute; una prioridad inferior a la de <var>x_1</var>.
</p>
<p>Los argumentos de <code>ratvars</code> pueden ser tanto variables como funciones no racionales como <code>sin(x)</code>.
</p>
<p>La variable <code>ratvars</code> es una lista que contiene los argumentos pasados a la funci&oacute;n <code>ratvars</code> la &uacute;ltima vez que fue invocada. Cada llamada a la funci&oacute;n <code>ratvars</code> reinicializa la lista. La llamada <code>ratvars ()</code> vac&iacute;a la lista.
</p>
</dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>ratvarswitch</b>
<a name="IDX665"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Maxima almacena una lista interna en la variable Lisp <code>VARLIST</code> cuyo
contenido son las variables principales de las expresiones racionales. Cuando <code>ratvarswitch</code>
vale <code>true</code>, su valor por defecto, cada evaluaci&oacute;n comienza con la lista
<code>VARLIST</code> vac&iacute;a. En caso contrario, las variables principales
de las expresiones anteriores se mantienen en la lista <code>VARLIST</code>.
</p>
<p>Las variables principales declaradas con la funci&oacute;n <code>ratvars</code> no se
ven afectadas por la opci&oacute;n <code>ratvarswitch</code>.
</p>
<p>Ejemplos:
</p>
<p>Cuando <code>ratvarswitch</code> vale <code>true</code>, su valor por defecto, cada 
evaluaci&oacute;n comienza con la lista <code>VARLIST</code> vac&iacute;a.
</p>
<pre class="example">(%i1) ratvarswitch:true$

(%i2) rat(2*x+y^2);
                             2
(%o2)/R/                    y  + 2 x
(%i3) :lisp varlist
($X $Y)

(%i3) rat(2*a+b^2);
                             2
(%o3)/R/                    b  + 2 a

(%i4) :lisp varlist
($A $B)
</pre>
<p>Cuando <code>ratvarswitch</code> vale <code>false</code>, las variables principales
de las expresiones anteriores se mantienen en lista <code>VARLIST</code>.
</p>
<pre class="example">(%i4) ratvarswitch:false$

(%i5) rat(2*x+y^2);
                             2
(%o5)/R/                    y  + 2 x
(%i6) :lisp varlist
($X $Y)

(%i6) rat(2*a+b^2);
                             2
(%o6)/R/                    b  + 2 a

(%i7) :lisp varlist
($A $B $X $Y)
</pre>
</dd></dl>





<dl>
<dt><u>Funci&oacute;n:</u> <b>ratweight</b><i> (<var>x_1</var>, <var>w_1</var>, ..., <var>x_n</var>, <var>w_n</var>)</i>
<a name="IDX666"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>ratweight</b><i> ()</i>
<a name="IDX667"></a>
</dt>
<dd><p>Asigna un peso <var>w_i</var> a la variable <var>x_i</var>. Un t&eacute;rmino ser&aacute; reemplazado por 0 si su peso excede el valor de la variable <code>ratwtlvl</code> (por defecto no se realiza el truncamiento). El peso de un t&eacute;rmino es la suma de los productos de los pesos de las variables que lo forman multiplicados por sus exponentes. Por ejemplo, el peso de <code>3 x_1^2 x_2</code> es <code>2 w_1 + w_2</code>. El truncamiento basado en <code>ratwtlvl</code> solamente se lleva a cabo cuando se multiplican o se elevan a potencias expresiones can&oacute;nicas (CRE).
</p>
<p>La llamada <code>ratweight ()</code> devuelve la lista acumulada de asignaciones de pesos.
</p>
<p>Nota: Los esquemas de comportamiento basados en <code>ratfac</code> y <code>ratweight</code> son incompatibles y no se debe  pretender usarlos al mismo tiempo.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) ratweight (a, 1, b, 1);
(%o1)                     [a, 1, b, 1]
(%i2) expr1: rat(a + b + 1)$
(%i3) expr1^2;
                  2                  2
(%o3)/R/         b  + (2 a + 2) b + a  + 2 a + 1
(%i4) ratwtlvl: 1$
(%i5) expr1^2;
(%o5)/R/                  2 b + 2 a + 1
</pre>
</dd></dl>

<dl>
<dt><u>Variable del sistema:</u> <b>ratweights</b>
<a name="IDX668"></a>
</dt>
<dd><p>Valor por defecto: <code>[]</code>
</p>
<p>La variable <code>ratweights</code> es una lista que contiene los pesos asignados por <code>ratweight</code>.
Las lista es acumulativa, en el sentido de que cada llamada a <code>ratweight</code> a&ntilde;ade nuevos elementos a la lista.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>ratwtlvl</b>
<a name="IDX669"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>La variable <code>ratwtlvl</code> se utiliza en combinaci&oacute;n con la funci&oacute;n <code>ratweight</code> para controlar el truncamiento de expresiones racionales can&oacute;nicas (CRE). Con el valor por defecto, <code>false</code>, no se produce truncamiento alguno.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>remainder</b><i> (<var>p_1</var>, <var>p_2</var>)</i>
<a name="IDX670"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>remainder</b><i> (<var>p_1</var>, <var>p_2</var>, <var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX671"></a>
</dt>
<dd><p>Devuelve el resto de la divisi&oacute;n del polinomio <var>p_1</var> entre <var>p_2</var>. Los argumentos <var>x_1</var>, ..., <var>x_n</var> se interpretan como en <code>ratvars</code>.
</p>
<p>La funci&oacute;n <code>remainder</code> devuelve el segundo elemento de la lista retornada por <code>divide</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>resultant</b><i> (<var>p_1</var>, <var>p_2</var>, <var>x</var>)</i>
<a name="IDX672"></a>
</dt>
<dd><p>Calcula la resultante de los dos polinomios <var>p_1</var> y <var>p_2</var>, eliminando
la variable <var>x</var>. La resultante es un determinante de los coeficientes de <var>x</var>
en <var>p_1</var> y <var>p_2</var>, que es igual a cero si s&oacute;lo si <var>p_1</var> y <var>p_2</var>
tienen un factor com&uacute;n no constante.
</p>
<p>Si <var>p_1</var> o <var>p_2</var> pueden ser factorizados, puede ser necesario llamar a 
<code>factor</code> antes que invocar a <code>resultant</code>.
</p>
<p>La variable opcional <code>resultant</code> controla qu&eacute; algoritmo ser&aacute; utilizado para calcular la resultante.
V&eacute;anse <code>option_resultant</code> y <code>resultant</code>.
</p>
<p>La funci&oacute;n <code>bezout</code> toma los mismos argumentos que <code>resultant</code> y devuelve una matriz.
El determinante del valor retornado es la resultante buscada.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) resultant(2*x^2+3*x+1, 2*x^2+x+1, x);
(%o1)                           8
(%i2) resultant(x+1, x+1, x);
(%o2)                           0
(%i3) resultant((x+1)*x, (x+1), x);
(%o3)                           0
(%i4) resultant(a*x^2+b*x+1, c*x + 2, x);
                         2
(%o4)                   c  - 2 b c + 4 a

(%i5) bezout(a*x^2+b*x+1, c*x+2, x);
                        [ 2 a  2 b - c ]
(%o5)                   [              ]
                        [  c      2    ]
(%i6) determinant(%);
(%o6)                   4 a - (2 b - c) c
</pre></dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>resultant</b>
<a name="IDX673"></a>
</dt>
<dd><p>Valor por defecto: <code>subres</code>
</p>
<p>La variable opcional <code>resultant</code> controla qu&eacute; algoritmo ser&aacute; utilizado para
calcular la resultante con la funci&oacute;n <code>resultant</code>. Los  valores posibles son:
</p>
<dl compact="compact">
<dt> <code>subres</code></dt>
<dd><p>para el algoritmo PRS (<i>polynomial remainder sequence</i>) subresultante,
</p></dd>
<dt> <code>mod</code></dt>
<dd><p>para el algoritmo resultante modular y
</p></dd>
<dt> <code>red</code></dt>
<dd><p>para el algoritmo PRS (<i>polynomial remainder sequence</i>) reducido.
</p></dd>
</dl>

<p>En la mayor parte de problemas, el valor por defecto, <code>subres</code>, es el
m&aacute;s apropiado. Pero en el caso de problemas bivariantes o univariantes
de grado alto, puede ser mejor utilizar <code>mod</code>.
</p></dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>savefactors</b>
<a name="IDX674"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>savefactors</code> vale <code>true</code>, los factores de una expresi&oacute;n producto se almacenan por ciertas funciones a fin de acelerar posteriores factorizaciones de expresiones que contengan algunos de estos factores.
</p>
</dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>showratvars</b><i> (<var>expr</var>)</i>
<a name="IDX675"></a>
</dt>
<dd><p>Devuelve una lista de las variables de expresiones can&oacute;nicas racionales (CRE) en la expresi&oacute;n <code>expr</code>.
</p>
<p>V&eacute;ase tambi&eacute;n <code>ratvars</code>.
</p>
</dd></dl>





<dl>
<dt><u>Funci&oacute;n:</u> <b>tellrat</b><i> (<var>p_1</var>, ..., <var>p_n</var>)</i>
<a name="IDX676"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>tellrat</b><i> ()</i>
<a name="IDX677"></a>
</dt>
<dd><p>A&ntilde;ade al anillo de enteros algebraicos conocidos por Maxima los elementos que son soluciones de los polinomios <var>p_1</var>, ..., <var>p_n</var>. Cada argumento <var>p_i</var> es un polinomio de coeficientes enteros.
</p>
<p>La llamada <code>tellrat (<var>x</var>)</code> hace que se sustituya 0 por <var>x</var> en las funciones racionales.
</p>
<p>La llamada <code>tellrat ()</code> devuelve una lista con las sustituciones actuales.
</p>
<p>A la variable <code>algebraic</code> se le debe asignar el valor <code>true</code> a fin de poder realizar la simplificaci&oacute;n de enteros algebraicos.
</p>
<p>Maxima reconoce la unidad imaginaria <code>%i</code> y todas las ra&iacute;ces de los enteros.
</p>
<p>La instrucci&oacute;n <code>untellrat</code> borra todas las propiedades de <code>tellrat</code>.
</p>
<p>Es ambiguo aplicar <code>tellrat</code> a un polinomio multivariante tal como <code>tellrat (x^2 - y^2)</code>, pues no se sabe si sustituir <code><var>y</var>^2</code> por <code><var>x</var>^2</code> o al rev&eacute;s. Maxima sigue un cierto orden, pero si el usuario quiere especificar uno en concreto, puede hacerlo mediante la sintaxis <code>tellrat (y^2 = x^2)</code>, que indica que se ponga <code><var>x</var>^2</code> en lugar de <code><var>y</var>^2</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) 10*(%i + 1)/(%i + 3^(1/3));
                           10 (%i + 1)
(%o1)                      -----------
                                  1/3
                            %i + 3
(%i2) ev (ratdisrep (rat(%)), algebraic);
             2/3      1/3              2/3      1/3
(%o2)    (4 3    - 2 3    - 4) %i + 2 3    + 4 3    - 2
(%i3) tellrat (1 + a + a^2);
                            2
(%o3)                     [a  + a + 1]
(%i4) 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
                      1                 a
(%o4)           ------------- + -----------------
                sqrt(2) a - 1   sqrt(3) + sqrt(2)
(%i5) ev (ratdisrep (rat(%)), algebraic);
         (7 sqrt(3) - 10 sqrt(2) + 2) a - 2 sqrt(2) - 1
(%o5)    ----------------------------------------------
                               7
(%i6) tellrat (y^2 = x^2);
                        2    2   2
(%o6)                 [y  - x , a  + a + 1]
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>totaldisrep</b><i> (<var>expr</var>)</i>
<a name="IDX678"></a>
</dt>
<dd><p>Convierte cada subexpresi&oacute;n  de <var>expr</var> del formato can&oacute;nico (CRE) al general y devuelve el resultado.
Si <var>expr</var> est&aacute; en formato CRE entonces <code>totaldisrep</code> es id&eacute;ntico a <code>ratdisrep</code>.
</p>
<p>La funci&oacute;n <code>totaldisrep</code> puede ser &uacute;til para modificar expresiones como las ecuaciones, listas, matrices, etc., que tienen algunas subexpresiones en formato CRE.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>untellrat</b><i> (<var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX679"></a>
</dt>
<dd><p>Elimina de <var>x_1</var>, ..., <var>x_n</var> las propiedades relacionadas con <code>tellrat</code>.
</p>
</dd></dl>











































<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC88" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_15.html#SEC91" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Robert</em> on <em>diciembre, 10 2012</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
