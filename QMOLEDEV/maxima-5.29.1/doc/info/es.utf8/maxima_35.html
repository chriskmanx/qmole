<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on diciembre, 10 2012 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual de Maxima: 35. Conjuntos</title>

<meta name="description" content="Manual de Maxima: 35. Conjuntos">
<meta name="keywords" content="Manual de Maxima: 35. Conjuntos">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body
{
    color: black;
    background: white; 
    margin-left: 8%;
    margin-right: 13%;
}

h1
{
    margin-left: +8%;
    font-size: 150%;
    font-family: sans-serif
}

h2
{
    font-size: 125%;
    font-family: sans-serif
}

h3
{
    font-size: 100%;
    font-family: sans-serif
}

h2,h3,h4,h5,h6 { margin-left: +4%; }

div.textbox
{
    border: solid;
    border-width: thin;
    /* width: 100%; */
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em
}

div.titlebox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
    background: rgb(200,255,255);
    font-family: sans-serif
}

div.synopsisbox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
     background: rgb(255,220,255);
    /*background: rgb(200,255,255); */
    /* font-family: fixed */
}

pre.example
{
    border: 1px solid gray;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 1em;
    padding-right: 1em;
    /* background: rgb(247,242,180); */ /* kind of sandy */
    /* background: rgb(200,255,255); */ /* sky blue */
    background-color: #F1F5F9; /* light blue-gray */
    /* font-family: "Lucida Console", monospace */
}

div.spacerbox
{
    border: none;
    padding-top: 2em;
    padding-bottom: 2em
}

div.image
{
    margin: 0;
    padding: 1em;
    text-align: center;
}

div.categorybox
{
    border: 1px solid gray;
    padding-top: 0px;
    padding-bottom: 0px;
    padding-left: 1em;
    padding-right: 1em;
    background: rgb(247,242,220);
}


-->
</style>

<link rel="icon" href="http://maxima.sourceforge.net/favicon.ico"/>
</head>

<body lang="es" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Conjuntos"></a>
<a name="SEC187"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_34.html#SEC186" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC188" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_34.html#SEC184" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_36.html#SEC194" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 35. Conjuntos </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC188">35.1 Introducci&oacute;n a los conjuntos</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC193">35.2 Funciones y variables para los conjuntos</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       
</td></tr>
</table>

<hr size="6">
<a name="Introducci_00f3n-a-los-conjuntos"></a>
<a name="SEC188"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC187" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC189" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC187" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC187" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_36.html#SEC194" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 35.1 Introducci&oacute;n a los conjuntos </h2>

<p>Maxima dispone de funciones para realizar operaciones con conjuntos, como la intersecci&oacute;n o la uni&oacute;n. Los conjuntos deben ser finitos y definidos por enumeraci&oacute;n. Maxima trata a los conjuntos y a las listas como objectos de distinta naturaleza, lo que permite trabajar con conjuntos cuyos elementos puedan ser tambi&eacute;n conjuntos o listas.
</p>
<p>Adem&aacute;s de funciones para operar con conjuntos finitos, Maxima dispone tambi&eacute;n de algunas funciones sobre combinatoria, como los n&uacute;meros de Stirling de primera y segunda especie, n&uacute;meros de Bell, coeficientes multinomiales, particiones de enteros no negativos y algunos otros. Maxima tambi&eacute;n define la funci&oacute;n delta de Kronecker.
</p>

<hr size="6">
<a name="SEC189"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC188" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC190" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC187" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC188" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_36.html#SEC194" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 35.1.1 Utilizaci&oacute;n </h3>

<p>Para construir un conjunto cuyos elementos sean <code>a_1, ..., a_n</code>, se utiliza la instrucci&oacute;n  <code>set(a_1, ..., a_n)</code> o <code>{a_1, ..., a_n}</code>; para formar un conjunto vac&iacute;o, basta con hacer <code>set()</code> o <code>{}</code>. Para introducir conjuntos en Maxima, <code>set (...)</code> y <code>{ ... }</code> son equivalentes. Los conjuntos se muestran siempre con llave.
</p>
<p>Si un elemento se indica m&aacute;s de una vez, el proceso 
de simplificaci&oacute;n elimina los elementos redundantes.
</p>
<pre class="example">(%i1) set();
(%o1)                          {}
(%i2) set(a, b, a);
(%o2)                        {a, b}
(%i3) set(a, set(b));
(%o3)                       {a, {b}}
(%i4) set(a, [b]);
(%o4)                       {a, [b]}
(%i5) {};
(%o5)                          {}
(%i6) {a, b, a};
(%o6)                        {a, b}
(%i7) {a, {b}};
(%o7)                       {a, {b}}
(%i8) {a, [b]};
(%o8)                       {a, [b]}
</pre>

<p>Dos elementos candidatos a formar parte de un conjunto, <var>x</var> e <var>y</var>,
son redundantes, esto es, se consideran el mismo elemento a 
efectos de consruir el conjunto, si y s&oacute;lo si <code>is (<var>x</var> = <var>y</var>)</code>
devuelve el valor <code>true</code>. N&oacute;tese que <code>is (equal (<var>x</var>, <var>y</var>))</code>
puede devolver <code>true</code> y <code>is (<var>x</var> = <var>y</var>)</code> retornar
<code>false</code>; en cuyo caso los elementos <var>x</var> e <var>y</var> se
considerar&iacute;an distintos.
</p>
<pre class="example">(%i1) x: a/c + b/c;
                              b   a
(%o1)                         - + -
                              c   c
(%i2) y: a/c + b/c;
                              b   a
(%o2)                         - + -
                              c   c
(%i3) z: (a + b)/c;
                              b + a
(%o3)                         -----
                                c
(%i4) is (x = y);
(%o4)                         true
(%i5) is (y = z);
(%o5)                         false
(%i6) is (equal (y, z));
(%o6)                         true
(%i7) y - z;
                           b + a   b   a
(%o7)                    - ----- + - + -
                             c     c   c
(%i8) ratsimp (%);
(%o8)                           0
(%i9) {x, y, z};
                          b + a  b   a
(%o9)                    {-----, - + -}
                            c    c   c
</pre>

<p>Para formar un conjunto a partir de los miembros de una lista &uacute;sese <code>setify</code>.
</p>
<pre class="example">(%i1) setify([b, a]);
(%o1)                        {a, b}
</pre>
<p>Los elementos <code>x</code> e <code>y</code> de un conjunto se consideran iguales si <code>is(x = y)</code> devuelve el valor <code>true</code>. As&iacute;, <code>rat(x)</code> y <code>x</code> se consideran el mismo elemento de un conjunto; consecuentemente, 
</p>
<pre class="example">(%i1) {x, rat(x)};
(%o1)                          {x}
</pre>
<p>Adem&aacute;s, puesto que  <code>is((x-1)*(x+1) = x^2 - 1)</code> devuelve <code>false</code>,  <code>(x-1)*(x+1)</code> y <code>x^2-1</code> se consideran elementos diferentes; as&iacute;
</p>
<pre class="example">(%i1) {(x - 1)*(x + 1), x^2 - 1};
                                       2
(%o1)               {(x - 1) (x + 1), x  - 1}
</pre>
<p>Para reducir este conjunto a otro unitario, aplicar <code>rat</code> a cada elemento del conjunto:
</p>
<pre class="example">(%i1) {(x - 1)*(x + 1), x^2 - 1};
                                       2
(%o1)               {(x - 1) (x + 1), x  - 1}
(%i2) map (rat, %);
                              2
(%o2)/R/                    {x  - 1}
</pre>
<p>Para eliminar redundancias con otros conjuntos, ser&aacute; necesario utilizar otras funciones de simplificaci&oacute;n. He aqu&iacute; un ejemplo que utiliza  <code>trigsimp</code>:
</p>
<pre class="example">(%i1) {1, cos(x)^2 + sin(x)^2};
                            2         2
(%o1)                {1, sin (x) + cos (x)}
(%i2) map (trigsimp, %);
(%o2)                          {1}
</pre>
<p>Se entiende que un conjunto est&aacute; simplificado cuando entre sus elementos no hay redundancias y se hayan ordenados. La versi&oacute;n actual de las funciones para conjuntos utiliza la funci&oacute;n <code>orderlessp</code> de Maxima para ordenar sus elementos; sin embargo, <i>futuras versiones de las funciones para operar con conjuntos podr&aacute;n utilizar otras funciones de ordenaci&oacute;n</i>.
</p>
<p>Algunas operaciones con conjuntos, tales como la sustituci&oacute;n, fuerzan autom&aacute;ticamente una re-simplificaci&oacute;n; por ejemplo,
</p>
<pre class="example">(%i1) s: {a, b, c}$
(%i2) subst (c=a, s);
(%o2)                        {a, b}
(%i3) subst ([a=x, b=x, c=x], s);
(%o3)                          {x}
(%i4) map (lambda ([x], x^2), set (-1, 0, 1));
(%o4)                        {0, 1}
</pre>
<p>Maxima considera a las listas y conjuntos como objetos diferentes;
funciones tales como <code>union</code> y <code>intersection</code> emitir&aacute;n
un error si alguno de sus argumentos no es un conjunto. Si se 
necesita aplicar una funci&oacute;n de conjunto a una lista, se deber&aacute; 
utilizar la funci&oacute;n <code>setify</code> para convertirla previamente en conjunto. 
As&iacute;,
</p>
<pre class="example">(%i1) union ([1, 2], {a, b});
Function union expects a set, instead found [1,2]
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i2) union (setify ([1, 2]), {a, b});
(%o2)                     {1, 2, a, b}
</pre>
<p>Para extraer todos los elementos de un conjunto <code>s</code> que satisfagan un predicado <code>f</code>, &uacute;sese <code>subset(s,f)</code>. (Un <i>predicado</i> es una funci&oacute;n booleana.) Por ejemplo, para encontrar las ecuaciones en un conjunto dado que no dependan de la variable <code>z</code>, se har&aacute;
</p>
<pre class="example">(%i1) subset ({x + y + z, x - y + 4, x + y - 5},
              lambda ([e], freeof (z, e)));
(%o1)               {- y + x + 4, y + x - 5}
</pre>
<p>La secci&oacute;n <code>Funciones y variables para los conjuntos</code> incluye una lista completa de funciones para operar con conjuntos en  Maxima.
</p>
<hr size="6">
<a name="SEC190"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC189" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC191" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC187" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC188" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_36.html#SEC194" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 35.1.2 Iteraciones con elementos </h3>

<p>Hay dos formas para operar iterativamente sobre los elementos de un conjunto. Una es utilizar <code>map</code>; por ejemplo:
</p>
<pre class="example">(%i1) map (f, {a, b, c});
(%o1)                  {f(a), f(b), f(c)}
</pre>
<p>La otra forma consiste en hacer uso de la construcci&oacute;n <code>for <var>x</var> in <var>s</var> do</code>
</p>
<pre class="example">(%i1) s: {a, b, c};
(%o1)                       {a, b, c}
(%i2) for si in s do print (concat (si, 1));
a1 
b1 
c1 
(%o2)                         done
</pre>
<p>Las funciones de Maxima  <code>first</code> y <code>rest</code> funcionan tambi&eacute;n con conjuntos.  En este caso, <code>first</code> devuelve el primer elemento que se muestra del conjunto, el cual puede depender de la implementaci&oacute;n del sistema. Si <code>s</code> es un conjunto, entonces <code>rest(s)</code> equivale a <code>disjoin (first(s), s)</code>. Hay otras funciones que trabajan correctamente con conjuntos. En pr&oacute;ximas versiones de las funciones para operar con conjuntos es posible que <code>first</code> y <code>rest</code> trabajen de modo diferente o que ya no lo hagan en absoluto.
</p>
<hr size="6">
<a name="SEC191"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC190" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC192" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC187" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC188" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_36.html#SEC194" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 35.1.3 Fallos </h3>

<p>Las funciones para operar con conjuntos utilizan la funci&oacute;n <code>orderlessp</code>
de Maxima para ordenar los elementos de los conjuntos, as&iacute;
como la funci&oacute;n <code>like</code> de Lisp para decidir sobre la igualdad de dichos
elementos. Ambas funciones tienen fallos que son conocidos y que pueden
aflorar si se trabaja con conjuntos que tengan elementos en formato de
listas o matrices y que contengan expresiones racionales can&oacute;nicas (CRE).
Un ejemplo es
</p>
<pre class="example">(%i1) {[x], [rat (x)]};
Maxima encountered a Lisp error:

  The value #:X1440 is not of type LIST.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
</pre>
<p>Esta expresi&oacute;n provoca una parada de Maxima junto con la 
emisi&oacute;n de un mensaje de error, el cual depender&aacute; de 
la versi&oacute;n de Lisp que utilice Maxima. Otro ejemplo es
</p>
<pre class="example">(%i1) setify ([[rat(a)], [rat(b)]]);
Maxima encountered a Lisp error:

  The value #:A1440 is not of type LIST.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
</pre>
<p>Estos fallos son causados por fallos en  <code>orderlessp</code> y <code>like</code>,
no por fallos cuyo origen se encuentre en las funciones para conjuntos.
Para ilustrarlo, se pueden ejecutar las siguientes expresiones
</p>
<pre class="example">(%i1) orderlessp ([rat(a)], [rat(b)]);
Maxima encountered a Lisp error:

  The value #:B1441 is not of type LIST.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
(%i2) is ([rat(a)] = [rat(a)]);
(%o2)                         false
</pre>
<p>Hasta que estos errores no se corrijan, no es aconsejable construir conjuntos que tengan por elementos listas o matrices que contengan expresiones en forma CRE; sin embargo, un conjunto con elementos de la forma CRE no deber&iacute;an dar problemas:
</p>
<pre class="example">(%i1) {x, rat (x)};
(%o1)                          {x}
</pre>
<p>La funci&oacute;n <code>orderlessp</code> de Maxima tiene otro fallo que puede causar problemas con las funciones para conjuntos, en concreto, que el predicado de ordenaci&oacute;n <code>orderlessp</code> no es transitivo. El ejemplo m&aacute;s simple que ilustra este punto es
</p>
<pre class="example">(%i1) q: x^2$
(%i2) r: (x + 1)^2$
(%i3) s: x*(x + 2)$
(%i4) orderlessp (q, r);
(%o4)                         true
(%i5) orderlessp (r, s);
(%o5)                         true
(%i6) orderlessp (q, s);
(%o6)                         false
</pre>
<p>El fallo puede causar problemas con todas las funciones para conjuntos,
as&iacute; como tambi&eacute;n con otras funciones de Maxima.
Es probable, pero no seguro, que este fallo se puede evitar si todos 
los elementos del conjunto est&aacute;n en la forma de expresi&oacute;n racional
can&oacute;nica (CRE) o han sido simplificados con <code>ratsimp</code>.
</p>
<p>Los mecanismos <code>orderless</code> y <code>ordergreat</code> de Maxima son incompatibles
con las funciones para conjuntos. Si se necesitan utilizar <code>orderless</code> o
<code>ordergreat</code>, h&aacute;gase antes de construir los conjuntos y no se utilice 
la instrucci&oacute;n <code>unorder</code>.
</p>
<p>Se ruega a todo usuario que crea haber encontrado un fallo en las funciones para conjuntos que lo comunique en la base de datos de Maxima. V&eacute;ase <code>bug_report</code>.
</p>
<hr size="6">
<a name="SEC192"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC191" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC193" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC187" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC188" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_36.html#SEC194" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 35.1.4 Autores </h3>

<p>Stavros Macrakis de Cambridge, Massachusetts y Barton Willis de la University of Nebraska at Kearney (UNK).
</p>
<hr size="6">
<a name="Funciones-y-variables-para-los-conjuntos"></a>
<a name="SEC193"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC192" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_36.html#SEC194" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC187" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC187" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_36.html#SEC194" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 35.2 Funciones y variables para los conjuntos </h2>


<dl>
<dt><u>Funci&oacute;n:</u> <b>adjoin</b><i> (<var>x</var>, <var>a</var>) </i>
<a name="IDX1388"></a>
</dt>
<dd><p>Calcula la uni&oacute;n del conjunto <var>a</var> y <code>{<var>x</var>}</code>.
</p>
<p>La funci&oacute;n <code>adjoin</code> emite un mensaje de error si <var>a</var>
no es un conjunto literal.
</p>
<p>Las sentencias <code>adjoin(<var>x</var>, <var>a</var>)</code> y 
<code>union(set(<var>x</var>), <var>a</var>)</code> son equivalentes, aunque
<code>adjoin</code> puede ser algo m&aacute;s r&aacute;pida que <code>union</code>.
</p>
<p>V&eacute;ase tambi&eacute;n <code>disjoin</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) adjoin (c, {a, b});
(%o1)                       {a, b, c}
(%i2) adjoin (a, {a, b});
(%o2)                        {a, b}
</pre>
</dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>belln</b><i> (<var>n</var>)</i>
<a name="IDX1389"></a>
</dt>
<dd><p>Representa el <em>n</em>-&eacute;simo n&uacute;mero de Bell, de
modo que <code>belln(n)</code> es el n&uacute;mero de particiones de un conjunto de 
<var>n</var> elementos.
</p>
<p>El argumento <var>n</var> debe ser un entero no negativo.
</p>
<p>La funci&oacute;n <code>belln</code> se distribuye sobre ecuaciones, listas,
matrices y conjuntos.
</p>
<p>Ejemplos:
</p>
<p><code>belln</code> se aplica a enteros no negativos,
</p>
<pre class="example">(%i1) makelist (belln (i), i, 0, 6);
(%o1)               [1, 1, 2, 5, 15, 52, 203]
(%i2) is (cardinality (set_partitions ({})) = belln (0));
(%o2)                         true
(%i3) is (cardinality (set_partitions ({1, 2, 3, 4, 5, 6}))
                            = belln (6));
(%o3)                         true
</pre>
<p>Si <var>n</var> no es un entero no negativo, la funci&oacute;n <code>belln(n)</code> no hace c&aacute;lculo alguno.
</p>
<pre class="example">(%i1) [belln (x), belln (sqrt(3)), belln (-9)];
(%o1)        [belln(x), belln(sqrt(3)), belln(- 9)]
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>cardinality</b><i> (<var>a</var>)</i>
<a name="IDX1390"></a>
</dt>
<dd><p>Devuelve el n&uacute;mero de elementos del conjunto <var>a</var>.
</p>
<p>La funci&oacute;n <code>cardinality</code> ignora los elementos
redundantes, incluso cuando la simplificaci&oacute;n est&aacute;
desabilitada.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) cardinality ({});
(%o1)                           0
(%i2) cardinality ({a, a, b, c});
(%o2)                           3
(%i3) simp : false;
(%o3)                         false
(%i4) cardinality ({a, a, b, c});
(%o4)                           3
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>cartesian_product</b><i> (<var>b_1</var>, ... , <var>b_n</var>)</i>
<a name="IDX1391"></a>
</dt>
<dd><p>Devuelve un conjunto formado por listas de la forma <code>[<var>x_1</var>, ..., <var>x_n</var>]</code>,
siendo <var>x_1</var>, ..., <var>x_n</var> elementos de los conjuntos <var>b_1</var>, ... , <var>b_n</var>,
respectivamente.
</p>
<p>La funci&oacute;n <code>cartesian_product</code> emite un mensaje de error si alguno
de sus argumentos no es un conjunto literal.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) cartesian_product ({0, 1});
(%o1)                      {[0], [1]}
(%i2) cartesian_product ({0, 1}, {0, 1});
(%o2)           {[0, 0], [0, 1], [1, 0], [1, 1]}
(%i3) cartesian_product ({x}, {y}, {z});
(%o3)                      {[x, y, z]}
(%i4) cartesian_product ({x}, {-1, 0, 1});
(%o4)              {[x, - 1], [x, 0], [x, 1]}
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>disjoin</b><i> (<var>x</var>, <var>a</var>)</i>
<a name="IDX1392"></a>
</dt>
<dd><p>Devuelve el conjunto <var>a</var> sin el elemento <var>x</var>.
Si <var>x</var> no es elemento de <var>a</var>, entonces el
resultado es el propio <var>a</var>.
</p>
<p>La funci&oacute;n <code>disjoin</code> emite un mensaje de error si
<var>a</var> no es un conjunto literal.
</p>
<p>Las sentencias <code>disjoin(<var>x</var>, <var>a</var>)</code>, <code>delete(<var>x</var>, <var>a</var>)</code>
y <code>setdifference(<var>a</var>, set(<var>x</var>))</code> son todas ellas equivalentes;
pero en general, <code>disjoin</code> ser&aacute; m&aacute;s r&aacute;pida que las otras.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) disjoin (a, {a, b, c, d});
(%o1)                       {b, c, d}
(%i2) disjoin (a + b, {5, z, a + b, %pi});
(%o2)                      {5, %pi, z}
(%i3) disjoin (a - b, {5, z, a + b, %pi});
(%o3)                  {5, %pi, b + a, z}
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>disjointp</b><i> (<var>a</var>, <var>b</var>) </i>
<a name="IDX1393"></a>
</dt>
<dd><p>Devuelve <code>true</code> si y s&oacute;lo si los conjuntos  <var>a</var> y <var>b</var>
son disjuntos.
</p>
<p>La funci&oacute;n <code>disjointp</code> emite un mensaje de error si
<var>a</var> o <var>b</var> no son conjuntos literales.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) disjointp ({a, b, c}, {1, 2, 3});
(%o1)                         true
(%i2) disjointp ({a, b, 3}, {1, 2, 3});
(%o2)                         false
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>divisors</b><i> (<var>n</var>)</i>
<a name="IDX1394"></a>
</dt>
<dd><p>Calcula el conjunto de divisores de <var>n</var>.
</p>
<p>La sentencia <code>divisors(<var>n</var>)</code> devuelve un conjunto
de enteros si <var>n</var> es un entero no nulo.
El conjunto de divisores incluye los elementos 1 y <var>n</var>.
Los divisores de un entero negativo son los divisores de su
valor absoluto.
</p>
<p>La funci&oacute;n <code>divisors</code> se distribuye sobre las ecuaciones,
listas, matrices y conjuntos.
</p>
<p>Ejemplos:
</p>
<p>Se puede comprobar que 28 es un n&uacute;mero perfecto:
la suma de sus divisores (excepto &eacute;l mismo) es 28.
</p>
<pre class="example">(%i1) s: divisors(28);
(%o1)                 {1, 2, 4, 7, 14, 28}
(%i2) lreduce (&quot;+&quot;, args(s)) - 28;
(%o2)                          28
</pre>
<p>La funci&oacute;n <code>divisors</code> es simplificadora.
Haciendo la sustituci&oacute;n de <code>a</code> por 8 en <code>divisors(a)</code>
devuelve los divisores sin tener que reevaluar <code>divisors(8)</code>,
</p>
<pre class="example">(%i1) divisors (a);
(%o1)                      divisors(a)
(%i2) subst (8, a, %);
(%o2)                     {1, 2, 4, 8}
</pre>
<p>La funci&oacute;n <code>divisors</code> se distribuye sobre ecuaciones, listas,
matrices y conjuntos.
</p>
<pre class="example">(%i1) divisors (a = b);
(%o1)               divisors(a) = divisors(b)
(%i2) divisors ([a, b, c]);
(%o2)        [divisors(a), divisors(b), divisors(c)]
(%i3) divisors (matrix ([a, b], [c, d]));
                  [ divisors(a)  divisors(b) ]
(%o3)             [                          ]
                  [ divisors(c)  divisors(d) ]
(%i4) divisors ({a, b, c});
(%o4)        {divisors(a), divisors(b), divisors(c)}
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>elementp</b><i> (<var>x</var>, <var>a</var>)</i>
<a name="IDX1395"></a>
</dt>
<dd><p>Devuelve <code>true</code> si y s&oacute;lo si <var>x</var> es miembro del
conjunto <var>a</var>.
</p>
<p>La funci&oacute;n <code>elementp</code> emite un mensaje de error si 
<var>a</var> no es un conjunto literal.
</p>
<p>Ejemplos: 
</p>
<pre class="example">(%i1) elementp (sin(1), {sin(1), sin(2), sin(3)});
(%o1)                         true
(%i2) elementp (sin(1), {cos(1), cos(2), cos(3)});
(%o2)                         false
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>emptyp</b><i> (<var>a</var>)</i>
<a name="IDX1396"></a>
</dt>
<dd><p>Devuelve <code>true</code> si y s&oacute;lo si <var>a</var> es el conjunto vac&iacute;o o la lista vac&iacute;a.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) map (emptyp, [{}, []]);
(%o1)                     [true, true]
(%i2) map (emptyp, [a + b, {{}}, %pi]);
(%o2)                 [false, false, false]
</pre></dd></dl>
       

<dl>
<dt><u>Funci&oacute;n:</u> <b>equiv_classes</b><i> (<var>s</var>, <var>F</var>)</i>
<a name="IDX1397"></a>
</dt>
<dd><p>Devuelve el conjunto de las clases de equivalencia del conjunto <var>s</var>
respecto de la relaci&oacute;n de equivalencia <var>F</var>.
</p>
<p>El argumento <var>F</var> es una funci&oacute;n de dos variables definida sobre
el producto cartesiano <var>s</var> por <var>s</var>.
El valor devuelto por <var>F</var> debe ser <code>true</code> o <code>false</code>,
o bien una expresi&oacute;n <var>expr</var> tal que <code>is(<var>expr</var>)</code>
tome el valor <code>true</code> o <code>false</code>.
</p>
<p>Si <var>F</var> no es una relaci&oacute;n de equivalencia, <code>equiv_classes</code>
la acepta sin emitir ning&uacute;n mensaje de error, pero el resultado
ser&aacute; incorrecto en general.
</p>
<p>Ejemplos:
</p>
<p>La relaci&oacute;n de equivalencia es una expresi&oacute;n lambda que devuelve 
<code>true</code> o <code>false</code>,
</p>
<pre class="example">(%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0},
                      lambda ([x, y], is (equal (x, y))));
(%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}
</pre>
<p>La relaci&oacute;n de equivalencia es el nombre de una funci&oacute;n relacional
en la que <code>is</code> eval&uacute;a a <code>true</code> o <code>false</code>,
</p>
<pre class="example">(%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0}, equal);
(%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}
</pre>
<p>Las clases de equivalencia son n&uacute;meros que difieren en un m&uacute;ltiplo de 3.
</p>
<pre class="example">(%i1) equiv_classes ({1, 2, 3, 4, 5, 6, 7}, 
              lambda ([x, y], remainder (x - y, 3) = 0));
(%o1)              {{1, 4, 7}, {2, 5}, {3, 6}}
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>every</b><i> (<var>f</var>, <var>s</var>)</i>
<a name="IDX1398"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>every</b><i> (<var>f</var>, <var>L_1</var>, ..., <var>L_n</var>)</i>
<a name="IDX1399"></a>
</dt>
<dd><p>Devuelve <code>true</code> si el predicado <var>f</var> vale <code>true</code>
para todos los argumentos dados.
</p>
<p>Dado un conjunto como segundo argumento,
<code>every(<var>f</var>, <var>s</var>)</code> devuelve <code>true</code>
si <code>is(<var>f</var>(<var>a_i</var>))</code> devuelve <code>true</code> para todos los
<var>a_i</var> pertenecientes <var>s</var>.
La funci&oacute;n <code>every</code> puede evaluar o no <var>f</var> para todos los
<var>a_i</var> pertenecientes <var>s</var>.
Puesto que los conjuntos no est&aacute;n ordenados, <code>every</code>
puede evaluar <code><var>f</var>(<var>a_i</var>)</code> en cualquier orden.
</p>
<p>Dada una o m&aacute;s listas como argumentos,
<code>every(<var>f</var>, <var>L_1</var>, ..., <var>L_n</var>)</code> devuelve <code>true</code>
si <code>is(<var>f</var>(<var>x_1</var>, ..., <var>x_n</var>))</code> devuelve <code>true</code> 
para todo <var>x_1</var>, ..., <var>x_n</var> en <var>L_1</var>, ..., <var>L_n</var>, respectivamente.
La funci&oacute;n <code>every</code> puede evaluar o no 
<var>f</var> para cualquier combinaci&oacute;n de <var>x_1</var>, ..., <var>x_n</var>; adem&aacute;s,
<code>every</code> eval&uacute;a las listas en el orden creciente del &iacute;ndice.
</p>
<p>Dado un conjunto vac&iacute;o <code>{}</code> o lista vac&iacute;a 
<code>[]</code> como argumentos, <code>every</code> devuelve <code>false</code>.
</p>
<p>Si la variable global <code>maperror</code> vale <code>true</code>, todas las listas
<var>L_1</var>, ..., <var>L_n</var> deben ser de igual longitud.
Si <code>maperror</code> vale <code>false</code>, los argumentos en forma de listas
se truncan para igualar sus longitudes a la de la lista m&aacute;s corta.
</p>
<p>Los valores que devuelve el predicado <var>f</var> cuando toman 
(mediante <code>is</code>) un valor diferente a <code>true</code> y <code>false</code>
se controlan con la variable global <code>prederror</code>.
Si <code>prederror</code> vale <code>true</code>, tales valores se
consideran como <code>false</code> y la respuesta de <code>every</code> es <code>false</code>.
Si <code>prederror</code> vale <code>false</code>, tales valores se
consideran como desconocidos (<code>unknown</code>) y la respuesta de 
<code>every</code> es <code>unknown</code>.
</p>
<p>Ejemplos:
</p>
<p>Se aplica <code>every</code> a un &uacute;nico conjunto.
El predicado es una funci&oacute;n de un argumento.
</p>
<pre class="example">(%i1) every (integerp, {1, 2, 3, 4, 5, 6});
(%o1)                         true
(%i2) every (atom, {1, 2, sin(3), 4, 5 + y, 6});
(%o2)                         false
</pre>
<p>Se aplica <code>every</code> a dos listas.
El predicado es una funci&oacute;n de dos argumentos.
</p>
<pre class="example">(%i1) every (&quot;=&quot;, [a, b, c], [a, b, c]);
(%o1)                         true
(%i2) every (&quot;#&quot;, [a, b, c], [a, b, c]);
(%o2)                         false
</pre>
<p>Las respuestas del predicado <var>f</var> que se eval&uacute;an 
a cualquier cosa diferente de <code>true</code> y <code>false</code>
est&aacute;n controlados por la variable global <code>prederror</code>.
</p>
<pre class="example">(%i1) prederror : false;
(%o1)                         false
(%i2) map (lambda ([a, b], is (a &lt; b)), [x, y, z],
                   [x^2, y^2, z^2]);
(%o2)              [unknown, unknown, unknown]
(%i3) every (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z^2]);
(%o3)                        unknown
(%i4) prederror : true;
(%o4)                         true
(%i5) every (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z^2]);
(%o5)                         false
</pre></dd></dl>
 

<dl>
<dt><u>Funci&oacute;n:</u> <b>extremal_subset</b><i> (<var>s</var>, <var>f</var>, max)</i>
<a name="IDX1400"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>extremal_subset</b><i> (<var>s</var>, <var>f</var>, min)</i>
<a name="IDX1401"></a>
</dt>
<dd><p>Calcula el subconjunto de <var>s</var> para el cual la funci&oacute;n <var>f</var>
toma sus valores mayor y menor.
</p>
<p>La sentencia <code>extremal_subset(<var>s</var>, <var>f</var>, max)</code>
devuelve el subconjunto del conjunto o lista <var>s</var> para el cual
la funci&oacute;n real <var>f</var> toma su valor m&aacute;ximo.
</p>
<p>La sentencia <code>extremal_subset(<var>s</var>, <var>f</var>, min)</code>
devuelve el subconjunto del conjunto o lista <var>s</var> para el cual
la funci&oacute;n real <var>f</var> toma su valor m&iacute;nimo.
</p>
<p>Ejemplos
</p>
<pre class="example">(%i1) extremal_subset ({-2, -1, 0, 1, 2}, abs, max);
(%o1)                       {- 2, 2}
(%i2) extremal_subset ({sqrt(2), 1.57, %pi/2}, sin, min);
(%o2)                       {sqrt(2)}
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>flatten</b><i> (<var>expr</var>)</i>
<a name="IDX1402"></a>
</dt>
<dd><p>Recoge los argumentos de subexpresiones con el mismo operador que <var>expr</var>
y construye con ellas otra expresi&oacute;n a partir de estos argumentos.
</p>
<p>Aquellas subexpresiones en las que el operador es diferente del operador
principal de <code>expr</code> se copian sin modificarse, incluso cuando ellas
mismas contengan subexpresiones en las que el operador sea el mismo 
que el de <code>expr</code>.
</p>
<p>Es posible que <code>flatten</code> construya expresiones en las que el n&uacute;mero
de argumentos difiera del n&uacute;mero admitido por el operador, lo cual
har&aacute; que se emita un mensaje de error. La funci&oacute;n <code>flatten</code>
no intentar&aacute; detectar estas situaciones.
</p>
<p>Las expresiones que tengan representaciones especiales, por ejemplo las racionales
can&oacute;nicas (CRE), no admiten que se aplique sobre ellas la funci&oacute;n <code>flatten</code>;
en tales casos se devuelve el argumento sin modificaci&oacute;n.
</p>
<p>Ejemplos:
</p>
<p>Aplicada a una lista, <code>flatten</code> reune todos los elementos que son a su vez listas.
</p>
<pre class="example">(%i1) flatten ([a, b, [c, [d, e], f], [[g, h]], i, j]);
(%o1)            [a, b, c, d, e, f, g, h, i, j]
</pre>
<p>Aplicado a un conjunto, <code>flatten</code> reune todos los elementos que son a su vez conjuntos.
</p>
<pre class="example">(%i1) flatten ({a, {b}, {{c}}});
(%o1)                       {a, b, c}
(%i2) flatten ({a, {[a], {a}}});
(%o2)                       {a, [a]}
</pre>
<p>La funci&oacute;n <code>flatten</code> es similar a la declaraci&oacute;n del operador
principal como n-ario. Sin embargo, <code>flatten</code> no tiene efecto alguno
sobre subexpresiones que tengan un operador diferente del principal, mientras
que s&iacute; lo tiene una declaraci&oacute;n n-aria.
</p>

<pre class="example">(%i1) expr: flatten (f (g (f (f (x)))));
(%o1)                     f(g(f(f(x))))
(%i2) declare (f, nary);
(%o2)                         done
(%i3) ev (expr);
(%o3)                      f(g(f(x)))
</pre>
<p>La funci&oacute;n <code>flatten</code> trata las funciones subindicadas como
a cualquier otro operador.
</p>
<pre class="example">(%i1) flatten (f[5] (f[5] (x, y), z));
(%o1)                      f (x, y, z)
                            5
</pre>
<p>Es posible que <code>flatten</code> construya expresiones en las que el n&uacute;mero
de argumentos difiera del n&uacute;mero admitido por el operador.
</p>
<pre class="example">(%i1) 'mod (5, 'mod (7, 4));
(%o1)                   mod(5, mod(7, 4))
(%i2) flatten (%);
(%o2)                     mod(5, 7, 4)
(%i3) ''%, nouns;
Wrong number of arguments to mod
 -- an error.  Quitting.  To debug this try debugmode(true);
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>full_listify</b><i> (<var>a</var>)</i>
<a name="IDX1403"></a>
</dt>
<dd><p>Sustituye los operadores de conjunto presentes en <var>a</var>
por operadores de listas, devolviendo el resultado.
La funci&oacute;n <code>full_listify</code> sustituye operadores de 
conjuntos en subexpresiones anidadas, incluso cuando
el operador principal no es <code>set</code>.
</p>
<p>La funci&oacute;n <code>listify</code> sustituye &uacute;nicamente el
operador principal.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) full_listify ({a, b, {c, {d, e, f}, g}});
(%o1)               [a, b, [c, [d, e, f], g]]
(%i2) full_listify (F (G ({a, b, H({c, d, e})})));
(%o2)              F(G([a, b, H([c, d, e])]))
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>fullsetify</b><i> (<var>a</var>)</i>
<a name="IDX1404"></a>
</dt>
<dd><p>Si <var>a</var> es una lista, sustituye el operador de lista por el
de conjunto, aplicando posteriormente <code>fullsetify</code> a todos
los elementos que son a su vez conjuntos.
Si <var>a</var> no es una lista, se devuelve sin cambio alguno.
</p>
<p>La funci&oacute;n <code>setify</code> sustituye solamente el operador principal.
</p>
<p>Ejemplos:
</p>
<p>En la salida <code>(%o2)</code> el argumento de <code>f</code> no se convierte en
conjunto porque el operador principal de <code>f([b])</code> no es una lista.
</p>
<pre class="example">(%i1) fullsetify ([a, [a]]);
(%o1)                       {a, {a}}
(%i2) fullsetify ([a, f([b])]);
(%o2)                      {a, f([b])}
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>identity</b><i> (<var>x</var>)</i>
<a name="IDX1405"></a>
</dt>
<dd><p>La funci&oacute;n <code>identity</code> devuelve su argumento cualquiera que sea &eacute;ste.
</p>
<p>Ejemplos:
</p>
<p>La funci&oacute;n <code>identity</code> puede utilizarse como predicado cuando
los argumentos ya son valores booleanos.
</p>
<pre class="example">(%i1) every (identity, [true, true]);
(%o1)                         true
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>integer_partitions</b><i> (<var>n</var>)</i>
<a name="IDX1406"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>integer_partitions</b><i> (<var>n</var>, <var>len</var>)</i>
<a name="IDX1407"></a>
</dt>
<dd><p>Devuelve particiones enteras de <var>n</var>, esto es,
listas de enteros cuyas sumas son <var>n</var>.
</p>
<p>La sentencia <code>integer_partitions(<var>n</var>)</code>
devuelve el conjunto de todas las particiones del entero <var>n</var>.
Cada partici&oacute;n es una lista ordenada de mayor a menor.
</p>
<p>La sentencia <code>integer_partitions(<var>n</var>, <var>len</var>)</code>
devuelve todas las particiones de longitud <var>len</var> o menor;
en este caso, se a&ntilde;aden ceros a cada partici&oacute;n con menos
de <var>len</var> t&eacute;rminos para que todas ellas sean de longitud
<var>len</var>. Las particiones son listas ordenadas de mayor a menor.
</p>
<p>Una lista <em>[a_1, ..., a_m]</em> es una partici&oacute;n de un entero no
negativo <em>n</em> si (1) cada <em>a_i</em> es entero no nulo y (2)
<em>a_1 + ... + a_m = n.</em> As&iacute;, 0 no tiene particiones.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) integer_partitions (3);
(%o1)               {[1, 1, 1], [2, 1], [3]}
(%i2) s: integer_partitions (25)$
(%i3) cardinality (s);
(%o3)                         1958
(%i4) map (lambda ([x], apply (&quot;+&quot;, x)), s);
(%o4)                         {25}
(%i5) integer_partitions (5, 3);
(%o5) {[2, 2, 1], [3, 1, 1], [3, 2, 0], [4, 1, 0], [5, 0, 0]}
(%i6) integer_partitions (5, 2);
(%o6)               {[3, 2], [4, 1], [5, 0]}
</pre>
<p>Para encontrar todas las particiones que satisfagan cierta
condici&oacute;n, util&iacute;cese la funci&oacute;n <code>subset</code>;
he aqu&iacute; un ejemplo que encuentra todas las
particiones de 10 formadas por n&uacute;meros primos.
</p>
<pre class="example">(%i1) s: integer_partitions (10)$
(%i2) cardinality (s);
(%o2)                          42
(%i3) xprimep(x) := integerp(x) and (x &gt; 1) and primep(x)$
(%i4) subset (s, lambda ([x], every (xprimep, x)));
(%o4) {[2, 2, 2, 2, 2], [3, 3, 2, 2], [5, 3, 2], [5, 5], [7, 3]}
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>intersect</b><i> (<var>a_1</var>, ..., <var>a_n</var>)</i>
<a name="IDX1408"></a>
</dt>
<dd><p>Es una forma abreviada de la funci&oacute;n <code>intersection</code>.
</p></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>intersection</b><i> (<var>a_1</var>, ..., <var>a_n</var>)</i>
<a name="IDX1409"></a>
</dt>
<dd><p>Devuelve el conjunto de todos los elementos que son
comunes a los conjuntos  <var>a_1</var> a <var>a_n</var>.
</p>
<p>Emite un mensaje de error en caso de que cualquiera de los 
<var>a_i</var> no sea un conjunto.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) S_1 : {a, b, c, d};
(%o1)                     {a, b, c, d}
(%i2) S_2 : {d, e, f, g};
(%o2)                     {d, e, f, g}
(%i3) S_3 : {c, d, e, f};
(%o3)                     {c, d, e, f}
(%i4) S_4 : {u, v, w};
(%o4)                       {u, v, w}
(%i5) intersection (S_1, S_2);
(%o5)                          {d}
(%i6) intersection (S_2, S_3);
(%o6)                       {d, e, f}
(%i7) intersection (S_1, S_2, S_3);
(%o7)                          {d}
(%i8) intersection (S_1, S_2, S_3, S_4);
(%o8)                          {}
</pre></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>kron_delta</b><i> (<var>x1</var>, <var>y1</var>, &hellip;, <var>xp</var>, <var>yp</var>)</i>
<a name="IDX1410"></a>
</dt>
<dd><p>Es la funci&oacute;n delta de Kronecker.
</p>
<p>La funci&oacute;n <code>kron_delta</code> devuelve 1 cuando <var>xi</var> y
<var>yi</var> son iguales para todos los pares, devolviendo 0 si existe
un par en el que <var>xi</var> y <var>yi</var> no sean iguales. La igualdad
se determina utilizando <code>is(equal(xi,xj))</code> y la desigualdad
con <code>is(notequal(xi,xj))</code>. En caso de un solo argumento,
<code>kron_delta</code> devuelve un mensaje de error.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) kron_delta(a,a);
(%o1)                                  1
(%i2) kron_delta(a,b,a,b);
(%o2)                          kron_delta(a, b)
(%i3) kron_delta(a,a,b,a+1);
(%o3)                                  0
(%i4) assume(equal(x,y));
(%o4)                            [equal(x, y)]
(%i5) kron_delta(x,y);
(%o5)                                  1
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>listify</b><i> (<var>a</var>)</i>
<a name="IDX1411"></a>
</dt>
<dd><p>Si <var>a</var> es un conjunto, devuelve una lista con los elementos de <var>a</var>;
si  <var>a</var> no es un conjunto, devuelve <var>a</var>.
</p>
<p>La funci&oacute;n <code>full_listify</code> sustituye todos los operadores
de conjunto en <var>a</var> por operadores de lista.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) listify ({a, b, c, d});
(%o1)                     [a, b, c, d]
(%i2) listify (F ({a, b, c, d}));
(%o2)                    F({a, b, c, d})
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>lreduce</b><i> (<var>f</var>, <var>s</var>)</i>
<a name="IDX1412"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>lreduce</b><i> (<var>f</var>, <var>s</var>, <var>init</var>)</i>
<a name="IDX1413"></a>
</dt>
<dd><p>Ampl&iacute;a la funci&oacute;n binaria <var>F</var> a n-aria mediante
composici&oacute;n, siendo <var>s</var> una lista.
</p>
<p>La sentencia  <code>lreduce(<var>F</var>, <var>s</var>)</code> devuelve
<code>F(... F(F(s_1, s_2), s_3), ... s_n)</code>.
Si se incluye el argumento opcional <var>s_0</var>,
el resultado equivale a <code>lreduce(<var>F</var>, cons(<var>s_0</var>, <var>s</var>))</code>.
</p>
<p>La funci&oacute;n <var>F</var> se aplica primero a los elementos del
extremo izquierdo de la lista, de ah&iacute; el nombre
<code>lreduce</code>, (<i>left reduce</i>).
</p>
<p>V&eacute;anse tambi&eacute;n <code>rreduce</code>, <code>xreduce</code> y <code>tree_reduce</code>.
</p>
<p>Ejemplos:
</p>
<p>La funci&oacute;n <code>lreduce</code> sin el argumento opcional,
</p>
<pre class="example">(%i1) lreduce (f, [1, 2, 3]);
(%o1)                     f(f(1, 2), 3)
(%i2) lreduce (f, [1, 2, 3, 4]);
(%o2)                  f(f(f(1, 2), 3), 4)
</pre>
<p>La funci&oacute;n <code>lreduce</code> con el argumento opcional,
</p>
<pre class="example">(%i1) lreduce (f, [1, 2, 3], 4);
(%o1)                  f(f(f(4, 1), 2), 3)
</pre>
<p>La funci&oacute;n <code>lreduce</code> aplicada a operadores binarios de Maxima.
El s&iacute;mbolo <code>/</code> es el operador divisi&oacute;n.
</p>
<pre class="example">(%i1) lreduce (&quot;^&quot;, args ({a, b, c, d}));
                               b c d
(%o1)                       ((a ) )
(%i2) lreduce (&quot;/&quot;, args ({a, b, c, d}));
                                a
(%o2)                         -----
                              b c d
</pre>
</dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>makeset</b><i> (<var>expr</var>, <var>x</var>, <var>s</var>)</i>
<a name="IDX1414"></a>
</dt>
<dd><p>Genera un conjunto cuyos miembros se generan a partir de la
expresi&oacute;n <var>expr</var>, siendo <var>x</var> una lista de variables de
<var>expr</var> y <var>s</var> un conjunto o lista de listas.
Para generar los elementos del conjunto, se eval&uacute;a <var>expr</var>
asignando a las variables de <var>x</var> los elementos de <var>s</var>
en paralelo.
</p>
<p>Los elementos de <var>s</var> deben tener la misma longitud que <var>x</var>.
La lista de variables <var>x</var> debe ser una lista de s&iacute;mbolos
sin sub&iacute;ndices. Cuando se trate de un &uacute;nico s&iacute;mbolo,
<var>x</var> debe expresarse como una lista de un elemento y cada elemento de <var>s</var>
debe ser una lista de un s&oacute;lo elemento.
</p>

<p>V&eacute;ase tambi&eacute;n <code>makelist</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) makeset (i/j, [i, j], [[1, a], [2, b], [3, c], [4, d]]);
                           1  2  3  4
(%o1)                     {-, -, -, -}
                           a  b  c  d
(%i2) S : {x, y, z}$
(%i3) S3 : cartesian_product (S, S, S);
(%o3) {[x, x, x], [x, x, y], [x, x, z], [x, y, x], [x, y, y], 
[x, y, z], [x, z, x], [x, z, y], [x, z, z], [y, x, x], 
[y, x, y], [y, x, z], [y, y, x], [y, y, y], [y, y, z], 
[y, z, x], [y, z, y], [y, z, z], [z, x, x], [z, x, y], 
[z, x, z], [z, y, x], [z, y, y], [z, y, z], [z, z, x], 
[z, z, y], [z, z, z]}
(%i4) makeset (i + j + k, [i, j, k], S3);
(%o4) {3 x, 3 y, y + 2 x, 2 y + x, 3 z, z + 2 x, z + y + x, 
                                       z + 2 y, 2 z + x, 2 z + y}
(%i5) makeset (sin(x), [x], {[1], [2], [3]});
(%o5)               {sin(1), sin(2), sin(3)}
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>moebius</b><i> (<var>n</var>)</i>
<a name="IDX1415"></a>
</dt>
<dd><p>Representa la funci&oacute;n de Moebius.
</p>
<p>Si <var>n</var> es el producto de <em>k</em> n&uacute;meros primos diferentes,
<code>moebius(<var>n</var>)</code> devuelve <em>(-1)^k</em>, retornando 1 si 
<em><var>n</var> = 1</em> y 0 para cualesquiera otros enteros positivos.
</p>

<p>La funci&oacute;n de Moebius se distribuye respecto de ecuaciones,
listas, matrices y conjuntos.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) moebius (1);
(%o1)                           1
(%i2) moebius (2 * 3 * 5);
(%o2)                          - 1
(%i3) moebius (11 * 17 * 29 * 31);
(%o3)                           1
(%i4) moebius (2^32);
(%o4)                           0
(%i5) moebius (n);
(%o5)                      moebius(n)
(%i6) moebius (n = 12);
(%o6)                    moebius(n) = 0
(%i7) moebius ([11, 11 * 13, 11 * 13 * 15]);
(%o7)                      [- 1, 1, 1]
(%i8) moebius (matrix ([11, 12], [13, 14]));
                           [ - 1  0 ]
(%o8)                      [        ]
                           [ - 1  1 ]
(%i9) moebius ({21, 22, 23, 24});
(%o9)                      {- 1, 0, 1}
</pre></dd></dl>
 

<dl>
<dt><u>Funci&oacute;n:</u> <b>multinomial_coeff</b><i> (<var>a_1</var>, ..., <var>a_n</var>)</i>
<a name="IDX1416"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>multinomial_coeff</b><i> ()</i>
<a name="IDX1417"></a>
</dt>
<dd><p>Calcula el coeficiente multinomial.
</p>
<p>Si todos los <var>a_k</var> son enteros no negativos, el coeficiente multinomial
es el n&uacute;mero de formas de colocar  <code><var>a_1</var> + ... + <var>a_n</var></code>
objetos diferentes en  <em>n</em> cajas con <var>a_k</var> elementos en la
<em>k</em>-&eacute;sima caja. En general,
<code>multinomial_coeff (<var>a_1</var>, ..., <var>a_n</var>)</code> calcula
<code>(<var>a_1</var> + ... + <var>a_n</var>)!/(<var>a_1</var>! ... <var>a_n</var>!)</code>.
</p>
<p>Si no se dan argumentos, <code>multinomial_coeff()</code> devuelve 1.
</p>
<p>Se puede usar <code>minfactorial</code> para simplificar el valor
devuelto por <code>multinomial_coeff</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) multinomial_coeff (1, 2, x);
                            (x + 3)!
(%o1)                       --------
                              2 x!
(%i2) minfactorial (%);
                     (x + 1) (x + 2) (x + 3)
(%o2)                -----------------------
                                2
(%i3) multinomial_coeff (-6, 2);
                             (- 4)!
(%o3)                       --------
                            2 (- 6)!
(%i4) minfactorial (%);
(%o4)                          10
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>num_distinct_partitions</b><i> (<var>n</var>)</i>
<a name="IDX1418"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>num_distinct_partitions</b><i> (<var>n</var>, <var>list</var>)</i>
<a name="IDX1419"></a>
</dt>
<dd><p>Si <var>n</var> es un entero no negativo, devuelve el n&uacute;mero de
particiones enteras distintas de <var>n</var>, en caso contrario
<code>num_distinct_partitions</code> devuelve una forma nominal.
</p>
<p>La sentencia <code>num_distinct_partitions(<var>n</var>, list)</code>
devuelve una lista con el n&uacute;mero de particiones distintas
de 1, 2, 3, ..., <var>n</var>.
</p>
<p>Una partici&oacute;n distinta de <var>n</var> es una lista de n&uacute;meros
enteros positivos distintos <em>k_1</em>, ..., <em>k_m</em>
tales que <em><var>n</var> = k_1 + ... + k_m</em>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) num_distinct_partitions (12);
(%o1)                          15
(%i2) num_distinct_partitions (12, list);
(%o2)      [1, 1, 1, 2, 2, 3, 4, 5, 6, 8, 10, 12, 15]
(%i3) num_distinct_partitions (n);
(%o3)              num_distinct_partitions(n)
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>num_partitions</b><i> (<var>n</var>)</i>
<a name="IDX1420"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>num_partitions</b><i> (<var>n</var>, <var>list</var>)</i>
<a name="IDX1421"></a>
</dt>
<dd><p>Si <var>n</var> es un entero no negativo, devuelve el n&uacute;mero de
particiones enteras de <var>n</var>, en caso contrario <code>num_partitions</code>
devuelve una expresi&oacute;n nominal.
</p>
<p>La sentencia <code>num_partitions(<var>n</var>, list)</code> devuelve una lista
con los n&uacute;meros de particiones enteras de 1, 2, 3, ..., <var>n</var>.
</p>
<p>Siendo <var>n</var> un entero no negativo, <code>num_partitions(<var>n</var>)</code>
es igual a <code>cardinality(integer_partitions(<var>n</var>))</code>; sin
embargo, <code>num_partitions</code> no construye el conjunto de 
particiones, por lo que es m&aacute;s r&aacute;pido.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) num_partitions (5) = cardinality (integer_partitions (5));
(%o1)                         7 = 7
(%i2) num_partitions (8, list);
(%o2)            [1, 1, 2, 3, 5, 7, 11, 15, 22]
(%i3) num_partitions (n);
(%o3)                   num_partitions(n)
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>partition_set</b><i> (<var>a</var>, <var>f</var>)</i>
<a name="IDX1422"></a>
</dt>
<dd><p>Particiona el conjunto <var>a</var> respecto del predicado <var>f</var>.
</p>
<p>La funci&oacute;n <code>partition_set</code> devuelve una lista con dos conjuntos;
el primer conjunto es el subconjunto de <var>a</var> para el cual el predicado
<var>f</var> devuelve <code>false</code> y el segundo contiene al resto de elementos de <var>a</var>.
</p>
<p>La funci&oacute;n <code>partition_set</code> no aplica <code>is</code> al valor devuelto
por <var>f</var>.
</p>
<p>La funci&oacute;n <code>partition_set</code> emite un mensaje de error si <var>a</var>
no es un conjunto literal.
</p>
<p>V&eacute;ase tambi&eacute;n <code>subset</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) partition_set ({2, 7, 1, 8, 2, 8}, evenp);
(%o1)                   [{1, 7}, {2, 8}]
(%i2) partition_set ({x, rat(y), rat(y) + z, 1},
                  lambda ([x], ratp(x)));
(%o2)/R/              [{1, x}, {y, y + z}]
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>permutations</b><i> (<var>a</var>)</i>
<a name="IDX1423"></a>
</dt>
<dd><p>Devuelve un conjunto con todas las permutaciones distintas
de los miembros de la lista o conjunto  <var>a</var>. Cada permutaci&oacute;n
es una lista, no un conjunto.
</p>
<p>Si <var>a</var> es una lista, sus miembros duplicados no son eliminados
antes de buscar sus permutaciones.
</p>
<p>Si <var>a</var> no es una lista o conjunto, <code>permutations</code> emite
un mensaje de error.
</p>
<p>V&eacute;ase tambi&eacute;n <code>random_permutation</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) permutations ([a, a]);
(%o1)                       {[a, a]}
(%i2) permutations ([a, a, b]);
(%o2)           {[a, a, b], [a, b, a], [b, a, a]}
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>powerset</b><i> (<var>a</var>)</i>
<a name="IDX1424"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>powerset</b><i> (<var>a</var>, <var>n</var>)</i>
<a name="IDX1425"></a>
</dt>
<dd><p>Devuelve el conjunto de todos los subconjuntos del conjunto <var>a</var>
o un sunconjunto de ellos.
</p>
<p>La sentencia <code>powerset(<var>a</var>)</code> devuelve el conjunto de todos
los subconjuntos de <var>a</var>, que contendr&aacute; <code>2^cardinality(<var>a</var>)</code>
elementos.
</p>
<p>La sentencia <code>powerset(<var>a</var>, <var>n</var>)</code> devuelve el conjunto de todos
los subconjuntos de <var>a</var> de cardinalidad <var>n</var>.
</p>
<p>La funci&oacute;n <code>powerset</code> emite un mensaje de error si <var>a</var> no
es un conjunto literal o si <var>n</var> no es un entero no negativo.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) powerset ({a, b, c});
(%o1) {{}, {a}, {a, b}, {a, b, c}, {a, c}, {b}, {b, c}, {c}}
(%i2) powerset ({w, x, y, z}, 4);
(%o2)                    {{w, x, y, z}}
(%i3) powerset ({w, x, y, z}, 3);
(%o3)     {{w, x, y}, {w, x, z}, {w, y, z}, {x, y, z}}
(%i4) powerset ({w, x, y, z}, 2);
(%o4)   {{w, x}, {w, y}, {w, z}, {x, y}, {x, z}, {y, z}}
(%i5) powerset ({w, x, y, z}, 1);
(%o5)                 {{w}, {x}, {y}, {z}}
(%i6) powerset ({w, x, y, z}, 0);
(%o6)                         {{}}
</pre></dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>random_permutation</b><i> (<var>a</var>)</i>
<a name="IDX1426"></a>
</dt>
<dd><p>Devuelve una permutaci&oacute;n aleatoria del conjunto o lista
<var>a</var>, siguiendo el algoritmo de Knuth.
</p>
<p>El valor devuelto es una lista nueva distinta del argumento,
incluso cuando todos los elementos son iguales. Sin embargo,
los elementos del argumento no se copian.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) random_permutation ([a, b, c, 1, 2, 3]);
(%o1)                  [c, 1, 2, 3, a, b]
(%i2) random_permutation ([a, b, c, 1, 2, 3]);
(%o2)                  [b, 3, 1, c, a, 2]
(%i3) random_permutation ({x + 1, y + 2, z + 3});
(%o3)                 [y + 2, z + 3, x + 1]
(%i4) random_permutation ({x + 1, y + 2, z + 3});
(%o4)                 [x + 1, y + 2, z + 3]
</pre>
</dd></dl>




<dl>
<dt><u>Funci&oacute;n:</u> <b>rreduce</b><i> (<var>f</var>, <var>s</var>)</i>
<a name="IDX1427"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>rreduce</b><i> (<var>f</var>, <var>s</var>, <var>init</var>)</i>
<a name="IDX1428"></a>
</dt>
<dd><p>Ampl&iacute;a la funci&oacute;n binaria <var>F</var> a n-aria mediante
composici&oacute;n, siendo <var>s</var> una lista.
</p>
<p>La sentencia  <code>rreduce(<var>F</var>, <var>s</var>)</code> devuelve
<code>F(s_1, ... F(s_{n - 2}, F(s_{n - 1}, s_n)))</code>.
Si se incluye el argumento opcional <var>s_{n + 1}</var>,
el resultado equivale a <code>rreduce(<var>F</var>, endcons(<var>s_{n + 1}</var>, <var>s</var>))</code>.
</p>
<p>La funci&oacute;n <var>F</var> se aplica primero a los elementos del
extremo derecho de la lista, de ah&iacute; el nombre
<code>rreduce</code>, (<i>right reduce</i>).
</p>
<p>V&eacute;anse tambi&eacute;n <code>lreduce</code>, <code>xreduce</code> y <code>tree_reduce</code>.
</p>
<p>Ejemplos:
</p>
<p>La funci&oacute;n <code>rreduce</code> sin el argumento opcional,
</p>
<pre class="example">(%i1) rreduce (f, [1, 2, 3]);
(%o1)                     f(1, f(2, 3))
(%i2) rreduce (f, [1, 2, 3, 4]);
(%o2)                  f(1, f(2, f(3, 4)))
</pre>
<p>La funci&oacute;n <code>rreduce</code> con el argumento opcional,
</p>
<pre class="example">(%i1) rreduce (f, [1, 2, 3], 4);
(%o1)                  f(1, f(2, f(3, 4)))
</pre>
<p>La funci&oacute;n <code>rreduce</code> aplicada a operadores binarios de Maxima.
El s&iacute;mbolo <code>/</code> es el operador divisi&oacute;n.
</p>
<pre class="example">(%i1) rreduce (&quot;^&quot;, args ({a, b, c, d}));
                                 d
                                c
                               b
(%o1)                         a
(%i2) rreduce (&quot;/&quot;, args ({a, b, c, d}));
                               a c
(%o2)                          ---
                               b d
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>setdifference</b><i> (<var>a</var>, <var>b</var>)</i>
<a name="IDX1429"></a>
</dt>
<dd><p>Devuelve el conjunto con los elementos del conjunto <var>a</var> que
no pertenecen al conjunto <var>b</var>.
</p>
<p>La funci&oacute;n <code>setdifference</code> emite un mensaje de error si
<var>a</var> o <var>b</var> no son conjuntos.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) S_1 : {a, b, c, x, y, z};
(%o1)                  {a, b, c, x, y, z}
(%i2) S_2 : {aa, bb, c, x, y, zz};
(%o2)                 {aa, bb, c, x, y, zz}
(%i3) setdifference (S_1, S_2);
(%o3)                       {a, b, z}
(%i4) setdifference (S_2, S_1);
(%o4)                     {aa, bb, zz}
(%i5) setdifference (S_1, S_1);
(%o5)                          {}
(%i6) setdifference (S_1, {});
(%o6)                  {a, b, c, x, y, z}
(%i7) setdifference ({}, S_1);
(%o7)                          {}
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>setequalp</b><i> (<var>a</var>, <var>b</var>)</i>
<a name="IDX1430"></a>
</dt>
<dd><p>Devuelve  <code>true</code> si los conjuntos <var>a</var> y <var>b</var> tienen
el mismo n&uacute;mero de elementos
y <code>is (<var>x</var> = <var>y</var>)</code> vale <code>true</code>
para <code>x</code> perteneciente a <var>a</var>
e <code>y</code> perteneciente a <var>b</var>,
considerados en el orden que determina la funci&oacute;n 
<code>listify</code>. En caso contrario, <code>setequalp</code>
devuelve <code>false</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) setequalp ({1, 2, 3}, {1, 2, 3});
(%o1)                         true
(%i2) setequalp ({a, b, c}, {1, 2, 3});
(%o2)                         false
(%i3) setequalp ({x^2 - y^2}, {(x + y) * (x - y)});
(%o3)                         false
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>setify</b><i> (<var>a</var>)</i>
<a name="IDX1431"></a>
</dt>
<dd><p>Construye un conjunto con los miembros de la lista <var>a</var>.
Los elementos duplicados de la lista <var>a</var> son borrados
y ordenados de acuerdo con el predicado <code>orderlessp</code>.
</p>
<p>La funci&oacute;n <code>setify</code> emite un mensaje de error si
<var>a</var> no es un conjunto literal.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) setify ([1, 2, 3, a, b, c]);
(%o1)                  {1, 2, 3, a, b, c}
(%i2) setify ([a, b, c, a, b, c]);
(%o2)                       {a, b, c}
(%i3) setify ([7, 13, 11, 1, 3, 9, 5]);
(%o3)                {1, 3, 5, 7, 9, 11, 13}
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>setp</b><i> (<var>a</var>)</i>
<a name="IDX1432"></a>
</dt>
<dd><p>Devuelve <code>true</code> si y s&oacute;lo si <var>a</var> es un conjunto de Maxima.
</p>
<p>La funci&oacute;n <code>setp</code> devuelve <code>true</code> tanto cuando el conjunto
tiene como cuando no tiene elementos repetidos.
</p>
<p>La funci&oacute;n <code>setp</code> is equivalent to the Maxima function
<code>setp(a) := not atom(a) and op(a) = 'set</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) simp : false;
(%o1)                         false
(%i2) {a, a, a};
(%o2)                       {a, a, a}
(%i3) setp (%);
(%o3)                         true
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>set_partitions</b><i> (<var>a</var>)</i>
<a name="IDX1433"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>set_partitions</b><i> (<var>a</var>, <var>n</var>)</i>
<a name="IDX1434"></a>
</dt>
<dd><p>Devuelve el conjunto de todas las particiones de <var>a</var> o
un subconjunto de ellas.
</p>
<p>La sentencia <code>set_partitions(<var>a</var>, <var>n</var>)</code>
devuelve un conjunto con todas las descomposiciones de <var>a</var>
en <var>n</var> conjuntos no vac&iacute;os disjuntos.
</p>
<p>La sentencia <code>set_partitions(<var>a</var>)</code> devuelve el
conjunto de todas las particiones.
</p>
<p>La funci&oacute;n <code>stirling2</code> devuelve la cardinalidad del conjunto
de las particiones de un conjunto.
</p>
<p>Se dice que un conjunto <em>P</em> es una partici&oacute;n del conjunto <em>S</em> si verifica
</p>
<ol>
<li>
cada elemento de <em>P</em> es un conjunto no vac&iacute;o, 
</li><li>
los elementos de <em>P</em> son disjuntos,
</li><li>
la uni&oacute;n de los elementos de <em>P</em> es igual a  <em>S</em>.
</li></ol>

<p>Ejemplos:
</p>
<p>El conjunto vac&iacute;o forma una partici&oacute;n de s&iacute; mismo,
</p>
<pre class="example">(%i1) set_partitions ({});
(%o1)                         {{}}
</pre>
<p>La cardinalidad del conjunto de particiones de un conjunto puede calcularse con <code>stirling2</code>,
</p>
<pre class="example">(%i1) s: {0, 1, 2, 3, 4, 5}$
(%i2) p: set_partitions (s, 3)$ 
(%i3) cardinality(p) = stirling2 (6, 3);
(%o3)                        90 = 90
</pre>
<p>Cada elemento de <code>p</code> deber&iacute;a tener <var>n</var> = 3 miembros,
</p>
<pre class="example">(%i1) s: {0, 1, 2, 3, 4, 5}$
(%i2) p: set_partitions (s, 3)$ 
(%i3) map (cardinality, p);
(%o3)                          {3}
</pre>
<p>Por &uacute;ltimo, para cada miembro de <code>p</code>, la uni&oacute;n de sus elementos
debe ser igual a <code>s</code>,
</p>
<pre class="example">(%i1) s: {0, 1, 2, 3, 4, 5}$
(%i2) p: set_partitions (s, 3)$ 
(%i3) map (lambda ([x], apply (union, listify (x))), p);
(%o3)                 {{0, 1, 2, 3, 4, 5}}
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>some</b><i> (<var>f</var>, <var>a</var>)</i>
<a name="IDX1435"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>some</b><i> (<var>f</var>, <var>L_1</var>, ..., <var>L_n</var>)</i>
<a name="IDX1436"></a>
</dt>
<dd><p>Devuelve <code>true</code> si el predicado <var>f</var> devuelve <code>true</code>
para al menos uno de sus argumentos.
Si el segundo argumento es un conjunto, <code>some (<var>f</var>, <var>a</var>)</code>
devuelve <code>true</code> si <code><var>f</var>(<var>a_i</var>)</code> devuelve tambi&eacute;n
<code>true</code> para alguno de los <var>a_i</var> en <var>a</var>; puede ser que
<code>some</code> no eval&uacute;e <var>f</var> para todos los <var>a_i</var> de <var>s</var>.
Puesto que los conjuntos no est&aacute;n ordenados, <code>some</code> puede evaluar
<code><var>f</var>(<var>a_i</var>)</code> en cualquier orden.
</p>
<p>Dada una o m&aacute;s listas como argumentos,
<code>some (<var>f</var>, <var>L_1</var>, ..., <var>L_n</var>)</code> devuelve <code>true</code>
si <code><var>f</var>(<var>x_1</var>, ..., <var>x_n</var>)</code> devuelve tambi&eacute;n
<code>true</code> para al menos un  <var>x_1</var>, ..., <var>x_n</var> de
<var>L_1</var>, ..., <var>L_n</var>, respectivamente; puede ser que
<code>some</code> no eval&uacute;e <var>f</var> para todos las combinaciones
<var>x_1</var>, ..., <var>x_n</var>. La funci&oacute;n <code>some</code> eval&uacute;a
las listas en el orden creciente de su &iacute;ndice
</p>
<p>Dado un conjunto vac&iacute;o <code>{}</code> o una lista
vac&iacute;a como argumentos, <code>some</code> devuelve <code>false</code>.
</p>
<p>Si la variable global <code>maperror</code> vale <code>true</code>,
todas las listas <var>L_1</var>, ..., <var>L_n</var> deben tener
igual n&uacute;mero de elementos. Si <code>maperror</code> vale
<code>false</code>, los argumentos se truncan para tener todos
el n&uacute;mero de elementos de la lista m&aacute;s corta. 
</p>
<p>Los valores que devuelve el predicado <var>f</var> cuando toman 
(mediante <code>is</code>) un valor diferente a <code>true</code> y <code>false</code>
se controlan con la variable global <code>prederror</code>.
Si <code>prederror</code> vale <code>true</code>, tales valores se
consideran como <code>false</code>.
Si <code>prederror</code> vale <code>false</code>, tales valores se
consideran como desconocidos (<code>unknown</code>).
</p>
<p>Ejemplos:
</p>
<p>La funci&oacute;n <code>some</code> aplicada a un &uacute;nico conjunto.
El predicado es una funci&oacute;n de un argumento,
</p>
<pre class="example">(%i1) some (integerp, {1, 2, 3, 4, 5, 6});
(%o1)                         true
(%i2) some (atom, {1, 2, sin(3), 4, 5 + y, 6});
(%o2)                         true
</pre>
<p>La funci&oacute;n <code>some</code> aplicada a dos listas.
El predicado es una funci&oacute;n de dos argumentos,
</p>
<pre class="example">(%i1) some (&quot;=&quot;, [a, b, c], [a, b, c]);
(%o1)                         true
(%i2) some (&quot;#&quot;, [a, b, c], [a, b, c]);
(%o2)                         false
</pre>
<p>Las respuestas del predicado <var>f</var> que se eval&uacute;an 
a cualquier cosa diferente de <code>true</code> y <code>false</code>
est&aacute;n controlados por la variable global <code>prederror</code>.
</p>
<pre class="example">(%i1) prederror : false;
(%o1)                         false
(%i2) map (lambda ([a, b], is (a &lt; b)), [x, y, z],
                     [x^2, y^2, z^2]);
(%o2)              [unknown, unknown, unknown]
(%i3) some (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z^2]);
(%o3)                        unknown
(%i4) some (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z + 1]);
(%o4)                         true
(%i5) prederror : true;
(%o5)                         true
(%i6) some (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z^2]);
(%o6)                         false
(%i7) some (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z + 1]);
(%o7)                         true
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>stirling1</b><i> (<var>n</var>, <var>m</var>)</i>
<a name="IDX1437"></a>
</dt>
<dd><p>Es el n&uacute;mero de Stirling de primera especie.
</p>
<p>Si tanto <var>n</var> como <var>m</var> son enteros no negativos,
el valor que toma <code>stirling1 (<var>n</var>, <var>m</var>)</code>
es el n&uacute;mero de permutaciones de un conjunto de
<var>n</var> elementos con <var>m</var> ciclos. Para m&aacute;s detalles,
v&eacute;ase Graham, Knuth and Patashnik <i>Concrete Mathematics</i>.
Maxima utiliza una relaci&oacute;n recursiva para definir
<code>stirling1 (<var>n</var>, <var>m</var>)</code> para <var>m</var> menor
que 0; no est&aacute; definida para <var>n</var> menor que 0 ni
para argumentos no enteros.
</p>
<p>La funci&oacute;n <code>stirling1</code> es simplificadora. Maxima
reconoce las siguientes identidades:
</p>
<ol>
<li>
<em>stirling1(0, n) = kron_delta(0, n)</em> (Ref. [1])
</li><li>
<em>stirling1(n, n) = 1</em> (Ref. [1])
</li><li>
<em>stirling1(n, n - 1) = binomial(n, 2)</em> (Ref. [1])
</li><li>
<em>stirling1(n + 1, 0) = 0</em> (Ref. [1])
</li><li>
<em>stirling1(n + 1, 1) = n!</em> (Ref. [1])
</li><li>
<em>stirling1(n + 1, 2) = 2^n  - 1</em> (Ref. [1])
</li></ol>

<p>Estas identidades se aplican cuando los argumentos son enteros
literales o s&iacute;mbolos declarados como enteros y
el primer argumento es no negativo. La funci&oacute;n <code>stirling1</code>
no simplifica para argumentos no enteros.
</p>
<p>Referencias:
</p>
<p>[1] Donald Knuth, <i>The Art of Computer Programming,</i>
Tercera Edici&oacute;n, Volumen 1, Secci&oacute;n 1.2.6, Ecuaciones 48, 49 y 50.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) declare (n, integer)$
(%i2) assume (n &gt;= 0)$
(%i3) stirling1 (n, n);
(%o3)                           1
</pre>
<p>La funci&oacute;n <code>stirling1</code> no simplifica en caso de argumentos no enteros,
</p>
<pre class="example">(%i1) stirling1 (sqrt(2), sqrt(2));
(%o1)              stirling1(sqrt(2), sqrt(2))
</pre>
<p>Maxima aplicas algunas identidades a <code>stirling1</code>,
</p>
<pre class="example">(%i1) declare (n, integer)$
(%i2) assume (n &gt;= 0)$
(%i3) stirling1 (n + 1, n);
                            n (n + 1)
(%o3)                       ---------
                                2
(%i4) stirling1 (n + 1, 1);
(%o4)                          n!
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>stirling2</b><i> (<var>n</var>, <var>m</var>)</i>
<a name="IDX1438"></a>
</dt>
<dd><p>Es el n&uacute;mero de Stirling de segunda especie.
</p>
<p>Si <var>n</var> y <var>m</var> son enteros no negativos,
<code>stirling2 (<var>n</var>, <var>m</var>)</code> es el n&uacute;mero
de formas en las que se puede particionar un conjunto
de cardinal <var>n</var> en <var>m</var> subconjuntos disjuntos.
Maxima utiliza una relaci&oacute;n recursiva para definir
<code>stirling2 (<var>n</var>, <var>m</var>)</code> con <var>m</var> menor
que 0; la funci&oacute;n no est&aacute; definida para  <var>n</var>
menor que 0  ni para argumentos no enteros.
</p>
<p>La funci&oacute;n <code>stirling2</code> es simplificadora. Maxima
reconoce las siguientes identidades:
</p>
<ol>
<li>
<em>stirling2(0, n) = kron_delta(0, n)</em> (Ref. [1])
</li><li>
<em>stirling2(n, n) = 1</em> (Ref. [1])
</li><li>
<em>stirling2(n, n - 1) = binomial(n, 2)</em> (Ref. [1])
</li><li>
<em>stirling2(n + 1, 1) = 1</em> (Ref. [1])
</li><li>
<em>stirling2(n + 1, 2) = 2^n  - 1</em> (Ref. [1])
</li><li>
<em>stirling2(n, 0) = kron_delta(n, 0)</em> (Ref. [2])
</li><li>
<em>stirling2(n, m) = 0</em> when <em>m &gt; n</em> (Ref. [2])
</li><li>
<em>stirling2(n, m) = sum((-1)^(m - k) binomial(m k) k^n,i,1,m) / m!</em>
si <em>m</em> y <em>n</em> son enteros y <em>n</em> no negativo. (Ref. [3])
</li></ol>

<p>Estas identidades se aplican cuando los argumentos son enteros
literales o s&iacute;mbolos declarados como enteros y
el primer argumento es no negativo. La funci&oacute;n <code>stirling2</code>
no simplifica para argumentos no enteros.
</p>
<p>Referencias:
</p>
<p>[1] Donald Knuth. <i>The Art of Computer Programming</i>,
Tercera Edici&oacute;n, Volumen 1, Secci&oacute;n 1.2.6, Ecuaciones 48, 49 y 50.
</p>
<p>[2] Graham, Knuth y Patashnik. <i>Concrete Mathematics</i>, Tabla 264.
</p>
<p>[3] Abramowitz y Stegun. <i>Handbook of Mathematical Functions</i>, Secci&oacute;n 24.1.4.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) declare (n, integer)$
(%i2) assume (n &gt;= 0)$
(%i3) stirling2 (n, n);
(%o3)                           1
</pre>
<p>La funci&oacute;n <code>stirling2</code> no simplifica en caso de argumentos no enteros,
</p>
<pre class="example">(%i1) stirling2 (%pi, %pi);
(%o1)                  stirling2(%pi, %pi)
</pre>
<p>Maxima aplicas algunas identidades a <code>stirling2</code>,
</p>
<pre class="example">(%i1) declare (n, integer)$
(%i2) assume (n &gt;= 0)$
(%i3) stirling2 (n + 9, n + 8);
                         (n + 8) (n + 9)
(%o3)                    ---------------
                                2
(%i4) stirling2 (n + 1, 2);
                              n
(%o4)                        2  - 1
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>subset</b><i> (<var>a</var>, <var>f</var>)</i>
<a name="IDX1439"></a>
</dt>
<dd><p>Devuelve el subconjunto del conjunto <var>a</var> que satisface el predicado <var>f</var>.
</p>
<p>La funci&oacute;n <code>subset</code> devuelve el conjunto que contiene a los
elementos de <var>a</var> para los cuales <var>f</var> devuelve un resultado
diferente de <code>false</code>. La funci&oacute;n <code>subset</code> no aplica
<code>is</code> al valor retornado por <var>f</var>.
</p>
<p>La funci&oacute;n <code>subset</code> emite un mensaje de error si <var>a</var>
no es un conjunto literal.
</p>
<p>V&eacute;ase tambi&eacute;n <code>partition_set</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) subset ({1, 2, x, x + y, z, x + y + z}, atom);
(%o1)                     {1, 2, x, z}
(%i2) subset ({1, 2, 7, 8, 9, 14}, evenp);
(%o2)                      {2, 8, 14}
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>subsetp</b><i> (<var>a</var>, <var>b</var>)</i>
<a name="IDX1440"></a>
</dt>
<dd><p>Devuelve <code>true</code> si y s&oacute;lo si el conjunto <var>a</var> es un subconjunto de <var>b</var>.
</p>
<p>La funci&oacute;n <code>subsetp</code> emite un mensaje de error si
cualesquiera <var>a</var> o <var>b</var> no es un conjunto literal.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) subsetp ({1, 2, 3}, {a, 1, b, 2, c, 3});
(%o1)                         true
(%i2) subsetp ({a, 1, b, 2, c, 3}, {1, 2, 3});
(%o2)                         false
</pre></dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>symmdifference</b><i> (<var>a_1</var>, &hellip;, <var>a_n</var>)</i>
<a name="IDX1441"></a>
</dt>
<dd><p>Devuelve la diferencia sim&eacute;trica de los conjuntos <code> <var>a_1</var>, &hellip;, <var>a_n</var></code>.
</p>
<p>Dados dos argumentos, <code>symmdifference (<var>a</var>, <var>b</var>)</code> equivale a
<code>union (setdifference (<var>a</var>, <var>b</var>), setdifference (<var>b</var>, <var>a</var>))</code>.
</p>
<p>La funci&oacute;n <code>symmdifference</code> emite un mensaje de error si alguno de
su argumentos no es un conjunto literal.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) S_1 : {a, b, c};
(%o1)                       {a, b, c}
(%i2) S_2 : {1, b, c};
(%o2)                       {1, b, c}
(%i3) S_3 : {a, b, z};
(%o3)                       {a, b, z}
(%i4) symmdifference ();
(%o4)                          {}
(%i5) symmdifference (S_1);
(%o5)                       {a, b, c}
(%i6) symmdifference (S_1, S_2);
(%o6)                        {1, a}
(%i7) symmdifference (S_1, S_2, S_3);
(%o7)                       {1, b, z}
(%i8) symmdifference ({}, S_1, S_2, S_3);
(%o8)                       {1,b, z}
</pre></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>tree_reduce</b><i> (<var>F</var>, <var>s</var>)</i>
<a name="IDX1442"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>tree_reduce</b><i> (<var>F</var>, <var>s</var>, <var>s_0</var>)</i>
<a name="IDX1443"></a>
</dt>
<dd><p>Ampl&iacute;a la funci&oacute;n binaria <var>F</var> a n-aria, siendo <var>s</var> una lista.
</p>
<p>La funci&oacute;n <code>tree_reduce</code> equivale a lo suguiente:
Aplicar <var>F</var> a pares sucesivos de elementos para formar
una nueva lista <code>[<var>F</var>(<var>s_1</var>, <var>s_2</var>), <var>F</var>(<var>s_3</var>, <var>s_4</var>), ...]</code>,
llevando el elemento final sin cambiar si el n&uacute;mero de elementos es impar;
despu&eacute;s repetir hasta que la lista se reduzca a un &uacute;nico elemento,
que es el valor de retorno.
</p>
<p>Cuando est&aacute; presente el argumento opcional <var>s_0</var>,
el resultado equivale a <code>tree_reduce(<var>F</var>, cons(<var>s_0</var>, <var>s</var>)</code>.
</p>
<p>Para la suma de n&uacute;meros decimales en coma flotante,
<code>tree_reduce</code> puede devolver una suma que tenga un error
de redondeo menor que el conseguido por <code>rreduce</code> o <code>lreduce</code>.
</p>
<p>Los elementos de <var>s</var> y los resultados parciales pueden colocarse
en un &aacute;rbol binario de m&iacute;nima profundidad, de ah&iacute;
el nombre de <i>tree_reduce</i>.
</p>
<p>Ejemplos:
</p>
<p>La funci&oacute;n <code>tree_reduce</code> aplicada a una lista con un n&uacute;mero
par de elementos,
</p>
<pre class="example">(%i1) tree_reduce (f, [a, b, c, d]);
(%o1)                  f(f(a, b), f(c, d))
</pre>
<p>La funci&oacute;n <code>tree_reduce</code> aplicada a una lista con un n&uacute;mero
impar de elementos,
</p>
<pre class="example">(%i1) tree_reduce (f, [a, b, c, d, e]);
(%o1)               f(f(f(a, b), f(c, d)), e)
</pre></dd></dl>


<dl>
<dt><u>Function:</u> <b>union</b><i> (<var>a_1</var>, ..., <var>a_n</var>)</i>
<a name="IDX1444"></a>
</dt>
<dd><p>Devuelve la uni&oacute;n de los conjuntos <var>a_1</var> hasta <var>a_n</var>.
</p>
<p>La sentencia <code>union()</code> (sin argumentos) devuelve el
conjunto vac&iacute;o.
</p>
<p>La funci&oacute;n <code>union</code> emite un mensaje de error si alguno
de sus argumentos no es un conjunto literal.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) S_1 : {a, b, c + d, %e};
(%o1)                   {%e, a, b, d + c}
(%i2) S_2 : {%pi, %i, %e, c + d};
(%o2)                 {%e, %i, %pi, d + c}
(%i3) S_3 : {17, 29, 1729, %pi, %i};
(%o3)                {17, 29, 1729, %i, %pi}
(%i4) union ();
(%o4)                          {}
(%i5) union (S_1);
(%o5)                   {%e, a, b, d + c}
(%i6) union (S_1, S_2);
(%o6)              {%e, %i, %pi, a, b, d + c}
(%i7) union (S_1, S_2, S_3);
(%o7)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}
(%i8) union ({}, S_1, S_2, S_3);
(%o8)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>xreduce</b><i> (<var>F</var>, <var>s</var>)</i>
<a name="IDX1445"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>xreduce</b><i> (<var>F</var>, <var>s</var>, <var>s_0</var>)</i>
<a name="IDX1446"></a>
</dt>
<dd><p>Ampl&iacute;a la funci&oacute;n <var>F</var> a n-aria mediante
composici&oacute;n; si <var>F</var> ya es n-aria, aplica <var>F</var> a <var>s</var>.
Si <var>F</var> no es n-aria, <code>xreduce</code> equivale a <code>lreduce</code>.
El argumento <var>s</var> debe ser una lista.
</p>
<p>Funciones n-arias reconocidas por Maxima son la suma <code>+</code>, la
multiplicaci&oacute;n <code>*</code>, <code>and</code>, <code>or</code>, <code>max</code>,
<code>min</code> y <code>append</code>. Las funciones tambi&eacute;n se pueden
declarar n-arias mediante <code>declare(<var>F</var>, nary)</code>;
para estas funciones, <code>xreduce</code> ser&aacute; m&aacute;s r&aacute;pida que
<code>rreduce</code> o <code>lreduce</code>.
</p>
<p>Cuando est&aacute; presente el argumento opcional <var>s_0</var>,
el resultado equivale a <code>xreduce(<var>s</var>, cons(<var>s_0</var>, <var>s</var>))</code>.
</p>
<p>La suma de n&uacute;meros decimales en coma flotante no es exactamente asociativa;
a&uacute;n as&iacute;, <code>xreduce</code> aplica la suma n-aria cuando <var>s</var>
contiene n&uacute;meros en coma flotante.
</p>
<p>Ejemplos:
</p>
<p>La funci&oacute;n <code>xreduce</code> aplicada a una funci&oacute;n n-aria;
<code>F</code> es invocada una s&oacute;la vez, con todos sus argumentos,
</p>
<pre class="example">(%i1) declare (F, nary);
(%o1)                         done
(%i2) F ([L]) := L;
(%o2)                      F([L]) := L
(%i3) xreduce (F, [a, b, c, d, e]);
(%o3)         [[[[[(&quot;[&quot;, simp), a], b], c], d], e]
</pre>
<p>La funci&oacute;n <code>xreduce</code> aplicada a una funci&oacute;n que se desconoce si
es n-aria; <code>G</code> es invocada varias veces, con dos argumentos de cada vez,
</p>
<pre class="example">(%i1) G ([L]) := L;
(%o1)                      G([L]) := L
(%i2) xreduce (G, [a, b, c, d, e]);
(%o2)         [[[[[(&quot;[&quot;, simp), a], b], c], d], e]
(%i3) lreduce (G, [a, b, c, d, e]);
(%o3)                 [[[[a, b], c], d], e]
</pre></dd></dl>








<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC187" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_36.html#SEC194" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Robert</em> on <em>diciembre, 10 2012</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
