<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on diciembre, 10 2012 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual de Maxima: 36. Definici&oacute;n de Funciones</title>

<meta name="description" content="Manual de Maxima: 36. Definici&oacute;n de Funciones">
<meta name="keywords" content="Manual de Maxima: 36. Definici&oacute;n de Funciones">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body
{
    color: black;
    background: white; 
    margin-left: 8%;
    margin-right: 13%;
}

h1
{
    margin-left: +8%;
    font-size: 150%;
    font-family: sans-serif
}

h2
{
    font-size: 125%;
    font-family: sans-serif
}

h3
{
    font-size: 100%;
    font-family: sans-serif
}

h2,h3,h4,h5,h6 { margin-left: +4%; }

div.textbox
{
    border: solid;
    border-width: thin;
    /* width: 100%; */
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em
}

div.titlebox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
    background: rgb(200,255,255);
    font-family: sans-serif
}

div.synopsisbox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
     background: rgb(255,220,255);
    /*background: rgb(200,255,255); */
    /* font-family: fixed */
}

pre.example
{
    border: 1px solid gray;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 1em;
    padding-right: 1em;
    /* background: rgb(247,242,180); */ /* kind of sandy */
    /* background: rgb(200,255,255); */ /* sky blue */
    background-color: #F1F5F9; /* light blue-gray */
    /* font-family: "Lucida Console", monospace */
}

div.spacerbox
{
    border: none;
    padding-top: 2em;
    padding-bottom: 2em
}

div.image
{
    margin: 0;
    padding: 1em;
    text-align: center;
}

div.categorybox
{
    border: 1px solid gray;
    padding-top: 0px;
    padding-bottom: 0px;
    padding-left: 1em;
    padding-right: 1em;
    background: rgb(247,242,220);
}


-->
</style>

<link rel="icon" href="http://maxima.sourceforge.net/favicon.ico"/>
</head>

<body lang="es" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Definici_00f3n-de-Funciones"></a>
<a name="SEC194"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_35.html#SEC193" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC195" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_35.html#SEC187" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC201" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 36. Definici&oacute;n de Funciones </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC195">36.1 Introducci&oacute;n a la definici&oacute;n de funciones</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC196">36.2 Funciones</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC199">36.3 Macros</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC200">36.4 Funciones y variables para la definici&oacute;n de funciones</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
</table>

<hr size="6">
<a name="Introducci_00f3n-a-la-definici_00f3n-de-funciones"></a>
<a name="SEC195"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC194" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC196" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC194" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC194" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC201" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 36.1 Introducci&oacute;n a la definici&oacute;n de funciones </h2>

<hr size="6">
<a name="Funciones"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC195" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC197" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC194" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC194" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC201" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>

<a name="SEC196"></a>
<h2 class="section"> 36.2 Funciones </h2>
<hr size="6">
<a name="SEC197"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC196" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC198" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC194" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC196" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC201" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 36.2.1 Funciones ordinarias </h3>

<p>Para definir una funci&oacute;n en Maxima es necesario utilizar el operador ':='.
</p>
<p>Por ejemplo,
</p>
<pre class="example">f(x) := sin(x)
</pre>

<p>define una funci&oacute;n <code>f</code>. Tambi&eacute;n se pueden definir funciones an&oacute;nimas utilizando <code>lambda</code>; por ejemplo,
</p>
<pre class="example">lambda ([i, j], ...)
</pre>

<p>puede utilizarse en lugar de <code>f</code> donde
</p>
<pre class="example">f(i,j) := block ([], ...);
map (lambda ([i], i+1), l)
</pre>

<p>devolver&iacute;a una lista con todos sus elementos aumentados en una unidad.
</p>
<p>Tambi&eacute;n se puede definir una funci&oacute;n con un n&uacute;mero variable de argumentos, sin m&aacute;s que a&ntilde;adir un argumento final al que se le asigna una lista con todos los argumentos adicionales.:
</p>
<pre class="example">(%i1) f ([u]) := u;
(%o1)                      f([u]) := u
(%i2) f (1, 2, 3, 4);
(%o2)                     [1, 2, 3, 4]
(%i3) f (a, b, [u]) := [a, b, u];
(%o3)               f(a, b, [u]) := [a, b, u]
(%i4) f (1, 2, 3, 4, 5, 6);
(%o4)                 [1, 2, [3, 4, 5, 6]]
</pre>
<p>El miembro derecho de una funci&oacute;n debe ser una expresi&oacute;n. As&iacute;, si se quiere una secuencia de expresiones, se debe hacer
</p>
<pre class="example">f(x) := (expr1, expr2, ...., exprn);
</pre>
<p>siendo el valor que alcance exprn el devuelto por la funci&oacute;n.
</p>
<p>Si se quiere hacer un <code>return</code> desde alguna de las expresiones de la funci&oacute;n, se debe utilizar la estructura  <code>block</code> junto con <code>return</code>. Por ejemplo,
</p>
<pre class="example">block ([], expr1, ..., if (a &gt; 10) then return(a), ..., exprn)
</pre>
<p>es una expresi&oacute;n de pleno derecho, por lo que puede ocupar el lado derecho de la definici&oacute;n de una funci&oacute;n. Aqu&iacute; puede ocurrir que el retorno se produzca antes que se alcance la &uacute;ltima expresi&oacute;n.
</p>
<p>Los primeros corchetes del bloque (<code>[]</code>) pueden contener una lista de variables junto con posibles asignaciones, tal como <code>[a: 3, b, c: []]</code>, lo que provocar&aacute; que las tres variables <code>a</code>,<code>b</code> y <code>c</code> se consideren locales y sean independientes de otras globales con el mismo nombre; las variables locales s&oacute;lo estar&aacute;n activas mientras se ejecute el c&oacute;digo que est&aacute; dentro de la estructura <code>block</code>, o dentro de funciones que son llamadas desde dentro de <code>block</code>. A esto se le llama asignaci&oacute;n din&aacute;mica, pues las variables sobreviven desde el inicio del bloque hasta que &eacute;ste deje de estar operativo. Una vez se salga del bloque los valores originales de las variables, si es que los hab&iacute;a, quedan restaurados. Es recomendable proteger las variables de esta forma. Se tendr&aacute; en cuenta que las asignaciones a las variables del bloque se hacen en paralelo, lo que significa que si como en el ejemplo anterior se hace <code>c: a</code> en el momento de entrar en el bloque, el valor de <code>c</code> ser&aacute; el que ten&iacute;a <code>a</code> antes de entrar en el bloque, es decir, antes de la asignaci&oacute;n <code>a: 3</code>. As&iacute;, haciendo lo siguiente
</p>

<pre class="example">block ([a: a], expr1, ... a: a+3, ..., exprn)
</pre>
<p>se prevendr&iacute;a de que el valor externo de <code>a</code> fuese alterado, pero permitir&iacute;a acceder a &eacute;l desde dentro del bloque. La parte derecha de las asignaciones se eval&uacute;a dentro de su contexto antes de hacer efectiva la asignaci&oacute;n. Utilizando &uacute;nicamente <code>block([x],..</code> har&iacute;a que <code>x</code> se tuviese a s&iacute; misma como valor, justo como si se acabase de iniciar una nueva sesi&oacute;n de Maxima.
</p>
<p>Los valores de los argumentos de una func&oacute;n se tratan exactamente de la misma forma que las variables de un bloque. As&iacute;, con
</p>
<pre class="example">f(x) := (expr1, ..., exprn);
</pre>
<p>y
</p>
<pre class="example">f(1);
</pre>
<p>se estar&iacute;a en un contexto similar para la evaluaci&oacute;n de las expresiones como si se hubiera hecho
</p>
<pre class="example">block ([x: 1], expr1, ..., exprn)
</pre>
<p>Dentro de las funciones, cuando el lado derecho de la definici&oacute;n deba ser evaluado ser&aacute; &uacute;til hacer uso de <code>define</code> y posiblemente de <code>buildq</code>. 
</p>
<hr size="6">
<a name="SEC198"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC197" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC199" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC194" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC196" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC201" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 36.2.2 Funciones array </h3>

<p>Una funci&oacute;n array almacena el valor de la funci&oacute;n la primera
vez que es invocada con un argumento dado, devolviendo el valor
almacenado sin recalcularlo cuando es llamada con ese mismo argumento.
Estas funciones reciben tambi&eacute;n el nombre de <i>funciones memorizadoras</i>.
</p>
<p>Los nombres de las funciones array son a&ntilde;adidos a la lista global 
<code>arrays</code>, no a la lista global <code>functions</code>.
La funci&oacute;n <code>arrayinfo</code> devuelve la lista de argumentos para
los que hay valores almacenados y <code>listarray</code> devuelve precisamente
estos valores almacenados.
Las funciones <code>dispfun</code> y <code>fundef</code> devuelven la definici&oacute;n
de la funci&oacute;n array.
</p>
<p>La funci&oacute;n <code>arraymake</code> construye una llamada a una funci&oacute;n array,
de forma similar a como lo hace <code>funmake</code> para las funciones 
ordinarias. Por otro lado, <code>arrayapply</code> aplica una funci&oacute;n array
a sus argumentos, tal como lo hace <code>apply</code> con las funciones
ordinarias. No existe para las funciones array nada similar a <code>map</code>,
aunque <code>map(lambda([<var>x</var>], <var>a</var>[<var>x</var>]), <var>L</var>)</code> o
<code>makelist(<var>a</var>[<var>x</var>], <var>x</var>, <var>L</var>)</code>,
siendo <var>L</var> una lista, podr&iacute;an suplantar esta
carencia.
</p>
<p>La funci&oacute;n <code>remarray</code> borra la definici&oacute;n de una funci&oacute;n array,
as&iacute; como cualesquiera valores almacenados que tenga asociados,
tal como <code>remfunction</code> lo hace con las funciones ordinarias.
</p>
<p>La llamada <code>kill(<var>a</var>[<var>x</var>])</code> borra el valor de la funci&oacute;n array
<var>a</var> almacenado para el argumento <var>x</var>;
la pr&oacute;xima vez que se llame a <var>a</var> con el argumento <var>x</var>,
se recalcular&aacute; el valor correspondiente.
Sin embargo, no hay forma de borrar todos los valores almacenados de
una sola vez, excepto mediante <code>kill(<var>a</var>)</code> o <code>remarray(<var>a</var>)</code>,
con lo que se borra tambi&eacute;n la definici&oacute;n de la propia funci&oacute;n.
</p>
<hr size="6">
<a name="Macros"></a>
<a name="SEC199"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC198" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC200" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC194" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC194" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC201" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 36.3 Macros </h2>


<dl>
<dt><u>Funci&oacute;n:</u> <b>buildq</b><i> (<var>L</var>, <var>expr</var>)</i>
<a name="IDX1447"></a>
</dt>
<dd><p>Sustituye en paralelo las variables nombradas en la lista <var>L</var> en la expresi&oacute;n <var>expr</var>, sin evaluar &eacute;sta.
La expresi&oacute;n resultante se simplifica pero no se eval&uacute;a hasta que <code>buildq</code> termine de hacer las sustituciones.
</p>
<p>Los elementos de <var>L</var> son s&iacute;mbolos o expresiones de asignaci&oacute;n del tipo <code><var>symbol</var>: <var>value</var></code>,
evaluadas en paralelo. Esto es, el valor de una variable en la parte derecha de una asignaci&oacute;n es el valor que toma dicha variable en el contexto desde el que se invoca a <code>buildq</code>. En caso de que a una variable de <var>L</var> no se le haga una signaci&oacute;n expl&iacute;cita, su valor en <code>buildq</code> es el mismo que tiene en el contexto desde el que se llama a <code>buildq</code>.
</p>
<p>Las variables referenciadas en <var>L</var> se sustituyen en <var>expr</var> en paralelo. Esto es, la sustituci&oacute;n para cada variable se determina antes de que se hagan las sustituciones, de forma que la sustituci&oacute;n de una variable no tiene efecto alguno sobre las otras.
</p>
<p>Si alguna variable <var>x</var> aparece como <code>splice (<var>x</var>)</code> en <var>expr</var>, entonces a <var>x</var> se le debe asignar una lista, la cual ser&aacute; interpolada en <var>expr</var> en lugar de hacer una simple sustituci&oacute;n; ver ejemplo m&aacute;s abajo.
</p>
<p>Cualesquiera otras variables de <var>expr</var> que no aparezcan en <var>L</var> se traspasan al resultado tal cual, incluso cuando tienen asignados valores en el contexto desde el que se llama a <code>buildq</code>.
</p>
<p>Ejemplos:
</p>
<p><code>a</code> queda asociada expl&iacute;citamente a <code>x</code>, mientras que <code>b</code> tiene la misma asociaci&oacute;n (29) que en el contexto de llamada y <code>c</code> es traspasado al resultado sin ser sustituido. La expresi&oacute;n resultante no se eval&uacute;a hasta que no se le obligue a ello mediante la evaluaci&oacute;n expl&iacute;cita <code>''%</code>.
</p>
<pre class="example">(%i1) (a: 17, b: 29, c: 1729)$
(%i2) buildq ([a: x, b], a + b + c);
(%o2)                      x + c + 29
(%i3) ''%;
(%o3)                       x + 1758
</pre>
<p>En este ejemplo, <code>e</code> se asocia a una lista, la cual aparece como tal en los argumentos de <code>foo</code> e interpolada en los argumentos de <code>bar</code>.
</p>
<pre class="example">(%i1) buildq ([e: [a, b, c]], foo (x, e, y));
(%o1)                 foo(x, [a, b, c], y)
(%i2) buildq ([e: [a, b, c]], bar (x, splice (e), y));
(%o2)                  bar(x, a, b, c, y)
</pre>
<p>Como se ve a continuaci&oacute;n, el resultado se simplifica tras las sustituciones. Si la simplificaci&oacute;n se realizase antes que las sustituciones, ambos resultados ser&iacute;an iguales.
</p>
<pre class="example">(%i1) buildq ([e: [a, b, c]], splice (e) + splice (e));
(%o1)                    2 c + 2 b + 2 a
(%i2) buildq ([e: [a, b, c]], 2 * splice (e));
(%o2)                        2 a b c
</pre>
<p>Las variables de <var>L</var> se asocian en paralelo; si se hiciese secuencialmente, el primer resultado ser&iacute;a <code>foo (b, b)</code>. Las sustituciones se llevan a cabo en paralelo. Comp&aacute;rese el segundo resultado con el resultado de <code>subst</code>, que hace las sustituciones de forma secuencial.
</p>
<pre class="example">(%i1) buildq ([a: b, b: a], foo (a, b));
(%o1)                       foo(b, a)
(%i2) buildq ([u: v, v: w, w: x, x: y, y: z, z: u],
              bar (u, v, w, x, y, z));
(%o2)                 bar(v, w, x, y, z, u)
(%i3) subst ([u=v, v=w, w=x, x=y, y=z, z=u],
             bar (u, v, w, x, y, z));
(%o3)                 bar(u, u, u, u, u, u)
</pre>
<p>Se construye a continuaci&oacute;n un sistema de ecuaciones con algunas variables o expresiones en el lado izquierdo y sus valores en el derecho; <code>macroexpand</code> muestra la expresi&oacute;n devuelta por <code>show_values</code>.
</p>
<pre class="example">(%i1) show_values ([L]) ::= buildq ([L], map (&quot;=&quot;, 'L, L));
(%o1)   show_values([L]) ::= buildq([L], map(&quot;=&quot;, 'L, L))
(%i2) (a: 17, b: 29, c: 1729)$
(%i3) show_values (a, b, c - a - b);
(%o3)          [a = 17, b = 29, c - b - a = 1683]
(%i4) macroexpand (show_values (a, b, c - a - b));
(%o4)    map(=, '([a, b, c - b - a]), [a, b, c - b - a])
</pre>
<p>Dada una funci&oacute;n con varios argumentos, se crea otra funci&oacute;n
en la cual algunos argumentos son fijos.
</p>

<pre class="example">(%i1) curry (f, [a]) :=
        buildq ([f, a], lambda ([[x]], apply (f, append (a, x))))$
(%i2) by3 : curry (&quot;*&quot;, 3);
(%o2)        lambda([[x]], apply(*, append([3], x)))
(%i3) by3 (a + b);
(%o3)                       3 (b + a)
</pre></dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>macroexpand</b><i> (<var>expr</var>)</i>
<a name="IDX1448"></a>
</dt>
<dd><p>Devuelve la macroexpansi&oacute;n de <var>expr</var>, sin evaluarla,
cuando <code>expr</code> es una llamada a una funci&oacute;n macro; en caso contrario,
<code>macroexpand</code> devuelve <var>expr</var>.
</p>
<p>Si la expansi&oacute;n de <var>expr</var> devuelve otra llamada a una funci&oacute;n macro, esta llamada tambi&eacute;n se expande.
</p>
<p>La funci&oacute;n <code>macroexpand</code> no eval&uacute;a su argumento.
Sin embargo, si la expansi&oacute;n de una llamada a funci&oacute;n macro tiene efectos laterales, &eacute;stos se ejecutan.
</p>
<p>V&eacute;anse tambi&eacute;n <code>::=</code>, <code>macros</code> y <code>macroexpand1</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) g (x) ::= x / 99;
                                    x
(%o1)                      g(x) ::= --
                                    99
(%i2) h (x) ::= buildq ([x], g (x - a));
(%o2)            h(x) ::= buildq([x], g(x - a))
(%i3) a: 1234;
(%o3)                         1234
(%i4) macroexpand (h (y));
                              y - a
(%o4)                         -----
                               99
(%i5) h (y);
                            y - 1234
(%o5)                       --------
                               99
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>macroexpand1</b><i> (<var>expr</var>)</i>
<a name="IDX1449"></a>
</dt>
<dd><p>Devuelve la macroexpansi&oacute;n de <var>expr</var>, sin evaluarla,
cuando <code>expr</code> es una llamada a una funci&oacute;n macro; en caso contrario,
<code>macroexpand1</code> devuelve <var>expr</var>.
</p>
<p>La funci&oacute;n <code>macroexpand1</code> no eval&uacute;a su argumento.
Sin embargo, si la expansi&oacute;n de una llamada a funci&oacute;n macro tiene efectos laterales, &eacute;stos se ejecutan.
</p>
<p>Si la expansi&oacute;n de <var>expr</var> devuelve otra llamada a una funci&oacute;n macro, esta llamada no se expande.
</p>
<p>V&eacute;anse tambi&eacute;n <code>::=</code>, <code>macros</code> y <code>macroexpand</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) g (x) ::= x / 99;
                                    x
(%o1)                      g(x) ::= --
                                    99
(%i2) h (x) ::= buildq ([x], g (x - a));
(%o2)            h(x) ::= buildq([x], g(x - a))
(%i3) a: 1234;
(%o3)                         1234
(%i4) macroexpand1 (h (y));
(%o4)                       g(y - a)
(%i5) h (y);
                            y - 1234
(%o5)                       --------
                               99
</pre>
</dd></dl>

<dl>
<dt><u>Variable global:</u> <b>macros</b>
<a name="IDX1450"></a>
</dt>
<dd><p>Valor por defecto: <code>[]</code>
</p>
<p>La variable <code>macros</code> es la lista de las funciones macro definidas por el usuario.
El operador de definici&oacute;n de funciones macro <code>::=</code> coloca la nueva funci&oacute;n macro en esta lista,
mientras que  <code>kill</code>, <code>remove</code> y <code>remfunction</code> eliminan las funciones macro de la lista.
</p>
<p>V&eacute;ase tambi&eacute;n <code>infolists</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>splice</b><i> (<var>a</var>)</i>
<a name="IDX1451"></a>
</dt>
<dd><p>Interpola la lista nombrada por el &aacute;tomo  <var>a</var> dentro de una expresi&oacute;n, pero s&oacute;lo si <code>splice</code> aparece dentro de <code>buildq</code>; en otro caso, <code>splice</code> se considera una funci&oacute;n no definida. Si <var>a</var> aparece dentro de <code>buildq</code> sin <code>splice</code>, entonces queda sustituida por una lista dentro del resultado. El argumento de <code>splice</code> debe ser un &aacute;tomo, no pudiendo ser una lista literal ni una expresi&oacute;n que devuelva una lista.
</p>
<p>Normalmente <code>splice</code> suministra los argumentos para una funci&oacute;n u operador. Para una funci&oacute;n <code>f</code>, la expresi&oacute;n <code>f (splice (<var>a</var>))</code> dentro de <code>buildq</code> se convierte en <code>f (<var>a</var>[1], <var>a</var>[2], <var>a</var>[3], ...)</code>. Dado un operador <code>o</code>, la expresi&oacute;n <code>&quot;o&quot; (splice (<var>a</var>)</code> dentro de <code>buildq</code> se convierte en 
<code>&quot;o&quot; (<var>a</var>[1], <var>a</var>[2], <var>a</var>[3], ...)</code>, donde <code>o</code> puede ser cualquier tipo de operador, normalmente uno que admita varios argumentos. N&oacute;tese que el operador debe ir encerrado entre comillas dobles <code>&quot;</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
                       foo(1, %pi, z - y)
(%o1)                -----------------------
                     length([1, %pi, z - y])
(%i2) buildq ([x: [1, %pi]], &quot;/&quot; (splice (x)));
                                1
(%o2)                          ---
                               %pi
(%i3) matchfix (&quot;&lt;&gt;&quot;, &quot;&lt;&gt;&quot;);
(%o3)                          &lt;&gt;
(%i4) buildq ([x: [1, %pi, z - y]], &quot;&lt;&gt;&quot; (splice (x)));
(%o4)                   &lt;&gt;1, %pi, z - y&lt;&gt;
</pre>
</dd></dl>

<hr size="6">
<a name="Funciones-y-variables-para-la-definici_00f3n-de-funciones"></a>
<a name="SEC200"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC199" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC201" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC194" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC194" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC201" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 36.4 Funciones y variables para la definici&oacute;n de funciones </h2>

<dl>
<dt><u>Funci&oacute;n:</u> <b>apply</b><i> (<var>F</var>, [<var>x_1</var>, ..., <var>x_n</var>])</i>
<a name="IDX1452"></a>
</dt>
<dd><p>Construye y eval&uacute;a la expresi&oacute;n <code><var>F</var>(<var>arg_1</var>, ..., <var>arg_n</var>)</code>.
</p>
<p>La funci&oacute;n <code>apply</code> no hace distinciones entre funciones array y 
funciones ordinarias; cuando <var>F</var> es el nombre de una funci&oacute;n array,
<code>apply</code> eval&uacute;a <code><var>F</var>(...)</code>, esto es, hace una llamada con
par&eacute;ntesis en lugar de corchetes. La funci&oacute;n <code>arrayapply</code>
eval&uacute;a una llamada a funci&oacute;n con corchetes para estos casos.
</p>
<p>Ejemplos:
</p>
<p>La funci&oacute;n <code>apply</code> eval&uacute;a sus argumentos.
En este ejemplo, <code>min</code> se aplica al valor de <code>L</code>.
</p>
<pre class="example">(%i1) L : [1, 5, -10.2, 4, 3];
(%o1)                 [1, 5, - 10.2, 4, 3]
(%i2) apply (min, L);
(%o2)                        - 10.2
</pre>
<p>La funci&oacute;n <code>apply</code> eval&uacute;a sus argumentos,
incluso cuando la funci&oacute;n <var>F</var> no lo hace.
</p>
<pre class="example">(%i1) F (x) := x / 1729;
                                   x
(%o1)                     F(x) := ----
                                  1729
(%i2) fname : F;
(%o2)                           F
(%i3) dispfun (F);
                                   x
(%t3)                     F(x) := ----
                                  1729

(%o3)                         [%t3]
(%i4) dispfun (fname);
fname is not the name of a user function.
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) apply (dispfun, [fname]);
                                   x
(%t5)                     F(x) := ----
                                  1729

(%o5)                         [%t5]
</pre>
<p>La funci&oacute;n <code>apply</code> eval&uacute;a el nombre de funci&oacute;n <var>F</var>.
La comilla simple <code>'</code> evita la evaluaci&oacute;n.
El nombre <code>demoivre</code> corresponde a una variable global y
tambi&eacute;n a una funci&oacute;n.
</p>
<pre class="example">(%i1) demoivre;
(%o1)                         false
(%i2) demoivre (exp (%i * x));
(%o2)                  %i sin(x) + cos(x)
(%i3) apply (demoivre, [exp (%i * x)]);
demoivre evaluates to false
Improper name or value in functional position.
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) apply ('demoivre, [exp (%i * x)]);
(%o4)                  %i sin(x) + cos(x)
</pre>
</dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>block</b><i> ([<var>v_1</var>, ..., <var>v_m</var>], <var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1453"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>block</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1454"></a>
</dt>
<dd><p>La funci&oacute;n <code>block</code> eval&uacute;a <var>expr_1</var>, ..., <var>expr_n</var> secuencialmente y devuelve el valor de la &uacute;ltima expresi&oacute;n evaluada. La secuencia puede alterarse con las funciones <code>go</code>, <code>throw</code> y <code>return</code>. La &uacute;ltima expresi&oacute;n es <var>expr_n</var> a menos que <code>return</code> o una expresi&oacute;n que contenga un <code>throw</code> sea evaluada. Las variables <var>v_1</var>, ..., <var>v_m</var> son locales en el bloque; &eacute;stas se distiguen de las globales que tengan el mismo nombre. Si no se declaran variables locales entonces se puede omitir la lista. Dentro del bloque, cualquier otra variable distinta de <var>v_1</var>, ..., <var>v_m</var> se considera global.
</p>
<p>La funci&oacute;n <code>block</code> guarda los valores actuales de las variables <var>v_1</var>, ..., <var>v_m</var>, si los tienen, a la entrada del bloque y luego las eval&uacute;a a s&iacute; mismas, es decir les saca el valor temporalmente. A las variables locales se les puede asignar cualquier valor dentro del bloque, pero al salir de &eacute;ste, los valores inicialmente almacenados quedan restaurados, al tiempo que los asignados dentro del bloque se pierden.
</p>
<p>La declaraci&oacute;n <code>local(<var>v_1</var>, ..., <var>v_m</var>)</code> dentro de un bloque
almacena las propiedades asociadas a los s&iacute;mbolos <var>v_1</var>, ..., <var>v_m</var>,
borra cualesquiera otras propiedades antes de evaluar las expresiones y
restaura las propiedades guardadas antes de abandonar el bloque.
Algunas declaraciones, como <code>:=</code>, <code>array</code>, <code>dependencies</code>, <code>atvalue</code>,
<code>matchdeclare</code>, <code>atomgrad</code>, <code>constant</code>, <code>nonscalar</code>, <code>assume</code>
y otras se implementan como propiedades de s&iacute;mbolos.
El efecto producido por <code>local</code> consiste en hacer que tales declaraciones tengan
efecto s&oacute;lo dentro del bloque, en otro caso las declaraciones dentro del bloque 
tendr&iacute;an un efecto global que afectar&iacute;an al exterior de <code>block</code>.
</p>
<p>Un <code>block</code> puede aparecer dentro de otro <code>block</code>. Las variables locales se inicializan cada vez que se entra dentro de un nuevo bloque. Las variables locales de un bloque se consideran globales dentro de otro anidado dentro del primero. Si una variable es no local dentro de un bloque, su valor es el que le corresponde en el bloque superior. Este criterio se conoce con el nombre de &quot;alcance din&aacute;mico&quot;.
</p>
<p>El valor del bloque es el de la &uacute;ltima sentencia o el argumento de la funci&oacute;n <code>return</code>, que puede utilizarse para salir del bloque. La funci&oacute;n <code>go</code> puede usarse para transferir el control a la sentencia del bloque que est&eacute; etiquetada con el argumento de <code>go</code>. Para etiquetar una sentencia basta que vaya precedida de un argumento at&oacute;mico como cualquier otra sentencia dentro del bloque. Por ejemplo, <code>block ([x], x:1, tururu, x: x+1, ..., go(tururu), ...)</code>.  El argumento de <code>go</code> debe ser el nombre de una etiqueta colocada dentro del bloque. No se puede utilzar <code>go</code> para trasladarse a una etiqueta de un bloque que no sea el que contenga a <code>go</code>.
</p>
<p>Normalmente los bloques aparecer&aacute;n al lado derecho de las definiciones de funciones, pero tambi&eacute;n pueden utilizarse en otros contextos.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>break</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1455"></a>
</dt>
<dd><p>Calcula e imprime <var>expr_1</var>, ..., <var>expr_n</var> para luego provocar la detenci&oacute;n de Maxima, de modo que el usuario pueda examinar y cambiar el entorno de ejecuci&oacute;n. Pulsando posteriormente <code>exit;</code> el c&aacute;lculo se reanuda.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>catch</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1456"></a>
</dt>
<dd><p>Eval&uacute;a <var>expr_1</var>, ..., <var>expr_n</var> una a una;  si alguna de ellas conlleva la evaluaci&oacute;n de una expresi&oacute;n de la forma <code>throw (arg)</code>, entonces el valor de <code>catch</code> es el de <code>throw (arg)</code> y ya no se eval&uacute;an m&aacute;s expresiones. Esta respuesta pasa todos los niveles de anidamiento hasta el <code>catch</code> m&aacute;s pr&oacute;ximo. Si no hay ning&uacute;n <code>catch</code>  que contenga un <code>throw</code> se emite un mensaje de error.
</p>
<p>Si la evaluaci&oacute;n de los argumentos no conlleva la evaluaci&oacute;n de ning&uacute;n <code>throw</code>, entonces el valor de <code>catch</code> es el devuelto por <var>expr_n</var>.
</p>
<pre class="example">(%i1) lambda ([x], if x &lt; 0 then throw(x) else f(x))$
(%i2) g(l) := catch (map (''%, l))$
(%i3) g ([1, 2, 3, 7]);
(%o3)               [f(1), f(2), f(3), f(7)]
(%i4) g ([1, 2, -3, 7]);
(%o4)                          - 3
</pre>
<p>La funci&oacute;n <code>g</code> devuelve las im&aacute;genes por <code>f</code> de todos los elementos de la lista <code>l</code> si &eacute;sta contiene &uacute;nicamente n&uacute;meros no negativos; si no es este el caso, entonces <code>g</code> captura el primer negativo que encuentra y lo devuelve por medio del <code>throw</code>.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>compfile</b><i> (<var>filename</var>, <var>f_1</var>, &hellip;, <var>f_n</var>)</i>
<a name="IDX1457"></a>
</dt>
<dt><u>Function:</u> <b>compfile</b><i> (<var>filename</var>, functions)</i>
<a name="IDX1458"></a>
</dt>
<dt><u>Function:</u> <b>compfile</b><i> (<var>filename</var>, all)</i>
<a name="IDX1459"></a>
</dt>
<dd><p>Traduce funciones de Maxima a c&oacute;digo Lisp, guard&aacute;ndolo 
luego en el fichero <var>filename</var>.
</p>
<p>Con la llamada <code>compfile(<var>filename</var>, <var>f_1</var>, &hellip;, <var>f_n</var>)</code>
se traducen las funciones especificadas, mientras que 
<code>compfile(<var>filename</var>, functions)</code> y
<code>compfile(<var>filename</var>, all)</code> traducen las funciones definidas por
el usuario.
</p>
<p>El c&oacute;digo Lisp traducido no se eval&uacute;a, ni el fichero 
de salida es procesado por el compilador de Lisp.
La funci&oacute;n <code>translate</code> crea y eval&uacute;a las traducciones Lisp, mientras que
<code>compile_file</code> traduce primero de Maxima a Lisp y luego
ejecuta el compilador Lisp. 
</p>
<p>V&eacute;anse tambi&eacute;n <code>translate</code>, <code>translate_file</code> y <code>compile_file</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>compile</b><i> (<var>f_1</var>, ..., <var>f_n</var>)</i>
<a name="IDX1460"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>compile</b><i> (functions)</i>
<a name="IDX1461"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>compile</b><i> (all)</i>
<a name="IDX1462"></a>
</dt>
<dd><p>Traduce las funciones de Maxima <var>f_1</var>, ..., <var>f_n</var> a Lisp, evaluando el c&oacute;digo resultante, y llama a la funci&oacute;n Lisp <code>COMPILE</code> para cada funci&oacute;n traducida. La funci&oacute;n <code>compile</code> devuelve una lista con los nombres de las funciones compiladas.
</p>
<p>Las llamadas <code>compile (all)</code> o <code>compile (functions)</code> compilan todas las funciones definidas por el usuario.
</p>
<p>La funci&oacute;n <code>compile</code> no eval&uacute;a sus argumentos, pero con el operador comilla-comilla (<code>''</code>) s&iacute; lo hace.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>define</b><i> (<var>f</var>(<var>x_1</var>, ..., <var>x_n</var>), <var>expr</var>)</i>
<a name="IDX1463"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>define</b><i> (<var>f</var>[<var>x_1</var>, ..., <var>x_n</var>], <var>expr</var>)</i>
<a name="IDX1464"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>define</b><i> (funmake (<var>f</var>, [<var>x_1</var>, ..., <var>x_n</var>]), <var>expr</var>)</i>
<a name="IDX1465"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>define</b><i> (arraymake (<var>f</var>, [<var>x_1</var>, ..., <var>x_n</var>]), <var>expr</var>)</i>
<a name="IDX1466"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>define</b><i> (ev (<var>expr_1</var>), <var>expr_2</var>)</i>
<a name="IDX1467"></a>
</dt>
<dd><p>Define una funci&oacute;n de nombre <var>f</var> con argumentos <var>x_1</var>, ..., <var>x_n</var> y cuerpo <var>expr</var>.
<code>define</code> eval&uacute;a siempre su segundo argumento, a menos que se
indique lo contrario con el operador de comilla simple. La funci&oacute;n as&iacute;
definida puede ser una funci&oacute;n ordinaria de Maxima (con sus argumentos
encerrados entre par&eacute;ntesis) o una funci&oacute;n array (con sus argumentos encerrados
entre corchetes).
</p>
<p>Cuando el &uacute;ltimo o &uacute;nico argumento <var>x_n</var> es una lista de un solo 
elemento, la funci&oacute;n definida por <code>define</code> acepta un n&uacute;mero variable
de argumentos. Los valores de los argumentos se van asignando uno a uno a 
<var>x_1</var>, ..., <var>x_(n - 1)</var>, y los que queden, si los hay, se asignan 
a <var>x_n</var> en forma de lista.
</p>
<p>Cuando el primer argumento de <code>define</code> es una expresi&oacute;n de la
forma <code><var>f</var>(<var>x_1</var>, ..., <var>x_n</var>)</code> o
<code><var>f</var>[<var>x_1</var>, ..., <var>x_n</var>]</code>, se eval&uacute;an los argumentos de la funci&oacute;n,
pero no <var>f</var>, incluso cuando se trate de una funci&oacute;n o variable ya existente 
con ese nombre.
</p>
<p>Cuando el primer argumento es una expresi&oacute;n con operador <code>funmake</code>, 
<code>arraymake</code> o <code>ev</code>, se eval&uacute;a este primer argumento, lo que
permite calcular la funci&oacute;n.
</p>
<p>Todas las definiciones de funciones aparecen en el mismo espacio
de nombres; definiendo una funci&oacute;n <code>f</code> dentro de otra
funci&oacute;n <code>g</code> no limita autom&aacute;ticamente el alcance de <code>f</code> a <code>g</code>.
Sin embargo, <code>local(f)</code> hace que la definici&oacute;n de la funci&oacute;n <code>f</code>
sea efectiva s&oacute;lo dentro del bloque o expresi&oacute;n compuesta en el que
aparece <code>local</code>.
</p>
<p>Si un argumento formal <var>x_k</var> es un s&iacute;mbolo afectado
por el operador comilla simple (expresi&oacute;n nominal), la funci&oacute;n definida por
<code>define</code> no eval&uacute;a el correspondiente valor de argumento.
En cualquier otro caso, los argumentos que se pasan son evaluados.
</p>
<p>V&eacute;anse tambi&eacute;n <code>:=</code> y <code>::=</code>.
</p>
<p>Ejemplos:
</p>
<p><code>define</code> eval&uacute;a siempre su segundo argumento, a menos que se
indique lo contrario con el operador de comilla simple.
</p>
<pre class="example">(%i1) expr : cos(y) - sin(x);
(%o1)                    cos(y) - sin(x)
(%i2) define (F1 (x, y), expr);
(%o2)              F1(x, y) := cos(y) - sin(x)
(%i3) F1 (a, b);
(%o3)                    cos(b) - sin(a)
(%i4) F2 (x, y) := expr;
(%o4)                   F2(x, y) := expr
(%i5) F2 (a, b);
(%o5)                    cos(y) - sin(x)
</pre>
<p>La funci&oacute;n as&iacute;
definida puede ser una funci&oacute;n ordinaria de Maxima o una funci&oacute;n array.
</p>
<pre class="example">(%i1) define (G1 (x, y), x.y - y.x);
(%o1)               G1(x, y) := x . y - y . x
(%i2) define (G2 [x, y], x.y - y.x);
(%o2)                G2     := x . y - y . x
                       x, y
</pre>
<p>Cuando el &uacute;ltimo o &uacute;nico argumento <var>x_n</var> es una lista de un solo 
elemento, la funci&oacute;n definida por <code>define</code> acepta un n&uacute;mero variable
de argumentos.
</p>
<pre class="example">(%i1) define (H ([L]), '(apply (&quot;+&quot;, L)));
(%o1)                H([L]) := apply(&quot;+&quot;, L)
(%i2) H (a, b, c);
(%o2)                       c + b + a
</pre>
<p>Cuando el primer argumento es una expresi&oacute;n con operador <code>funmake</code>, 
<code>arraymake</code> o <code>ev</code>, se eval&uacute;a este primer argumento.
</p>
<pre class="example">(%i1) [F : I, u : x];
(%o1)                        [I, x]
(%i2) funmake (F, [u]);
(%o2)                         I(x)
(%i3) define (funmake (F, [u]), cos(u) + 1);
(%o3)                  I(x) := cos(x) + 1
(%i4) define (arraymake (F, [u]), cos(u) + 1);
(%o4)                   I  := cos(x) + 1
                         x
(%i5) define (foo (x, y), bar (y, x));
(%o5)                foo(x, y) := bar(y, x)
(%i6) define (ev (foo (x, y)), sin(x) - cos(y));
(%o6)             bar(y, x) := sin(x) - cos(y)
</pre>
</dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>define_variable</b><i> (<var>name</var>, <var>default_value</var>, <var>mode</var>)</i>
<a name="IDX1468"></a>
</dt>
<dd><p>Introduce una variable global en el entorno de Maxima. La funci&oacute;n 
<code>define_variable</code> puede ser &uacute;til en los paquetes escritos por
los usuarios que vayan a ser compilados o traducidos con frecuencia.
</p>
<p>La funci&oacute;n <code>define_variable</code> ejecuta los siguientes pasos:
</p>
<ol>
<li>
<code>mode_declare (<var>name</var>, <var>mode</var>)</code> declara el modo de <var>name</var> al traductor.
V&eacute;ase <code>mode_declare</code> para ver la lista de modos aceptables.

</li><li>
Si a&uacute;n no tiene asignaci&oacute;n, se le da a la variable <var>default_value</var> el valor <var>name</var>.

</li><li>
<code>declare (<var>name</var>, special)</code> la declara como especial.

</li><li>
Asocia <var>name</var> a una funci&oacute;n de comprobaci&oacute;n para asegurar que
a <var>name</var> s&oacute;lo se le asignan valores del modo declarado.
</li></ol>



<p>La propiedad <code>value_check</code> se puede asociar a cualquier variable que haya
sido definida mediante <code>define_variable</code> en cualquiera de los modos diferentes
a <code>any</code>. La propiedad <code>value_check</code> puede ser una expresi&oacute;n lambda o
una funci&oacute;n de una variable, que ser&aacute; invocada al intentar asignar un valor a la
variable; el argumento pasado a la funci&oacute;n <code>value_check</code> es el valor que
se le quiere asignar a la variable.
</p>
<p>La funci&oacute;n <code>define_variable</code> eval&uacute;a <code>default_value</code> pero no
<code>name</code> ni <code>mode</code>; el valor que devuelve es el valor actual de 
<code>name</code>, el cual es <code>default_value</code> si a <code>name</code> no se le ha
aplicado ninguna asignaci&oacute;n, o el valor de dicha asignaci&oacute;n en caso
contrario.
</p>
<p>Ejemplos:
</p>
<p><code>foo</code> es una variable booleana con valor inicial <code>true</code>.
</p><pre class="example">(%i1) define_variable (foo, true, boolean);
(%o1)                         true
(%i2) foo;
(%o2)                         true
(%i3) foo: false;
(%o3)                         false
(%i4) foo: %pi;
Error: foo was declared mode boolean, has value: %pi
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) foo;
(%o5)                         false
</pre>
<p><code>bar</code> es una variable entera, cuyo valor habr&aacute; de ser primo.
</p><pre class="example">(%i1) define_variable (bar, 2, integer);
(%o1)                           2
(%i2) qput (bar, prime_test, value_check);
(%o2)                      prime_test
(%i3) prime_test (y) := if not primep(y) then
                           error (y, &quot;is not prime.&quot;);
(%o3) prime_test(y) := 
         if not primep(y) then error(y, &quot;is not prime.&quot;)
(%i4) bar: 1439;
(%o4)                         1439
(%i5) bar: 1440;
1440 is not prime.
#0: prime_test(y=1440)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i6) bar;
(%o6)                         1439
</pre>
<p><code>baz_quux</code> es una variable a la que no se le podr&aacute; asignar valor alguno.
El modo <code>any_check</code> es como <code>any</code>, 
pero <code>any_check</code> activa el mecanismo <code>value_check</code>, cosa que <code>any</code>
no hace.
</p><pre class="example">(%i1) define_variable (baz_quux, 'baz_quux, any_check);
(%o1)                       baz_quux
(%i2) F: lambda ([y], if y # 'baz_quux then
                 error (&quot;Cannot assign to `baz_quux'.&quot;));
(%o2) lambda([y], if y # 'baz_quux
                   then error(Cannot assign to `baz_quux'.))
(%i3) qput (baz_quux, ''F, value_check);
(%o3) lambda([y], if y # 'baz_quux
                   then error(Cannot assign to `baz_quux'.))
(%i4) baz_quux: 'baz_quux;
(%o4)                       baz_quux
(%i5) baz_quux: sqrt(2);
Cannot assign to `baz_quux'.
#0: lambda([y],if y # 'baz_quux then
             error(&quot;Cannot assign to `baz_quux'.&quot;))(y=sqrt(2))
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i6) baz_quux;
(%o6)                       baz_quux
</pre>
</dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>dispfun</b><i> (<var>f_1</var>, ..., <var>f_n</var>)</i>
<a name="IDX1469"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>dispfun</b><i> (all)</i>
<a name="IDX1470"></a>
</dt>
<dd><p>Muestra la deficni&oacute;n de las funciones de usuario <var>f_1</var>, ..., <var>f_n</var>. Cada argumento puede ser el nombre de una macro (definida mediante <code>::=</code>), una funci&oacute;n ordinaria (definida mediante <code>:=</code> o <code>define</code>), una funci&oacute;n arreglo  (definida mediante <code>:=</code> o <code>define</code>, pero encerrando los argumentos dentro de corchetes <code>[ ]</code>), una funci&oacute;n de sub&iacute;ndice (definida mediante <code>:=</code> o <code>define</code>, pero encerrando algunos argumentos entre corchetes y otros entre par&eacute;ntesis  <code>( )</code>), una funci&oacute;n de sub&iacute;ndice seleccionada por un sub&iacute;ndice variable, o una funci&oacute;n de sub&iacute;ndice definida con un sub&iacute;ndice constante.
</p>
<p>La llamada <code>dispfun (all)</code> muestra todas las funciones de usuario tal como las dan las listas <code>functions</code>, <code>arrays</code> y <code>macros</code>, omitiendo las funciones con sub&iacute;ndices definidas con sub&iacute;ndices constantes.
</p>
<p>La funci&oacute;n <code>dispfun</code> crea una etiqueta (<code>%t1</code>, <code>%t2</code>, etc.) para cada funci&oacute;n mostrada, y asigna la definici&oacute;n de la funci&oacute;n a la etiqueta. En contraste, <code>fundef</code> devuelve las definiciones de las funciones.
</p>
<p>La funci&oacute;n <code>dispfun</code> no eval&uacute;a sus argumentos; el operador de comilla-comilla <code>''</code> permite la evaluaci&oacute;n.
</p>
<p>La funci&oacute;n <code>dispfun</code> devuelve la lista de etiquetas de expresiones intermedias correspondientes a las funciones mostradas.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) m(x, y) ::= x^(-y);
                                     - y
(%o1)                   m(x, y) ::= x
(%i2) f(x, y) :=  x^(-y);
                                     - y
(%o2)                    f(x, y) := x
(%i3) g[x, y] :=  x^(-y);
                                    - y
(%o3)                     g     := x
                           x, y
(%i4) h[x](y) :=  x^(-y);
                                    - y
(%o4)                     h (y) := x
                           x
(%i5) i[8](y) :=  8^(-y);
                                    - y
(%o5)                     i (y) := 8
                           8
(%i6) dispfun (m, f, g, h, h[5], h[10], i[8]);
                                     - y
(%t6)                   m(x, y) ::= x

                                     - y
(%t7)                    f(x, y) := x

                                    - y
(%t8)                     g     := x
                           x, y

                                    - y
(%t9)                     h (y) := x
                           x

                                    1
(%t10)                     h (y) := --
                            5        y
                                    5

                                     1
(%t11)                    h  (y) := ---
                           10         y
                                    10

                                    - y
(%t12)                    i (y) := 8
                           8

(%o12)       [%t6, %t7, %t8, %t9, %t10, %t11, %t12]
(%i12) ''%;
                     - y              - y            - y
(%o12) [m(x, y) ::= x   , f(x, y) := x   , g     := x   , 
                                            x, y
                  - y           1              1             - y
        h (y) := x   , h (y) := --, h  (y) := ---, i (y) := 8   ]
         x              5        y   10         y   8
                                5             10
</pre>
</dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>fullmap</b><i> (<var>f</var>, <var>expr_1</var>, ...)</i>
<a name="IDX1471"></a>
</dt>
<dd><p>Similar a <code>map</code>, pero conservar&aacute; el mapeado
descendente de todas las subexpresiones hasta que los operadores
principales ya no sean los mismos.
</p>
<p>La funci&oacute;n <code>fullmap</code> es utilizada por el simplificador de Maxima
en algunas transformaciones matriciales, por lo que Maxima generar&aacute; en algunas ocasiones mensajes de error relacionados con <code>fullmap</code> aunque el usuario no haya invocado expl&iacute;citamente esta funci&oacute;n.
</p>
<pre class="example">(%i1) a + b * c;
(%o1)                        b c + a
(%i2) fullmap (g, %);
(%o2)                   g(b) g(c) + g(a)
(%i3) map (g, %th(2));
(%o3)                     g(b c) + g(a)
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>fullmapl</b><i> (<var>f</var>, <var>list_1</var>, ...)</i>
<a name="IDX1472"></a>
</dt>
<dd><p>Similar a <code>fullmap</code>, pero <code>fullmapl</code> s&oacute;lo hace mapeo
sobre listas y matrices.
</p>
<pre class="example">(%i1) fullmapl (&quot;+&quot;, [3, [4, 5]], [[a, 1], [0, -1.5]]);
(%o1)                [[a + 3, 4], [4, 3.5]]
</pre>
</dd></dl>


<dl>
<dt><u>Variable del sistema:</u> <b>functions</b>
<a name="IDX1473"></a>
</dt>
<dd><p>Valor por defecto: <code>[]</code>
</p>
<p>La variable <code>functions</code> es una lista que contiene los nombres de las funciones ordinarias de Maxima. Una funci&oacute;n ordinaria es aquella que ha sido construida mediante cualquiera de los m&eacute;todos <code>define</code> o <code>:=</code> y que es invocada utilizando par&eacute;ntesis. Una funci&oacute;n puede definirse durante una sesi&oacute;n de Maxima o en un fichero que posteriormente ser&aacute; cargado en memoria por <code>load</code> o <code>batch</code>.
</p>
<p>Las funciones array, que son invocadas con corchetes (<code>F[x]</code>),
y las funciones subindicadas, que son las invocadas con corchetes y
par&eacute;ntesis (<code>F[x](y)</code>) se registran en la variable global <code>arrays</code>,
no en <code>functions</code>.
</p>
<p>Las funciones Lisp no se registran en ninguna lista.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) F_1 (x) := x - 100;
(%o1)                   F_1(x) := x - 100
(%i2) F_2 (x, y) := x / y;
                                      x
(%o2)                    F_2(x, y) := -
                                      y
(%i3) define (F_3 (x), sqrt (x));
(%o3)                   F_3(x) := sqrt(x)
(%i4) G_1 [x] := x - 100;
(%o4)                    G_1  := x - 100
                            x
(%i5) G_2 [x, y] := x / y;
                                     x
(%o5)                     G_2     := -
                             x, y    y
(%i6) define (G_3 [x], sqrt (x));
(%o6)                    G_3  := sqrt(x)
                            x
(%i7) H_1 [x] (y) := x^y;
                                      y
(%o7)                     H_1 (y) := x
                             x
(%i8) functions;
(%o8)              [F_1(x), F_2(x, y), F_3(x)]
(%i9) arrays;
(%o9)                 [G_1, G_2, G_3, H_1]
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>fundef</b><i> (<var>f</var>)</i>
<a name="IDX1474"></a>
</dt>
<dd><p>Devuelve la definici&oacute;n de la funci&oacute;n <var>f</var>.
</p>
<p>Cada argumento puede ser el nombre de una macro (definida mediante <code>::=</code>), una funci&oacute;n ordinaria (definida mediante <code>:=</code> o <code>define</code>), una funci&oacute;n arreglo  (definida mediante <code>:=</code> o <code>define</code>, pero encerrando los argumentos dentro de corchetes <code>[ ]</code>), una funci&oacute;n de sub&iacute;ndice (definida mediante <code>:=</code> o <code>define</code>, pero encerrando algunos argumentos entre corchetes y otros entre par&eacute;ntesis  <code>( )</code>), una funci&oacute;n de sub&iacute;ndice seleccionada por un sub&iacute;ndice variable, o una funci&oacute;n de sub&iacute;ndice definida con un sub&iacute;ndice constante.
</p>
<p>La funci&oacute;n <code>fundef</code> no eval&uacute;a sus argumentos; el operador comilla-comilla <code>''</code> permite la evaluaci&oacute;n.
</p>
<p>La llamada de funci&oacute;n <code>fundef (<var>f</var>)</code> devuelve la definici&oacute;n de <var>f</var>. Por el contrario, <code>dispfun (<var>f</var>)</code> crea una etiqueta intermedia y le asigna la definici&oacute;n a la etiqueta.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>funmake</b><i> (<var>F</var>, [<var>arg_1</var>, ..., <var>arg_n</var>])</i>
<a name="IDX1475"></a>
</dt>
<dd><p>Devuelve una expresi&oacute;n <code><var>F</var>(<var>arg_1</var>, ..., <var>arg_n</var>)</code>.
El valor as&iacute; retornado es simplificado pero no evaluado,
de forma que la funci&oacute;n <var>F</var> no es invocada, incluso cuando exista.
</p>
<p>La funci&oacute;n <code>funmake</code> no hace distinciones entre funciones array
y funciones ordinarias; cuando <var>F</var> es el nombre de una funci&oacute;n array,
<code>funmake</code> devuelve <code><var>F</var>(...)</code>,
esto es, una llamada a funci&oacute;n con par&eacute;ntesis en lugar de corchetes.
La funci&oacute;n <code>arraymake</code> devuelve una llamada a funci&oacute;n con
corchetes para estos casos.
</p>
<p>La funci&oacute;n <code>funmake</code> eval&uacute;a sus argumentos.
</p>
<p>Ejemplos:
</p>
<p>La funci&oacute;n <code>funmake</code> aplicada a una funci&oacute;n ordinaria de Maxima.
</p>
<pre class="example">(%i1) F (x, y) := y^2 - x^2;
                                   2    2
(%o1)                  F(x, y) := y  - x
(%i2) funmake (F, [a + 1, b + 1]);
(%o2)                    F(a + 1, b + 1)
(%i3) ''%;
                              2          2
(%o3)                  (b + 1)  - (a + 1)
</pre>
<p>La funci&oacute;n <code>funmake</code> aplicada a una macro.
</p>
<pre class="example">(%i1) G (x) ::= (x - 1)/2;
                                  x - 1
(%o1)                    G(x) ::= -----
                                    2
(%i2) funmake (G, [u]);
(%o2)                         G(u)
(%i3) ''%;
                              u - 1
(%o3)                         -----
                                2
</pre>
<p>La funci&oacute;n <code>funmake</code> aplicada a una funci&oacute;n subindicada.
</p>
<pre class="example">(%i1) H [a] (x) := (x - 1)^a;
                                        a
(%o1)                   H (x) := (x - 1)
                         a
(%i2) funmake (H [n], [%e]);
                                       n
(%o2)               lambda([x], (x - 1) )(%e)
(%i3) ''%;
                                    n
(%o3)                       (%e - 1)
(%i4) funmake ('(H [n]), [%e]);
(%o4)                        H (%e)
                              n
(%i5) ''%;
                                    n
(%o5)                       (%e - 1)
</pre>
<p>La funci&oacute;n <code>funmake</code> aplicada a un s&iacute;mbolo
que no est&aacute; asociado a funci&oacute;n alguna.
</p>
<pre class="example">(%i1) funmake (A, [u]);
(%o1)                         A(u)
(%i2) ''%;
(%o2)                         A(u)
</pre>
<p>La funci&oacute;n <code>funmake</code> eval&uacute;a sus argumentos,
pero no el valor retornado.
</p>
<pre class="example">(%i1) det(a,b,c) := b^2 -4*a*c;
                                    2
(%o1)              det(a, b, c) := b  - 4 a c
(%i2) (x : 8, y : 10, z : 12);
(%o2)                          12
(%i3) f : det;
(%o3)                          det
(%i4) funmake (f, [x, y, z]);
(%o4)                    det(8, 10, 12)
(%i5) ''%;
(%o5)                         - 284
</pre>
<p>Maxima simplifica el valor retornado de <code>funmake</code>.
</p>
<pre class="example">(%i1) funmake (sin, [%pi / 2]);
(%o1)                           1
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>lambda</b><i> ([<var>x_1</var>, ..., <var>x_m</var>], <var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1476"></a>
</dt>
<dt><u>Function:</u> <b>lambda</b><i> ([[<var>L</var>]], <var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1477"></a>
</dt>
<dt><u>Function:</u> <b>lambda</b><i> ([<var>x_1</var>, ..., <var>x_m</var>, [<var>L</var>]], <var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1478"></a>
</dt>
<dd><p>Define y devuelve una expresi&oacute;n lambda (es decir, una funci&oacute;n an&oacute;nima).
La funci&oacute;n puede tener argumentos <var>x_1</var>, ..., <var>x_m</var> y/o argumentos
opcionales <var>L</var>, que aparecer&aacute;n dentro del cuerpo de la funci&oacute;n como una lista.
El valor que devuelve la funci&oacute;n es <var>expr_n</var>.
Una expresi&oacute;n lambda puede asignarse a una variable y ser evaluada como si fuese una funci&oacute;n ordinaria. Adem&aacute;s, puede aparecer en algunos contextos en los que sea necesario un nombre de funci&oacute;n.
</p>
<p>Cuando se eval&uacute;a la funci&oacute;n, se crean las variables <var>x_1</var>, ..., <var>x_m</var> sin asignaci&oacute;n de valores. Una funci&oacute;n <code>lambda</code> puede aparecer dentro de un <code>block</code> o de otra <code>lambda</code>. Las variables locales se inicializan cada vez que se entra dentro de un nuevo bloque o de otra funci&oacute;n <code>lambda</code>. Las variables locales se consideran globales dentro de un bloque o funci&oacute;n <code>lambda</code> anidado dentro del primero. Si una variable es no local dentro de un bloque o funci&oacute;n <code>lambda</code>, su valor es el que le corresponde en el bloque o funci&oacute;n <code>lambda</code> superior. Este criterio se conoce con el nombre de &quot;alcance din&aacute;mico&quot;.
</p>
<p>Una vez establecidas las variables locales <var>expr_1</var> a <var>expr_n</var> son secuencialmente evaluadas. La variable especial  <code>%%</code> representa el valor de la expresi&oacute;n inmediata anterior. Las sentencias <code>throw</code> y <code>catch</code> pueden aparecer tambi&eacute;n en la lista de expresiones.
</p>
<p>La funci&oacute;n <code>return</code> no puede aparecer en una expresi&oacute;n <code>lambda</code> a menos que se encuentre acotada dentro de un bloque (<code>block</code>), en cuyo caso <code>return</code> establece el valor de retorno del bloque, pero no de la expresi&oacute;n <code>lambda</code>, a menos que el bloque resulte ser precisamente <var>expr_n</var>. De igual manera, <code>go</code> no puede aparecer en una expresi&oacute;n <code>lambda</code> si no es dentro de un <code>block</code>.
</p>
<p>Las funciones <code>lambda</code> no eval&uacute;an sus argumentos;  el operador comilla-comilla <code>''</code> permite su evaluaci&oacute;n.
</p>
<p>Ejemplo:
</p>
<ul>
<li>
Una funci&oacute;n lambda puede asignarse a una variable y ser evaluada como si fuese una funci&oacute;n ordinaria.
</li></ul>
<pre class="example">(%i1) f: lambda ([x], x^2);
                                      2
(%o1)                    lambda([x], x )
(%i2) f(a);
                                2
(%o2)                          a
</pre><ul>
<li>
Una expresi&oacute;n lambda puede aparecer en algunos contextos en los que sea necesario un nombre de funci&oacute;n.
</li></ul>
<pre class="example">(%i3) lambda ([x], x^2) (a);
                                2
(%o3)                          a
(%i4) apply (lambda ([x], x^2), [a]);
                                2
(%o4)                          a
(%i5) map (lambda ([x], x^2), [a, b, c, d, e]);
                        2   2   2   2   2
(%o5)                 [a , b , c , d , e ]
</pre><ul>
<li>
Los argumentos son variables locales. Otras variables se consideran globales. Las variables globales son evaluadas en el momento que lo es la expresi&oacute;n, a menos que la evaluaci&oacute;n de las mismas sea forzada, como cuando se hace uso de <code>''</code>.
</li></ul>
<pre class="example">(%i6) a: %pi$
(%i7) b: %e$
(%i8) g: lambda ([a], a*b);
(%o8)                   lambda([a], a b)
(%i9) b: %gamma$
(%i10) g(1/2);
                             %gamma
(%o10)                       ------
                               2
(%i11) g2: lambda ([a], a*''b);
(%o11)                lambda([a], a %gamma)
(%i12) b: %e$
(%i13) g2(1/2);
                             %gamma
(%o13)                       ------
                               2
</pre><ul>
<li>
Las expresiones lambda pueden anidarse. Las variables locales de expresiones lambda exteriores se consideran globales en expresiones internas, a menos que se enmascaren con variables locales de igual nombre.
</li></ul>
<pre class="example">(%i14) h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
                                                   1
(%o14)    lambda([a, b], h2 : lambda([a], a b), h2(-))
                                                   2
(%i15) h(%pi, %gamma);
                             %gamma
(%o15)                       ------
                               2
</pre><ul>
<li>
Puesto que <code>lambda</code> no eval&uacute;a sus argumentos, la expresi&oacute;n lambda <code>i</code> de m&aacute;s abajo no define una funci&oacute;n del tipo &quot;multiplicar por <code>a</code>&quot;. Tal tipo de funci&oacute;n se puede definir a trav&eacute;s de <code>buildq</code>, como en la expresi&oacute;n lambda <code>i2</code> de m&aacute;s abajo.
</li></ul>
<pre class="example">(%i16) i: lambda ([a], lambda ([x], a*x));
(%o16)            lambda([a], lambda([x], a x))
(%i17) i(1/2);
(%o17)                  lambda([x], a x)
(%i18) i2: lambda([a], buildq([a: a], lambda([x], a*x)));
(%o18)    lambda([a], buildq([a : a], lambda([x], a x)))
(%i19) i2(1/2);
                                     x
(%o19)                   lambda([x], -)
                                     2
(%i20) i2(1/2)(%pi);
                               %pi
(%o20)                         ---
                                2
</pre><ul>
<li>
Una expresi&oacute;n lambda puede tener un n&uacute;mero variable de argumentos,
los cuales se indican mediante <code>[<var>L</var>]</code>, bien sea solo o como un
&uacute;ltimo argumento. Estos argumentos aparecer&aacute;n dentro del cuerpo de
la funci&oacute;n en forma de lista.
</li></ul>
<pre class="example">(%i1) f : lambda ([aa, bb, [cc]], aa * cc + bb);
(%o1)          lambda([aa, bb, [cc]], aa cc + bb)
(%i2) f (foo, %i, 17, 29, 256);
(%o2)       [17 foo + %i, 29 foo + %i, 256 foo + %i]
(%i3) g : lambda ([[aa]], apply (&quot;+&quot;, aa));
(%o3)             lambda([[aa]], apply(+, aa))
(%i4) g (17, 29, x, y, z, %e);
(%o4)                  z + y + x + %e + 46
</pre></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>local</b><i> (<var>v_1</var>, ..., <var>v_n</var>)</i>
<a name="IDX1479"></a>
</dt>
<dd><p>La declaraci&oacute;n <code>local(<var>v_1</var>, ..., <var>v_m</var>)</code> dentro de un bloque
almacena las propiedades asociadas a los s&iacute;mbolos <var>v_1</var>, ..., <var>v_m</var>,
borra cualesquiera otras propiedades antes de evaluar las expresiones y
restaura las propiedades guardadas antes de abandonar el bloque.
</p>
<p>Algunas declaraciones, como <code>:=</code>, <code>array</code>, <code>dependencies</code>, <code>atvalue</code>,
<code>matchdeclare</code>, <code>atomgrad</code>, <code>constant</code>, <code>nonscalar</code>, <code>assume</code>
y otras se implementan como propiedades de s&iacute;mbolos.
El efecto producido por <code>local</code> consiste en hacer que tales declaraciones tengan
efecto s&oacute;lo dentro del bloque, en otro caso las declaraciones dentro del bloque 
tendr&iacute;an un efecto global que afectar&iacute;an al exterior de <code>block</code>.
</p>
<p>La funci&oacute;n <code>local</code> s&oacute;lo puede usarse dentro de un <code>block</code>, en el
cuerpo de definici&oacute;n de funciones o de expresiones <code>lambda</code> o en la
funci&oacute;n <code>ev</code>, si&eacute;ndole permitido aparecer una s&oacute;la vez en cada una de ellas.
</p>
<p>La funci&oacute;n <code>local</code> no eval&uacute;a sus argumentos y devuelve <code>done</code>.
</p>
<p>Ejemplo:
</p>
<p>Definici&oacute;n local de una funci&oacute;n.
</p>
<pre class="example">(%i1) foo (x) := 1 - x;
(%o1)                    foo(x) := 1 - x
(%i2) foo (100);
(%o2)                         - 99
(%i3) block (local (foo), foo (x) := 2 * x, foo (100));
(%o3)                          200
(%i4) foo (100);
(%o4)                         - 99
</pre></dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>macroexpansion</b>
<a name="IDX1480"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>La variable <code>macroexpansion</code> controla si la expansi&oacute;n (esto es, el valor de retorno) de una funci&oacute;n macro se sustituye por la llamada a la funci&oacute;n macro. Una sustituci&oacute;n puede acelerar futuras evaluaciones de la expresi&oacute;n, bajo el coste que implica tener que almacenar la expansi&oacute;n.
</p>
<dl compact="compact">
<dt> <code>false</code></dt>
<dd><p>La expansi&oacute;n de una funci&oacute;n macro no se sustituye por la llamada a la funci&oacute;n macro.
</p></dd>
<dt> <code>expand</code></dt>
<dd><p>La primera vez que se eval&uacute;a una llamada a funci&oacute;n macro se almacena la expansi&oacute;n. De esta manera la expansi&oacute;n no se recalcula en llamadas posteriores; cualesquiera efectos laterales (como <code>print</code> o asignaciones a variables globales)
tan solo tienen lugar la primera vez que la funci&oacute;n macro es evaluada. La expansi&oacute;n en una expresi&oacute;n no afecta a otras expresiones que llamen a la misma funci&oacute;n macro.
</p></dd>
<dt> <code>displace</code></dt>
<dd><p>La primera vez que se eval&uacute;a una llamada a una funci&oacute;n macro, la expansi&oacute;n se sustituye por la llamada, modificando as&iacute; la expresi&oacute;n desde la que se hizo la llamada a la funci&oacute;n macro. La expansi&oacute;n no se recalcula en llamadas posteriores; cualesquiera efectos laterales tan solo tienen lugar la primera vez que la funci&oacute;n macro es evaluada. La expansi&oacute;n en una expresi&oacute;n no afecta a otras expresiones que llamen a la misma funci&oacute;n macro.
</p></dd>
</dl>

<p>Ejemplos:
</p>
<p>Si <code>macroexpansion</code> vale <code>false</code>,
una funci&oacute;n macro es llamada cada vez que la expresi&oacute;n de llamada es evaluada.
</p>
<pre class="example">(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print (&quot;x + 99 is equal to&quot;, x),
                       return (x + 99));
(%o2) g(x) ::= block(print(&quot;x + 99 is equal to&quot;, x), 
                     return(x + 99))
(%i3) h (x) ::= block (print (&quot;x - 99 is equal to&quot;, x),
                       return (x - 99));
(%o3) h(x) ::= block(print(&quot;x - 99 is equal to&quot;, x), 
                     return(x - 99))
(%i4) macroexpansion: false;
(%o4)                         false
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                  h(x)
(%t6)                     f(x) := ----
                                  g(x)

(%o6)                         done
(%i7) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o7)                       --------
                            a b + 99
</pre>
<p>Si <code>macroexpansion</code> vale <code>expand</code>, una funci&oacute;n macro tan solo es llamada una vez.
</p>
<pre class="example">(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print (&quot;x + 99 is equal to&quot;, x),
                       return (x + 99));
(%o2) g(x) ::= block(print(&quot;x + 99 is equal to&quot;, x), 
                     return(x + 99))
(%i3) h (x) ::= block (print (&quot;x - 99 is equal to&quot;, x),
                       return (x - 99));
(%o3) h(x) ::= block(print(&quot;x - 99 is equal to&quot;, x), 
                     return(x - 99))
(%i4) macroexpansion: expand;
(%o4)                        expand
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                  h(x)
(%t6)                     f(x) := ----
                                  g(x)

(%o6)                         done
(%i7) f (a * b);
                            a b - 99
(%o7)                       --------
                            a b + 99
</pre>
<p>Si <code>macroexpansion</code> vale <code>expand</code>, una funci&oacute;n macro es llamada una vez y la expresi&oacute;n de llamada se modifica.
</p>
<pre class="example">(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print (&quot;x + 99 is equal to&quot;, x), return (x + 99));
(%o2) g(x) ::= block(print(&quot;x + 99 is equal to&quot;, x), 
                                                  return(x + 99))
(%i3) h (x) ::= block (print (&quot;x - 99 is equal to&quot;, x), return (x - 99));
(%o3) h(x) ::= block(print(&quot;x - 99 is equal to&quot;, x), 
                                                  return(x - 99))
(%i4) macroexpansion: displace;
(%o4)                       displace
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                 x - 99
(%t6)                    f(x) := ------
                                 x + 99

(%o6)                         done
(%i7) f (a * b);
                            a b - 99
(%o7)                       --------
                            a b + 99
</pre>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>mode_checkp</b>
<a name="IDX1481"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Cuando <code>mode_checkp</code> vale <code>true</code>, <code>mode_declare</code> chequea los modos de las variables con valores asignados.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>mode_check_errorp</b>
<a name="IDX1482"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Cuando <code>mode_check_errorp</code> vale <code>true</code>, <code>mode_declare</code> llama a error.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>mode_check_warnp</b>
<a name="IDX1483"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Cuando <code>mode_check_warnp</code> vale <code>true</code>, se detallan los errores de modo.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>mode_declare</b><i> (<var>y_1</var>, <var>modo_1</var>, ..., <var>y_n</var>, <var>modo_n</var>)</i>
<a name="IDX1484"></a>
</dt>
<dd><p>La funci&oacute;n <code>mode_declare</code> se utiliza para declarar los modos de variables y funciones para la ulterior traducci&oacute;n a Lisp o compilaci&oacute;n de funciones. Se coloca habitualmente al comienzo de la definici&oacute;n de una funci&oacute;n, de un script en Maxima o se ejecuta en tiempo real.
</p>
<p>Los argumentos de <code>mode_declare</code> son pares formados por una variable y un modo, el cual debe ser <code>boolean</code>, <code>fixnum</code>, <code>number</code>, <code>rational</code> o <code>float</code>. Cada variable puede ser sustituida por una lista de variables, en cuyo caso todas ellas tendr&aacute;n el mismo modo.
</p>

<p>C&oacute;digo num&eacute;rico que utilice arreglos puede ejecutarse m&aacute;s r&aacute;pido declarando el tama&ntilde;o que va a ocupar el arreglo, como en:
</p>
<pre class="example">mode_declare (array (a [10, 10]), float)
</pre>
<p>para un arreglo de n&uacute;meros en coma flotante de dimensiones 10 x 10.
</p>
<p>Se puede declarar el modo del resultado de una funci&oacute;n poniendo <code>function (f_1, f_2, ...)</code> como argumento;
aqu&iacute; <code>f_1</code>, <code>f_2</code>, ... son los nombres de las funciones. Por ejemplo, la expresi&oacute;n
</p>
<pre class="example">mode_declare ([function (f_1, f_2, ...)], fixnum)
</pre>
<p>declara que el valor a devolver por  <code>f_1</code>, <code>f_2</code>, ... son enteros de modo &quot;single-word&quot;.
</p>
<p>El nombre <code>modedeclare</code> es sin&oacute;nimo de <code>mode_declare</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>mode_identity</b><i> (<var>arg_1</var>, <var>arg_2</var>)</i>
<a name="IDX1485"></a>
</dt>
<dd><p>Es una forma especial usada con <code>mode_declare</code> y <code>macros</code> para declarar, por ejemplo, una lista de listas de n&uacute;meros. 
</p>

</dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>remfunction</b><i> (<var>f_1</var>, ..., <var>f_n</var>)</i>
<a name="IDX1486"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>remfunction</b><i> (all)</i>
<a name="IDX1487"></a>
</dt>
<dd><p>Desliga las definiciones de funci&oacute;n de sus s&iacute;mbolos <var>f_1</var>, ..., <var>f_n</var>.
Los argumentos pueden ser nombres de funciones ordinarias 
(creadas con <code>:=</code> o <code>define</code>) o de funciones macro (creadas con <code>::=</code>).
</p>
<p>La instrucci&oacute;n <code>remfunction (all)</code> desliga todas las definiciones de funciones.
</p>
<p>La funci&oacute;n <code>remfunction</code> no eval&uacute;a sus argumentos.
</p>
<p>La funci&oacute;n <code>remfunction</code> devuelve una lista con los
s&iacute;mbolos para los que la definici&oacute;n de funci&oacute;n
fue desligada. Devuelve <code>false</code> en el lugar de cualquier 
s&iacute;mbolo para el que no hay funci&oacute;n definida.
</p>
<p>La funci&oacute;n <code>remfunction</code> no se puede aplicar a arrays de funciones ni a
funciones subindicadas. S&iacute; es aplicable en tales casos la 
funci&oacute;n <code>remarray</code>.
</p></dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>savedef</b>
<a name="IDX1488"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>savedef</code> vale <code>true</code>, se mantiene la versi&oacute;n Maxima de una funci&oacute;n definida por el usuario cuando &eacute;sta se traduce, lo que permite mostrar su c&oacute;digo con <code>dispfun</code> y que la funci&oacute;n pueda ser editada.
</p>
<p>Si <code>savedef</code> vale <code>false</code>, los nombres de las funciones traducidas se eliminan de la lista <code>functions</code>.
</p>
</dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>transcompile</b>
<a name="IDX1489"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>transcompile</code> vale <code>true</code>, <code>translate</code> y <code>translate_file</code> generan declaraciones para hacer el c&oacute;digo traducido m&aacute;s apto para la compilaci&oacute;n.
</p>
<p>La funci&oacute;n <code>compfile</code> hace la asignaci&oacute;n <code>transcompile: true</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>translate</b><i> (<var>f_1</var>, ..., <var>f_n</var>)</i>
<a name="IDX1490"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>translate</b><i> (functions)</i>
<a name="IDX1491"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>translate</b><i> (all)</i>
<a name="IDX1492"></a>
</dt>
<dd><p>Traduce las funciones definidas por el usuario <var>f_1</var>, ..., <var>f_n</var> del lenguaje de Maxima a Lisp y eval&uacute;a las traducciones Lisp. Normalmente las funciones traducidas se ejecutan m&aacute;s rapidamente que las originales.
</p>
<p>Las llamadas <code>translate (all)</code> o <code>translate (functions)</code> traducen todas las funciones de usuario.
</p>
<p>Las funciones a ser traducidas deber&iacute;an incluir una llamada a <code>mode_declare</code> al comienzo siempre que sea posible, a fin de producir c&oacute;digo m&aacute;s eficiente. Por ejemplo:
</p>
<pre class="example">f (x_1, x_2, ...) := block ([v_1, v_2, ...],
    mode_declare (v_1, modo_1, v_2, modo_2, ...), ...)
</pre>


<p>donde <var>x_1</var>, <var>x_2</var>, ... son los par&aacute;metros que se pasan a la funci&oacute;n y <var>v_1</var>, <var>v_2</var>, ... son las variables locales.
</p>
<p>Los nombres de las funciones traducidas son eliminados de la lista <code>functions</code> si <code>savedef</code> vale <code>false</code> (ver m&aacute;s abajo) y son a&ntilde;adidos a las listas <code>props</code>.
</p>
<p>Las funciones no deber&iacute;an ser traducidas hasta no estar completamente depuradas.
</p>
<p>Se supone que las expresiones est&aacute;n simplificadas; en caso de no estarlo, se generar&aacute; c&oacute;digo correcto pero ineficiente. As&iacute;, el usuario no deber&iacute;a asignar a <code>simp</code> el valor <code>false</code>, el cual inhibe la simplificaci&oacute;n de la expresi&oacute;n a ser traducida.
</p>
<p>Cuando la variable <code>translate</code> vale <code>true</code>, se traducen autom&aacute;ticamente las funciones de usuario a Lisp.
</p>
<p>N&oacute;tese que las funciones traducidas puede que no se ejecuten exactamente igual a como lo hac&iacute;an antes de la traducci&oacute;n, debido a posibles incompatibilidades entre las versiones de Maxima y Lisp. En general, la funci&oacute;n <code>rat</code> con m&aacute;s de un argumento y la funci&oacute;n <code>ratvars</code> no deber&iacute;an utilizarse si algunas de las variables son declaradas como expresiones racionales can&oacute;nicas (CRE) mediante <code>mode_declare</code>. Adem&aacute;s, la asignaci&oacute;n  <code>prederror: false</code> no traducir&aacute;.
</p>
<p>Si <code>savedef</code> vale <code>true</code>, entonces la versi&oacute;n de Maxima de una funci&oacute;n de usuario permanecer&aacute; cuando la funci&oacute;n sea traducida por <code>translate</code>. Con esto se hace posible que se muestre la definici&oacute;n llamando a <code>dispfun</code> y que la funci&oacute;n sea editada.
</p>
<p>Si <code>transrun</code> vale <code>false</code> entonces las versiones interpretadas de todas las funciones ser&aacute;n ejecutadas en lugar de las versiones traducidas.
</p>
<p>El resultado devuelto por <code>translate</code> es una lista con los nombres de las funciones traducidas.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>translate_file</b><i> (<var>nombre_fichero_maxima</var>)</i>
<a name="IDX1493"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>translate_file</b><i> (<var>nombre_fichero_maxima</var>, <var>nombre_fichero_lisp</var>)</i>
<a name="IDX1494"></a>
</dt>
<dd><p>Traduce un fichero en c&oacute;digo Maxima a un fichero en c&oacute;digo Lisp. La funci&oacute;n <code>translate_file</code> devuelve una lista con los nombres de tres ficheros: el nombre del ficheero en Maxima, el nombre del fichero en Lisp y el nombre del fichero que contiene informaci&oacute;n adicional sobre la traducci&oacute;n. La funci&oacute;n <code>translate_file</code> eval&uacute;a sus argumentos.
</p>
<p>La llamada <code>translate_file (&quot;foo.mac&quot;); load(&quot;foo.LISP&quot;)</code> es lo mismo que <code>batch (&quot;foo.mac&quot;)</code>, excepto por la presencia de ciertas restricciones, como el uso de <code>''</code> y <code>%</code>, por ejemplo.
</p>
<p>La llamada <code>translate_file (<var>nombre_fichero_maxima</var>)</code> traduce un fichero en Maxima, <var>nombre_fichero_maxima</var>, a otro en Lisp de nombre similar. Por ejemplo, <code>foo.mac</code> se traduce en <code>foo.LISP</code>. El nombre del fichero en Maxima puede incluir el nombre de un directorio, en cuyo caso el fichero de salida Lisp se guardar&aacute; en el mismo directorio desde el que se ley&oacute; la fuente Maxima.
</p>
<p>La llamada <code>translate_file (<var>nombre_fichero_maxima</var>, <var>nombre_fichero_lisp</var>)</code> traduce el fichero Maxima  <var>nombre_fichero_maxima</var> en el fichero Lisp <var>nombre_fichero_lisp</var>. La funci&oacute;n <code>translate_file</code> ignora la extensi&oacute;n del fichero, en caso de que exista, de <code>nombre_fichero_lisp</code>; la extensi&oacute;n del fichero de salida Lisp  ser&aacute; invariablemente <code>LISP</code>. El nombre del fichero Lisp puede incluir la ruta del directorio, en cuyo caso se almacenar&aacute; en el directorio especificado.
</p>
<p>La funci&oacute;n <code>translate_file</code> tambi&eacute;n escribe un fichero de mensajes de avisos del traductor con diversos niveles de gravedad. La extensi&oacute;n de este fichero es <code>UNLISP</code>. Este fichero puede contener informaci&oacute;n valiosa, aunque de dif&iacute;cil interpretaci&oacute;n, para detectar fallos en el c&oacute;digo traducido. El fichero <code>UNLISP</code> se guarda siempre en el mismo directorio desde el que se ley&oacute; la fuente de Maxima.
</p>
<p>La funci&oacute;n <code>translate_file</code> emite c&oacute;digo Lisp que incluye algunas declaraciones y definiciones que entran en efecto tan pronto como el c&oacute;digo Lisp es compilado. V&eacute;ase <code>compile_file</code> para m&aacute;s informaci&oacute;n sobre este particular.
</p>
<p>V&eacute;anse tambi&eacute;n <code>tr_array_as_ref</code>,
<code>tr_bound_function_applyp</code>,
<code>tr_exponent</code>,
<code>tr_file_tty_messagesp</code>, 
<code>tr_float_can_branch_complex</code>,
<code>tr_function_call_default</code>, 
<code>tr_numer</code>,
<code>tr_optimize_max_loop</code>, 
<code>tr_semicompile</code>,
<code>tr_state_vars</code>, 
<code>tr_warnings_get</code>,
<code>tr_warn_bad_function_calls</code>,
<code>tr_warn_fexpr</code>, 
<code>tr_warn_meval</code>,
<code>tr_warn_mode</code>,
<code>tr_warn_undeclared</code>,
y <code>tr_warn_undefined_variable</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>transrun</b>
<a name="IDX1495"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>transrun</code> vale <code>false</code> entonces se ejecutar&aacute;n las versiones interpretadas de todas las funciones, en lugar de las versiones traducidas.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>tr_array_as_ref</b>
<a name="IDX1496"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>translate_fast_arrays</code> vale <code>false</code>, referencias de arreglos en el c&oacute;digo Lisp creadas por  <code>translate_file</code> se ven afectadas por <code>tr_array_as_ref</code>.
</p>
<p>El valor de la variable <code>tr_array_as_ref</code> no tiene ning&uacute;n efecto cuando <code>translate_fast_arrays</code> vale <code>true</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>tr_bound_function_applyp</b>
<a name="IDX1497"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>tr_bound_function_applyp</code> vale <code>true</code>, Maxima env&iacute;a un aviso si encuentra una variable con valor asignado que est&aacute; siendo utilizada como una funci&oacute;n. <code>tr_bound_function_applyp</code> no influye en el c&oacute;digo generado bajo estas circunstancias.
</p>
<p>Por ejemplo, una expresi&oacute;n como <code>g (f, x) := f (x+1)</code> provocar&aacute; un mensaje de esta naturaleza.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>tr_file_tty_messagesp</b>
<a name="IDX1498"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>tr_file_tty_messagesp</code> vale <code>true</code>, los mensajes generados por <code>translate_file</code> durante la traducci&oacute;n de un fichero se muestran en la consola y se insertan en el fichero UNLISP.  Si vale <code>false</code>, los mensajes sobre la traducci&oacute;n del fichero s&oacute;lo se incorporan al fichero UNLISP.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>tr_float_can_branch_complex</b>
<a name="IDX1499"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Le dice al traductor de Maxima a Lisp que las funciones <code>acos</code>, <code>asin</code>, <code>asec</code> y <code>acsc</code> pueden devolver valores complejos.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>tr_function_call_default</b>
<a name="IDX1500"></a>
</dt>
<dd><p>Valor por defecto: <code>general</code>
</p>
<p>El valor <code>false</code> significa llama a <code>meval</code>, <code>expr</code> significa que Lisp asign&oacute; los argumentos de la funci&oacute;n,  <code>general</code>, el valor por defecto, devuelve c&oacute;digo apropiado para <code>mexprs</code> y <code>mlexprs</code> pero no para <code>macros</code>. La opci&oacute;n <code>general</code> asegura que las asignaciones de las variables son correctas en el c&oacute;digo compilado. En modo <code>general</code>, cuando se traduce F(X), si F es una variable con valor, entonces se entiende que se quiere calcular <code>apply (f, [x])</code>, y como tal se traduce, con el apropiado aviso. No es necesario desactivar esto. Con los valores por defecto la falta de mensajes de aviso implica compatibilidad completa entre el c&oacute;digo traducido y compilado con el interpretado por Maxima.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>tr_numer</b>
<a name="IDX1501"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>tr_numer</code> vale <code>true</code> se utilizan las propiedades num&eacute;ricas en aquellos &aacute;tomos que las posean, como en  <code>%pi</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>tr_optimize_max_loop</b>
<a name="IDX1502"></a>
</dt>
<dd><p>Valor por defecto: 100
</p>
<p>El valor de <code>tr_optimize_max_loop</code> es el n&uacute;mero m&aacute;ximo de veces que el traductor repetir&aacute; la macro-expansi&oacute;n y la optimizaci&oacute;n en el tratamiento de una expresi&oacute;n.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>tr_semicompile</b>
<a name="IDX1503"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>tr_semicompile</code> vale <code>true</code>, las salidas de <code>translate_file</code> y <code>compfile</code> ser&aacute;n macro-expandidas pero no compiladas a c&oacute;digo m&aacute;quina por el compilador de Lisp.
</p>
</dd></dl>

<dl>
<dt><u>Variable del sistema:</u> <b>tr_state_vars</b>
<a name="IDX1504"></a>
</dt>
<dd><p>Valor por defecto:
</p>
<pre class="example">[transcompile, tr_semicompile, tr_warn_undeclared, tr_warn_meval,
tr_warn_fexpr, tr_warn_mode, tr_warn_undefined_variable,
tr_function_call_default, tr_array_as_ref,tr_numer]
</pre>
<p>Es la lista de variables que afectan la forma en que se obtiene la salida del c&oacute;digo traducido. Esta informaci&oacute;n es &uacute;til para desarrolladores que pretendan corregir posibles fallos del traductor. Comparando el c&oacute;digo traducido con el que se deber&iacute;a obtener bajo unas ciertas condiciones, es posible hacer el seguimiento de los fallos.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>tr_warnings_get</b><i> ()</i>
<a name="IDX1505"></a>
</dt>
<dd><p>Devuelve una lista con los avisos dados por el traductor.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>tr_warn_bad_function_calls</b>
<a name="IDX1506"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Devuelve un aviso cuando se hacen llamadas a funciones que quiz&aacute;s no sean correctas debido a declaraciones inapropiadas realizadas durante la traducci&oacute;n.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>tr_warn_fexpr</b>
<a name="IDX1507"></a>
</dt>
<dd><p>Valor por defecto: <code>compfile</code>
</p>
<p>Devuelve un aviso si se encuentra con alguna FEXPR. Las FEXPR no deber&iacute;an aparecer en el c&oacute;digo traducido.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>tr_warn_meval</b>
<a name="IDX1508"></a>
</dt>
<dd><p>Valor por defecto: <code>compfile</code>
</p>
<p>Devuelve un aviso si la funci&oacute;n <code>meval</code> es llamada.  Si <code>meval</code> es invocada, es se&ntilde;al de la presencia de problemas en la traducci&oacute;n.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>tr_warn_mode</b>
<a name="IDX1509"></a>
</dt>
<dd><p>Valor por defecto: <code>all</code>
</p>
<p>Devuelve un aviso cuando a las variables se les asignan valores incompatibles con su modo.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>tr_warn_undeclared</b>
<a name="IDX1510"></a>
</dt>
<dd><p>Valor por defecto: <code>compile</code>
</p>
<p>Determina cuando enviar mensajes sobre variables no declaradas.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>tr_warn_undefined_variable</b>
<a name="IDX1511"></a>
</dt>
<dd><p>Valor por defecto: <code>all</code>
</p>
<p>Devuelve un aviso cuando se detectan variables globales no definidas.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>compile_file</b><i> (<var>nombre_fich</var>)</i>
<a name="IDX1512"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>compile_file</b><i> (<var>nombre_fich</var>, <var>nombre_fich_compilado</var>)</i>
<a name="IDX1513"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>compile_file</b><i> (<var>nombre_fich</var>, <var>nombre_fich_compilado</var>, <var>nombre_fich_lisp</var>)</i>
<a name="IDX1514"></a>
</dt>
<dd><p>Traduce el fichero Maxima <var>nombre_fich</var> a Lisp, ejecuta el compilador de Lisp y, en caso de ser exitosa la compilaci&oacute;n, carga el c&oacute;digo compilado en Maxima.
</p>
<p>La funci&oacute;n <code>compile_file</code> devuelve una lista con los nombres de tres ficheros: el fichero original en Maxima, la traducci&oacute;n Lisp, notas sobre la traducci&oacute;n y el c&oacute;digo compilado. Si la compilaci&oacute;n falla, el cuarto elemento es  <code>false</code>.
</p>
<p>Algunas declaraciones y definiciones entran en efecto tan pronto como el c&oacute;digo Lisp es compilado (sin cargar el c&oacute;digo compilado). &Eacute;stas incluyen funciones definidas con el operador <code>:=</code>, macros definidas con el operador <code>::=</code>, <code>alias</code>, <code>declare</code>, <code>define_variable</code>,  <code>mode_declare</code> y <code>infix</code>, <code>matchfix</code>,
<code>nofix</code>, <code>postfix</code>, <code>prefix</code> y <code>compfile</code>.
</p>
<p>Asignaciones y llamadas a funciones no se eval&uacute;an hasta que el c&oacute;digo compilado es cargado. En particular, dentro del fichero Maxima, asignaciones a los controles (&quot;flags&quot;) de traducci&oacute;n (<code>tr_numer</code>, etc.) no tienen efecto durante la traducci&oacute;n.
</p>
<p>El <var>nombre_fich</var> no puede contener sentencias del tipo <code>:lisp</code>.
</p>
<p>La funci&oacute;n <code>compile_file</code> eval&uacute;a sus argumentos.
</p>
</dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>declare_translated</b><i> (<var>f_1</var>, <var>f_2</var>, ...)</i>
<a name="IDX1515"></a>
</dt>
<dd><p>Cuando se traduce un fichero de c&oacute;digo Maxima a Lisp, es importante para el traductor saber qu&eacute; funciones de las que est&aacute;n en el fichero van a ser llamadas como traducidas o compiladas, y cu&aacute;les son simplemente funciones Maxima o que no est&aacute;n definidas. Se genera el c&oacute;digo <code>(MFUNCTION-CALL fn arg1 arg2 ...)</code> cuando el traductor no sabe si <code>fn</code> va a ser una funci&oacute;n lisp.
</p>
</dd></dl>

<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC194" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC201" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Robert</em> on <em>diciembre, 10 2012</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
