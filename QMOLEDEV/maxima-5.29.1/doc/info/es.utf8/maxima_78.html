<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on diciembre, 10 2012 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual de Maxima: 78. to_poly_solve</title>

<meta name="description" content="Manual de Maxima: 78. to_poly_solve">
<meta name="keywords" content="Manual de Maxima: 78. to_poly_solve">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body
{
    color: black;
    background: white; 
    margin-left: 8%;
    margin-right: 13%;
}

h1
{
    margin-left: +8%;
    font-size: 150%;
    font-family: sans-serif
}

h2
{
    font-size: 125%;
    font-family: sans-serif
}

h3
{
    font-size: 100%;
    font-family: sans-serif
}

h2,h3,h4,h5,h6 { margin-left: +4%; }

div.textbox
{
    border: solid;
    border-width: thin;
    /* width: 100%; */
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em
}

div.titlebox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
    background: rgb(200,255,255);
    font-family: sans-serif
}

div.synopsisbox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
     background: rgb(255,220,255);
    /*background: rgb(200,255,255); */
    /* font-family: fixed */
}

pre.example
{
    border: 1px solid gray;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 1em;
    padding-right: 1em;
    /* background: rgb(247,242,180); */ /* kind of sandy */
    /* background: rgb(200,255,255); */ /* sky blue */
    background-color: #F1F5F9; /* light blue-gray */
    /* font-family: "Lucida Console", monospace */
}

div.spacerbox
{
    border: none;
    padding-top: 2em;
    padding-bottom: 2em
}

div.image
{
    margin: 0;
    padding: 1em;
    text-align: center;
}

div.categorybox
{
    border: 1px solid gray;
    padding-top: 0px;
    padding-bottom: 0px;
    padding-left: 1em;
    padding-right: 1em;
    background: rgb(247,242,220);
}


-->
</style>

<link rel="icon" href="http://maxima.sourceforge.net/favicon.ico"/>
</head>

<body lang="es" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="to_005fpoly_005fsolve"></a>
<a name="SEC365"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_77.html#SEC364" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC366" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC360" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC367" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 78. to_poly_solve </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC366">78.1 Funciones y variables para to_poly_solve</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Funciones-y-variables-para-to_005fpoly_005fsolve"></a>
<a name="SEC366"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC365" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC367" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC365" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC365" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC367" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 78.1 Funciones y variables para to_poly_solve </h2>

<p>Los paquetes <code>to_poly</code> y <code>to_poly_solve</code> son experimentales,
siendo posible que las especificaciones de sus funciones puedan
cambiar en el futuro, o que algunas de estas funciones puedan ser
incorporadas a otras partes de Maxima.
</p>
<p>Los paquetes <code>to_poly</code> y <code>to_poly_solve</code>, junto con su documentaci&oacute;n,
fue escrito por Barton Willis de la Universidad de Nebraska en Kearney. 
</p>





<dl>
<dt><u>Operador:</u> <b>%and</b>
<a name="IDX2738"></a>
</dt>
<dd><p>El operador <code>%and</code> es una conjunci&oacute;n l&oacute;gica. Maxima simplifica
una expresi&oacute;n <code>%and</code> a <code>true</code>, <code>false</code> o a una expresi&oacute;n
l&oacute;gicamente equivalente, pero simplificada. El operador <code>%and</code>
es asociativo, conmutativo e idempotente. As&iacute;, cuando <code>%and</code>
devuelva una forma nominal, sus argumentos no ser&aacute;n redundantes; por ejemplo,
</p>
<pre class="example">(%i1) a %and (a %and b);
(%o1)                       a %and b
</pre>
<p>Si uno de los argumentos de la conjunci&oacute;n es la negaci&oacute;n de otro argumento,
<code>%and</code> devuelve <code>false</code>:
</p>
<pre class="example"> (%i2) a %and (not a);
 (%o2) false
</pre>
<p>Si cualquiera de los argumentos vale <code>false</code>, la conjunci&oacute;n devuelve
<code>false</code>, incluso cuando haya alg&uacute;n otro argumento que sea una
expresi&oacute;n no booleana; por ejemplo,
</p>
<pre class="example">(%i2) a %and (not a);
(%o2)                         false
</pre>
<p>Los argumentos de la expresi&oacute;n <code>%and</code> que sean inecuaciones se
reducen con la simplificaci&oacute;n de Fourier; el m&eacute;todo que se
aplica dispone de un pre-procesador que convierte algunas, pero no
todas, las inecuaciones no lineales a lineales. Por ejemplo, el
m&eacute;todo de simplificaci&oacute;n de Fourier simplifica <code>abs(x) + 1 &gt; 0</code>
a <code>true</code>:
</p>
<pre class="example">(%i4) (x &lt; 1) %and (abs(x) + 1 &gt; 0);
(%o4)                         x &lt; 1
</pre>
<p><b>Notas</b>  
</p><ul>
<li> La variable opcional <code>prederror</code> no altera la
simplificaci&oacute;n de las expresiones <code>%and</code>.

</li><li> Para evitar errores en la precedencia de las operaciones,
se recomienda utilizar par&eacute;ntesis en las expresiones combinadas
en las que aparezcan los operadores <code>%and</code>,  <code>%or</code> y <code>not</code> .

</li><li> Los operadores <code>and</code> y <code>or</code>, tal como est&aacute;n
programados en Maxima, no conocen las propiedades asociativa
ni conmutativa.

</li></ul>

<p><b>Limitaciones</b> La conjunci&oacute;n <code>%and</code> simplifica inecuaciones
<i>locamente</i>, no <i>globalmente</i>, lo que significa que conjunciones tales como
</p>
<pre class="example">(%i5) (x &lt; 1) %and (x &gt; 1);
(%o5)                 (x &gt; 1) %and (x &lt; 1)
</pre>
<p><i>no</i> simplifican a <code>false</code>. Adem&aacute;s, las rutinas de eliminaci&oacute;n de Fourier
ignoran los hechos almacenados en la base de datos.
</p>
<pre class="example">(%i6) assume(x &gt; 5);
(%o6)                        [x &gt; 5]
(%i7) (x &gt; 1) %and (x &gt; 2);
(%o7)                 (x &gt; 1) %and (x &gt; 2)
</pre>
<p>Por &uacute;ltimo, las inecuaciones no lineales que no se puedan reducir de
manera sencilla a formas lineales, no se simplifican.
</p>
<p>No est&aacute; soportada la distributividad de <code>%and</code> respecto de <code>%or</code>,
ni la negaci&oacute;n respecto de <code>%and</code>.
</p>
<p>Para hacer uso de este operador, ejec&uacute;tese <code>load(to_poly_solve)</code>.
</p>
<p>V&eacute;anse tambi&eacute;n <code>%or</code>, <code>%if</code>, <code>and</code>, <code>or</code> y <code>not</code>.
</p>
</dd></dl>






<dl>
<dt><u>Operador:</u> <b>%if</b><i> ( <var>bool</var>, <var>a</var>, <var>b</var>)</i>
<a name="IDX2739"></a>
</dt>
<dd><p>El operador <code>%if</code> es un condicional. La condici&oacute;n <var>bool</var>
debe tomar un valor l&oacute;gico; cuando sea <code>true</code>, se devolver&aacute;
el segundo argumento, y cuando valga <code>false</code>, el segundo. En
cualquier otro caso, se obtiene una forma nominal.
</p>
<p>En Maxima, las expresiones con desigualdades o igualdades no adquieren
valores l&oacute;gicos; por ejemplo, <em>5 &lt; 6</em> no se simplifica a <code>true</code>,
ni <em>5 = 6</em> <code>false</code>. Sin embargo, en la condici&oacute;n de una
sentencia <code>%if</code>, Maxima intenta determinar el valor l&oacute;gico
de la expresi&oacute;n de forma autom&aacute;tica. V&eacute;ase un ejemplo:
</p>
<pre class="example">(%i1) f : %if(x # 1, 2, 8);
(%o1)                 %if(x - 1 # 0, 2, 8)
(%i2) [subst(x = -1,f), subst(x=1,f)];
(%o2)                        [2, 8]
</pre>
<p>Si en la condici&oacute;n aparece una inecuaci&oacute;n, Maxima la
reduce con una simplificaci&oacute;n de Fourier.
</p>
<p><b>Notas</b> 
</p><ul class="toc">
<li> bullet  Si la condici&oacute;n no se reduce a un valor l&oacute;gico, Maxima devuelve
una forma nominal:
<pre class="example">(%i3) %if(42,1,2);
(%o3)                     %if(42, 1, 2)
</pre>
</li><li> bullet  El operador <code>if</code> de Maxima es n-ario, pero el operador <code>%if</code> no lo es.
</li></ul>

<p>Por &uacute;ltimo, las inecuaciones no lineales que no se puedan reducir de
manera sencilla a formas lineales, no se simplifican.
</p>
<p>Para hacer uso de este operador, ejec&uacute;tese <code>load(to_poly_solve)</code>.
</p></dd></dl>




  
<dl>
<dt><u>Operador:</u> <b>%or</b>
<a name="IDX2740"></a>
</dt>
<dd><p>El operador <code>%or</code> es una disyunci&oacute;n l&oacute;gica. Maxima simplifica
una expresi&oacute;n <code>%or</code> a <code>true</code>, <code>false</code> o a una expresi&oacute;n
l&oacute;gicamente equivalente, pero simplificada. El operador <code>%or</code>
es asociativo, conmutativo e idempotente. As&iacute;, cuando <code>%or</code>
devuelva una forma nominal, sus argumentos no ser&aacute;n redundantes; por ejemplo,
</p>
<pre class="example">(%i1) a %or (a %or b);
(%o1)                        a %or b
</pre>
<p>Si uno de los argumentos de la disyunci&oacute;n es la negaci&oacute;n de otro argumento,
<code>%or</code> devuelve <code>true</code>:
</p>
<pre class="example">(%i2) a %or (not a);
(%o2)                         true
</pre>
<p>Si cualquiera de los argumentos vale <code>true</code>, la disyunci&oacute;n devuelve
<code>true</code>, incluso cuando haya alg&uacute;n otro argumento que sea una
expresi&oacute;n no booleana; por ejemplo,
</p>
<pre class="example">(%i3) 42 %or true;
(%o3)                         true
</pre>
<p>Los argumentos de la expresi&oacute;n <code>%or</code> que sean inecuaciones se
reducen con la simplificaci&oacute;n de Fourier. Por ejemplo, el
m&eacute;todo de simplificaci&oacute;n de Fourier simplifica <code>abs(x) + 1 &gt; 0</code>
a <code>true</code>:
</p>
<pre class="example">(%i4) (x &lt; 1) %or (abs(x) + 1 &gt; 0);
(%o4)                         true
</pre>
<p><b>Notas</b>  
</p><ul>
<li> La variable opcional <code>prederror</code> no altera la
simplificaci&oacute;n de las expresiones <code>%or</code>.

</li><li> Para evitar errores en la precedencia de las operaciones,
se recomienda utilizar par&eacute;ntesis en las expresiones combinadas
en las que aparezcan los operadores <code>%and</code>,  <code>%or</code> y <code>not</code> .

</li><li> Los operadores <code>and</code> y <code>or</code>, tal como est&aacute;n
programados en Maxima, no conocen las propiedades asociativa
ni conmutativa.

</li></ul>

<p><b>Limitaciones</b> La conjunci&oacute;n <code>%or</code> simplifica inecuaciones
<i>locamente</i>, no <i>globalmente</i>, lo que significa que disyunciones tales como
</p>
<pre class="example"> (%i1) (x &lt; 1) %or (x &gt;= 1);
 (%o1) (x &gt; 1) %or (x &gt;= 1)
</pre>
<p><i>no</i> simplifican a <code>true</code>. Adem&aacute;s, las rutinas de eliminaci&oacute;n de Fourier
ignoran los hechos almacenados en la base de datos.
</p>
<pre class="example">(%i2) assume(x &gt; 5);
(%o2)                        [x &gt; 5]
(%i3) (x &gt; 1) %and (x &gt; 2);
(%o3)                 (x &gt; 1) %and (x &gt; 2)
</pre>
<p>Por &uacute;ltimo, las inecuaciones no lineales que no se puedan reducir de
manera sencilla a formas lineales, no se simplifican.
</p>
<p>No est&aacute; soportada la distributividad de <code>%or</code> respecto de <code>%and</code>,
ni la negaci&oacute;n respecto de <code>%or</code>.
</p>
<p>Para hacer uso de este operador, ejec&uacute;tese <code>load(to_poly_solve)</code>.
</p>
<p>V&eacute;anse tambi&eacute;n <code>%and</code>, <code>%if</code>, <code>and</code>, <code>or</code> y <code>not</code>.
</p>
</dd></dl>





<dl>
<dt><u>Funci&oacute;n:</u> <b>complex_number_p</b><i> (<var>x</var>)</i>
<a name="IDX2741"></a>
</dt>
<dd><p>La funci&oacute;n <code>complex_number_p</code> devuelve <code>true</code> si su
argumento es de cualquiera de las formas <code>a + %i * b</code>, <code>a</code>, <code>%i b</code> o
<code>%i</code>, donde <code>a</code> y <code>b</code> son racionales o decimales en coma flotante,
de precisi&oacute;n doble o arbitraria (<i>bigfloats</i>); para cualesquiera otros argumentos,
<code>complex_number_p</code> devuelve <code>false</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) map('complex_number_p,[2/3, 2 + 1.5 * %i, %i]);
(%o1)                  [true, true, true]
(%i2) complex_number_p((2+%i)/(5-%i));
(%o2)                         false
(%i3) complex_number_p(cos(5 - 2 * %i));
(%o3)                         false
</pre>
<p>V&eacute;ase tambi&eacute;n <code>isreal_p</code>.
</p>
<p>Para hacer uso de esta funci&oacute;n, ejec&uacute;tese <code>load(to_poly_solve)</code>.
</p></dd></dl>






<dl>
<dt><u>Funci&oacute;n:</u> <b>compose_functions</b><i> (<var>l</var>)</i>
<a name="IDX2742"></a>
</dt>
<dd><p>La funci&oacute;n <code>compose_functions(l)</code> devuelve una expresi&oacute;n lambda
que es la composici&oacute;n de las funciones presentes en la lista <var>l</var>.
Las funciones se aplican de derecha a izquierda.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) compose_functions([cos, exp]);
                                        %g151
(%o1)             lambda([%g151], cos(%e     ))
(%i2) %(x);
                                  x
(%o2)                       cos(%e )
</pre>
<p>Si la lista est&aacute; vac&iacute;a devuelve la funci&oacute;n identidad:
</p>
<pre class="example">(%i3) compose_functions([]);
(%o3)                lambda([%g152], %g152)
(%i4)  %(x);
(%o4)                           x
</pre>
<p><b>Notas</b> 
</p><ul>
<li> Cuando Maxima detecta que un miembro de la lista no es un
s&iacute;mbolo o expresi&oacute;n lambda, la funci&oacute;n 
<code>funmake</code> (no <code>compose_functions</code>) muestra un mensaje de
error:
<pre class="example">(%i5) compose_functions([a &lt; b]);

funmake: first argument must be a symbol, subscripted symbol,
string, or lambda expression; found: a &lt; b
#0: compose_functions(l=[a &lt; b])(to_poly_solve.mac line 40)
 -- an error. To debug this try: debugmode(true);
</pre>
</li><li> Para evitar conflictos de nombres, la variable independiente se determina
con la funci&oacute;n <code>new_variable</code>:
<pre class="example">(%i6) compose_functions([%g0]);
(%o6)              lambda([%g154], %g0(%g154))
(%i7) compose_functions([%g0]);
(%o7)              lambda([%g155], %g0(%g155))
</pre><p>Aunque las variables dependientes sean diferentes, Maxima es capaz de
determinar que las expresiones lambda son sem&aacute;nticamente equivalentes:
</p><pre class="example">(%i8) is(equal(%o6,%o7));
(%o8)                         true
</pre></li></ul>

<p>Para hacer uso de esta funci&oacute;n, ejec&uacute;tese <code>load(to_poly_solve)</code>.
</p></dd></dl>






<dl>
<dt><u>Funci&oacute;n:</u> <b>dfloat</b><i> (<var>x</var>)</i>
<a name="IDX2743"></a>
</dt>
<dd><p>La funci&oacute;n <code>dfloat</code> es similar a <code>float</code>, pero <code>dfloat</code> 
aplica <code>rectform</code> cuando <code>float</code> no puede evaluar a un n&uacute;mero
decimal de coma flotante de doble precisi&oacute;n. Ejemplo:
</p>
<pre class="example">(%i1) float(4.5^(1 + %i));
                               %i + 1
(%o1)                       4.5
(%i2) dfloat(4.5^(1 + %i));
(%o2)        4.48998802962884 %i + .3000124893895671
</pre>
<p><b>Notas</b> 
</p>
<ul>
<li> La forma rectangular de una expresi&oacute;n puede no ser la
m&aacute;s adecuada para c&aacute;lculos num&eacute;ricos

</li><li> El identificador <code>float</code> es al mismo tiempo una variable opcional,
cuyo valor por defecto es <code>false</code> y el nombre de una funci&oacute;n.
</li></ul>

<p>V&eacute;anse tambi&eacute;n <code>float</code> y <code>bfloat</code>.
</p>
<p>Para hacer uso de esta funci&oacute;n, ejec&uacute;tese <code>load(to_poly_solve)</code>.
</p>
</dd></dl>






<dl>
<dt><u>Funci&oacute;n:</u> <b>elim</b><i> (<var>l</var>, <var>x</var>)</i>
<a name="IDX2744"></a>
</dt>
<dd><p>La funci&oacute;n <code>elim</code> elimina las variables que se indican en el conjunto
o lista <code>x</code> del conjunto o lista de ecuaciones en <code>l</code>. Cada
elemento de <code>x</code> debe ser un s&iacute;mbolo, mientras que los
elementos de <code>l</code> pueden ser ecuaciones o expresiones que se suponen
igualadas a cero.
</p>
<p>La funci&oacute;n <code>elim</code> devuelve una lista formada por dos listas; la
primera est&aacute; formada por las expresiones con las variables eliminadas y
la segunda es la lista de pivotes o, en otras palabras, es la lista de
expresiones que <code>elim</code> ha utilizado para proceder con la eliminaci&oacute;n.
</p>
<p>Ejemplo:
</p>
<p>Eliminaci&oacute;n entre ecuaciones lineales. Eliminando <code>x</code> e <code>y</code>
se obtiene una &uacute;nica ecuaci&oacute;n <code>2 z - 7 = 0</code>; las ecuaciones
<code>y + 7 = 0</code> y <code>z - z + 1 = 1</code> se han utilizado como pivotes.
</p>
<pre class="example">(%i1) elim(set(x + y + z = 1, x - y  - z = 8, x - z = 1), 
           set(x,y));
(%o1)            [[2 z - 7], [y + 7, z - x + 1]]
</pre>
<p>Eliminando las tres variables de estas ecuaciones se triangulariza el sistema
lineal:
</p>
<pre class="example">(%i2) elim(set(x + y + z = 1, x - y  - z = 8, x - z = 1),
           set(x,y,z));
(%o2)           [[], [2 z - 7, y + 7, z - x + 1]]
</pre>
<p>Las ecuaciones no necesitan ser lineales:
</p>
<pre class="example">(%i3) elim(set(x^2 - 2 * y^3 = 1,  x - y = 5), [x,y]);
                     3    2
(%o3)       [[], [2 y  - y  - 10 y - 24, y - x + 5]]
</pre>
<p>El usuario no puede controlar el orden en el que se eliminan las
variables. El algoritmo utiliza una heur&iacute;stica con
la que intenta escoger el mejor pivote y el mejor orden de eliminaci&oacute;n.
</p>
<p><b>Notas</b> 
</p>
<ul>
<li> Al contrario que la funci&oacute;n relacionada <code>eliminate</code>, la
funci&oacute;n <code>elim</code> no llama a la funci&oacute;n <code>solve</code> cuando el
n&uacute;mero de ecuaciones iguala al de variables.

</li><li> La funci&oacute;n <code>elim</code> trabaja aplicando resultantes; la variable
opcional <code>resultant</code> determina qu&eacute; algoritmo va a utilizar Maxima.
Con <code>sqfr</code>, Maxima factoriza cada resultante y suprime ceros m&uacute;ltiples.

</li><li> <code>elim</code> triangulariza un conjunto de ecuaciones polin&oacute;micas no
lineales; el conjunto soluci&oacute;n del conjunto triangularizado puede ser mayor
que el conjunto de soluciones del conjunto no triangularizado, por lo que
las ecuaciones triangularizadas pueden tener soluciones falsas.

</li></ul>

<p>V&eacute;anse tambi&eacute;n <code>elim_allbut</code>, <code>eliminate_using</code>, <code>eliminate</code>
y <code>resultant</code>.
</p>
<p>Para hacer uso de esta funci&oacute;n, ejec&uacute;tese <code>load(to_poly)</code>.
</p>
</dd></dl>







<dl>
<dt><u>Funci&oacute;n:</u> <b>elim_allbut</b><i> (<var>l</var>, <var>x</var>)</i>
<a name="IDX2745"></a>
</dt>
<dd><p>Es similar a <code>elim</code>, excepto por el hecho de que elimina todas las variables
que aparecen en la lista de ecuaciones <code>l</code> que no est&aacute;n en <code>x</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) elim_allbut([x+y = 1, x - 5*y = 1],[]);
(%o1)                 [[], [y, y + x - 1]]
(%i2) elim_allbut([x+y = 1, x - 5*y = 1],[x]);
(%o2)                [[x - 1], [y + x - 1]]
</pre>
<p>Para hacer uso de esta funci&oacute;n, ejec&uacute;tese <code>load(to_poly)</code>.
</p>
<p>V&eacute;anse tambi&eacute;n <code>elim</code>, <code>eliminate_using</code>, <code>eliminate</code>
y <code>resultant</code>.
</p>
</dd></dl>





<dl>
<dt><u>Funci&oacute;n:</u> <b>eliminate_using</b><i> (<var>l</var>, <var>e</var>, <var>x</var>)</i>
<a name="IDX2746"></a>
</dt>
<dd><p>Elmina el s&iacute;mbolo <code>x</code> de la lista o conjunto de ecuaciones
<code>l</code> haciendo uso del pivote <code>e</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) eq : [x^2 - y^2 - z^3 , x*y - z^2 - 5, x - y + z];
               3    2    2     2
(%o1)      [- z  - y  + x , - z  + x y - 5, z - y + x]
(%i2) eliminate_using(eq,first(eq),z);
        3              2      2      3    2
(%o2) {y  + (1 - 3 x) y  + 3 x  y - x  - x , 
                        4    3  3       2  2             4
                       y  - x  y  + 13 x  y  - 75 x y + x  + 125}
(%i3) eliminate_using(eq,second(eq),z);
        2            2       4    3  3       2  2             4
(%o3) {y  - 3 x y + x  + 5, y  - x  y  + 13 x  y  - 75 x y + x
                                                           + 125}
(%i4) eliminate_using(eq, third(eq),z);
        2            2       3              2      2      3    2
(%o4) {y  - 3 x y + x  + 5, y  + (1 - 3 x) y  + 3 x  y - x  - x }
</pre>
<p>Para hacer uso de esta funci&oacute;n, ejec&uacute;tese <code>load(to_poly)</code>.
</p>
<p>V&eacute;anse tambi&eacute;n <code>elim</code>, <code>elim_allbut</code>, <code>eliminate</code>
y <code>resultant</code>.
</p>
</dd></dl>






<dl>
<dt><u>Funci&oacute;n:</u> <b>fourier_elim</b><i> ([<var>eq1</var>, <var>eq2</var>, ...], [<var>var1</var>, <var>var</var>, ...])</i>
<a name="IDX2747"></a>
</dt>
<dd><p>La instrucci&oacute;n <code>fourier_elim([eq1,eq2,...], [var1,var2,...]</code> aplica el
algoritmo de eliminaci&oacute;n de Fourier para resolver el sistema de inecuaciones 
lineales <code>[eq1,eq2,...]</code> respecto de las variables <code>[var1,var2,...]</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) fourier_elim([y-x &lt; 5, x - y &lt; 7, 10 &lt; y],[x,y]);
(%o1)            [y - 5 &lt; x, x &lt; y + 7, 10 &lt; y]
(%i2) fourier_elim([y-x &lt; 5, x - y &lt; 7, 10 &lt; y],[y,x]);
(%o2)        [max(10, x - 7) &lt; y, y &lt; x + 5, 5 &lt; x]
</pre>
<p>Eliminando primero respecto de <em>x</em> y luego respecto de <em>y</em>,
se obtienen l&iacute;mites inferior y superior para <em>x</em>
que dependen de <em>y</em>, y l&iacute;mites num&eacute;ricos para <em>y</em>.
Si se eliminan en orden inverso, se obtienen los l&iacute;mites
de <em>y</em> en funci&oacute;n de <em>x</em>, y los de <em>x</em> son n&uacute;meros.
</p>
<p>De ser necesario, <code>fourier_elim</code> devuelve una disyunci&oacute;n de listas
de ecuaciones:
</p>
<pre class="example">(%i3) fourier_elim([x # 6],[x]);
(%o3)                  [x &lt; 6] or [6 &lt; x]
</pre>
<p>Si no existe soluci&oacute;n, <code>fourier_elim</code> devuelve <code>emptyset</code>,
y si la soluci&oacute;n son todos los reales, <code>fourier_elim</code> devuelve 
<code>universalset</code>:
</p>
<pre class="example">(%i4) fourier_elim([x &lt; 1, x &gt; 1],[x]);
(%o4)                       emptyset
(%i5) fourier_elim([minf &lt; x, x &lt; inf],[x]);
(%o5)                     universalset
</pre>
<p>En caso de que las inecuaciones no sean lineales, <code>fourier_elim</code>
devuelve una lista de inecuaciones simplificadas:
</p>
<pre class="example">(%i6) fourier_elim([x^3 - 1 &gt; 0],[x]);
               2                             2
(%o6) [1 &lt; x, x  + x + 1 &gt; 0] or [x &lt; 1, - (x  + x + 1) &gt; 0]
(%i7) fourier_elim([cos(x) &lt; 1/2],[x]);
(%o7)                  [1 - 2 cos(x) &gt; 0]
</pre>
<p>En lugar de una lista de inecuaciones, el primer argumento pasado a
<code>fourier_elim</code> puede ser una conjunci&oacute;n o disyunci&oacute;n l&oacute;gica.
</p>
<pre class="example">(%i8) fourier_elim((x + y &lt; 5) and (x - y &gt;8),[x,y]);
                                              3
(%o8)            [y + 8 &lt; x, x &lt; 5 - y, y &lt; - -]
                                              2
(%i9) fourier_elim(((x + y &lt; 5) and x &lt; 1) or  (x - y &gt;8),[x,y]);
(%o9)          [y + 8 &lt; x] or [x &lt; min(1, 5 - y)]
</pre>
<p>La funci&oacute;n <code>fourier_elim</code> soporta los operadores de desigualdad 
<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>#</code> y <code>=</code>.
</p>
<p>La rutina de eliminaci&oacute;n de Fourier dispone de un preprocesador que
convierte algunas inecuaciones no lineales formadas con las funciones
del valor absoluto, m&iacute;nimo y m&aacute;ximo a inecuaciones 
lineales. Adem&aacute;s, el preprocesador admite algunas expresiones 
que son productos o cocientes de t&eacute;rminos lineales:
</p>
<pre class="example">(%i10) fourier_elim([max(x,y) &gt; 6, x # 8, abs(y-1) &gt; 12],[x,y]);
(%o10) [6 &lt; x, x &lt; 8, y &lt; - 11] or [8 &lt; x, y &lt; - 11]
 or [x &lt; 8, 13 &lt; y] or [x = y, 13 &lt; y] or [8 &lt; x, x &lt; y, 13 &lt; y]
 or [y &lt; x, 13 &lt; y]
(%i11) fourier_elim([(x+6)/(x-9) &lt;= 6],[x]);
(%o11)           [x = 12] or [12 &lt; x] or [x &lt; 9]
(%i12) fourier_elim([x^2 - 1 # 0],[x]);
(%o12)      [- 1 &lt; x, x &lt; 1] or [1 &lt; x] or [x &lt; - 1]
</pre>
<p>Para hacer uso de esta funci&oacute;n, ejec&uacute;tese <code>load(fourier_elim)</code>.
</p>
</dd></dl>







<dl>
<dt><u>Funci&oacute;n:</u> <b>isreal_p</b><i> (<var>e</var>)</i>
<a name="IDX2748"></a>
</dt>
<dd><p>El predicado <code>isreal_p</code> devuelve <code>true</code> si <code>e</code> representa un
n&uacute;mero real y <code>false</code> si no representa un punto de la recta; en cualquier
otro caso devuelve una forma nominal.
</p>
<pre class="example">(%i1) map('isreal_p, [-1, 0, %i, %pi]);
(%o1)               [true, true, false, true]
</pre>
<p>Las variables de Maxima se interpretan como n&uacute;meros reales:
</p>
<pre class="example">(%i2) isreal_p(x);
(%o2)                         true
</pre>
<p>La funci&oacute;n <code>isreal_p</code> consulta los hechos almacenados en la base de datos:
</p><pre class="example">(%i3) declare(z,complex)$

(%i4) isreal_p(z);
(%o4)                      isreal_p(z)
</pre>
<p><b>Limitaciones</b>
Con frecuencia, <code>isreal_p</code> devuelve una forma nominal cuando deber&iacute;a
devolver <code>false</code>; por ejemplo, la funci&oacute;n logar&iacute;tmica no toma valores
reales en toda la recta real, por lo que  <code>isreal_p(log(x))</code> deber&iacute;a
devolver <code>false</code>, sin embargo:
</p>
<pre class="example">(%i5) isreal_p(log(x));
(%o5)                   isreal_p(log(x))
</pre>
<p>Para hacer uso de esta funci&oacute;n, ejec&uacute;tese <code>load(to_poly_solve)</code>.
</p>
<p>V&eacute;ase tambi&eacute;n <code>complex_number_p</code>.
</p>
</dd></dl>






<dl>
<dt><u>Funci&oacute;n:</u> <b>new_variable</b><i> (<var>type</var>)</i>
<a name="IDX2749"></a>
</dt>
<dd><p>Devuelve un s&iacute;mbolo de la forma <code>%[z,n,r,c,g]k</code>,
siendo <code>k</code> un n&uacute;mero entero. Los valores admisibles para <var>type</var>
son <code>integer</code>, <code>natural_number</code>, <code>real</code>, <code>natural_number</code>
y <code>general</code>. Por n&uacute;mero natural se entiende <i>entero negativo</i>, de 
manera que el ceero es un n&uacute;mero natural.
</p>
<p>Cuando <var>type</var> no es de ninguno de los tipos indicados m&aacute;s arriba,
<var>type</var> toma por defecto el valor <code>general</code>. Para enteros, n&uacute;meros
naturales y n&uacute;meros complejos, Maxima a&ntilde;ade esta informaci&oacute;n a la base de
datos de forma autom&aacute;tica.
</p>
<pre class="example">(%i1) map('new_variable,
          ['integer, 'natural_number, 'real, 'complex, 'general]);
(%o1)          [%z144, %n145, %r146, %c147, %g148]
(%i2) nicedummies(%);
(%o2)               [%z0, %n0, %r0, %c0, %g0]
(%i3) featurep(%z0, 'integer);
(%o3)                         true
(%i4) featurep(%n0, 'integer);
(%o4)                         true
(%i5) is(%n0 &gt;= 0);
(%o5)                         true
(%i6) featurep(%c0, 'complex);
(%o6)                         true
</pre>
<p>Es recomendable que al argumento de <code>new_variable</code> se le
aplique el operador de comilla simple para evitar su evaluaci&oacute;n,
de esta manera se evitan errores como el siguiente:
</p>
<pre class="example">(%i7) integer : 12$

(%i8) new_variable(integer);
(%o8)                         %g149
(%i9) new_variable('integer);
(%o9)                         %z150
</pre>
<p>Para hacer uso de esta funci&oacute;n, ejec&uacute;tese <code>load(to_poly_solve)</code>.
</p>
<p>V&eacute;ase tambi&eacute;n <code>nicedummies</code>.
</p>
</dd></dl>






<dl>
<dt><u>Funci&oacute;n:</u> <b>nicedummies</b>
<a name="IDX2750"></a>
</dt>
<dd><p>La funci&oacute;n <code>nicedummies</code> reescribe los &iacute;ndices,
comenzando por cero, de las variables de una expresi&oacute;n qua hayan
sido introducidas por <code>new_variable</code>:
</p>
<pre class="example">(%i1) new_variable('integer) + 52 * new_variable('integer);
(%o1)                   52 %z136 + %z135
(%i2) new_variable('integer) - new_variable('integer);
(%o2)                     %z137 - %z138
(%i3) nicedummies(%);
(%o3)                       %z0 - %z1
</pre>
<p>Para hacer uso de esta funci&oacute;n, ejec&uacute;tese <code>load(to_poly_solve)</code>.
</p>
<p>V&eacute;ase tambi&eacute;n <code>new_variable</code>.
</p>
</dd></dl>





<dl>
<dt><u>Funci&oacute;n:</u> <b>parg</b><i> (<var>x</var>)</i>
<a name="IDX2751"></a>
</dt>
<dd><p>La funci&oacute;n <code>parg</code> es una versi&oacute;n con capacidades simplificadoras
de la funci&oacute;n de argumento complejo <code>carg</code>:
</p>
<pre class="example">(%i1) map('parg,[1,1+%i,%i, -1 + %i, -1]);
                        %pi  %pi  3 %pi
(%o1)               [0, ---, ---, -----, %pi]
                         4    2     4
</pre>
<p>Si el argumento pasado a la funci&oacute;n <code>parg</code> no es una constante,
se devolver&aacute; una forma nominal:
</p>
<pre class="example">(%i2) parg(x + %i * sqrt(x));
(%o2)                 parg(x + %i sqrt(x))
</pre>
<p>Si <code>sign</code> detecta que la entrada es un n&uacute;mero real negativo o
positivo, <code>parg</code> devuelve una forma no nominal aunque la entrada
no sea una constante:
</p>
<pre class="example">(%i3) parg(abs(x));
(%o3) 0
(%i4) parg(-x^2-1);
(%o4)                          %pi
</pre>
<p>La funci&oacute;n <code>sign</code> suele ignorar las variables declaradas complejas
(<code>declare(x,complex)</code>); en tales casos, <code>parg</code>
puede retornar valores incorrectos:
</p>
<pre class="example">(%i1) declare(x,complex)$

(%i2) parg(x^2 + 1);
(%o2) 0
</pre>
<p>Para hacer uso de esta funci&oacute;n, ejec&uacute;tese <code>load(to_poly_solve)</code>.
</p>
<p>V&eacute;anse tambi&eacute;n <code>carg</code>, <code>isreal_p</code>.
</p>
</dd></dl>






<dl>
<dt><u>Funci&oacute;n:</u> <b>real_imagpart_to_conjugate</b><i> (<var>e</var>)</i>
<a name="IDX2752"></a>
</dt>
<dd><p>La funci&oacute;n <code>real_imagpart_to_conjugate</code> reemplaza todas las
llamadas a <code>realpart</code> y <code>imagpart</code> presentes en una expresi&oacute;n 
por llamadas a <code>conjugate</code>, obteniendo otra expresi&oacute;n equivalente:
</p>
<pre class="example">(%i1) declare(x, complex)$

(%i2) real_imagpart_to_conjugate(realpart(x) +  imagpart(x) = 3);
          conjugate(x) + x   %i (x - conjugate(x))
(%o2)     ---------------- - --------------------- = 3
                 2                     2
</pre>
<p>Para hacer uso de esta funci&oacute;n, ejec&uacute;tese <code>load(to_poly_solve)</code>.
</p>
</dd></dl>





<dl>
<dt><u>Funci&oacute;n:</u> <b>rectform_log_if_constant</b><i> (<var>e</var>)</i>
<a name="IDX2753"></a>
</dt>
<dd><p>La funci&oacute;n <code>rectform_if_constant</code> convierte todos los t&eacute;rminos
de la forma <code>log(c)</code> a <code>rectform(log(c))</code>, siendo <code>c</code> 
una expresi&oacute;n constante o declarada como tal.
</p>
<pre class="example">(%i1) rectform_log_if_constant(log(1-%i) - log(x - %i));
                                 log(2)   %i %pi
(%o1)            - log(x - %i) + ------ - ------
                                   2        4
(%i2) declare(a,constant, b,constant)$

(%i3) rectform_log_if_constant(log(a + %i*b));
                       2    2
                  log(b  + a )
(%o3)             ------------ + %i atan2(b, a)
                       2
</pre>
<p>Para hacer uso de esta funci&oacute;n, ejec&uacute;tese <code>load(to_poly_solve)</code>.
</p>
</dd></dl>





<dl>
<dt><u>Funci&oacute;n:</u> <b>simp_inequality</b><i> (<var>e</var>)</i>
<a name="IDX2754"></a>
</dt>
<dd><p>La funci&oacute;n <code>simp_inequality</code> aplica ciertas simplificaciones
a conjunciones y disyunciones de inecuaciones.
</p>
<p><b>Limitaciones</b> La funci&oacute;n <code>simp_inequality</code> est&aacute; limitada en
al menos dos aspectos; en primer lugar, las simplificaciones son locales:
</p>
<pre class="example">(%i1) simp_inequality((x &gt; minf) %and (x &lt; 0));
(%o2) (x&gt;1) %and (x&lt;1)
</pre>
<p>En segundo lugar, <code>simp_inequality</code> no tiene en cuenta los hechos de la
base de datos:
</p>
<pre class="example">(%i2) assume(x &gt; 0)$

(%i3) simp_inequality(x &gt; 0);
(%o3)                         x &gt; 0
</pre>
<p>Para hacer uso de esta funci&oacute;n, ejec&uacute;tese <code>load(fourier_elim)</code>.
</p>
</dd></dl>





<dl>
<dt><u>Funci&oacute;n:</u> <b>standardize_inverse_trig</b><i> (<var>e</var>)</i>
<a name="IDX2755"></a>
</dt>
<dd><p>Esta funci&oacute;n aplica las identidades <code>cot(x) = atan(1/x)</code> y
<code>acsc(x) = asin(1/x)</code> y similares con <code>asec</code>, <code>acoth</code>
y <code>acsch</code>. Cons&uacute;ltese Abramowitz y Stegun, ecuaciones
4.4.6 a 4.4.8 y 4.6.4 a 4.6.6.
</p>
<p>Para hacer uso de esta funci&oacute;n, ejec&uacute;tese <code>load(to_poly_solve)</code>.
</p>
</dd></dl>





<dl>
<dt><u>Funci&oacute;n:</u> <b>subst_parallel</b><i> (<var>l</var>, <var>e</var>)</i>
<a name="IDX2756"></a>
</dt>
<dd><p>Dada la ecuaci&oacute;n o lista de ecuaciones <var>l</var> y la expresi&oacute;n
<var>e</var>, sustituye <i>en paralelo</i> en <var>e</var> los miembros izquierdos
de las ecuaciones por los derechos:
</p>
<pre class="example">(%i1) load(to_poly_solve)$

(%i2) subst_parallel([x=y,y=x], [x,y]);
(%o2)                        [y, x]
</pre>
<p>Comp&aacute;rese el resultado anterior con las sustituciones hechas en serie: 
</p>
<pre class="example">(%i3) subst([x=y,y=x],[x,y]);
(%o3)                        [x, x]
</pre>
<p>La funci&oacute;n <code>subst_parallel</code> es similar a <code>sublis</code>, excepto por
el hecho de que <code>subst_parallel</code> permite la sustituci&oacute;n de expresiones
no at&oacute;micas:
</p>
<pre class="example">(%i4) subst_parallel([x^2 = a, y = b], x^2 * y);
(%o4)                          a b
(%i5) sublis([x^2 = a, y = b], x^2 * y);

                                                             2
sublis: left-hand side of equation must be a symbol; found: x
 -- an error. To debug this try: debugmode(true);
</pre>
<p>Las sustituciones hechas por <code>subst_parallel</code> son literales, no sem&aacute;nticas,
por lo que <code>subst_parallel</code> no reconoce que <em>x * y</em> sea una subexpresi&oacute;n
de <em>x^2 * y</em>:
</p>
<pre class="example">(%i6) subst_parallel([x * y = a], x^2 * y);
                               2
(%o6)                         x  y
</pre>
<p>La funci&oacute;n <code>subst_parallel</code> realiza todas las sustituciones
antes de proceder a la simplificaci&oacute;n, lo que permite sustituciones
en expresiones condicionales que podr&iacute;n producir 
errores en caso de simplificar antes de sustituir:
</p>
<pre class="example">(%i7) subst_parallel([x = 0], %if(x &lt; 1, 5, log(x)));
(%o7)                           5
(%i8) subst([x = 0], %if(x &lt; 1, 5, log(x)));

log: encountered log(0).
 -- an error. To debug this try: debugmode(true);
</pre>
<p>Para hacer uso de esta funci&oacute;n, ejec&uacute;tese <code>load(to_poly_solve_extra.lisp)</code>.
</p>
<p>V&eacute;anse tambi&eacute;n <code>subst</code>, <code>sublis</code> y <code>ratsubst</code>.
</p>
</dd></dl>






<dl>
<dt><u>Funci&oacute;n:</u> <b>to_poly</b><i> (<var>e</var>, <var>l</var>)</i>
<a name="IDX2757"></a>
</dt>
<dd><p>La funci&oacute;n <code>to_poly</code> intenta convertir la ecuaci&oacute;n <var>e</var>
en un sistema de polinomios, junto con restricciones en forma de
desigualdades. Las soluciones del sistema polin&oacute;mico que cumplan
las restricciones son, a su vez, las soluciones de la ecuaci&oacute;n <var>e</var>.
Dicho de manera informal, <code>to_poly</code> intenta pasar a forma de
polinomio la ecuaci&oacute;n <var>e</var>; un ejemplo ayudar&aacute; a aclarar su
comportamiento:
</p>
<pre class="example">(%i1) load(to_poly_solve)$

(%i2) to_poly(sqrt(x) = 3, [x]);
                            2
(%o2) [[%g130 - 3, x = %g130 ], 
                      %pi                               %pi
                   [- --- &lt; parg(%g130), parg(%g130) &lt;= ---], []]
                       2                                 2
</pre>
<p>Las condiciones <code>-%pi/2&lt;parg(%g6),parg(%g6)&lt;=%pi/2</code> dicen que
<code>%g6</code> est&aacute; en el rango de la funci&oacute;n radical; cuando eso se
cumpla, el conjunto de ecuaciones de <code>sqrt(x) = 3</code> coincide con
el de <code>%g6-3,x=%g6^2</code>.
</p>
<p>Para convertir a forma polin&oacute;mica una expresi&oacute;n trigonom&eacute;trica,
es necesario introducir una sustituci&oacute;n no algebraica; tal sustituci&oacute;n
se devuelve en la tercera lista de la respuesta de <code>to_poly</code>:
</p>
<pre class="example">(%i3) to_poly(cos(x),[x]);
                2                                 %i x
(%o3)    [[%g131  + 1], [2 %g131 # 0], [%g131 = %e    ]]
</pre>
<p>Los t&eacute;rminos constantes no se transforman a polinomios a menos que el
n&uacute;mero uno se introduzca en la lista de variables:
</p>
<pre class="example">(%i4) to_poly(x = sqrt(5),[x]);
(%o4)                [[x - sqrt(5)], [], []]
(%i5) to_poly(x = sqrt(5),[1,x]);
                            2
(%o5) [[x - %g132, 5 = %g132 ], 
                      %pi                               %pi
                   [- --- &lt; parg(%g132), parg(%g132) &lt;= ---], []]
                       2                                 2
</pre>
<p>Para generar un polinomio que tenga <em>sqrt(5) + sqrt(7)</em> como
ra&iacute;z puede hacerse lo siguiente:
</p>
<pre class="example">(%i6) first(elim_allbut(first(to_poly(x = sqrt(5) + sqrt(7),
                                      [1,x])), [x]));
                          4       2
(%o6)                   [x  - 24 x  + 4]
</pre>
<p>Para hacer uso de esta funci&oacute;n, ejec&uacute;tese <code>load(to_poly)</code>.
</p>
<p>V&eacute;ase tambi&eacute;n <code>to_poly_solve</code>.
</p>
</dd></dl>






<dl>
<dt><u>Funci&oacute;n:</u> <b>to_poly_solve</b><i> (<var>e</var>, <var>l</var>, [options])</i>
<a name="IDX2758"></a>
</dt>
<dd><p>La funci&oacute;n <code>to_poly_solve</code> intenta resolver las ecuaciones <var>e</var>
de inc&oacute;gnitas <var>l</var>. El argumento <var>e</var> puede ser una &uacute;nica ecuaci&oacute;n,
o una lista o conjunto de ecuaciones; de forma similar, <var>l</var> puede ser un
s&iacute;mbolo o una lista o conjunto de s&iacute;mbolos. Cuando
uno de los elementos de <var>e</var> no sea una igualdad, como <em>x^2 -1</em>,
se supodr&aacute; que es igual a cero.
</p>
<p>La estrategia b&aacute;sica de <code>to_poly_solve</code> consiste en utilizar
<code>to_poly</code> para convertir la entrada a su forma polinomial e invocar
posteriormente <code>algsys</code>. As&iacute;, las variables opcionales
que afectan a <code>algsys</code>, especialmente <code>algexact</code>, tambi&eacute;n
afectan a <code>to_poly_solve</code>. El valor por defecto de <code>algexact</code> es
<code>false</code>, pero para <code>to_poly_solve</code> se recomienda que tome el 
valor <code>true</code>. La funci&oacute;n <code>to_poly_solve</code> no asigna localmente
a <code>algexact</code> el valor <code>true</code>, lo que imposibilitar&iacute;a
encontrar soluciones aproximadas cuando <code>algsys</code> sea incapaz de encontrar
las exactas.
</p>
<p>Cuando <code>to_poly_solve</code> consigue determinar el conjunto de soluciones, cada
miembro del conjunto de soluciones es una lista en un objeto  <code>%union</code>:
</p>
<pre class="example">(%i1) load(to_poly_solve)$

(%i2) to_poly_solve(x*(x-1) = 0, x);
(%o2)               %union([x = 0], [x = 1])
</pre>
<p>Cuando <code>to_poly_solve</code> es incapaz de determinar el conjunto de soluciones,
devuelve una forma nominal de <code>%solve</code> y muestra un mensaje de aviso:
</p>
<pre class="example">(%i3) to_poly_solve(x^k + 2* x + 1 = 0, x);

Nonalgebraic argument given to 'to_poly'
unable to solve
                          k
(%o3)            %solve([x  + 2 x + 1 = 0], [x])
</pre>
<p>A veces se puede obtener la soluci&oacute;n haciendo una sustituci&oacute;n en <code>%solve</code>:
</p>
<pre class="example">(%i4) subst(k = 2, %);
(%o4)                   %union([x = - 1])
</pre>
<p>Especialmente en el caso de las funciones trigonom&eacute;tricas, los resultados pueden
incorporar n&uacute;meros enteros arbitrarios de la forma <code>%zXXX</code>, siendo <code>XXX</code>
un &iacute;ndice entero:
</p>
<pre class="example">(%i5) to_poly_solve(sin(x) = 0, x);
(%o5)   %union([x = 2 %pi %z33 + %pi], [x = 2 %pi %z35])
</pre>
<p>Para inicializar los &iacute;ndices, h&aacute;gase uso de <code>nicedummies</code>:
</p>
<pre class="example">(%i6) nicedummies(%);
(%o6)    %union([x = 2 %pi %z0 + %pi], [x = 2 %pi %z1])
</pre>
<p>En ocasiones, se introducen n&uacute;meros complejos arbitrarios de la forma
<code>%cXXX</code>, o reales de la forma <code>%rXXX</code>. La funci&oacute;n <code>nicedummies</code>
inicializa estos identificadores a cero.
</p>
<p>Tambi&eacute;n a veces, la soluci&oacute;n incorpora versiones simplificadas de los
operadores l&oacute;gicos <code>%and</code>, <code>%or</code> y <code>%if</code>, que representan, respectivamente,
la conjunci&oacute;n, la disyunci&oacute;n y la implicaci&oacute;n:
</p>
<pre class="example">(%i7) sol : to_poly_solve(abs(x) = a, x);
(%o7) %union(%if(isnonnegative_p(a), [x = - a], %union()), 
                      %if(isnonnegative_p(a), [x = a], %union()))
(%i8) subst(a = 42, sol);
(%o8)             %union([x = - 42], [x = 42])
(%i9) subst(a = -42, sol);
(%o9)                       %union()
</pre>
<p>El conjunto vac&iacute;o se representa por <code>%union</code>.
</p>
<p>La funci&oacute;n <code>to_poly_solve</code> es capaz de resolver algunas ecuaciones
con potencias racionales, potencias no racionales, valores absolutos, funciones
trigonom&eacute;tricas y funciones del m&iacute;nimo y del m&aacute;ximo. 
Tambi&eacute;n puede resolver algunas ecuaciones resolubles en t&eacute;rminos de la
funci&oacute;n W de Lambert:
</p>
<pre class="example">(%i1) load(to_poly_solve)$

(%i2) to_poly_solve(set(max(x,y) = 5, x+y = 2), set(x,y));
(%o2)      %union([x = - 3, y = 5], [x = 5, y = - 3])
(%i3) to_poly_solve(abs(1-abs(1-x)) = 10,x);
(%o3)             %union([x = - 10], [x = 12])
(%i4) to_poly_solve(set(sqrt(x) + sqrt(y) = 5, x + y = 10),
                    set(x,y));
                     3/2               3/2
                    5    %i - 10      5    %i + 10
(%o4) %union([x = - ------------, y = ------------], 
                         2                 2
                                3/2                 3/2
                               5    %i + 10        5    %i - 10
                          [x = ------------, y = - ------------])
                                    2                   2
(%i5) to_poly_solve(cos(x) * sin(x) = 1/2,x,
                    'simpfuncs = ['expand, 'nicedummies]);
                                         %pi
(%o5)              %union([x = %pi %z0 + ---])
                                          4
(%i6) to_poly_solve(x^(2*a) + x^a + 1,x);
                                        2 %i %pi %z81
                                        -------------
                                  1/a         a
                  (sqrt(3) %i - 1)    %e
(%o6) %union([x = -----------------------------------], 
                                  1/a
                                 2
                                                  2 %i %pi %z83
                                                  -------------
                                            1/a         a
                          (- sqrt(3) %i - 1)    %e
                     [x = -------------------------------------])
                                           1/a
                                          2
(%i7) to_poly_solve(x * exp(x) = a, x);
(%o7)              %union([x = lambert_w(a)])
</pre>
<p>En el caso de inecuaciones lineales, <code>to_poly_solve</code> aplica autom&aacute;ticamente
la eliminaci&oacute;n de Fourier:
</p>
<pre class="example">(%i8) to_poly_solve([x + y &lt; 1, x - y &gt;= 8], [x,y]);
                               7
(%o8) %union([x = y + 8, y &lt; - -], 
                               2
                                                              7
                                 [y + 8 &lt; x, x &lt; 1 - y, y &lt; - -])
                                                              2
</pre>
<p>Los argumentos opcionales deben tener forma de ecuaci&oacute;n; generalmente, el orden
de estas opciones no reviste importancia.
</p>
<ul class="toc">
<li> <code>simpfuncs = l</code>, siendo <code>l</code> una lista de funciones,
aplica la composici&oacute;n de los elementos de <code>l</code> a cada soluci&oacute;n:
<pre class="example">(%i1) to_poly_solve(x^2=%i,x);
                               1/4             1/4
(%o1)       %union([x = - (- 1)   ], [x = (- 1)   ])
(%i2) to_poly_solve(x^2= %i,x, 'simpfuncs = ['rectform]);
                      %i         1             %i         1
(%o2) %union([x = - ------- - -------], [x = ------- + -------])
                    sqrt(2)   sqrt(2)        sqrt(2)   sqrt(2)
</pre>
<p>A veces, una simplificaci&oacute;n puede anular una simplificaci&oacute;n anterior:
</p><pre class="example">(%i3) to_poly_solve(x^2=1,x);
(%o3)              %union([x = - 1], [x = 1])
(%i4) to_poly_solve(x^2= 1,x, 'simpfuncs = [polarform]);
                                        %i %pi
(%o4)            %union([x = 1], [x = %e      ]
</pre>
<p>Maxima no comprueba que los elementos de la lista de funciones <code>l</code> sean
todos simplificaciones:
</p><pre class="example">(%i5) to_poly_solve(x^2 = %i,x, 'simpfuncs = [lambda([s],s^2)]);
(%o5)                   %union([x = %i])
</pre>
<p>Para convertir cada soluci&oacute;n a real de doble precisi&oacute;n h&aacute;gase uso de
<code>simpfunc = ['dfloat]</code>:
</p><pre class="example">(%i6) to_poly_solve(x^3 +x + 1 = 0,x, 
                    'simpfuncs = ['dfloat]), algexact : true;
(%o6) %union([x = - .6823278038280178], 
[x = .3411639019140089 - 1.161541399997251 %i], 
[x = 1.161541399997251 %i + .3411639019140089])
</pre>
</li><li> Con la opci&oacute;n <code>use_grobner = true</code> se aplica la funci&oacute;n 
<code>poly_reduced_grobner</code> a las ecuaciones antes de intentar resolverlas.
En primer lugar, esta opci&oacute;n proporciona una manera de soslayar algunas
debilidades de la funci&oacute;n <code>algsys</code>:

<pre class="example">(%i7) to_poly_solve([x^2+y^2=2^2,(x-1)^2+(y-1)^2=2^2],[x,y],
                    'use_grobner = true);
                    sqrt(7) - 1      sqrt(7) + 1
(%o7) %union([x = - -----------, y = -----------], 
                         2                2
                                 sqrt(7) + 1        sqrt(7) - 1
                            [x = -----------, y = - -----------])
                                      2                  2
(%i8) to_poly_solve([x^2+y^2=2^2,(x-1)^2+(y-1)^2=2^2],[x,y]);
(%o8)                       %union()
</pre>
</li><li> <code>maxdepth = k</code>, siendo <code>k</code> un positivo entero, controla el nivel
de recursi&oacute;n. El valor por defecto es cinco. Cuando se excede el nivel de recursi&oacute;n
se obtiene un mensaje de error:
<pre class="example">(%i9) to_poly_solve(cos(x) = x,x, 'maxdepth = 2);

Unable to solve
Unable to solve
(%o9)        %solve([cos(x) = x], [x], maxdepth = 2)
</pre>
</li><li> Con <code>parameters = l</code>, siendo <code>l</code> una lista de s&iacute;mbolos,
el programa intenta encontrar una soluci&oacute;n v&aacute;lida para todos los miembros de la
lista <code>l</code>:
<pre class="example">(%i10) to_poly_solve(a * x = x, x);
(%o10)                   %union([x = 0])
(%i11) to_poly_solve(a * x = x, x, 'parameters = [a]);
(%o11) %union(%if(a - 1 = 0, [x = %c111], %union()), 
                               %if(a - 1 # 0, [x = 0], %union()))
</pre><p>En <code>(%o2)</code>, el programa introduce una variable ficticia; para reinicializarla,
&uacute;sese la funci&oacute;n <code>nicedummies</code>:
</p><pre class="example">(%i12) nicedummies(%);
(%o12) %union(%if(a - 1 = 0, [x = %c0], %union()), 
                               %if(a - 1 # 0, [x = 0], %union()))
</pre></li></ul>

<p><code>to_poly_solve</code> utiliza informaci&oacute;n almacenada en el array <code>one_to_one_reduce</code>
para resolver ecuaciones de la forma  <em>f(a) = f(b)</em>. La asignaci&oacute;n 
<code>one_to_one_reduce['f,'f] : lambda([a,b], a=b)</code> le dice a <code>to_poly_solve</code>
que el conjunto de soluciones de <em>f(a) = f(b)</em> es igual al conjunto de soluciones
de <em>a=b</em>:
</p><pre class="example">(%i13) one_to_one_reduce['f,'f] : lambda([a,b], a=b)$

(%i14) to_poly_solve(f(x^2-1) = f(0),x);
(%o14)             %union([x = - 1], [x = 1])
</pre>
<p>De forma m&aacute;s general, la asignaci&oacute;n 
<code>one_to_one_reduce['f,'g] : lambda([a,b], w(a,b)=0</code> le indica a
<code>to_poly_solve</code> que el cojunto de soluciones de <em>f(a) = f(b)</em> 
es igual al conjunto de soluciones de <em>w(a,b) = 0</em>:
</p><pre class="example">(%i15) one_to_one_reduce['f,'g] : lambda([a,b], a = 1 + b/2)$

(%i16) to_poly_solve(f(x) - g(x),x);
(%o16)                   %union([x = 2])
</pre>
<p>Adem&aacute;s, <code>to_poly_solve</code> utiliza informaci&oacute;n almacenada en el array
<code>function_inverse</code> para resolver ecuaciones de la forma <em>f(a) = b</em>.
La asignaci&oacute;n <code>function_inverse['f] : lambda([s], g(s))</code> le dice a
<code>to_poly_solve</code> que el conjunto de soluciones de <em>f(x) = b</em> es
igual al conjunto de soluciones de <em>x = g(b)</em>:
</p><pre class="example">(%i17) function_inverse['Q] : lambda([s], P(s))$

(%i18) to_poly_solve(Q(x-1) = 2009,x);
(%o18)              %union([x = P(2009) + 1])
(%i19) function_inverse['G] : lambda([s], s+new_variable(integer));
(%o19)       lambda([s], s + new_variable(integer))
(%i20) to_poly_solve(G(x - a) = b,x);
(%o20)             %union([x = b + a + %z125])
</pre>
<p><b>Notas</b>
</p>
<ul class="toc">
<li> Las inc&oacute;gnitas a resolver no necesitan ser s&iacute;mbolos, lo cual es
cierto cuando <code>fullratsubst</code> es capaz de hacer las sustituciones de forma apropiadas:
<pre class="example">(%i1) to_poly_solve([x^2 + y^2 + x * y = 5, x * y = 8],
                    [x^2 + y^2, x * y]);
                                  2    2
(%o1)           %union([x y = 8, y  + x  = - 3])
</pre>
</li><li> Cuando las ecuaciones involucran conjugados de complejos, el programa
a&ntilde;ade autom&aacute;ticamente las ecuaciones conjugadas:
<pre class="example">(%i1) declare(x,complex)$

(%i2) to_poly_solve(x + (5 + %i) * conjugate(x) = 1, x);
                                   %i + 21
(%o2)              %union([x = - -----------])
                                 25 %i - 125
(%i3) declare(y,complex)$

(%i4) to_poly_solve(set(conjugate(x) - y = 42 + %i,
                        x + conjugate(y) = 0), set(x,y));
                           %i - 42        %i + 42
(%o4)        %union([x = - -------, y = - -------])
                              2              2
</pre>
</li><li> Cuando las funciones involucran valores absolutos, <code>to_poly_solve</code>
consulta los hechos de la base de datos para decidir si los argumentos de los valores
absolutos son n&uacute;meros complejos:
<pre class="example">(%i1) to_poly_solve(abs(x) = 6, x);
(%o1)              %union([x = - 6], [x = 6])
(%i2) declare(z,complex)$

(%i3) to_poly_solve(abs(z) = 6, z);
(%o3) %union(%if((%c11 # 0) %and (%c11 conjugate(%c11) - 36 = 
                                       0), [z = %c11], %union()))
</pre>
<p>Esta es la &uacute;nica situaci&oacute;n en la que <code>to_poly_solve</code> consulta la base de
datos; si una inc&oacute;gnita se declara, por ejemplo, como entero, <code>to_poly_solve</code> lo ignora.
</p></li></ul>

<p>Para hacer uso de esta funci&oacute;n, ejec&uacute;tese <code>load(to_poly_solve)</code>.
</p>
<p>V&eacute;ase tambi&eacute;n <code>algexact</code>, <code>resultant</code>, <code>algebraic</code> y <code>to_poly</code>.
</p>
</dd></dl>

<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC365" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC367" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Robert</em> on <em>diciembre, 10 2012</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
