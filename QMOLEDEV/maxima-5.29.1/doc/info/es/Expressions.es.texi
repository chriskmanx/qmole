@c English version 2011-09-03
@menu
* Introducci@'on a las expresiones::
* Nombres y verbos::
* Identificadores::
* Desigualdades::
* Funciones y variables para expresiones::
@end menu

@node Introducci@'on a las expresiones, Nombres y verbos, Expresiones, Expresiones
@section Introducci@'on a las expresiones

Existe un cierto n@'umero de palabras reservadas
que no deber@'{@dotless{i}}an
utilizarse como nombres de variables. Su uso podr@'{@dotless{i}}a causar 
errores sint@'acticos. 

@example
integrate            next           from                 diff            
in                   at             limit                sum             
for                  and            elseif               then            
else                 do             or                   if              
unless               product        while                thru            
step                                                                     
@end example

La mayor@'{@dotless{i}}a de los objetos en Maxima son expresiones. Una secuencia
de expresiones puede constituir una expresi@'on, separ@'andolas por
comas y colocando par@'entesis alrededor de ellas. Esto es similar a 
las @i{expresiones con coma} en @b{C}. 

@example
(%i1) x: 3$
(%i2) (x: x+1, x: x^2);
(%o2)                          16
(%i3) (if (x > 17) then 2 else 4);
(%o3)                           4
(%i4) (if (x > 17) then x: 2 else y: 4, y+x);
(%o4)                          20
@end example

Incluso los bucles en Maxima son expresiones, aunque el valor que
 retornan (@code{done}) no es muy @'util. 

@example
(%i1) y: (x: 1, for i from 1 thru 10 do (x: x*i))$
(%i2) y;
(%o2)                         done
@end example

pero quiz@'as se quiera incluir un tercer t@'ermino en la @i{expresi@'on con coma} para que devuelva el valor de inter@'es. 

@example
(%i3) y: (x: 1, for i from 1 thru 10 do (x: x*i), x)$
(%i4) y;
(%o4)                        3628800
@end example










@node Nombres y verbos, Identificadores, Introducci@'on a las expresiones, Expresiones
@section Nombres y verbos

Maxima distingue entre operadores que son "nombres" y operadores que son "verbos".
Un verbo es un operador que puede ser ejecutado.
Un nombre es un operador que aparece como un s@'{@dotless{i}}mbolo en una expresi@'on pero sin ser ejecutado.
Por defecto, los nombres de funciones son verbos.
Un verbo puede transformarse en nombre utilizando el ap@'ostrofo o aplicando la funci@'on @code{nounify}.
Un nombre puede transformarse en verbo aplicando la funci@'on @code{verbify}.
La variable @code{nouns} hace que @code{ev} eval@'ue los nombres presentes en una expresi@'on.

La forma verbal se distingue mediante la precedencia del car@'acter d@'olar @code{$} al correspondiente s@'{@dotless{i}}mbolo de Lisp.
Por otro lado, la forma nominal se distingue mediante la precedencia del car@'acter porcentaje @code{%} al correspondiente s@'{@dotless{i}}mbolo de Lisp. 
Algunos nombres gozan de propiedades especiales para su representaci@'on, como @code{'integrate} o @code{'derivative}
(devuelto por @code{diff}), pero la mayor@'{@dotless{i}}a no.
Por defecto, las formas nominal y verbal de una funci@'on son id@'enticas cuando se muestran en un terminal.
La variable global @code{noundisp} hace que Maxima muestre los nombres precedidos del ap@'ostrofo @code{'}.

V@'eanse tambi@'en @code{noun}, @code{nouns}, @code{nounify} y @code{verbify}.

Ejemplos:

@c ===beg===
@c foo (x) := x^2;
@c foo (42);
@c 'foo (42);
@c 'foo (42), nouns;
@c declare (bar, noun);
@c bar (x) := x/17;
@c bar (52);
@c bar (52), nouns;
@c integrate (1/x, x, 1, 42);
@c 'integrate (1/x, x, 1, 42);
@c ev (%, nouns);
@c ===end===
@example
(%i1) foo (x) := x^2;
                                     2
(%o1)                     foo(x) := x
(%i2) foo (42);
(%o2)                         1764
(%i3) 'foo (42);
(%o3)                        foo(42)
(%i4) 'foo (42), nouns;
(%o4)                         1764
(%i5) declare (bar, noun);
(%o5)                         done
(%i6) bar (x) := x/17;
                                     x
(%o6)                    ''bar(x) := --
                                     17
(%i7) bar (52);
(%o7)                        bar(52)
(%i8) bar (52), nouns;
                               52
(%o8)                          --
                               17
(%i9) integrate (1/x, x, 1, 42);
(%o9)                        log(42)
(%i10) 'integrate (1/x, x, 1, 42);
                             42
                            /
                            [   1
(%o10)                      I   - dx
                            ]   x
                            /
                             1
(%i11) ev (%, nouns);
(%o11)                       log(42)
@end example








@node Identificadores, Desigualdades, Nombres y verbos, Expresiones
@section Identificadores


En Maxima, los identificadores pueden contener caracteres alfab@'eticos, n@'umeros del 0 al 9 y cualquier otro car@'acter precedido de la barra invertida @code{\}.

Un identificador puede comenzar con un car@'acter num@'erico si @'este va precedido de la barra invertida @code{\}.
Los caracteres num@'ericos que ocupen la segunda posici@'on o posterior no necesitan ir precedidos de la barra invertida.

Los caracteres pueden declararse como alfab@'eticos con la funci@'on @code{declare}.
As@'{@dotless{i}} declarados, no necesitan ir precedidos de la barra invertida en un identificador.
En principio, los caracteres alfab@'eticos son las letras de @code{A} a @code{Z} y
@code{a} a @code{z}, junto con  @code{%} y @code{_}.

Maxima distingue min@'usculas y may@'usculas. Los identificadores @code{foo}, @code{FOO} y @code{Foo} son distintos.
V@'ease @ref{Lisp y Maxima} para m@'as informaci@'on.

Un identificador en Maxima es un s@'{@dotless{i}}mbolo Lisp que comienza con el s@'{@dotless{i}}mbolo d@'olar @code{$}.
Cualquier otro s@'{@dotless{i}}mbolo de Lisp va precedido de la interrogaci@'on @code{?} cuando aparece en Maxima.
V@'ease @ref{Lisp y Maxima} para m@'as informaci@'on.

Ejemplos:

@c ===beg===
@c %an_ordinary_identifier42;
@c embedded\ spaces\ in\ an\ identifier;
@c symbolp (%);
@c [foo+bar, foo\+bar];
@c [1729, \1729];
@c [symbolp (foo\+bar), symbolp (\1729)];
@c [is (foo\+bar = foo+bar), is (\1729 = 1729)];
@c baz\~quux;
@c declare ("~", alphabetic);
@c baz~quux;
@c [is (foo = FOO), is (FOO = Foo), is (Foo = foo)];
@c :lisp (defvar *my-lisp-variable* '$foo)
@c ?\*my\-lisp\-variable\*;
@c ===end===

@example
(%i1) %an_ordinary_identifier42;
(%o1)               %an_ordinary_identifier42
(%i2) embedded\ spaces\ in\ an\ identifier;
(%o2)           embedded spaces in an identifier
(%i3) symbolp (%);
(%o3)                         true
(%i4) [foo+bar, foo\+bar];
(%o4)                 [foo + bar, foo+bar]
(%i5) [1729, \1729];
(%o5)                     [1729, 1729]
(%i6) [symbolp (foo\+bar), symbolp (\1729)];
(%o6)                     [true, true]
(%i7) [is (foo\+bar = foo+bar), is (\1729 = 1729)];
(%o7)                    [false, false]
(%i8) baz\~quux;
(%o8)                       baz~quux
(%i9) declare ("~", alphabetic);
(%o9)                         done
(%i10) baz~quux;
(%o10)                      baz~quux
(%i11) [is (foo = FOO), is (FOO = Foo), is (Foo = foo)];
(%o11)                [false, false, false]
(%i12) :lisp (defvar *my-lisp-variable* '$foo)
*MY-LISP-VARIABLE*
(%i12) ?\*my\-lisp\-variable\*;
(%o12)                         foo
@end example









@node Desigualdades, Funciones y variables para expresiones, Identificadores, Expresiones
@section Desigualdades


Maxima dispone de los operadores de desigualdad @code{<}, @code{<=}, @code{>=}, @code{>}, @code{#} y @code{notequal}.
V@'ease @code{if} para una descripci@'on de las expresiones condicionales.







@node Funciones y variables para expresiones,  , Desigualdades, Expresiones
@section Funciones y variables para expresiones


@deffn {Funci@'on} alias (@var{new_name_1}, @var{old_name_1}, ..., @var{new_name_n}, @var{old_name_n})
provee un nombre
alternativo para una (bien sea definida por el usuario o por el sistema) funci@'on, variable, arreglo, etc. 
Cualquier n@'umero par de argumentos puede ser usado. 
@end deffn


@defvr {Variable del sistema} aliases
Valor por defecto: @code{[]}

La variable @code{aliases} es la lista de @'atomos que tienen un "alias" definido por el usuario (establecido mediante las funciones  @code{alias}, @code{ordergreat} o @code{orderless} o declarando el @'atomo como un @code{noun} (nombre) con @code{declare}.
@end defvr



@defvr {Clave} allbut
Opera con los comandos @code{part} (como @code{part}, @code{inpart}, @code{substpart},
@code{substinpart}, @code{dpart} y @code{lpart}). Por ejemplo:

@c ===beg===
@c expr : e + d + c + b + a;
@c part (expr, [2, 5]);
@c ===end===
@example
(%i1) expr : e + d + c + b + a;
(%o1)                   e + d + c + b + a
(%i2) part (expr, [2, 5]);
(%o2)                         d + a
@end example

mientras que: 

@c ===beg===
@c expr : e + d + c + b + a;
@c part (expr, allbut (2, 5));
@c ===end===
@example
(%i1) expr : e + d + c + b + a;
(%o1)                   e + d + c + b + a
(%i2) part (expr, allbut (2, 5));
(%o2)                       e + c + b
@end example

La funci@'on @code{kill} tambi@'en reconoce a @code{allbut}.

@c ===beg===
@c [aa : 11, bb : 22, cc : 33, dd : 44, ee : 55];
@c kill (allbut (cc, dd));
@c [aa, bb, cc, dd];
@c ===end===
@example
(%i1) [aa : 11, bb : 22, cc : 33, dd : 44, ee : 55];
(%o1)                 [11, 22, 33, 44, 55]
(%i2) kill (allbut (cc, dd));
(%o0)                         done
(%i1) [aa, bb, cc, dd];
(%o1)                   [aa, bb, 33, 44]
@end example

La sentencia @code{kill(allbut(@var{a_1}, @var{a_2}, ...))}
tiene el mismo efecto que @code{kill(all)}, excepto que no
elimina los s@'{@dotless{i}}mbolos @var{a_1}, @var{a_2}, ... .

@end defvr



@deffn {Funci@'on} args (@var{expr})

Devuelve la lista de argumentos de @code{expr}, que puede ser cualquier tipo de expresi@'on a excepci@'on de un @'atomo. Tan solo se muestran los argumentos del operador principal; subexpresiones de @code{expr} aparecen como elementos o subexpresiones de elementos de la lista de argumentos.

El orden de los miembros de la lista puede depender de la variable global @code{inflag}.

La llamada @code{args (@var{expr})} es equivalente a @code{substpart ("[", @var{expr}, 0)}.

V@'eanse tambi@'en @code{substpart} y @code{op}.

@end deffn



@deffn {Funci@'on} atom (@var{expr})

Devuelve @code{true} si @var{expr} es un @'atomo (n@'umero, nombre o cadena alfanum@'erica) y @code{false} en caso contario. As@'{@dotless{i}}, @code{atom(5)} devolver@'a @code{true}, mientras que @code{atom(a[1])} y @code{atom(sin(x))} dar@'an como resultado @code{false} (dando por hecho que tanto @code{a[1]} como @code{x} no tienen valores asignados).

@end deffn



@deffn {Funci@'on} box (@var{expr})
@deffnx {Funci@'on} box (@var{expr}, @var{a})
Devuelve @var{expr} encerrada en una caja.
El valor devuelto es una expresi@'on con @code{box} como operador y @var{expr} como argumento.
Se dibujar@'a una caja cuando @code{display2d} valga @code{true}.

La llamada @code{box (@var{expr}, @var{a})}
encierra @var{expr} en una caja etiquetada con el s@'{@dotless{i}}mbolo @var{a}.
La etiqueta se recorta si es m@'as larga que el ancho de la caja.

La funci@'on @code{box} eval@'ua su argumento. Sin embargo, la expresi@'on 
encerrada no se eval@'ua, siendo exclu@'{@dotless{i}}da de los c@'alculos.

La variable @code{boxchar} guarda el car@'acter a utilizar para dibujar la caja en las funciones @code{box}, @code{dpart} y @code{lpart}.

Ejemplos:

@c ===beg===
@c box (a^2 + b^2);
@c a : 1234;
@c b : c - d;
@c box (a^2 + b^2);
@c box (a^2 + b^2, term_1);
@c 1729 - box (1729);
@c boxchar: "-";
@c box (sin(x) + cos(y));
@c ===end===
@example
(%i1) box (a^2 + b^2);
                            """""""""
                            " 2    2"
(%o1)                       "b  + a "
                            """""""""
(%i2) a : 1234;
(%o2)                         1234
(%i3) b : c - d;
(%o3)                         c - d
(%i4) box (a^2 + b^2);
                      """"""""""""""""""""
                      "       2          "
(%o4)                 "(c - d)  + 1522756"
                      """"""""""""""""""""
(%i5) box (a^2 + b^2, term_1);
                      term_1""""""""""""""
                      "       2          "
(%o5)                 "(c - d)  + 1522756"
                      """"""""""""""""""""
(%i6) 1729 - box (1729);
                                 """"""
(%o6)                     1729 - "1729"
                                 """"""
(%i7) boxchar: "-";
(%o7)                           -
(%i8) box (sin(x) + cos(y));
                        -----------------
(%o8)                   -cos(y) + sin(x)-
                        -----------------
@end example

@end deffn



@defvr {Variable opcional} boxchar
Valor por defecto: @code{"}

La variable @code{boxchar} guarda el car@'acter a utilizar para dibujar la caja en las funciones @code{box}, @code{dpart} y @code{lpart}.

Todas las cajas en una expresi@'on se dibujan con el valor actual de @code{boxchar}, car@'acter que no se almacena con las expresi@'on encerrada.

@end defvr



@deffn {Funci@'on} collapse (@var{expr})

Colapsa @var{expr} haciendo que todas las subexpresiones que sean iguales
compartan las mismas celdas, ahorrando espacio. @code{collapse} es una
subrutina utilizada por la instrucci@'on @code{optimize}. El uso de 
@code{collapse} puede ser @'util despu@'es de  cargar un fichero 
creado con @code{save}. Se pueden colapsar varias expresiones de forma
conjunta utilizando @code{collapse ([@var{expr_1}, ..., @var{expr_n}])}.
Tambi@'en se pueden colapsar los elementos del array @code{A}
haciendo @code{collapse (listarray ('A))}.
@end deffn




@deffn {Funci@'on} disolate (@var{expr}, @var{x_1}, ..., @var{x_n})
Es similar a @code{isolate (@var{expr}, @var{x})}, excepto que permite al usuario aislar m@'as de una variable simult@'aneamente. Puede ser @'util para hacer un cambio de variables en integrales m@'ultiples en las que tales variables dependan de de dos o m@'as variables de integraci@'on.  Esta funci@'on se carga autom@'aticamente desde 
@file{simplification/disol.mac}.  Se dispone de una demostyraci@'on en @code{demo("disol")$}.

@end deffn

@deffn {Funci@'on} dispform (@var{expr})
@deffnx {Function} dispform (@var{expr}, all)

@code{dispform(@var{expr})} devuelve la representaci@'on externa de
@var{expr} respecto del operador del nivel superior.
@code{dispform(@var{expr}, all)} devuelve la representaci@'on
externa respecto de todos los operadores que haya en @var{expr}.

V@'ease tambi@'en @code{part}, @code{inpart} y @code{inflag}.

Ejemplos:

La representaci@'on interna de @code{- x} es "menos uno 
multiplicado por @code{x}", mientras que la representaci@'on externa es
"menos @code{x}".

@c ===beg===
@c - x;
@c ?format (true, "~S~%", %);
@c dispform (- x);
@c ?format (true, "~S~%", %);
@c ===end===
@example
(%i1) - x;
(%o1)                          - x
(%i2) ?format (true, "~S~%", %);
((MTIMES SIMP) -1 $X)
(%o2)                         false
(%i3) dispform (- x);
(%o3)                          - x
(%i4) ?format (true, "~S~%", %);
((MMINUS SIMP) $X)
(%o4)                         false
@end example

La representaci@'on interna de @code{sqrt(x)} es 
"@code{x} elevado a 1/2", mientras que su representaci@'on
externa es "ra@'{@dotless{i}}z de @code{x}".

@c ===beg===
@c sqrt (x);
@c ?format (true, "~S~%", %);
@c dispform (sqrt (x));
@c ?format (true, "~S~%", %);
@c ===end===
@example
(%i1) sqrt (x);
(%o1)                        sqrt(x)
(%i2) ?format (true, "~S~%", %);
((MEXPT SIMP) $X ((RAT SIMP) 1 2))
(%o2)                         false
(%i3) dispform (sqrt (x));
(%o3)                        sqrt(x)
(%i4) ?format (true, "~S~%", %);
((%SQRT SIMP) $X)
(%o4)                         false
@end example

Utilizaci@'on del argumento opcional @code{all}.

@c ===beg===
@c expr : sin (sqrt (x));
@c freeof (sqrt, expr);
@c freeof (sqrt, dispform (expr));
@c freeof (sqrt, dispform (expr, all));
@c ===end===
@example
(%i1) expr : sin (sqrt (x));
(%o1)                     sin(sqrt(x))
(%i2) freeof (sqrt, expr);
(%o2)                         true
(%i3) freeof (sqrt, dispform (expr));
(%o3)                         true
(%i4) freeof (sqrt, dispform (expr, all));
(%o4)                         false
@end example
@end deffn



@deffn {Funci@'on} dpart (@var{expr}, @var{n_1}, ..., @var{n_k})
Selecciona la misma expresi@'on que @code{part}, pero en lugar de devolver esa expresi@'on como su valor, devuelve la expresi@'on completa con la subexpresi@'on seleccionada dentro de una caja. La caja es parte de la expresi@'on.

@example
(%i1) dpart (x+y/z^2, 1, 2, 1);
                             y
(%o1)                       ---- + x
                               2
                            """
                            "z"
                            """
@end example
@end deffn



@defvr {Variable opcional} exptisolate
Valor por defecto: @code{false}

V@'ease @code{isolate}.

@end defvr



@defvr {Variable opcional} exptsubst
Valor por defecto: @code{false}

Si @code{exptsubst} vale @code{true} permite la sustituci@'on @code{y} por @code{%e^x} en @code{%e^(a x)}.

@c NEED EXAMPLES HERE
@end defvr




@deffn {Funci@'on} freeof (@var{x_1}, ..., @var{x_n}, @var{expr})

@code{freeof (@var{x_1}, @var{expr})}
devuelve @code{true} si ninguna subexpresi@'on de @var{expr} coincide con @var{x_1},
o si @var{x_1} aparece como variable muda en @var{expr}, o si @var{x_1} no es ni
una forma nominal ni verbal de cualesquiera operadores presentes en @var{expr},
devolviendo @code{false} en otro caso.

La llamada @code{freeof (@var{x_1}, ..., @var{x_n}, @var{expr})}
equivale a @code{freeof (@var{x_1}, @var{expr}) and ... and freeof (@var{x_n}, @var{expr})}.

Los argumentos @var{x_1}, ..., @var{x_n} 
pueden seer nombres de funciones y variables, nombres subindicados,
operadores (encerrados entre comillas dobles) o expresiones generales.

La funci@'on @code{freeof} eval@'ua sus argumentos.

Una variable es una variable muda en una expresi@'on si no tiene valor asignado fuera de la expresi@'on.
Variable mudas reconocidas por  @code{freeof} son el @'{@dotless{i}}ndice de una suma o producto, la variable l@'{@dotless{i}}mite en @code{limit},
la variable de integraci@'on en la versi@'on de integral definida de @code{integrate},
la variable original en @code{laplace},
variables formales en expresiones @code{at} y
los argumentos de las expresiones  @code{lambda}.

La versi@'on indefinida de  @code{integrate} no est@'a libre de su variable de integraci@'on.

Ejemplos:

Los argumentos son nombres de funciones, variables, nombres subindicados, operaores y expresiones. La llamada @code{freeof (a, b, expr)} equivale a @code{freeof (a, expr) and freeof (b, expr)}.

@example
(%i1) expr: z^3 * cos (a[1]) * b^(c+d);
                                 d + c  3
(%o1)                   cos(a ) b      z
                             1
(%i2) freeof (z, expr);
(%o2)                         false
(%i3) freeof (cos, expr);
(%o3)                         false
(%i4) freeof (a[1], expr);
(%o4)                         false
(%i5) freeof (cos (a[1]), expr);
(%o5)                         false
(%i6) freeof (b^(c+d), expr);
(%o6)                         false
(%i7) freeof ("^", expr);
(%o7)                         false
(%i8) freeof (w, sin, a[2], sin (a[2]), b*(c+d), expr);
(%o8)                         true
@end example

@code{freeof} eval@'ua sus argumentos.

@example
(%i1) expr: (a+b)^5$
(%i2) c: a$
(%i3) freeof (c, expr);
(%o3)                         false
@end example

@code{freeof} no considera funciones equivalentes.
La simplificaci@'on puede dar una expresi@'on equivalente pero diferente.

@example
(%i1) expr: (a+b)^5$
(%i2) expand (expr);
          5        4       2  3       3  2      4      5
(%o2)    b  + 5 a b  + 10 a  b  + 10 a  b  + 5 a  b + a
(%i3) freeof (a+b, %);
(%o3)                         true
(%i4) freeof (a+b, expr);
(%o4)                         false
(%i5) exp (x);
                                 x
(%o5)                          %e
(%i6) freeof (exp, exp (x));
(%o6)                         true
@end example

Un sumatorio o integral definida est@'a libre de su variable muda.
Una integral indefinida de  @code{integrate} no est@'a libre de su variable de integraci@'on.

@example
(%i1) freeof (i, 'sum (f(i), i, 0, n));
(%o1)                         true
(%i2) freeof (x, 'integrate (x^2, x, 0, 1));
(%o2)                         true
(%i3) freeof (x, 'integrate (x^2, x));
(%o3)                         false
@end example
@end deffn




@defvr {Variable opcional} inflag
Valor por defecto: @code{false}

Si @code{inflag} vale @code{true}, las funciones para la extracci@'on de partes inspeccionan la forma interna de @code{expr}.

N@'otese que el simplificador reordena expresiones.
As@'{@dotless{i}},  @code{first (x + y)} devuelve @code{x} si @code{inflag}
vale @code{true} y @code{y} si @code{inflag} vale @code{false}.
(@code{first (y + x)} devuelve el mismo resultado.)

Adem@'as, d@'andole a  @code{inflag} el valor @code{true} y llamando a @code{part} o  a @code{substpart} es lo mismo que llamar a @code{inpart} o a @code{substinpart}.

Las funciones que se ven afectadas por el valor de @code{inflag} son:
@code{part}, @code{substpart}, @code{first}, @code{rest}, @code{last}, @code{length},
la construcci@'on @code{for} ... @code{in},
@code{map}, @code{fullmap}, @code{maplist}, @code{reveal} y @code{pickapart}.

@c NEED EXAMPLES HERE
@end defvr




@c NEEDS WORK
@deffn {Funci@'on} inpart (@var{expr}, @var{n_1}, ..., @var{n_k})
Similar a @code{part}, pero trabaja con la representaci@'on interna de la expresi@'on, siendo m@'as r@'apida. Se debe tener cuidado con el orden de subexpresiones en sumas y productos, pues el orden de las variables en la forma interna es normalmente diferente al que se muestra por el terminal, y cuando se trata con el signo menos unario, resta y divisi@'on, pues estos operadores desaparecen de la expresi@'on. Las llamadas @code{part (x+y, 0)} o @code{inpart (x+y, 0)} devuelven @code{+}, siendo necesario encerrar el operador entre comillas dobles cuando se haga referencia a@'el. Por ejemplo,
@code{... if inpart (%o9,0) = "+" then ...}.

Ejemplos:

@example
(%i1) x + y + w*z;
(%o1)                      w z + y + x
(%i2) inpart (%, 3, 2);
(%o2)                           z
(%i3) part (%th (2), 1, 2);
(%o3)                           z
(%i4) 'limit (f(x)^g(x+1), x, 0, minus);
                                  g(x + 1)
(%o4)                 limit   f(x)
                      x -> 0-
(%i5) inpart (%, 1, 2);
(%o5)                       g(x + 1)
@end example

@end deffn




@c NEEDS WORK
@deffn {Funci@'on} isolate (@var{expr}, @var{x})
Devuelve @var{expr} con subexpresiones que son sumas y que no contienen variables reemplazadas por etiquetas de expresiones intermedias (tales etiquetas son s@'{@dotless{i}}mbolos at@'omicos como @code{%t1}, @code{%t2}, ...).  Esta funci@'on es de utilidad para evitar la expansi@'on innecesaria de subexpresiones que no contienen la variable de inter@'es. Puesto que las etiquetas intermedias toman el valor de subexpresiones pueden ser todas sustituidas evaluando la expresi@'on en la que aparecen.

Si la variable @code{exptisolate}, cuyo valor por defecto es @code{false}, vale @code{true} har@'a que @code{isolate} busque exponentes de @'atomos (como @code{%e}) que contengan la variable.

Si @code{isolate_wrt_times} vale @code{true}, entonces @code{isolate} tambi@'en aislar@'a respecto de los productos. V@'ease @code{isolate_wrt_times}.

Para ejemplos, ejec@'utese @code{example (isolate)}.

@end deffn

@c NEEDS WORK
@defvr {Variable opcional} isolate_wrt_times
Valor por defecto: @code{false}

Si @code{isolate_wrt_times} vale @code{true}, entonces @code{isolate} tambi@'en aislar@'a respecto de los productos. Comp@'arese el comportamiento de @code{isolate} al cambiar el valor de esta variable global en el siguiente ejemplo,

@example
(%i1) isolate_wrt_times: true$
(%i2) isolate (expand ((a+b+c)^2), c);

(%t2)                          2 a


(%t3)                          2 b


                          2            2
(%t4)                    b  + 2 a b + a

                     2
(%o4)               c  + %t3 c + %t2 c + %t4
(%i4) isolate_wrt_times: false$
(%i5) isolate (expand ((a+b+c)^2), c);
                     2
(%o5)               c  + 2 b c + 2 a c + %t4
@end example

@end defvr




@c NEEDS EXAMPLES
@defvr {Variable opcional} listconstvars
Valor por defecto: @code{false}

Si @code{listconstvars} vale @code{true}, har@'a que @code{listofvars} incluya @code{%e}, @code{%pi}, @code{%i} y cualquier otra variable que sea declarada constante de las que aparezcan en el argumento de @code{listofvars}.
Estas constantes se omiten por defecto.

@end defvr

@defvr {Variable opcional} listdummyvars
Valor por defecto: @code{true}

Si @code{listdummyvars} vale @code{false}, las "variables mudas" de la expresi@'on no ser@'an inclu@'{@dotless{i}}das en la lista devuelta por @code{listofvars}. (La definici@'on de "variables mudas" se encuentra en la descripci@'on de @code{freeof}.
"Variables mudas" son objetos matem@'aticos como el @'{@dotless{i}}ndice de un sumatorio o producto, una variable l@'{@dotless{i}}mite o la variable de una integraci@'on definida.)
Ejemplo:

@example
(%i1) listdummyvars: true$
(%i2) listofvars ('sum(f(i), i, 0, n));
(%o2)                        [i, n]
(%i3) listdummyvars: false$
(%i4) listofvars ('sum(f(i), i, 0, n));
(%o4)                          [n]
@end example

@end defvr




@c NEEDS WORK
@deffn {Funci@'on} listofvars (@var{expr})
Devuelve una lista con las variables presentes en @var{expr}.

Si la variable @code{listconstvars} vale @code{true} entonces
@code{listofvars} incluir@'a @code{%e}, @code{%pi}, @code{%i}
y cualquier otra variable declarada constante de las que aparezcan
en @var{expr}.  Estas constantes se omiten por defecto.

V@'ease tambi@'en la variable opcional @code{listdummyvars} para
excluir o incluir variables ficticias en la lista de variables.

Ejemplo:

@example
(%i1) listofvars (f (x[1]+y) / g^(2+a));
(%o1)                     [g, a, x , y]
                                  1
@end example

@end deffn

@c NEEDS WORK
@deffn {Funci@'on} lfreeof (@var{list}, @var{expr})
Para cada miembro  @var{m} de @var{list}, realiza la llamada @code{freeof (@var{m}, @var{expr})}.
Devuelve @code{false} si alguna de estas llamadas a @code{freeof} retorn@'o @code{false}, y @code{true} en caso contrario.
@end deffn



@c NEEDS WORK
@deffn {Funci@'on} lpart (@var{label}, @var{expr}, @var{n_1}, ..., @var{n_k})
Similar a @code{dpart} pero utiliza una caja etiquetada. Una caja etiquetada es similar a la que produce @code{dpart}, pero con un nombre en la l@'{@dotless{i}}nea superior.
@end deffn




@defvr {Propiedad} mainvar
Se pueden declarar variables de tipo @code{mainvar}.  El orden de los @'atomos 
es: n@'umeros < constantes (como @code{%e} o @code{%pi}) <
escalares < otras variables < "mainvars".  Por ejemplo, comp@'arese @code{expand ((X+Y)^4)}
con @code{(declare (x, mainvar), expand ((x+y)^4))}.  (Nota: Se debe tener cuidado si se quiere hacer uso de esta declaraci@'on. Por ejemplo, si se resta una expresi@'on en la que @code{x} ha sido declarada como @code{mainvar} de otra en la que @code{x} no es @code{mainvar}, puede ser necesario volver a simplificar, @code{ev (expr, simp)}, a fin de obtener cancelaciones.  Adem@'as, si se guarda una expresi@'on en la que @code{x} es @code{mainvar}, quiz@'as sea necesario guardar tambi@'en @code{x}.)

@end defvr



@defvr {Propiedad} noun
El s@'{@dotless{i}}mbolo @code{noun} es una de las opciones de la instrucci@'on @code{declare}. Hace que una funci@'on se declare como "nombre", lo que significa que no se evaluar@'a autom@'aticamente.

@end defvr




@defvr {Variable opcional} noundisp
Valor por defecto: @code{false}

Si @code{noundisp} vale @code{true}, los nombres se muestran precedidos de un ap@'ostrofo. Siempre debe valer @code{true} cuando se quiera representar la definici@'on de funciones.

@end defvr



@c NEEDS WORK
@deffn {Funci@'on} nounify (@var{f})
Devuelve la forma nominal de la funci@'on cuyo nombre es @var{f}.  Puede ser @'util cuando se quiera hacer referencia al nombre de una funci@'on sin que @'esta se ejecute.  N@'otese que algunas funciones verbales devolver@'an su forma nominal si no pueden ser evaluadas para ciertos argumentos.  Esta es tambi@'en la expresi@'on que se obtiene cuando la llamada a una funci@'on va precedida por del ap@'ostrofo.

@end deffn

@c NEEDS WORK
@deffn {Funci@'on} nterms (@var{expr})
Devuelve el n@'umero de t@'erminos que  @var{expr} llegar@'{@dotless{i}}a a tener si fuese completamente expandida y no hubiesen cancelaciones ni combinaciones de t@'erminos semejantes.
N@'otese que expresiones como @code{sin (@var{expr})}, @code{sqrt (@var{expr})}, @code{exp (@var{expr})}, etc.
cuentan como un s@'olo t@'ermino, independientemente de cu@'antos t@'erminos tenga a su vez @var{expr} en caso de tratarse de una suma.

@end deffn




@c NEEDS WORK
@deffn {Funci@'on} op (@var{expr})
Devuelve el operador principal de la expresi@'on @var{expr}. La llamada
@code{op (@var{expr})} equivale a @code{part (@var{expr}, 0)}. 

La funci@'on @code{op} devuelve una cadena si el operador principal es un operador prefijo, infijo (binario o @code{n}-ario), postfijo, "bi-fijo" o "no-fijo" ("bi-fijo"  se refiere a un par de s@'{@dotless{i}}mbolos que encierran su o sus argumentos, y "no-fijo" es un operador que no necesita argumentos).
Si @var{expr} es la expresi@'on de una funci@'on
subindicada, @code{op} devuelve la funci@'on subindicada;
en cuyo caso el valor devuelto no es un @'atomo.
En otro caso, @var{expr} es la expresi@'on de una funci@'on array u
ordinaria, y entonces @code{op} devuelve un s@'{@dotless{i}}mbolo.

La funci@'on @code{op} observa el valor de la variable global @code{inflag}.

La funci@'on @code{op} eval@'ua sus argumentos.

V@'ease tambi@'en @code{args}.

Ejemplos:

@c ===beg===
@c stringdisp: true$
@c op (a * b * c);
@c op (a * b + c);
@c op ('sin (a + b));
@c op (a!);
@c op (-a);
@c op ([a, b, c]);
@c op ('(if a > b then c else d));
@c op ('foo (a));
@c prefix (foo);
@c op (foo a);
@c op (F [x, y] (a, b, c));
@c op (G [u, v, w]);
@c ===end===

@example
(%i1) stringdisp: true$
(%i2) op (a * b * c);
(%o2)                          "*"
(%i3) op (a * b + c);
(%o3)                          "+"
(%i4) op ('sin (a + b));
(%o4)                          sin
(%i5) op (a!);
(%o5)                          "!"
(%i6) op (-a);
(%o6)                          "-"
(%i7) op ([a, b, c]);
(%o7)                          "["
(%i8) op ('(if a > b then c else d));
(%o8)                         "if"
(%i9) op ('foo (a));
(%o9)                          foo
(%i10) prefix (foo);
(%o10)                        "foo"
(%i11) op (foo a);
(%o11)                        "foo"
(%i12) op (F [x, y] (a, b, c));
(%o12)                        F
                               x, y
(%i13) op (G [u, v, w]);
(%o13)                          G
@end example

@end deffn


@c NEEDS WORK
@deffn {Funci@'on} operatorp (@var{expr}, @var{op})
@deffnx {Funci@'on} operatorp (@var{expr}, [@var{op_1}, ..., @var{op_n}])

La llamada @code{operatorp (@var{expr}, @var{op})} devuelve @code{true}
si @var{op} es igual al operador de @var{expr}.

La llamada @code{operatorp (@var{expr}, [@var{op_1}, ..., @var{op_n}])} devuelve @code{true}
si alg@'un elemento  @var{op_1}, ..., @var{op_n} es igual al operador de @var{expr}.

@end deffn



@defvr {Variable opcional} opsubst
Valor por defecto: @code{true}

Si @code{opsubst} vale @code{false}, @code{subst} no sustituye el operdor de una expresi@'on, de manera que @code{(opsubst: false, subst (x^2, r, r+r[0]))} trabajar@'a correctamente.

@end defvr




@c NEEDS WORK
@deffn {Funci@'on} optimize (@var{expr})
Devuelve una expresi@'on que produce el mismo valor y efectos secundarios que @var{expr}, pero de forma m@'as eficiente al evitar recalcular subexpresiones comunes. La funci@'on @code{optimize} tambi@'en tiene el efecto secundario de colapsar su argumento de manera que se compartan todas sus subexpresiones comunes.
H@'agase @code{example (optimize)} para ver ejemplos.

@end deffn

@defvr {Variable opcional} optimprefix
Valor por defecto: @code{%}

La variable @code{optimprefix} es el prefijo utilizado para los s@'{@dotless{i}}mbolos generados por la instrucci@'on @code{optimize}.

@end defvr

@deffn {Funci@'on} ordergreat (@var{v_1}, ..., @var{v_n})
@deffnx {Funci@'on} orderless (@var{v_1}, ..., @var{v_n})

@code{ordergreat} cambia el orden can@'onico de las expresiones de
Maxima, de manera que @var{v_1} prevalece sobre @var{v_2}, que
prevalece sobre ..., que prevalece sobre @var{v_n}, que prevalece
sobre cualquier otro s@'{@dotless{i}}mbolo no presente en la
lista de argumentos.

@code{orderless} cambia el orden can@'onico de las expresiones de
Maxima, de manera que @var{v_1} precede a @var{v_2}, que precede a ...,
que precede a @var{v_n}, que precede a cualquier otra variable no 
presente en la lista de argumentos.

El orden impuesto por @code{ordergreat} y @code{orderless} se 
destruye con @code{unorder}. @code{ordergreat} y @code{orderless}
s@'olo se pueden llamar una vez, a menos que se invoque a @code{unorder}.
La @'ultima llamada a @code{ordergreat} y @code{orderless} es la que
se mantiene activa.

V@'ease tambi@'en @code{ordergreatp}.

@end deffn


@deffn {Funci@'on} ordergreatp (@var{expr_1}, @var{expr_2})
@deffnx {Funci@'on} orderlessp (@var{expr_1}, @var{expr_2})

@code{ordergreatp} devuelve @code{true} si @var{expr_1} prevalece sobre
@var{expr_2} en el orden can@'onico de las expresiones de Maxima, o
@code{false} en caso contrario.

@code{orderlessp} devuelve @code{true} si @var{expr_1} precede a
@var{expr_2} en el orden can@'onico de las expresiones de Maxima, o
@code{false} en caso contrario.

Todos los @'atomos y expresiones de Maxima son comparables bajo 
@code{ordergreatp} y @code{orderlessp}, aunque existen ejemplos aislados
de expresiones para los que estos predicados no son transitivos.

La ordenaci@'on can@'onica de @'atomos (s@'{@dotless{i}}mbolos, n@'umeros
literales y cadenas) es la siguiente: (enteros y decimales en coma flotante)
preceden a (n@'umeros decimales grandes o @i{bigfloats}), que preceden a (constantes
declaradas), que preceden a (cadenas), que preceden a (escalares declarados), que preceden a 
(primer argumento de @code{orderless}), que precede a ..., que precede a (@'ultimo
argumento de @code{orderless}), que precede a (otros s@'{@dotless{i}}mbolos), que
preceden a (@'ultimo argumento de @code{ordergreat}), que precede a ..., que
precede a (primer argumento de @code{ordergreat}), que precede a (variables
principales declaradas).

Para las expresiones no at@'omicas, la ordenaci@'on can@'onica se deriva de la
ordenaci@'on de @'atomos. Para los operadores nativos @code{+}, @code{*} y @code{^},
los criterios de ordenaci@'on no son sencillos de resumir.
Para otros operadores nativos, y todas las dem@'as funciones y operadores,
las expresiones se ordenan por sus argumentos (empezando por el primero),
despu@'es por el nombre del operador o funci@'on. En caso de expresiones
con sub@'{@dotless{i}}ndices, el s@'{@dotless{i}}mbolo subindicado se
considera operador y el sub@'{@dotless{i}}ndice un argumento del mismo.

El orden can@'onico de expresiones se modifica mediante las funciones
@code{ordergreat} y @code{orderless}, as@'{@dotless{i}} como por las 
declaraciones @code{mainvar}, @code{constant} y @code{scalar}.

V@'ease tambi@'en @code{sort}.

Ejemplos:

Ordenaci@'on de s@'{@dotless{i}}mbolos comunes y constantes.
N@'otese que @code{%pi} no se ordena en funci@'on de su valor
num@'erico.

@c ===beg===
@c stringdisp : true;
@c sort ([%pi, 3b0, 3.0, x, X, "foo", 3, a, 4, "bar", 4.0, 4b0]);
@c ===end===
@example
(%i1) stringdisp : true;
(%o1)                         true
(%i2) sort ([%pi, 3b0, 3.0, x, X, "foo", 3, a, 4, "bar", 4.0, 4b0]);
(%o2) [3, 3.0, 4, 4.0, 3.0b0, 4.0b0, %pi, "bar", "foo", a, x, X]
@end example

Efecto producido por las funciones @code{ordergreat} y @code{orderless}.

@c ===beg===
@c sort ([M, H, K, T, E, W, G, A, P, J, S]);
@c ordergreat (S, J);
@c orderless (M, H);
@c sort ([M, H, K, T, E, W, G, A, P, J, S]);
@c ===end===
@example
(%i1) sort ([M, H, K, T, E, W, G, A, P, J, S]);
(%o1)           [A, E, G, H, J, K, M, P, S, T, W]
(%i2) ordergreat (S, J);
(%o2)                         done
(%i3) orderless (M, H);
(%o3)                         done
(%i4) sort ([M, H, K, T, E, W, G, A, P, J, S]);
(%o4)           [M, H, A, E, G, K, P, T, W, J, S]
@end example

Efecto producido por las declaraciones @code{mainvar}, @code{constant} y @code{scalar}.

@c ===beg===
@c sort ([aa, foo, bar, bb, baz, quux, cc, dd, A1, B1, C1]);
@c declare (aa, mainvar);
@c declare ([baz, quux], constant);
@c declare ([A1, B1], scalar);
@c sort ([aa, foo, bar, bb, baz, quux, cc, dd, A1, B1, C1]);
@c ===end===
@example
(%i1) sort ([aa, foo, bar, bb, baz, quux, cc, dd, A1, B1, C1]);
(%o1)   [aa, bar, baz, bb, cc, dd, foo, quux, A1, B1, C1]
(%i2) declare (aa, mainvar);
(%o2)                         done
(%i3) declare ([baz, quux], constant);
(%o3)                         done
(%i4) declare ([A1, B1], scalar);
(%o4)                         done
(%i5) sort ([aa, foo, bar, bb, baz, quux, cc, dd, A1, B1, C1]);
(%o5)   [baz, quux, A1, B1, bar, bb, cc, dd, foo, C1, aa]
@end example

Ordenaci@'on de expresiones no at@'omicas.

@c ===beg===
@c sort ([1, 2, n, f(1), f(2), f(2, 1), g(1), g(1, 2), g(n), f(n, 1)]);
@c sort ([foo(1), X[1], X[k], foo(k), 1, k]);
@c ===end===
@example
(%i1) sort ([1, 2, n, f(1), f(2), f(2, 1), g(1), g(1, 2), g(n), f(n, 1)]);
(%o1) [1, 2, f(1), g(1), g(1, 2), f(2), f(2, 1), n, g(n), 
                                                         f(n, 1)]
(%i2) sort ([foo(1), X[1], X[k], foo(k), 1, k]);
(%o2)            [1, foo(1), X , k, foo(k), X ]
                              1              k
@end example
@end deffn


@c NEEDS WORK
@deffn {Funci@'on} part (@var{expr}, @var{n_1}, ..., @var{n_k})
Devuelve partes de la forma mostrada de @code{expr}. Obtiene la 
parte de @code{expr} que se especifica por los @'{@dotless{i}}ndices 
@var{n_1}, ..., @var{n_k}.  Primero se obtiene la parte @var{n_1} de 
@code{expr}, despu@'es la parte @var{n_2} del resultado anterior, 
y as@'{@dotless{i}} sucesivamente.  El resultado que se obtiene es 
la parte @var{n_k} de ... la parte @var{n_2} de la parte @var{n_1} de @code{expr}.
Si no se especifican @'{@dotless{i}}ndices, devuelve @code{expr}.

La funci@'on @code{part} se puede utilizar para obtener un elemento 
de una lista, una fila de una matriz, etc.

@c "If the last argument to a part function" => FOLLOWING APPLIES TO OTHER FUNCTIONS ??
@c ATTEMPT TO VERIFY; IF SO, COPY THIS COMMENTARY TO DESCRIPTIONS OF OTHER FUNCTIONS
Si el @'ultimo argumento de la funci@'on @code{part} es una lista de 
@'{@dotless{i}}ndices, entonces se toman varias subexpresiones, cada 
una de las cuales correspondiente a un @'{@dotless{i}}ndice de la lista.
As@'{@dotless{i}}, @code{part (x + y + z, [1, 3])} devuelve @code{z+x}.

La variable @code{piece} guarda la @'ultima expresi@'on seleccionada
con la funci@'on @code{part}. Se actualiza durante la ejecuci@'on de
la funci@'on, por lo que puede ser referenciada en la misma funci@'on.

Si @code{partswitch} vale @code{true} entonces de devuelve @code{end}
cuando no exista la parte seleccionada de una expresi@'on, si vale
@code{false} se mostrar@'a un mensaje de error.

V@'eanse tambi@'en @code{inpart}, @code{substpart}, @code{substinpart},
@code{dpart} y @code{lpart}.

Ejemplos:

@c ===beg===
@c part(z+2*y+a,2);
@c part(z+2*y+a,[1,3]);
@c part(z+2*y+a,2,1);
@c ===end===
@example
(%i1) part(z+2*y+a,2);
(%o1)                                 2 y
(%i2) part(z+2*y+a,[1,3]);
(%o2)                                z + a
(%i3) part(z+2*y+a,2,1);
(%o3)                                  2
@end example

La instrucci@'on @code{example (part)} muestra m@'as ejemplos.

@end deffn




@c NEEDS WORK
@deffn {Funci@'on} partition (@var{expr}, @var{x})
Devuelve una lista con dos expresiones, que son: (1) los factores de 
@var{expr} si es un producto, los t@'erminos de @var{expr} si es una
suma, o los elementos de @var{expr}, si es una lista, que no contengan
a @var{x}, (2) los factores, t@'erminos o lista que contengan a @var{x}.

@example
(%i1) partition (2*a*x*f(x), x);
(%o1)                     [2 a, x f(x)]
(%i2) partition (a+b, x);
(%o2)                      [b + a, 0]
(%i3) partition ([a, b, f(a), c], a); 
(%o3)                  [[b, c], [a, f(a)]]
@end example

@end deffn

@c NEEDS EXAMPLE
@defvr {Variable opcional} partswitch
Valor por defecto: @code{false}

Si @code{partswitch} vale @code{true} entonces de devuelve @code{end} cuando no exista la parte seleccionada de una expresi@'on, si vale @code{false} se mostrar@'a un mensaje de error.

@end defvr

@deffn {Funci@'on} pickapart (@var{expr}, @var{n})
Asigna etiquetas de expresiones intermedias a subexpresiones de @var{expr} al nivel de profundidad @var{n}, que es un entero. A las subexpresiones a un nivel de profundidad mayor o menor no se les asignan etiquetas. La funci@'on
@code{pickapart} devuelve una expresi@'on en t@'erminos de expresiones intermedias equivalente a la expresi@'on original @var{expr}.

V@'eanse tambi@'en @code{part}, @code{dpart}, @code{lpart}, @code{inpart} y @code{reveal}.

Ejemplos:

@example
(%i1) expr: (a+b)/2 + sin (x^2)/3 - log (1 + sqrt(x+1));
                                          2
                                     sin(x )   b + a
(%o1)       - log(sqrt(x + 1) + 1) + ------- + -----
                                        3        2
(%i2) pickapart (expr, 0);

                                          2
                                     sin(x )   b + a
(%t2)       - log(sqrt(x + 1) + 1) + ------- + -----
                                        3        2

(%o2)                          %t2
(%i3) pickapart (expr, 1);

(%t3)                - log(sqrt(x + 1) + 1)


                                  2
                             sin(x )
(%t4)                        -------
                                3


                              b + a
(%t5)                         -----
                                2

(%o5)                    %t5 + %t4 + %t3
(%i5) pickapart (expr, 2);

(%t6)                 log(sqrt(x + 1) + 1)


                                  2
(%t7)                        sin(x )


(%t8)                         b + a

                         %t8   %t7
(%o8)                    --- + --- - %t6
                          2     3
(%i8) pickapart (expr, 3);

(%t9)                    sqrt(x + 1) + 1


                                2
(%t10)                         x

                  b + a              sin(%t10)
(%o10)            ----- - log(%t9) + ---------
                    2                    3
(%i10) pickapart (expr, 4);

(%t11)                     sqrt(x + 1)

                      2
                 sin(x )   b + a
(%o11)           ------- + ----- - log(%t11 + 1)
                    3        2
(%i11) pickapart (expr, 5);

(%t12)                        x + 1

                   2
              sin(x )   b + a
(%o12)        ------- + ----- - log(sqrt(%t12) + 1)
                 3        2
(%i12) pickapart (expr, 6);
                  2
             sin(x )   b + a
(%o12)       ------- + ----- - log(sqrt(x + 1) + 1)
                3        2
@end example

@end deffn

@c NEEDS WORK
@defvr {Variable del sistema} piece
Guarda la @'ultima expresi@'on seleccionada por las funciones @code{part}.

@c NEED "SEE ALSO" TO POINT TO LIST OF ALL RELEVANT FUNCTIONS

@end defvr



@deffn  {Funci@'on} psubst (@var{list}, @var{expr})
@deffnx {Funci@'on} psubst (@var{a}, @var{b}, @var{expr})

@code{psubst(@var{a}, @var{b}, @var{expr})} es simliar a @code{subst}.  V@'ease 
@code{subst}.

A diferencia de @code{subst}, la funci@'on @code{psubst} hace sustituciones
en paralelo si su primer argumento es una lista de ecuaciones.

V@'ease tambi@'en @code{sublis} para hacer sustituciones en paralelo.

Ejemplo:

El primer ejemplo muestra la sustituci@'on en paralelo con @code{psubst}.
El segundo ejemplo muestra el resultado de la funci@'on @code{subst},
que realiza la sustituci@'on en serie.

@c ===beg===
@c psubst ([a^2=b, b=a], sin(a^2) + sin(b));
@c subst ([a^2=b, b=a], sin(a^2) + sin(b));
@c ===end===
@example
(%i4) psubst ([a^2=b, b=a], sin(a^2) + sin(b));
(%o4)                           sin(b) + sin(a)
(%i5) subst ([a^2=b, b=a], sin(a^2) + sin(b));
(%o5)                              2 sin(a)
@end example

@end deffn




@deffn {Funci@'on} rembox (@var{expr}, unlabelled)
@deffnx {Funci@'on} rembox (@var{expr}, @var{label})
@deffnx {Funci@'on} rembox (@var{expr})
Elimina cajas de @var{expr}.

La llamada @code{rembox (@var{expr}, unlabelled)} elimina todas las cajas no etiquetadas de @var{expr}.

La llamada @code{rembox (@var{expr}, @var{label})} s@'olo elimina las cajas etiquetadas con @var{label}.

La llamada @code{rembox (@var{expr})} elimina todas las caajs, independientemente de que est@'en etiquetadas o no.

Las cajas son dibujadas por las funciones @code{box}, @code{dpart} y @code{lpart}.

Ejemplos:

@c ===beg===
@c expr: (a*d - b*c)/h^2 + sin(%pi*x);
@c dpart (dpart (expr, 1, 1), 2, 2);
@c expr2: lpart (BAR, lpart (FOO, %, 1), 2);
@c rembox (expr2, unlabelled);
@c rembox (expr2, FOO);
@c rembox (expr2, BAR);
@c rembox (expr2);
@c ===end===
@example
(%i1) expr: (a*d - b*c)/h^2 + sin(%pi*x);
                                  a d - b c
(%o1)                sin(%pi x) + ---------
                                      2
                                     h
(%i2) dpart (dpart (expr, 1, 1), 2, 2);
                        """""""    a d - b c
(%o2)               sin("%pi x") + ---------
                        """""""      """"
                                     " 2"
                                     "h "
                                     """"
(%i3) expr2: lpart (BAR, lpart (FOO, %, 1), 2);
                  FOO"""""""""""   BAR""""""""
                  "    """"""" "   "a d - b c"
(%o3)             "sin("%pi x")" + "---------"
                  "    """"""" "   "  """"   "
                  """"""""""""""   "  " 2"   "
                                   "  "h "   "
                                   "  """"   "
                                   """""""""""
(%i4) rembox (expr2, unlabelled);
                                  BAR""""""""
                   FOO"""""""""   "a d - b c"
(%o4)              "sin(%pi x)" + "---------"
                   """"""""""""   "    2    "
                                  "   h     "
                                  """""""""""
(%i5) rembox (expr2, FOO);
                                  BAR""""""""
                       """""""    "a d - b c"
(%o5)              sin("%pi x") + "---------"
                       """""""    "  """"   "
                                  "  " 2"   "
                                  "  "h "   "
                                  "  """"   "
                                  """""""""""
(%i6) rembox (expr2, BAR);
                   FOO"""""""""""
                   "    """"""" "   a d - b c
(%o6)              "sin("%pi x")" + ---------
                   "    """"""" "     """"
                   """"""""""""""     " 2"
                                      "h "
                                      """"
(%i7) rembox (expr2);
                                  a d - b c
(%o7)                sin(%pi x) + ---------
                                      2
                                     h
@end example

@end deffn




@deffn {Funci@'on} reveal (@var{expr}, @var{nivel})
Reemplaza partes de @var{expr} al @var{nivel} especificado y las sutituye por descripciones cortas.

@itemize @bullet
@item
Las sumas y restas se reemplazan por @code{Sum(@var{n})},
siendo @var{n} el n@'umero de t@'erminos de la suma.
@item
Los productos se reemplazan por @code{Product(@var{n})},
siendo @var{n} el n@'umero de factores del producto.
@item
Las potencias se reemplazan por @code{Expt}. 
@item
Los cocientes se reemplazan por @code{Quotient}.
@item
El s@'{@dotless{i}}mbolo negativo se reemplaza por @code{Negterm}.
@item
Las listas se reemplazan por @code{List(@var{n})}, siendo @var{n} el n@'umero de
elementos de la lista.
@end itemize

Si el entero  @var{depth} es mayor o igual que la profundidad m@'axima de @var{expr},
@code{reveal (@var{expr}, @var{depth})} devuelve @var{expr} sin modificar.

La funci@'on @code{reveal} eval@'ua sus argumentos y devuelve la expresi@'on con las modificaciones solicitadas.

Ejemplo:

@c === beg ===
@c e: expand ((a - b)^2)/expand ((exp(a) + exp(b))^2);
@c reveal (e, 1);
@c reveal (e, 2);
@c reveal (e, 3);
@c reveal (e, 4);
@c reveal (e, 5);
@c reveal (e, 6);
@c === end ===
@example
(%i1) e: expand ((a - b)^2)/expand ((exp(a) + exp(b))^2);
                          2            2
                         b  - 2 a b + a
(%o1)               -------------------------
                        b + a     2 b     2 a
                    2 %e      + %e    + %e
(%i2) reveal (e, 1);
(%o2)                       Quotient
(%i3) reveal (e, 2);
                             Sum(3)
(%o3)                        ------
                             Sum(3)
(%i4) reveal (e, 3);
                     Expt + Negterm + Expt
(%o4)               ------------------------
                    Product(2) + Expt + Expt
(%i5) reveal (e, 4);
                       2                 2
                      b  - Product(3) + a
(%o5)         ------------------------------------
                         Product(2)     Product(2)
              2 Expt + %e           + %e
(%i6) reveal (e, 5);
                         2            2
                        b  - 2 a b + a
(%o6)              --------------------------
                       Sum(2)     2 b     2 a
                   2 %e       + %e    + %e
(%i7) reveal (e, 6);
                          2            2
                         b  - 2 a b + a
(%o7)               -------------------------
                        b + a     2 b     2 a
                    2 %e      + %e    + %e
@end example
@end deffn



@deffn {Funci@'on} sublis (@var{list}, @var{expr})

Hace sustituciones m@'ultiples en paralelo dentro de las expresiones.
@var{list} es una lista de ecuaciones, cuyos miembros izquierdos deben
ser @'atomos.

La variable @code{sublis_apply_lambda} controla la simplificaci@'on
despu@'es de @code{sublis}.

V@'ease tambi@'en @code{psubst} para hacer sustituciones en paralelo.

Ejemplo:

@c ===beg===
@c sublis ([a=b, b=a], sin(a) + cos(b));
@c ===end===
@example
(%i1) sublis ([a=b, b=a], sin(a) + cos(b));
(%o1)                    sin(b) + cos(a)
@end example
@end deffn



@defvr {Variable opcional} sublis_apply_lambda
Valor por defecto: @code{true}

Controla si los @code{lambda} sustituidos son aplicados en la simplificaci@'on despu@'es de invocar a @code{sublis}, o si se tiene que hacer un @code{ev} para hacerlo. Si @code{sublis_apply_lambda} vale @code{true}, significa que se ejecute la aplicaci@'on.

@end defvr



@defvr {Variable opcional} subnumsimp
Valor por defecto: @code{false}

Si vale @code{true}, las funciones @code{subst} y @code{psubst} puede sustituir
una variable subindicada @code{f[x]} por un n@'umero simplemente utilizando el
s@'{@dotless{i}}mbolo @code{f}.

V@'ease tambi@'en @code{subst}.

@example
(%i1) subst(100,g,g[x]+2);

subst: cannot substitute 100 for operator g in expression g
                                                           x
 -- an error. To debug this try: debugmode(true);

(%i2) subst(100,g,g[x]+2),subnumsimp:true;
(%o2)                          102
@end example

@end defvr




@deffn {Funci@'on} subst (@var{a}, @var{b}, @var{c})
Sustituye @var{a} por @var{b} en @var{c}. El argumento  @var{b} debe ser un @'atomo o una subexpresi@'on completa de @var{c}.  Por ejemplo, @code{x+y+z} es una subexpresi@'on completa de  @code{2*(x+y+z)/w} mientras que @code{x+y} no lo es. Cuando @var{b} no cumple esta caracter@'{@dotless{i}}stica, se puede utilizar en algunos casos @code{substpart} o @code{ratsubst}
(ver m@'as abajo).  Alternativamente, si @var{b} no es de la forma @code{e/f} entonces se puede usar @code{subst (a*f, e, c)}, pero si @var{b} es de la forma @code{e^(1/f)} se debe usar @code{subst (a^f, e, c)}.  La instrucci@'on @code{subst} tambi@'en reconoce @code{x^y} en @code{x^-y}, de manera que  @code{subst (a, sqrt(x), 1/sqrt(x))} da @code{1/a}. Los argumentos @var{a} y @var{b} tambi@'en pueden ser operadores de una expresi@'on acotados por comillas dobles @code{"} o nombres de funciones.  Si se quiere sustituir la variable independiente en expresiones con derivadas se debe utilizar la funci@'on @code{at} (ver m@'as abajo).

La funci@'on @code{subst} es sin@'onimo de @code{substitute}.

La llamada @code{subst (@var{eq_1}, @var{expr})} o 
@code{subst ([@var{eq_1}, ..., @var{eq_k}], @var{expr})}
est@'an permitidas. Las @var{eq_i} son ecuaciones que indican las sustituciones a realizar.
Para cada ecuaci@'on, el miembro izquierdo ser@'a sustituido por la expresi@'on del 
miembro derecho en @var{expr}. Las ecuaciones se sustituyen secuencialmente de
izquierda a derecha en @var{expr}. V@'eanse las funciones @code{sublis} y @code{psubst} 
para sustituciones en paralelo.

Si la variable @code{exptsubst} vale @code{true} se permiten ciertas
sustituciones de exponentes; por ejemplo, sustituir @code{y} por @code{%e^x}
en @code{%e^(a*x)}.

Si @code{opsubst} vale @code{false},
@code{subst} no intentar@'a sustituir un operador de una expresi@'on. Por ejemplo, 
@code{(opsubst: false, subst (x^2, r, r+r[0]))} trabajar@'a sin problemas.

Ejemplos:

@c ===beg===
@c subst (a, x+y, x + (x+y)^2 + y);
@c subst (-%i, %i, a + b*%i);
@c ===end===
@example
(%i1) subst (a, x+y, x + (x+y)^2 + y);
                                    2
(%o1)                      y + x + a
(%i2) subst (-%i, %i, a + b*%i);
(%o2)                       a - %i b
@end example

La sustituci@'on se hace secuencialmente seg@'un una lista de
ecuaciones. Comp@'arese con la sustituci@'on en paralelo.

@c ===beg===
@c subst([a=b, b=c], a+b);
@c sublis([a=b, b=c], a+b);
@c ===end===
@example
(%i3) subst([a=b, b=c], a+b);
(%o3)                                 2 c
(%i4) sublis([a=b, b=c], a+b);
(%o4)                                c + b
@end example

@noindent
Para m@'as ejemplos, ejec@'utese @code{example (subst)}.

@end deffn



@deffn {Funci@'on} substinpart (@var{x}, @var{expr}, @var{n_1}, @dots{}, @var{n_k})

Es similar a @code{substinpart}, pero trabaja con la representaci@'on interna de @var{expr}.

Ejemplos:

@c ===beg===
@c x . 'diff (f(x), x, 2);
@c substinpart (d^2, %, 2);
@c substinpart (f1, f[1](x + 1), 0);
@c ===end===
@example
(%i1) x . 'diff (f(x), x, 2);
                              2
                             d
(%o1)                   x . (--- (f(x)))
                               2
                             dx
(%i2) substinpart (d^2, %, 2);
                                  2
(%o2)                        x . d
(%i3) substinpart (f1, f[1](x + 1), 0);
(%o3)                       f1(x + 1)
@end example

Si el @'ultimo argumento pasado a la funci@'on @code{part} es una
lista de @'{@dotless{i}}ndices, se obtendr@'a la lista de subexpresiones
correspondientes a cada uno de los @'{@dotless{i}}ndices.

@c ===beg===
@c part (x + y + z, [1, 3]);
@c ===end===
@example
(%i1) part (x + y + z, [1, 3]);
(%o1)                         z + x
@end example

La variable @code{piece} guarda el valor de la @'ultima expresi@'on seleccionada al
utilizar las funciones @code{part}. El valor es asignado durante la 
ejecuci@'on de la funci@'on y puede ser utilizada tal como se muestra m@'as
abajo. Si a @code{partswitch} se le asigna el valor @code{true} entonces se
devolver@'a @code{end} cuando no existe la parte solicitada; con otro
valor devuelve un mensaje de error.

@c ===beg===
@c expr: 27*y^3 + 54*x*y^2 + 36*x^2*y + y + 8*x^3 + x + 1;
@c part (expr, 2, [1, 3]);
@c sqrt (piece/54);
@c substpart (factor (piece), expr, [1, 2, 3, 5]);
@c expr: 1/x + y/x - 1/z;
@c substpart (xthru (piece), expr, [2, 3]);
@c ===end===
@example
(%i1) expr: 27*y^3 + 54*x*y^2 + 36*x^2*y + y + 8*x^3 + x + 1;
              3         2       2            3
(%o1)     27 y  + 54 x y  + 36 x  y + y + 8 x  + x + 1
(%i2) part (expr, 2, [1, 3]);
                                  2
(%o2)                         54 y
(%i3) sqrt (piece/54);
(%o3)                        abs(y)
(%i4) substpart (factor (piece), expr, [1, 2, 3, 5]);
                               3
(%o4)               (3 y + 2 x)  + y + x + 1
(%i5) expr: 1/x + y/x - 1/z;
                             1   y   1
(%o5)                      - - + - + -
                             z   x   x
(%i6) substpart (xthru (piece), expr, [2, 3]);
                            y + 1   1
(%o6)                       ----- - -
                              x     z
@end example

Adem@'as, d@'andole a @code{inflag} el valor @code{true} y llamando a
@code{part} o @code{substpart} es lo mismo que invocar a  @code{inpart} o @code{substinpart}.

@end deffn



@deffn {Funci@'on} substpart (@var{x}, @var{expr}, @var{n_1}, @dots{}, @var{n_k})

Sustituye por @var{x} la subexpresi@'on que se obtiene de aplicar el resto de
argumentos a la funci@'on @code{part}, devolviendo el nuevo valor de @var{expr}.
@var{x} puede ser un operador que sustituya otro operador de @var{expr}. En
ciertos casos, @var{x} necesita estar entrecomillado por comillas dobles (@code{"});
por ejemplo, de @code{substpart ("+", a*b, 0)} se obtiene @code{b + a}.

Ejemplo:

@c ===beg===
@c 1/(x^2 + 2);
@c substpart (3/2, %, 2, 1, 2);
@c a*x + f(b, y);
@c substpart ("+", %, 1, 0);
@c ===end===
@example
(%i1) 1/(x^2 + 2);
                               1
(%o1)                        ------
                              2
                             x  + 2
(%i2) substpart (3/2, %, 2, 1, 2);
                               1
(%o2)                       --------
                             3/2
                            x    + 2
(%i3) a*x + f(b, y);
(%o3)                     a x + f(b, y)
(%i4) substpart ("+", %, 1, 0);
(%o4)                    x + f(b, y) + a
@end example

Adem@'as, d@'andole a @code{inflag} el valor @code{true} y llamando a
@code{part} o @code{substpart} es lo mismo que invocar a  @code{inpart} o @code{substinpart}.

@end deffn



@deffn {Funci@'on} symbolp (@var{expr})
Devuelve @code{true} si @var{expr} es un s@'{@dotless{i}}mbolo y @code{false} en caso contrario.
La llamada @code{symbolp(x)} equivale al predicado @code{atom(x) and not numberp(x)}.

V@'ease tambi@'en @code{Identifiers}.

@end deffn




@deffn {Funci@'on} unorder ()
Desactiva las asociaciones creadas por la @'ultima utilizaci@'on de los comandos de ordenaci@'on @code{ordergreat} y @code{orderless}, los cuales no pueden ser utilizados m@'as de una vez sin invocar a @code{unorder}. 

@code{unorder} no sustituye en expresiones los s@'{@dotless{i}}mbolos originales
por los alias introducidos por @code{ordergreat} y @code{orderless}. Es por ello
que tras la ejecucin de @code{unorder} los alias aparecen en expresiones
anteriores.

V@'ease tambi@'en @code{ordergreat} y @code{orderless}.

Ejemplos:

@code{ordergreat(a)} introduce un alias para el s@'{@dotless{i}}mbolo @code{a},
raz@'on por la cual la diferencia de @code{%o2} y @code{%o4} no se anula.
@code{unorder} no restablece el s@'{@dotless{i}}mbolo @code{a} y el alias
aparece en el resultado @code{%o7}.

@c ===beg===
@c unorder();
@c b*x + a^2;
@c ordergreat (a);
@c b*x + a^2;
@c  %th(1) - %th(3);
@c unorder();
@c %th(2);
@c ===end===
@example
(%i1) 
(%o1)                          []
(%i2) b*x+a^2;
                                   2
(%o2)                       b x + a
(%i3) ordergreat(a);
(%o3)                         done
(%i4) b*x+a^2;
                             2
(%o4)                       a  + b x
(%i5) %th(1)-%th(3);
                              2    2
(%o5)                        a  - a
(%i6) unorder();
(%o6)                          [a]
(%i7) %th(2);
                                2    2
(%o7)                      _101a  - a
@end example
@end deffn




@deffn {Funci@'on} verbify (@var{f})
Devuelve la forma verbal del nombre de funci@'on @var{f}.

V@'eanse tambi@'en @code{verb}, @code{noun} y @code{nounify}.

Ejemplos:

@c ===beg===
@c verbify ('foo);
@c :lisp $%
@c nounify (foo);
@c :lisp $%
@c ===end===
@example
(%i1) verbify ('foo);
(%o1)                          foo
(%i2) :lisp $%
$FOO
(%i2) nounify (foo);
(%o2)                          foo
(%i3) :lisp $%
%FOO
@end example

@end deffn
