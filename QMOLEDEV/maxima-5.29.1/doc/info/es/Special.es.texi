@c English version 2012-07-30
@menu
* Introducci@'on a las funciones especiales::
* Funciones de Bessel::
* Funciones de Airy::
* Funciones Gamma y factorial::
* Integral exponencial::
* Funci@'on de error::
* Funciones de Struve::
* Funciones hipergeom@'etricas::
* Funciones de cilindro parab@'olico::
* Funciones y variables para las funciones especiales::
@end menu

@node Introducci@'on a las funciones especiales, Funciones de Bessel, Funciones Especiales, Funciones Especiales
@section Introducci@'on a las funciones especiales

A continuaci@'on se especifican las notaciones correspondientes a las funciones especiales:

@example
bessel_j (index, expr)    Funci@'on de Bessel de primera especie
bessel_y (index, expr)    Funci@'on de Bessel de segunda especie
bessel_i (index, expr)    Funci@'on de Bessel modificada de primera especie
bessel_k (index, expr)    Funci@'on de Bessel modificada de segunda especie
hankel_1 (v,z)            Funci@'on de Hankel de primera especie
hankel_2 (v,z)            Funci@'on de Hankel de segunda especie
struve_h (v,z)            Funci@'on H de Struve
struve_l (v,z)            Funci@'on L de Struve
%p[u,v] (z)               Funci@'on de Legendre de primera especie
%q[u,v] (z)               Funci@'on de Legendre de segunda especie
%f[p,q] ([], [], expr)    Funci@'on hipergeom@'etrica generalizada
gamma()                   Funci@'on Gamma
gammagreek(a,z)           Funci@'on Gamma incompleta
gammaincomplete(a,z)      Extremo de la funci@'on Gamma incompleta
hypergeometric(l1, l2, z) Funci@'on hipergeom@'etrica
@c IS slommel THE "LOMMEL" FUNCTION ?? NOT OTHERWISE MENTIONED IN TEXINFO FILES
slommel
%m[u,k] (z)               Funci@'on de Whittaker de primera especie
%w[u,k] (z)               Funci@'on de Whittaker de segunda especie
erfc (z)                  Complemento de la funci@'on de error, erf
expintegral_e (v,z)       Integral exponencial E
expintegral_e1 (z)        Integral exponencial E1
expintegral_ei (z)        Integral exponencial Ei
expintegral_li (z)        Integral logar@'{@dotless{i}}tmica Li
expintegral_si (z)        Integral exponencial Si
expintegral_ci (z)        Integral exponencial Ci
expintegral_shi (z)       Integral exponencial Shi
expintegral_chi (z)       Integral exponencial Chi
kelliptic (z)             Integral el@'{@dotless{i}}ptica completa
                                  de primera especie (K)
parabolic_cylinder_d(v,z) Funci@'on D de cilindro parab@'olico
@end example





@node Funciones de Bessel, Funciones de Airy, Introducci@'on a las funciones especiales, Funciones Especiales
@section Funciones de Bessel


@deffn {Funci@'on} bessel_j (@var{v}, @var{z})
Funci@'on de Bessel de primera especie de orden @math{v} y argumento @math{z}.

La funci@'on @code{bessel_j} se define como

@ifnottex
@example
                inf
                ====       k  - v - 2 k  v + 2 k
                \     (- 1)  2          z
                 >    --------------------------
                /        k! gamma(v + k + 1)
                ====
                k = 0
@end example
@end ifnottex

@tex
$$\sum_{k=0}^{\infty }{{{\left(-1\right)^{k}\,\left(z\over 2\right)^{v+2\,k}
 }\over{k!\,\Gamma\left(v+k+1\right)}}}$$
@end tex

aunque la serie infinita no se utiliza en los c@'alculos.

@end deffn

@deffn {Funci@'on} bessel_y (@var{v}, @var{z})
Funci@'on de Bessel de segunda especie de orden @math{v} y argumento @math{z}.

La funci@'on @code{bessel_y} se define como

@ifnottex
@example
              cos(%pi v) bessel_j(v, z) - bessel_j(-v, z)
              -------------------------------------------
                             sin(%pi v)
@end example
@end ifnottex

@tex
$${{\cos \left(\pi\,v\right)\,J_{v}(z)-J_{-v}(z)}\over{
 \sin \left(\pi\,v\right)}}$$
@end tex

si @math{v} no es un entero.  En caso de que  @math{v} sea un entero @math{n}, se calcula el l@'{@dotless{i}}mite cuando @math{v} se aproxima a @math{n}.

@end deffn


@deffn {Funci@'on} bessel_i (@var{v}, @var{z})
Funci@'on modificada de Bessel de primera especie de orden @math{v} y argumento @math{z}.

La funci@'on @code{bessel_i} se define como

@ifnottex
@example
                    inf
                    ====   - v - 2 k  v + 2 k
                    \     2          z
                     >    -------------------
                    /     k! gamma(v + k + 1)
                    ====
                    k = 0
@end example
@end ifnottex

@tex
$$\sum_{k=0}^{\infty } {{1\over{k!\,\Gamma
 \left(v+k+1\right)}} {\left(z\over 2\right)^{v+2\,k}}}$$
@end tex

aunque la serie infinita no se utiliza en los c@'alculos.

@end deffn


@deffn {Funci@'on} bessel_k (@var{v}, @var{z})
Funci@'on modificada de Bessel de segunda especie de orden @math{v} y argumento @math{z}.

La funci@'on @code{bessel_k} se define como

@ifnottex
@example
           %pi csc(%pi v) (bessel_i(-v, z) - bessel_i(v, z))
           -------------------------------------------------
                                  2
@end example
@end ifnottex

@tex
$${{\pi\,\csc \left(\pi\,v\right)\,\left(I_{-v}(z)-I_{v}(z)\right)}\over{2}}$$
@end tex

si @math{v} no es un entero.  Si @math{v} es igual al entero @math{n}, entonces se calcula el l@'{@dotless{i}}mite cuando @math{v} tiende a @math{n}.
@end deffn


@deffn {Funci@'on} hankel_1 (@var{v}, @var{z})
Funci@'on de Hankel de primera especie de orden @math{v} y argumento @math{z}
(A&S 9.1.3). La funci@'on @code{hankel_1} se define como

@example
   bessel_j(v,z) + %i * bessel_y(v,z)
@end example

Maxima eval@'ua @code{hankel_1} num@'ericamente para el orden real @math{v}
y el argumento complejo @math{z} en doble precisi@'on (float). La evaluaci@'on
num@'erica en gran precisi@'on (bigfloat) y para @'ordenes complejos no est@'a
implementada.

Si @code{besselexpand} vale @code{true}, @code{hankel_1} se expande en 
t@'erminos de funciones elementales cuando el orden @math{v} es la mitad
de un entero impar. V@'ease al respecto @code{besselexpand}.

Maxima reconoce la derivada de @code{hankel_1} con respecto del argumento @math{z}.

Ejemplos:

Evaluaci@'on num@'erica:

@c ===beg===
@c hankel_1(1,0.5);
@c hankel_1(1,0.5+%i);
@c ===end===
@example
(%i1) hankel_1(1,0.5);
(%o1)              .2422684576748738 - 1.471472392670243 %i
(%i2) hankel_1(1,0.5+%i);
(%o2)             - .2558287994862166 %i - 0.239575601883016
@end example

No se soportan @'ordenes complejos. Maxima devuelve una forma nominal:

@c ===beg===
@c hankel_1(%i,0.5+%i);
@c ===end===
@example
(%i3) hankel_1(%i,0.5+%i);
(%o3)                       hankel_1(%i, %i + 0.5)
@end example

Expansi@'on de @code{hankel_1} cuando @code{besselexpand} vale @code{true}:

@c ===beg===
@c hankel_1(1/2,z),besselexpand:true;
@c ===end===
@example
(%i4) hankel_1(1/2,z),besselexpand:true;
                      sqrt(2) sin(z) - sqrt(2) %i cos(z)
(%o4)                 ----------------------------------
                              sqrt(%pi) sqrt(z)
@end example

Derivada de @code{hankel_1} respecto del argumento @math{z}. No est@'a
soportada la derivada respecto del orden @math{v}. Maxima devuelve una forma nominal:

@c ===beg===
@c diff(hankel_1(v,z),z);
@c diff(hankel_1(v,z),v);
@c ===end===
@example
(%i5) diff(hankel_1(v,z),z);
                    hankel_1(v - 1, z) - hankel_1(v + 1, z)
(%o5)               ---------------------------------------
                                       2
(%i6) diff(hankel_1(v,z),v);
                             d
(%o6)                        -- (hankel_1(v, z))
                             dv
@end example

@end deffn

@deffn {Funci@'on} hankel_2 (@var{v}, @var{z})
Funci@'on de Hankel de segunda especie de orden @math{v} y argumento @math{z}
(A&S 9.1.4). La funci@'on @code{hankel_2} se define como

@example
   bessel_j(v,z) - %i * bessel_y(v,z)
@end example

Maxima eval@'ua @code{hankel_2} num@'ericamente para el orden real @math{v}
y el argumento complejo @math{z} en doble precisi@'on (float). La evaluaci@'on
num@'erica en gran precisi@'on (bigfloat) y para @'ordenes complejos no est@'a
implementada.

Si @code{besselexpand} vale @code{true}, @code{hankel_2} se expande en 
t@'erminos de funciones elementales cuando el orden @math{v} es la mitad
de un entero impar. V@'ease al respecto @code{besselexpand}.

Maxima reconoce la derivada de @code{hankel_2} con respecto del argumento @math{z}.

V@'eanse ejemplos en @code{hankel_1}.

@end deffn

@defvr {Variable optativa} besselexpand
Valor por defecto: @code{false}

Controla la expansi@'on de las funciones de Bessel cuando el orden es la mitad de un entero impar. En tal caso, las funciones de Bessel se pueden expandir en t@'erminos de otras funciones elementales.  Si @code{besselexpand} vale @code{true}, se expande la funci@'on de Bessel.

@example
(%i1) besselexpand: false$
(%i2) bessel_j (3/2, z);
                                    3
(%o2)                      bessel_j(-, z)
                                    2
(%i3) besselexpand: true$
(%i4) bessel_j (3/2, z);
                                        sin(z)   cos(z)
                       sqrt(2) sqrt(z) (------ - ------)
                                           2       z
                                          z
(%o4)                  ---------------------------------
                                   sqrt(%pi)
@end example

@end defvr


@deffn {Funci@'on} scaled_bessel_i (@var{v}, @var{z})

Es la funci@'on de Bessel modificada de primera especie de
orden @math{v} y argumento @math{z}, es decir
@math{scaled_bessel_i(v,z) = exp(-abs(z))*bessel_i(v, z)}.
Esta funci@'on es especialmente @'util para calcular @math{bessel_i}
cuando @math{z} es grande. Sin embargo, Maxima no sabe mucho m@'as 
sobre esta funci@'on. En c@'alculos simb@'olicos, quiz@'as sea
preferible trabajar directamente con la expresi@'on 
@code{exp(-abs(z))*bessel_i(v, z)}.

@end deffn


@deffn {Funci@'on} scaled_bessel_i0 (@var{z})

Id@'entica a @code{scaled_bessel_i(0,z)}.

@end deffn

@deffn {Funci@'on} scaled_bessel_i1 (@var{z})

Id@'entica a @code{scaled_bessel_i(1,z)}.

@end deffn


@deffn {Funci@'on} %s [@var{u},@var{v}] (@var{z}) 

Funci@'on s[u,v](z) de Lommel.
Gradshteyn & Ryzhik 8.570.1.

@end deffn





@node Funciones de Airy, Funciones Gamma y factorial, Funciones de Bessel, Funciones Especiales
@section Funciones de Airy

Las funciones de Airy Ai(x) y Bi(x) se definen en la secci@'on 10.4.
de Abramowitz and Stegun, @i{Handbook of Mathematical Functions}.

@code{y = Ai(x)} y @code{y = Bi(x)} son dos soluciones linealmente
independientes de la ecuaci@'on diferencia de Airy
@code{diff (y(x), x, 2) - x y(x) = 0}.

Si el argumento @code{x} es un n@'umero decimal en coma flotante
real o complejo, se devolver@'a el valor num@'erico de la funci@'on.

@deffn {Funci@'on} airy_ai (@var{x})
Funci@'on de Airy Ai(x).  (A&S 10.4.2)

La derivada @code{diff (airy_ai(x), x)} es @code{airy_dai(x)}.

V@'eanse @code{airy_bi}, @code{airy_dai} y @code{airy_dbi}.
@end deffn


@deffn {Funci@'on} airy_dai (@var{x})
Es la derivada de la funci@'on Ai de Airy, @code{airy_ai(x)}. 

V@'ease @code{airy_ai}.
@end deffn


@deffn {Funci@'on} airy_bi (@var{x})
Es la funci@'on Bi de Airy, tal como la definen Abramowitz y Stegun,
@i{Handbook of Mathematical Functions}, Secci@'on 10.4. Se trata de la segunda soluci@'on de la ecuaci@'on de Airy @code{diff (y(x), x, 2) - x y(x) = 0}.

Si el argumento @code{x} es un n@'umero decimal real o complejo, se devolver@'a el valor num@'erico de @code{airy_bi} siempre que sea posible. En los otros casos, se devuelve la expresi@'on sin evaluar.

La derivada @code{diff (airy_bi(x), x)} es @code{airy_dbi(x)}.

V@'eanse @code{airy_ai} y @code{airy_dbi}.
@end deffn

@deffn {Funci@'on} airy_dbi (@var{x})
Es la derivada de la funci@'on Bi de Airy, @code{airy_bi(x)}.

V@'eanse @code{airy_ai} y @code{airy_bi}.
@end deffn





@node Funciones Gamma y factorial, Integral exponencial, Funciones de Airy, Funciones Especiales
@section Funciones Gamma y factorial

Las funciones gamma, beta, psi y gamma incompleta est@'an
definidas en el cap@'{@dotless{i}}tulo 6 de Abramowitz y Stegun,
@i{Handbook of Mathematical Functions}.




@deffn {Funci@'on} bffac (@var{expr}, @var{n})
Versi@'on para "bigfloat" de la funci@'on factorial (Gamma desplazada). El segundo argumento indica cu@'antos d@'{@dotless{i}}gitos se conservan y devuelven, pudiendo utilizarse para obtener algunas cifras extra.

@end deffn

@defvr {Variable optativa} algepsilon
Valor por defecto: 10^8

El valor de @code{algepsilon} es usado por @code{algsys}.

@end defvr



@deffn {Funci@'on} bfpsi (@var{n}, @var{z}, @var{fpprec})
@deffnx {Funci@'on} bfpsi0 (@var{z}, @var{fpprec})
La funci@'on @code{bfpsi} es la poligamma de argumento real @var{z} y de orden el entero @var{n}. La funci@'on @code{bfpsi0} es la digamma.  La llamada @code{bfpsi0 (@var{z}, @var{fpprec})} equivale a @code{bfpsi (0, @var{z}, @var{fpprec})}.

Estas funciones devuelven valores "bigfloat". La variable @var{fpprec} es la precisi@'on "bigfloat" del valor de retorno.

@c psi0(1) = -%gamma IS AN INTERESTING PROPERTY BUT IN THE ABSENCE OF ANY OTHER
@c DISCUSSION OF THE PROPERTIES OF THIS FUNCTION, THIS STATEMENT SEEMS OUT OF PLACE.
@c Note @code{-bfpsi0 (1, fpprec)} provides @code{%gamma} (Euler's constant) as a bigfloat.

@end deffn



@deffn {Funci@'on} cbffac (@var{z}, @var{fpprec})
Calcula el factorial de n@'umeros complejos de punto flotante grandes.

La instrucci@'on @code{load ("bffac")} carga esta funci@'on.

@end deffn



@deffn {Funci@'on} gamma (@var{x})

La definici@'on b@'asica de la funci@'on gamma (A&S 6.1.1) es

@ifnottex
@example
                               inf
                              /
                              [     z - 1   - t
                   gamma(z) = I    t      %e    dt
                              ]
                              /
                               0
@end example
@end ifnottex
@tex
$$\Gamma\left(z\right)=\int_{0}^{\infty }{t^{z-1}\,e^ {- t }\;dt}$$
@end tex

Maxima simplifica @code{gamma} para enteros positivos y para fracciones positivas
o negativas. Para fracciones de denominador dos, el resultado es un n@'umero 
racional multiplicado por @code{sqrt(%pi)}. La simplificaci@'on para valores
enteros la controla @code{factlim}. Para enteros mayores que @code{factlim}
el resultado num@'erico de la funci@'on factorial, la cual se utiliza para
calcular @code{gamma}, producir@'a un desbordamiento. La simplificaci@'on
para n@'umeros racionales la controla @code{gammalim} para evitar desbordamientos.
V@'eanse tambi@'en @code{factlim} y @code{gammalim}.

Para enteros negativos, @code{gamma} no est@'a definida.

Maxima puede evaluar @code{gamma} num@'ericamente para valores reales
y complejos, tanto en formato float (doble precisi@'on) como big float 
(precisi@'on arbitraria).

La funci@'on @code{gamma} tiene simetr@'{@dotless{i}}a especular.

Si @code{gamma_expand} vale @code{true}, Maxima expande @code{gamma}
para argumentos del tipo @code{z+n} y @code{z-n}, siendo @code{n}
un entero.

Maxima conoce la derivada de @code{gamma}.

Ejemplos:

Simplificaci@'on para enteros, fracciones de denominador dos
y n@'umeros racionales:

@example
(%i1) map('gamma,[1,2,3,4,5,6,7,8,9]);
(%o1)               [1, 1, 2, 6, 24, 120, 720, 5040, 40320]

(%i2) map('gamma,[1/2,3/2,5/2,7/2]);
                           sqrt(%pi)  3 sqrt(%pi)  15 sqrt(%pi)
(%o2)          [sqrt(%pi), ---------, -----------, ------------]
                               2           4            8

(%i3) map('gamma,[2/3,5/3,7/3]);
                                        2           1
                                2 gamma(-)  4 gamma(-)
                            2           3           3
(%o3)                [gamma(-), ----------, ----------]
                            3       3           9
@end example

Evaluaci@'on num@'erica para valores reales y complejos:

@example
(%i4) map('gamma,[2.5,2.5b0]);
(%o4)             [1.329340388179137, 1.329340388179137b0]

(%i5) map('gamma,[1.0+%i,1.0b0+%i]);
(%o5) [.4980156681183558 - .1549498283018108 %i, 
                      4.980156681183561b-1 - 1.549498283018107b-1 %i]
@end example

Simetr@'{@dotless{i}}a especular:

@example
(%i6) declare(z,complex)$
(%i7) conjugate(gamma(z));
(%o7)                         gamma(conjugate(z))
@end example

Maxima expande @code{gamma(z+n)} y @code{gamma(z-n)} si 
@code{gamma_expand} vale @code{true}:

@example
(%i8) gamma_expand:true$
(%i9) [gamma(z+1),gamma(z-1),gamma(z+2)/gamma(z+1)];
                                      gamma(z)
(%o9)                    [z gamma(z), --------, z + 1]
                                       z - 1
@end example

Derivada de @code{gamma}:

@example
(%i10) diff(gamma(z),z);
(%o10)                         psi (z) gamma(z)
                                  0
@end example

V@'ease tambi@'en @code{makegamma}.

La constante de Euler-Mascheroni es @code{%gamma}.
@end deffn


@deffn {Funci@'on} log_gamma (@var{z})
Logaritmo natural de la funci@'on gamma.
@end deffn

@deffn {Funci@'on} gamma_incomplete (@var{a},@var{z})
Funci@'on gamma incompleta superior, A&S 6.5.2:

@ifnottex
@example
                              inf
                             /
                             [     a - 1   - t
    gamma_incomplete(a, z) = I    t      %e    dt
                             ]
                             /
                              z
@end example
@end ifnottex
@tex
$$\Gamma\left(a , z\right)=\int_{z}^{\infty }{t^{a-1}\,e^ {- t }\;dt}$$
@end tex

V@'eanse tambi@'en @code{gamma_expand} para controlar c@'omo se expresa
@code{gamma_incomplete} en t@'erminos de funciones elementales y de @code{erfc}.

V@'eanse tambi@'en las funciones relacionadas @code{gamma_incomplete_regularized} y
@code{gamma_incomplete_generalized}.
@end deffn

@deffn {Funci@'on} gamma_incomplete_regularized (@var{a},@var{z})
Funci@'on gamma incompleta superior regularizada, A&S 6.5.1.

@ifnottex
@example
gamma_incomplete_regularized(a, z) = 
                                        gamma_incomplete(a, z)
                                        ----------------------
                                               gamma(a)
@end example
@end ifnottex
@tex
$${\it Q}\left(a , z\right)={{\Gamma\left(a , z\right)}\over{\Gamma\left(a\right)}}$$
@end tex

V@'eanse tambi@'en @code{gamma_expand} para controlar c@'omo se expresa
@code{gamma_incomplete} en t@'erminos de funciones elementales y de @code{erfc}.

V@'ease tambi@'en @code{gamma_incomplete}.
@end deffn

@deffn {Funci@'on} gamma_incomplete_generalized (@var{a},@var{z1},@var{z1})
Funci@'on gamma incompleta generalizada.  

@ifnottex
@example
gamma_incomplete_generalized(a, z1, z2) = 
                                               z2
                                              /
                                              [    a - 1   - t
                                              I   t      %e    dt
                                              ]
                                              /
                                               z1
@end example
@end ifnottex
@tex
$$\Gamma\left(a , z_{1}, z_{2}\right)=\int_{z_{1}}^{z_{2}}{t^{a-1}\,e^ {- t }\;dt}$$
@end tex

V@'eanse tambi@'en @code{gamma_incomplete} y @code{gamma_incomplete_regularized}.
@end deffn


@defvr {Variable opcional} gamma_expand
Valor por defecto: @code{false}

@code{gamma_expand} controla la expansi@'on de @code{gamma_incomplete}.
Si @code{gamma_expand} vale @code{true}, @code{gamma_incomplete(v,z)}
se expande en t@'erminos de
@code{z}, @code{exp(z)} y @code{erfc(z)}, siempre que sea posible.

@example
(%i1) gamma_incomplete(2,z);
(%o1)                       gamma_incomplete(2, z)
(%i2) gamma_expand:true;
(%o2)                                true
(%i3) gamma_incomplete(2,z);
                                           - z
(%o3)                            (z + 1) %e
@group
(%i4) gamma_incomplete(3/2,z);
                              - z   sqrt(%pi) erfc(sqrt(z))
(%o4)               sqrt(z) %e    + -----------------------
                                               2
@end group
@end example
@end defvr



@defvr {Variable optativa} gammalim
Valor por defecto: 1000000

La variable @code{gammalim} controla la simplificaci@'on de la funci@'on gamma con argumentos enteros o racionales. Si el valor absoluto del argumento no es mayor que @code{gammalim}, entonces se realizar@'a la simplificaci@'on. N@'otese que la variable @code{factlim} tambi@'en controla la simplificaci@'on del resultado de @code{gamma} con argumento entero.

@end defvr

@deffn {Funci@'on} makegamma (@var{expr})
Transforma las funciones @code{binomial}, @code{factorial} y @code{beta} que aparecen en @var{expr} en funciones @code{gamma}.

V@'ease tambi@'en @code{makefact}.

@end deffn


@deffn {Funci@'on} beta (@var{a}, @var{b})
La funci@'on beta se define como @code{gamma(a) gamma(b)/gamma(a+b)}
(A&S 6.2.1).

Maxima simplifica la funci@'on beta para enteros positivos y n@'umeros
racionales cuya suma sea entera. Si @code{beta_args_sum_to_integer}
vale @code{true}, Maxima tambi@'en simplifica expresiones generales
cuya suma sea tambi@'en entera.

Cuando @var{a} o @var{b} sean nulos, la funci@'on beta no est@'a definida.

En general, la funci@'on beta no est@'a definida para enteros negativos. 
La excepci@'on es para @var{a=-n}, siendo @var{n} un entero positivo
y @var{b} otro entero positivo tal que @var{b<=n}, entonces es posible
definir una continuaci@'on anal@'{@dotless{i}}tica. En este caso Maxima
devuelve un resultado.

Si @code{beta_expand} vale @code{true}, expresiones como @code{beta(a+n,b)},
@code{beta(a-n,b)}, @code{beta(a,b+n)} o @code{beta(a,b-n)}, siendo @code{n}
entero, se simplifican.

Maxima puede evaluar la funci@'on beta para valores reales y complejos, tanto
de tipo decimal flotante o big float. Para la evaluaci@'on num@'erica
Maxima utiliza @code{log_gamma}:

@example
           - log_gamma(b + a) + log_gamma(b) + log_gamma(a)
         %e
@end example

Maxima reconoce la simetr@'{@dotless{i}}a de la funci@'on beta.

Maxima conoce las derivadas de la funci@'on beta, tanto respecto de @var{a}
como de @var{b}.

Para expresar la funci@'on beta como un cociente de funciones gamma,
v@'ease @code{makegamma}.

Ejemplos:

Simplificaci@'on cuando uno de sus argumentos es entero:

@example
(%i1) [beta(2,3),beta(2,1/3),beta(2,a)];
                               1   9      1
(%o1)                         [--, -, ---------]
                               12  4  a (a + 1)
@end example

Simplificaci@'on para argumentos racionales que suman un entero:

@example
(%i2) [beta(1/2,5/2),beta(1/3,2/3),beta(1/4,3/4)];
                          3 %pi   2 %pi
(%o2)                    [-----, -------, sqrt(2) %pi]
                            8    sqrt(3)
@end example

Cuando se iguala @code{beta_args_sum_to_integer} a @code{true} se
simplifican expresiones m@'as generales si la suma de los argumentos
se reduce a un entero:

@example
(%i3) beta_args_sum_to_integer:true$
(%i4) beta(a+1,-a+2);
                                %pi (a - 1) a
(%o4)                         ------------------
                              2 sin(%pi (2 - a))
@end example

Posibles valores cuando uno de los argumentos es entero negativo: 

@example
(%i5) [beta(-3,1),beta(-3,2),beta(-3,3)];
                                    1  1    1
(%o5)                            [- -, -, - -]
                                    3  6    3
@end example

@code{beta(a+n,b)} o @code{beta(a-n)} con @code{n} entero se simplifica
si @code{beta_expand} vale @code{true}:

@example
(%i6) beta_expand:true$
(%i7) [beta(a+1,b),beta(a-1,b),beta(a+1,b)/beta(a,b+1)];
                    a beta(a, b)  beta(a, b) (b + a - 1)  a
(%o7)              [------------, ----------------------, -]
                       b + a              a - 1           b

@end example

La funci@'on beta no est@'a definida si uno de sus argumentos es cero:

@example
(%i7) beta(0,b);
beta: expected nonzero arguments; found 0, b
 -- an error.  To debug this try debugmode(true);
@end example

Evaluaci@'on num@'erica para argumentos reales y complejos de tipo
decimal flotante o big float:

@example
(%i8) beta(2.5,2.3);
(%o8) .08694748611299981

(%i9) beta(2.5,1.4+%i);
(%o9) 0.0640144950796695 - .1502078053286415 %i

(%i10) beta(2.5b0,2.3b0);
(%o10) 8.694748611299969b-2

(%i11) beta(2.5b0,1.4b0+%i);
(%o11) 6.401449507966944b-2 - 1.502078053286415b-1 %i
@end example

La funci@'on beta es sim@'etrica con simetr@'{@dotless{i}}a especular:

@example
(%i14) beta(a,b)-beta(b,a);
(%o14)                                 0
(%i15) declare(a,complex,b,complex)$
(%i16) conjugate(beta(a,b));
(%o16)                 beta(conjugate(a), conjugate(b))
@end example

Derivada de la funci@'on beta respecto de @code{a}:

@example
(%i17) diff(beta(a,b),a);
(%o17)               - beta(a, b) (psi (b + a) - psi (a))
                                      0             0
@end example
@end deffn

@deffn {Funci@'on} beta_incomplete (@var{a}, @var{b}, @var{z})
La definici@'on b@'asica de la funci@'on beta incompleta (A&S 6.6.1) es

@example
                       z
                      /
                      [         b - 1  a - 1
                      I  (1 - t)      t      dt
                      ]
                      /
                       0
@end example

Esta definici@'on es posible para @math{realpart(a)>0}, @math{realpart(b)>0}
y @math{abs(z)<1}. Para otras situaciones, la funci@'on beta incompleta puede
definirse por medio de una funci@'on hipergeom@'etrica generalizada:

@example
   gamma(a) hypergeometric_generalized([a, 1 - b], [a + 1], z) z
@end example
(V@'ease Funci@'ons.wolfram.com para una completa definici@'on de la funci@'on beta 
incompleta.)

Para enteros negativos @math{a = -n} y enteros positivos @math{b=m} con 
@math{m<=n} la funci@'on beta incompleta se define como

@example
                            m - 1           k
                            ====  (1 - m)  z
                      n - 1 \            k
                     z       >    -----------
                            /     k! (n - k)
                            ====
                            k = 0
@end example
Maxima utiliza esta definici@'on para simplificar @code{beta_incomplete} 
cuando @var{a} es entero negativo.

Cuando @var{a} es entero positivo, @code{beta_incomplete} se simplifica
para cualesquiera argumentos @var{b} y @var{z}, y para @var{b} entero
positivo para cualesquiera argumentos @var{a} y @var{z}, con la 
excepci@'on de cuando @var{a} sea entero negativo.

Para @math{z=0} y @math{realpart(a)>0}, @code{beta_incomplete} se anula.
Para @var{z=1} y @math{realpart(b)>0}, @code{beta_incomplete} se reduce a
la funci@'on @code{beta(a,b)}.

Maxima eval@'ua @code{beta_incomplete} num@'ericamente para valores reales
y complejos en forma decimal y big float. La evaluaci@'on num@'erica se
realiza expandiendo la funci@'on beta incompleta en fracciones continuas.

Si @code{beta_expand} vale @code{true}, Maxima expande las expresiones
@code{beta_incomplete(a+n,b,z)} y @code{beta_incomplete(a-n,b,z)},
siendo @var{n} entero positivo.

Maxima conoce las derivadas de @code{beta_incomplete} con respecto a
las variables @var{a}, @var{b} y @var{z}, as@'{@dotless{i}} como la
integral respecto de la variable @var{z}.

Ejemplos:

Simplificaci@'on para @var{a} entero positivo:

@example
(%i1) beta_incomplete(2,b,z);
                                       b
                            1 - (1 - z)  (b z + 1)
(%o1)                       ----------------------
                                  b (b + 1)
@end example

Simplificaci@'on para @var{b} entero positivo:

@example
(%i2) beta_incomplete(a,2,z);
                                               a
                              (a (1 - z) + 1) z
(%o2)                         ------------------
                                  a (a + 1)
@end example

Simplificaci@'on para @var{a} y @var{b} enteros positivos:

@example
(%i3) beta_incomplete(3,2,z);
                                               3
                              (3 (1 - z) + 1) z
(%o3)                         ------------------
                                      12
@end example

Para @var{a} entero negativo y @math{b<=(-a)}:

@example
(%i4) beta_incomplete(-3,1,z);
                                       1
(%o4)                              - ----
                                        3
                                     3 z
@end example

Simplificaci@'on para los valores @math{z=0} y @math{z=1}:

@example
(%i5) assume(a>0,b>0)$
(%i6) beta_incomplete(a,b,0);
(%o6)                                 0
(%i7) beta_incomplete(a,b,1);
(%o7)                            beta(a, b)
@end example

Evaluaci@'on num@'erica, tanto con float (precisi@'on doble)
como big float (precisi@'on arbitraria):

@example
(%i8) beta_incomplete(0.25,0.50,0.9);
(%o8)                          4.594959440269333
(%i9)  fpprec:25$
(%i10) beta_incomplete(0.25,0.50,0.9b0);
(%o10)                    4.594959440269324086971203b0
@end example

Para @math{abs(z)>1}, @code{beta_incomplete} devuelve un
resultado complejo:

@example
(%i11) beta_incomplete(0.25,0.50,1.7);
(%o11)              5.244115108584249 - 1.45518047787844 %i
@end example

Resultados para argumentos complejos m@'as generales:

@example
(%i14) beta_incomplete(0.25+%i,1.0+%i,1.7+%i);
(%o14)             2.726960675662536 - .3831175704269199 %i
(%i15) beta_incomplete(1/2,5/4*%i,2.8+%i);
(%o15)             13.04649635168716 %i - 5.802067956270001
(%i16) 
@end example

Expansi@'on cuando @code{beta_expand} vale @code{true}:

@example
(%i23) beta_incomplete(a+1,b,z),beta_expand:true;
                                                       b  a
                   a beta_incomplete(a, b, z)   (1 - z)  z
(%o23)             -------------------------- - -----------
                             b + a                 b + a

(%i24) beta_incomplete(a-1,b,z),beta_expand:true;
                                                           b  a - 1
           beta_incomplete(a, b, z) (- b - a + 1)   (1 - z)  z
(%o24)     -------------------------------------- - ---------------
                           1 - a                         1 - a
@end example
 
Derivada e integral de @code{beta_incomplete}:

@example
@example
(%i34) diff(beta_incomplete(a, b, z), z);
                              b - 1  a - 1
(%o34)                 (1 - z)      z
(%i35) integrate(beta_incomplete(a, b, z), z);
              b  a
       (1 - z)  z
(%o35) ----------- + beta_incomplete(a, b, z) z
          b + a
                                       a beta_incomplete(a, b, z)
                                     - --------------------------
                                                 b + a
(%i36) factor(diff(%, z));
(%o36)              beta_incomplete(a, b, z)
@end example

@end example
@end deffn

@deffn {Funci@'on} beta_incomplete_regularized (@var{a}, @var{b}, @var{z})
Funci@'on beta incompleta regularizada A&S 6.6.2,
definida como

@example
beta_incomplete_regularized(a, b, z) = 
                                      beta_incomplete(a, b, z)
                                      ------------------------
                                             beta(a, b)
@end example

Al igual que @code{beta_incomplete}, esta definici@'on no es completa.
V@'ease Funci@'ons.wolfram.com para una definici@'on completa de 
@code{beta_incomplete_regularized}.

@code{beta_incomplete_regularized} se simplifica para @var{a} o @var{b} 
entero positivo.

Para @math{z=0} y @math{realpart(a)>0}, @code{beta_incomplete_regularized} se anula.
Para @var{z=1} y @math{realpart(b)>0}, @code{beta_incomplete_regularized} se reduce a 1.

Maxima eval@'ua @code{beta_incomplete_regularized} num@'ericamente para valores reales
y complejos en forma decimal y big float.

Si @code{beta_expand} vale @code{true}, Maxima expande 
@code{beta_incomplete_regularized} para los argumentos @math{a+n} o @math{a-n},
siendo @var{n} entero.

Maxima conoce las derivadas de @code{beta_incomplete_regularized} con respecto a
las variables @var{a}, @var{b} y @var{z}, as@'{@dotless{i}} como la
integral respecto de la variable @var{z}.

Ejemplos:

Simplificaci@'on para @var{a} o @var{b} enteros positivos:

@example
(%i1) beta_incomplete_regularized(2,b,z);
                                       b
(%o1)                       1 - (1 - z)  (b z + 1)

(%i2) beta_incomplete_regularized(a,2,z);
                                               a
(%o2)                         (a (1 - z) + 1) z

(%i3) beta_incomplete_regularized(3,2,z);
                                               3
(%o3)                         (3 (1 - z) + 1) z
@end example

Simplificaci@'on para los valores @math{z=0} y @math{z=1}:

@example
(%i4) assume(a>0,b>0)$
(%i5) beta_incomplete_regularized(a,b,0);
(%o5)                                 0
(%i6) beta_incomplete_regularized(a,b,1);
(%o6)                                 1
@end example

Evaluaci@'on num@'erica, tanto con float (precisi@'on doble)
como big float (precisi@'on arbitraria):

@example
(%i7) beta_incomplete_regularized(0.12,0.43,0.9);
(%o7)                         .9114011367359802
(%i8) fpprec:32$
(%i9) beta_incomplete_regularized(0.12,0.43,0.9b0);
(%o9)               9.1140113673598075519946998779975b-1
(%i10) beta_incomplete_regularized(1+%i,3/3,1.5*%i);
(%o10)             .2865367499935403 %i - 0.122995963334684
(%i11) fpprec:20$
(%i12) beta_incomplete_regularized(1+%i,3/3,1.5b0*%i);
(%o12)      2.8653674999354036142b-1 %i - 1.2299596333468400163b-1
@end example

Expansi@'on cuando @code{beta_expand} vale @code{true}:

@example
(%i13) beta_incomplete_regularized(a+1,b,z);
                                                     b  a
                                              (1 - z)  z
(%o13) beta_incomplete_regularized(a, b, z) - ------------
                                              a beta(a, b)
(%i14) beta_incomplete_regularized(a-1,b,z);
(%o14) beta_incomplete_regularized(a, b, z)
                                                     b  a - 1
                                              (1 - z)  z
                                         - ----------------------
                                           beta(a, b) (b + a - 1)

@end example

Derivada e integral respecto de @var{z}:

@example
(%i15) diff(beta_incomplete_regularized(a,b,z),z);
                              b - 1  a - 1
                       (1 - z)      z
(%o15)                 -------------------
                           beta(a, b)
(%i16) integrate(beta_incomplete_regularized(a,b,z),z);
(%o16) beta_incomplete_regularized(a, b, z) z
                                                           b  a
                                                    (1 - z)  z
          a (beta_incomplete_regularized(a, b, z) - ------------)
                                                    a beta(a, b)
        - -------------------------------------------------------
                                   b + a
@end example

@end deffn

@deffn {Funci@'on} beta_incomplete_generalized (@var{a}, @var{b}, @var{z1}, @var{z2})
La definici@'on b@'asica de la funci@'on beta incompleta generalizada es

The basic definition of the generalized incomplete beta function is

@example
                      z2
                     /
                     [          b - 1  a - 1
                     I   (1 - t)      t      dt
                     ]
                     /
                      z1
@end example

Maxima simplifica @code{beta_incomplete_regularized} para @var{a} y @var{b} 
enteros positivos.

Para @math{realpart(a)>0} y @math{z1=0} o @math{z2=0}, Maxima reduce
@code{beta_incomplete_generalized} a @code{beta_incomplete}. Para
@math{realpart(b)>0} y @math{z1=1} o @var{z2=1}, Maxima reduce a
una expresi@'on con @code{beta} y @code{beta_incomplete}.

Maxima eval@'ua @code{beta_incomplete_generalized} num@'ericamente para valores reales
y complejos en forma decimal y big float.

Si @code{beta_expand} vale @code{true}, Maxima expande 
@code{beta_incomplete_generalized} para los argumentos @math{a+n} y @math{a-n},
siendo @var{n} entero positivo.

Maxima conoce las derivadas de @code{beta_incomplete_generalized} con respecto a
las variables @var{a}, @var{b}, @var{z1} y @var{z2}, as@'{@dotless{i}} como la
integral respecto de las variables @var{z1} y @var{z2}.

Ejemplos:

Maxima simplifica @code{beta_incomplete_generalized} para @var{a} y @var{b}
enteros positivos:
@example
(%i1) beta_incomplete_generalized(2,b,z1,z2);
                          b                      b
                  (1 - z1)  (b z1 + 1) - (1 - z2)  (b z2 + 1)
(%o1)             -------------------------------------------
                                   b (b + 1)

(%i2) beta_incomplete_generalized(a,2,z1,z2);
                                     a                      a
                  (a (1 - z2) + 1) z2  - (a (1 - z1) + 1) z1
(%o2)             -------------------------------------------
                                   a (a + 1)

(%i3) beta_incomplete_generalized(3,2,z1,z2);
                  2      2                       2      2
          (1 - z1)  (3 z1  + 2 z1 + 1) - (1 - z2)  (3 z2  + 2 z2 + 1)
(%o3)     -----------------------------------------------------------
                                      12
@end example

Simplificaci@'on para los valores @math{z1=0}, @math{z2=0}, @math{z1=1}
o @math{z2=1}:
@example
(%i4) assume(a > 0, b > 0)$
(%i5) beta_incomplete_generalized(a,b,z1,0);
(%o5)                    - beta_incomplete(a, b, z1)

(%i6) beta_incomplete_generalized(a,b,0,z2);
(%o6)                    - beta_incomplete(a, b, z2)

(%i7) beta_incomplete_generalized(a,b,z1,1);
(%o7)              beta(a, b) - beta_incomplete(a, b, z1)

(%i8) beta_incomplete_generalized(a,b,1,z2);
(%o8)              beta_incomplete(a, b, z2) - beta(a, b)
@end example

Evaluaci@'on num@'erica para argumentos reales, tanto con float
(precisi@'on doble) como big float (precisi@'on arbitraria):
@example
(%i9) beta_incomplete_generalized(1/2,3/2,0.25,0.31);
(%o9)                        .09638178086368676

(%i10) fpprec:32$
(%i10) beta_incomplete_generalized(1/2,3/2,0.25,0.31b0);
(%o10)               9.6381780863686935309170054689964b-2
@end example

Evaluaci@'on num@'erica para argumentos complejos, tanto con float
(precisi@'on doble) como big float (precisi@'on arbitraria):
@example
(%i11) beta_incomplete_generalized(1/2+%i,3/2+%i,0.25,0.31);
(%o11)           - .09625463003205376 %i - .003323847735353769
(%i12) fpprec:20$
(%i13) beta_incomplete_generalized(1/2+%i,3/2+%i,0.25,0.31b0);
(%o13)     - 9.6254630032054178691b-2 %i - 3.3238477353543591914b-3
@end example

Expansi@'on para @math{a+n} o @math{a-n}, siendo @var{n} entero positivo
con @code{beta_expand} igual @code{true}:
@example
(%i14) beta_expand:true$
(%i15) beta_incomplete_generalized(a+1,b,z1,z2);
               b   a           b   a
       (1 - z1)  z1  - (1 - z2)  z2
(%o15) -----------------------------
                   b + a
                            a beta_incomplete_generalized(a, b, z1, z2)
                          + -------------------------------------------
                                               b + a

(%i16) beta_incomplete_generalized(a-1,b,z1,z2);
       beta_incomplete_generalized(a, b, z1, z2) (- b - a + 1)
(%o16) -------------------------------------------------------
                                1 - a
                                          b   a - 1           b   a - 1
                                  (1 - z2)  z2      - (1 - z1)  z1
                                - -------------------------------------
                                                  1 - a
@end example

Derivada respecto de la variable @var{z1} e integrales respecto de 
@var{z1} y @var{z2}:
@example
(%i17) diff(beta_incomplete_generalized(a,b,z1,z2),z1);
                                      b - 1   a - 1
(%o17)                      - (1 - z1)      z1

(%i18) integrate(beta_incomplete_generalized(a,b,z1,z2),z1);
(%o18) beta_incomplete_generalized(a, b, z1, z2) z1
                                        + beta_incomplete(a + 1, b, z1)

(%i19) integrate(beta_incomplete_generalized(a,b,z1,z2),z2);
(%o19) beta_incomplete_generalized(a, b, z1, z2) z2
                                        - beta_incomplete(a + 1, b, z2)
@end example
@end deffn


@defvr {Variable opcional} beta_expand
Valor por defecto: false

Si @code{beta_expand} vale @code{true}, @code{beta(a,b)} y sus
funciones relacionadas se expanden para argumentos del tipo 
@math{a+n} o @math{a-n}, siendo @math{n} un n@'umero entero.
@end defvr

@defvr {Variable opcional} beta_args_sum_to_integer
Valor por defecto: false

Si @code{beta_args_sum_to_integer} vale @code{true}, Maxima simplifica 
@code{beta(a,b)} cuando la suma de los argumentos @var{a} y @var{b} sea un entero.
@end defvr



@deffn {Funci@'on} psi [@var{n}](@var{x})

Es la derivada de @code{log (gamma (@var{x}))} de orden @code{@var{n}+1},
de tal manera que @code{psi[0](@var{x})} es la primera derivada, 
@code{psi[1](@var{x})} la segunda derivada y as@'{@dotless{i}} 
sucesivamente.

En general, Maxima no sabe c@'omo calcular valores num@'ericos de 
@code{psi}, pero s@'{@dotless{i}} conoce el valor exacto para
algunos argumentos racionales.
Existen algunas variables globales para controlar en qu@'e rangos
racionales debe devolver @code{psi} resultados exactos, si ello es posible.
V@'eanse las descripciones de @code{maxpsiposint}, @code{maxpsinegint},
@code{maxpsifracnum} y @code{maxpsifracdenom}.
En resumen, @var{x} debe alcanzar un valor entre @code{maxpsinegint} y
@code{maxpsiposint}. Si el valor absoluto de la parte fraccional de
@var{x} es racional y tiene un numerador menor que @code{maxpsifracnum}
y un denominador menor que @code{maxpsifracdenom}, la funci@'on @code{psi}
devolver@'a un valor exacto.

La funci@'on @code{bfpsi} del paquete @code{bffac} puede calcular
valores num@'ericos.

@end deffn

@defvr {Variable opcional} maxpsiposint
Valor por defecto: 20

La variable @code{maxpsiposint} guarda el mayor valor positivo para el 
que @code{psi[n](x)} intentar@'a calcular un valor exacto.

@end defvr

@defvr {Variable opcional} maxpsinegint
Valor por defecto: -10

La variable @code{maxpsinegint} guarda el menor valor negativo para el
que @code{psi[n](x)} intentar@'a calcular un valor exacto. Si
@var{x} es menor que @code{maxnegint}, @code{psi[n](@var{x})} no devolver@'a
una respuesta simplificada, aunque supiese c@'omo hacerlo.

@end defvr


@defvr {Variable opcional} maxpsifracnum
Valor por defecto: 6

Sea @var{x} un n@'umero racional menor que la unidad de la forma @code{p/q}.
Si @code{p} es mayor que @code{maxpsifracnum}, entonces
@code{psi[@var{n}](@var{x})} no devolver@'a una respuesta simplificada.

@end defvr

@defvr {Variable opcional} maxpsifracdenom
Valor por defecto: 6

Sea @var{x} un n@'umero racional menor que la unidad de la forma @code{p/q}.
Si @code{q} es mayor que @code{maxpsifracnum}, entonces
@code{psi[@var{n}](@var{x})} no devolver@'a una respuesta simplificada.

@end defvr


@deffn {Funci@'on} makefact (@var{expr})
Transforma las funciones @code{binomial}, @code{gamma} y @code{beta} que aparecen en @var{expr} en su notaci@'on factorial.

V@'ease tambi@'en @code{makegamma}.

@end deffn


@deffn {Funci@'on} numfactor (@var{expr})
Devuelve el factor num@'erico que multiplica a la expresi@'on @var{expr}, la cual debe tener un @'unico t@'ermino. 

@example
(%i1) gamma (7/2);
                          15 sqrt(%pi)
(%o1)                     ------------
                               8
(%i2) numfactor (%);
                               15
(%o2)                          --
                               8
@end example

@end deffn







@node Integral exponencial, Funci@'on de error, Funciones Gamma y factorial, Funciones Especiales
@section Integral exponencial

La integral exponencial y sus funciones relacionadas se 
definen en el cap@'{@dotless{i}}tulo 5 de Abramowitz y Stegun, 
@i{Handbook of Mathematical Functions}.


@deffn {Funci@'on} expintegral_e1 (@var{z})
La integral exponencial E1(z) (A&S 5.1.1)
@end deffn

@deffn {Funci@'on} expintegral_ei (@var{z})
La integral exponencial Ei(z) (A&S 5.1.2)
@end deffn

@deffn {Funci@'on} expintegral_li (@var{z})
La integral exponencial Li(z)  (A&S 5.1.3)
@end deffn

@deffn {Funci@'on} expintegral_e (@var{n},@var{z})
La integral exponencial En(z)  (A&S 5.1.4)
@end deffn

@deffn {Funci@'on} expintegral_si (@var{z})
La integral exponencial Si(z) (A&S 5.2.1)
@end deffn

@deffn {Funci@'on} expintegral_ci (@var{z})
La integral exponencial Ci(z) (A&S 5.2.2)
@end deffn

@deffn {Funci@'on} expintegral_shi (@var{z})
La integral exponencial Shi(z) (A&S 5.2.3)
@end deffn

@deffn {Funci@'on} expintegral_chi (@var{z})
La integral exponencial Chi(z) (A&S 5.2.4)
@end deffn

@defvr {Option variable} expintrep
Valor por defecto: false

Transforma la representaci@'on de la integral exponencial
en t@'erminos de las funciones @code{gamma_incomplete}, 
@code{expintegral_e1}, @code{expintegral_ei}, 
@code{expintegral_li}, @code{expintegral_trig} y @code{expintegral_hyp}.
@end defvr

@defvr {Option variable} expintexpand 
Valor por defecto: false

Expande la integral exponencial E[n](z)
para valores medios de la integral en t@'erminos de 
las funciones Erfc o Erf y para positivos enteros
en t@'erminos de Ei .
@end defvr





@node Funci@'on de error, Funciones de Struve, Integral exponencial, Funciones Especiales
@section Funci@'on de error

La funci@'on de error y sus asociadas se definen en el 
cap@'{@dotless{i}}tulo 7 de Abramowitz y Stegun, 
@i{Handbook of Mathematical Functions}.


@deffn {Funci@'on} erf (@var{z})
Funci@'on de error erf(z) (A&S 7.1.1)

V@'ease tambi@'en @code{erfflag}.
@end deffn

@deffn {Funci@'on} erfc (@var{z})
Complemento de la funci@'on de error erfc(z) (A&S 7.1.2)

@code{erfc(z) = 1-erf(z)}
@end deffn

@deffn {Funci@'on} erfi (@var{z})
Funci@'on de error imaginaria. 

@code{erfi(z) = -%i*erf(%i*z)}
@end deffn

@deffn {Funci@'on} erf_generalized (@var{z1},@var{z2})
Funci@'on de error generalizada Erf(z1,z2)
@end deffn


@deffn {Funci@'on} fresnel_c (@var{z})
Integral de Fresnel C(z) = integrate(cos((%pi/2)*t^2),t,0,z). (A&S 7.3.1)

La simplificaci@'on fresnel_c(-x) = -fresnel_c(x) se aplica cuando
la variable global @code{trigsign} vale @code{true}.

La simplificaci@'on fresnel_c(%i*x) =  %i*fresnel_c(x) se aplica cuando
la variable global @code{%iargs} vale @code{true}.

V@'eanse tambi@'en @code{erf_representation} y
@code{hypergeometric_representation}.
@end deffn

@deffn {Funci@'on} fresnel_s (@var{z})
Integral de Fresnel S(z) = integrate(sin((%pi/2)*t^2),t,0,z). (A&S 7.3.2)

La simplificaci@'on fresnel_s(-x) = -fresnel_s(x) se aplica cuando
la variable global @code{trigsign} vale @code{true}.

La simplificaci@'on fresnel_s(%i*x) =  %i*fresnel_s(x) se aplica cuando
la variable global @code{%iargs} vale @code{true}.

V@'eanse tambi@'en @code{erf_representation} y
@code{hypergeometric_representation}.
@end deffn

@defvr {Variable opcional} erf_representation
Valor por defecto: false

Cuando valga @code{true} erfc, erfi, erf_generalized, fresnel_s 
y fresnel_c se transforman a erf.
@end defvr

@defvr {Variable opcional} hypergeometric_representation
Valor por defecto: false

Permite obtener la representaci@'on hipergeom@'etrica
de las funciones fresnel_s y fresnel_c.
@end defvr







@node Funciones de Struve, Funciones hipergeom@'etricas, Funci@'on de error, Funciones Especiales
@section Funciones de Struve

Las funciones de Struve se definen en el cap@'{@dotless{i}}tulo
12 de Abramowitz y Stegun, @i{Handbook of Mathematical Functions}.

@deffn {Funci@'on} struve_h (@var{v}, @var{z})
Funci@'on H de Struve de orden @var{v} y argumento @var{z}, (A&S 12.1.1).

@end deffn

@deffn {Funci@'on} struve_l (@var{v}, @var{z})
Funci@'on L modificada de Struve de orden @var{v} y argumento @var{z}, (A&S 12.2.1).

@end deffn





@node Funciones hipergeom@'etricas, Funciones de cilindro parab@'olico, Funciones de Struve, Funciones Especiales
@section Funciones hipergeom@'etricas

Las funciones hipergeom@'etricas se definen en los cap@'{@dotless{i}}tulos
13 y 15 de Abramowitz y Stegun, @i{Handbook of Mathematical Functions}. 

Maxima tiene un soporte limitado sobre estas funciones, que pueden
aparecer en resultados devueltos por @code{hgfred}.

@deffn {Funci@'on} %m [@var{k},@var{u}] (@var{z}) 
Funci@'on M de Whittaker
@code{M[k,u](z) = exp(-z/2)*z^(1/2+u)*M(1/2+u-k,1+2*u,z)}.  
(A&S 13.1.32)
@end deffn

@deffn {Funci@'on} %w [@var{k},@var{u}] (@var{z}) 
Funci@'on W de Whittaker.  (A&S 13.1.33)
@end deffn


@deffn {Funci@'on} %f [@var{p},@var{q}] (@var{[a],[b],z}) 
Es la funci@'on hipergeom@'etrica pFq(a1,a2,..ap;b1,b2,..bq;z),
donde @code{a} es una lista de longitud @code{p} y 
@code{b} otra lista de longitud @code{q}.
@end deffn


@deffn {Funci@'on} hypergeometric ([@var{a1}, ..., @var{ap}],[@var{b1}, ... ,@var{bq}], x)
Es la funci@'on hipergeom@'etrica. A diferencia de la funci@'on
hipergeom@'etrica @code{%f} de Maxima, la funci@'on @code{hypergeometric}
es simplificadora; adem@'as, @code{hypergeometric} soporta la evaluaci@'on
en doble (float) y gran (bigfloat) precisi@'on. La evaluaci@'on 
num@'erica fuera del c@'{@dotless{i}}rculo unidad no est@'a en general
soportada, pero s@'{@dotless{i}} en el caso de la funci@'on
hipergeom@'etrica de Gauss, cuando @math{p = 2} y @math{q = 1}.

Si la variable opcional @code{expand_hypergeometric} vale @code{true},
(el valor por defecto es @code{false}) y uno de los argumentos entr @code{a1}
y @code{ap} es entero negativo (caso polinomial), entonces @code{hypergeometric}
devuelve un polinomio expandido.

Ejemplos:
@example
(%i1)  hypergeometric([],[],x);
(%o1) %e^x
@end example

Los polinomios se expanden autom@'aticamente cuando @code{expand_hypergeometric}
vale @code{true}.

@example
(%i2) hypergeometric([-3],[7],x);
(%o2) hypergeometric([-3],[7],x)

(%i3) hypergeometric([-3],[7],x), expand_hypergeometric : true;
(%o3) -x^3/504+3*x^2/56-3*x/7+1
@end example

Se soporta la evaluaci@'on en doble (float) y gran (bigfloat) precisi@'on:

@example
(%i4) hypergeometric([5.1],[7.1 + %i],0.42);
(%o4)       1.346250786375334 - 0.0559061414208204 %i
(%i5) hypergeometric([5,6],[8], 5.7 - %i);
(%o5)     .007375824009774946 - .001049813688578674 %i
(%i6) hypergeometric([5,6],[8], 5.7b0 - %i), fpprec : 30;
(%o6) 7.37582400977494674506442010824b-3
                          - 1.04981368857867315858055393376b-3 %i
@end example
@end deffn









@node Funciones de cilindro parab@'olico, Funciones y variables para las funciones especiales, Funciones hipergeom@'etricas, Funciones Especiales
@section  Funciones de cilindro parab@'olico

Las funciones de cilindro parab@'olico se definen en el cap@'{@dotless{i}}tulo
19 de Abramowitz y Stegun, @i{Handbook of Mathematical Functions}. 

Maxima tiene un soporte limitado sobre estas funciones, que pueden
aparecer en resultados devueltos por @code{hgfred}.

@deffn {Funci@'on} parabolic_cylinder_d (@var{v}, @var{z}) 
Funci@'on de cilindro parab@'olico @code{parabolic_cylinder_d(v,z)}. (A&s 19.3.1)
@end deffn











@node Funciones y variables para las funciones especiales,  , Funciones de cilindro parab@'olico, Funciones Especiales
@section Funciones y variables para las funciones especiales


@deffn {Funci@'on} specint (exp(- s*@var{t}) * @var{expr}, @var{t})

Calcula la transformada de Laplace de @var{expr} respecto de
la variable @var{t}. El integrando @var{expr} puede contener
funciones especiales.

La funci@'on @code{specint} admite las funciones especiales siguientes:
la gamma incompleta, las funciones de error (pero no @code{erfi}, siendo
sencillo transformar @code{erfi} en la funci@'on de error @code{erf}),
integrales exponenciales, funciones de Bessel (incluidos productos de
funciones de Bessel), funciones de Hankel, de Hermite y los polinomios de
Laguerre.

Adem@'as, @code{specint} tambi@'en admite la funci@'on hipergeom@'etrica
@code{%f[p,q]([],[],z)}, la funci@'on de Whittaker de primera especie
@code{%m[u,k](z)} y la de segunda especie @code{%w[u,k](z)}.

El resultado puede darse en t@'erminos de funciones especiales y es
posible que incluya tambi@'en funciones hipergeom@'etricas sin
simplificar.

Cuando @code{laplace} es incapaz de calcular la transformada de Laplace,
entonces llama a la funci@'on @code{specint}. Puesto que @code{laplace}
tiene programadas m@'as reglas para calcular transformadas de Laplace,
es preferible utilizar @code{laplace} en lugar de @code{specint}.

La ejecuci@'on de @code{demo(hypgeo)} muestra algunos ejemplos de
transformadas de Laplace calculadas con @code{specint}.

Ejemplos:
@c ===beg===
@c assume (p > 0, a > 0)$
@c specint (t^(1/2) * exp(-a*t/4) * exp(-p*t), t);
@c specint (t^(1/2) * bessel_j(1, 2 * a^(1/2) * t^(1/2))
@c               * exp(-p*t), t);
@c ===end===

@example
(%i1) assume (p > 0, a > 0)$
(%i2) specint (t^(1/2) * exp(-a*t/4) * exp(-p*t), t);
                           sqrt(%pi)
(%o2)                     ------------
                                 a 3/2
                          2 (p + -)
                                 4
(%i3) specint (t^(1/2) * bessel_j(1, 2 * a^(1/2) * t^(1/2))
              * exp(-p*t), t);
                                   - a/p
                         sqrt(a) %e
(%o3)                    ---------------
                                2
                               p
@end example

Ejemplos para integrales exponenciales:

@example
(%i4) assume(s>0,a>0,s-a>0)$
(%i5) ratsimp(specint(%e^(a*t)
                      *(log(a)+expintegral_e1(a*t))*%e^(-s*t),t));
                             log(s)
(%o5)                        ------
                             s - a
(%i6) logarc:true$

(%i7) gamma_expand:true$

radcan(specint((cos(t)*expintegral_si(t)
                     -sin(t)*expintegral_ci(t))*%e^(-s*t),t));
                             log(s)
(%o8)                        ------
                              2
                             s  + 1
ratsimp(specint((2*t*log(a)+2/a*sin(a*t)
                      -2*t*expintegral_ci(a*t))*%e^(-s*t),t));
                               2    2
                          log(s  + a )
(%o9)                     ------------
                                2
                               s
@end example

Resultados cuando se utiliza la expansi@'on de @code{gamma_incomplete}
y se cambia la representaci@'on de @code{expintegral_e1}:

@example
(%i10) assume(s>0)$
(%i11) specint(1/sqrt(%pi*t)*unit_step(t-k)*%e^(-s*t),t);
                                            1
                            gamma_incomplete(-, k s)
                                            2
(%o11)                      ------------------------
                               sqrt(%pi) sqrt(s)

(%i12) gamma_expand:true$
(%i13) specint(1/sqrt(%pi*t)*unit_step(t-k)*%e^(-s*t),t);
                              erfc(sqrt(k) sqrt(s))
(%o13)                        ---------------------
                                     sqrt(s)

(%i14) expintrep:expintegral_e1$
(%i15) ratsimp(specint(1/(t+a)^2*%e^(-s*t),t));
                              a s
                        a s %e    expintegral_e1(a s) - 1
(%o15)                - ---------------------------------
                                        a
@end example
@end deffn


@deffn {Funci@'on} hgfred (@var{a}, @var{b}, @var{t})

Simplifica la funci@'on hipergeom@'etrica generalizada en t@'erminos
de otras funciones m@'as sencillas. @var{a} es una lista de par@'ametros
del numerador y @var{b} lo es de par@'ametros del denominador.

En caso de que @code{hgfred} no pueda simplificar la funci@'on hipergeom@'etrica
devolver@'a una expresi@'on de la forma @code{%f[p,q]([a], [b], x)}, siendo @var{p}
el n@'umero de elementos de @var{a} y @var{q} el de @var{b}. Esta es la 
funci@'on hipergeom@'etrica generalizada @code{pFq}.

@example
(%i1) assume(not(equal(z,0)));
(%o1)                          [notequal(z, 0)]
(%i2) hgfred([v+1/2],[2*v+1],2*%i*z);

                     v/2                               %i z
                    4    bessel_j(v, z) gamma(v + 1) %e
(%o2)               ---------------------------------------
                                       v
                                      z
(%i3) hgfred([1,1],[2],z);

                                   log(1 - z)
(%o3)                            - ----------
                                       z
(%i4) hgfred([a,a+1/2],[3/2],z^2);

                               1 - 2 a          1 - 2 a
                        (z + 1)        - (1 - z)
(%o4)                   -------------------------------
                                 2 (1 - 2 a) z

@end example

Tal como muestra el siguiente ejemplo, puede ser de utilidad cargar
tambi@'en el paquete @code{orthopoly}. N@'otese que @var{L} es el
polinomio generalizado de Laguerre.

@example
(%i5) load(orthopoly)$
(%i6) hgfred([-2],[a],z);

                                    (a - 1)
                                 2 L       (z)
                                    2
(%o6)                            -------------
                                   a (a + 1)
(%i7) ev(%);

                                  2
                                 z        2 z
(%o7)                         --------- - --- + 1
                              a (a + 1)    a

@end example

@end deffn


@deffn {Funci@'on} lambert_w (@var{z})
Rama principal de la funci@'on W de Lambert, soluci@'on de
la ecuaci@'on @code{z = W(z) * exp(W(z))}.  (DLMF 4.13)
@end deffn

@deffn {Funci@'on} generalized_lambert_w (@var{k}, @var{z})
@var{k}-@'esima rama de la funci@'on W de Lambert's, W(z), soluci@'on de
@code{z = W(z) * exp(W(z))}. (DLMF 4.13)

La rama principal, representada por Wp(z) en DLMF, es @code{lambert_w(z) = generalized_lambert_w(0,z)}.

La otra rama con valores reales, representada por Wm(z) en DLMF, es @code{generalized_lambert_w(-1,z)}.
@end deffn

@deffn {Funci@'on} nzeta (@var{z})
Funci@'on de dispersi@'on del plasma.
@code{nzeta(z) = %i*sqrt(%pi)*exp(-z^2)*(1-erf(-%i*z))}
@end deffn

@deffn {Funci@'on} nzetar (@var{z})
Devuelve @code{realpart(nzeta(z))}.
@end deffn

@deffn {Funci@'on} nzetai (@var{z})
Devuelve @code{imagpart(nzeta(z))}.
@end deffn

