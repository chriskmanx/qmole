<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on diciembre, 10 2012 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual de Maxima: 25. itensor</title>

<meta name="description" content="Manual de Maxima: 25. itensor">
<meta name="keywords" content="Manual de Maxima: 25. itensor">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body
{
    color: black;
    background: white; 
    margin-left: 8%;
    margin-right: 13%;
}

h1
{
    margin-left: +8%;
    font-size: 150%;
    font-family: sans-serif
}

h2
{
    font-size: 125%;
    font-family: sans-serif
}

h3
{
    font-size: 100%;
    font-family: sans-serif
}

h2,h3,h4,h5,h6 { margin-left: +4%; }

div.textbox
{
    border: solid;
    border-width: thin;
    /* width: 100%; */
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em
}

div.titlebox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
    background: rgb(200,255,255);
    font-family: sans-serif
}

div.synopsisbox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
     background: rgb(255,220,255);
    /*background: rgb(200,255,255); */
    /* font-family: fixed */
}

pre.example
{
    border: 1px solid gray;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 1em;
    padding-right: 1em;
    /* background: rgb(247,242,180); */ /* kind of sandy */
    /* background: rgb(200,255,255); */ /* sky blue */
    background-color: #F1F5F9; /* light blue-gray */
    /* font-family: "Lucida Console", monospace */
}

div.spacerbox
{
    border: none;
    padding-top: 2em;
    padding-bottom: 2em
}

div.image
{
    margin: 0;
    padding: 1em;
    text-align: center;
}

div.categorybox
{
    border: 1px solid gray;
    padding-top: 0px;
    padding-bottom: 0px;
    padding-left: 1em;
    padding-right: 1em;
    background: rgb(247,242,220);
}


-->
</style>

<link rel="icon" href="http://maxima.sourceforge.net/favicon.ico"/>
</head>

<body lang="es" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="itensor"></a>
<a name="SEC134"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_24.html#SEC133" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC135" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_24.html#SEC132" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC149" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 25. itensor </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC135">25.1 Introducci&oacute;n a itensor</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC138">25.2 Funciones y variables para itensor</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Introducci_00f3n-a-itensor"></a>
<a name="SEC135"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC134" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC136" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC134" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC134" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC149" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 25.1 Introducci&oacute;n a itensor </h2>

<p>Maxima implementa dos tipos diferentes de manipulaci&oacute;n simb&oacute;lica de tensores: la manipulaci&oacute;n de componentes
(paquete <code>ctensor</code>) y la manipulaci&oacute;n indexada (paquete <code>itensor</code>).
</p>
<p>V&eacute;ase m&aacute;s abajo la nota sobre 'notaci&oacute;n tensorial'.
</p>
<p>La manipulaci&oacute;n de componentes significa que los objetos geom&eacute;tricos tensoriales se representan como arreglos (arrays) o matrices. Operaciones tensoriales como la contracci&oacute;n o la diferenciaci&oacute;n covariante se llevan a cabo sumando &iacute;ndices mudos con la sentencia <code>do</code>. Esto es, se realizan operaciones directamente con las componentes del tensor almacenadas en un arreglo o matriz.
</p>
<p>La manipulaci&oacute;n indexada de tensores se lleva a cabo mediante la representaci&oacute;n de los tensores como funciones de sus &iacute;ndices covariantes, contravariantes y de derivadas. Operaciones tensoriales como la contracci&oacute;n o la diferenciaci&oacute;n covariante se realizan manipulando directamente los &iacute;ndices, en lugar de sus componentes asociadas.
</p>
<p>Estas dos t&eacute;cnicas para el tratamiento de los procesos diferenciales, algebraicos y anal&iacute;ticos en el contexto de la geometr&iacute;a riemanniana tienen varias ventajas y desventajas que surgen seg&uacute;n la naturaleza y dificultad del problema que est&aacute; abordando el usuario. Sin embargo, se deben tener presentes las siguientes caracter&iacute;sticas de estas dos t&eacute;cnicas:
</p>
<p>La representaci&oacute;n de los tensores y sus operaciones en t&eacute;rminos de sus componentes facilita el uso de paquete <code>ctensor</code>. La especificaci&oacute;n de la m&eacute;trica y el c&aacute;lculo de los tensores inducidos e invariantes es inmediato. Aunque toda la potencia de simplificaci&oacute;n de Maxima se encuentra siempre a mano, una m&eacute;trica compleja con dependencias funcionales y de coordenadas intrincada, puede conducir a expresiones de gran tama&ntilde;o en las que la estructura interna quede oculta. Adem&aacute;s, muchos c&aacute;lculos requieren de expresiones intermedias que pueden provocar la detenci&oacute;n s&uacute;bita de los programas antes de que se termine el c&aacute;lculo. Con la experiencia, el usuario podr&aacute; evitar muchas de estas dificultades.
</p>
<p>Devido a la forma en que los tensores y sus operaciones se representan en t&eacute;rminos de operaciones simb&oacute;licas con sus &iacute;ndices, expresiones que ser&iacute;an intratables en su representaci&oacute;n por componentes pueden en ocasiones simplificarse notablemente utilizando las rutinas especiales para objetos sim&eacute;tricos del paquete <code>itensor</code>. De esta manera, la estructura de expresiones grandes puede hacerse m&aacute;s transparente. Por otro lado, debido a la forma especial de la representaci&oacute;n indexada de tensores en <code>itensor</code>, en algunos casos el usuario encontrar&aacute; dificultades con la especificaci&oacute;n de la m&eacute;trica o la definici&oacute;n de funciones.
</p>
<p>El paquete <code>itensor</code> puede derivar respecto de una variable indexada, lo que 
permite utilizar el paquete cuando se haga uso del formalismo de lagrangiano y
hamiltoniano. Puesto que es posible derivar un campo lagrangiano respecto de
una variable de campo indexada, se puede hacer uso de Maxima para derivar las
ecuaciones de Euler-Lagrange correspondientes en forma indexada. Estas ecuaciones
pueden traducirse a componentes tensoriales (<code>ctensor</code>) con la funci&oacute;n 
<code>ic_convert</code>, lo que permite resolver las ecuaciones de campo en cualquier
sistema de coordenadas, o obtener las ecuaciones de movimiento en forma 
hamiltoniana. V&eacute;anse dos ejemplos en <code>einhil.dem</code> y <code>bradic.dem</code>; 
el primero utiliza la acci&oacute;n de Einstein-Hilbert para derivar el campo
tensorial de Einstein en el caso homog&eacute;neo e isotr&oacute;pico (ecuaciones de
Friedmann), as&iacute; como en el caso esferosim&eacute;trico est&aacute;tico
(soluci&oacute;n de Schwarzschild); el segundo demuestra c&oacute;mo calcular las
ecuaciones de Friedmann a partir de la acci&oacute;n de la teor&iacute;a
de la gravedad de Brans-Dicke, y tambi&eacute;n muestra c&oacute;mo derivar el
hamiltoniano asociado con la teor&iacute;a del campo escalar.
</p>

<hr size="6">
<a name="SEC136"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC135" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC137" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC134" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC135" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC149" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.1.1 Notaci&oacute;n tensorial </h3>

<p>Hasta ahora, el paquete <code>itensor</code> de Maxima utilizaba una notaci&oacute;n que algunas veces llevaba a una ordenaci&oacute;n incorrecta de los &iacute;ndices. Por ejemplo:
</p>
<pre class="example">(%i2) imetric(g);
(%o2)                                done
(%i3) ishow(g([],[j,k])*g([],[i,l])*a([i,j],[]))$
                                 i l  j k
(%t3)                           g    g    a
                                           i j
(%i4) ishow(contract(%))$
                                      k l
(%t4)                                a
</pre>
<p>Este resultado no es correcto a menos que <code>a</code> sea un tensor sim&eacute;trico. La raz&oacute;n por la que esto ocurre es que aunque <code>itensor</code> mantenga correctamente el orden dentro del conjunto de &iacute;ndices covariantes y contravariantes, una vez un &iacute;ndice sea aumentado o disminuido, su posici&oacute;n relativa al otro conjunto de &iacute;ndices se pierde.
</p>
<p>Para evitar este problema, se ha desarrollado una notaci&oacute;n totalmente compatible con la anterior.En esta notaci&oacute;n, los &iacute;ndices contravariantes se insertan en las posiciones correctas en la lista de &iacute;ndices covariantes, pero precedidos del signo negativo.
</p>
<p>En esta notaci&oacute;n, el ejemplo anterior da el resultado correcto:
</p>
<pre class="example">(%i5) ishow(g([-j,-k],[])*g([-i,-l],[])*a([i,j],[]))$
                                 i l       j k
(%t5)                           g    a    g
                                      i j
(%i6) ishow(contract(%))$
                                      l k
(%t6)                                a
</pre>
<p>El &uacute;nico c&oacute;digo que hace uso de esta notaci&oacute;n es la funci&oacute;n <code>lc2kdt</code>. </p>
<p>Devido a que este c&oacute;digo es nuevo, puede contener errores.
</p>

<hr size="6">
<a name="SEC137"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC136" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC138" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC134" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC135" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC149" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.1.2 Manipulaci&oacute;n indexada de tensores </h3>

<p>El paquete <code>itensor</code> se carga haciendo <code>load(itensor)</code>. Para acceder a las demos se har&aacute; <code>demo(tensor)</code>.
</p>
<p>En el paquete <code>itensor</code> un tensor se representa como un objeto indexado, esto es, como una funci&oacute;n de tres grupos de &iacute;ndices: los covariantes, los contravariantes y los de derivadas. Los &iacute;ndices covariantes se especifican mediante una lista que ser&aacute; el primer argumento del objeto indexado, siendo los &iacute;ndices contravariantes otra lista que ser&aacute; el segundo argumento del mismo objeto indexado. Si al objeto indexado le falta cualquiera de estos grupos de &iacute;ndices, entonces se le asignar&aacute; al argumento correspondiente la lista vac&iacute;a <code>[]</code>.  As&iacute;, <code>g([a,b],[c])</code> representa un objeto indexado llamado <code>g</code>, el cual tiene dos &iacute;ndices covariantes <code>(a,b)</code>, un &iacute;ndice contravariante (<code>c</code>) y no tiene &iacute;ndices de derivadas.
</p>
<p>Los &iacute;ndices de derivadas, si est&aacute;n presentes, se a&ntilde;aden como argumentos adicionales a la funci&oacute;n simb&oacute;lica que representa al tensor. Se pueden especificar expl&iacute;citamente por el usuario o pueden crearse durante el proceso de diferenciaci&oacute;n respecto de alguna coordenada. Puesto que la diferenciaci&oacute;n ordinaria es conmutativa, los &iacute;ndices de derivadas se ordenan alfanum&eacute;ricamente, a menos que la variable <code>iframe_flag</code> valga <code>true</code>, indicando que se est&aacute; utilizando una m&eacute;trica del sistema de referencia. Esta ordenaci&oacute;n can&oacute;nica hace posible que Maxima reconozca, por ejemplo, que <code>t([a],[b],i,j)</code> es lo mismo que <code>t([a],[b],j,i)</code>. La diferenciaci&oacute;n de un objeto indexado con respecto de alguna coordenada cuyo &iacute;ndice no aparece como argumento de dicho objeto indexado, dar&aacute; como resultado cero. Esto se debe a que Maxima no sabe si el tensor representado por el objeto indexado depende impl&iacute;citamente de la coordenada correspondiente. Modificando la funci&oacute;n <code>diff</code> de Maxima en <code>itensor</code>, se da por hecho que todos los objetos indexados dependen de cualquier variable de diferenciaci&oacute;n, a menos que se indique lo contrario. Esto hace posible que la convenci&oacute;n sobre la sumaci&oacute;n se extienda a los &iacute;ndices de derivadas. El paquete <code>itensor</code> trata a los &iacute;ndices de derivadas como covariantes.
</p>
<p>Las siguientes funciones forman parte del paquete <code>itensor</code> para la manipulaci&oacute;n indexada de vectores. En lo que respecta a las rutinas de simplificaci&oacute;n, no se considera en general que los objetos indexados tengan propiedades sim&eacute;tricas. Esto puede cambiarse reasignando a la variable <code>allsym[false]</code> el valor <code>true</code>, con lo cual los objetos indexados se considerar&aacute;n sim&eacute;tricos tanto respecto de sus &iacute;ndices covariantes como contravariantes.
</p>
<p>En general, el paquete <code>itensor</code> trata a los tensores como objetos opacos. Las ecuaciones tensoriales se manipulan en base a reglas algebraicas, como la simetr&iacute;a y la contracci&oacute;n. Adem&aacute;s, en el paquete <code>itensor</code> hay funciones para la diferenciaci&oacute;n covariante, la curvatura y la torsi&oacute;n. Los c&aacute;lculos se pueden realizar respecto de una m&eacute;trica del sistema de referencia m&oacute;vil, dependiendo de las asignaciones dadas a la variable <code>iframe_flag</code>.
</p>
<p>La siguiente sesi&oacute;n de ejemplo demuestra c&oacute;mo cargar el paquete <code>itensor</code>, especificar el nombre de la m&eacute;trica y realizar algunos c&aacute;lculos sencillos.
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                                done
(%i3) components(g([i,j],[]),p([i,j],[])*e([],[]))$
(%i4) ishow(g([k,l],[]))$
(%t4)                               e p
                                       k l
(%i5) ishow(diff(v([i],[]),t))$
(%t5)                                  0
(%i6) depends(v,t);
(%o6)                               [v(t)]
(%i7) ishow(diff(v([i],[]),t))$
                                    d
(%t7)                               -- (v )
                                    dt   i
(%i8) ishow(idiff(v([i],[]),j))$
(%t8)                                v
                                      i,j
(%i9) ishow(extdiff(v([i],[]),j))$
(%t9)                             v    - v
                                   j,i    i,j
                                  -----------
                                       2
(%i10) ishow(liediff(v,w([i],[])))$
                               %3          %3
(%t10)                        v   w     + v   w
                                   i,%3    ,i  %3
(%i11) ishow(covdiff(v([i],[]),j))$
                                              %4
(%t11)                        v    - v   ichr2
                               i,j    %4      i j
(%i12) ishow(ev(%,ichr2))$
                %4 %5
(%t12) v    - (g      v   (e p       + e   p     - e p       - e    p
        i,j            %4     j %5,i    ,i  j %5      i j,%5    ,%5  i j

                                         + e p       + e   p    ))/2
                                              i %5,j    ,j  i %5
(%i13) iframe_flag:true;
(%o13)                               true
(%i14) ishow(covdiff(v([i],[]),j))$
                                             %6
(%t14)                        v    - v   icc2
                               i,j    %6     i j
(%i15) ishow(ev(%,icc2))$
                                             %6
(%t15)                        v    - v   ifc2
                               i,j    %6     i j
(%i16) ishow(radcan(ev(%,ifc2,ifc1)))$
             %6 %7                    %6 %7
(%t16) - (ifg      v   ifb       + ifg      v   ifb       - 2 v
                    %6    j %7 i             %6    i j %7      i,j

                                             %6 %7
                                        - ifg      v   ifb      )/2
                                                    %6    %7 i j
(%i17) ishow(canform(s([i,j],[])-s([j,i])))$
(%t17)                            s    - s
                                   i j    j i
(%i18) decsym(s,2,0,[sym(all)],[]);
(%o18)                               done
(%i19) ishow(canform(s([i,j],[])-s([j,i])))$
(%t19)                                 0
(%i20) ishow(canform(a([i,j],[])+a([j,i])))$
(%t20)                            a    + a
                                   j i    i j
(%i21) decsym(a,2,0,[anti(all)],[]);
(%o21)                               done
(%i22) ishow(canform(a([i,j],[])+a([j,i])))$
(%t22)                                 0
</pre>

<hr size="6">
<a name="Funciones-y-variables-para-itensor"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC137" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC139" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC134" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC134" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC149" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>

<a name="SEC138"></a>
<h2 class="section"> 25.2 Funciones y variables para itensor </h2>
<hr size="6">
<a name="SEC139"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC138" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC140" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC134" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC138" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC149" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.2.1 Trabajando con objetos indexados </h3>


<dl>
<dt><u>Funci&oacute;n:</u> <b>dispcon</b><i> (<var>tensor_1</var>, <var>tensor_2</var>, ...)</i>
<a name="IDX1030"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>dispcon</b><i> (all)</i>
<a name="IDX1031"></a>
</dt>
<dd><p>Muestra las propiedades contractivas de sus argumentos tal como 
fueron asignadas por <code>defcon</code>. La llamada <code>dispcon (all)</code>
muestra todas propiedades contractivas que fueron definidas.
</p></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>entertensor</b><i> (<var>nombre</var>)</i>
<a name="IDX1032"></a>
</dt>
<dd><p>Permite crear un objeto indexado llamado <var>nombre</var>, con cualquier n&uacute;mero de &iacute;ndices tensoriales y de derivadas. Se admiten desde un &uacute;nico &iacute;ndice hasta una lista de &iacute;ndices. V&eacute;ase el ejemplo en la descripci&oacute;n de <code>covdiff</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>changename</b><i> (<var>anterior</var>, <var>nuevo</var>, <var>expr</var>)</i>
<a name="IDX1033"></a>
</dt>
<dd><p>Cambia el nombre de todos los objetos indexados llamados <var>anterior</var> a <var>new</var> en <var>expr</var>. El argumento <var>anterior</var> puede ser un s&iacute;mbolo o una lista de la forma <code>[<var>nombre</var>, <var>m</var>, <var>n</var>]</code>, en cuyo caso s&oacute;lo los objetos indexados de llamados <var>nombre</var> con <var>m</var> &iacute;ndices covariantes y <var>n</var> contravariantes se renombrar&aacute;n como <var>nuevo</var>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>listoftens</b>
<a name="IDX1034"></a>
</dt>
<dd><p>Hace un listado de todos los tensores y sus &iacute;ndices en una expresi&oacute;n tensorial. Por ejemplo,
</p>
<pre class="example">
(%i6) ishow(a([i,j],[k])*b([u],[],v)+c([x,y],[])*d([],[])*e)$
                                         k
(%t6)                        d e c    + a    b
                                  x y    i j  u,v
(%i7) ishow(listoftens(%))$
                               k
(%t7)                        [a   , b   , c   , d]
                               i j   u,v   x y

</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>ishow</b><i> (<var>expr</var>)</i>
<a name="IDX1035"></a>
</dt>
<dd><p>Muestra <var>expr</var> con todos los objetos indexados que contiene, junto con los correspondientes &iacute;ndices covariantes (como sub&iacute;ndices) y contravariantes (como super&iacute;ndices). Los &iacute;ndices de derivadas se muestran como sub&iacute;ndices, separados de los covariantes por una coma; v&eacute;anse los m&uacute;ltiples ejemplos de este documento.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>indices</b><i> (<var>expr</var>)</i>
<a name="IDX1036"></a>
</dt>
<dd><p>Devuelve una lista con dos elementos. El primer elemento es una lista con los &iacute;ndices libres, aquellos que aparecen una sola vez. El segundo elemento es una lista con los &iacute;ndices mudos en <var>expr</var>, aquellos que aparecen exactamente dos veces. Por ejemplo,
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i,j],[k,l],m,n)*b([k,o],[j,m,p],q,r))$
                                k l      j m p
(%t2)                          a        b
                                i j,m n  k o,q r
(%i3) indices(%);
(%o3)                 [[l, p, i, n, o, q, r], [k, j, m]]

</pre>
<p>Un producto tensorial que contenga el mismo &iacute;ndice m&aacute;s de dos veces es sint&aacute;cticamente incorrecto. La funci&oacute;n <code>indices</code> intenta tratar estas expresiones de una forma razonable; sin embargo, cuando se la obliga a manipular una expresi&oacute;n incorrecta puede tener un comportamiento imprevisto.
</p>

</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>rename</b><i> (<var>expr</var>)</i>
<a name="IDX1037"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>rename</b><i> (<var>expr</var>, <var>count</var>)</i>
<a name="IDX1038"></a>
</dt>
<dd><p>Devuelve una expresi&oacute;n equivalente a <var>expr</var> pero con los &iacute;ndices mudos de cada t&eacute;rmino elegidos del conjunto  <code>[%1, %2,...]</code> si el segundo argumento opcional se omite. En otro caso, los &iacute;ndices mudos son indexados empezando con el valor <var>count</var>. Cada &iacute;ndice mudo en un producto ser&aacute; diferente. En el caso de las sumas, la funci&oacute;n <code>rename</code> operar&aacute; sobre cada t&eacute;rmino de la suma reinicializando el contador con cada t&eacute;rmino. De esta manera <code>rename</code> puede servir como simplificador tensorial. Adem&aacute;s, los &iacute;ndices se ordenar&aacute;n alfanum&eacute;ricamente, si la variable <code>allsym</code> vale <code>true</code>, respecto de los &iacute;ndices covariantes y contravariantes dependiendo del valor de <code>flipflag</code>. Si  <code>flipflag</code> vale <code>false</code>, entonces los &iacute;ndices se renombrar&aacute;n de acuerdo con el orden de los &iacute;ndices contravariantes. Si <code>flipflag</code> vale <code>true</code>, entonces los &iacute;ndices se renombrar&aacute;n de acuerdo con el orden de los &iacute;ndices covariantes. Suele acontecer que el efecto combinado de los dos cambios de nombre reduzcan la expresi&oacute;n m&aacute;s de lo que que pueda reducir cualquiera de ellas por separado.
</p>

<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) allsym:true;
(%o2)                                true
(%i3) g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%4],[%3])*
ichr2([%2,%3],[u])*ichr2([%5,%6],[%1])*ichr2([%7,r],[%2])-
g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%2],[u])*
ichr2([%3,%5],[%1])*ichr2([%4,%6],[%3])*ichr2([%7,r],[%2]),noeval$
(%i4) expr:ishow(%)$

       %4 %5  %6 %7      %3         u          %1         %2
(%t4) g      g      ichr2      ichr2      ichr2      ichr2
                         %1 %4      %2 %3      %5 %6      %7 r

        %4 %5  %6 %7      u          %1         %3         %2
     - g      g      ichr2      ichr2      ichr2      ichr2
                          %1 %2      %3 %5      %4 %6      %7 r
(%i5) flipflag:true;
(%o5)                                true
(%i6) ishow(rename(expr))$
       %2 %5  %6 %7      %4         u          %1         %3
(%t6) g      g      ichr2      ichr2      ichr2      ichr2
                         %1 %2      %3 %4      %5 %6      %7 r

        %4 %5  %6 %7      u          %1         %3         %2
     - g      g      ichr2      ichr2      ichr2      ichr2
                          %1 %2      %3 %4      %5 %6      %7 r
(%i7) flipflag:false;
(%o7)                                false
(%i8) rename(%th(2));
(%o8)                                  0
(%i9) ishow(rename(expr))$
       %1 %2  %3 %4      %5         %6         %7        u
(%t9) g      g      ichr2      ichr2      ichr2     ichr2
                         %1 %6      %2 %3      %4 r      %5 %7

        %1 %2  %3 %4      %6         %5         %7        u
     - g      g      ichr2      ichr2      ichr2     ichr2
                          %1 %3      %2 %6      %4 r      %5 %7
</pre>
</dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>show</b><i> (<var>expr</var>)</i>
<a name="IDX1039"></a>
</dt>
<dd><p>Muestra <code>expr</code> con sus objetos indexados que tengan &iacute;ndices covariantes como sub&iacute;ndices y los contravariantes como super&iacute;ndices.  Los &iacute;ndices derivados se muestran como sub&iacute;ndices, separados por una coma de los covariantes.
</p></dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>flipflag</b>
<a name="IDX1040"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si vale <code>false</code> los &iacute;ndices se renombrar&aacute;n de acuerdo con el orden de los &iacute;ndices covariantes, si <code>true</code> se renombrar&aacute;n de acuerdo con el orden de los &iacute;ndices covariantes.
</p>
<p>Si <code>flipflag</code> vale <code>false</code>, entonces <code>rename</code> construye una lista con los &iacute;ndices contravariantes seg&uacute;n van apareciendo de izquierda a derecha; si vale <code>true</code>, entonces va formando la lista con los covariantes. Al primer &iacute;ndice mudo se le da el nombre <code>%1</code>, al siguiente <code>%2</code>, etc. Finalmente se hace la ordenaci&oacute;n. V&eacute;ase el ejemplo en la descripci&oacute;n de la funci&oacute;n <code>rename</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>defcon</b><i> (<var>tensor_1</var>)</i>
<a name="IDX1041"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>defcon</b><i> (<var>tensor_1</var>, <var>tensor_2</var>, <var>tensor_3</var>)</i>
<a name="IDX1042"></a>
</dt>
<dd><p>Le asigna a gives <var>tensor_1</var> la propiedad de que la contracci&oacute;n de un producto de <var>tensor_1</var> por <var>tensor_2</var> da como resultado un <var>tensor_3</var> con los &iacute;ndices apropiados. Si s&oacute;lo se aporta un argumento, <var>tensor_1</var>, entonces la contracci&oacute;n del producto de <var>tensor_1</var> por cualquier otro objeto indexado que tenga los &iacute;ndices apropiados, por ejemplo <code>my_tensor</code>, dar&aacute; como resultado un objeto indexado con ese nombre, <code>my_tensor</code>, y con un nuevo conjunto de &iacute;ndices que reflejen las contracciones realizadas. Por ejemplo, si <code>imetric:g</code>, entonces <code>defcon(g)</code> implementar&aacute; el aumento o disminuci&oacute;n de los &iacute;ndices a trav&eacute;s de la contracci&oacute;n con el tensor m&eacute;trico. Se puede dar m&aacute;s de un <code>defcon</code> para el mismo objeto indexado, aplic&aacute;ndose el &uacute;ltimo. La variable 
<code>contractions</code> es una lista con aquellos objetos indexados a los que se le han dado propiedades de contracci&oacute;n con  <code>defcon</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>remcon</b><i> (<var>tensor_1</var>, ..., <var>tensor_n</var>)</i>
<a name="IDX1043"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>remcon</b><i> (all)</i>
<a name="IDX1044"></a>
</dt>
<dd><p>Borra todas las propiedades de contracci&oacute;n de <var>tensor_1</var>, ..., <var>tensor_n</var>). La llamada <code>remcon(all)</code> borra todas las propiedades de contracci&oacute;n de todos los objetos indexados.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>contract</b><i> (<var>expr</var>)</i>
<a name="IDX1045"></a>
</dt>
<dd><p>Lleva a cabo las contracciones tensoriales en <var>expr</var>, la cual puede ser cualquier combinaci&oacute;n de sumas y productos. Esta funci&oacute;n utiliza la informaci&oacute;n dada a la funci&oacute;n <code>defcon</code>. Para obtener mejores resultados, <code>expr</code>
deber&iacute;a estar completamente expandida. La funci&oacute;n <code>ratexpand</code> es la forma m&aacute;s r&aacute;pida de expandir productos y potencias de sumas si no hay variables en los denominadores de los t&eacute;rminos.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>indexed_tensor</b><i> (<var>tensor</var>)</i>
<a name="IDX1046"></a>
</dt>
<dd><p>Debe ejecutarse antes de asignarle componentes a un <var>tensor</var> para el que ya existe un valor, como <code>ichr1</code>, <code>ichr2</code> o <code>icurvature</code>. V&eacute;ase el ejemplo de la descripci&oacute;n de <code>icurvature</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>components</b><i> (<var>tensor</var>, <var>expr</var>)</i>
<a name="IDX1047"></a>
</dt>
<dd><p>Permite asignar un valor indexado a la expresi&oacute;n <var>expr</var> dando los valores de las componentes de <var>tensor</var>. El tensor debe ser de la forma <code>t([...],[...])</code>, donde cualquiera de las listas puede estar vac&iacute;a. La expresi&oacute;n  <var>expr</var> puede ser cualquier objeto indexado que tenga otros objetos con los mismos &iacute;ndices libres que <var>tensor</var>. Cuando se utiliza para asignar valores al tensor m&eacute;trico en el que las componentes contengan &iacute;ndices mudos, se debe tener cuidado en no generar &iacute;ndices mudos m&uacute;ltiples. Se pueden borrar estas asignaciones con la funci&oacute;n  <code>remcomps</code>.
</p>
<p>Es importante tener en cuenta que <code>components</code> controla la valencia del tensor, no el orden de los &iacute;ndices. As&iacute;, asignando componentes de la forma <code>x([i,-j],[])</code>, <code>x([-j,i],[])</code> o <code>x([i],[j])</code> todos ellos producen el mismo resultado, la asignaci&oacute;n de componentes a un tensor de nombre <code>x</code> con valencia <code>(1,1)</code>.
</p>
<p>Las componentes se pueden asignar a una expresi&oacute;n indexada de cuatro maneras, dos de las cuales implican el uso de la instrucci&oacute;n <code>components</code>:
</p>
<p>1) Como una expresi&oacute;n indexada. Por ejemplo:
</p>
<pre class="example">
(%i2) components(g([],[i,j]),e([],[i])*p([],[j]))$
(%i3) ishow(g([],[i,j]))$
                                      i  j
(%t3)                                e  p

</pre>
<p>2) Como una matriz:
</p>
<pre class="example">(%i5) lg:-ident(4)$lg[1,1]:1$lg;
                            [ 1   0    0    0  ]
                            [                  ]
                            [ 0  - 1   0    0  ]
(%o5)                       [                  ]
                            [ 0   0   - 1   0  ]
                            [                  ]
                            [ 0   0    0   - 1 ]

(%i6) components(g([i,j],[]),lg);
(%o6)                                done
(%i7) ishow(g([i,j],[]))$
(%t7)                                g
                                      i j
(%i8) g([1,1],[]);
(%o8)                                  1
(%i9) g([4,4],[]);
(%o9)                                 - 1

</pre>
<p>3) Como una funci&oacute;n. Se puede utilizar una funci&oacute;n de Maxima para especificar las componentes de un tensor en base a sus &iacute;ndices. Por ejemplo, el c&oacute;digo siguiente asigna  <code>kdelta</code> a <code>h</code> si <code>h</code> tiene el mismo n&uacute;mero de &iacute;ndices covariantes y contravariantes y no tiene &iacute;ndices de derivadas, asign&aacute;ndole <code>g</code> en otro caso:
</p>
<pre class="example">
(%i4) h(l1,l2,[l3]):=if length(l1)=length(l2) and length(l3)=0
  then kdelta(l1,l2) else apply(g,append([l1,l2], l3))$
(%i5) ishow(h([i],[j]))$
                                          j
(%t5)                               kdelta
                                          i
(%i6) ishow(h([i,j],[k],l))$
                                     k
(%t6)                               g
                                     i j,l

</pre>
<p>4) Utilizando los patrones de Maxima, en particular las funciones <code>defrule</code> y <code>applyb1</code>:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) matchdeclare(l1,listp);
(%o2)                                done
(%i3) defrule(r1,m(l1,[]),(i1:idummy(),
      g([l1[1],l1[2]],[])*q([i1],[])*e([],[i1])))$

(%i4) defrule(r2,m([],l1),(i1:idummy(),
      w([],[l1[1],l1[2]])*e([i1],[])*q([],[i1])))$

(%i5) ishow(m([i,n],[])*m([],[i,m]))$
                                    i m
(%t5)                              m    m
                                         i n
(%i6) ishow(rename(applyb1(%,r1,r2)))$
                           %1  %2  %3 m
(%t6)                     e   q   w     q   e   g
                                         %1  %2  %3 n


</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>remcomps</b><i> (<var>tensor</var>)</i>
<a name="IDX1048"></a>
</dt>
<dd><p>Borra todos los valores de <var>tensor</var> que han sido asignados con la funci&oacute;n <code>components</code>.
</p>
</dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>showcomps</b><i> (<var>tensor</var>)</i>
<a name="IDX1049"></a>
</dt>
<dd><p>Muestra las componentes de un tensor definidas con la instrucci&oacute;n <code>components</code>. Por ejemplo:
</p>
<pre class="example">
(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) load(itensor);
(%o2)      /share/tensor/itensor.lisp
(%i3) lg:matrix([sqrt(r/(r-2*m)),0,0,0],[0,r,0,0],
                [0,0,sin(theta)*r,0],[0,0,0,sqrt((r-2*m)/r)]);
               [         r                                     ]
               [ sqrt(-------)  0       0              0       ]
               [      r - 2 m                                  ]
               [                                               ]
               [       0        r       0              0       ]
(%o3)          [                                               ]
               [       0        0  r sin(theta)        0       ]
               [                                               ]
               [                                      r - 2 m  ]
               [       0        0       0        sqrt(-------) ]
               [                                         r     ]
(%i4) components(g([i,j],[]),lg);
(%o4)                                done
(%i5) showcomps(g([i,j],[]));
                  [         r                                     ]
                  [ sqrt(-------)  0       0              0       ]
                  [      r - 2 m                                  ]
                  [                                               ]
                  [       0        r       0              0       ]
(%t5)      g    = [                                               ]
            i j   [       0        0  r sin(theta)        0       ]
                  [                                               ]
                  [                                      r - 2 m  ]
                  [       0        0       0        sqrt(-------) ]
                  [                                         r     ]
(%o5)                                false

</pre>
<p>La funci&oacute;n <code>showcomps</code> tambi&eacute;n puede mostrar las componentes de tensores de rango mayor de 2.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>idummy</b><i> ()</i>
<a name="IDX1050"></a>
</dt>
<dd><p>Incrementa <code>icounter</code> y devuelve un &iacute;ndice de la forma <code>%n</code> siendo <code>n</code> un entero positivo.  Esto garantiza que &iacute;ndices mudos que sean necesarios para formar expresiones no entren en conflico con &iacute;ndices que ya est&aacute;n en uso. V&eacute;ase el ejemplo de la descripci&oacute;n de <code>indices</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>idummyx</b>
<a name="IDX1051"></a>
</dt>
<dd><p>Valor por defecto: <code>%</code>
</p>
<p>Es el prefijo de los &iacute;ndices mudos. V&eacute;ase <code>indices</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>icounter</b>
<a name="IDX1052"></a>
</dt>
<dd><p>Valor por defecto: <code>1</code>
</p>
<p>Determina el sufijo num&eacute;rico a ser utilizado en la generaci&oacute;n del siguiente &iacute;ndice mudo. El prefijo se determina con la opci&oacute;n <code>idummy</code> (por defecto: %).
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>kdelta</b><i> (<var>L1</var>, <var>L2</var>)</i>
<a name="IDX1053"></a>
</dt>
<dd><p>Es la funci&oacute;n delta generalizada de Kronecker definida en el paquete <code>itensor</code> siendo <var>L1</var> la lista de &iacute;ndices covariantes y <var>L2</var> la lista de &iacute;ndices contravariantes. La funci&oacute;n  <code>kdelta([i],[j])</code> devuelve el valor de la delta ordinaria de Kronecker. La instrucci&oacute;n <code>ev(<var>expr</var>,kdelta)</code> provoca la evaluaci&oacute;n de una expresi&oacute;n que contenga <code>kdelta([],[])</code>.
</p>
<p>En un abuso de la notaci&oacute;n, <code>itensor</code> tambi&eacute;n permite a <code>kdelta</code> tener 2 &iacute;ndices covariantes y ninguno contravariante, o 2 contravariantes y ninguno covariante. Esto es una funcionalidad del paquete, loque no implica que  <code>kdelta([i,j],[])</code> sea un objeto tensorial de pleno derecho.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>kdels</b><i> (<var>L1</var>, <var>L2</var>)</i>
<a name="IDX1054"></a>
</dt>
<dd><p>Funci&oacute;n delta de Kronecker simetrizada, utilizada en algunos c&aacute;lculos. Por ejemplo:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) kdelta([1,2],[2,1]);
(%o2)                                 - 1
(%i3) kdels([1,2],[2,1]);
(%o3)                                  1
(%i4) ishow(kdelta([a,b],[c,d]))$
                             c       d         d       c
(%t4)                  kdelta  kdelta  - kdelta  kdelta
                             a       b         a       b
(%i4) ishow(kdels([a,b],[c,d]))$
                             c       d         d       c
(%t4)                  kdelta  kdelta  + kdelta  kdelta
                             a       b         a       b

</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>levi_civita</b><i> (<var>L</var>)</i>
<a name="IDX1055"></a>
</dt>
<dd><p>Es el tensor de permutaci&oacute;n de Levi-Civita, el cual devuelve 1  si la lista <var>L</var> con una permutaci&oacute;n par de enteros, -1 si es en una permutaci&oacute;n impar y 0 si algunos de los &iacute;ndices de <var>L</var> est&aacute;n repetidos.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>lc2kdt</b><i> (<var>expr</var>)</i>
<a name="IDX1056"></a>
</dt>
<dd><p>Simplifica expresiones que contengan el s&iacute;mbolo de Levi-Civita, convirti&eacute;ndolas en expresiones con la delta de Kronecker siempre que sea posible. La diferencia principal entre esta funci&oacute;n y la simple evaluaci&oacute;n del s&iacute;mbolo de Levi-Civita consiste en que de esta &uacute;ltima forma se obtienen expresiones de Kronecker con &iacute;ndices num&eacute;ricos, lo que impide simplificaciones ulteriores. La funci&oacute;n <code>lc2kdt</code> evita este problema, dando resultados con son m&aacute;s f&aacute;ciles de simplificar con <code>rename</code> o <code>contract</code>.
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) expr:ishow('levi_civita([],[i,j])
                 *'levi_civita([k,l],[])*a([j],[k]))$
                                  i j  k
(%t2)                  levi_civita    a  levi_civita
                                       j            k l
(%i3) ishow(ev(expr,levi_civita))$
                                  i j  k       1 2
(%t3)                       kdelta    a  kdelta
                                  1 2  j       k l
(%i4) ishow(ev(%,kdelta))$
             i       j         j       i   k
(%t4) (kdelta  kdelta  - kdelta  kdelta ) a
             1       2         1       2   j

                               1       2         2       1
                        (kdelta  kdelta  - kdelta  kdelta )
                               k       l         k       l
(%i5) ishow(lc2kdt(expr))$
                     k       i       j    k       j       i
(%t5)               a  kdelta  kdelta  - a  kdelta  kdelta
                     j       k       l    j       k       l
(%i6) ishow(contract(expand(%)))$
                                 i           i
(%t6)                           a  - a kdelta
                                 l           l

</pre>
<p>La funci&oacute;n <code>lc2kdt</code> en ocasiones hace uso del tensor m&eacute;trico. Si el tensor m&eacute;trico no fue previamente definido con <code>imetric</code>, se obtiene un mensaje de error.
</p>
<pre class="example">
(%i7) expr:ishow('levi_civita([],[i,j])
                 *'levi_civita([],[k,l])*a([j,k],[]))$
                                 i j            k l
(%t7)                 levi_civita    levi_civita    a
                                                     j k
(%i8) ishow(lc2kdt(expr))$
Maxima encountered a Lisp error:

 Error in $IMETRIC [or a callee]:
 $IMETRIC [or a callee] requires less than two arguments.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
(%i9) imetric(g);
(%o9)                                done
(%i10) ishow(lc2kdt(expr))$
         %3 i       k   %4 j       l     %3 i       l   %4 j
(%t10) (g     kdelta   g     kdelta   - g     kdelta   g    
                    %3             %4               %3
              k
        kdelta  ) a
              %4   j k
(%i11) ishow(contract(expand(%)))$
                                  l i    l i  j
(%t11)                           a    - g    a
                                              j

</pre>

</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>lc_l</b>
<a name="IDX1057"></a>
</dt>
<dd><p>Regla de simplificaci&oacute;n utilizada en expresiones que contienen el s&iacute;mbolo de <code>levi_civita</code> sin evaluar. Junto con  <code>lc_u</code>, puede utilizarse para simplificar muchas expresiones de forma m&aacute;s eficiente que la evaluaci&oacute;n de <code>levi_civita</code>. Por ejemplo:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2)  el1:ishow('levi_civita([i,j,k],[])*a([],[i])*a([],[j]))$
                             i  j
(%t2)                       a  a  levi_civita
                                             i j k
(%i3) el2:ishow('levi_civita([],[i,j,k])*a([i])*a([j]))$
                                       i j k
(%t3)                       levi_civita      a  a
                                              i  j
(%i4) canform(contract(expand(applyb1(el1,lc_l,lc_u))));
(%t4)                                  0
(%i5) canform(contract(expand(applyb1(el2,lc_l,lc_u))));
(%t5)                                  0

</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>lc_u</b>
<a name="IDX1058"></a>
</dt>
<dd><p>Regla de simplificaci&oacute;n utilizada en expresiones que contienen el s&iacute;mbolo de <code>levi_civita</code> sin evaluar. Junto con  <code>lc_l</code>, puede utilizarse para simplificar muchas expresiones de forma m&aacute;s eficiente que la evaluaci&oacute;n de <code>levi_civita</code>. V&eacute;ase <code>lc_l</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>canten</b><i> (<var>expr</var>)</i>
<a name="IDX1059"></a>
</dt>
<dd><p>Simplifica <var>expr</var> renombrando (v&eacute;ase <code>rename</code>) y permutando &iacute;ndices mudos. La funci&oacute;n <code>rename</code> se restringe a sumas de productos de tensores en los cuales no hay derivadas, por lo que est&aacute; limitada y s&oacute;lo deber&iacute;a utilizarse si <code>canform</code> no es capaz de de llevar a cabo la simplificaci&oacute;n requerida.
</p>
<p>La funci&oacute;n <code>canten</code> devuelve un resultado matem&aacute;ticamente correcto s&oacute;lo si su argumento es una expresi&oacute;n completamente sim&eacute;trica respecto de sus &iacute;ndices. Por esta raz&oacute;n, <code>canten</code> devuelve un error si <code>allsym</code> no vale <code>true</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>concan</b><i> (<var>expr</var>)</i>
<a name="IDX1060"></a>
</dt>
<dd><p>Similar a <code>canten</code> pero tambi&eacute;n realiza la contracci&oacute;n de los &iacute;ndices.
</p>
</dd></dl>

<hr size="6">
<a name="SEC140"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC139" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC141" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC134" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC138" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC149" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.2.2 Simetr&iacute;as de tensores </h3>

<dl>
<dt><u>Variable opcional:</u> <b>allsym</b>
<a name="IDX1061"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si vale <code>true</code> entonces todos los objetos indexados se consideran sim&eacute;tricos respecto de todos sus &iacute;ndices covariantes y contravariantes. Si vale <code>false</code> entonces no se tienen en cuenta ning&uacute;n tipo de simetr&iacute;a para estos &iacute;ndices. Los &iacute;ndices de derivadas se consideran siempre sim&eacute;tricos, a menos que la variable <code>iframe_flag</code> valga <code>true</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>decsym</b><i> (<var>tensor</var>, <var>m</var>, <var>n</var>, [<var>cov_1</var>, <var>cov_2</var>, ...], [<var>contr_1</var>, <var>contr_2</var>, ...])</i>
<a name="IDX1062"></a>
</dt>
<dd><p>Declara propiedades de simetr&iacute;a para el <var>tensor</var> de <var>m</var> &iacute;ndices covariantes y <var>n</var> contravariantes. Los <var>cov_i</var> y <var>contr_i</var> son seudofunciones que expresan relaciones de simetr&iacute;a entre los &iacute;ndices covariantes y contravariantes, respectivamente. &Eacute;stos son de la forma <code>symoper(<var>index_1</var>, <var>index_2</var>,...)</code> donde <code>symoper</code> es uno de <code>sym</code>, <code>anti</code> o <code>cyc</code> y los <var>index_i</var> son enteros que indican la posici&oacute;n del &iacute;ndice en el <var>tensor</var>.  Esto declarar&aacute; a <var>tensor</var> sim&eacute;trico, antisim&eacute;trico o c&iacute;clico respecto de <var>index_i</var>. La llamada <code>symoper(all)</code> indica que todos los &iacute;ndices cumplen la condici&oacute;n de simetr&iacute;a. Por ejemplo, dado un objeto <code>b</code> con 5 &iacute;ndices covariantes, <code>decsym(b,5,3,[sym(1,2),anti(3,4)],[cyc(all)])</code> declara <code>b</code> sim&eacute;trico en el primer y segundo &iacute;ndices covariantes, antisim&eacute;trico en su tercer y cuarto &iacute;ndices tambi&eacute;n covariantes y c&iacute;clico en todos sus &iacute;ndices contravariantes. Cualquiera de las listas de declaraci&oacute;n de simetr&iacute;as puede ser nula. La funci&oacute;n que realiza las simplificaciones es <code>canform</code>, como se ilustra en el siguiente ejemplo,
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) expr:contract(expand(a([i1,j1,k1],[])
            *kdels([i,j,k],[i1,j1,k1])))$
(%i3) ishow(expr)$
(%t3)         a      + a      + a      + a      + a      + a
               k j i    k i j    j k i    j i k    i k j    i j k
(%i4) decsym(a,3,0,[sym(all)],[]);
(%o4)                                done
(%i5) ishow(canform(expr))$
(%t5)                              6 a
                                      i j k
(%i6) remsym(a,3,0);
(%o6)                                done
(%i7) decsym(a,3,0,[anti(all)],[]);
(%o7)                                done
(%i8) ishow(canform(expr))$
(%t8)                                  0
(%i9) remsym(a,3,0);
(%o9)                                done
(%i10) decsym(a,3,0,[cyc(all)],[]);
(%o10)                               done
(%i11) ishow(canform(expr))$
(%t11)                        3 a      + 3 a
                                 i k j      i j k
(%i12) dispsym(a,3,0);
(%o12)                     [[cyc, [[1, 2, 3]], []]]

</pre>

</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>remsym</b><i> (<var>tensor</var>, <var>m</var>, <var>n</var>)</i>
<a name="IDX1063"></a>
</dt>
<dd><p>Borra todas las propiedades de simetr&iacute;a del <var>tensor</var> que tiene <var>m</var> &iacute;ndices covariantes y <var>n</var> contravariantes.
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>canform</b><i> (<var>expr</var>)</i>
<a name="IDX1064"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>canform</b><i> (<var>expr</var>, <var>rename</var>)</i>
<a name="IDX1065"></a>
</dt>
<dd><p>Simplifica <var>expr</var> renombrando &iacute;ndices mudos y reordenando todos los &iacute;ndices seg&uacute;n las condiciones de simetr&iacute;a que se le hayan impuesto. Si <code>allsym</code> vale <code>true</code> entonces todos los &iacute;ndices se consideran sim&eacute;tricos, en otro caso se utilizar&aacute; la informaci&oacute;n sobre simetr&iacute;as suministrada por <code>decsym</code>. Los &iacute;ndices mudos se renombran de la misma manera que en la funci&oacute;n <code>rename</code>. Cuando <code>canform</code> se aplica a una expresi&oacute;n grande el c&aacute;lculo puede llevar mucho tiempo. Este tiempo se puede acortar llamando primero  a <code>rename</code>.
V&eacute;ase tambi&eacute;n el ejemplo de la descripci&oacute;n de <code>decsym</code>. La funci&oacute;n <code>canform</code> puede que no reduzca completamente una expresi&oacute;n a su forma m&aacute;s sencilla, pero en todo caso devolver&aacute; un resultado matem&aacute;ticamente correcto.
</p>
<p>Si al par&aacute;metro opcional <var>rename</var> se le asigna el valor <code>false</code>, no se renombrar&aacute;n los &iacute;ndices mudos.
</p></dd></dl>

<hr size="6">
<a name="SEC141"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC140" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC142" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC134" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC138" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC149" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.2.3 C&aacute;lculo tensorial indexado </h3>


<dl>
<dt><u>Funci&oacute;n:</u> <b>diff</b><i> (<var>expr</var>, <var>v_1</var>, [<var>n_1</var>, [<var>v_2</var>, <var>n_2</var>] ...])</i>
<a name="IDX1066"></a>
</dt>
<dd><p>Se trata de la funci&oacute;n de Maxima para la diferenciaci&oacute;n, ampliada para las necesidades del paquete <code>itensor</code>. Calcula la derivada de <var>expr</var> respecto de <var>v_1</var> <var>n_1</var> veces, respecto de <var>v_2</var> <var>n_2</var> veces, etc. Para el paquete de tensores,la funci&oacute;n ha sido modificada de manera que <var>v_i</var> puedan ser enteros desde 1 hasta el valor que tome la variable <code>dim</code>. Esto permite que la derivaci&oacute;n se pueda realizar con respecto del <var>v_i</var>-&eacute;simo miembro de la lista <code>vect_coords</code>. Si <code>vect_coords</code> guarda una variable at&oacute;mica, entonces esa variable ser&aacute; la que se utilice en la derivaci&oacute;n. Con esto se hace posible la utilizaci&oacute;n de una lista con nombres de coordenadas subindicadas, como <code>x[1]</code>, <code>x[2]</code>, ...
</p>
<p>El paquete sobre tensores ampl&iacute;a las capacidades de <code>diff</code> con el
fin de poder calcular derivadas respecto de variables indexadas. En particular, es
posible derivar expresiones que contengan combinaciones del tensor m&eacute;trico y
sus derivadas respecto del tensor m&eacute;trico y su primera y segunda derivadas.
Estos m&eacute;todos son particularmente &uacute;tiles cuando se consideran los
formalismos lagrangianos de la teor&iacute;a gravitatoria, permitiendo
obtener el tensor de Einstein y las ecuaciones de campo a partir del principio
de acci&oacute;n.
</p></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>idiff</b><i> (<var>expr</var>, <var>v_1</var>, [<var>n_1</var>, [<var>v_2</var>, <var>n_2</var>] ...])</i>
<a name="IDX1067"></a>
</dt>
<dd><p>Diferenciaci&oacute;n inicial. Al contrario que <code>diff</code>, que deriva respecto de una variable independiente, <code>idiff</code> puede usarse para derivar respecto de una coordenada. </p>
<p>La funci&oacute;n <code>idiff</code> tambi&eacute;n puede derivar el determinante del tensor m&eacute;trico. As&iacute;, si <code>imetric</code> toma el valor <code>G</code> entonces <code>idiff(determinant(g),k)</code> devolver&aacute; <code>2*determinant(g)*ichr2([%i,k],[%i])</code> donde la &iacute;ndice mudo <code>%i</code> se escoge de forma apropiada.
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>liediff</b><i> (<var>v</var>, <var>ten</var>)</i>
<a name="IDX1068"></a>
</dt>
<dd><p>Calcula la derivada de Lie de la expresi&oacute;n tensorial <var>ten</var> respecto de campo vectorial <var>v</var>. La expresi&oacute;n <var>ten</var> debe ser cualquier tensor indexado; <var>v</var> debe ser el nombre (sin &iacute;ndices) de un campo vectorial. Por ejemplo:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(liediff(v,a([i,j],[])*b([],[k],l)))$
       k    %2            %2          %2
(%t2) b   (v   a       + v   a     + v   a    )
       ,l       i j,%2    ,j  i %2    ,i  %2 j

                          %1  k        %1  k      %1  k
                      + (v   b      - b   v    + v   b   ) a
                              ,%1 l    ,l  ,%1    ,l  ,%1   i j

</pre>

</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>rediff</b><i> (<var>ten</var>)</i>
<a name="IDX1069"></a>
</dt>
<dd><p>Calcula todas las instrucciones <code>idiff</code> que aparezcan en la expresi&oacute;n tensorial <var>ten</var>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>undiff</b><i> (<var>expr</var>)</i>
<a name="IDX1070"></a>
</dt>
<dd><p>Devuelve una expresi&oacute;n equivalente a <var>expr</var> pero con todas las derivadas de los objetos indexados reemplazadas por la forma nominal de la funci&oacute;n <code>idiff</code>. </p>
</dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>evundiff</b><i> (<var>expr</var>)</i>
<a name="IDX1071"></a>
</dt>
<dd><p>Equivale a <code>undiff</code> seguido de  <code>ev</code> y <code>rediff</code>.
</p>
<p>La raz&oacute;n de esta operaci&oacute;n es evaluar de forma sencilla expresiones que no pueden ser directamente evaluadas en su forma derivada. Por ejemplo, lo siguiente provoca un error:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) icurvature([i,j,k],[l],m);
Maxima encountered a Lisp error:

 Error in $ICURVATURE [or a callee]:
 $ICURVATURE [or a callee] requires less than three arguments.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
</pre>
<p>Sin embargo, si <code>icurvature</code> se da en forma nominal, puede ser evaluada utilizando <code>evundiff</code>:
</p>
<pre class="example">(%i3) ishow('icurvature([i,j,k],[l],m))$
                                         l
(%t3)                          icurvature
                                         i j k,m
(%i4) ishow(evundiff(%))$
             l              l         %1           l           %1
(%t4) - ichr2        - ichr2     ichr2      - ichr2       ichr2
             i k,j m        %1 j      i k,m        %1 j,m      i k

             l              l         %1           l           %1
      + ichr2        + ichr2     ichr2      + ichr2       ichr2
             i j,k m        %1 k      i j,m        %1 k,m      i j
</pre>
<p>Nota: en versiones antiguas de Maxima, las formas derivadas de los s&iacute;mbolos de
Christoffel no se pod&iacute;an evaluar. Este fallo ha sido subsanado, de manera que
<code>evundiff</code> ya no se necesita en expresiones como esta:
</p>
<pre class="example">(%i5) imetric(g);
(%o5)                                done
(%i6) ishow(ichr2([i,j],[k],l))$
       k %3
      g     (g         - g         + g        )
              j %3,i l    i j,%3 l    i %3,j l
(%t6) -----------------------------------------
                          2

                         k %3
                        g     (g       - g       + g      )
                         ,l     j %3,i    i j,%3    i %3,j
                      + -----------------------------------
                                         2
</pre>


</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>flush</b><i> (<var>expr</var>, <var>tensor_1</var>, <var>tensor_2</var>, ...)</i>
<a name="IDX1072"></a>
</dt>
<dd><p>Iguala a cero en la expresi&oacute;n <var>expr</var> todas las apariciones de <var>tensor_i</var> que no tengan &iacute;ndices de derivadas.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>flushd</b><i> (<var>expr</var>, <var>tensor_1</var>, <var>tensor_2</var>, ...)</i>
<a name="IDX1073"></a>
</dt>
<dd><p>Iguala a cero en la expresi&oacute;n <var>expr</var> todas las apariciones de <var>tensor_i</var> que tengan &iacute;ndices de derivadas
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>flushnd</b><i> (<var>expr</var>, <var>tensor</var>, <var>n</var>)</i>
<a name="IDX1074"></a>
</dt>
<dd><p>Iguala a cero en <var>expr</var> todas las apariciones del objeto diferenciado  <var>tensor</var> que tenga <var>n</var> o m&aacute;s
&iacute;ndices de derivadas, como demuestra el siguiente ejemplo:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i],[J,r],k,r)+a([i],[j,r,s],k,r,s))$
                                J r      j r s
(%t2)                          a      + a
                                i,k r    i,k r s
(%i3) ishow(flushnd(%,a,3))$
                                     J r
(%t3)                               a
                                     i,k r
</pre></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>coord</b><i> (<var>tensor_1</var>, <var>tensor_2</var>, ...)</i>
<a name="IDX1075"></a>
</dt>
<dd><p>Le da a <var>tensor_i</var> la propiedad de diferenciaci&oacute;n coordenada, que la derivada del vector contravariante cuyo nombre es uno de los <var>tensor_i</var> es igual a la delta de Kronecker.  Por ejemplo, si se ha hecho <code>coord(x)</code> entonces  <code>idiff(x([],[i]),j)</code> da <code>kdelta([i],[j])</code>. La llamada <code>coord</code> devuelve una lista de todos los objetos indexados con esta propiedad.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>remcoord</b><i> (<var>tensor_1</var>, <var>tensor_2</var>, ...)</i>
<a name="IDX1076"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>remcoord</b><i> (all)</i>
<a name="IDX1077"></a>
</dt>
<dd><p>Borra todas las propiedades de diferenciaci&oacute;n coordenada de <code>tensor_i</code> que hayan sido establecidas por la funci&oacute;n <code>coord</code>. La llamada <code>remcoord(all)</code> borra esta propiedad de todos los objetos indexados.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>makebox</b><i> (<var>expr</var>)</i>
<a name="IDX1078"></a>
</dt>
<dd><p>Muestra <var>expr</var> de la misma manera que lo hace <code>show</code>; sin embargo, cualquier tensor de d'Alembert que aparezca en  <var>expr</var> estar&aacute; indicado por <code>[]</code>.  Por ejemplo, <code>[]p([m],[n])</code> representa <code>g([],[i,j])*p([m],[n],i,j)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>conmetderiv</b><i> (<var>expr</var>, <var>tensor</var>)</i>
<a name="IDX1079"></a>
</dt>
<dd><p>Simplifica expresiones que contengan derivadas ordinarias tanto de las formas covariantes como contravariantes del tensor m&eacute;trico. Por ejemplo,  <code>conmetderiv</code> puede relacionar la derivada del tensor m&eacute;trico contravariante con los s&iacute;mbolos de Christoffel, como se ve en el ejemplo:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(g([],[a,b],c))$
                                      a b
(%t2)                                g
                                      ,c
(%i3) ishow(conmetderiv(%,g))$
                         %1 b      a       %1 a      b
(%t3)                 - g     ichr2     - g     ichr2
                                   %1 c              %1 c
</pre></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>simpmetderiv</b><i> (<var>expr</var>)</i>
<a name="IDX1080"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>simpmetderiv</b><i> (<var>expr</var>[, <var>stop</var>])</i>
<a name="IDX1081"></a>
</dt>
<dd><p>Simplifica expresiones que contienen productos de las derivadas del tensor m&eacute;trico. La funci&oacute;n <code>simpmetderiv</code> reconoce dos identidades:
</p>
<pre class="example">
   ab        ab           ab                 a
  g   g   + g   g     = (g   g  )   = (kdelta )   = 0
   ,d  bc        bc,d         bc ,d          c ,d

</pre>
<p>de donde 
</p>
<pre class="example">
   ab          ab
  g   g   = - g   g
   ,d  bc          bc,d
</pre>
<p>y
</p>
<pre class="example">
  ab          ab
 g   g     = g   g
  ,j  ab,i    ,i  ab,j

</pre>
<p>que se deduce de las simetr&iacute;as de los s&iacute;mbolos de Christoffel.
</p>
<p>La funci&oacute;n <code>simpmetderiv</code> tiene un argumento opcional, el cual detiene la funci&oacute;n despu&eacute;s de la primera sustituci&oacute;n exitosa en un expresi&oacute;n producto. La funci&oacute;n <code>simpmetderiv</code> tambi&eacute;n hace uso de la variable global <var>flipflag</var> que determina c&oacute;mo aplicar una ordenaci&oacute;n &quot;can&oacute;nica&quot; a los &iacute;ndices de los productos.
</p>
<p>Todo esto se puede utilizar para conseguir buenas simplificaciones que ser&iacute;an dif&iacute;ciles o imposibles de conseguir, lo que se demuestra en el siguiente ejemplo, que utiliza expl&iacute;citamente las simplificaciones parciales de <code>simpmetderiv</code>:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                                done
(%i3) ishow(g([],[a,b])*g([],[b,c])*g([a,b],[],d)*g([b,c],[],e))$
                             a b  b c
(%t3)                       g    g    g      g
                                       a b,d  b c,e
(%i4) ishow(canform(%))$

errexp1 has improper indices
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) ishow(simpmetderiv(%))$
                             a b  b c
(%t5)                       g    g    g      g
                                       a b,d  b c,e
(%i6) flipflag:not flipflag;
(%o6)                                true
(%i7) ishow(simpmetderiv(%th(2)))$
                               a b  b c
(%t7)                         g    g    g    g
                               ,d   ,e   a b  b c
(%i8) flipflag:not flipflag;
(%o8)                                false
(%i9) ishow(simpmetderiv(%th(2),stop))$
                               a b  b c
(%t9)                       - g    g    g      g
                                    ,e   a b,d  b c
(%i10) ishow(contract(%))$
                                    b c
(%t10)                           - g    g
                                    ,e   c b,d

</pre>
<p>V&eacute;ase tambi&eacute;n <code>weyl.dem</code> para un ejemplo que utiliza <code>simpmetderiv</code> y <code>conmetderiv</code> para simplificar contracciones del tensor de Weyl.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>flush1deriv</b><i> (<var>expr</var>, <var>tensor</var>)</i>
<a name="IDX1082"></a>
</dt>
<dd><p>Iguala a cero en <code>expr</code> todas las apariciones de <code>tensor</code> que tengan exactamente un &iacute;ndice derivado.
</p>
</dd></dl>

<hr size="6">
<a name="SEC142"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC141" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC143" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC134" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC138" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC149" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.2.4 Tensores en espacios curvos </h3>

<dl>
<dt><u>Funci&oacute;n:</u> <b>imetric</b><i> (<var>g</var>)</i>
<a name="IDX1083"></a>
</dt>
<dt><u>Variable de sistema:</u> <b>imetric</b>
<a name="IDX1084"></a>
</dt>
<dd><p>Especifica la m&eacute;trica haciendo la asignaci&oacute;n de la variable <code>imetric:<var>g</var></code>, adem&aacute;s las propiedades de contracci&oacute;n de la m&eacute;trica <var>g</var> se fijan ejecutando las instrucciones <code>defcon(<var>g</var>), defcon(<var>g</var>,<var>g</var>,kdelta)</code>. La variable <code>imetric</code>, a la que no se le asigna ning&uacute;n valor por defecto, tiene el valor de la m&eacute;trica que se le haya asignado con la instrucci&oacute;n <code>imetric(<var>g</var>)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>idim</b><i> (<var>n</var>)</i>
<a name="IDX1085"></a>
</dt>
<dd><p>Establece las dimensiones de la m&eacute;trica. Tambi&eacute;n inicializa las propiedades de antisimetr&iacute;a de los s&iacute;mbolos de Levi-Civita para la dimensi&oacute;n dada.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>ichr1</b><i> ([<var>i</var>, <var>j</var>, <var>k</var>])</i>
<a name="IDX1086"></a>
</dt>
<dd><p>Devuelve el s&iacute;mbolo de Christoffel de primera especie dado por la definici&oacute;n 
</p><pre class="example">       (g      + g      - g     )/2 .
         ik,j     jk,i     ij,k
</pre>
<p>Para evaluar los s&iacute;mbolos de Christoffel de una m&eacute;trica determinada, a la variable  <code>imetric</code> hay que asignarle un nombre como en el ejemplo de la descripci&oacute;n de <code>chr2</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>ichr2</b><i> ([<var>i</var>, <var>j</var>], [<var>k</var>])</i>
<a name="IDX1087"></a>
</dt>
<dd><p>Devuelve el s&iacute;mbolo de Christoffel de segunda especie dado por la definici&oacute;n
</p><pre class="example">                       ks
   ichr2([i,j],[k]) = g    (g      + g      - g     )/2
                             is,j     js,i     ij,s
</pre></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>icurvature</b><i> ([<var>i</var>, <var>j</var>, <var>k</var>], [<var>h</var>])</i>
<a name="IDX1088"></a>
</dt>
<dd><p>Devuelve el tensor de curvatura de Riemann en t&eacute;rminos de los s&iacute;mbolos de Christoffel de segunda especie (<code>ichr2</code>).  Se utiliza la siguiente notaci&oacute;n:
</p><pre class="example">               h             h            h         %1         h
     icurvature     = - ichr2      - ichr2     ichr2    + ichr2
               i j k         i k,j        %1 j      i k        i j,k
                               h          %1
                        + ichr2      ichr2
                               %1 k       i j
</pre></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>covdiff</b><i> (<var>expr</var>, <var>v_1</var>, <var>v_2</var>, ...)</i>
<a name="IDX1089"></a>
</dt>
<dd><p>Devuelve la derivada covariante de <var>expr</var> respecto de las variables  <var>v_i</var> en t&eacute;rminos de los s&iacute;mbolos de Christoffel de segunda especie (<code>ichr2</code>). Para evaluarlos debe hacerse <code>ev(<var>expr</var>,ichr2)</code>.
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) entertensor()$
Enter tensor name: a;
Enter a list of the covariant indices: [i,j];
Enter a list of the contravariant indices: [k];
Enter a list of the derivative indices: [];
                                      k
(%t2)                                a
                                      i j
(%i3) ishow(covdiff(%,s))$
             k         %1     k         %1     k
(%t3)     - a     ichr2    - a     ichr2    + a
             i %1      j s    %1 j      i s    i j,s

             k     %1
      + ichr2     a
             %1 s  i j
(%i4) imetric:g;
(%o4)                                  g
(%i5) ishow(ev(%th(2),ichr2))$
         %1 %4  k
        g      a     (g       - g       + g      )
                i %1   s %4,j    j s,%4    j %4,s
(%t5) - ------------------------------------------
                            2
    %1 %3  k
   g      a     (g       - g       + g      )
           %1 j   s %3,i    i s,%3    i %3,s
 - ------------------------------------------
                       2
    k %2  %1
   g     a    (g        - g        + g       )
          i j   s %2,%1    %1 s,%2    %1 %2,s     k
 + ------------------------------------------- + a
                        2                         i j,s

</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>lorentz_gauge</b><i> (<var>expr</var>)</i>
<a name="IDX1090"></a>
</dt>
<dd><p>Impone la condici&oacute;n de Lorentz sustituyendo por 0 todos los objetos indexados de <var>expr</var> que tengan un &iacute;ndice derivado id&eacute;ntico a un &iacute;ndice contravariante.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>igeodesic_coords</b><i> (<var>expr</var>, <var>nombre</var>)</i>
<a name="IDX1091"></a>
</dt>
<dd><p>Elimina los s&iacute;mbolos no diferenciados de Christoffel y las primeras derivadas del tensor m&eacute;trico de <var>expr</var>. El argumento <var>nombre</var> de la funci&oacute;n <code>igeodesic_coords</code> se refiere a la m&eacute;trica <var>nombre</var> si aparece en <var>expr</var>, mientras que los coeficientes de conexi&oacute;n deben tener los nombres  <code>ichr1</code> y/o <code>ichr2</code>. El siguiente ejemplo hace la verificaci&oacute;n de la identidad c&iacute;clica satisfecha por el tensor de curvatura de Riemann haciendo uso de la funci&oacute;n <code>igeodesic_coords</code>.
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(icurvature([r,s,t],[u]))$
             u            u         %1         u     
(%t2) - ichr2      - ichr2     ichr2    + ichr2      
             r t,s        %1 s      r t        r s,t 

                                              u         %1
                                       + ichr2     ichr2
                                              %1 t      r s
(%i3) ishow(igeodesic_coords(%,ichr2))$
                                 u            u
(%t3)                       ichr2      - ichr2
                                 r s,t        r t,s
(%i4) ishow(igeodesic_coords(icurvature([r,s,t],[u]),ichr2)+
            igeodesic_coords(icurvature([s,t,r],[u]),ichr2)+
            igeodesic_coords(icurvature([t,r,s],[u]),ichr2))$
             u            u            u            u
(%t4) - ichr2      + ichr2      + ichr2      - ichr2
             t s,r        t r,s        s t,r        s r,t

                                             u            u
                                      - ichr2      + ichr2
                                             r t,s        r s,t
(%i5) canform(%);
(%o5)                                  0

</pre>
</dd></dl>

<hr size="6">
<a name="SEC143"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC142" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC134" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC138" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC149" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.2.5 Sistemas de referencia m&oacute;viles </h3>

<p>Maxima puede hacer c&aacute;lculos utilizando sistemas de referencia m&oacute;viles, los cuales pueden ser ortonormales o cualesquiera otros.
</p>
<p>Para utilizar sistemas de referencia, primero se debe asignar a la variable <code>iframe_flag</code> el valor <code>true</code>. Con esto se hace que los s&iacute;mbolos de Christoffel, <code>ichr1</code> y <code>ichr2</code>, sean reemplazados por los coeficientes <code>icc1</code> y <code>icc2</code> en los c&aacute;lculos, cambiando as&iacute; el comportamiento de <code>covdiff</code> y <code>icurvature</code>.
</p>
<p>El sistema de referencia se define con dos tensores: el campo del sistema de referencia inverso (<code>ifri</code>, la base dual tetrad) y la m&eacute;trica del sistema de referencia <code>ifg</code>. La m&eacute;trica del sistema de referencia es la matriz identidad en los sistemas de referencia ortonormales, o la m&eacute;trica de Lorentz en sistemas de referencia ortonormales en el espacio-tiempo de Minkowski.  El campo del sistema de referencia inverso define la base del sistema de referencia con vectores unitarios. Las propiedades contractivas se definen para el campo y la m&eacute;trica del sistema de referencia.
</p>
<p>Si <code>iframe_flag</code> vale <code>true</code>, muchas expresiones de <code>itensor</code> utilizan la m&eacute;trica <code>ifg</code> en lugar de la m&eacute;trica definida por <code>imetric</code> para incrementar y reducir &iacute;ndices.
</p>
<p>IMPORTANTE: Asignando a la variable <code>iframe_flag</code> el valor <code>true</code> NO deshace las propiedades contractivas de una m&eacute;trica establecidas con una llamada a <code>defcon</code> o a <code>imetric</code>. Si se utiliza el campo del sistema de referencia, es mejor definir la m&eacute;trica asignando su nombre a la variable  <code>imetric</code> y NO hacer una llamada a la funci&oacute;n <code>imetric</code>.
</p>
<p>Maxima utiliza estos dos tensores para definir los coeficientes del sistema de referencia: <code>ifc1</code> y and <code>ifc2</code>, los cuales forman parte de los coeficientes de conexi&oacute;n <code>icc1</code> y <code>icc2</code>, tal como demuestra el siguiente ejemplo:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) iframe_flag:true;
(%o2)                                true
(%i3) ishow(covdiff(v([],[i]),j))$
                               i        i     %1
(%t3)                         v   + icc2     v
                               ,j       %1 j
(%i4) ishow(ev(%,icc2))$
                               %1     i       i
(%t4)                         v   ifc2     + v
                                      %1 j    ,j
(%i5) ishow(ev(%,ifc2))$
                          %1    i %2                i
(%t5)                    v   ifg     ifc1        + v
                                         %1 j %2    ,j
(%i6) ishow(ev(%,ifc1))$
            %1    i %2
           v   ifg     (ifb        - ifb        + ifb       )
                           j %2 %1      %2 %1 j      %1 j %2     i
(%t6)      -------------------------------------------------- + v
                                   2                             ,j
(%i7) ishow(ifb([a,b,c]))$
                                                   %3    %4
(%t7)               (ifri        - ifri       ) ifr   ifr
                         a %3,%4       a %4,%3     b     c

</pre>
<p>Se utiliza un m&eacute;todo alternativo  para calcular el sistema de referencia <code>ifb</code> si la variable <code>iframe_bracket_form</code> vale <code>false</code>:
</p>
<pre class="example">
(%i8) block([iframe_bracket_form:false],ishow(ifb([a,b,c])))$
                                %6    %5        %5      %6
(%t8)              ifri     (ifr   ifr     - ifr     ifr  )
                       a %5     b     c,%6      b,%6    c

</pre>

<dl>
<dt><u>Variable:</u> <b>ifb</b>
<a name="IDX1092"></a>
</dt>
<dd><p>Es el sistema de referencia soporte. La contribuci&oacute;n de la m&eacute;trica del campo a los coeficientes de conexi&oacute;n se expresa utilizando:
</p>
<pre class="example">
          - ifb      + ifb      + ifb
               c a b      b c a      a b c
ifc1    = --------------------------------
    abc                  2

</pre>
<p>El sistema de referencia soporte se define en t&eacute;rminos del campo y la m&eacute;trica del sistema de referencia. Se utilizan dos m&eacute;todos alternativos dependiendo del valor de <code>frame_bracket_form</code>. Si vale <code>true</code> (que es el valor por defecto) o si <code>itorsion_flag</code> vale <code>true</code>:
</p>
<pre class="example">
          d      e                                      f
ifb =  ifr    ifr   (ifri      - ifri      - ifri    itr   )
   abc    b      c       a d,e       a e,d       a f    d e


</pre>
<p>En otro caso:
</p>
<pre class="example">
             e      d        d      e
ifb    = (ifr    ifr    - ifr    ifr   ) ifri
   abc       b      c,e      b,e    c        a d

</pre>

</dd></dl>


<dl>
<dt><u>Variable:</u> <b>icc1</b>
<a name="IDX1093"></a>
</dt>
<dd><p>Coeficientes de conexi&oacute;n de primera especie. Se definen en <code>itensor</code> como
</p>
<pre class="example">
icc1    = ichr1    - ikt1    - inmc1
    abc        abc       abc        abc

</pre>
<p>En esta expresi&oacute;n, si <code>iframe_flag</code> vale <code>true</code>, el s&iacute;mbolo de Christoffel <code>ichr1</code> se reemplaza por el coeficiente de conexi&oacute;n del sistema de referencia <code>ifc1</code>. Si <code>itorsion_flag</code> vale <code>false</code>, <code>ikt1</code> ser&aacute; omitido. Tambi&eacute;n se omite si se utiliza una base, ya que la torsi&oacute;n ya est&aacute; calculada como parte del sistema de referencia.
</p>
</dd></dl>


<dl>
<dt><u>Variable:</u> <b>icc2</b>
<a name="IDX1094"></a>
</dt>
<dd><p>Coeficientes de conexi&oacute;n de segunda especie. Se definen en <code>itensor</code> como
</p>
<pre class="example">
    c         c        c         c
icc2   = ichr2   - ikt2   - inmc2
    ab        ab       ab        ab

</pre>
<p>En esta expresi&oacute;n, si la variable <code>iframe_flag</code> vale <code>true</code>, el s&iacute;mbolo de Christoffel <code>ichr2</code> se reemplaza por el coeficiente de conexi&oacute;n del sistema de referencia <code>ifc2</code>. Si <code>itorsion_flag</code> vale <code>false</code>, <code>ikt2</code> se omite. Tambi&eacute;n se omite si se utiliza una base de referncia. Por &uacute;ltimo, si  <code>inonmet_flag</code> vale <code>false</code>, se omite <code>inmc2</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>ifc1</b>
<a name="IDX1095"></a>
</dt>
<dd><p>Coeficiente del sistema de referencia de primera especie, tambi&eacute;n conocido como coeficientes de rotaci&oacute;n de Ricci. Este tensor represnta la contribuci&oacute;n de la m&eacute;trica del sistema de referencia al coeficiente de conexi&oacute;n de primera especie, definido como
</p>
<pre class="example">
          - ifb      + ifb      + ifb
               c a b      b c a      a b c
ifc1    = --------------------------------
    abc                   2


</pre>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>ifc2</b>
<a name="IDX1096"></a>
</dt>
<dd><p>Coeficiente del sistema de referencia de segunda especie. Este tensor representa
la contribuci&oacute;n de la m&eacute;trica del sistema de referencia al coeficiente 
de conexi&oacute;n de segunda especie, definido como
</p>
<pre class="example">
    c       cd
ifc2   = ifg   ifc1
    ab             abd

</pre>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>ifr</b>
<a name="IDX1097"></a>
</dt>
<dd><p>El campo del sistema de referencia. Se contrae con el campo inverso <code>ifri</code> para formar la m&eacute;trica del sistema de referencia, <code>ifg</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>ifri</b>
<a name="IDX1098"></a>
</dt>
<dd><p>Campo inverso del sistema de referencia. Especifica la base del sistema de referencia (vectores de la base dual).
</p>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>ifg</b>
<a name="IDX1099"></a>
</dt>
<dd><p>La m&eacute;trica del sistema de referencia. Su valor por defecto es <code>kdelta</code>, pero puede cambiarse utilizando 
<code>components</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>ifgi</b>
<a name="IDX1100"></a>
</dt>
<dd><p>La m&eacute;trica inversa del sistema de referencia. Se contrae con la m&eacute;trica <code>ifg</code> para dar <code>kdelta</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>iframe_bracket_form</b>
<a name="IDX1101"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Especifica c&oacute;mo se calcula <code>ifb</code>.
</p>
</dd></dl>

<hr size="6">
<a name="SEC144"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC143" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC145" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC134" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC138" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC149" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.2.6 Torsi&oacute;n y no metricidad </h3>

<p>Maxima trabaja con conceptos como la torsi&oacute;n y la no metricidad. Cuando la variable <code>itorsion_flag</code> vale <code>true</code>, la contribuci&oacute;n de la torsi&oacute;n se a&ntilde;ade a los coeficientes de conexi&oacute;n. Tambi&eacute;n se a&ntilde;aden las componentes de no metricidad cuando <code>inonmet_flag</code> vale  <code>true</code>.
</p>
<dl>
<dt><u>Variable:</u> <b>inm</b>
<a name="IDX1102"></a>
</dt>
<dd><p>Vector de no metricidad. La no metricidad conforme se define a partir de la derivada covariante del tensor m&eacute;trico. La derivada covariante del tensor m&eacute;trico, que normalmente es nula, se calcula, cuando <code>inonmet_flag</code> vale <code>true</code>, como 
</p>
<pre class="example">g     =- g  inm
 ij;k     ij   k
</pre>
</dd></dl>


<dl>
<dt><u>Variable:</u> <b>inmc1</b>
<a name="IDX1103"></a>
</dt>
<dd><p>Permutaci&oacute;n covariante de las componentes del vector de no metricidad. Se define como
</p>
<pre class="example">
           g   inm  - inm  g   - g   inm
            ab    c      a  bc    ac    b
inmc1    = ------------------------------
     abc                 2

</pre>
<p>(Sustit&uacute;yase <code>g</code> por <code>ifg</code> si se utiliza una m&eacute;trica para el sistema de referencia.)
</p>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>inmc2</b>
<a name="IDX1104"></a>
</dt>
<dd><p>Permutaci&oacute;n contravariante de las componentes del vector de no metricidad. Se utiliza en los coeficientes de conexi&oacute;n si <code>inonmet_flag</code> vale <code>true</code>. Se define como
</p>
<pre class="example">
                      c         c         cd
          -inm  kdelta  - kdelta  inm  + g   inm  g
     c        a       b         a    b          d  ab
inmc2   = -------------------------------------------
     ab                        2

</pre>
<p>(Sustit&uacute;yase <code>g</code> por <code>ifg</code> si se utiliza una m&eacute;trica para el sistema de referencia.)
</p>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>ikt1</b>
<a name="IDX1105"></a>
</dt>
<dd><p>Permutaci&oacute;n covariante del tensor de permutaci&oacute;n, tambi&eacute;n conocido como contorsi&oacute;n. Se define como
</p>
<pre class="example">
                  d           d       d
          -g   itr  - g    itr   - itr   g
            ad    cb    bd    ca      ab  cd
ikt1    = ----------------------------------
    abc                   2

</pre>
<p>(Sustit&uacute;yase <code>g</code> por <code>ifg</code> si se utiliza una m&eacute;trica para el sistema de referencia.)
</p>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>ikt2</b>
<a name="IDX1106"></a>
</dt>
<dd><p>Permutaci&oacute;n contravariante del tensor de permutaci&oacute;n, tambi&eacute;n conocido como contorsi&oacute;n. Se define como
</p>
<pre class="example">
    c     cd
ikt2   = g   ikt1
    ab           abd

</pre>
<p>(Sustit&uacute;yase <code>g</code> por <code>ifg</code> si se utiliza una m&eacute;trica para el sistema de referencia.)
</p>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>itr</b>
<a name="IDX1107"></a>
</dt>
<dd><p>Tensor de torsi&oacute;n. Para una m&eacute;trica con torsi&oacute;n, la diferenciaci&oacute;n covariante iterada de una funci&oacute;n escalar no conmuta, tal como demuestra el siguiente ejemplo:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric:g;
(%o2)                                  g
(%i3) covdiff(covdiff(f([],[]),i),j)
         -covdiff(covdiff(f([],[]),j),i)$
(%i4) ishow(%)$
                                   %4              %2
(%t4)                    f    ichr2    - f    ichr2
                          ,%4      j i    ,%2      i j
(%i5) canform(%);
(%o5)                                  0
(%i6) itorsion_flag:true;
(%o6)                                true
(%i7) covdiff(covdiff(f([],[]),i),j)
        -covdiff(covdiff(f([],[]),j),i)$
(%i8) ishow(%)$
                           %8             %6
(%t8)             f    icc2    - f    icc2    - f     + f
                   ,%8     j i    ,%6     i j    ,j i    ,i j
(%i9) ishow(canform(%))$
                                   %1             %1
(%t9)                     f    icc2    - f    icc2
                           ,%1     j i    ,%1     i j
(%i10) ishow(canform(ev(%,icc2)))$
                                   %1             %1
(%t10)                    f    ikt2    - f    ikt2
                           ,%1     i j    ,%1     j i
(%i11) ishow(canform(ev(%,ikt2)))$
                      %2 %1                    %2 %1
(%t11)          f    g      ikt1       - f    g      ikt1
                 ,%2            i j %1    ,%2            j i %1
(%i12) ishow(factor(canform(rename(expand(ev(%,ikt1))))))$
                           %3 %2            %1       %1
                     f    g      g      (itr    - itr   )
                      ,%3         %2 %1     j i      i j
(%t12)               ------------------------------------
                                      2
(%i13) decsym(itr,2,1,[anti(all)],[]);
(%o13)                               done
(%i14) defcon(g,g,kdelta);
(%o14)                               done
(%i15) subst(g,nounify(g),%th(3))$
(%i16) ishow(canform(contract(%)))$
                                           %1
(%t16)                           - f    itr
                                    ,%1    i j

</pre>
</dd></dl>

<hr size="6">
<a name="SEC145"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC144" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC146" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC134" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC138" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC149" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.2.7 &Aacute;lgebra exterior </h3>

<p>Con el paquete <code>itensor</code> se pueden realizar operaciones en campos tensoriales covariantes antisim&eacute;tricos. Un campo tensorial totalmente antisim&eacute;trrico de rango (0,L) se corresponde con una L-forma diferencial. Sobre estos objetos se define una operaci&oacute;n que se llama producto exterior.
</p>
<p>Desafortunadamente no hay consenso entre los autores a la hora de definir el producto exterior. Algunos autores prefieren una definici&oacute;n que se corresponde con la noci&oacute;n de antisimetrizaci&oacute;n, con lo que el producto externo de dos campos vectoriales se definir&iacute;a como
</p>
<pre class="example">            a a  - a a
             i j    j i
 a  /\ a  = -----------
  i     j        2
</pre>
<p>De forma m&aacute;s general, el producto de una p-forma por una q-forma se definir&iacute;a como
</p>
<pre class="example">                       1     k1..kp l1..lq
A       /\ B       = ------ D              A       B
 i1..ip     j1..jq   (p+q)!  i1..ip j1..jq  k1..kp  l1..lq
</pre>
<p>donde <code>D</code> es la delta de Kronecker.
</p>
<p>Otros autores, sin embargo, prefieren una definici&oacute;n &quot;geom&eacute;trica&quot; que se corresponde con la noci&oacute;n del elemento de volumen,
</p>
<pre class="example">a  /\ a  = a a  - a a
 i     j    i j    j i
</pre>
<p>y, en el caso general,
</p>
<pre class="example">                       1    k1..kp l1..lq
A       /\ B       = ----- D              A       B
 i1..ip     j1..jq   p! q!  i1..ip j1..jq  k1..kp  l1..lq
</pre>
<p>Puesto que <code>itensor</code> un paquete de &aacute;lgebra tensorial, la primera de estas dos definiciones parece la m&aacute;s natural. Sin embargo, muchas aplicaciones hacen uso de la segunda definici&oacute;n. Para resolver el dilema, se define una variable que controla el comportamiento del producto exteriort: si <code>igeowedge_flag</code> vale <code>false</code> (el valor por defecto), se utiliza la primera definici&oacute;n, si vale <code>true</code>, la segunda.
</p>
<dl>
<dt><u>Operador:</u> <b>~</b>
<a name="IDX1108"></a>
</dt>
<dd><p>El operador del producto exterior se representa por el s&iacute;mbolo <code>~</code>. Este es un operador binario. Sus argumentos deben ser expresiones que tengan escalares, tensores covariantes de rango uno o tensores covariantes de rango <code>l</code> que hayan sido declarados antisim&eacute;tricos en todos los &iacute;ndices covariantes.
</p>
<p>El comportamiento del operador del producto exterior se controla con la variable <code>igeowedge_flag</code>, como en el ejemplo siguiente:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i])~b([j]))$
                                 a  b  - b  a
                                  i  j    i  j
(%t2)                            -------------
                                       2
(%i3) decsym(a,2,0,[anti(all)],[]);
(%o3)                                done
(%i4) ishow(a([i,j])~b([k]))$
                          a    b  + b  a    - a    b
                           i j  k    i  j k    i k  j
(%t4)                     ---------------------------
                                       3
(%i5) igeowedge_flag:true;
(%o5)                                true
(%i6) ishow(a([i])~b([j]))$
(%t6)                            a  b  - b  a
                                  i  j    i  j
(%i7) ishow(a([i,j])~b([k]))$
(%t7)                     a    b  + b  a    - a    b
                           i j  k    i  j k    i k  j
</pre>
</dd></dl>

<dl>
<dt><u>Operador:</u> <b>|</b>
<a name="IDX1109"></a>
</dt>
<dd><p>La barra vertical <code>|</code> representa la operaci&oacute;n &quot;contracci&oacute;n con un vector&quot;. Cuando un tensor covariante totalmente antisim&eacute;trico se contrae con un vector contravariante, el resultado no depende del &iacute;ndice utilizado para la contracci&oacute;n. As&iacute;, es posible definir la operaci&oacute;n de contracci&oacute;n de forma que no se haga referencia al &iacute;ndice.
</p>
<p>En el paquete <code>itensor</code> la contracci&oacute;n con un vector se realiza siempre respecto del primer &iacute;ndice de la ordenaci&oacute;n literal. Ejemplo:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) decsym(a,2,0,[anti(all)],[]);
(%o2)                                done
(%i3) ishow(a([i,j],[])|v)$
                                    %1
(%t3)                              v   a
                                        %1 j
(%i4) ishow(a([j,i],[])|v)$
                                     %1
(%t4)                             - v   a
                                         %1 j
</pre>
<p>N&oacute;tese que es primordial que los tensores utilizados junto con el operador <code>|</code> se declaren totalmente antisim&eacute;tricos en sus  &iacute;ndices covariantes. De no ser as&iacute;, se pueden obtener resultados incorrectos.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>extdiff</b><i> (<var>expr</var>, <var>i</var>)</i>
<a name="IDX1110"></a>
</dt>
<dd><p>Calcula la derivada exterior de <var>expr</var> con respecto del &iacute;ndice <var>i</var>. La derivada exterior se define formalmente como el producto exterior del operador de la derivada parcial y una forma diferencial. Por lo tanto, esta operaci&oacute;n tambi&eacute;n se ve afectada por el valor que tome la variable <code>igeowedge_flag</code>. Ejemplo:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(extdiff(v([i]),j))$
                                  v    - v
                                   j,i    i,j
(%t2)                             -----------
                                       2
(%i3) decsym(a,2,0,[anti(all)],[]);
(%o3)                                done
(%i4) ishow(extdiff(a([i,j]),k))$
                           a      - a      + a
                            j k,i    i k,j    i j,k
(%t4)                      ------------------------
                                      3
(%i5) igeowedge_flag:true;
(%o5)                                true
(%i6) ishow(extdiff(v([i]),j))$
(%t6)                             v    - v
                                   j,i    i,j
(%i7) ishow(extdiff(a([i,j]),k))$
(%t7)                    - (a      - a      + a     )
                             k j,i    k i,j    j i,k

</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>hodge</b><i> (<var>expr</var>)</i>
<a name="IDX1111"></a>
</dt>
<dd><p>Calcula el dual de Hodge  <var>expr</var>. Por ejemplo:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                            done
(%i3) idim(4);
(%o3)                            done
(%i4) icounter:100;
(%o4)                             100
(%i5) decsym(A,3,0,[anti(all)],[])$

(%i6) ishow(A([i,j,k],[]))$
(%t6)                           A
                                 i j k
(%i7) ishow(canform(hodge(%)))$
                          %1 %2 %3 %4
               levi_civita            g        A
                                       %1 %102  %2 %3 %4
(%t7)          -----------------------------------------
                                   6
(%i8) ishow(canform(hodge(%)))$
                 %1 %2 %3 %8            %4 %5 %6 %7
(%t8) levi_civita            levi_civita            g       
                                                     %1 %106
                             g        g        g      A         /6
                              %2 %107  %3 %108  %4 %8  %5 %6 %7
(%i9) lc2kdt(%)$

(%i10) %,kdelta$

(%i11) ishow(canform(contract(expand(%))))$
(%t11)                     - A
                              %106 %107 %108

</pre>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>igeowedge_flag</b>
<a name="IDX1112"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Controla el comportamiento del producto exterior y de la derivada exterior. Cuando vale <code>false</code>, la noci&oacute;n de formas diferenciales se corresponde con el de campo tensorial covariante totalmente antisim&eacute;trico. Cuando vale <code>true</code>, las formas diferenciales se corresponden con la idea de elemento de volumen.
</p>
</dd></dl>


<hr size="6">
<a name="SEC146"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC145" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC147" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC134" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC138" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC149" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.2.8 Exportando expresiones en TeX </h3>


<p>El paquete <code>itensor</code> dispone de soporte limitado para exportar expresiones con tensores a TeX. Puesto que las expresiones de <code>itensor</code> son llamadas a funciones, puede que la instrucci&oacute;n habitual en Maxima, <code>tex</code>, no devuleva los resultados esperados. Se puede utlizar el comando <code>tentex</code>, que tratar&aacute; de traducir expresiones tensoriales a objetos de TeX correctamente indexados.
</p>
<dl>
<dt><u>Funci&oacute;n:</u> <b>tentex</b><i> (<var>expr</var>)</i>
<a name="IDX1113"></a>
</dt>
<dd><p>Para utilizar la funci&oacute;n <code>tentex</code>, primero se debe cargar <code>tentex</code>, tal como muestra el siguiente ejemplo:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) load(tentex);
(%o2)       /share/tensor/tentex.lisp
(%i3) idummyx:m;
(%o3)                                  m
(%i4) ishow(icurvature([j,k,l],[i]))$
            m1       i           m1       i           i
(%t4)  ichr2    ichr2     - ichr2    ichr2     - ichr2
            j k      m1 l        j l      m1 k        j l,k

                                                      i
                                               + ichr2
                                                      j k,l
(%i5) tentex(%)$
$$\Gamma_{j\,k}^{m_1}\,\Gamma_{l\,m_1}^{i}-\Gamma_{j\,l}^{m_1}\,
 \Gamma_{k\,m_1}^{i}-\Gamma_{j\,l,k}^{i}+\Gamma_{j\,k,l}^{i}$$

</pre>
<p>N&oacute;tese la asignaci&oacute;n de la variable <code>idummyx</code> para evitar la aparici&oacute;n del s&iacute;mbolo del porcentaje en la expresi&oacute;n en TeX, que puede dar errores de compilaci&oacute;n.
</p>
<p>T&eacute;ngase en cuenta que esta versi&oacute;n de la funci&oacute;n <code>tentex</code> es experimental.
</p>
</dd></dl>

<hr size="6">
<a name="SEC147"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC146" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC148" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC134" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC138" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC149" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.2.9 Interactuando con ctensor </h3>

<p>El paquete <code>itensor</code> genera c&oacute;digo Maxima que luego puede ser ejecutado en el contexto del paquete <code>ctensor</code>. La funci&oacute;n que se encarga de esta tarea es <code>ic_convert</code>.
</p>
<dl>
<dt><u>Function:</u> <b>ic_convert</b><i> (<var>eqn</var>)</i>
<a name="IDX1114"></a>
</dt>
<dd><p>Convierte la ecuaci&oacute;n <var>eqn</var> del entorno <code>itensor</code> a una sentencia de asignaci&oacute;n de <code>ctensor</code>. Sumas impl&iacute;citas sobre &iacute;ndices mudos se hacen expl&iacute;citas mientras que objetos indexados se transforman en arreglos (los sub&iacute;ndices de los arreglos se ordenan poniendo primero los covariantes seguidos de los contravariantes. La derivada de un objeto indexado se reemplazar&aacute; por por la forma nominal de <code>diff</code> tomada con respecto a <code>ct_coords</code> con el sub&iacute;ndice correspondiente al &iacute;ndice derivado. Los s&iacute;mbolos de Christoffel <code>ichr1</code>  <code>ichr2</code> se traducen a <code>lcs</code> y <code>mcs</code>, respectivamente. Adem&aacute;s, se a&ntilde;aden bucles <code>do</code> para la sumaci&oacute;n de todos los &iacute;ndices libres, de manera que la sentencia traducida pueda ser evaluada haciendo simplemente <code>ev</code>. Los siguientes ejemplos muestran las funcionalidades de esta funci&oacute;n.
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) eqn:ishow(t([i,j],[k])=f([],[])*g([l,m],[])*a([],[m],j)
      *b([i],[l,k]))$
                             k        m   l k
(%t2)                       t    = f a   b    g
                             i j      ,j  i    l m
(%i3) ic_convert(eqn);
(%o3) for i thru dim do (for j thru dim do (
       for k thru dim do
        t        : f sum(sum(diff(a , ct_coords ) b
         i, j, k                   m           j   i, l, k

 g    , l, 1, dim), m, 1, dim)))
  l, m
(%i4) imetric(g);
(%o4)                                done
(%i5) metricconvert:true;
(%o5)                                true
(%i6) ic_convert(eqn);
(%o6) for i thru dim do (for j thru dim do (
       for k thru dim do
        t        : f sum(sum(diff(a , ct_coords ) b
         i, j, k                   m           j   i, l, k

 lg    , l, 1, dim), m, 1, dim)))
   l, m
</pre>
</dd></dl>

<hr size="6">
<a name="SEC148"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC147" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC149" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC134" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC138" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC149" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.2.10 Palabras reservadas </h3>

<p>Las siguientes palabras son utilizadas por el paquete <code>itensor</code> internamente, por lo que no deber&iacute;an ser modificadas por el usuario:
</p>
<pre class="example">  Palabra    Comentarios
  ------------------------------------------
  indices2() Versi&oacute;n interna de indices()
  conti      Lista los &iacute;ndices contravariantes
  covi       Lista los &iacute;ndices covariantes
  deri       Lista los &iacute;ndices de derivadas
  name       Devuelve el nombre de un objeto indexado
  concan
  irpmon
  lc0
  _lc2kdt0
  _lcprod
  _extlc
</pre>

<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC134" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC149" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_82.html#SEC377" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Robert</em> on <em>diciembre, 10 2012</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
