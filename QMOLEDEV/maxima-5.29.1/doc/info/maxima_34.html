<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on June, 20 2016 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Maxima 5.29.1 Manual: 34. Rules and Patterns</title>

<meta name="description" content="Maxima 5.29.1 Manual: 34. Rules and Patterns">
<meta name="keywords" content="Maxima 5.29.1 Manual: 34. Rules and Patterns">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body
{
    color: black;
    background: white; 
    margin-left: 8%;
    margin-right: 13%;
}

h1
{
    margin-left: +8%;
    font-size: 150%;
    font-family: sans-serif
}

h2
{
    font-size: 125%;
    font-family: sans-serif
}

h3
{
    font-size: 100%;
    font-family: sans-serif
}

h2,h3,h4,h5,h6 { margin-left: +4%; }

div.textbox
{
    border: solid;
    border-width: thin;
    /* width: 100%; */
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em
}

div.titlebox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
    background: rgb(200,255,255);
    font-family: sans-serif
}

div.synopsisbox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
     background: rgb(255,220,255);
    /*background: rgb(200,255,255); */
    /* font-family: fixed */
}

pre.example
{
    border: 1px solid gray;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 1em;
    padding-right: 1em;
    /* background: rgb(247,242,180); */ /* kind of sandy */
    /* background: rgb(200,255,255); */ /* sky blue */
    background-color: #F1F5F9; /* light blue-gray */
    /* font-family: "Lucida Console", monospace */
}

div.spacerbox
{
    border: none;
    padding-top: 2em;
    padding-bottom: 2em
}

div.image
{
    margin: 0;
    padding: 1em;
    text-align: center;
}

div.categorybox
{
    border: 1px solid gray;
    padding-top: 0px;
    padding-bottom: 0px;
    padding-left: 1em;
    padding-right: 1em;
    background: rgb(247,242,220);
}


-->
</style>

<link rel="icon" href="http://maxima.sourceforge.net/favicon.ico"/>
</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Rules-and-Patterns"></a>
<a name="SEC180"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_33.html#SEC179" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC181" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_33.html#SEC176" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_35.html#SEC183" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_83.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 34. Rules and Patterns </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC181">34.1 Introduction to Rules and Patterns</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC182">34.2 Functions and Variables for Rules and Patterns</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
</table>

<p><a name="Item_003a-Introduction-to-Rules-and-Patterns"></a>
</p><hr size="6">
<a name="Introduction-to-Rules-and-Patterns"></a>
<a name="SEC181"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC180" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC182" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC180" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC180" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_35.html#SEC183" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_83.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 34.1 Introduction to Rules and Patterns </h2>

<p>This section describes user-defined pattern matching and simplification rules.
There are two groups of functions which implement somewhat different pattern
matching schemes.  In one group are <code>tellsimp</code>, <code>tellsimpafter</code>,
<code>defmatch</code>, <code>defrule</code>, <code>apply1</code>, <code>applyb1</code>, and
<code>apply2</code>.  In the other group are <code>let</code> and <code>letsimp</code>.
Both schemes define patterns in terms of pattern variables declared by
<code>matchdeclare</code>.
</p>
<p>Pattern-matching rules defined by <code>tellsimp</code> and <code>tellsimpafter</code> are
applied automatically by the Maxima simplifier.  Rules defined by
<code>defmatch</code>, <code>defrule</code>, and <code>let</code> are applied by an explicit
function call.
</p>
<p>There are additional mechanisms for rules applied to polynomials by
<code>tellrat</code>, and for commutative and noncommutative algebra in <code>affine</code>
package.
</p>
<div class=categorybox>


<p>Categories:&nbsp;&nbsp;<a href="maxima_99.html#Category_003a-Simplification">Simplification</a>
 &middot;
<a href="maxima_99.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
</p>
</div>



<p><a name="Item_003a-Functions-and-Variables-for-Rules-and-Patterns"></a>
</p><hr size="6">
<a name="Functions-and-Variables-for-Rules-and-Patterns"></a>
<a name="SEC182"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC181" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_35.html#SEC183" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC180" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC180" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_35.html#SEC183" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_83.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 34.2 Functions and Variables for Rules and Patterns </h2>


<p><a name="apply1"></a>
<a name="Item_003a-apply1"></a>
</p><dl>
<dt><u>Function:</u> <b>apply1</b><i> (<var>expr</var>, <var>rule_1</var>, &hellip;, <var>rule_n</var>)</i>
<a name="IDX1380"></a>
</dt>
<dd><p>Repeatedly applies <var>rule_1</var> to
<var>expr</var> until it fails, then repeatedly applies the same rule to all
subexpressions of <var>expr</var>, left to right, until <var>rule_1</var> has failed
on all subexpressions.  Call the result of transforming <var>expr</var> in this
manner <var>expr_2</var>.  Then <var>rule_2</var> is applied in the same fashion
starting at the top of <var>expr_2</var>.  When <var>rule_n</var> fails on the final
subexpression, the result is returned.
</p>
<p><code>maxapplydepth</code> is the depth of the deepest subexpressions processed by
<code>apply1</code> and <code>apply2</code>.
</p>
<p>See also <code>applyb1</code>, <code>apply2</code>, and <code>let</code>.
</p>
<div class=categorybox>


<p>Categories:&nbsp;&nbsp;<a href="maxima_99.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
</p>
</div>

</dd></dl>


<p><a name="apply2"></a>
<a name="Item_003a-apply2"></a>
</p><dl>
<dt><u>Function:</u> <b>apply2</b><i> (<var>expr</var>, <var>rule_1</var>, &hellip;, <var>rule_n</var>)</i>
<a name="IDX1381"></a>
</dt>
<dd><p>If <var>rule_1</var> fails on a given subexpression, then <var>rule_2</var> is
repeatedly applied, etc.  Only if all rules fail on a given
subexpression is the whole set of rules repeatedly applied to the next
subexpression.  If one of the rules succeeds, then the same
subexpression is reprocessed, starting with the first rule.
</p>
<p><code>maxapplydepth</code> is the depth of the deepest subexpressions processed by
<code>apply1</code> and <code>apply2</code>.
</p>
<p>See also <code>apply1</code> and <code>let</code>.
</p>
<div class=categorybox>


<p>Categories:&nbsp;&nbsp;<a href="maxima_99.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
</p>
</div>

</dd></dl>


<p><a name="applyb1"></a>
<a name="Item_003a-applyb1"></a>
</p><dl>
<dt><u>Function:</u> <b>applyb1</b><i> (<var>expr</var>, <var>rule_1</var>, &hellip;, <var>rule_n</var>)</i>
<a name="IDX1382"></a>
</dt>
<dd><p>Repeatedly applies <var>rule_1</var> to the deepest subexpression of <var>expr</var>
until it fails, then repeatedly applies the same rule one level higher (i.e.,
larger subexpressions), until <var>rule_1</var> has failed on the top-level
expression.  Then <var>rule_2</var> is applied in the same fashion to the result of
<var>rule_1</var>.  After <var>rule_n</var> has been applied to the top-level expression,
the result is returned.
</p>
<p><code>applyb1</code> is similar to <code>apply1</code> but works from
the bottom up instead of from the top down.
</p>
<p><code>maxapplyheight</code> is the maximum height which <code>applyb1</code> reaches
before giving up.
</p>
<p>See also <code>apply1</code>, <code>apply2</code>, and <code>let</code>.
</p>
<div class=categorybox>


<p>Categories:&nbsp;&nbsp;<a href="maxima_99.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
</p>
</div>

</dd></dl>

<p><a name="current_005flet_005frule_005fpackage"></a>
<a name="Item_003a-current_005flet_005frule_005fpackage"></a>
</p><dl>
<dt><u>Option variable:</u> <b>current_let_rule_package</b>
<a name="IDX1383"></a>
</dt>
<dd><p>Default value: <code>default_let_rule_package</code>
</p>
<p><code>current_let_rule_package</code> is the name of the rule package that is used by
functions in the <code>let</code> package (<code>letsimp</code>, etc.) if no other rule package is specified.
This variable may be assigned the name of any rule package defined
via the <code>let</code> command.
</p>
<p>If a call such as <code>letsimp (expr, rule_pkg_name)</code> is made,
the rule package <code>rule_pkg_name</code> is used for that function call only,
and the value of <code>current_let_rule_package</code> is not changed.
</p>
<div class=categorybox>


<p>Categories:&nbsp;&nbsp;<a href="maxima_99.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
</p>
</div>

</dd></dl>

<p><a name="default_005flet_005frule_005fpackage"></a>
<a name="Item_003a-default_005flet_005frule_005fpackage"></a>
</p><dl>
<dt><u>Option variable:</u> <b>default_let_rule_package</b>
<a name="IDX1384"></a>
</dt>
<dd><p>Default value: <code>default_let_rule_package</code>
</p>
<p><code>default_let_rule_package</code> is the name of the rule package used when one
is not explicitly set by the user with <code>let</code> or by changing the value of
<code>current_let_rule_package</code>.
</p>
<div class=categorybox>


<p>Categories:&nbsp;&nbsp;<a href="maxima_99.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
</p>
</div>

</dd></dl>

<p><a name="defmatch"></a>
<a name="Item_003a-defmatch"></a>
</p><dl>
<dt><u>Function:</u> <b>defmatch</b><i> (<var>progname</var>, <var>pattern</var>, <var>x_1</var>, &hellip;, <var>x_n</var>)</i>
<a name="IDX1385"></a>
</dt>
<dt><u>Function:</u> <b>defmatch</b><i> (<var>progname</var>, <var>pattern</var>)</i>
<a name="IDX1386"></a>
</dt>
<dd><p>Defines a function <code><var>progname</var>(<var>expr</var>, <var>x_1</var>, ..., <var>x_n</var>)</code>
which tests <var>expr</var> to see if it matches <var>pattern</var>.
</p>
<p><var>pattern</var> is an expression containing the pattern arguments <var>x_1</var>,
&hellip;, <var>x_n</var> (if any) and some pattern variables (if any).  The pattern
arguments are given explicitly as arguments to <code>defmatch</code> while the pattern
variables are declared by the <code>matchdeclare</code> function.  Any variable not
declared as a pattern variable in <code>matchdeclare</code> or as a pattern argument
in <code>defmatch</code> matches only itself.
</p>
<p>The first argument to the created function <var>progname</var> is an expression to be
matched against the pattern and the other arguments are the actual arguments
which correspond to the dummy variables <var>x_1</var>, &hellip;, <var>x_n</var> in the
pattern.
</p>
<p>If the match is successful, <var>progname</var> returns a list of equations whose
left sides are the pattern arguments and pattern variables, and whose right
sides are the subexpressions which the pattern arguments and variables matched.
The pattern variables, but not the pattern arguments, are assigned the
subexpressions they match.  If the match fails, <var>progname</var> returns
<code>false</code>.
</p>
<p>A literal pattern (that is, a pattern which contains neither pattern arguments
nor pattern variables) returns <code>true</code> if the match succeeds.
</p>
<p>See also <code>matchdeclare</code>, <code>defrule</code>, <code>tellsimp</code>, and
<code>tellsimpafter</code>.
</p>
<p>Examples:
</p>
<p>Define a function <code>linearp(expr, x)</code> which
tests <code>expr</code> to see if it is of the form <code>a*x + b</code>
such that <code>a</code> and <code>b</code> do not contain <code>x</code> and <code>a</code> is nonzero.
This match function matches expressions which are linear in any variable,
because the pattern argument <code>x</code> is given to <code>defmatch</code>.
</p>
<pre class="example">(%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b,
                    freeof(x));
(%o1)                         done
(%i2) defmatch (linearp, a*x + b, x);
(%o2)                        linearp
(%i3) linearp (3*z + (y + 1)*z + y^2, z);
                         2
(%o3)              [b = y , a = y + 4, x = z]
(%i4) a;
(%o4)                         y + 4
(%i5) b;
                                2
(%o5)                          y
(%i6) x;
(%o6)                           x
</pre>
<p>Define a function <code>linearp(expr)</code> which tests <code>expr</code>
to see if it is of the form <code>a*x + b</code>
such that <code>a</code> and <code>b</code> do not contain <code>x</code> and <code>a</code> is nonzero.
This match function only matches expressions linear in <code>x</code>,
not any other variable, because no pattern argument is given to <code>defmatch</code>.
</p>
<pre class="example">(%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b,
                    freeof(x));
(%o1)                         done
(%i2) defmatch (linearp, a*x + b);
(%o2)                        linearp
(%i3) linearp (3*z + (y + 1)*z + y^2);
(%o3)                         false
(%i4) linearp (3*x + (y + 1)*x + y^2);
                             2
(%o4)                  [b = y , a = y + 4]
</pre>
<p>Define a function <code>checklimits(expr)</code> which tests <code>expr</code>
to see if it is a definite integral.
</p>
<pre class="example">(%i1) matchdeclare ([a, f], true);
(%o1)                         done
(%i2) constinterval (l, h) := constantp (h - l);
(%o2)        constinterval(l, h) := constantp(h - l)
(%i3) matchdeclare (b, constinterval (a));
(%o3)                         done
(%i4) matchdeclare (x, atom);
(%o4)                         done
(%i5) simp : false;
(%o5)                         false
(%i6) defmatch (checklimits, 'integrate (f, x, a, b));
(%o6)                      checklimits
(%i7) simp : true;
(%o7)                         true
(%i8) 'integrate (sin(t), t, %pi + x, 2*%pi + x);
                       x + 2 %pi
                      /
                      [
(%o8)                 I          sin(t) dt
                      ]
                      /
                       x + %pi
(%i9) checklimits (%);
(%o9)    [b = x + 2 %pi, a = x + %pi, x = t, f = sin(t)]
</pre>
<div class=categorybox>


<p>Categories:&nbsp;&nbsp;<a href="maxima_99.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
</p>
</div>

</dd></dl>


<p><a name="defrule"></a>
<a name="Item_003a-defrule"></a>
</p><dl>
<dt><u>Function:</u> <b>defrule</b><i> (<var>rulename</var>, <var>pattern</var>, <var>replacement</var>)</i>
<a name="IDX1387"></a>
</dt>
<dd><p>Defines and names a replacement rule for the given pattern.  If the rule named
<var>rulename</var> is applied to an expression (by <code>apply1</code>, <code>applyb1</code>, or
<code>apply2</code>), every subexpression matching the pattern will be replaced by the
replacement.  All variables in the replacement which have been
assigned values by the pattern match are assigned those values in the
replacement which is then simplified.
</p>
<p>The rules themselves can be
treated as functions which transform an expression by one
operation of the pattern match and replacement.
If the match fails, the rule function returns <code>false</code>.
</p>
<div class=categorybox>


<p>Categories:&nbsp;&nbsp;<a href="maxima_99.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
</p>
</div>

</dd></dl>


<p><a name="disprule"></a>
<a name="Item_003a-disprule"></a>
</p><dl>
<dt><u>Function:</u> <b>disprule</b><i> (<var>rulename_1</var>, &hellip;, <var>rulename_2</var>)</i>
<a name="IDX1388"></a>
</dt>
<dt><u>Function:</u> <b>disprule</b><i> (all)</i>
<a name="IDX1389"></a>
</dt>
<dd><p>Display rules with the names <var>rulename_1</var>, &hellip;, <var>rulename_n</var>,
as returned by <code>defrule</code>, <code>tellsimp</code>, or <code>tellsimpafter</code>,
or a pattern defined by <code>defmatch</code>.
Each rule is displayed with an intermediate expression label (<code>%t</code>).
</p>
<p><code>disprule (all)</code> displays all rules.
</p>
<p><code>disprule</code> quotes its arguments.
<code>disprule</code> returns the list of intermediate expression labels corresponding
to the displayed rules.
</p>
<p>See also <code>letrules</code>, which displays rules defined by <code>let</code>.
</p>
<p>Examples:
</p>
<pre class="example">(%i1) tellsimpafter (foo (x, y), bar (x) + baz (y));
(%o1)                   [foorule1, false]
(%i2) tellsimpafter (x + y, special_add (x, y));
(%o2)                   [+rule1, simplus]
(%i3) defmatch (quux, mumble (x));
(%o3)                         quux
(%i4) disprule (foorule1, &quot;+rule1&quot;, quux);
(%t4)        foorule1 : foo(x, y) -&gt; baz(y) + bar(x)

(%t5)          +rule1 : y + x -&gt; special_add(x, y)

(%t6)                quux : mumble(x) -&gt; []

(%o6)                    [%t4, %t5, %t6]
(%i6) ''%;
(%o6) [foorule1 : foo(x, y) -&gt; baz(y) + bar(x), 
     +rule1 : y + x -&gt; special_add(x, y), quux : mumble(x) -&gt; []]
</pre>
<div class=categorybox>


<p>Categories:&nbsp;&nbsp;<a href="maxima_99.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
 &middot;
<a href="maxima_99.html#Category_003a-Display-functions">Display functions</a>
</p>
</div>

</dd></dl>

<p><a name="let"></a>
<a name="Item_003a-let"></a>
</p><dl>
<dt><u>Function:</u> <b>let</b><i> (<var>prod</var>, <var>repl</var>, <var>predname</var>, <var>arg_1</var>, &hellip;, <var>arg_n</var>)</i>
<a name="IDX1390"></a>
</dt>
<dt><u>Function:</u> <b>let</b><i> ([<var>prod</var>, <var>repl</var>, <var>predname</var>, <var>arg_1</var>, &hellip;, <var>arg_n</var>], <var>package_name</var>)</i>
<a name="IDX1391"></a>
</dt>
<dd><p>Defines a substitution rule for <code>letsimp</code> such that <var>prod</var> is replaced
by <var>repl</var>.  <var>prod</var> is a product of positive or negative powers of the
following terms:
</p>
<ul>
<li>
Atoms which <code>letsimp</code> will search for literally unless previous to calling
<code>letsimp</code> the <code>matchdeclare</code> function is used to associate a
predicate with the atom.  In this case <code>letsimp</code> will match the atom to
any term of a product satisfying the predicate.
</li><li>
Kernels such as <code>sin(x)</code>, <code>n!</code>, <code>f(x,y)</code>, etc.  As with atoms
above <code>letsimp</code> will look for a literal match unless <code>matchdeclare</code>
is used to associate a predicate with the argument of the kernel.
</li></ul>

<p>A term to a positive power will only match a term having at least that
power.  A term to a negative power
on the other hand will only match a term with a power at least as
negative.  In the case of negative powers in <var>prod</var> the switch
<code>letrat</code> must be set to <code>true</code>.
See also <code>letrat</code>.
</p>
<p>If a predicate is included in the <code>let</code> function followed by a list of
arguments, a tentative match (i.e. one that would be accepted if the predicate
were omitted) is accepted only if <code>predname (arg_1', ..., arg_n')</code>
evaluates to <code>true</code> where <var>arg_i'</var> is the value matched to <var>arg_i</var>.
The <var>arg_i</var> may be the name of any atom or the argument of any kernel
appearing in <var>prod</var>.
<var>repl</var> may be any rational expression.  If any of the atoms or arguments from <var>prod</var> appear in <var>repl</var> the
appropriate substitutions are made.  </p>
<p>The global flag <code>letrat</code> controls the simplification of quotients by
<code>letsimp</code>.  When <code>letrat</code> is <code>false</code>, <code>letsimp</code> simplifies
the numerator and denominator of <var>expr</var> separately, and does not simplify
the quotient.  Substitutions such as <code>n!/n</code> goes to <code>(n-1)!</code> then
fail.  When <code>letrat</code> is <code>true</code>, then the numerator, denominator, and
the quotient are simplified in that order.
</p>
<p>These substitution functions allow you to work with several rule packages at
once.  Each rule package can contain any number of <code>let</code> rules and is
referenced by a user-defined name.  The command <code>let ([<var>prod</var>,
<var>repl</var>, <var>predname</var>, <var>arg_1</var>, ..., <var>arg_n</var>], <var>package_name</var>)</code>
adds the rule <var>predname</var> to the rule package <var>package_name</var>.  The
command <code>letsimp (<var>expr</var>, <var>package_name</var>)</code> applies the rules in 
<var>package_name</var>.  <code>letsimp (<var>expr</var>, <var>package_name1</var>,
<var>package_name2</var>, ...)</code> is equivalent to <code>letsimp (<var>expr</var>,
<var>package_name1</var>)</code> followed by <code>letsimp (%, <var>package_name2</var>)</code>,
&hellip;
</p>
<p><code>current_let_rule_package</code> is the name of the rule package that is
presently being used.  This variable may be assigned the name of any rule
package defined via the <code>let</code> command.  Whenever any of the functions
comprising the <code>let</code> package are called with no package name, the package
named by <code>current_let_rule_package</code> is used.  If a call such as
<code>letsimp (<var>expr</var>, <var>rule_pkg_name</var>)</code> is made, the rule package
<var>rule_pkg_name</var> is used for that <code>letsimp</code> command only, and
<code>current_let_rule_package</code> is not changed.  If not otherwise specified,
<code>current_let_rule_package</code> defaults to <code>default_let_rule_package</code>.
</p>
<pre class="example">(%i1) matchdeclare ([a, a1, a2], true)$
(%i2) oneless (x, y) := is (x = y-1)$
(%i3) let (a1*a2!, a1!, oneless, a2, a1);
(%o3)         a1 a2! --&gt; a1! where oneless(a2, a1)
(%i4) letrat: true$
(%i5) let (a1!/a1, (a1-1)!);
                        a1!
(%o5)                   --- --&gt; (a1 - 1)!
                        a1
(%i6) letsimp (n*m!*(n-1)!/m);
(%o6)                      (m - 1)! n!
(%i7) let (sin(a)^2, 1 - cos(a)^2);
                        2               2
(%o7)                sin (a) --&gt; 1 - cos (a)
(%i8) letsimp (sin(x)^4);
                        4           2
(%o8)                cos (x) - 2 cos (x) + 1
</pre>
<div class=categorybox>


<p>Categories:&nbsp;&nbsp;<a href="maxima_99.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
</p>
</div>

</dd></dl>

<p><a name="letrat"></a>
<a name="Item_003a-letrat"></a>
</p><dl>
<dt><u>Option variable:</u> <b>letrat</b>
<a name="IDX1392"></a>
</dt>
<dd><p>Default value: <code>false</code>
</p>
<p>When <code>letrat</code> is <code>false</code>, <code>letsimp</code> simplifies the
numerator and denominator of a ratio separately,
and does not simplify the quotient.
</p>
<p>When <code>letrat</code> is <code>true</code>,
the numerator, denominator, and their quotient are simplified in that order.
</p>
<pre class="example">(%i1) matchdeclare (n, true)$
(%i2) let (n!/n, (n-1)!);
                         n!
(%o2)                    -- --&gt; (n - 1)!
                         n
(%i3) letrat: false$
(%i4) letsimp (a!/a);
                               a!
(%o4)                          --
                               a
(%i5) letrat: true$
(%i6) letsimp (a!/a);
(%o6)                       (a - 1)!
</pre>
<div class=categorybox>


<p>Categories:&nbsp;&nbsp;<a href="maxima_99.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
</p>
</div>

</dd></dl>


<p><a name="letrules"></a>
<a name="Item_003a-letrules"></a>
</p><dl>
<dt><u>Function:</u> <b>letrules</b><i> ()</i>
<a name="IDX1393"></a>
</dt>
<dt><u>Function:</u> <b>letrules</b><i> (<var>package_name</var>)</i>
<a name="IDX1394"></a>
</dt>
<dd><p>Displays the rules in a rule package.
<code>letrules ()</code> displays the rules in the current rule package.
<code>letrules (<var>package_name</var>)</code> displays the rules in <var>package_name</var>.
</p>
<p>The current rule package is named by <code>current_let_rule_package</code>.
If not otherwise specified, <code>current_let_rule_package</code>
defaults to <code>default_let_rule_package</code>.
</p>
<p>See also <code>disprule</code>, which displays rules defined by <code>tellsimp</code> and
<code>tellsimpafter</code>.
</p>
<div class=categorybox>


<p>Categories:&nbsp;&nbsp;<a href="maxima_99.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
</p>
</div>

</dd></dl>

<p><a name="letsimp"></a>
<a name="Item_003a-letsimp"></a>
</p><dl>
<dt><u>Function:</u> <b>letsimp</b><i> (<var>expr</var>)</i>
<a name="IDX1395"></a>
</dt>
<dt><u>Function:</u> <b>letsimp</b><i> (<var>expr</var>, <var>package_name</var>)</i>
<a name="IDX1396"></a>
</dt>
<dt><u>Function:</u> <b>letsimp</b><i> (<var>expr</var>, <var>package_name_1</var>, &hellip;, <var>package_name_n</var>)</i>
<a name="IDX1397"></a>
</dt>
<dd><p>Repeatedly applies the substitution rules defined by <code>let</code>
until no further change is made to <var>expr</var>.
</p>
<p><code>letsimp (<var>expr</var>)</code> uses the rules from <code>current_let_rule_package</code>.
</p>
<p><code>letsimp (<var>expr</var>, <var>package_name</var>)</code> uses the rules from
<var>package_name</var> without changing <code>current_let_rule_package</code>.
</p>
<p><code>letsimp (<var>expr</var>, <var>package_name_1</var>, ..., <var>package_name_n</var>)</code>
is equivalent to <code>letsimp (<var>expr</var>, <var>package_name_1</var></code>,
followed by <code>letsimp (%, <var>package_name_2</var>)</code>, and so on.
</p>
<div class=categorybox>


<p>Categories:&nbsp;&nbsp;<a href="maxima_99.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
</p>
</div>

</dd></dl>

<p><a name="let_005frule_005fpackages"></a>
<a name="Item_003a-let_005frule_005fpackages"></a>
</p><dl>
<dt><u>Option variable:</u> <b>let_rule_packages</b>
<a name="IDX1398"></a>
</dt>
<dd><p>Default value: <code>[default_let_rule_package]</code>
</p>
<p><code>let_rule_packages</code> is a list of all user-defined let rule packages
plus the default package <code>default_let_rule_package</code>.
</p>
<div class=categorybox>


<p>Categories:&nbsp;&nbsp;<a href="maxima_99.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
</p>
</div>

</dd></dl>

<p><a name="matchdeclare"></a>
<a name="Item_003a-matchdeclare"></a>
</p><dl>
<dt><u>Function:</u> <b>matchdeclare</b><i> (<var>a_1</var>, <var>pred_1</var>, &hellip;, <var>a_n</var>, <var>pred_n</var>)</i>
<a name="IDX1399"></a>
</dt>
<dd><p>Associates a predicate <var>pred_k</var> 
with a variable or list of variables <var>a_k</var>
so that <var>a_k</var> matches expressions
for which the predicate returns anything other than <code>false</code>.
</p>
<p>A predicate is the name of a function,
or a lambda expression,
or a function call or lambda call missing the last argument,
or <code>true</code> or <code>all</code>.
Any expression matches <code>true</code> or <code>all</code>.
If the predicate is specified as a function call or lambda call,
the expression to be tested is appended to the list of arguments;
the arguments are evaluated at the time the match is evaluated.
Otherwise, the predicate is specified as a function name or lambda expression,
and the expression to be tested is the sole argument.
A predicate function need not be defined when <code>matchdeclare</code> is called;
the predicate is not evaluated until a match is attempted.
</p>
<p>A predicate may return a Boolean expression as well as <code>true</code> or
<code>false</code>.  Boolean expressions are evaluated by <code>is</code> within the
constructed rule function, so it is not necessary to call <code>is</code> within the
predicate.
</p>
<p>If an expression satisfies a match predicate, the match variable is assigned the
expression, except for match variables which are operands of addition <code>+</code>
or multiplication <code>*</code>.  Only addition and multiplication are handled
specially; other n-ary operators (both built-in and user-defined) are treated
like ordinary functions.
</p>
<p>In the case of addition and multiplication, the match variable may be assigned a
single expression which satisfies the match predicate, or a sum or product
(respectively) of such expressions.  Such multiple-term matching is greedy:
predicates are evaluated in the order in which their associated variables
appear in the match pattern, and a term which satisfies more than one predicate
is taken by the first predicate which it satisfies.  Each predicate is tested
against all operands of the sum or product before the next predicate is
evaluated.  In addition, if 0 or 1 (respectively) satisfies a match predicate,
and there are no other terms which satisfy the predicate, 0 or 1 is assigned to
the match variable associated with the predicate.
</p>
<p>The algorithm for processing addition and multiplication patterns makes some
match results (for example, a pattern in which a &quot;match anything&quot; variable
appears) dependent on the ordering of terms in the match pattern and in the
expression to be matched.  However, if all match predicates are mutually
exclusive, the match result is insensitive to ordering, as one match predicate
cannot accept terms matched by another.
</p>
<p>Calling <code>matchdeclare</code> with a variable <var>a</var> as an argument changes the
<code>matchdeclare</code> property for <var>a</var>, if one was already declared; only the
most recent <code>matchdeclare</code> is in effect when a rule is defined.  Later
changes to the <code>matchdeclare</code> property (via <code>matchdeclare</code> or
<code>remove</code>) do not affect existing rules.
</p>
<p><code>propvars (matchdeclare)</code> returns the list of all variables for which there
is a <code>matchdeclare</code> property.  <code>printprops (<var>a</var>, matchdeclare)</code>
returns the predicate for variable <code>a</code>.
<code>printprops (all, matchdeclare)</code> returns the list of predicates for all
<code>matchdeclare</code> variables.  <code>remove (<var>a</var>, matchdeclare)</code> removes
the <code>matchdeclare</code> property from <var>a</var>.
</p>
<p>The functions <code>defmatch</code>, <code>defrule</code>, <code>tellsimp</code>,
<code>tellsimpafter</code>, and <code>let</code> construct rules which test expressions
against patterns.
</p>
<p><code>matchdeclare</code> quotes its arguments.
<code>matchdeclare</code> always returns <code>done</code>.
</p>
<p>Examples:
</p>
<p>A predicate is the name of a function,
or a lambda expression,
or a function call or lambda call missing the last argument,
or <code>true</code> or <code>all</code>.
</p>
<pre class="example">(%i1) matchdeclare (aa, integerp);
(%o1)                         done
(%i2) matchdeclare (bb, lambda ([x], x &gt; 0));
(%o2)                         done
(%i3) matchdeclare (cc, freeof (%e, %pi, %i));
(%o3)                         done
(%i4) matchdeclare (dd, lambda ([x, y], gcd (x, y) = 1) (1728));
(%o4)                         done
(%i5) matchdeclare (ee, true);
(%o5)                         done
(%i6) matchdeclare (ff, all);
(%o6)                         done
</pre>
<p>If an expression satisfies a match predicate,
the match variable is assigned the expression.
</p>
<pre class="example">(%i1) matchdeclare (aa, integerp, bb, atom);
(%o1)                         done
(%i2) defrule (r1, bb^aa, [&quot;integer&quot; = aa, &quot;atom&quot; = bb]);
                    aa
(%o2)        r1 : bb   -&gt; [integer = aa, atom = bb]
(%i3) r1 (%pi^8);
(%o3)               [integer = 8, atom = %pi]
</pre>
<p>In the case of addition and multiplication, the match variable may be assigned
a single expression which satisfies the match predicate, or a sum or product
(respectively) of such expressions.
</p>
<pre class="example">(%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
(%o1)                         done
(%i2) defrule (r1, aa + bb, [&quot;all atoms&quot; = aa, &quot;all nonatoms&quot; =
               bb]);
bb + aa partitions `sum'
(%o2)  r1 : bb + aa -&gt; [all atoms = aa, all nonatoms = bb]
(%i3) r1 (8 + a*b + sin(x));
(%o3)     [all atoms = 8, all nonatoms = sin(x) + a b]
(%i4) defrule (r2, aa * bb, [&quot;all atoms&quot; = aa, &quot;all nonatoms&quot; =
               bb]);
bb aa partitions `product'
(%o4)   r2 : aa bb -&gt; [all atoms = aa, all nonatoms = bb]
(%i5) r2 (8 * (a + b) * sin(x));
(%o5)    [all atoms = 8, all nonatoms = (b + a) sin(x)]
</pre>
<p>When matching arguments of <code>+</code> and <code>*</code>,
if all match predicates are mutually exclusive,
the match result is insensitive to ordering,
as one match predicate cannot accept terms matched by another.
</p>
<pre class="example">(%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
(%o1)                         done
(%i2) defrule (r1, aa + bb, [&quot;all atoms&quot; = aa, &quot;all nonatoms&quot; =
               bb]);
bb + aa partitions `sum'
(%o2)  r1 : bb + aa -&gt; [all atoms = aa, all nonatoms = bb]
(%i3) r1 (8 + a*b + %pi + sin(x) - c + 2^n);
                                                     n
(%o3) [all atoms = %pi + 8, all nonatoms = sin(x) + 2  - c + a b]
(%i4) defrule (r2, aa * bb, [&quot;all atoms&quot; = aa, &quot;all nonatoms&quot; =
               bb]);
bb aa partitions `product'
(%o4)   r2 : aa bb -&gt; [all atoms = aa, all nonatoms = bb]
(%i5) r2 (8 * (a + b) * %pi * sin(x) / c * 2^n);
                                                  n
                                         (b + a) 2  sin(x)
(%o5) [all atoms = 8 %pi, all nonatoms = -----------------]
                                                 c
</pre>
<p>The functions <code>propvars</code> and <code>printprops</code> return information about
match variables.
</p>
<pre class="example">(%i1) matchdeclare ([aa, bb, cc], atom, [dd, ee], integerp);
(%o1)                         done
(%i2) matchdeclare (ff, floatnump, gg, lambda ([x], x &gt; 100));
(%o2)                         done
(%i3) propvars (matchdeclare);
(%o3)             [aa, bb, cc, dd, ee, ff, gg]
(%i4) printprops (ee, matchdeclare);
(%o4)                    [integerp(ee)]
(%i5) printprops (gg, matchdeclare);
(%o5)              [lambda([x], x &gt; 100, gg)]
(%i6) printprops (all, matchdeclare);
(%o6) [lambda([x], x &gt; 100, gg), floatnump(ff), integerp(ee), 
                      integerp(dd), atom(cc), atom(bb), atom(aa)]
</pre>
<div class=categorybox>


<p>Categories:&nbsp;&nbsp;<a href="maxima_99.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
 &middot;
<a href="maxima_99.html#Category_003a-Declarations-and-inferences">Declarations and inferences</a>
</p>
</div>

</dd></dl>


<p><a name="maxapplydepth"></a>
<a name="Item_003a-maxapplydepth"></a>
</p><dl>
<dt><u>Option variable:</u> <b>maxapplydepth</b>
<a name="IDX1400"></a>
</dt>
<dd><p>Default value: 10000
</p>
<p><code>maxapplydepth</code> is the maximum depth to which <code>apply1</code>
and <code>apply2</code> will delve.
</p>
<div class=categorybox>


<p>Categories:&nbsp;&nbsp;<a href="maxima_99.html#Category_003a-Function-application">Function application</a>
</p>
</div>

</dd></dl>


<p><a name="maxapplyheight"></a>
<a name="Item_003a-maxapplyheight"></a>
</p><dl>
<dt><u>Option variable:</u> <b>maxapplyheight</b>
<a name="IDX1401"></a>
</dt>
<dd><p>Default value: 10000
</p>
<p><code>maxapplyheight</code> is the maximum height to which <code>applyb1</code>
will reach before giving up.
</p>
<div class=categorybox>


<p>Categories:&nbsp;&nbsp;<a href="maxima_99.html#Category_003a-Function-application">Function application</a>
</p>
</div>

</dd></dl>


<p><a name="remlet"></a>
<a name="Item_003a-remlet"></a>
</p><dl>
<dt><u>Function:</u> <b>remlet</b><i> (<var>prod</var>, <var>name</var>)</i>
<a name="IDX1402"></a>
</dt>
<dt><u>Function:</u> <b>remlet</b><i> ()</i>
<a name="IDX1403"></a>
</dt>
<dt><u>Function:</u> <b>remlet</b><i> (all)</i>
<a name="IDX1404"></a>
</dt>
<dt><u>Function:</u> <b>remlet</b><i> (all, <var>name</var>)</i>
<a name="IDX1405"></a>
</dt>
<dd><p>Deletes the substitution rule, <var>prod</var> -&gt; repl, most
recently defined by the <code>let</code> function.  If name is supplied the rule is
deleted from the rule package name.
</p>
<p><code>remlet()</code> and <code>remlet(all)</code> delete all substitution rules from the
current rule package.  If the name of a rule package is supplied, e.g.
<code>remlet (all, <var>name</var>)</code>, the rule package <var>name</var> is also deleted.
</p>
<p>If a substitution is to be changed using the same
product, <code>remlet</code> need not be called, just redefine the substitution
using the same product (literally) with the <code>let</code> function and the new
replacement and/or predicate name.  Should <code>remlet (<var>prod</var>)</code> now be
called the original substitution rule is revived.
</p>
<p>See also <code>remrule</code>, which removes a rule defined by <code>tellsimp</code> or
<code>tellsimpafter</code>.
</p>
<div class=categorybox>


<p>Categories:&nbsp;&nbsp;<a href="maxima_99.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
</p>
</div>

</dd></dl>

<p><a name="remrule"></a>
<a name="Item_003a-remrule"></a>
</p><dl>
<dt><u>Function:</u> <b>remrule</b><i> (<var>op</var>, <var>rulename</var>)</i>
<a name="IDX1406"></a>
</dt>
<dt><u>Function:</u> <b>remrule</b><i> (<var>op</var>, all)</i>
<a name="IDX1407"></a>
</dt>
<dd><p>Removes rules defined by <code>tellsimp</code> or <code>tellsimpafter</code>.
</p>
<p><code>remrule (<var>op</var>, <var>rulename</var>)</code>
removes the rule with the name <var>rulename</var> from the operator <var>op</var>.
When <var>op</var> is a built-in or user-defined operator
(as defined by <code>infix</code>, <code>prefix</code>, etc.),
<var>op</var> and <var>rulename</var> must be enclosed in double quote marks.
</p>
<p><code>remrule (<var>op</var>, all)</code> removes all rules for the operator <var>op</var>.
</p>
<p>See also <code>remlet</code>, which removes a rule defined by <code>let</code>.
</p>
<p>Examples:
</p>
<pre class="example">(%i1) tellsimp (foo (aa, bb), bb - aa);
(%o1)                   [foorule1, false]
(%i2) tellsimpafter (aa + bb, special_add (aa, bb));
(%o2)                   [+rule1, simplus]
(%i3) infix (&quot;@@&quot;);
(%o3)                          @@
(%i4) tellsimp (aa @@ bb, bb/aa);
(%o4)                   [@@rule1, false]
(%i5) tellsimpafter (quux (%pi, %e), %pi - %e);
(%o5)                  [quuxrule1, false]
(%i6) tellsimpafter (quux (%e, %pi), %pi + %e);
(%o6)             [quuxrule2, quuxrule1, false]
(%i7) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
       quux (%e, %pi)];
                                     bb
(%o7) [bb - aa, special_add(aa, bb), --, %pi - %e, %pi + %e]
                                     aa
(%i8) remrule (foo, foorule1);
(%o8)                          foo
(%i9) remrule (&quot;+&quot;, ?\+rule1);
(%o9)                           +
(%i10) remrule (&quot;@@&quot;, ?\@\@rule1);
(%o10)                         @@
(%i11) remrule (quux, all);
(%o11)                        quux
(%i12) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
        quux (%e, %pi)];
(%o12) [foo(aa, bb), bb + aa, aa @@ bb, quux(%pi, %e), 
                                         quux(%e, %pi)]
</pre>
<div class=categorybox>


<p>Categories:&nbsp;&nbsp;<a href="maxima_99.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
</p>
</div>

</dd></dl>


<p><a name="tellsimp"></a>
<a name="Item_003a-tellsimp"></a>
</p><dl>
<dt><u>Function:</u> <b>tellsimp</b><i> (<var>pattern</var>, <var>replacement</var>)</i>
<a name="IDX1408"></a>
</dt>
<dd><p>is similar to <code>tellsimpafter</code> but places
new information before old so that it is applied before the built-in
simplification rules.
</p>
<p><code>tellsimp</code> is used when it is important to modify
the expression before the simplifier works on it, for instance if the
simplifier &quot;knows&quot; something about the expression, but what it returns
is not to your liking.
If the simplifier &quot;knows&quot; something about the
main operator of the expression, but is simply not doing enough for
you, you probably want to use <code>tellsimpafter</code>.
</p>
<p>The pattern may not be a
sum, product, single variable, or number.
</p>
<p>The system variable <code>rules</code> is the list of rules defined by
<code>defrule</code>, <code>defmatch</code>, <code>tellsimp</code>, and <code>tellsimpafter</code>.
</p>
<p>Examples:
</p>
<pre class="example">(%i1) matchdeclare (x, freeof (%i));
(%o1)                         done
(%i2) %iargs: false$
(%i3) tellsimp (sin(%i*x), %i*sinh(x));
(%o3)                 [sinrule1, simp-%sin]
(%i4) trigexpand (sin (%i*y + x));
(%o4)         sin(x) cos(%i y) + %i cos(x) sinh(y)
(%i5) %iargs:true$
(%i6) errcatch(0^0);
 0
0  has been generated
(%o6)                          []
(%i7) ev (tellsimp (0^0, 1), simp: false);
(%o7)                  [^rule1, simpexpt]
(%i8) 0^0;
(%o8)                           1
(%i9) remrule (&quot;^&quot;, %th(2)[1]);
(%o9)                           ^
(%i10) tellsimp (sin(x)^2, 1 - cos(x)^2);
(%o10)                 [^rule2, simpexpt]
(%i11) (1 + sin(x))^2;
                                      2
(%o11)                    (sin(x) + 1)
(%i12) expand (%);
                                   2
(%o12)               2 sin(x) - cos (x) + 2
(%i13) sin(x)^2;
                                  2
(%o13)                     1 - cos (x)
(%i14) kill (rules);
(%o14)                        done
(%i15) matchdeclare (a, true);
(%o15)                        done
(%i16) tellsimp (sin(a)^2, 1 - cos(a)^2);
(%o16)                 [^rule3, simpexpt]
(%i17) sin(y)^2;
                                  2
(%o17)                     1 - cos (y)
</pre>
<div class=categorybox>


<p>Categories:&nbsp;&nbsp;<a href="maxima_99.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
</p>
</div>

</dd></dl>

<p><a name="tellsimpafter"></a>
<a name="Item_003a-tellsimpafter"></a>
</p><dl>
<dt><u>Function:</u> <b>tellsimpafter</b><i> (<var>pattern</var>, <var>replacement</var>)</i>
<a name="IDX1409"></a>
</dt>
<dd><p>Defines a simplification rule which the Maxima simplifier applies after built-in
simplification rules.  <var>pattern</var> is an expression, comprising pattern
variables (declared by <code>matchdeclare</code>) and other atoms and operators,
considered literals for the purpose of pattern matching.  <var>replacement</var> is
substituted for an actual expression which matches <var>pattern</var>; pattern
variables in <var>replacement</var> are assigned the values matched in the actual
expression.
</p>
<p><var>pattern</var> may be any nonatomic expression in which the main operator is not
a pattern variable; the simplification rule is associated with the main
operator.  The names of functions (with one exception, described below), lists,
and arrays may appear in <var>pattern</var> as the main operator only as literals
(not pattern variables); this rules out expressions such as <code>aa(x)</code> and
<code>bb[y]</code> as patterns, if <code>aa</code> and <code>bb</code> are pattern variables.
Names of functions, lists, and arrays which are pattern variables may appear as
operators other than the main operator in <var>pattern</var>.
</p>
<p>There is one exception to the above rule concerning names of functions.
The name of a subscripted function in an expression such as <code>aa[x](y)</code>
may be a pattern variable, because the main operator is not <code>aa</code> but rather
the Lisp atom <code>mqapply</code>.  This is a consequence of the representation of
expressions involving subscripted functions.
</p>

<p>Simplification rules are applied after evaluation 
(if not suppressed through quotation or the flag <code>noeval</code>).
Rules established by <code>tellsimpafter</code> are applied in the order they were
defined, and after any built-in rules.
Rules are applied bottom-up, that is,
applied first to subexpressions before application to the whole expression.
It may be necessary to repeatedly simplify a result (for example, via the
quote-quote operator <code>''</code> or the flag <code>infeval</code>)
to ensure that all rules are applied.
</p>
<p>Pattern variables are treated as local variables in simplification rules.
Once a rule is defined, the value of a pattern variable
does not affect the rule, and is not affected by the rule.
An assignment to a pattern variable which results from a successful rule match
does not affect the current assignment (or lack of it) of the pattern variable.
However, as with all atoms in Maxima, the properties of pattern variables (as
declared by <code>put</code> and related functions) are global.
</p>
<p>The rule constructed by <code>tellsimpafter</code> is named after the main operator of
<var>pattern</var>.  Rules for built-in operators, and user-defined operators defined
by <code>infix</code>, <code>prefix</code>, <code>postfix</code>, <code>matchfix</code>, and
<code>nofix</code>, have names which are Lisp identifiers.
Rules for other functions have names which are Maxima identifiers.
</p>
<p>The treatment of noun and verb forms is slightly confused.  If a rule is defined for a noun (or verb) form
and a rule for the corresponding verb (or noun) form already exists, 
the newly-defined rule applies to both forms (noun and verb).
If a rule for the corresponding verb (or noun) form does not exist,
the newly-defined rule applies only to the noun (or verb) form.
</p>
<p>The rule constructed by <code>tellsimpafter</code> is an ordinary Lisp function.
If the name of the rule is <code>$foorule1</code>,
the construct <code>:lisp (trace $foorule1)</code> traces the function,
and <code>:lisp (symbol-function '$foorule1)</code> displays its definition.
</p>
<p><code>tellsimpafter</code> quotes its arguments.
<code>tellsimpafter</code> returns the list of rules for the main operator of
<var>pattern</var>, including the newly established rule.
</p>
<p>See also <code>matchdeclare</code>, <code>defmatch</code>, <code>defrule</code>, <code>tellsimp</code>,
<code>let</code>, <code>kill</code>, <code>remrule</code>, and <code>clear_rules</code>.
</p>
<p>Examples:
</p>
<p><var>pattern</var> may be any nonatomic expression in which the 
main operator is not a pattern variable.
</p>
<pre class="example">(%i1) matchdeclare (aa, atom, [ll, mm], listp, xx, true)$
(%i2) tellsimpafter (sin (ll), map (sin, ll));
(%o2)                 [sinrule1, simp-%sin]
(%i3) sin ([1/6, 1/4, 1/3, 1/2, 1]*%pi);
                    1  sqrt(2)  sqrt(3)
(%o3)              [-, -------, -------, 1, 0]
                    2     2        2
(%i4) tellsimpafter (ll^mm, map (&quot;^&quot;, ll, mm));
(%o4)                  [^rule1, simpexpt]
(%i5) [a, b, c]^[1, 2, 3];
                                2   3
(%o5)                      [a, b , c ]
(%i6) tellsimpafter (foo (aa (xx)), aa (foo (xx)));
(%o6)                   [foorule1, false]
(%i7) foo (bar (u - v));
(%o7)                    bar(foo(u - v))
</pre>
<p>Rules are applied in the order they were defined.
If two rules can match an expression,
the rule which was defined first is applied.
</p>
<pre class="example">(%i1) matchdeclare (aa, integerp);
(%o1)                         done
(%i2) tellsimpafter (foo (aa), bar_1 (aa));
(%o2)                   [foorule1, false]
(%i3) tellsimpafter (foo (aa), bar_2 (aa));
(%o3)              [foorule2, foorule1, false]
(%i4) foo (42);
(%o4)                       bar_1(42)
</pre>
<p>Pattern variables are treated as local variables in simplification rules.
(Compare to <code>defmatch</code>, which treats pattern variables as global
variables.)
</p>
<pre class="example">(%i1) matchdeclare (aa, integerp, bb, atom);
(%o1)                         done
(%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
(%o2)                   [foorule1, false]
(%i3) bb: 12345;
(%o3)                         12345
(%i4) foo (42, %e);
(%o4)                 bar(aa = 42, bb = %e)
(%i5) bb;
(%o5)                         12345
</pre>
<p>As with all atoms, properties of pattern variables are global even though values
are local.  In this example, an assignment property is declared via
<code>define_variable</code>.  This is a property of the atom <code>bb</code> throughout
Maxima.
</p>
<pre class="example">(%i1) matchdeclare (aa, integerp, bb, atom);
(%o1)                         done
(%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
(%o2)                   [foorule1, false]
(%i3) foo (42, %e);
(%o3)                 bar(aa = 42, bb = %e)
(%i4) define_variable (bb, true, boolean);
(%o4)                         true
(%i5) foo (42, %e);
Error: bb was declared mode boolean, has value: %e
 -- an error.  Quitting.  To debug this try debugmode(true);
</pre>
<p>Rules are named after main operators.
Names of rules for built-in and user-defined operators are Lisp identifiers,
while names for other functions are Maxima identifiers.
</p>
<pre class="example">(%i1) tellsimpafter (foo (%pi + %e), 3*%pi);
(%o1)                   [foorule1, false]
(%i2) tellsimpafter (foo (%pi * %e), 17*%e);
(%o2)              [foorule2, foorule1, false]
(%i3) tellsimpafter (foo (%i ^ %e), -42*%i);
(%o3)         [foorule3, foorule2, foorule1, false]
(%i4) tellsimpafter (foo (9) + foo (13), quux (22));
(%o4)                   [+rule1, simplus]
(%i5) tellsimpafter (foo (9) * foo (13), blurf (22));
(%o5)                  [*rule1, simptimes]
(%i6) tellsimpafter (foo (9) ^ foo (13), mumble (22));
(%o6)                  [^rule1, simpexpt]
(%i7) rules;
(%o7) [foorule1, foorule2, foorule3, +rule1, *rule1, ^rule1]
(%i8) foorule_name: first (%o1);
(%o8)                       foorule1
(%i9) plusrule_name: first (%o4);
(%o9)                        +rule1
(%i10) remrule (foo, foorule1);
(%o10)                         foo
(%i11) remrule (&quot;^&quot;, ?\^rule1);
(%o11)                          ^
(%i12) rules;
(%o12)        [foorule2, foorule3, +rule1, *rule1]
</pre>
<p>A worked example: anticommutative multiplication.
</p>
<pre class="example">(%i1) gt (i, j) := integerp(j) and i &lt; j;
(%o1)           gt(i, j) := integerp(j) and i &lt; j
(%i2) matchdeclare (i, integerp, j, gt(i));
(%o2)                         done
(%i3) tellsimpafter (s[i]^^2, 1);
(%o3)                 [^^rule1, simpncexpt]
(%i4) tellsimpafter (s[i] . s[j], -s[j] . s[i]);
(%o4)                   [.rule1, simpnct]
(%i5) s[1] . (s[1] + s[2]);
(%o5)                    s  . (s  + s )
                          1     2    1
(%i6) expand (%);
(%o6)                      1 - s  . s
                                2    1
(%i7) factor (expand (sum (s[i], i, 0, 9)^^5));
(%o7) 100 (s  + s  + s  + s  + s  + s  + s  + s  + s  + s )
            9    8    7    6    5    4    3    2    1    0
</pre>
<div class=categorybox>


<p>Categories:&nbsp;&nbsp;<a href="maxima_99.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
</p>
</div>

</dd></dl>

<p><a name="clear_005frules"></a>
<a name="Item_003a-clear_005frules"></a>
</p><dl>
<dt><u>Function:</u> <b>clear_rules</b><i> ()</i>
<a name="IDX1410"></a>
</dt>
<dd><p>Executes <code>kill (rules)</code> and then resets the next rule number to 1
for addition <code>+</code>, multiplication <code>*</code>, and exponentiation <code>^</code>.
</p>
<div class=categorybox>


<p>Categories:&nbsp;&nbsp;<a href="maxima_99.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
</p>
</div>

</dd></dl>


<p><a name="Item_003a-Sets"></a>
</p><hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC180" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_35.html#SEC183" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_83.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Chris User</em> on <em>June, 20 2016</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
