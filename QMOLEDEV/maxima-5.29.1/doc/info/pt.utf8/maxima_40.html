<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on Dezembro, 3 2012 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual do Maxima: 40. Fluxo de Programa</title>

<meta name="description" content="Manual do Maxima: 40. Fluxo de Programa">
<meta name="keywords" content="Manual do Maxima: 40. Fluxo de Programa">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body
{
    color: black;
    background: white; 
    margin-left: 8%;
    margin-right: 13%;
}

h1
{
    margin-left: +8%;
    font-size: 150%;
    font-family: sans-serif
}

h2
{
    font-size: 125%;
    font-family: sans-serif
}

h3
{
    font-size: 100%;
    font-family: sans-serif
}

h2,h3,h4,h5,h6 { margin-left: +4%; }

div.textbox
{
    border: solid;
    border-width: thin;
    /* width: 100%; */
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em
}

div.titlebox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
    background: rgb(200,255,255);
    font-family: sans-serif
}

div.synopsisbox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
     background: rgb(255,220,255);
    /*background: rgb(200,255,255); */
    /* font-family: fixed */
}

pre.example
{
    border: 1px solid gray;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 1em;
    padding-right: 1em;
    /* background: rgb(247,242,180); */ /* kind of sandy */
    /* background: rgb(200,255,255); */ /* sky blue */
    background-color: #F1F5F9; /* light blue-gray */
    /* font-family: "Lucida Console", monospace */
}

div.spacerbox
{
    border: none;
    padding-top: 2em;
    padding-bottom: 2em
}

div.image
{
    margin: 0;
    padding: 1em;
    text-align: center;
}

div.categorybox
{
    border: 1px solid gray;
    padding-top: 0px;
    padding-bottom: 0px;
    padding-left: 1em;
    padding-right: 1em;
    background: rgb(247,242,220);
}


-->
</style>

<link rel="icon" href="http://maxima.sourceforge.net/favicon.ico"/>
</head>

<body lang="pt" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Fluxo-de-Programa"></a>
<a name="SEC162"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_39.html#SEC161" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC163" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_39.html#SEC155" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_41.html#SEC165" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_74.html#SEC274" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 40. Fluxo de Programa </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC163">40.1 Introdu&ccedil;&atilde;o a Fluxo de Programa</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC164">40.2 Defini&ccedil;&otilde;es para Fluxo de Programa</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
</table>

<hr size="6">
<a name="Introdu_00e7_00e3o-a-Fluxo-de-Programa"></a>
<a name="SEC163"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC162" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC164" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC162" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC162" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_41.html#SEC165" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_74.html#SEC274" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 40.1 Introdu&ccedil;&atilde;o a Fluxo de Programa </h2>

<p>Maxima fornece um <code>do</code> para ciclos iterativos, tamb&eacute;m contru&ccedil;&otilde;es mais
primitivas tais como <code>go</code>.
</p>
<hr size="6">
<a name="Defini_00e7_00f5es-para-Fluxo-de-Programa"></a>
<a name="SEC164"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC163" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_41.html#SEC165" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC162" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC162" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_41.html#SEC165" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_74.html#SEC274" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 40.2 Defini&ccedil;&otilde;es para Fluxo de Programa </h2>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>backtrace</b><i> ()</i>
<a name="IDX1354"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>backtrace</b><i> (<var>n</var>)</i>
<a name="IDX1355"></a>
</dt>
<dd><p>Imprime a pilha de chamadas, que &eacute;, a lista de fun&ccedil;&otilde;es que
foram chamadas pela fun&ccedil;&atilde;o correntemente activa.
</p>
<p><code>backtrace()</code> imprime toda a pilha de chamadas.
</p>
<p><code>backtrace (<var>n</var>)</code> imprime as <var>n</var> mais recentes chamadas a
fun&ccedil;&otilde;es, incluindo a fun&ccedil;&atilde;o correntemente activa.
</p>
<p><code>backtrace</code> pode ser chamada por um script, uma fun&ccedil;&atilde;o, ou a partir da linha de comando interativa
(n&atilde;o somente em um contexto de depura&ccedil;&atilde;o).
</p>
<p>Exemplos:
</p>
<ul>
<li>
<code>backtrace()</code> imprime toda a pilha de chamadas.

<pre class="example">(%i1) h(x) := g(x/7)$
(%i2) g(x) := f(x-11)$
(%i3) f(x) := e(x^2)$
(%i4) e(x) := (backtrace(), 2*x + 13)$
(%i5) h(10);
#0: e(x=4489/49)
#1: f(x=-67/7)
#2: g(x=10/7)
#3: h(x=10)
                              9615
(%o5)                         ----
                               49
</pre></li></ul>

<ul>
<li>
<code>backtrace (<var>n</var>)</code> imprime as <var>n</var> mais recentes chamadas a
fun&ccedil;&otilde;es, incluindo a fun&ccedil;&atilde;o correntemente activa.

<pre class="example">(%i1) h(x) := (backtrace(1), g(x/7))$
(%i2) g(x) := (backtrace(1), f(x-11))$
(%i3) f(x) := (backtrace(1), e(x^2))$
(%i4) e(x) := (backtrace(1), 2*x + 13)$
(%i5) h(10);
#0: h(x=10)
#0: g(x=10/7)
#0: f(x=-67/7)
#0: e(x=4489/49)
                              9615
(%o5)                         ----
                               49
</pre></li></ul>

</dd></dl>

<dl>
<dt><u>Operador especial:</u> <b>do</b>
<a name="IDX1356"></a>
</dt>
<dd><p>A declara&ccedil;&atilde;o <code>do</code> &eacute; usada para executar itera&ccedil;&atilde;o.  Devido &agrave; sua
grande generalidade a declara&ccedil;&atilde;o <code>do</code> ser&aacute;  descrita em duas partes.
Primeiro a forma usual ser&aacute; dada que &eacute; an&aacute;loga &agrave; forma que &eacute; usada em
muitas outras linguagens de programa&ccedil;&atilde;o (Fortran, Algol, PL/I, etc.); em segundo lugar
os outros recursos ser&atilde;o mencionados.
</p>
<p>Existem tr&ecirc;s variantes do operador especial <code>do</code> que diferem somente por suas
condi&ccedil;&otilde;es de encerramento.  S&atilde;o elas:
</p>
<ul>
<li>
<code>for <var>Vari&aacute;vel</var>: <var>valor_inicial</var> step <var>incremento</var>
      thru <var>limite</var> do <var>corpo</var></code>
</li><li>
<code>for <var>Vari&aacute;vel</var>: <var>valor_inicial</var> step <var>incremento</var>
      while <var>condition</var> do <var>corpo</var></code>
</li><li>
<code>for <var>Vari&aacute;vel</var>: <var>valor_inicial</var> step <var>incremento</var>
      unless <var>condition</var> do <var>corpo</var></code>
</li></ul>

<p>(Alternativamente, o <code>step</code> pode ser dado ap&oacute;s a condi&ccedil;&atilde;o de encerramento
ou limite.)
</p>
<p><var>valor_inicial</var>, <var>incremento</var>, <var>limite</var>, e <var>corpo</var> podem ser quaisquer
express&otilde;es.  Se o incremento for 1 ent&atilde;o &quot;<code>step 1</code>&quot; pode ser omitido.
</p>
<p>A execu&ccedil;&atilde;o da declara&ccedil;&atilde;o <code>do</code> processa-se primeiro atribuindo o
valor_inicial para a vari&aacute;vel (daqui em diante chamada a
vari&aacute;vel de controle).  Ent&atilde;o: (1) Se a vari&aacute;vel de controle excede
o limite de uma especifica&ccedil;&atilde;o <code>thru</code>, ou se a condi&ccedil;&atilde;o de <code>unless</code> for
<code>true</code>, ou se a condi&ccedil;&atilde;o de <code>while</code> for <code>false</code> ent&atilde;o o <code>do</code>
ser&aacute; encerrado.  (2) O corpo &eacute; avaliado.  (3) O incremento &eacute; adicionado &agrave;
vari&aacute;vel de controle.  O processo de (1) a (3) &eacute; executado
repetidamente at&eacute; que a condi&ccedil;&atilde;o de encerramento seja satisfeita.  Pode-se tamb&eacute;m
dar muitas condi&ccedil;&otilde;es de encerramento e nesse caso o <code>do</code> termina
quando qualquer delas for satisfeita.
</p>
<p>Em geral o teste <code>thru</code> &eacute; satisfeito quando a vari&aacute;vel de controle for
maior que o limite se o incremento for n&atilde;o negativo, ou quando a
vari&aacute;vel de controle for menor que o limite se o incremento for negativo.
O incremento e o limite podem ser express&otilde;es n&atilde;o num&eacute;ricas enquanto essa
desigualdade puder ser determinada.  Todavia, a menos que o incremento seja
sintaticamente negativo (e.g. for um n&uacute;mero negativo) na hora em que a declara&ccedil;&atilde;o <code>do</code>
for iniciada, Maxima assume que o incremento e o limite ser&atilde;o positivos quando o <code>do</code> for
executado.  Se o limite e o incremento n&atilde;o forem positivos, ent&atilde;o o <code>do</code> pode n&atilde;o terminar
propriamente.
</p>
<p>Note que o limite, incremento, e condi&ccedil;&atilde;o de encerramento s&atilde;o
avaliados cada vez que ocorre um ciclo.  Dessa forma se qualquer desses for respons&aacute;vel por
muitos c&aacute;lculos, e retornar um resultado que n&atilde;o muda durante todas
as execu&ccedil;&otilde;es do corpo, ent&atilde;o &eacute; mais eficiente escolher uma
vari&aacute;vel para seu valor anterior para o <code>do</code> e usar essa vari&aacute;vel na
forma <code>do</code>.
</p>
<p>O valor normalmente retornado por uma declara&ccedil;&atilde;o <code>do</code> &eacute; o &aacute;tomo <code>done</code>.
Todavia, a fun&ccedil;&atilde;o
<code>return</code> pode ser usada dentro do corpo para sair da delcara&ccedil;&atilde;o <code>do</code> prematuramente e dar
a isso qualquer valor desejado.
Note todavia que um <code>return</code> dentro de um <code>do</code> que
ocorre em um <code>block</code> encerrar&aacute; somente o <code>do</code> e n&atilde;o o <code>block</code>.  Note tamb&eacute;m
que a fun&ccedil;&atilde;o <code>go</code> n&atilde;o pode ser usada para sair de dentro de um <code>do</code> dentro de um
<code>block</code> que o envolve.
</p>
<p>A vari&aacute;vel de controle &eacute; sempre local para o <code>do</code> e dessa forma qualquer
vari&aacute;vel pode ser usada sem afectar o valor de uma vari&aacute;vel com
o mesmo nome fora da declara&ccedil;&atilde;o <code>do</code>.  A vari&aacute;vel de controle &eacute; liberada
ap&oacute;s o encerramento da declara&ccedil;&atilde;o <code>do</code>.
</p>
<pre class="example">(%i1) for a:-3 thru 26 step 7 do display(a)$
                             a = - 3

                              a = 4

                             a = 11

                             a = 18

                             a = 25
</pre>
<pre class="example">(%i1) s: 0$
(%i2) for i: 1 while i &lt;= 10 do s: s+i;
(%o2)                         done
(%i3) s;
(%o3)                          55
</pre>
<p>Note que a condi&ccedil;&atilde;o <code>while i &lt;= 10</code>
&eacute; equivalente a <code>unless i &gt; 10</code> e tamb&eacute;m <code>thru 10</code>.
</p>
<pre class="example">(%i1) series: 1$
(%i2) term: exp (sin (x))$
(%i3) for p: 1 unless p &gt; 7 do
          (term: diff (term, x)/p, 
           series: series + subst (x=0, term)*x^p)$
(%i4) series;
                  7    6     5    4    2
                 x    x     x    x    x
(%o4)            -- - --- - -- - -- + -- + x + 1
                 90   240   15   8    2
</pre>
<p>que fornece 8 termos da s&eacute;rie de Taylor para <code>e^sin(x)</code>.
</p>
<pre class="example">(%i1) poly: 0$
(%i2) for i: 1 thru 5 do
          for j: i step -1 thru 1 do
              poly: poly + i*x^j$
(%i3) poly;
                  5      4       3       2
(%o3)          5 x  + 9 x  + 12 x  + 14 x  + 15 x
(%i4) guess: -3.0$
(%i5) for i: 1 thru 10 do
          (guess: subst (guess, x, 0.5*(x + 10/x)),
           if abs (guess^2 - 10) &lt; 0.00005 then return (guess));
(%o5)                  - 3.162280701754386
</pre>
<p>Esse exemplo calcula a ra&iacute;z quadrada negativa de 10 usando a
itera&ccedil;&atilde;o de Newton- Raphson um maximum de 10 vezes.  Caso o crit&eacute;rio de
converg&ecirc;cia n&atilde;o tenha sido encontrado o valor retornado pode ser <code>done</code>.
Em lugar de sempre adicionar uma quantidade &agrave; vari&aacute;vel de controle pode-se
algumas vezes desejar alterar isso de alguma outra forma para cada itera&ccedil;&atilde;o.
Nesse caso pode-se usar <code>next <var>express&atilde;o</var></code> em lugar de <code>step <var>incremento</var></code>.
Isso far&aacute; com que a vari&aacute;vel de controle seja escolhida para o
resultado da express&atilde;o de avalia&ccedil;&atilde;o cada vez que o ciclo de repeti&ccedil;&atilde;o for executado.
</p>
<pre class="example">(%i6) for count: 2 next 3*count thru 20 do display (count)$
                            count = 2

                            count = 6

                           count = 18
</pre>
<p>Como uma alternativa para <code>for <var>Vari&aacute;vel</var>: <var>valor</var> ...do...</code> a sintaxe
<code>for <var>Vari&aacute;vel</var> from <var>valor</var> ...do...</code>  pode ser usada.  Isso permite o
<code>from <var>valor</var></code> ser colocado ap&oacute;s o <code>step</code> ou proximo valor ou ap&oacute;s a
condi&ccedil;&atilde;o de encerramento.  Se <code>from <var>valor</var></code> for omitido ent&atilde;o 1 &eacute; usado como
o valor inicial.
</p>
<p>Algumas vezes se pode estar interessado em executar uma itera&ccedil;&atilde;o onde
a vari&aacute;vel de controle nunca seja usada.  Isso &eacute; permiss&iacute;vel
para dar somente as condi&ccedil;&otilde;es de encerramento omitindo a inicializa&ccedil;&atilde;o
e a informa&ccedil;&atilde;o de actualiza&ccedil;&atilde;o como no exemplo seguinte para para calcular a
ra&iacute;z quadrada de 5 usando uma fraca suposi&ccedil;&atilde;o inicial.
</p>
<pre class="example">(%i1) x: 1000$
(%i2) thru 20 do x: 0.5*(x + 5.0/x)$
(%i3) x;
(%o3)                   2.23606797749979
(%i4) sqrt(5), numer;
(%o4)                   2.23606797749979
</pre>
<p>Se isso for desejado pode-se sempre omitir as condi&ccedil;&otilde;es de encerramento
inteiramente e apenas dar o corpo <code>do <var>corpo</var></code> que continuar&aacute; a ser 
avaliado indefinidamente.  Nesse caso a fun&ccedil;&atilde;o <code>return</code> ser&aacute; usada para
encerrar a execu&ccedil;&atilde;o da declara&ccedil;&atilde;o <code>do</code>.
</p>
<pre class="example">(%i1) newton (f, x):= ([y, df, dfx], df: diff (f ('x), 'x),
          do (y: ev(df), x: x - f(x)/y, 
              if abs (f (x)) &lt; 5e-6 then return (x)))$
(%i2) sqr (x) := x^2 - 5.0$
(%i3) newton (sqr, 1000);
(%o3)                   2.236068027062195
</pre>
<p>(Note que <code>return</code>, quando executado, faz com que o valor corrente de
<code>x</code> seja retornado como o valor da declara&ccedil;&atilde;o <code>do</code>.  O <code>block</code> &eacute; encerrado e
esse valor da declara&ccedil;&atilde;o <code>do</code> &eacute; retornado como o valor do <code>block</code> porque o
<code>do</code> &eacute; a &uacute;ltima declara&ccedil;&atilde;o do <code>block</code>.)
</p>
<p>Uma outra forma de <code>do</code> &eacute; dispon&iacute;vel no Maxima.  A sintaxe &eacute;:
</p>
<pre class="example">for <var>Vari&aacute;vel</var> in <var>list</var> <var>end_tests</var> do <var>corpo</var>
</pre>
<p>Os elementos de <var>list</var> s&atilde;o quaisquer express&otilde;es que ir&atilde;o
sucessivamente ser atribu&iacute;das para a vari&aacute;vel a cada itera&ccedil;&atilde;o do
corpo.  O teste opcional <var>end_tests</var> pode ser usado para encerrar a execu&ccedil;&atilde;o da
declara&ccedil;&atilde;o <code>do</code>; de outra forma o <code>do</code> terminar&aacute; quando a lista for exaurida ou quando
um <code>return</code> for executado no corpo.  (De facto, a lista pode ser qualquer
express&atilde;o n&atilde;o at&ocirc;mica, e partes sucessivas s&atilde;o usadas.)
</p>
<pre class="example">(%i1)  for f in [log, rho, atan] do ldisp(f(1))$
(%t1)                                  0
(%t2)                                rho(1)
                                     %pi
(%t3)                                 ---
                                      4
(%i4) ev(%t3,numer);
(%o4)                             0.78539816
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>errcatch</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1357"></a>
</dt>
<dd><p>Avalia <var>expr_1</var>, ..., <var>expr_n</var> uma por uma e
retorna <code>[<var>expr_n</var>]</code> (uma lista) se nenhum erro ocorrer.  Se um
erro ocorrer na avalia&ccedil;&atilde;o de qualquer argumento, <code>errcatch</code>
evita que o erro se propague e
retorna a lista vazia <code>[]</code> sem avaliar quaisquer mais argumentos.
</p>
<p><code>errcatch</code>
&eacute; &uacute;til em ficheiros <code>batch</code> onde se suspeita que um erro possa estar ocorrendo o <code>errcatch</code>
terminar&aacute; o <code>batch</code> se o erro n&atilde;o for detectado.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>error</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1358"></a>
</dt>
<dt><u>Vari&aacute;vel de sistema:</u> <b>error</b>
<a name="IDX1359"></a>
</dt>
<dd><p>Avalia e imprime <var>expr_1</var>, ..., <var>expr_n</var>,
e ent&atilde;o causa um retorno de erro para o n&iacute;vel mais alto do Maxima
ou para o mais pr&oacute;ximo contendo <code>errcatch</code>.
</p>
<p>A vari&aacute;vel <code>error</code> &eacute; escolhida para uma lista descrevendo o erro.
O primeiro elemento de <code>error</code> &eacute; uma sequ&ecirc;ncia de caracteres de formato,
que junta todas as sequ&ecirc;ncias de caracteres entre os argumentos <var>expr_1</var>, ..., <var>expr_n</var>,
e os elementos restantes s&atilde;o os valores de quaisquer argumentos que n&atilde;o s&atilde;o sequ&ecirc;ncias de caracteres.
</p>
<p><code>errormsg()</code> formata e imprime <code>error</code>.
Isso efectivamente reimprime a mais recente mensagem de erro.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>errormsg</b><i> ()</i>
<a name="IDX1360"></a>
</dt>
<dd><p>Reimprime a mais recente mensagem de erro.
A vari&aacute;vel <code>error</code> recebe a mensagem,
e <code>errormsg</code> formata e imprime essa mensagem.
</p>
</dd></dl>

<dl>
<dt><u>Operador especial:</u> <b>for</b>
<a name="IDX1361"></a>
</dt>
<dd><p>Usado em itera&ccedil;&otilde;es.  Veja <code>do</code> para uma descri&ccedil;&atilde;o das
facilidades de itera&ccedil;&atilde;o do Maxima.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>go</b><i> (<var>tag</var>)</i>
<a name="IDX1362"></a>
</dt>
<dd><p>&eacute; usada dentro de um <code>block</code> para transferir o controle para a declara&ccedil;&atilde;o
do bloco que for identificada com o argumento para <code>go</code>.  Para identificar uma
declara&ccedil;&atilde;o, coloque antes dessa declara&ccedil;&atilde;o um argumento at&ocirc;mico como outra declara&ccedil;&atilde;o no
<code>block</code>.  Por exemplo:
</p>
<pre class="example">block ([x], x:1, loop, x+1, ..., go(loop), ...)
</pre>
<p>O argumento para <code>go</code> deve ser o nome de um identificardor aparecendo no mesmo
<code>block</code>.  N&atilde;o se pode usar <code>go</code> para transferir para um identificador em um outro <code>block</code> que n&atilde;o seja
o pr&oacute;prio contendo o <code>go</code>.
</p>
</dd></dl>

<dl>
<dt><u>Operador especial:</u> <b>if</b>
<a name="IDX1363"></a>
</dt>
<dd><p>Representa avalia&ccedil;&atilde;o condicional. V&aacute;rias formas de express&otilde;es <code>if</code> s&atilde;o reconhecidas.
<code>if <var>cond_1</var> then <var>expr_1</var> else <var>expr_0</var></code>
avalia para <var>expr_1</var> se <var>cond_1</var> avaliar para <code>true</code>,
de outra forma a express&atilde;o avalia para <code>expr_0</code>.
</p>
<p><code>if <var>cond_1</var> then <var>expr_1</var> elseif <var>cond_2</var> then <var>expr_2</var> elseif ... else <var>expr_0</var></code>
avalia para <var>expr_k</var> se <var>cond_k</var> for <code>true</code> e todas as condi&ccedil;&otilde;es precedentes forem <code>false</code>.
Se nenhuma das condi&ccedil;&otilde;es forem <code>true</code>, a express&atilde;o avalia para <code>expr_0</code>.
</p>
<p>O comportamento <code>else false</code> &eacute; assumido se <code>else</code> for omitido.
Isso &eacute;, <code>if <var>cond_1</var> then <var>expr_1</var></code> &eacute; equivalente a
<code>if <var>cond_1</var> then <var>expr_1</var> else false</code>,
e <code>if <var>cond_1</var> then <var>expr_1</var> elseif ... elseif <var>cond_n</var> then <var>expr_n</var></code>
&eacute; equivalente a
<code>if <var>cond_1</var> then <var>expr_1</var> elseif ... elseif <var>cond_n</var> then <var>expr_n</var> else false</code>.
</p>
<p>As alternativas <var>expr_0</var>, ..., <var>expr_n</var> podem ser quaisquer express&otilde;es do Maxima,
inclu&iacute;ndo express&otilde;es <code>if</code> aninhadas ( if dentro de if).
As alternativas n&atilde;o s&atilde;o nem simplificadas nem avaliadas a menos que a correspondente condi&ccedil;&atilde;o seja <code>true</code>.
</p>
<p>As condi&ccedil;&otilde;es <var>cond_1</var>, ..., <var>cond_n</var> s&atilde;o express&otilde;es tais que <code>is(<var>cond_k</var>)</code> avaliem
para <code>true</code> ou para <code>false</code>;
de outra forma &eacute; um erro.
Entre outros elementos, condi&ccedil;&otilde;es podem compreender operadores l&oacute;gicos e relacionais como segue.
</p>
<pre class="example">Opera&ccedil;&atilde;o             S&iacute;mbolo      Tipo
 
menor que            &lt;           infixo relacional
menor que            &lt;=
  ou igual a                     infixo relacional
igualdade            =
  (sint&aacute;tica)                    infixo relacional
nega&ccedil;&atilde;o de =         #           infixo relacional
igualdade (valor)    equal       fun&ccedil;&atilde;o relacional
nega&ccedil;&atilde;o de           notequal
  igualdade                      fun&ccedil;&atilde;o relacional
maior que            &gt;=
  ou igual a                     infixo relacional
maior que            &gt;           infixo relacional
e                    and         infixo l&oacute;gico
ou                   or          infixo l&oacute;gico
n&atilde;o                  not         prefixo l&oacute;gico
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>map</b><i> (<var>f</var>, <var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1364"></a>
</dt>
<dd><p>Retorna uma express&atilde;o cujo operador principal
&eacute; o mesmo que o das express&otilde;es
<var>expr_1</var>, ..., <var>expr_n</var> mas cujas subpartes s&atilde;o os resultados da
aplica&ccedil;&atilde;o de <var>f</var> nas correspondentes subpartes das express&otilde;es.  <var>f</var> &eacute; ainda
o nome de uma fun&ccedil;&atilde;o de <em>n</em> argumentos
ou &eacute; uma forma <code>lambda</code> de <em>n</em> argumentos.
</p>
<p><code>maperror</code> - se <code>false</code> far&aacute; com que todas as fun&ccedil;&otilde;es mapeadas
(1) parem quando elas terminarem retornando a menor expi se n&atilde;o forem todas as
expi do mesmo comprimento e (2) aplique fn a [exp1, exp2,...]
se expi n&atilde;o forem todas do mesmo tipo de objecto.  Se <code>maperror</code> for <code>true</code>
ent&atilde;o uma mensagem de erro ser&aacute; dada nas duas inst&acirc;ncias acima.
</p>
<p>Um dos usos dessa fun&ccedil;&atilde;o &eacute; para mapear (<code>map</code>) uma fun&ccedil;&atilde;o (e.g. <code>partfrac</code>)
sobre cada termo de uma express&atilde;o muito larga onde isso comumente n&atilde;o poderia
ser poss&iacute;vel usar a fun&ccedil;&atilde;o sobre a express&atilde;o inteira devido a uma
exaust&atilde;o de espa&ccedil;o da lista de armazenamento no decorrer da computa&ccedil;&atilde;o.
</p>
<pre class="example">(%i1) map(f,x+a*y+b*z);
(%o1)                        f(b z) + f(a y) + f(x)
(%i2) map(lambda([u],partfrac(u,x)),x+1/(x^3+4*x^2+5*x+2));
                           1       1        1
(%o2)                     ----- - ----- + -------- + x
                         x + 2   x + 1          2
                                         (x + 1)
(%i3) map(ratsimp, x/(x^2+x)+(y^2+y)/y);
                                      1
(%o3)                            y + ----- + 1
                                    x + 1
(%i4) map(&quot;=&quot;,[a,b],[-0.5,3]);
(%o4)                          [a = - 0.5, b = 3]


</pre></dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>mapatom</b><i> (<var>expr</var>)</i>
<a name="IDX1365"></a>
</dt>
<dd><p>Retorna <code>true</code> se e somente se <var>expr</var> for tratada pelas rotinas de
mapeamento como um &aacute;tomo.  &quot;Mapatoms&quot; s&atilde;o &aacute;tomos, n&uacute;meros
(inclu&iacute;ndo n&uacute;meros racioanais), e vari&aacute;veis subscritas.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>maperror</b>
<a name="IDX1366"></a>
</dt>
<dd><p>Valor por omiss&atilde;o: <code>true</code>
</p>
<p>Quando <code>maperror</code> &eacute; <code>false</code>, faz com que todas as fun&ccedil;&otilde;es mapeadas, por exemplo
</p>
<pre class="example">map (f, expr_1, expr_2, ...))
</pre>
<p>(1) parem quando elas terminarem
retornando a menor expi se n&atilde;o forem todas as expi do mesmo
comprimento e (2) aplique <code>f</code> a <code>[expr_1, expr_2, ...]</code> se <code>expr_i</code> n&atilde;o forem todas
do mesmo tipo de objecto.
</p>
<p>Se <code>maperror</code> for <code>true</code> ent&atilde;o uma ,mensagem de erro
&eacute; mostrada nas duas inst&acirc;ncias acima.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>maplist</b><i> (<var>f</var>, <var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1367"></a>
</dt>
<dd><p>Retorna uma lista de aplica&ccedil;&otilde;es de <var>f</var>
em todas as partes das express&otilde;es <var>expr_1</var>, ..., <var>expr_n</var>.
<var>f</var> &eacute; o nome de uma fun&ccedil;&atilde;o, ou uma express&atilde;o lambda.
</p>
<p><code>maplist</code> difere de <code>map (<var>f</var>, <var>expr_1</var>, ..., <var>expr_n</var>)</code>
que retorna uma express&atilde;o com o mesmo operador principal que <var>expr_i</var> tem
(excepto para simplifica&ccedil;&otilde;es  e o caso onde <code>map</code> faz um <code>apply</code>).
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>prederror</b>
<a name="IDX1368"></a>
</dt>
<dd><p>Valor por omiss&atilde;o: <code>true</code>
</p>
<p>Quando <code>prederror</code> for <code>true</code>, uma mensagem de erro &eacute; mostrada
sempre que o predicado de uma declara&ccedil;&atilde;o <code>if</code> ou uma fun&ccedil;&atilde;o <code>is</code> falha em
avaliar ou para <code>true</code> ou para  <code>false</code>.
</p>
<p>Se <code>false</code>, <code>unknown</code> &eacute; retornado
no lugar nesse caso.  O modo <code>prederror: false</code> n&atilde;o &eacute; suportado no
c&oacute;digo traduzido;
todavia, <code>maybe</code> &eacute; suportado no c&oacute;digo traduzido.
</p>
<p>Veja tamb&eacute;m <code>is</code> e <code>maybe</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>return</b><i> (valor)</i>
<a name="IDX1369"></a>
</dt>
<dd><p>Pode ser usada para sair explicitamente de um bloco, levando
seu argumento.  Veja <code>block</code> para mais informa&ccedil;&atilde;o.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>scanmap</b><i> (<var>f</var>, <var>expr</var>)</i>
<a name="IDX1370"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>scanmap</b><i> (<var>f</var>, <var>expr</var>, bottomup)</i>
<a name="IDX1371"></a>
</dt>
<dd><p>Recursivamente aplica <var>f</var> a <var>expr</var>, de cima
para baixo.  Isso &eacute; muito &uacute;til quando uma factora&ccedil;&atilde;o completa &eacute;
desejada, por exemplo:
</p>
<pre class="example">(%i1) exp:(a^2+2*a+1)*y + x^2$
(%i2) scanmap(factor,exp);
                                    2      2
(%o2)                         (a + 1)  y + x
</pre>
<p>Note o caminho atrav&eacute;s do qual <code>scanmap</code> aplica a dada fun&ccedil;&atilde;o <code>factor</code> para as
subexpress&otilde;es constituintes de <var>expr</var>; se outra forma de <var>expr</var> &eacute; apresentada
para <code>scanmap</code> ent&atilde;o o resultado pode ser diferente.  Dessa forma, <code>%o2</code> n&atilde;o &eacute;
recuperada quando <code>scanmap</code> &eacute; aplicada para a forma expandida de exp:
</p>
<pre class="example">(%i3) scanmap(factor,expand(exp));
                           2                  2
(%o3)                      a  y + 2 a y + y + x
</pre>
<p>Aqui est&aacute; um outro exemplo do caminho no qual <code>scanmap</code> aplica
recursivamente uma fun&ccedil;&atilde;o dada para todas as subexpress&otilde;es, incluindo expoentes:
</p>
<pre class="example">(%i4) expr : u*v^(a*x+b) + c$
(%i5) scanmap('f, expr);
                    f(f(f(a) f(x)) + f(b))
(%o5) f(f(f(u) f(f(v)                      )) + f(c))
</pre>
<p><code>scanmap (<var>f</var>, <var>expr</var>, bottomup)</code> aplica <var>f</var> a <var>expr</var> de
baixo para cima.  E.g., para <code>f</code> indefinida,
</p>
<pre class="example">scanmap(f,a*x+b) -&gt;
   f(a*x+b) -&gt; f(f(a*x)+f(b)) -&gt; f(f(f(a)*f(x))+f(b))
scanmap(f,a*x+b,bottomup) -&gt; f(a)*f(x)+f(b)
    -&gt; f(f(a)*f(x))+f(b) -&gt;
     f(f(f(a)*f(x))+f(b))
</pre>
<p>Neste caso, obt&eacute;m-se a mesma resposta pelos dois m&eacute;todos.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>throw</b><i> (<var>expr</var>)</i>
<a name="IDX1372"></a>
</dt>
<dd><p>Avalia <var>expr</var> e descarta o valor retornado para o mais recente
<code>catch</code>.  <code>throw</code> &eacute; usada com <code>catch</code> como um mecanismo
de retorno n&atilde;o local.
</p>
</dd></dl>

<dl>
<dt><u>Operador especial:</u> <b>while</b>
<a name="IDX1373"></a>
</dt>
<dd><p>Veja <code>do</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>outermap</b><i> (<var>f</var>, <var>a_1</var>, ..., <var>a_n</var>)</i>
<a name="IDX1374"></a>
</dt>
<dd><p>Aplica a fun&ccedil;&atilde;o <var>f</var> para cada um dos elementos do produto externo
<var>a_1</var> vezes <var>a_2</var> ... vezes <var>a_n</var>.
</p>
<p><var>f</var> &eacute; o nome de uma fun&ccedil;&atilde;o de <em>n</em> argumentos
ou uma express&atilde;o lambda de <em>n</em> argumentos.
Cada argumento <var>a_k</var> pode ser uma lista simples ou lista aninhada ( lista contendo listas como elementos ), ou uma matrz, ou qualquer outro tip de express&atilde;o.
</p>
<p>O valor de retorno de <code>outermap</code> &eacute; uma estrutura aninhada.
Tomemos <var>x</var> como sendo o valor de retorno.
Ent&atilde;o <var>x</var> tem a mesma estrutura da primeira lista, lista aninhada, ou argumento matriz,
<code><var>x</var>[i_1]...[i_m]</code> tem a mesma estrutura que a segunda lista, lista aninhada, ou argumento matriz,
<code><var>x</var>[i_1]...[i_m][j_1]...[j_n]</code> tem a mesma estrutura que a terceira lista, lista aninhada, ou argumento matriz,
e assim por diante,
onde <var>m</var>, <var>n</var>, ... s&atilde;o os n&uacute;meros dos &iacute;ndices requeridos para acessar os
elementos de cada argumento (um para uma lista, dois para uma matriz, um ou mais para uma lista aninhada).
Argumentos que n&atilde;o forem listas ou matrizes n&atilde;o afectam a estrutura do valor de retorno.
</p>
<p>Note que o efeito de <code>outermap</code> &eacute; diferente daquele de aplicar <var>f</var>
a cada um dos elementos do produto externo retornado por <code>cartesian_product</code>.
<code>outermap</code> preserva a estrutura dos argumentos no valor de retorno,
enquanto <code>cartesian_product</code> n&atilde;o reserva essa mesma estrutura.
</p>
<p><code>outermap</code> avalia seus argumentos.
</p>
<p>Veja tamb&eacute;m <code>map</code>, <code>maplist</code>, e <code>apply</code>.
</p>
<p>Exemplos:
Exemplos elementares de <code>outermap</code>.
Para mostrar a a combina&ccedil;&atilde;o de argumentos mais claramente, <code>F</code> est&aacute; indefinida &agrave; esquerda.
</p>
<pre class="example">(%i1) outermap (F, [a, b, c], [1, 2, 3]);
(%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)], 
                                     [F(c, 1), F(c, 2), F(c, 3)]]
(%i2) outermap (F, matrix ([a, b], [c, d]), matrix ([1, 2], [3, 4]));
         [ [ F(a, 1)  F(a, 2) ]  [ F(b, 1)  F(b, 2) ] ]
         [ [                  ]  [                  ] ]
         [ [ F(a, 3)  F(a, 4) ]  [ F(b, 3)  F(b, 4) ] ]
(%o2)    [                                            ]
         [ [ F(c, 1)  F(c, 2) ]  [ F(d, 1)  F(d, 2) ] ]
         [ [                  ]  [                  ] ]
         [ [ F(c, 3)  F(c, 4) ]  [ F(d, 3)  F(d, 4) ] ]
(%i3) outermap (F, [a, b], x, matrix ([1, 2], [3, 4]));
       [ F(a, x, 1)  F(a, x, 2) ]  [ F(b, x, 1)  F(b, x, 2) ]
(%o3) [[                        ], [                        ]]
       [ F(a, x, 3)  F(a, x, 4) ]  [ F(b, x, 3)  F(b, x, 4) ]
(%i4) outermap (F, [a, b], matrix ([1, 2]), matrix ([x], [y]));
       [ [ F(a, 1, x) ]  [ F(a, 2, x) ] ]
(%o4) [[ [            ]  [            ] ], 
       [ [ F(a, 1, y) ]  [ F(a, 2, y) ] ]
                              [ [ F(b, 1, x) ]  [ F(b, 2, x) ] ]
                              [ [            ]  [            ] ]]
                              [ [ F(b, 1, y) ]  [ F(b, 2, y) ] ]
(%i5) outermap (&quot;+&quot;, [a, b, c], [1, 2, 3]);
(%o5) [[a + 1, a + 2, a + 3], [b + 1, b + 2, b + 3], 
                                           [c + 1, c + 2, c + 3]]
</pre>
<p>Uma explana&ccedil;&atilde;o final do valor de retorno de <code>outermap</code>.
Os argumentos primeiro, segundo, e terceiro s&atilde;o matriz, lista, e matriz, respectivamente.
O valor de retorno &eacute; uma matriz.
Cada elementos daquela matriz &eacute; uma lista,
e cada elemento de cada lista &eacute; uma matriz.
</p>
<pre class="example">(%i1) arg_1 :  matrix ([a, b], [c, d]);
                            [ a  b ]
(%o1)                       [      ]
                            [ c  d ]
(%i2) arg_2 : [11, 22];
(%o2)                       [11, 22]
(%i3) arg_3 : matrix ([xx, yy]);
(%o3)                      [ xx  yy ]
(%i4) xx_0 : outermap (lambda ([x, y, z], x / y + z), arg_1, arg_2, arg_3);
               [  [      a        a  ]  [      a        a  ]  ]
               [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
               [  [      11       11 ]  [      22       22 ]  ]
(%o4)  Col 1 = [                                              ]
               [  [      c        c  ]  [      c        c  ]  ]
               [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
               [  [      11       11 ]  [      22       22 ]  ]
                 [  [      b        b  ]  [      b        b  ]  ]
                 [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                 [  [      11       11 ]  [      22       22 ]  ]
         Col 2 = [                                              ]
                 [  [      d        d  ]  [      d        d  ]  ]
                 [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                 [  [      11       11 ]  [      22       22 ]  ]
(%i5) xx_1 : xx_0 [1][1];
           [      a        a  ]  [      a        a  ]
(%o5)     [[ xx + --  yy + -- ], [ xx + --  yy + -- ]]
           [      11       11 ]  [      22       22 ]
(%i6) xx_2 : xx_0 [1][1] [1];
                      [      a        a  ]
(%o6)                 [ xx + --  yy + -- ]
                      [      11       11 ]
(%i7) xx_3 : xx_0 [1][1] [1] [1][1];
                                  a
(%o7)                        xx + --
                                  11
(%i8) [op (arg_1), op (arg_2), op (arg_3)];
(%o8)                  [matrix, [, matrix]
(%i9) [op (xx_0), op (xx_1), op (xx_2)];
(%o9)                  [matrix, [, matrix]
</pre>
<p><code>outermap</code> preserves the structure of the arguments in the return value,
while <code>cartesian_product</code> does not.
</p>
<pre class="example">(%i1) outermap (F, [a, b, c], [1, 2, 3]);
(%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)], 
                                     [F(c, 1), F(c, 2), F(c, 3)]]
(%i2) setify (flatten (%));
(%o2) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3), 
                                       F(c, 1), F(c, 2), F(c, 3)}
(%i3) map (lambda ([L], apply (F, L)), cartesian_product ({a, b, c}, {1, 2, 3}));
(%o3) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3), 
                                       F(c, 1), F(c, 2), F(c, 3)}
(%i4) is (equal (%, %th (2)));
(%o4)                         true
</pre>
</dd></dl>

<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC162" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_41.html#SEC165" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_74.html#SEC274" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Robert</em> on <em>Dezembro, 3 2012</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
