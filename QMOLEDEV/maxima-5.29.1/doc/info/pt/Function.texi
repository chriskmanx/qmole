@c /Function.texi/1.46/Fri Mar  2 00:44:37 2007/-ko/
@menu
* Introdu@value{cedilha}@~ao a Defini@value{cedilha}@~ao de Fun@value{cedilha}@~ao::  
* Fun@value{cedilha}@~ao::                    
* Macros::                      
* Defini@value{cedilha}@~oes para Defini@value{cedilha}@~ao de Fun@value{cedilha}@~ao::  
@end menu

@node Introdu@value{cedilha}@~ao a Defini@value{cedilha}@~ao de Fun@value{cedilha}@~ao, Fun@value{cedilha}@~ao, Defini@value{cedilha}@~ao de Fun@value{cedilha}@~ao, Defini@value{cedilha}@~ao de Fun@value{cedilha}@~ao
@section Introdu@value{cedilha}@~ao a Defini@value{cedilha}@~ao de Fun@value{cedilha}@~ao

@node Fun@value{cedilha}@~ao, Macros, Introdu@value{cedilha}@~ao a Defini@value{cedilha}@~ao de Fun@value{cedilha}@~ao, Defini@value{cedilha}@~ao de Fun@value{cedilha}@~ao
@c NEEDS WORK, THIS TOPIC IS IMPORTANT
@c MENTION DYNAMIC SCOPE (VS LEXICAL SCOPE)
@section Fun@value{cedilha}@~ao
@subsection Ordinary functions

Para definir uma fun@value{cedilha}@~ao no Maxima usa-se o operador :=.
Por exemplo,

@example
f(x) := sin(x)
@end example

@noindent
define uma fun@value{cedilha}@~ao @code{f}.
Fun@value{cedilha}@~oes an@^onimas podem tamb@'em serem criadas usando @code{lambda}.
Por exemplo

@example
lambda ([i, j], ...)
@end example

@noindent
pode ser usada em lugar de @code{f}
onde

@example
f(i,j) := block ([], ...);
map (lambda ([i], i+1), l)
@end example

@noindent
retornar@'a uma lista com 1 adicionado a cada termo.

Pode tamb@'em definir uma fun@value{cedilha}@~ao com um n@'umero
vari@'avel de argumentos, usando um argumento final que seja uma lista,
na qual ser@~ao inseridos todos os argumentos adicionais:

@example
(%i1) f ([u]) := u;
(%o1)                      f([u]) := u
(%i2) f (1, 2, 3, 4);
(%o2)                     [1, 2, 3, 4]
(%i3) f (a, b, [u]) := [a, b, u];
(%o3)               f(a, b, [u]) := [a, b, u]
(%i4) f (1, 2, 3, 4, 5, 6);
(%o4)                 [1, 2, [3, 4, 5, 6]]
@end example

O lado direito na defini@value{cedilha}@~ao de uma
fun@value{cedilha}@~ao @'e uma express@~ao. Assim, quando quiser que a
defini@value{cedilha}@~ao seja uma sequ@^encia de express@~oes, poder@'a
usar a forma
@example
f(x) := (expr1, expr2, ...., exprn);
@end example

e o valor de @var{exprn} @'e que @'e retornado pela fun@value{cedilha}@~ao.

Se quiser introduzir um ponto de @code{retorno} em alguma express@~ao dentro da
fun@value{cedilha}@~ao, dever@'a usar @code{block} e @code{return}.

@example
block ([], expr1, ..., if (a > 10) then return(a), ..., exprn)
@end example

@'e em si mesma uma express@~ao, e ent@~ao poder@'a ocupar o lugar do
lado direito de uma defini@value{cedilha}@~ao de fun@value{cedilha}@~ao.  Aqui pode acontecer
que o retorno aconte@value{cedilha}a mais facilmente que no exemplo anterior a essa @'ultima express@~ao.

@c COPY THIS STUFF TO @defun block AS NEEDED
@c ESPECIALLY STUFF ABOUT LOCAL VARIABLES
O primeiro @code{[]} no bloco, pode conter uma lista de vari@'aveis e
atribui@value{cedilha}@~oes de vari@'aveis, tais como @code{[a: 3, b, c:
[]]}, que far@~ao com que as tr@^es vari@'aveis @code{a},@code{b},e
@code{c} n@~ao se refiram a seus valores globais, mas ao contr@'ario
tenham esses valores especiais enquanto o c@'odigo estiver executando a
parte dentro do bloco @code{block}, ou dentro da fun@value{cedilha}@~oes
chamadas de dentro do bloco @code{block}.  Isso @'e chamado
associa@value{cedilha}@~ao @i{dynamic}, uma vez que as vari@'aveis
permanecem do in@'{@dotless{i}}cio do bloco pelo tempo que ele
existir. Quando regressar do bloco @code{block}, ou o descartar, os
valores antigos (quaisquer que sejam) das vari@'aveis ser@~ao
restaurados.  @'E certamente uma boa id@'eia para proteger as suas
vari@'aveis nesse caminho.  Note que as atribui@value{cedilha}@~oes em
vari@'aveis do bloco, s@~ao realizadas em paralelo.  Isso
significa, que se tivesse usado @code{c: a} acima, o valor de @code{c}
seria o valor que @code{a} tinha antes do bloco, antes de ter obtido o
seu novo valor atribu@'{@dotless{i}}do no bloco.  Dessa forma fazendo alguma
coisa como

@example
block ([a: a], expr1, ...  a: a+3, ..., exprn)
@end example

proteger@'a o valor externo de @code{a} de ser alterado, mas impedir@'a
aceder ao valor antigo. Assim, o lado direito de
atribui@value{cedilha}@~oes, @'e avaliado no contexto inserido, antes
que qualquer avalia@value{cedilha}@~ao ocorra.  Usando apenas
@code{block ([x], ...} faremos com que o @code{x} tenho como valor a si
pr@'oprio; esse @'e o mesmo valor que teria no in@'{@dotless{i}}cio de
uma sess@~ao do @b{Maxima}.

Os actuais argumentos para uma fun@value{cedilha}@~ao s@~ao tratados exactamente da mesma que
as vari@'aveis em um bloco.  Dessa forma em

@example
f(x) := (expr1, ..., exprn);
@end example

e

@example
f(1);
@end example

teremos um contexto similar para avalia@value{cedilha}@~ao de express@~oes
como se tiv@'essemos conclu@'{@dotless{i}}do

@example
block ([x: 1], expr1, ..., exprn)
@end example

Dentro de fun@value{cedilha}@~oes, quando o lado direito de uma defini@value{cedilha}@~ao,
pode ser calculado em tempo de execu@value{cedilha}@~ao, isso @'e @'uti para usar @code{define} e
possivelmente @code{buildq}.  

@subsection Fun@value{cedilha}@~ao de Array

Uma fun@value{cedilha}@~ao de Array armazena o valor da fun@value{cedilha}@~ao na primeira vez que ela for chamada com um argumento dado,
e retorna o valor armazenado, sem recalcular esse valor, quando o mesmo argumento for fornecido.
De modo que uma fun@value{cedilha}@~ao @'e muitas vezes chamada uma @i{fun@value{cedilha}@~ao de memoriza@value{cedilha}@~ao}.

Nomes de fun@value{cedilha}@~oes de Array s@~ao anexados ao final da lista global @code{arrays}
(n@~ao na lista global @code{functions}).
O comando @code{arrayinfo} retorna a lista de argumentos para os quais exite valores armazenados,
e @code{listarray} retorna os valores armazenados. 
Os comandos @code{dispfun} e @code{fundef} retornam a defini@value{cedilha}@~ao da fun@value{cedilha}@~ao de array.

O comando @code{arraymake} contr@'oi uma chamada de fun@value{cedilha}@~ao de array,
an@'alogamente a @code{funmake} para fun@value{cedilha}@~oes comuns.
O comando @code{arrayapply} aplica uma fun@value{cedilha}@~ao de array a seus argmentos,
an@'alogamente a @code{apply} para fun@value{cedilha}@~oes comuns.
N@~ao existe nada exactamente an@'alogo a @code{map} para fun@value{cedilha}@~oes de array,
embora @code{map(lambda([@var{x}], @var{a}[@var{x}]), @var{L})} ou
@code{makelist(@var{a}[@var{x}], @var{x}, @var{L})}, onde @var{L} @'e uma lista,
n@~ao estejam t@~ao longe disso.

O comando @code{remarray} remove uma defini@value{cedilha}@~ao de fun@value{cedilha}@~ao de array (incluindo qualquer valor armazenado pela fun@value{cedilha}@~ao removida),
an@'alogo a @code{remfunction} para fun@value{cedilha}@~oes comuns.

o comando @code{kill(@var{a}[@var{x}])} remove o valor da fun@value{cedilha}@~ao de array @var{a}
armazenado para o argumento @var{x};
a pr@'oxima vez que @var{a} foor chamada com o argumento @var{x},
o valor da fun@value{cedilha}@~ao @'e recomputado.
Todavia, n@~ao exite caminho para remover todos os valores armazenados de uma vez,
excepto para @code{kill(@var{a})} ou @code{remarray(@var{a})},
o qual remove tamb@'em remove a defini@value{cedilha}@~ao da fun@value{cedilha}@~ao de array.

@node Macros, Defini@value{cedilha}@~oes para Defini@value{cedilha}@~ao de Fun@value{cedilha}@~ao, Fun@value{cedilha}@~ao, Defini@value{cedilha}@~ao de Fun@value{cedilha}@~ao
@section Macros

@deffn {Fun@value{cedilha}@~ao} buildq (@var{L}, @var{expr})
Substitue vari@'aveis nomeadas pela lista @var{L} dentro da express@~ao @var{expr},
paralelamente,
sem avaliar @var{expr}.
A express@~ao resultante @'e simplificada,
mas n@~ao avaliada,
ap@'os @code{buildq} realizar a substitui@value{cedilha}@~ao.

Os elementos de @var{L} s@~ao s@'{@dotless{i}}mbolos ou express@~oes de atribui@value{cedilha}@~ao @code{@var{s@'{@dotless{i}}mbolo}: @var{valor}},
avaliadas paralelamente.
Isto @'e, a associa@value{cedilha}@~ao de uma vari@'avel sobre o lado direito de uma atribui@value{cedilha}@~ao
@'e a associa@value{cedilha}@~ao daquela vari@'avel no contexto do qual @code{buildq} for chamada,
n@~ao a associa@value{cedilha}@~ao daquela vari@'avel na lista @var{L} de vari@'aveis.
Se alguma vari@'avel em @var{L} n@~ao dada como uma atribui@value{cedilha}@~ao expl@'{@dotless{i}}cita,
sua associa@value{cedilha}@~ao em @code{buildq} @'e a mesma que no contexto no qual @code{buildq} for chamada.

Ent@~ao as vari@'aveis nomeadas em @var{L} s@~ao substituidas em @var{expr} paralelamente.
Isto @'e, a substitui@value{cedilha}@~ao para cada vari@'avel @'e determinada antes que qualquer substitui@value{cedilha}@~ao seja feita,
ent@~ao a substitui@value{cedilha}@~ao para uma vari@'avel n@~ao tem efeito sobre qualquer outra.

Se qualquer vari@'avel @var{x} aparecer como @code{splice (@var{x})} em @var{expr},
ent@~ao @var{x} deve estar associada para uma lista,
e a lista recebe uma aplica@value{cedilha}@~ao da fun@value{cedilha}@~ao @code{splice} (@'e interpolada) na @var{expr} em lugar de substitu@'{@dotless{i}}da.

Quaisquer vari@'aveis em @var{expr} n@~ao aparecendo em @var{L} s@~ao levados no resultado tal como foram escritos,
mesmo se elas tiverem associa@value{cedilha}@~oes no contexto do qual @code{buildq} tiver sido chamada.

Exemplos

@code{a} @'e explicitamente associada a @code{x},
enquanto @code{b} tem a mesma associa@value{cedilha}@~ao (nomeadamente 29) como no contexto chamado,
e @code{c} @'e levada do come@value{cedilha}o ao fim da forma como foi escrita.
A express@~ao resultante n@~ao @'e avaliada at@'e a avalia@value{cedilha}@~ao expl@'{@dotless{i}}cita ( com duplo ap@'ostrofo - n@~ao com aspas - @code{''%}.

@c ===beg===
@c (a: 17, b: 29, c: 1729)$
@c buildq ([a: x, b], a + b + c);
@c ''%;
@c ===end===
@example
(%i1) (a: 17, b: 29, c: 1729)$
(%i2) buildq ([a: x, b], a + b + c);
(%o2)                      x + c + 29
(%i3) ''%;
(%o3)                       x + 1758
@end example

@code{e} est@'a associado a uma lista, a qual aparece tamb@'em como tal nos argumentos de @code{foo},
e interpolada nos argumentos de @code{bar}.

@c ===beg===
@c buildq ([e: [a, b, c]], foo (x, e, y));
@c buildq ([e: [a, b, c]], bar (x, splice (e), y));
@c ===end===
@example
(%i1) buildq ([e: [a, b, c]], foo (x, e, y));
(%o1)                 foo(x, [a, b, c], y)
(%i2) buildq ([e: [a, b, c]], bar (x, splice (e), y));
(%o2)                  bar(x, a, b, c, y)
@end example

O resultado @'e simplificado ap@'os substitui@value{cedilha}@~ao.
Se a simplifica@value{cedilha}@~ao for aplicada antes da substitui@value{cedilha}@~ao, esses dois resultados podem ser iguais.
@c ===beg===
@c buildq ([e: [a, b, c]], splice (e) + splice (e));
@c buildq ([e: [a, b, c]], 2 * splice (e));
@c ===end===
@example
(%i1) buildq ([e: [a, b, c]], splice (e) + splice (e));
(%o1)                    2 c + 2 b + 2 a
(%i2) buildq ([e: [a, b, c]], 2 * splice (e));
(%o2)                        2 a b c
@end example

As vari@'aveis em @var{L} s@~ao associadas em paralelo; se associadas sequ@^encialmente,
o primeiro resultado pode ser @code{foo (b, b)}.
Substitui@value{cedilha}@~oes s@~ao realizadas em paralelo;
compare o segundo resultado com o resultado de @code{subst},
que realiza substitui@value{cedilha}@~oes sequ@^encialmente.

@c ===beg===
@c buildq ([a: b, b: a], foo (a, b));
@c buildq ([u: v, v: w, w: x, x: y, y: z, z: u], bar (u, v, w, x, y, z));
@c subst ([u=v, v=w, w=x, x=y, y=z, z=u], bar (u, v, w, x, y, z));
@c ===end===
@example
(%i1) buildq ([a: b, b: a], foo (a, b));
(%o1)                       foo(b, a)
(%i2) buildq ([u: v, v: w, w: x, x: y, y: z, z: u], bar (u, v, w, x, y, z));
(%o2)                 bar(v, w, x, y, z, u)
(%i3) subst ([u=v, v=w, w=x, x=y, y=z, z=u], bar (u, v, w, x, y, z));
(%o3)                 bar(u, u, u, u, u, u)
@end example

Constr@'oi uma lista de euq@value{cedilha}@~oes com algumas vari@'aveis ou express@~oes sobre o lado esquerdo
e seus valores sobre o lado direito.
@code{macroexpand} mostra a express@~ao retornada por @code{show_values}.

@c ===beg===
@c show_values ([L]) ::= buildq ([L], map ("=", 'L, L));
@c (a: 17, b: 29, c: 1729)$
@c macroexpand (show_values (a, b, c - a - b));
@c show_values (a, b, c - a - b);
@c ===end===
@example
(%i1) show_values ([L]) ::= buildq ([L], map ("=", 'L, L));
(%o1)   show_values([L]) ::= buildq([L], map("=", 'L, L))
(%i2) (a: 17, b: 29, c: 1729)$
(%i3) show_values (a, b, c - a - b);
(%o3)              [a = 17, b = 29, c = 1729]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} macroexpand (@var{expr})
Retorna a expans@~ao da macro de @var{expr} sem avaliar a express@~ao,
quando @code{expr} for uma chamada de fun@value{cedilha}@~ao de macro.
De outra forma, @code{macroexpand} retorna @var{expr}.

Se a expans@~ao de @var{expr} retorna outra chamada de fun@value{cedilha}@~ao de macro,
aquela chamada de fun@value{cedilha}@~ao de macro @'e tamb@'em expandida.

@code{macroexpand} coloca ap@'ostrofo em seus argumentos, isto @'e, n@~ao os avalia.
Todavia, se a expans@~ao de uma chamada de fun@value{cedilha}@~ao de macro tiver algum efeito,
esse efeito colateral @'e executado.

Veja tamb@'em @code{::=}, @code{macros}, e @code{macroexpand1}.

Exemplos

@c ===beg===
@c g (x) ::= x / 99;
@c h (x) ::= buildq ([x], g (x - a));
@c a: 1234;
@c macroexpand (h (y));
@c h (y);
@c ===end===
@example
(%i1) g (x) ::= x / 99;
                                    x
(%o1)                      g(x) ::= --
                                    99
(%i2) h (x) ::= buildq ([x], g (x - a));
(%o2)            h(x) ::= buildq([x], g(x - a))
(%i3) a: 1234;
(%o3)                         1234
(%i4) macroexpand (h (y));
                              y - a
(%o4)                         -----
                               99
(%i5) h (y);
                            y - 1234
(%o5)                       --------
                               99
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} macroexpand1 (@var{expr})
Retorna a expans@~ao de macro de @var{expr} sem avaliar a express@~ao,
quando @code{expr} for uma chamada de fun@value{cedilha}@~ao de macro.
De outra forma, @code{macroexpand1} retorna @var{expr}.

@code{macroexpand1} n@~ao avalia seus argumentos.
Todavia, se a expans@~ao de uma chamada de fun@value{cedilha}@~ao de macro tiver algum efeito,
esse efeito colateral @'e executado.

Se a expans@~ao de @var{expr} retornar outra chamada de fun@value{cedilha}@~ao de macro,
aquela chamada de fun@value{cedilha}@~ao de macro n@~ao @'e expandida.

Veja tamb@'em @code{::=}, @code{macros}, e @code{macroexpand}.

Examples

@c ===beg===
@c g (x) ::= x / 99;
@c h (x) ::= buildq ([x], g (x - a));
@c a: 1234;
@c macroexpand1 (h (y));
@c h (y);
@c ===end===
@example
(%i1) g (x) ::= x / 99;
                                    x
(%o1)                      g(x) ::= --
                                    99
(%i2) h (x) ::= buildq ([x], g (x - a));
(%o2)            h(x) ::= buildq([x], g(x - a))
(%i3) a: 1234;
(%o3)                         1234
(%i4) macroexpand1 (h (y));
(%o4)                       g(y - a)
(%i5) h (y);
                            y - 1234
(%o5)                       --------
                               99
@end example

@end deffn

@defvr {Global variable} macros
Default value: @code{[]}

@code{macros} @'e a lista de fun@value{cedilha}@~oes de macro definidas pelo utilizador.
O operador de defini@value{cedilha}@~ao de fun@value{cedilha}@~ao de macro @code{::=} coloca uma nova fun@value{cedilha}@~ao de macro nessa lista,
e @code{kill}, @code{remove}, e @code{remfunction} removem fun@value{cedilha}@~oes de macro da lista.

Veja tamb@'em @code{infolists}.

@end defvr

@deffn {Fun@value{cedilha}@~ao} splice (@var{a})
Une como se fosse um elo de liga@value{cedilha}@~ao (interpola) a lista nomeada atrav@'es do @'atomo @var{a} em uma express@~ao,
mas somente se @code{splice} aparecer dentro de @code{buildq};
de outra forma, @code{splice} @'e tratada como uma fun@value{cedilha}@~ao indefinida.
Se aparecer dentro de @code{buildq} com @var{a} sozinho (sem @code{splice}),
@var{a} @'e substituido (n@~ao interpolado) como uma lista no resultado.
O argumento de @code{splice} pode somente ser um @'atomo;
n@~ao pode ser uma lista lateral ou uma express@~ao que retorna uma lista.

Tipicamente @code{splice} fornece os argumentos para uma fun@value{cedilha}@~ao ou operador.
Para uma fun@value{cedilha}@~ao @code{f}, a express@~ao @code{f (splice (@var{a}))} dentro de @code{buildq}
expande para @code{f (@var{a}[1], @var{a}[2], @var{a}[3], ...)}.
Para um operador @code{o}, a express@~ao @code{"o" (splice (@var{a})} dentro de @code{buildq}
expande para @code{"o" (@var{a}[1], @var{a}[2], @var{a}[3], ...)},
onde @code{o} pode ser qualquer tipo de operador (tipicamente um que toma m@'ultiplos argumentos).
Note que o operador deve ser contido dentro de aspas duplas @code{"}.

Exemplos

@c ===beg===
@c buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
@c buildq ([x: [1, %pi]], "/" (splice (x)));
@c matchfix ("<>", "<>");
@c buildq ([x: [1, %pi, z - y]], "<>" (splice (x)));
@c ===end===
@example
(%i1) buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
                       foo(1, %pi, z - y)
(%o1)                -----------------------
                     length([1, %pi, z - y])
(%i2) buildq ([x: [1, %pi]], "/" (splice (x)));
                                1
(%o2)                          ---
                               %pi
(%i3) matchfix ("<>", "<>");
(%o3)                          <>
(%i4) buildq ([x: [1, %pi, z - y]], "<>" (splice (x)));
(%o4)                   <>1, %pi, z - y<>
@end example

@end deffn

@c end concepts Defini@value{cedilha}@~ao de Fun@value{cedilha}@~ao
@node Defini@value{cedilha}@~oes para Defini@value{cedilha}@~ao de Fun@value{cedilha}@~ao,  , Macros, Defini@value{cedilha}@~ao de Fun@value{cedilha}@~ao
@section Defini@value{cedilha}@~oes para Defini@value{cedilha}@~ao de Fun@value{cedilha}@~ao

@deffn {Fun@value{cedilha}@~ao} apply (@var{F}, [@var{x_1}, ..., @var{x_n}])
Constr@'oi e avalia uma express@~ap @code{@var{F}(@var{arg_1}, ..., @var{arg_n})}.

@code{apply} n@~ao tenta distinguir fun@value{cedilha}@~oes de array de fun@value{cedilha}@~oes comuns;
quando @var{F} for o nome de uma fun@value{cedilha}@~ao de array,
@code{apply} avalia @code{@var{F}(...)}
(isto @'e, uma chamada de fun@value{cedilha}@~ao com par@^entesis em lugar de colch@^etes).
@code{arrayapply} avalia uma chamada de fun@value{cedilha}@~ao com colch@^etes nesse caso.

Exemplos:

@code{apply} avalia seus argumentos.
Nesse exemplo, @code{min} @'e aplicado a @code{L}.

@c ===beg===
@c L : [1, 5, -10.2, 4, 3];
@c apply (min, L);
@c ===end===
@example
(%i1) L : [1, 5, -10.2, 4, 3];
(%o1)                 [1, 5, - 10.2, 4, 3]
(%i2) apply (min, L);
(%o2)                        - 10.2
@end example

@code{apply} avalia argumentos, mesmo se a fun@value{cedilha}@~ao @var{F} disser que os argumentos n@~ao devem ser avaliados.

@c ===beg===
@c F (x) := x / 1729;
@c fname : F;
@c dispfun (F);
@c dispfun (fname);
@c apply (dispfun, [fname]);
@c ===end===
@example
(%i1) F (x) := x / 1729;
                                   x
(%o1)                     F(x) := ----
                                  1729
(%i2) fname : F;
(%o2)                           F
(%i3) dispfun (F);
                                   x
(%t3)                     F(x) := ----
                                  1729

(%o3)                         [%t3]
(%i4) dispfun (fname);
fname is not the name of a user function.
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) apply (dispfun, [fname]);
                                   x
(%t5)                     F(x) := ----
                                  1729

(%o5)                         [%t5]
@end example

@code{apply} avalia o nome de fun@value{cedilha}@~ao @var{F}.
Ap@'ostrofo @code{'} evita avalia@value{cedilha}@~ao.
@code{demoivre} @'e o nome de uma vari@'avel global e tamb@'em de uma fun@value{cedilha}@~ao.

@c ===beg===
@c demoivre;
@c demoivre (exp (%i * x));
@c apply (demoivre, [exp (%i * x)]);
@c apply ('demoivre, [exp (%i * x)]);
@c ===end===
@example
(%i1) demoivre;
(%o1)                         false
(%i2) demoivre (exp (%i * x));
(%o2)                  %i sin(x) + cos(x)
(%i3) apply (demoivre, [exp (%i * x)]);
demoivre evaluates to false
Improper name or value in functional position.
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) apply ('demoivre, [exp (%i * x)]);
(%o4)                  %i sin(x) + cos(x)
@end example

@end deffn


@deffn {Fun@value{cedilha}@~ao} block ([@var{v_1}, ..., @var{v_m}], @var{expr_1}, ..., @var{expr_n})
@deffnx {Fun@value{cedilha}@~ao} block (@var{expr_1}, ..., @var{expr_n})
@code{block} avalia @var{expr_1}, ..., @var{expr_n} em sequ@^encia
e retorna o valor da @'ultima express@~ao avaliada.
A sequ@^encia pode ser modificada pelas fun@value{cedilha}@~oes @code{go}, @code{throw}, e @code{return}.
A @'ultima express@~ao @'e @var{expr_n} a menos que @code{return} ou uma express@~ao contendo @code{throw}
seja avaliada.
Algumas vari@'aveis @var{v_1}, ..., @var{v_m} podem ser declaradas locais para o bloco;
essas s@~ao distinguidas das vari@'aveis globais dos mesmos nomes.
Se vari@'aveis n@~ao forem declaradas locais ent@~ao a lista pode ser omitida.
Dentro do bloco,
qualquer vari@'avel que n@~ao @var{v_1}, ..., @var{v_m} @'e uma vari@'avel global.

@code{block} salva os valores correntes das vari@'aveis @var{v_1}, ..., @var{v_m} (quaisquer valores)
na hora da entrada para o bloco,
ent@~ao libera as vari@'aveis dessa forma eles avaliam para si mesmos.
As vari@'aveis locais podem ser associadas a valores arbitr@'arios dentro do bloco mas quando o
bloco @'e encerrado o valores salvos s@~ao restaurados,
e os valores atribu@'{@dotless{i}}dos dentro do bloco s@~ao perdidos.

@code{block} pode aparecer dentro de outro @code{block}.
Vari@'aveis locais s@~ao estabelecidas cada vez que um novo @code{block} @'e avaliado.
Vari@'aveis locais parecem ser globais para quaisquer blocos fechados.
Se uma vari@'avel @'e n@~ao local em um bloco,
seu valor @'e o valor mais recentemente atribu@'{@dotless{i}}do por um bloco fechado, quaisquer que sejam,
de outra forma, seu valor @'e o valor da vari@'avel no ambiente global.
Essa pol@'{@dotless{i}}tica pode coincidir com o entendimento usual de "escopo din@^amico".

Se isso for desejado para salvar e restaurar outras propriedades locais
ao lado de @code{value}, por exemplo @code{array} (excepto para arrays completos),
@code{function}, @code{dependencies}, @code{atvalue}, @code{matchdeclare}, @code{atomgrad}, @code{constant}, e
@code{nonscalar} ent@~ao a fun@value{cedilha}@~ao @code{local} pode ser usada dentro do bloco
com argumentos sendo o nome das vari@'aveis.

O valor do bloco @'e o valor da @'ultima declara@value{cedilha}@~ao ou o
valor do argumento para a fun@value{cedilha}@~ao @code{return} que pode ser usada para sair
explicitamente do bloco.  A fun@value{cedilha}@~ao @code{go} pode ser usada para transferir o
controle para a declara@value{cedilha}@~ao do bloco que @'e identificada com o argumento
para @code{go}.  Para identificar uma declara@value{cedilha}@~ao, coloca-se antes dela um argumento at@^omico como
outra declara@value{cedilha}@~ao no bloco.  Por exemplo:
@code{block ([x], x:1, loop, x: x+1, ..., go(loop), ...)}.  O argumento para @code{go} deve
ser o nome de um identificador que aparece dentro do bloco.  N@~ao se deve usar @code{go} para
transferir para um identificador em um outro bloco a n@~ao ser esse que cont@'em o @code{go}.

Blocos tipicamente aparecem do lado direito de uma defini@value{cedilha}@~ao de fun@value{cedilha}@~ao
mas podem ser usados em outros lugares tamb@'em.

@end deffn

@c REPHRASE, NEEDS EXAMPLE
@deffn {Fun@value{cedilha}@~ao} break (@var{expr_1}, ..., @var{expr_n})
Avalia e imprime @var{expr_1}, ..., @var{expr_n} e ent@~ao
causa uma parada do Maxima nesse ponto e o utilizador pode examinar e alterar
seu ambiente.  Nessa situa@value{cedilha}@~ao digite @code{exit;} para que o c@'alculo seja retomado.

@end deffn

@c FOR SOME REASON throw IS IN SOME OTHER FILE.  MOVE throw INTO THIS FILE.
@c NEEDS CLARIFICATION
@deffn {Fun@value{cedilha}@~ao} catch (@var{expr_1}, ..., @var{expr_n})
Avalia @var{expr_1}, ..., @var{expr_n} uma por uma; se qualquer avalia@value{cedilha}@~ao
levar a uma avalia@value{cedilha}@~ao de uma express@~ao da
forma @code{throw (arg)}, ent@~ao o valor de @code{catch} @'e o valor de
@code{throw (arg)}, e express@~oes adicionais n@~ao s@~ao avaliadas.
Esse "retorno n@~ao local" atravessa assim qualquer profundidade de
aninhar para o mais pr@'oximo contendo @code{catch}.
Se n@~ao existe nenhum @code{catch} contendo um @code{throw}, uma mensagem de erro @'e impressa.

Se a avalia@value{cedilha}@~ao de argumentos n@~ao leva para a avalia@value{cedilha}@~ao de qualquer @code{throw}
ent@~ao o valor de @code{catch} @'e o valor de @var{expr_n}.

@example
(%i1) lambda ([x], if x < 0 then throw(x) else f(x))$
(%i2) g(l) := catch (map (''%, l))$
(%i3) g ([1, 2, 3, 7]);
(%o3)               [f(1), f(2), f(3), f(7)]
(%i4) g ([1, 2, -3, 7]);
(%o4)                          - 3
@end example

@c REWORD THIS PART.
A fun@value{cedilha}@~ao @code{g} retorna uma lista de @code{f} de cada elemento de @code{l} se @code{l}
consiste somente de n@'umeros n@~ao negativos; de outra forma, @code{g} "captura" o
primeiro elemento negativo de @code{l} e "arremessa-o".

@end deffn

@deffn {Fun@value{cedilha}@~ao} compfile (@var{nomeficheiro}, @var{f_1}, ..., @var{f_n})
@deffnx {Fun@value{cedilha}@~ao} compfile (@var{nomeficheiro}, fun@value{cedilha}@~oes)
@deffnx {Fun@value{cedilha}@~ao} compfile (@var{nomeficheiro}, all)

Traduz fu@value{cedilha}@~oes Maxima para Lisp 
e escreve o c@'odigo traduzido no ficheiro @var{nomeficheiro}.

@code{compfile(@var{nomeficheiro}, @var{f_1}, ..., @var{f_n})} traduz as
fun@value{cedilha}@~oes especificadas.
@code{compfile(@var{nomeficheiro}, functions)} e @code{compfile(@var{nomeficheiro}, all)}
traduz todas as fun@value{cedilha}@~oes definidas pelo utilizador.

As tradu@value{cedilha}@~oes Lisp n@~ao s@~ao avaliadas, nem @'e o ficheiro de sa@'{@dotless{i}}da processado pelo compilador Lisp.
@c SO LET'S CONSIDER GIVING THIS FUNCTION A MORE ACCURATE NAME.
@code{translate} cria e avalia tradu@value{cedilha}@~oes Lisp.
@code{compile_file} traduz Maxima para Lisp, e ent@~ao executa o compilador Lisp.  

Veja tamb@'em @code{translate}, @code{translate_file}, e @code{compile_file}.

@end deffn

@c THIS VARIABLE IS OBSOLETE: ASSIGNING compgrind: true CAUSES compfile
@c TO EVENTUALLY CALL AN OBSOLETE FUNCTION SPRIN1.
@c RECOMMENDATION IS TO CUT THIS ITEM, AND CUT $compgrind FROM src/transs.lisp
@c @defvar compgrind
@c Default value: @code{false}
@c 
@c When @code{compgrind} @'e @code{true}, function definitions printed by
@c @code{compfile} are pretty-printed.
@c 
@c @end defvar

@deffn {Fun@value{cedilha}@~ao} compile (@var{f_1}, ..., @var{f_n})
@deffnx {Fun@value{cedilha}@~ao} compile (fun@value{cedilha}@~oes)
@deffnx {Fun@value{cedilha}@~ao} compile (all)
Traduz fun@value{cedilha}@~oes Maxima @var{f_1}, ..., @var{f_n} para Lisp, avalia a tradu@value{cedilha}@~ao Lisp,
e chama a fun@value{cedilha}@~ao Lisp @code{COMPILE} sobre cada fun@value{cedilha}@~ao traduzida.
@code{compile} retorna uma lista de nomes de fun@value{cedilha}@~oes compiladas.

@code{compile (all)} ou @code{compile (fun@value{cedilha}@~oes)} compila todas as fun@value{cedilha}@~oes definidas pelo utilizador.

@code{compile} n@~ao avalia seus argumentos; 
o operador ap@'ostrofo-ap@'ostrofo @code{'@w{}'} faz com que ocorra avalia@value{cedilha}@~ao sobrepondo-se ao ap@'ostrofo.

@end deffn

@deffn {Fun@value{cedilha}@~ao} define (@var{f}(@var{x_1}, ..., @var{x_n}), @var{expr})
@deffnx {Fun@value{cedilha}@~ao} define (@var{f}[@var{x_1}, ..., @var{x_n}], @var{expr})
@deffnx {Fun@value{cedilha}@~ao} define (funmake (@var{f}, [@var{x_1}, ..., @var{x_n}]), @var{expr})
@deffnx {Fun@value{cedilha}@~ao} define (arraymake (@var{f}, [@var{x_1}, ..., @var{x_n}]), @var{expr})
@deffnx {Fun@value{cedilha}@~ao} define (ev (@var{expr_1}), @var{expr_2})

Define uma fun@value{cedilha}@~ao chamada @var{f} com argumentos @var{x_1}, ..., @var{x_n} e corpo da fun@value{cedilha}@~ao @var{expr}.
@code{define} sempre avalia seu segundo argumento (a menos que expl@'{@dotless{i}}citamente receba um apostrofo de forma a evitar a avalia@value{cedilha}@~ao).
A fun@value{cedilha}@~ao ent@~ao definida pode ser uma fun@value{cedilha}@~ao comum do Maxima (com argumentos contidos entre par@^etesis)
ou uma fun@value{cedilha}@~ao de array (com argumentos contidos entre colch@^etes).

Quando o @'ultimo ou @'unico argumento da fun@value{cedilha}@~ao @var{x_n} for uma lista de um elemento,
a fun@value{cedilha}@~ao definida por @code{define} aceita um n@'umero vari@'avel de argumentos.
Os argumentos actuais s@~ao atribu@'{@dotless{i}}dos um a um a argumentos formais @var{x_1}, ..., @var{x_(n - 1)},
e quaisquer argumentos adicionais actuais, se estiverem presentes, s@~ao atribu@'{@dotless{i}}dos a @var{x_n} como uma lista.

Quando o primeiro argumento de @code{define} for uma express@~ao da forma
@code{@var{f}(@var{x_1}, ..., @var{x_n})} or @code{@var{f}[@var{x_1}, ..., @var{x_n}]},
os argumentos s@~ao avaliados mas @var{f} n@~ao @'e avaliada,
mesmo se j@'a existe anteriormente uma fun@value{cedilha}@~ao ou vari@'avel com aquele nome.
Quando o primeiro argumento for uma express@~ao com operador @code{funmake}, @code{arraymake}, ou @code{ev},
o primeiro argumento ser@'a avaliado;
isso permite para o nome da fun@value{cedilha}@~ao seja calculado, tamb@'em como o corpo.

Todas as defini@value{cedilha}@~oes de fun@value{cedilha}@~ao aparecem no mesmo n@'{@dotless{i}}vel de escopo e visibilidade;
definindo uma fun@value{cedilha}@~ao @code{f} dentro de outra fun@value{cedilha}@~ao @code{g}
n@~ao limita o escopo de @code{f} a @code{g}.

Se algum argumento formal @var{x_k} for um s@'{@dotless{i}}mbolo com ap@'ostrofo (ap@'os ter sido feita uma avalia@value{cedilha}@~ao),
a fun@value{cedilha}@~ao definida por @code{define} n@~ao avalia o correspondente actual argumento.
de outra forma todos os argumentos actuais s@~ao avaliados.

Veja tamb@'em @code{:=} and @code{::=}.

Exemplos:

@code{define} sempre avalia seu segundo argumento (a menos que expl@'{@dotless{i}}citamente receba um apostrofo de forma a evitar a avalia@value{cedilha}@~ao).

@c ===beg===
@c expr : cos(y) - sin(x);
@c define (F1 (x, y), expr);
@c F1 (a, b);
@c F2 (x, y) := expr;
@c F2 (a, b);
@c ===end===
@example
(%i1) expr : cos(y) - sin(x);
(%o1)                    cos(y) - sin(x)
(%i2) define (F1 (x, y), expr);
(%o2)              F1(x, y) := cos(y) - sin(x)
(%i3) F1 (a, b);
(%o3)                    cos(b) - sin(a)
(%i4) F2 (x, y) := expr;
(%o4)                   F2(x, y) := expr
(%i5) F2 (a, b);
(%o5)                    cos(y) - sin(x)
@end example

A fun@value{cedilha}@~ao definida por @code{define} pode ser uma fun@value{cedilha}@~ao comum do Maxima ou uma fun@value{cedilha}@~ao de array.

@c ===beg===
@c define (G1 (x, y), x.y - y.x);
@c define (G2 [x, y], x.y - y.x);
@c ===end===
@example
(%i1) define (G1 (x, y), x.y - y.x);
(%o1)               G1(x, y) := x . y - y . x
(%i2) define (G2 [x, y], x.y - y.x);
(%o2)                G2     := x . y - y . x
                       x, y
@end example

Quando o @'ultimo ou @'unico argumento da fun@value{cedilha}@~ao @var{x_n} for uma lista de um @'unico elemento,
a fun@value{cedilha}@~ao definida por @code{define} aceita um n@'umero vari@'avel de argumentos.

@c ===beg===
@c define (H ([L]), '(apply ("+", L)));
@c H (a, b, c);
@c ===end===
@example
(%i1) define (H ([L]), '(apply ("+", L)));
(%o1)                H([L]) := apply("+", L)
(%i2) H (a, b, c);
(%o2)                       c + b + a
@end example

When the first argument is an expression with operator @code{funmake}, @code{arraymake}, or @code{ev},
the first argument is evaluated.

@c ===beg===
@c [F : I, u : x];
@c funmake (F, [u]);
@c define (funmake (F, [u]), cos(u) + 1);
@c define (arraymake (F, [u]), cos(u) + 1);
@c define (foo (x, y), bar (y, x));
@c define (ev (foo (x, y)), sin(x) - cos(y));
@c ===end===
@example
(%i1) [F : I, u : x];
(%o1)                        [I, x]
(%i2) funmake (F, [u]);
(%o2)                         I(x)
(%i3) define (funmake (F, [u]), cos(u) + 1);
(%o3)                  I(x) := cos(x) + 1
(%i4) define (arraymake (F, [u]), cos(u) + 1);
(%o4)                   I  := cos(x) + 1
                         x
(%i5) define (foo (x, y), bar (y, x));
(%o5)                foo(x, y) := bar(y, x)
(%i6) define (ev (foo (x, y)), sin(x) - cos(y));
(%o6)             bar(y, x) := sin(x) - cos(y)
@end example

@end deffn

@c SEE NOTE BELOW ABOUT THE DOCUMENTATION STRING
@c @deffn {Fun@value{cedilha}@~ao} define_variable (@var{name}, @var{default_value}, @var{mode}, @var{documentation})
@deffn {Fun@value{cedilha}@~ao} define_variable (@var{name}, @var{default_value}, @var{mode})

Introduz uma vari@'avel global dentro do ambiente Maxima.
@c IMPORT OF FOLLOWING STATEMENT UNCLEAR: IN WHAT WAY IS define_variable MORE USEFUL IN TRANSLATED CODE ??
@code{define_variable} @'e @'util em pacotes escritos pelo utilizador, que s@~ao muitas vezes traduzidos ou compilados.

@code{define_variable} realiza os seguintes passos:

@enumerate
@item
@code{mode_declare (@var{name}, @var{mode})} declara o modo de @var{name} para o tradutor.
Veja @code{mode_declare} para uma lista dos modos poss@'{@dotless{i}}veis.

@item
Se a vari@'avel @'e n@~ao associada, @var{default_value} @'e atribu@'{@dotless{i}}do para @var{name}.

@item
@code{declare (@var{name}, special)} declara essa vari@'avel especial.
@c CLARIFY THE MEANING OF SPECIAL FOR THE BENEFIT OF READERS OTHER THAN LISP PROGRAMMERS

@item
Associa @var{name} com uma fun@value{cedilha}@~ao de teste
para garantir que a @var{name} seja somente atribu@'{@dotless{i}}do valores do modo declarado.
@end enumerate


@c FOLLOWING STATEMENT APPEARS TO BE OUT OF DATE.
@c EXAMINING DEFMSPEC $DEFINE_VARIABLE AND DEF%TR $DEFINE_VARIABLE IN src/trmode.lisp,
@c IT APPEARS THAT THE 4TH ARGUMENT IS NEVER REFERRED TO.
@c EXECUTING translate_file ON A MAXIMA BATCH FILE WHICH CONTAINS
@c define_variable (foo, 2222, integer, "THIS IS FOO");
@c DOES NOT PUT "THIS IS FOO" INTO THE LISP FILE NOR THE UNLISP FILE.
@c The optional 4th argumento @'e a documentation string.  When
@c @code{translate_file} @'e used on a package which includes documentation
@c strings, a second file @'e output in addition to the Lisp file which
@c will contain the documentation strings, formatted suitably for use in
@c manuals, usage files, or (for instance) @code{describe}.

A propriedade @code{value_check} pode ser atribu@'{@dotless{i}}da a qualquer vari@'avel que tenha sido definida
via @code{define_variable} com um outro modo que n@~ao @code{any}.
A propriedade @code{value_check} @'e uma express@~ao lambda ou o nome de uma fun@value{cedilha}@~ao de uma vari@'avel,
que @'e chamada quando uma tentativa @'e feita para atribuir um valor a uma vari@'avel.
O argumento da  fun@value{cedilha}@~ao @code{value_check} @'e o valor que ser@'a atribu@'{@dotless{i}}do.

@code{define_variable} avalia @code{default_value}, e n@~ao avalia @code{name} e @code{mode}.
@code{define_variable} retorna o valor corrente de @code{name},
que @'e @code{default_value} se @code{name} n@~ao tiver sido associada antes,
e de outra forma isso @'e o valor pr@'evio de @code{name}.

Exemplos:

@code{foo} @'e uma vari@'avel Booleana, com o valor inicial @code{true}.
@c GENERATED FROM:
@c define_variable (foo, true, boolean);
@c foo;
@c foo: false;
@c foo: %pi;
@c foo;

@example
(%i1) define_variable (foo, true, boolean);
(%o1)                         true
(%i2) foo;
(%o2)                         true
(%i3) foo: false;
(%o3)                         false
(%i4) foo: %pi;
Error: foo was declared mode boolean, has value: %pi
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) foo;
(%o5)                         false
@end example

@code{bar} @'e uma vari@'avel inteira, que deve ser um n@'umero primo.
@c GENERATED FROM:
@c define_variable (bar, 2, integer);
@c qput (bar, prime_test, value_check);
@c prime_test (y) := if not primep(y) then error (y, "is not prime.");
@c bar: 1439;
@c bar: 1440;
@c bar;

@example
(%i1) define_variable (bar, 2, integer);
(%o1)                           2
(%i2) qput (bar, prime_test, value_check);
(%o2)                      prime_test
(%i3) prime_test (y) := if not primep(y) then error (y, "is not prime.");
(%o3) prime_test(y) := if not primep(y)

                                   then error(y, "is not prime.")
(%i4) bar: 1439;
(%o4)                         1439
(%i5) bar: 1440;
1440 @'e not prime.
#0: prime_test(y=1440)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i6) bar;
(%o6)                         1439
@end example

@code{baz_quux} @'e uma vari@'avel que n@~ao pode receber a atribui@value{cedilha}@~ao de um valor.
O modo @code{any_check} @'e como @code{any}, 
mas @code{any_check} habilita o mecanismo @code{value_check}, e @code{any} n@~ao habilita.
@c GENERATED FROM:
@c define_variable (baz_quux, 'baz_quux, any_check);
@c F: lambda ([y], if y # 'baz_quux then error ("Cannot assign to `baz_quux'."));
@c qput (baz_quux, ''F, value_check);
@c baz_quux: 'baz_quux;
@c baz_quux: sqrt(2);
@c baz_quux;

@example
(%i1) define_variable (baz_quux, 'baz_quux, any_check);
(%o1)                       baz_quux
(%i2) F: lambda ([y], if y # 'baz_quux then error ("Cannot assign to `baz_quux'."));
(%o2) lambda([y], if y # 'baz_quux

                        then error(Cannot assign to `baz_quux'.))
(%i3) qput (baz_quux, ''F, value_check);
(%o3) lambda([y], if y # 'baz_quux

                        then error(Cannot assign to `baz_quux'.))
(%i4) baz_quux: 'baz_quux;
(%o4)                       baz_quux
(%i5) baz_quux: sqrt(2);
Cannot assign to `baz_quux'.
#0: lambda([y],if y # 'baz_quux then error("Cannot assign to `baz_quux'."))(y=sqrt(2))
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i6) baz_quux;
(%o6)                       baz_quux
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} dispfun (@var{f_1}, ..., @var{f_n})
@deffnx {Fun@value{cedilha}@~ao} dispfun (all)
Mostra a defini@value{cedilha}@~ao de fun@value{cedilha}@~oes definidas pelo utilizador @var{f_1}, ..., @var{f_n}.
Cada argumento pode ser o nome de uma macro (definida com @code{::=}),
uma fun@value{cedilha}@~ao comum (definida com @code{:=} ou @code{define}),
uma fun@value{cedilha}@~ao array (definida com @code{:=} ou com @code{define},
mas contendo argumentos entre colch@^etes @code{[ ]}),
uma fun@value{cedilha}@~ao subscrita, (definida com @code{:=} ou @code{define},
mas contendo alguns argumentos entre colch@^etes e outros entre par@^entesis @code{( )})
uma da fam@'{@dotless{i}}lia de fun@value{cedilha}@~oes subscritas seleccionadas por um valor subscrito particular,
ou uma fun@value{cedilha}@~ao subscrita definida com uma constante subscrita.

@code{dispfun (all)} mostra todas as fun@value{cedilha}@~oes definidas pelo utilizador como
dadas pelas @code{functions}, @code{arrays}, e listas de @code{macros},
omitindo fun@value{cedilha}@~oes subscritas definidas com constantes subscritas.

@code{dispfun} cria um R@'otulo de express@~ao interm@'edia
(@code{%t1}, @code{%t2}, etc.)
para cada fun@value{cedilha}@~ao mostrada, e atribui a defini@value{cedilha}@~ao de fun@value{cedilha}@~ao para o r@'otulo.
Em contraste, @code{fundef} retorna a defini@value{cedilha}@~ao de fun@value{cedilha}@~ao.

@code{dispfun} n@~ao avalia seus argumentos; 
O operador ap@'ostrofo-ap@'ostrofo @code{'@w{}'} faz com que ocorra avalia@value{cedilha}@~ao.

@code{dispfun} retorna a lista de r@'otulos de express@~oes interm@'edias correspondendo @`as fun@value{cedilha}@~oes mostradas.

Exemplos:


@c ===beg===
@c m(x, y) ::= x^(-y);
@c f(x, y) :=  x^(-y);
@c g[x, y] :=  x^(-y);
@c h[x](y) :=  x^(-y);
@c i[8](y) :=  8^(-y);
@c dispfun (m, f, g, h, h[5], h[10], i[8]);
@c ''%;
@c ===end===
@example
(%i1) m(x, y) ::= x^(-y);
                                     - y
(%o1)                   m(x, y) ::= x
(%i2) f(x, y) :=  x^(-y);
                                     - y
(%o2)                    f(x, y) := x
(%i3) g[x, y] :=  x^(-y);
                                    - y
(%o3)                     g     := x
                           x, y
(%i4) h[x](y) :=  x^(-y);
                                    - y
(%o4)                     h (y) := x
                           x
(%i5) i[8](y) :=  8^(-y);
                                    - y
(%o5)                     i (y) := 8
                           8
(%i6) dispfun (m, f, g, h, h[5], h[10], i[8]);
                                     - y
(%t6)                   m(x, y) ::= x

                                     - y
(%t7)                    f(x, y) := x

                                    - y
(%t8)                     g     := x
                           x, y

                                    - y
(%t9)                     h (y) := x
                           x

                                    1
(%t10)                     h (y) := --
                            5        y
                                    5

                                     1
(%t11)                    h  (y) := ---
                           10         y
                                    10

                                    - y
(%t12)                    i (y) := 8
                           8

(%o12)       [%t6, %t7, %t8, %t9, %t10, %t11, %t12]
(%i12) ''%;
                     - y              - y            - y
(%o12) [m(x, y) ::= x   , f(x, y) := x   , g     := x   , 
                                            x, y
                  - y           1              1             - y
        h (y) := x   , h (y) := --, h  (y) := ---, i (y) := 8   ]
         x              5        y   10         y   8
                                5             10

@end example

@end deffn

@defvr {Vari@'avel de sistema} functions
Valor por omiss@~ao: @code{[]}

@code{functions} @'e uma lista de todas as fun@value{cedilha}@~oes comuns do Maxima
na sess@~ao corrente.
Uma fun@value{cedilha}@~ao comum @'e uma fun@value{cedilha}@~ao constru@'{@dotless{i}}da atrav@'es de
@code{define} ou de @code{:=} e chamada com par@^entesis @code{()}.
Uma fun@value{cedilha}@~ao pode ser definida pela linha de comando do Maxima de forma interativa com o utilizador
ou em um ficheiro Maxima chamado por @code{load} ou @code{batch}.

Fun@value{cedilha}@~oes de array (chamadas com colch@^etes, e.g., @code{F[x]})
e fun@value{cedilha}@~oes com subscritos (chamadas com colch@^etes e par@^entesis, e.g., @code{F[x](y)})
s@~ao lsitados atrav@'es da vari@'avel global @code{arrays}, e n@~ao por meio de @code{functions}.

Fun@value{cedilha}@~oes Lisp n@~ao s@~ao mantidas em nenhuma lista.

Exemplos:

@c ===beg===
@c F_1 (x) := x - 100;
@c F_2 (x, y) := x / y;
@c define (F_3 (x), sqrt (x));
@c G_1 [x] := x - 100;
@c G_2 [x, y] := x / y;
@c define (G_3 [x], sqrt (x));
@c H_1 [x] (y) := x^y;
@c functions;
@c arrays;
@c ===end===
@example
(%i1) F_1 (x) := x - 100;
(%o1)                   F_1(x) := x - 100
(%i2) F_2 (x, y) := x / y;
                                      x
(%o2)                    F_2(x, y) := -
                                      y
(%i3) define (F_3 (x), sqrt (x));
(%o3)                   F_3(x) := sqrt(x)
(%i4) G_1 [x] := x - 100;
(%o4)                    G_1  := x - 100
                            x
(%i5) G_2 [x, y] := x / y;
                                     x
(%o5)                     G_2     := -
                             x, y    y
(%i6) define (G_3 [x], sqrt (x));
(%o6)                    G_3  := sqrt(x)
                            x
(%i7) H_1 [x] (y) := x^y;
                                      y
(%o7)                     H_1 (y) := x
                             x
(%i8) functions;
(%o8)              [F_1(x), F_2(x, y), F_3(x)]
(%i9) arrays;
(%o9)                 [G_1, G_2, G_3, H_1]
@end example

@end defvr

@deffn {Fun@value{cedilha}@~ao} fundef (@var{f})
Retorna a defini@value{cedilha}@~ao da fun@value{cedilha}@~ao @var{f}.

@c PROBABLY THIS WOULD BE CLEARER AS A BULLET LIST
O argumento pode ser o nome de uma macro (definida com @code{::=}),
uma fun@value{cedilha}@~ao comum (definida com @code{:=} ou @code{define}),
uma fun@value{cedilha}@~ao array (definida com @code{:=} ou @code{define},
mas contendo argumentos entre colch@^etes @code{[ ]}),
Uma fun@value{cedilha}@~ao subscrita, (definida com @code{:=} ou @code{define},
mas contendo alguns argumentos entre colch@^etes e par@^entesis @code{( )})
uma da fam@'{@dotless{i}}lia de fun@value{cedilha}@~oes subscritas seleccionada por um valor particular subscrito,
ou uma fun@value{cedilha}@~ao subscrita definida com uma constante subscrita.

@code{fundef} n@~ao avalia seu argumento;
o operador ap@'ostrofo-ap@'ostrofo @code{'@w{}'} faz com que ocorra avalia@value{cedilha}@~ao.

@code{fundef (@var{f})} retorna a defini@value{cedilha}@~ao de @var{f}.
Em contraste, @code{dispfun (@var{f})} cria um r@'otulo de express@~ao interm@'edia
e atribui a defini@value{cedilha}@~ao para o r@'otulo.

@c PROBABLY NEED SOME EXAMPLES HERE
@end deffn

@deffn {Fun@value{cedilha}@~ao} funmake (@var{F}, [@var{arg_1}, ..., @var{arg_n}])
Retorna uma express@~ao @code{@var{F}(@var{arg_1}, ..., @var{arg_n})}.
O valor de retorno @'e simplificado, mas n@~ao avaliado,
ent@~ao a fun@value{cedilha}@~ao @var{F} n@~ao @'e chamada, mesmo se essa fun@value{cedilha}@~ao @var{F} existir.

@code{funmake} n@~ao tenta distinguir fun@value{cedilha}@~oes de array de fun@value{cedilha}@~oes comuns;
quando @var{F} for o nome de uma fun@value{cedilha}@~ao de array,
@code{funmake} retorna @code{@var{F}(...)}
(isto @'e, uma chamada de fun@value{cedilha}@~ao com par@^entesis em lugar de colch@^etes).
@code{arraymake} retorna uma chamada de fun@value{cedilha}@~ao com colch@^etes nesse caso.

@code{funmake} avalia seus argumentos.

Exemplos:

@code{funmake} aplicada a uma fun@value{cedilha}@~ao comum do Maxima.

@c ===beg===
@c F (x, y) := y^2 - x^2;
@c funmake (F, [a + 1, b + 1]);
@c ''%;
@c ===end===
@example
(%i1) F (x, y) := y^2 - x^2;
                                   2    2
(%o1)                  F(x, y) := y  - x
(%i2) funmake (F, [a + 1, b + 1]);
(%o2)                    F(a + 1, b + 1)
(%i3) ''%;
                              2          2
(%o3)                  (b + 1)  - (a + 1)
@end example

@code{funmake} aplicada a uma macro.

@c ===beg===
@c G (x) ::= (x - 1)/2;
@c funmake (G, [u]);
@c ''%;
@c ===end===
@example
(%i1) G (x) ::= (x - 1)/2;
                                  x - 1
(%o1)                    G(x) ::= -----
                                    2
(%i2) funmake (G, [u]);
(%o2)                         G(u)
(%i3) ''%;
                              u - 1
(%o3)                         -----
                                2
@end example

@code{funmake} aplicada a uma fun@value{cedilha}@~ao subscrita.

@c ===beg===
@c H [a] (x) := (x - 1)^a;
@c funmake (H [n], [%e]);
@c ''%;
@c funmake ('(H [n]), [%e]);
@c ''%;
@c ===end===
@example
(%i1) H [a] (x) := (x - 1)^a;
                                        a
(%o1)                   H (x) := (x - 1)
                         a
(%i2) funmake (H [n], [%e]);
                                       n
(%o2)               lambda([x], (x - 1) )(%e)
(%i3) ''%;
                                    n
(%o3)                       (%e - 1)
(%i4) funmake ('(H [n]), [%e]);
(%o4)                        H (%e)
                              n
(%i5) ''%;
                                    n
(%o5)                       (%e - 1)
@end example

@code{funmake} aplicada a um s@'{@dotless{i}}mbolo que n@~ao @'e uma fun@value{cedilha}@~ao definida de qualquer tipo.

@c ===beg===
@c funmake (A, [u]);
@c ''%;
@c ===end===
@example
(%i1) funmake (A, [u]);
(%o1)                         A(u)
(%i2) ''%;
(%o2)                         A(u)
@end example

 @code{funmake} avalia seus argumentos, mas n@~ao o valor de retorno.

@c ===beg===
@c det(a,b,c) := b^2 -4*a*c;
@c (x : 8, y : 10, z : 12);
@c f : det;
@c funmake (f, [x, y, z]);
@c ''%;
@c ===end===
@example
(%i1) det(a,b,c) := b^2 -4*a*c;
                                    2
(%o1)              det(a, b, c) := b  - 4 a c
(%i2) (x : 8, y : 10, z : 12);
(%o2)                          12
(%i3) f : det;
(%o3)                          det
(%i4) funmake (f, [x, y, z]);
(%o4)                    det(8, 10, 12)
(%i5) ''%;
(%o5)                         - 284
@end example
Maxima simplifica o valor de retorno de @code{funmake}.

@c ===beg===
@c funmake (sin, [%pi / 2]);
@c ===end===
@example
(%i1) funmake (sin, [%pi / 2]);
(%o1)                           1
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} lambda ([@var{x_1}, ..., @var{x_m}], @var{expr_1}, ..., @var{expr_n})
@deffnx {Fun@value{cedilha}@~ao} lambda ([[@var{L}]], @var{expr_1}, ..., @var{expr_n})
@deffnx {Fun@value{cedilha}@~ao} lambda ([@var{x_1}, ..., @var{x_m}, [@var{L}]], @var{expr_1}, ..., @var{expr_n})
Define e retorna uma express@~ao lambda (que @'e, uma fun@value{cedilha}@~ao an@^onima)
A fun@value{cedilha}@~ao pode ter argumentos que sejam necess@'arios @var{x_1}, ..., @var{x_m}
e/ou argumentos opcionais @var{L}, os quais aparecem dentro do corpo da fun@value{cedilha}@~ao como uma lista.
O valor de retorno da fun@value{cedilha}@~ao @'e @var{expr_n}.
Uma express@~ao lambda pode ser atribu@'{@dotless{i}}da para uma vari@'avel e avaliada como uma fun@value{cedilha}@~ao comum.
Uma express@~ao lambda pode aparecer em alguns contextos nos quais um nome de fun@value{cedilha}@~ao @'e esperado.

Quando a fun@value{cedilha}@~ao @'e avaliada,
vari@'aveis locais n@~ao associadas @var{x_1}, ..., @var{x_m} s@~ao criadas.
@code{lambda} pode aparecer dentro de @code{block} ou outra fun@value{cedilha}@~ao @code{lambda};
vari@'aveis locais s@~ao estabelecidas cada vez que outro @code{block} ou fun@value{cedilha}@~ao @code{lambda} @'e avaliada.
Vari@'aveis locais parecem ser globais para qualquer coisa contendo @code{block} ou @code{lambda}.
Se uma vari@'avel @'e n@~ao local,
seu valor @'e o valor mais recentemente atribu@'{@dotless{i}}do em alguma coisa contendo @code{block} ou @code{lambda}, qualquer que seja,
de outra forma, seu valor @'e o valor da vari@'avel no ambiente global.
Essa pol@'{@dotless{i}}tica pode coincidir com o entendimento usual de "escopo din@^amico".

Ap@'os vari@'aveis locais serem estabelecidas,
@var{expr_1} at@'e @var{expr_n} s@~ao avaliadas novamente.
a vari@'avel especial @code{%%}, representando o valor da express@~ao precedente,
@'e reconhecida.
@code{throw} e @code{catch} pode tamb@'em aparecer na lista de express@~oes.

@code{return} n@~ao pode aparecer em uma express@~ao lambda a menos que contendo @code{block},
nesse caso @code{return} define o valor de retorno do  bloco e n@~ao da
express@~ao lambda,
a menos que o bloco seja @var{expr_n}.
Da mesma forma, @code{go} n@~ao pode aparecer em uma express@~ao lambda a menos que contendo @code{block}.

@code{lambda} n@~ao avalia seus argumentos; 
o operador ap@'ostrofo-ap@'ostrofo @code{'@w{}'} faz com que ocorra avalia@value{cedilha}@~ao.

Exemplos:

@itemize @bullet
@item
A express@~ao lambda pode ser atribu@'{@dotless{i}}da para uma vari@'avel e avaliada como uma fun@value{cedilha}@~ao comum.
@end itemize
@c ===beg===
@c f: lambda ([x], x^2);
@c f(a);
@c ===end===
@example
(%i1) f: lambda ([x], x^2);
                                      2
(%o1)                    lambda([x], x )
(%i2) f(a);
                                2
(%o2)                          a
@end example
@itemize @bullet
@item
Uma express@~ao lambda pode aparecer em contextos nos quais uma avalia@value{cedilha}@~ao de fun@value{cedilha}@~ao @'e esperada como resposta.
@end itemize
@c ===beg===
@c lambda ([x], x^2) (a);
@c apply (lambda ([x], x^2), [a]);
@c map (lambda ([x], x^2), [a, b, c, d, e]);
@c ===end===
@example
(%i3) lambda ([x], x^2) (a);
                                2
(%o3)                          a
(%i4) apply (lambda ([x], x^2), [a]);
                                2
(%o4)                          a
(%i5) map (lambda ([x], x^2), [a, b, c, d, e]);
                        2   2   2   2   2
(%o5)                 [a , b , c , d , e ]
@end example
@itemize @bullet
@item
Vari@'aveis argumento s@~ao vari@'aveis locais.
Outras vari@'aveis aparecem para serem vari@'aveis globais.
Vari@'aveis globais s@~ao avaliadas ao mesmo tempo em que a express@~ao lambda @'e avaliada,
a menos que alguma avalia@value{cedilha}@~ao especial seja for@value{cedilha}ada por alguns meios, tais como @code{'@w{}'}.
@end itemize
@c ===beg===
@c a: %pi$
@c b: %e$
@c g: lambda ([a], a*b);
@c b: %gamma$
@c g(1/2);
@c g2: lambda ([a], a*''b);
@c b: %e$
@c g2(1/2);
@c ===end===
@example
(%i6) a: %pi$
(%i7) b: %e$
(%i8) g: lambda ([a], a*b);
(%o8)                   lambda([a], a b)
(%i9) b: %gamma$
(%i10) g(1/2);
                             %gamma
(%o10)                       ------
                               2
(%i11) g2: lambda ([a], a*''b);
(%o11)                lambda([a], a %gamma)
(%i12) b: %e$
(%i13) g2(1/2);
                             %gamma
(%o13)                       ------
                               2
@end example
@itemize @bullet
@item
Express@~oes lambda podem ser aninhadas.
Vari@'aveis locais dentro de outra express@~ao lambda parece ser global para a express@~ao interna
a menos que mascarada por vari@'aveis locais de mesmos nomes.
@end itemize
@c ===beg===
@c h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
@c h(%pi, %gamma);
@c ===end===
@example
(%i14) h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
                                                   1
(%o14)    lambda([a, b], h2 : lambda([a], a b), h2(-))
                                                   2
(%i15) h(%pi, %gamma);
                             %gamma
(%o15)                       ------
                               2
@end example
@itemize @bullet
@item
Uma vez que @code{lambda} n@~ao avalia seus argumentos, a express@~ao lambda @code{i} abaixo
n@~ao define uma fun@value{cedilha}@~ao "multiplica@value{cedilha}@~ao por @code{a}".
Tanto uma fun@value{cedilha}@~ao pode ser definida via @code{buildq}, como na express@~ao lambda @code{i2} abaixo.
@end itemize
@c ===beg===
@c i: lambda ([a], lambda ([x], a*x));
@c i(1/2);
@c i2: lambda([a], buildq([a: a], lambda([x], a*x)));
@c i2(1/2);
@c i2(1/2)(%pi);
@c ===end===
@example
(%i16) i: lambda ([a], lambda ([x], a*x));
(%o16)            lambda([a], lambda([x], a x))
(%i17) i(1/2);
(%o17)                  lambda([x], a x)
(%i18) i2: lambda([a], buildq([a: a], lambda([x], a*x)));
(%o18)    lambda([a], buildq([a : a], lambda([x], a x)))
(%i19) i2(1/2);
                                     x
(%o19)                   lambda([x], -)
                                     2
(%i20) i2(1/2)(%pi);
                               %pi
(%o20)                         ---
                                2
@end example
@itemize @bullet
@item
Uma express@~ao lambda pode receber um n@'umero vari@'avel de argumentos,
os quais s@~ao indicados por meio de @code{[@var{L}]} como o argumento @'unico ou argumento final.
Os argumentos aparecem dentro do corpo da fun@value{cedilha}@~ao como uma lista.
@end itemize
@c ===beg===
@c f : lambda ([aa, bb, [cc]], aa * cc + bb);
@c f (foo, %i, 17, 29, 256);
@c g : lambda ([[aa]], apply ("+", aa));
@c g (17, 29, x, y, z, %e);
@c ===end===
@example
(%i1) f : lambda ([aa, bb, [cc]], aa * cc + bb);
(%o1)          lambda([aa, bb, [cc]], aa cc + bb)
(%i2) f (foo, %i, 17, 29, 256);
(%o2)       [17 foo + %i, 29 foo + %i, 256 foo + %i]
(%i3) g : lambda ([[aa]], apply ("+", aa));
(%o3)             lambda([[aa]], apply(+, aa))
(%i4) g (17, 29, x, y, z, %e);
(%o4)                  z + y + x + %e + 46
@end example
@end deffn

@c NEEDS CLARIFICATION AND EXAMPLES
@deffn {Fun@value{cedilha}@~ao} local (@var{v_1}, ..., @var{v_n})
Declara as vari@'aveis @var{v_1}, ..., @var{v_n} para serem locais com
rela@value{cedilha}@~ao a todas as propriedades na declara@value{cedilha}@~ao na qual essa fun@value{cedilha}@~ao
@'e usada.

@code{local} n@~ao avalia seus argumentos.
@code{local} retorna @code{done}.

@code{local} pode somente ser usada em @code{block}, no corpo de defini@value{cedilha}@~oes
de fun@value{cedilha}@~ao ou express@~oes @code{lambda}, ou na fun@value{cedilha}@~ao @code{ev}, e somente uma
ocorr@^ecia @'e permitida em cada.

@code{local} @'e independente de @code{context}.

@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} macroexpansion
Valor por omiss@~ao: @code{false}

@code{macroexpansion} controla recursos avan@value{cedilha}ados que
afectam a efici@^encia de macros.  Escolhas poss@'{@dotless{i}}veis:

@itemize @bullet
@item
@code{false} -- Macros expandem normalmente cada vez que s@~ao chamadas.
@item
@code{expand} -- A primeira vez de uma chamada particular @'e avaliada, a
expans@~ao @'e lembrada internamente, dessa forma n@~ao tem como ser
recalculada em chamadas subsequ@^ente rapidamente.  A
macro chama ainda chamadas @code{grind} e @code{display} normalmente.  Todavia, mem@'oria extra @'e
requerida para lembrar todas as expans@~oes.
@item
@code{displace} -- A primeira vez de uma chamada particular @'e avaliada, a
expans@~ao @'e substitu@'{@dotless{i}}da pela chamada.  Isso requer levemente menos
armazenagem que quando @code{macroexpansion} @'e escolhida para @code{expand} e @'e razo@'avelmente r@'apido,
mas tem a desvantagem de a macro original ser lentamente
lembrada e da@'{@dotless{i}} a expans@~ao ser@'a vista se @code{display} ou @code{grind} for
chamada.  Veja a documenta@value{cedilha}@~ao para @code{translate} e @code{macros} para maiores detalhes.
@end itemize
@c NEED SOME EXAMPLES HERE.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} mode_checkp
Valor por omiss@~ao: @code{true}

@c WHAT DOES THIS MEAN ??
Quando @code{mode_checkp} @'e @code{true}, @code{mode_declare} verifica os modos
de associa@value{cedilha}@~ao de vari@'aveis.
@c NEED SOME EXAMPLES HERE.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} mode_check_errorp
Valor por omiss@~ao: @code{false}

@c WHAT DOES THIS MEAN ??
Quando @code{mode_check_errorp} @'e @code{true}, @code{mode_declare} chama
a fun@value{cedilha}@~ao "error".
@c NEED SOME EXAMPLES HERE.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} mode_check_warnp
Valor por omiss@~ao: @code{true}

@c WHAT DOES THIS MEAN ??
Quando @code{mode_check_warnp} @'e @code{true}, modo "errors" s@~ao
descritos.
@c NEED SOME EXAMPLES HERE.

@end defvr

@c NEEDS CLARIFICATION AND EXAMPLES
@deffn {Fun@value{cedilha}@~ao} mode_declare (@var{y_1}, @var{mode_1}, ..., @var{y_n}, @var{mode_n})
@code{mode_declare} @'e usado para declarar os modos de vari@'aveis e
fun@value{cedilha}@~oes para subsequ@^ente tradu@value{cedilha}@~ao ou compila@value{cedilha}@~ao das fun@value{cedilha}@~oes.
@code{mode_declare} @'e tipicamente colocada no in@'{@dotless{i}}cio de uma defini@value{cedilha}@~ao de
fun@value{cedilha}@~ao, no in@'{@dotless{i}}cio de um script Maxima, ou executado atrav@'es da linha de comando de forma interativa.

Os argumentos de @code{mode_declare} s@~ao pares consistindo de  uma vari@'avel e o modo que @'e
um de @code{boolean}, @code{fixnum}, @code{number}, @code{rational}, ou @code{float}.
Cada vari@'avel pode tamb@'em
ser uma lista de vari@'aveis todas as quais s@~ao declaradas para ter o mesmo modo.

@c WHAT DOES THE FOLLOWING STATEMENT MEAN ???
Se uma vari@'avel @'e um array, e se todo elemento do array que @'e
referenciado tiver um valor ent@~ao @code{array (yi, complete, dim1, dim2, ...)}
em lugar de 
@example
array(yi, dim1, dim2, ...)
@end example
dever@'a ser usado primeiro
declarando as associa@value{cedilha}@~oes do array.
@c WHAT DOES THE FOLLOWING STATEMENT MEAN ???
Se todos os elementos do array
est@~ao no modo @code{fixnum} (@code{float}), use @code{fixnum} (@code{float}) em lugar de @code{complete}.
@c WHAT DOES THE FOLLOWING STATEMENT MEAN ???
Tamb@'em se todo elemento do array est@'a no mesmo modo, digamos @code{m}, ent@~ao

@example
mode_declare (completearray (yi), m))
@end example

dever@'a ser usado para uma tradu@value{cedilha}@~ao
eficiente.

C@'odigo num@'ericos usando arrays podem rodar mais r@'apidamente
se for decladado o tamanho esperado do array, como em:

@example
mode_declare (completearray (a [10, 10]), float)
@end example

para um array num@'erico em ponto flutuante que @'e 10 x 10.

Pode-se declarar o modo do resultado de uma fun@value{cedilha}@~ao
usando @code{function (f_1, f_2, ...)} como um argumento;
aqui @code{f_1}, @code{f_2}, ...  s@~ao nomes
de fun@value{cedilha}@~oes.  Por exemplo a express@~ao,

@example
mode_declare ([function (f_1, f_2, ...)], fixnum)
@end example

declara que os valores retornados por @code{f_1}, @code{f_2}, ...  s@~ao inteiros palavra simples.

@code{modedeclare} @'e um sin@^onimo para @code{mode_declare}.

@end deffn

@c WHAT IS THIS ABOUT ??
@c NEEDS CLARIFICATION AND EXAMPLES
@deffn {Fun@value{cedilha}@~ao} mode_identity (@var{arg_1}, @var{arg_2})
Uma forma especial usada com @code{mode_declare} e @code{macros} para
declarar, e.g., uma lista de listas de n@'umeros em ponto flutuante ou
outros objectos de dados.  O primeiro argumento para
@code{mode_identity} @'e um valor primitivo nome de modo como dado para
@code{mode_declare} (i.e., um de @code{float}, @code{fixnum},
@code{number}, @code{list}, ou @code{any}), e o segundo argumento @'e
uma express@~ao que @'e avaliada e retornada com o valor de
@code{mode_identity}. No entanto, se o valor de retorno n@~ao @'e
permitido pelo modo declarado no primeiro argumento, um erro ou alerta
@'e sinalizado.  Um ponto importante @'e que o modo da express@~ao como
determinado pelo Maxima para o tradutor Lisp, ser@'a aquele dado como o
primeiro argumento, independente de qualquer coisa que v@'a no segundo
argumento.  E.g., @code{x: 3.3; mode_identity (fixnum, x);} retorna um
erro.  @code{mode_identity (flonum, x)} returns 3.3 .  Isto tem
n@'umerosas utilidades, por exemplo, se souber que @code{first (l)}
retornou um n@'umero ent@~ao poder@'a escrever @code{mode_identity
(number, first (l))}. No entanto, um caminho mais eficiente para fazer a
mesma coisa @'e definir uma nova primitiva,

@example
firstnumb (x) ::= buildq ([x], mode_identity (number, x));
@end example

e usar @code{firstnumb} sempre que obtiver o primeiro de uma lista de
n@'umeros.

@end deffn

@c IS THERE ANY REASON TO SET transcompile: false ??
@c MAYBE THIS VARIABLE COULD BE PERMANENTLY SET TO true AND STRUCK FROM THE DOCUMENTATION.
@defvr {Vari@'avel de op@value{cedilha}@~ao} transcompile
Valor por omiss@~ao: @code{true}

Quando @code{transcompile} @'e @code{true}, @code{translate} e @code{translate_file} geram
declara@value{cedilha}@~oes para fazer o c@'odigo traduzido mais adequado para compila@value{cedilha}@~ao.
@c BUT THE DECLARATIONS DON'T SEEM TO BE NECESSARY, SO WHAT'S THE POINT AGAIN ??

@code{compfile} escolhe @code{transcompile: true} para a dura@value{cedilha}@~ao.

@end defvr

@deffn {Fun@value{cedilha}@~ao} translate (@var{f_1}, ..., @var{f_n})
@deffnx {Fun@value{cedilha}@~ao} translate (fun@value{cedilha}@~oes)
@deffnx {Fun@value{cedilha}@~ao} translate (all)
Traduz fun@value{cedilha}@~oes definidas pelo utilizador
@var{f_1}, ..., @var{f_n} da linguagem de Maxima para Lisp
e avalia a tradu@value{cedilha}@~ao Lisp.
Tipicamente as fun@value{cedilha}@~oes traduzidas executam mais r@'apido que as originais.

@code{translate (all)} ou @code{translate (fun@value{cedilha}@~oes)} traduz todas as fun@value{cedilha}@~oes definidas pelo utilizador.

Fun@value{cedilha}@~oes a serem traduzidas incluir~ao uma chamada para @code{mode_declare} no
in@'{@dotless{i}}cio quando poss@'{@dotless{i}}vel com o objectivo de produzir um c@'odigo mais eficiente.  Por
exemplo:

@example
f (x_1, x_2, ...) := block ([v_1, v_2, ...],
    mode_declare (v_1, mode_1, v_2, mode_2, ...), ...)
@end example

@noindent

quando @var{x_1}, @var{x_2}, ...  s@~ao par@^ametros para a fun@value{cedilha}@~ao e
@var{v_1}, @var{v_2}, ...  s@~ao vari@'aveis locais.

Os nomes de fun@value{cedilha}@~oes traduzidas
s@~ao removidos da lista @code{functions} se @code{savedef} @'e @code{false} (veja abaixo)
e s@~ao adicionados nas listas @code{props}.

Fun@value{cedilha}@~oes n@~ao poder@~ao ser traduzidas
a menos que elas sejam totalmente depuradas.

Express@~oes s@~ao assumidas simplificadas; se n@~ao forem, um c@'odigo correcto ser@'a gerado mas n@~ao ser@'a um c@'odigo
@'optimo.  Dessa forma, o utilizador n@~ao poder@'a escolher o comutador @code{simp} para @code{false}
o qual inibe simplifica@value{cedilha}@~ao de express@~oes a serem traduzidas.

O comutador @code{translate}, se @code{true}, causa tradu@value{cedilha}@~ao
automatica de uma fun@value{cedilha}@~ao de utilizador para Lisp.

Note que fun@value{cedilha}@~oes
traduzidas podem n@~ao executar identicamente para o caminho que elas faziam antes da
tradu@value{cedilha}@~ao como certas incompatabilidades podem existir entre o Lisp
e vers@~oes do Maxima.  Principalmente, a fun@value{cedilha}@~ao  @code{rat} com mais de
um argumento e a fun@value{cedilha}@~ao @code{ratvars} n@~ao poder@'a ser usada se quaisquer
vari@'aveis s@~ao declaradas com @code{mode_declare} como sendo express@~oes rotacionais can@'onicas(CRE).
Tamb@'em a escolha @code{prederror: false}
n@~ao traduzir@'a.
@c WHAT ABOUT % AND %% ???

@code{savedef} - se @code{true} far@'a com que a vers@~ao Maxima de uma fun@value{cedilha}@~ao
 utilizador permane@value{cedilha}a quando a fun@value{cedilha}@~ao @'e traduzida com @code{translate}.  Isso permite a
que defini@value{cedilha}@~ao seja mostrada por @code{dispfun} e autoriza a fun@value{cedilha}@~ao a ser
editada.

@code{transrun} - se @code{false} far@'a com que a vers@~ao interpretada de todas as
fun@value{cedilha}@~oes sejam executadas (desde que estejam ainda dispon@'{@dotless{i}}veis) em lugar da
vers@~ao traduzida.

O resultado retornado por @code{translate} @'e uma lista de nomes de
fun@value{cedilha}@~oes traduzidas.

@end deffn

@deffn {Fun@value{cedilha}@~ao} translate_file (@var{maxima_nomeficheiro})
@deffnx {Fun@value{cedilha}@~ao} translate_file (@var{maxima_nomeficheiro}, @var{lisp_nomeficheiro})
Traduz um ficheiro com c@'odigo Maxima para um ficheiro com c@'odigo Lisp.
@code{translate_file} retorna uma lista de tr@^es nomes de ficheiro:
O nome do ficheiro Maxima, o nome do ficheiro Lisp, e o nome do ficheiro
contendo informa@value{cedilha}@~oes adicionais sobre a tradu@value{cedilha}@~ao.
@code{translate_file} avalia seus argumentos.

@code{translate_file ("foo.mac"); load("foo.LISP")} @'e o mesmo que
@code{batch ("foo.mac")} excepto por certas restri@value{cedilha}@~oes,
o uso de @code{'@w{}'} e @code{%}, por exemplo.
@c FIGURE OUT WHAT THE RESTRICTIONS ARE AND STATE THEM

@code{translate_file (@var{maxima_nomeficheiro})} traduz um ficheiro Maxima @var{maxima_nomeficheiro}
para um similarmente chamado ficheiro Lisp.
Por exemplo, @code{foo.mac} @'e traduzido em @code{foo.LISP}.
O nome de ficheiro Maxima pod incluir nome ou nomes de direct@'orio(s),
nesse caso o ficheiro de sa@'{@dotless{i}}da Lisp @'e escrito
para o mesmo direct@'orio que a entrada Maxima.

@code{translate_file (@var{maxima_nomeficheiro}, @var{lisp_nomeficheiro})} traduz
um ficheiro Maxima @var{maxima_nomeficheiro} em um ficheiro Lisp @var{lisp_nomeficheiro}.
@code{translate_file} ignora a extens@~ao do nome do ficheiro, se qualquer, de @code{lisp_nomeficheiro};
a extens@~ao do ficheiro de sa@'{@dotless{i}}da Lisp @'e sempre @code{LISP}.
O nome de ficheiro Lisp pode incluir um nome ou nomes de direct@'orios),
nesse caso o ficheiro de sa@'{@dotless{i}}da Lisp @'e escrito para o direct@'orio especificado.

@code{translate_file} tamb@'em escreve um ficheiro de mensagens de alerta
do tradutor em v@'arios graus de severidade.
A extens@~ao do nome de ficheiro desse ficheiro @'e @code{UNLISP}.
Esse ficheiro pode conter informa@value{cedilha}@~ao valiosa, apesar de possivelmente obscura,
para rastrear erros no c@'odigo traduzido.
O ficheiro @code{UNLISP} @'e sempre escrito
para o mesmo direct@'orio que a entrada Maxima.

@code{translate_file} emite c@'odigo Lisp o qual faz com que
algumas defini@value{cedilha}@~oes tenham efeito t@~ao logo
o c@'odigo Lisp @'e compilado.
Veja @code{compile_file} para mais sobre esse t@'opico.

@c CHECK ALL THESE AND SEE WHICH ONES ARE OBSOLETE
Veja tamb@'em @code{tr_array_as_ref},
@c tr_bind_mode_hook EXISTS BUT IT APPEARS TO BE A GROTESQUE UNDOCUMENTED HACK
@c WE DON'T WANT TO MENTION IT
@c @code{tr_bind_mode_hook}, 
@code{tr_bound_function_applyp},
@c tr_exponent EXISTS AND WORKS AS ADVERTISED IN src/troper.lisp
@c NOT OTHERWISE DOCUMENTED; ITS EFFECT SEEMS TOO WEAK TO MENTION
@code{tr_exponent},
@code{tr_file_tty_messagesp}, 
@code{tr_float_can_branch_complex},
@code{tr_function_call_default}, 
@code{tr_numer},
@code{tr_optimize_max_loop}, 
@code{tr_semicompile},
@code{tr_state_vars}, 
@code{tr_warnings_get},
@code{tr_warn_bad_function_calls},
@code{tr_warn_fexpr}, 
@code{tr_warn_meval},
@code{tr_warn_mode},
@code{tr_warn_undeclared},
e @code{tr_warn_undefined_variable}.

@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} transrun
Valor por omiss@~ao: @code{true}

Quando @code{transrun} @'e @code{false} far@'a com que a vers@~ao
interpretada de todas as fun@value{cedilha}@~oes sejam executadas (desde que estejam ainda dispon@'{@dotless{i}}veis)
em lugar de vers@~ao traduzidas.

@end defvr

@c IN WHAT CONTEXT IS tr_array_as_ref: false APPROPRIATE ??? NOT SEEING THE USEFULNESS HERE.
@c ALSO, I GUESS WE SHOULD HAVE AN ITEM FOR translate_fast_arrays, ANOTHER CONFUSING FLAG ...
@defvr {Vari@'avel de op@value{cedilha}@~ao} tr_array_as_ref
Valor por omiss@~ao: @code{true}

Se @code{translate_fast_arrays} for @code{false}, refer@^encias a arrays no
C@'odigo Lisp emitidas por @code{translate_file} s@~ao afectadas por @code{tr_array_as_ref}.
Quando @code{tr_array_as_ref} @'e @code{true},
nomes de arrays s@~ao avaliados,
de outra forma nomes de arrays aparecem como s@'{@dotless{i}}mbolos literais no c@'odigo traduzido.

@code{tr_array_as_ref} n@~ao ter@~ao efeito se @code{translate_fast_arrays} for @code{true}.

@end defvr

@c WHY IS THIS FLAG NEEDED ??? UNDER WHAT CIRCUMSTANCES CAN TRANSLATION
@c OF A BOUND VARIABLE USED AS A FUNCTION GO WRONG ???
@defvr {Vari@'avel de op@value{cedilha}@~ao} tr_bound_function_applyp
Valor por omiss@~ao: @code{true}

Quando @code{tr_bound_function_applyp} for @code{true}, Maxima emite um alerta se uma associa@value{cedilha}@~ao
de vari@'avel (tal como um argumento de fun@value{cedilha}@~ao) @'e achada sendo usada como uma fun@value{cedilha}@~ao.
@code{tr_bound_function_applyp} n@~ao afecta o c@'odigo gerado em tais casos.

Por exemplo, uma express@~ao tal como @code{g (f, x) := f (x+1)} ir@'a disparar
a mensagem de alerta.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} tr_file_tty_messagesp
Valor por omiss@~ao: @code{false}

Quando @code{tr_file_tty_messagesp} @'e @code{true},
messagens geradas por @code{translate_file} durante a tradu@value{cedilha}@~ao de um ficheiro s@~ao mostradas
sobre o console e inseridas dentro do ficheiro UNLISP.  
Quando @code{false}, messagens sobre tradu@value{cedilha}@~oes de
ficheiros s@~ao somente inseridas dentro do ficheiro UNLISP.

@end defvr

@c THIS FLAG APPEARS TO HAVE NO EFFECT.  SHOULD CUT OUT THIS ITEM AND RELATED CODE.
@c NOTE THAT THERE IS CODE IN src/transf.lisp WHICH USES THIS FLAG BUT THE MODE
@c FLAG IS LOST SOMEWHERE ALONG THE WAY TO THE LISP OUTPUT FILE.
@defvr {Vari@'avel de op@value{cedilha}@~ao} tr_float_can_branch_complex
Valor por omiss@~ao: @code{true}

Diz ao tradutor Maxima-para-Lisp assumir que as fun@value{cedilha}@~oes 
@code{acos}, @code{asin}, @code{asec}, e @code{acsc} podem retornar resultados complexos.

O efeito ostensivo de @code{tr_float_can_branch_complex} @'e mostrado adiante.
Todavia, parece que esse sinalizador n@~ao tem efeito sobre a sa@'{@dotless{i}}da do tradutor.

Quando isso for @code{true} ent@~ao @code{acos(x)} ser@'a do modo @code{any}
sempre que @code{x} for do modo @code{float} (como escolhido por @code{mode_declare}).
Quando @code{false} ent@~ao @code{acos(x)} ser@'a do modo
@code{float} se e somente se @code{x} for do modo @code{float}.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} tr_function_call_default
Valor por omiss@~ao: @code{general}

@code{false} significa abandonando e
chamando @code{meval}, @code{expr} significa que Lisp assume fun@value{cedilha}@~ao de argumento fixado.  @code{general}, o
c@'odigo padr@~ao dado como sendo bom para @code{mexprs} e @code{mlexprs} mas n@~ao @code{macros}.
@code{general} garante que associa@value{cedilha}@~oes de vari@'avel s@~ao correctas em c@'odigos compilados.  No
modo @code{general}, quando traduzindo F(X), se F for uma vari@'avel associada, ent@~ao isso
assumir@'a que @code{apply (f, [x])} @'e significativo, e traduz como tal, com
o alerta apropriado.  N@~ao @'e necess@'ario desabilitar isso.  Com as
escolhas padr@~ao, sem mensagens de alerta implica compatibilidade total do
c@'odigo traduzido e compilado com o interpretador Maxima.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} tr_numer
Valor por omiss@~ao: @code{false}

Quando @code{tr_numer} for @code{true} propriedades @code{numer} s@~ao usadas para
@'atomos que possuem essa propriedade, e.g. @code{%pi}.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} tr_optimize_max_loop
Valor por omiss@~ao: 100

@code{tr_optimize_max_loop} @'e n@'umero m@'aximo de vezes do
passo de macro-expans@~ao e optimiza@value{cedilha}@~ao que o tradutor ir@'a executar
considerando uma forma.  Isso @'e para capturar erros de expans@~ao de macro, e
propriedades de optimiza@value{cedilha}@~ao n@~ao terminadas.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} tr_semicompile
Valor por omiss@~ao: @code{false}

Quando @code{tr_semicompile} for @code{true}, as formas de sa@'{@dotless{i}}da de @code{translate_file}
e @code{compfile} ser@~ao macroexpandidas mas n@~ao compiladas em c@'odigo
de m@'aquina pelo compilador Lisp.

@end defvr

@c ARE ANY OF THESE OBSOLETE ??
@defvr {Vari@'avel de sistema} tr_state_vars
Valor por omiss@~ao:
@example
[transcompile, tr_semicompile, tr_warn_undeclared, tr_warn_meval,
tr_warn_fexpr, tr_warn_mode, tr_warn_undefined_variable,
tr_function_call_default, tr_array_as_ref,tr_numer]
@end example

A lista de comutadores que afectam a forma de sa@'{@dotless{i}}da da
tradu@value{cedilha}@~ao.
@c DOES THE GENERAL USER REALLY CARE ABOUT DEBUGGING THE TRANSLATOR ???
Essa informa@value{cedilha}@~ao @'e @'util para sistemas populares quando
tentam depurar o tradutor.  Comparando o produto traduzido
para o qual pode ter sido produzido por um dado estado, isso @'e poss@'{@dotless{i}}vel para
rastrear erros.

@end defvr

@c tr_warnings_get EXISTS AND FUNCTIONS AS ADVERTISED (SORT OF) -- RETURNS *tr-runtime-warned*
@c WHICH HAS ONLY A FEW KINDS OF WARNINGS PUSHED ONTO IT; IT'S CERTAINLY NOT COMPREHENSIVE
@c DO WE REALLY NEED THIS SLIGHTLY WORKING FUNCTION ??
@deffn {Fun@value{cedilha}@~ao} tr_warnings_get ()
Imprime uma lista de alertas que podem ter sido dadas pelo
tradutor durante a tradu@value{cedilha}@~ao corrente.

@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} tr_warn_bad_function_calls
Valor por omiss@~ao: @code{true}

- Emite um alerta quando
chamadas de fun@value{cedilha}@~ao est@~ao sendo feitas por um caminho que pode n@~ao ser correcto devido
a declara@value{cedilha}@~oes impr@'oprias que foram feitas em tempo de tradu@value{cedilha}@~ao.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} tr_warn_fexpr
Valor por omiss@~ao: @code{compfile}

- Emite um alerta se quaisquer FEXPRs forem
encontradas.  FEXPRs n@~ao poder@~ao normalmente ser sa@'{@dotless{i}}da em c@'odigo traduzido,
todas as formas de programa especial leg@'{@dotless{i}}timo s@~ao traduzidas.

@end defvr

@defvr {Vari@'avel} tr_warn_meval
Valor por omiss@~ao: @code{compfile}

- Emite um alerta se a fun@value{cedilha}@~ao
@code{meval} recebe chamadas.  Se @code{meval} @'e chamada isso indica problemas na
tradu@value{cedilha}@~ao.

@end defvr

@defvr {Vari@'avel} tr_warn_mode
Valor por omiss@~ao: @code{all}

- Emite um alerta quando a vari@'aveis forem
atribu@'{@dotless{i}}dos valores inapropriados para seu modo.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} tr_warn_undeclared
Valor por omiss@~ao: @code{compile}

- Determina quando enviar
alertas sobre vari@'aveis n@~ao declaradas para o TTY.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} tr_warn_undefined_variable
Valor por omiss@~ao: @code{all}

- Emite um alerta quando
vari@'aveis globais indefinidas forem vistas.

@end defvr

@deffn {Fun@value{cedilha}@~ao} compile_file (@var{nomeficheiro})
@deffnx {Fun@value{cedilha}@~ao} compile_file (@var{nomeficheiro}, @var{nomeficheiro_compilado})
@deffnx {Fun@value{cedilha}@~ao} compile_file (@var{nomeficheiro}, @var{nomeficheiro_compilado}, @var{lisp_nomeficheiro})
Traduz o ficheiro Maxima @var{nomeficheiro} para Lisp,
executa o compilador Lisp,
e, se a tradu@value{cedilha}@~ao e a compila@value{cedilha}@~ao obtiverem sucesso, chama o c@'odigo compilado dentro do Maxima.

@code{compile_file} retorna uma lista dos nomes de quatro ficheiros:
o ficheiro original do Maxima, o nome da tradu@value{cedilha}@~ao Lisp, uma ficheiro de notas sobre a tradu@value{cedilha}@~ao, e o nome do ficheiro que cont@'em o c@'odigo compilado.
Se a compila@value{cedilha}@~ao falhar,
o quarto item @'e @code{false}.

Algumas declara@value{cedilha}@~oes e defini@value{cedilha}@~oes passam a ter efeito t@~ao logo
o c@'odigo Lisp seja compilado (sem que seja necess@'ario chamar o c@'odigo compilado).
Isso inclui fun@value{cedilha}@~oes definidas com o operador @code{:=},
macros definidas com o operador @code{::=}, @c HEDGE -- DON'T KNOW IF THERE IS ANOTHER WAY
@code{alias}, @code{declare},
@code{define_variable},  @code{mode_declare},
e 
@code{infix}, @code{matchfix},
@code{nofix}, @code{postfix}, @code{prefix},
e @code{compfile}.

Atribui@value{cedilha}@~oes e chamadas de fun@value{cedilha}@~ao n@~ao ser@~ao avaliadas at@'e que o c@'odigo compilado seja carregado.
Em particular, dentro do ficheiro Maxima,
atribui@value{cedilha}@~oes para sinalizadores traduzidos (@code{tr_numer}, etc.) n@~ao t@^em efeito sobre a tradu@value{cedilha}@~ao.

@c @code{compile_file} may mistake warnings for errors and
@c return @code{false} as the name of the compiled code when, in fact,
@c the compilation succeeded.  This @'e a bug.  
@c REPORTED AS SOURCEFORGE BUG # 1103722.

@var{nomeficheiro} pode n@~ao conter declara@value{cedilha}@~oes @code{:lisp}.

@code{compile_file} avalia seus argumentos.

@end deffn

@c NEEDS CLARIFICATION
@deffn {Fun@value{cedilha}@~ao} declare_translated (@var{f_1}, @var{f_2}, ...)
Quando traduzindo um ficheiro do c@'odigo Maxima
para Lisp, @'e importante para o programa tradutor saber quais fun@value{cedilha}@~oes
no ficheiro s@~ao para serem chamadas como fun@value{cedilha}@~oes traduzidas ou compiladas,
e quais outras s@~ao apenas fun@value{cedilha}@~oes Maxima ou indefinidas.  Colocando essa
declara@value{cedilha}@~ao no topo do ficheiro, faremos conhecido que embora um s@'{@dotless{i}}mbolo
diga que n@~ao temos ainda um valor de fun@value{cedilha}@~ao Lisp, teremos uma em
tempo de chamada.  @code{(MFUNCTION-CALL fn arg1 arg2 ...)} @'e gerado quando
o tradutor n~ao sabe que @code{fn} est@'a sendo compilada para ser uma fun@value{cedilha}@~ao Lisp.

@end deffn

