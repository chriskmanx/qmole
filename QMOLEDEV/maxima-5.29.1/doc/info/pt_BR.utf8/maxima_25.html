<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on Dezembro, 3 2012 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual do Maxima: 25. Matrizes e &Aacute;lgebra Linear</title>

<meta name="description" content="Manual do Maxima: 25. Matrizes e &Aacute;lgebra Linear">
<meta name="keywords" content="Manual do Maxima: 25. Matrizes e &Aacute;lgebra Linear">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body
{
    color: black;
    background: white; 
    margin-left: 8%;
    margin-right: 13%;
}

h1
{
    margin-left: +8%;
    font-size: 150%;
    font-family: sans-serif
}

h2
{
    font-size: 125%;
    font-family: sans-serif
}

h3
{
    font-size: 100%;
    font-family: sans-serif
}

h2,h3,h4,h5,h6 { margin-left: +4%; }

div.textbox
{
    border: solid;
    border-width: thin;
    /* width: 100%; */
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em
}

div.titlebox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
    background: rgb(200,255,255);
    font-family: sans-serif
}

div.synopsisbox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
     background: rgb(255,220,255);
    /*background: rgb(200,255,255); */
    /* font-family: fixed */
}

pre.example
{
    border: 1px solid gray;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 1em;
    padding-right: 1em;
    /* background: rgb(247,242,180); */ /* kind of sandy */
    /* background: rgb(200,255,255); */ /* sky blue */
    background-color: #F1F5F9; /* light blue-gray */
    /* font-family: "Lucida Console", monospace */
}

div.spacerbox
{
    border: none;
    padding-top: 2em;
    padding-bottom: 2em
}

div.image
{
    margin: 0;
    padding: 1em;
    text-align: center;
}

div.categorybox
{
    border: 1px solid gray;
    padding-top: 0px;
    padding-bottom: 0px;
    padding-left: 1em;
    padding-right: 1em;
    background: rgb(247,242,220);
}


-->
</style>

<link rel="icon" href="http://maxima.sourceforge.net/favicon.ico"/>
</head>

<body lang="pt" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Matrizes-e_00c1lgebra-Linear"></a>
<a name="SEC81"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_24.html#SEC80" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC82" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_24.html#SEC79" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC87" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 25. Matrizes e &Aacute;lgebra Linear </h1>

<p>/Matrices.texi/1.29/Sat Jun  2 00:12:57 2007/-ko/
</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC82">25.1 Introdu&ccedil;&atilde;o a Matrizes e &Aacute;lgebra Linear</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC86">25.2 Fun&ccedil;&otilde;es e Vari&aacute;veis Definidas para Matrizes e &Aacute;lgebra Linear</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
</table>

<hr size="6">
<a name="Introdu_00e7_00e3o-a-Matrizes-e_00c1lgebra-Linear"></a>
<a name="SEC82"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC81" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC83" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC81" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC81" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC87" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 25.1 Introdu&ccedil;&atilde;o a Matrizes e &Aacute;lgebra Linear </h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC83">25.1.1 Ponto</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                         
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC84">25.1.2 Vetores</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC85">25.1.3 auto</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Ponto"></a>
<a name="SEC83"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC82" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC84" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC81" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC82" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC87" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.1.1 Ponto </h3>
<p>O operador <code>.</code> representa multiplica&ccedil;&atilde;o n&atilde;o comutativa e produto escalar.
Quando os operandos s&atilde;o matrizes 1-coluna ou 1-linha <code>a</code> e <code>b</code>,
a expres&atilde;o <code>a.b</code> &eacute; equivalente a <code>sum (a[i]*b[i], i, 1, length(a))</code>.
Se <code>a</code> e <code>b</code> n&atilde;o s&atilde;o complexos, isso &eacute; o produto escalar,
tamb&eacute;m chamado produto interno ou produto do ponto, de <code>a</code> e <code>b</code>.
O produto escalar &eacute; definido como <code>conjugate(a).b</code> quando <code>a</code> e <code>b</code> s&atilde;o complexos;
<code>innerproduct</code> no pacote <code>eigen</code> fornece o produto escalar complexo.
</p>
<p>Quando os operandos s&atilde;o matrizes mais gerais,
o produto &eacute; a matriz produto <code>a</code> e <code>b</code>.
O n&uacute;mero de linhas de <code>b</code> deve ser igual ao n&uacute;mero de colunas de <code>a</code>,
e o resultado tem n&uacute;mero de linhas igual ao n&uacute;mero de linhas de <code>a</code>
e n&uacute;mero de colunas igual ao n&uacute;mero de colunas de <code>b</code>.
</p>
<p>Para disting&uuml;ir <code>.</code> como um operador aritm&eacute;tico do 
ponto decimal em um n&uacute;mero em ponto flutuante,
pode ser necess&aacute;rio deixar espa&ccedil;os em cada lado.
Por exemplo, <code>5.e3</code> &eacute; <code>5000.0</code> mas <code>5 . e3</code> &eacute; <code>5</code> vezes <code>e3</code>.
</p>
<p>Existem muitos sinalizadores que governam a simplifica&ccedil;&atilde;o de
expres&otilde;es envolvendo <code>.</code>, a saber
<code>dot</code>, <code>dot0nscsimp</code>, <code>dot0simp</code>, <code>dot1simp</code>, <code>dotassoc</code>, 
<code>dotconstrules</code>, <code>dotdistrib</code>, <code>dotexptsimp</code>, <code>dotident</code>,
e <code>dotscrules</code>.
</p>
<hr size="6">
<a name="Vetores"></a>
<a name="SEC84"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC83" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC85" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC81" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC82" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC87" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.1.2 Vetores </h3>
<p><code>vect</code> &eacute; um pacote de fun&ccedil;&otilde;es para an&aacute;lise vetorial.
<code>load (&quot;vect&quot;)</code> chama esse pacote, e <code>demo (&quot;vect&quot;)</code> permite visualizar uma demonstra&ccedil;&atilde;o.
</p>
<p>O pacote de an&aacute;lise vetorial pode combinar e simplificar expres&otilde;es
simb&oacute;licas incluindo produtos dos pontos e productos dos x, juntamente com
o gradiente, divergencia, tor&ccedil;&atilde;o, e operadores Laplacianos.  A 
distribui&ccedil;&atilde;o desses operadores sobre adi&ccedil;&otilde;es ou produtos &eacute; governada
por muitos sinalizadores, como s&atilde;o v&aacute;rias outras expans&otilde;es, incluindo expans&atilde;o
dentro de componentes em qualquer sistema de coordenadas ortogonais.
Existem tamb&eacute;m fun&ccedil;&otilde;es para derivar o escalar ou vetor potencial
de um campo.
</p>
<p>O pacote <code>vect</code> cont&eacute;m essas fun&ccedil;&otilde;es:
<code>vectorsimp</code>, <code>scalefactors</code>,
<code>express</code>, <code>potential</code>, e <code>vectorpotential</code>.
</p>
<p>Aten&ccedil;&atilde;o: o pacote <code>vect</code> declara o operador ponto <code>.</code>
como sendo um operador comutativo.
</p>
<hr size="6">
<a name="auto"></a>
<a name="SEC85"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC84" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC86" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC81" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC82" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC87" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.1.3 auto </h3>

<p>O pacote <code>eigen</code> cont&eacute;m muitas fun&ccedil;&otilde;es devotadas para a
computa&ccedil;&atilde;o simb&oacute;lica de autovalores e autovetores.
Maxima chama o pacote automaticamente se uma das fun&ccedil;&otilde;es
<code>eigenvalues</code> ou <code>eigenvectors</code> &eacute; invocada.
O pacote pode ser chamado explicitamente com <code>load (&quot;eigen&quot;)</code>.
</p>
<p><code>demo (&quot;eigen&quot;)</code> mostra uma demonstra&ccedil;&atilde;o das compatibilidades
desse pacote.
<code>batch (&quot;eigen&quot;)</code> executa a mesma demonstra&ccedil;&atilde;o,
mas sem lembretes de usu&aacute;rio entre sucessivas computa&ccedil;&otilde;es.
</p>
<p>As fun&ccedil;&otilde;es no pacote <code>eigen</code> s&atilde;o
<code>innerproduct</code>, <code>unitvector</code>, <code>columnvector</code>,
<code>gramschmidt</code>, <code>eigenvalues</code>, <code>eigenvectors</code>, <code>uniteigenvectors</code>,
e <code>similaritytransform</code>.
</p>
<hr size="6">
<a name="Fun_00e7_00f5es-e-Vari_00e1veis-Definidas-para-Matrizes-e_00c1lgebra-Linear"></a>
<a name="SEC86"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC85" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC87" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC81" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC81" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC87" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 25.2 Fun&ccedil;&otilde;es e Vari&aacute;veis Definidas para Matrizes e &Aacute;lgebra Linear </h2>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>addcol</b><i> (<var>M</var>, <var>list_1</var>, ..., <var>list_n</var>)</i>
<a name="IDX755"></a>
</dt>
<dd><p>Anexa a(s) coluna(s) dadas por uma
ou mais listas (ou matrizes) sobre a matriz <var>M</var>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>addrow</b><i> (<var>M</var>, <var>list_1</var>, ..., <var>list_n</var>)</i>
<a name="IDX756"></a>
</dt>
<dd><p>Anexa a(s) linha(s) dadas por uma ou
mais listas (ou matrizes) sobre a matriz <var>M</var>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>adjoint</b><i> (<var>M</var>)</i>
<a name="IDX757"></a>
</dt>
<dd><p>Retorna a matriz adjunta da matriz <var>M</var>.
A matriz adjunta &eacute; a transposta da matriz dos cofatores de <var>M</var>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>augcoefmatrix</b><i> ([<var>eqn_1</var>, ..., <var>eqn_m</var>], [<var>x_1</var>, ..., <var>x_n</var>])</i>
<a name="IDX758"></a>
</dt>
<dd><p>Retorna a matriz dos coeficientes
aumentada para as vari&aacute;veis <var>x_1</var>, ..., <var>x_n</var> do sistema de equa&ccedil;&otilde;es lineares
<var>eqn_1</var>, ..., <var>eqn_m</var>.  Essa &eacute; a matriz dos coeficientes com uma coluna anexada para
os termos independentes em cada equa&ccedil;&atilde;o (i.e., esses termos n&atilde;o dependem de
<var>x_1</var>, ..., <var>x_n</var>).
</p>
<pre class="example">(%i1) m: [2*x - (a - 1)*y = 5*b, c + b*y + a*x = 0]$
(%i2) augcoefmatrix (m, [x, y]);
                       [ 2  1 - a  - 5 b ]
(%o2)                  [                 ]
                       [ a    b      c   ]
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>charpoly</b><i> (<var>M</var>, <var>x</var>)</i>
<a name="IDX759"></a>
</dt>
<dd><p>Retorna um polin&ocirc;mio caracter&iacute;stico para a matriz <var>M</var>
em rela&ccedil;&atilde;o &agrave; vari&aacute;vel <var>x</var>.  Que &eacute;,
<code>determinant (<var>M</var> - diagmatrix (length (<var>M</var>), <var>x</var>))</code>.
</p>
<pre class="example">(%i1) a: matrix ([3, 1], [2, 4]);
                            [ 3  1 ]
(%o1)                       [      ]
                            [ 2  4 ]
(%i2) expand (charpoly (a, lambda));
                           2
(%o2)                lambda  - 7 lambda + 10
(%i3) (programmode: true, solve (%));
(%o3)               [lambda = 5, lambda = 2]
(%i4) matrix ([x1], [x2]);
                             [ x1 ]
(%o4)                        [    ]
                             [ x2 ]
(%i5) ev (a . % - lambda*%, %th(2)[1]);
                          [ x2 - 2 x1 ]
(%o5)                     [           ]
                          [ 2 x1 - x2 ]
(%i6) %[1, 1] = 0;
(%o6)                     x2 - 2 x1 = 0
(%i7) x2^2 + x1^2 = 1;
                            2     2
(%o7)                     x2  + x1  = 1
(%i8) solve ([%th(2), %], [x1, x2]);
                  1               2
(%o8) [[x1 = - -------, x2 = - -------], 
               sqrt(5)         sqrt(5)

                                             1             2
                                    [x1 = -------, x2 = -------]]
                                          sqrt(5)       sqrt(5)
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>coefmatrix</b><i> ([<var>eqn_1</var>, ..., <var>eqn_m</var>], [<var>x_1</var>, ..., <var>x_n</var>])</i>
<a name="IDX760"></a>
</dt>
<dd><p>Retorna a matriz dos coeficientes para as
vari&aacute;veis <var>x_1</var>, ..., <var>x_n</var> do sistema de equa&ccedil;&otilde;es lineares
<var>eqn_1</var>, ..., <var>eqn_m</var>.
</p>
<pre class="example">(%i1) coefmatrix([2*x-(a-1)*y+5*b = 0, b*y+a*x = 3], [x,y]);
                                 [ 2  1 - a ]
(%o1)                            [          ]
                                 [ a    b   ]
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>col</b><i> (<var>M</var>, <var>i</var>)</i>
<a name="IDX761"></a>
</dt>
<dd><p>Reorna a <var>i</var>'&eacute;sima coluna da matriz <var>M</var>.
O valor de retorno &eacute; uma matriz.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>columnvector</b><i> (<var>L</var>)</i>
<a name="IDX762"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>covect</b><i> (<var>L</var>)</i>
<a name="IDX763"></a>
</dt>
<dd><p>Retorna uma matriz de uma coluna e <code>length (<var>L</var>)</code> linhas,
contendo os elementos da lista <var>L</var>.
</p>
<p><code>covect</code> &eacute; um sin&ocirc;nimo para <code>columnvector</code>.
</p>
<p><code>load (&quot;eigen&quot;)</code> chama essa fun&ccedil;&atilde;o.
</p>
<p>Isso &eacute; &uacute;til se voc&ecirc; quer usar partes das sa&iacute;das das
fun&ccedil;&otilde;es nesse pacote em c&aacute;lculos matriciais.
</p>
<p>Exemplo:
</p>
<pre class="example">(%i1) load (&quot;eigen&quot;)$
Warning - you are redefining the Macsyma function autovalores
Warning - you are redefining the Macsyma function autovetores
(%i2) columnvector ([aa, bb, cc, dd]);
                             [ aa ]
                             [    ]
                             [ bb ]
(%o2)                        [    ]
                             [ cc ]
                             [    ]
                             [ dd ]
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>conjugate</b><i> (<var>x</var>)</i>
<a name="IDX764"></a>
</dt>
<dd><p>Retorna o conjugado complexo de <var>x</var>.
</p>
<pre class="example">(%i1) declare ([aa, bb], real, cc, complex, ii, imaginary);

(%o1)                         done
(%i2) conjugate (aa + bb*%i);

(%o2)                      aa - %i bb
(%i3) conjugate (cc);

(%o3)                     conjugate(cc)
(%i4) conjugate (ii);

(%o4)                         - ii
(%i5) conjugate (xx + yy);

(%o5)             conjugate(yy) + conjugate(xx)
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>copymatrix</b><i> (<var>M</var>)</i>
<a name="IDX765"></a>
</dt>
<dd><p>Retorna uma c&oacute;pia da matriz <var>M</var>.  Esse &eacute; o &uacute;nico
para fazer uma copia separada copiando <var>M</var> elemento a elemento.
</p>
<p>Note que uma atribui&ccedil;&atilde;o de uma matriz para outra, como em <code>m2: m1</code>,
n&atilde;o copia <code>m1</code>.
Uma atribui&ccedil;&atilde;o <code>m2 [i,j]: x</code> ou <code>setelmx (x, i, j, m2</code> tamb&eacute;m modifica <code>m1 [i,j]</code>.
criando uma c&oacute;pia com <code>copymatrix</code> e ent&atilde;o usando atribu&ccedil;&atilde;o cria uma separada e modificada c&oacute;pia.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>determinant</b><i> (<var>M</var>)</i>
<a name="IDX766"></a>
</dt>
<dd><p>Calcula o determinante de <var>M</var> por um m&eacute;todo similar &agrave;
elimina&ccedil;&atilde;o de Gauss.
</p>
<p>A forma do resultado depende da escolha
do comutador <code>ratmx</code>.
</p>
<p>Existe uma rotina especial para calcular
determinantes esparsos que &eacute; chamada quando os comutadores
<code>ratmx</code> e <code>sparse</code> s&atilde;o ambos <code>true</code>.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>detout</b>
<a name="IDX767"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>
</p>
<p>Quando <code>detout</code> &eacute; <code>true</code>, o determinante de uma
matriz cuja inversa &eacute; calculada &eacute; fatorado fora da inversa.
</p>
<p>Para esse comutador ter efeito <code>doallmxops</code> e <code>doscmxops</code> deveram ambos serem
<code>false</code> (veja suas transcri&ccedil;&otilde;es).  Alternativamente esses comutadores podem ser
dados para <code>ev</code> o que faz com que os outros dois sejam escolhidos corretamente.
</p>
<p>Exemplo:
</p>
<pre class="example">(%i1) m: matrix ([a, b], [c, d]);
                            [ a  b ]
(%o1)                       [      ]
                            [ c  d ]
(%i2) detout: true$
(%i3) doallmxops: false$
(%i4) doscmxops: false$
(%i5) invert (m);
                          [  d   - b ]
                          [          ]
                          [ - c   a  ]
(%o5)                     ------------
                           a d - b c
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>diagmatrix</b><i> (<var>n</var>, <var>x</var>)</i>
<a name="IDX768"></a>
</dt>
<dd><p>Retorna uma matriz diagonal de tamanho <var>n</var> por <var>n</var> com os
elementos da diagonal todos iguais a <var>x</var>.
<code>diagmatrix (<var>n</var>, 1)</code> retorna uma matriz identidade (o mesmo que <code>ident (<var>n</var>)</code>).
</p>
<p><var>n</var> deve avaliar para um inteiro, de outra forma <code>diagmatrix</code> reclama com uma mensagem de erro.
</p>
<p><var>x</var> pode ser qualquer tipo de expres&atilde;o, incluindo outra matriz.
Se <var>x</var> &eacute; uma matriz, isso n&atilde;o &eacute; copiado; todos os elementos da diagonal referem-se &agrave; mesma inst&acirc;ncia, <var>x</var>.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>doallmxops</b>
<a name="IDX769"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>doallmxops</code> &eacute; <code>true</code>,
todas as opera&ccedil;&otilde;es relacionadas a matrizes s&atilde;o realizadas.
Quando isso &eacute; <code>false</code> ent&atilde;o a escolha de
comutadores individuais <code>dot</code> governam quais opera&ccedil;&otilde;es s&atilde;o executadas.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>domxexpt</b>
<a name="IDX770"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>domxexpt</code> &eacute; <code>true</code>,
uma matriz exponencial, <code>exp (<var>M</var>)</code> onde <var>M</var> &eacute; a matriz,
&eacute; interpretada como uma matriz com elementos <code>[i,j</code> iguais a <code>exp (m[i,j])</code>.
de outra forma <code>exp (<var>M</var>)</code> avalia para <code>exp (<var>ev(M)</var></code>.
</p>
<p><code>domxexpt</code>
afeta todas as expres&otilde;es da forma <code><var>base</var>^<var>expoente</var></code> onde <var>base</var> &eacute; uma
expres&atilde;o assumida escalar ou constante, e <var>expoente</var> &eacute; uma lista ou
matriz.
</p>
<p>Exemplo:
</p>
<pre class="example">(%i1) m: matrix ([1, %i], [a+b, %pi]);
                         [   1    %i  ]
(%o1)                    [            ]
                         [ b + a  %pi ]
(%i2) domxexpt: false$
(%i3) (1 - c)^m;
                             [   1    %i  ]
                             [            ]
                             [ b + a  %pi ]
(%o3)                 (1 - c)
(%i4) domxexpt: true$
(%i5) (1 - c)^m;
                  [                      %i  ]
                  [    1 - c      (1 - c)    ]
(%o5)             [                          ]
                  [        b + a         %pi ]
                  [ (1 - c)       (1 - c)    ]
</pre>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>domxmxops</b>
<a name="IDX771"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>domxmxops</code> &eacute; <code>true</code>, todas as opera&ccedil;&otilde;es matriz-matriz ou
matriz-lista s&atilde;o realizadas (mas n&atilde;o opera&ccedil;&otilde;es
escalar-matriz); se esse comutador &eacute; <code>false</code> tais opera&ccedil;&otilde;es n&atilde;o s&atilde;o.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>domxnctimes</b>
<a name="IDX772"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>
</p>
<p>Quando <code>domxnctimes</code> &eacute; <code>true</code>, produtos n&atilde;o comutativos de
matrizes s&atilde;o realizados.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>dontfactor</b>
<a name="IDX773"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>[]</code>
</p>
<p><code>dontfactor</code> pode ser escolhido para uma lista de vari&aacute;veis em rela&ccedil;&atilde;o
a qual fatora&ccedil;&atilde;o n&atilde;o &eacute; para ocorrer.  (A lista &eacute; inicialmente vazia.)
Fatora&ccedil;&atilde;o tamb&eacute;m n&atilde;o pegar&aacute; lugares com rela&ccedil;&atilde;o a quaisquer vari&aacute;veis que
s&atilde;o menos importantes, conforme a hierarqu&iacute;a de vari&aacute;vel assumida para a forma expres&atilde;o racional can&ocirc;nica (CRE),
que essas na lista <code>dontfactor</code>.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>doscmxops</b>
<a name="IDX774"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>
</p>
<p>Quando <code>doscmxops</code> &eacute; <code>true</code>, opera&ccedil;&otilde;es escalar-matriz s&atilde;o
realizadas.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>doscmxplus</b>
<a name="IDX775"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>
</p>
<p>Quando <code>doscmxplus</code> &eacute; <code>true</code>, opera&ccedil;&otilde;es escalar-matriz retornam
uma matriz resultado.  Esse comutador n&atilde;o &eacute; subsomado sob <code>doallmxops</code>.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>dot0nscsimp</b>
<a name="IDX776"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>dot0nscsimp</code> &eacute; <code>true</code>, um produto n&atilde;o comutativo de zero
e um termo n&atilde;o escalar &eacute; simplificado para um produto comutativo.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>dot0simp</b>
<a name="IDX777"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>dot0simp</code> &eacute; <code>true</code>,
um produto n&atilde;o comutativo de zero e
um termo escalar &eacute; simplificado para um produto n&atilde;o comutativo.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>dot1simp</b>
<a name="IDX778"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>dot1simp</code> &eacute; <code>true</code>,
um produto n&atilde;o comutativo de um e
outro termo &eacute; simplificado para um produto comutativo.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>dotassoc</b>
<a name="IDX779"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>dotassoc</code> &eacute; <code>true</code>, uma expres&atilde;o <code>(A.B).C</code> simplifica para
<code>A.(B.C)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>dotconstrules</b>
<a name="IDX780"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>dotconstrules</code> &eacute; <code>true</code>, um produto n&atilde;o comutativo de uma
constante e outro termo &eacute; simplificado para um produto comutativo.
Ativando esse sinalizador efetivamente ativamos <code>dot0simp</code>, <code>dot0nscsimp</code>, e
<code>dot1simp</code> tamb&eacute;m.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>dotdistrib</b>
<a name="IDX781"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>
</p>
<p>Quando <code>dotdistrib</code> &eacute; <code>true</code>, uma expres&atilde;o <code>A.(B + C)</code> simplifica para <code>A.B + A.C</code>.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>dotexptsimp</b>
<a name="IDX782"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>dotexptsimp</code> &eacute; <code>true</code>, uma expres&atilde;o <code>A.A</code> simplifica para <code>A^^2</code>.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>dotident</b>
<a name="IDX783"></a>
</dt>
<dd><p>Valor padr&atilde;o: 1
</p>
<p><code>dotident</code> &eacute; o valor retornado por <code>X^^0</code>.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>dotscrules</b>
<a name="IDX784"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>
</p>
<p>Quando <code>dotscrules</code> &eacute; <code>true</code>, uma expres&atilde;o <code>A.SC</code> ou <code>SC.A</code> simplifica
para <code>SC*A</code> e <code>A.(SC*B)</code> simplifica para <code>SC*(A.B)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>echelon</b><i> (<var>M</var>)</i>
<a name="IDX785"></a>
</dt>
<dd><p>Retorna a forma escalonada da matriz <var>M</var>,
como produzido atrav&eacute;s da elimina&ccedil;&atilde;o de Gauss.
A forma escalonada &eacute; calculada de <var>M</var>
por opera&ccedil;&otilde;es elementares de linha tais que o primeiro
elemento n&atilde;o zero em cada linha na matriz resultante seja o n&uacute;mero um e os
elementos da coluna abaixo do primeiro n&uacute;mero um em cada linha sejam todos zero.
</p>
<p><code>triangularize</code> tamb&eacute;m realiza elimina&ccedil;&atilde;o de Gaussian,
mas n&atilde;o normaliza o elemento l&iacute;der n&atilde;o nulo em cada linha.
</p>
<p><code>lu_factor</code> e <code>cholesky</code> s&atilde;o outras fun&ccedil;&otilde;es que retornam matrizes triangularizadas.
</p>
<pre class="example">(%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                       [  3   7  aa  bb ]
                       [                ]
(%o1)                  [ - 1  8  5   2  ]
                       [                ]
                       [  9   2  11  4  ]
(%i2) echelon (M);
                  [ 1  - 8  - 5      - 2     ]
                  [                          ]
                  [         28       11      ]
                  [ 0   1   --       --      ]
(%o2)             [         37       37      ]
                  [                          ]
                  [              37 bb - 119 ]
                  [ 0   0    1   ----------- ]
                  [              37 aa - 313 ]
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>eigenvalues</b><i> (<var>M</var>)</i>
<a name="IDX786"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>eivals</b><i> (<var>M</var>)</i>
<a name="IDX787"></a>
</dt>
<dd><p>Retorna uma lista de duas listas contendo os autovalores da matriz <var>M</var>.
A primeira sublista do valor de retorno &eacute; a lista de autovalores da
matriz, e a segunda sublista &eacute; a lista de
multiplicidade dos autovalores na ordem correspondente.
</p>
<p><code>eivals</code> &eacute; um sin&ocirc;nimo de <code>eigenvalues</code>.
</p>
<p><code>eigenvalues</code> chama a fun&ccedil;&atilde;o <code>solve</code> para achar as ra&iacute;zes do
polin&ocirc;mio caracter&iacute;stico da matriz.
Algumas vezes <code>solve</code> pode n&atilde;o estar habilitado a achar as ra&iacute;zes do polin&ocirc;mio;
nesse caso algumas outras fun&ccedil;&otilde;es nesse
pacote (except <code>innerproduct</code>, <code>unitvector</code>, <code>columnvector</code> e
<code>gramschmidt</code>) n&atilde;o ir&atilde;o trabalhar.
</p>
<p>Em alguns casos os autovalores achados por <code>solve</code> podem ser expres&otilde;es complicadas.
(Isso pode acontecer quando <code>solve</code> retorna uma expres&atilde;o real n&atilde;o trivial
para um autovalor que &eacute; sabidamente real.)
Isso pode ser poss&iacute;vel para simplificar os autovalores usando algumas outras fun&ccedil;&otilde;es.
</p>
<p>O pacote <code>eigen.mac</code> &eacute; chamado automaticamente quando
<code>eigenvalues</code> ou <code>eigenvectors</code> &eacute; referenciado.
Se <code>eigen.mac</code> n&atilde;o tiver sido ainda chamado,
<code>load (&quot;eigen&quot;)</code> chama-o.
Ap&oacute;s ser chamado, todas as fun&ccedil;&otilde;es e vari&aacute;veis no pacote estar&atilde;o dispon&iacute;veis.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>eigenvectors</b><i> (<var>M</var>)</i>
<a name="IDX788"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>eivects</b><i> (<var>M</var>)</i>
<a name="IDX789"></a>
</dt>
<dd><p>pegam uma matriz <var>M</var> como seu argumento e retorna uma lista
de listas cuja primeira sublista &eacute; a sa&iacute;da de <code>eigenvalues</code>
e as outras sublistas s&atilde;o os autovetores da
matriz correspondente para esses autovalores respectivamente.
</p>
<p><code>eivects</code> &eacute; um sin&ocirc;nimo para <code>eigenvectors</code>.
</p>
<p>O pacote <code>eigen.mac</code> &eacute; chamado automaticamente quando
<code>eigenvalues</code> ou <code>eigenvectors</code> &eacute; referenciado.
Se <code>eigen.mac</code> n&atilde;o tiver sido ainda chamado,
<code>load (&quot;eigen&quot;)</code> chama-o.
Ap&oacute;s ser chamado, todas as fun&ccedil;&otilde;es e vari&aacute;veis no pacote estar&atilde;o dispon&iacute;veis.
</p>
<p>Os sinalizadores que afetam essa fun&ccedil;&atilde;o s&atilde;o:
</p>
<p><code>nondiagonalizable</code> &eacute; escolhido para <code>true</code> ou <code>false</code> dependendo de
se a matriz &eacute; n&atilde;o diagonaliz&aacute;vel ou diagonaliz&aacute;vel ap&oacute;s o
retorno de <code>eigenvectors</code>.
</p>
<p><code>hermitianmatrix</code> quando <code>true</code>, faz com que os autovetores
degenerados da matriz Hermitiana sejam ortogonalizados usando o
algor&iacute;tmo de Gram-Schmidt.
</p>
<p><code>knowneigvals</code> quando <code>true</code> faz com que o pacote <code>eigen</code> assumir que os
autovalores da matriz s&atilde;o conhecidos para o usu&aacute;rio e armazenados sob o
nome global <code>listeigvals</code>.  <code>listeigvals</code> poder&aacute; ser escolhido para uma lista similar
&agrave; sa&iacute;da de <code>eigenvalues</code>.
</p>
<p>A fun&ccedil;&atilde;o <code>algsys</code> &eacute; usada aqui para resolver em rela&ccedil;&atilde;o aos autovetores.  Algumas vezes se os
autovalores est&atilde;o aus&ecirc;ntes, <code>algsys</code> pode n&atilde;o estar habilitado a achar uma solu&ccedil;&atilde;o.
Em alguns casos, isso pode ser poss&iacute;vel para simplificar os autovalores por
primeiro achando e ent&atilde;o usando o comando <code>eigenvalues</code> e ent&atilde;o usando outras fun&ccedil;&otilde;es
para reduzir os autovalores a alguma coisa mais simples.
Continuando a simplifica&ccedil;&atilde;o, <code>eigenvectors</code> pode ser chamada novamente
com o sinalizador <code>knowneigvals</code> escolhido para <code>true</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ematrix</b><i> (<var>m</var>, <var>n</var>, <var>x</var>, <var>i</var>, <var>j</var>)</i>
<a name="IDX790"></a>
</dt>
<dd><p>Retorna uma matriz <var>m</var> por <var>n</var>, todos os elementos da qual
s&atilde;o zero exceto para o elemento <code>[<var>i</var>, <var>j</var>]</code> que &eacute; <var>x</var>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>entermatrix</b><i> (<var>m</var>, <var>n</var>)</i>
<a name="IDX791"></a>
</dt>
<dd><p>Retorna uma matriz <var>m</var> por <var>n</var>, lendo os elementos interativamente.
</p>
<p>Se <var>n</var> &eacute; igual a <var>m</var>,
Maxima pergunta pelo tipo de matriz (diagonal, sim&eacute;trica, antisim&eacute;trica, ou gen&eacute;rica)
e por cada elemento.
Cada resposta &eacute; terminada por um ponto e v&iacute;rgula <code>;</code> ou sinal de d&oacute;lar <code>$</code>.
</p>
<p>Se <var>n</var> n&atilde;o &eacute; igual a <var>m</var>,
Maxima pergunta por cada elemento.
</p>
<p>Os elementos podem ser quaisquer express&otilde;es, que s&atilde;o avaliadas.
<code>entermatrix</code> avalia seus argumentos.
</p>
<pre class="example">(%i1) n: 3$
(%i2) m: entermatrix (n, n)$

Is the matriz  1.  Diagonal  2.  Symmetric  3.  Antisymmetric  4.  General
Answer 1, 2, 3 or 4 : 
1$
Row 1 Column 1: 
(a+b)^n$
Row 2 Column 2: 
(a+b)^(n+1)$
Row 3 Column 3: 
(a+b)^(n+2)$

Matriz entered.
(%i3) m;
                [        3                     ]
                [ (b + a)      0         0     ]
                [                              ]
(%o3)           [                  4           ]
                [    0      (b + a)      0     ]
                [                              ]
                [                            5 ]
                [    0         0      (b + a)  ]
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>genmatrix</b><i> (<var>a</var>, <var>i_2</var>, <var>j_2</var>, <var>i_1</var>, <var>j_1</var>)</i>
<a name="IDX792"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>genmatrix</b><i> (<var>a</var>, <var>i_2</var>, <var>j_2</var>, <var>i_1</var>)</i>
<a name="IDX793"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>genmatrix</b><i> (<var>a</var>, <var>i_2</var>, <var>j_2</var>)</i>
<a name="IDX794"></a>
</dt>
<dd><p>Retorna uma matriz gerada de <var>a</var>,
pegando o elemento <code><var>a</var>[<var>i_1</var>,<var>j_1</var>]</code>
como o elemento do canto superior esquerdo e <code><var>a</var>[<var>i_2</var>,<var>j_2</var>]</code>
como o elemento do canto inferior direto da matriz.
Aqui <var>a</var> &eacute; um array declarado (criado atrav&eacute;s de <code>array</code> mas n&atilde;o por meio de <code>make_array</code>)
ou um array n&atilde;o declarado,
ou uma fun&ccedil;&atilde;o array,
ou uma express&atilde;o lambda de dois argumentos.
(Uma fun&ccedil;&atilde;O array &eacute; criado como outras fun&ccedil;&otilde;es com <code>:=</code> ou <code>define</code>,
mas os argumentos s&atilde;o colocados entre colch&ecirc;tes em lugar de par&ecirc;ntesis.)
</p>
<p>Se <var>j_1</var> &eacute; omitido, isso &eacute; assumido ser igual a <var>i_1</var>.
Se ambos <var>j_1</var> e <var>i_1</var> s&atilde;o omitidos, ambos s&atilde;o assumidos iguais a 1.
</p>
<p>Se um elemento selecionado <code>i,j</code> de um array for indefinido,
a matriz conter&aacute; um elemento simb&oacute;lico <code><var>a</var>[i,j]</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) h [i, j] := 1 / (i + j - 1);
                                    1
(%o1)                  h     := ---------
                        i, j    i + j - 1
(%i2) genmatrix (h, 3, 3);
                           [    1  1 ]
                           [ 1  -  - ]
                           [    2  3 ]
                           [         ]
                           [ 1  1  1 ]
(%o2)                      [ -  -  - ]
                           [ 2  3  4 ]
                           [         ]
                           [ 1  1  1 ]
                           [ -  -  - ]
                           [ 3  4  5 ]
(%i3) array (a, fixnum, 2, 2);
(%o3)                           a
(%i4) a [1, 1] : %e;
(%o4)                          %e
(%i5) a [2, 2] : %pi;
(%o5)                          %pi
(%i6) genmatrix (a, 2, 2);
                           [ %e   0  ]
(%o6)                      [         ]
                           [ 0   %pi ]
(%i7) genmatrix (lambda ([i, j], j - i), 3, 3);
                         [  0    1   2 ]
                         [             ]
(%o7)                    [ - 1   0   1 ]
                         [             ]
                         [ - 2  - 1  0 ]
(%i8) genmatrix (B, 2, 2);
                        [ B      B     ]
                        [  1, 1   1, 2 ]
(%o8)                   [              ]
                        [ B      B     ]
                        [  2, 1   2, 2 ]
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>gramschmidt</b><i> (<var>x</var>)</i>
<a name="IDX795"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>gschmit</b><i> (<var>x</var>)</i>
<a name="IDX796"></a>
</dt>
<dd><p>Realiza o algor&iacute;tmo de ortonaliza&ccedil;&atilde;o de Gram-Schmidt sobre <var>x</var>,
seja ela uma matriz ou uma lista de listas.
<var>x</var> n&atilde;o &eacute; modificado por <code>gramschmidt</code>.
</p>
<p>Se <var>x</var> &eacute; uma matriz, o algor&iacute;tmo &eacute; aplicado para as linhas de <var>x</var>.
Se <var>x</var> &eacute; uma lista de listas, o algor&iacute;tmo &eacute; aplicado &agrave;s sublistas,
que devem ter igual n&uacute;meros de elementos.
Nos dois casos,
o valor de retorno &eacute; uma lista de listas, as sublistas das listas s&atilde;o ortogonais
e gera o mesmo spa&ccedil;o que <var>x</var>.
Se a dimens&atilde;o do conjunto gerador de <var>x</var> &eacute; menor que o n&uacute;mero de linhas ou sublistas,
algumas sublistas do valor de retorno s&atilde;o zero.
</p>
<p><code>factor</code> &eacute; chamada a cada est&aacute;gio do algor&iacute;tmo para simplificar resultados intermedi&aacute;rios.
Como uma conseq&uuml;&ecirc;ncia, o valor de retorno pode conter inteiros fatorados.
</p>
<p><code>gschmit</code> (nota ortogr&aacute;fica) &eacute; um sin&ocirc;nimo para <code>gramschmidt</code>.
</p>
<p><code>load (&quot;eigen&quot;)</code> chama essa fun&ccedil;&atilde;o.
</p>
<p>Exemplo:
</p>
<pre class="example">(%i1) load (&quot;eigen&quot;)$
Warning - you are redefining the Macsyma function autovalores
Warning - you are redefining the Macsyma function autovetores
(%i2) x: matrix ([1, 2, 3], [9, 18, 30], [12, 48, 60]);
                         [ 1   2   3  ]
                         [            ]
(%o2)                    [ 9   18  30 ]
                         [            ]
                         [ 12  48  60 ]
(%i3) y: gramschmidt (x);
                       2      2            4     3
                      3      3   3 5      2  3  2  3
(%o3)  [[1, 2, 3], [- ---, - --, ---], [- ----, ----, 0]]
                      2 7    7   2 7       5     5
(%i4) i: innerproduct$
(%i5) [i (y[1], y[2]), i (y[2], y[3]), i (y[3], y[1])];
(%o5)                       [0, 0, 0]
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ident</b><i> (<var>n</var>)</i>
<a name="IDX797"></a>
</dt>
<dd><p>Retorna uma matriz identidade <var>n</var> por <var>n</var>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>innerproduct</b><i> (<var>x</var>, <var>y</var>)</i>
<a name="IDX798"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>inprod</b><i> (<var>x</var>, <var>y</var>)</i>
<a name="IDX799"></a>
</dt>
<dd><p>Retorna o produto interno (tamb&eacute;m chamado produto escalar ou produto do ponto) de <var>x</var> e <var>y</var>,
que s&atilde;o listas de igual comprimento, ou ambas matrizes 1-coluna ou 1-linha de igual comprimento.
O valor de retorno &eacute; <code>conjugate (x) . y</code>,
onde <code>.</code> &eacute; o operador de multiplica&ccedil;&atilde;o n&atilde;o comutativa.
</p>
<p><code>load (&quot;eigen&quot;)</code> chama essa fun&ccedil;&atilde;o.
</p>
<p><code>inprod</code> &eacute; um sin&ocirc;nimo para <code>innerproduct</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>invert</b><i> (<var>M</var>)</i>
<a name="IDX800"></a>
</dt>
<dd><p>Retorna a inversa da matriz <var>M</var>.
A inversa &eacute; calculada pelo m&eacute;todo adjunto.
</p>
<p>Isso permite a um usu&aacute;rio calcular a inversa de uma matriz com
entradas bfloat ou polin&ocirc;mios com coeficientes em ponto flutuante sem
converter para a forma CRE.
</p>
<p>Cofatores s&atilde;o calculados pela fun&ccedil;&atilde;o  <code>determinant</code>,
ent&atilde;o se <code>ratmx</code> &eacute; <code>false</code> a inversa &eacute; calculada
sem mudar a representa&ccedil;&atilde;o dos elementos.
</p>
<p>A implementa&ccedil;&atilde;o
corrente &eacute; ineficiente para matrizes de alta ordem.
</p>
<p>Quando <code>detout</code> &eacute; <code>true</code>, o determinante &eacute; fatorado fora da
inversa.
</p>
<p>Os elementos da inversa n&atilde;o s&atilde;o automaticamente expandidos.
Se <var>M</var> tem elementos polinomiais, melhor apar&ecirc;ncia de sa&iacute;da pode ser
gerada por <code>expand (invert (m)), detout</code>.
Se isso &eacute; desej&aacute;vel para ela
divis&atilde;o at&eacute; pelo determinante pode ser excelente por <code>xthru (%)</code>
ou alternativamente na unha por
</p>
<pre class="example">expe (adjoint (m)) / expand (determinant (m))
invert (m) := adjoint (m) / determinant (m)
</pre>
<p>Veja <code>^^</code> (expoente n&atilde;o comutativo) para outro m&eacute;todo de inverter uma matriz.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>lmxchar</b>
<a name="IDX801"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>[</code>
</p>
<p><code>lmxchar</code> &eacute; o caractere mostrado como o delimitador
esquerdo de uma matriz.
Veja tamb&eacute;m <code>rmxchar</code>.
</p>
<p>Exemplo:
</p>
<pre class="example">(%i1) lmxchar: &quot;|&quot;$
(%i2) matrix ([a, b, c], [d, e, f], [g, h, i]);
                           | a  b  c ]
                           |         ]
(%o2)                      | d  e  f ]
                           |         ]
                           | g  h  i ]
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>matrix</b><i> (<var>row_1</var>, ..., <var>row_n</var>)</i>
<a name="IDX802"></a>
</dt>
<dd><p>Retorna uma matriz retangular que tem as linhas <var>row_1</var>, ..., <var>row_n</var>.
Cada linha &eacute; uma lista de express&otilde;es.
Todas as linhas devem ter o mesmo comprimento.
</p>
<p>As opera&ccedil;&otilde;es <code>+</code> (adi&ccedil;&atilde;o), <code>-</code> (subtra&ccedil;&atilde;o), <code>*</code> (multiplica&ccedil;&atilde;o),
e <code>/</code> (divis&atilde;o), s&atilde;o realizadas elemento por elemento
quando os operandos s&atilde;o duas matrizes, um escalar e uma matriz, ou uma matriz e um escalar.
A opera&ccedil;&atilde;o <code>^</code> (exponencia&ccedil;&atilde;o, equivalentemente <code>**</code>)
&eacute; realizada elemento por elemento
se os operandos s&atilde;o um escalar e uma matriz ou uma matriz e um escalar,
mas n&atilde;o se os operandos forem duas matrizes.
Todos as opera&ccedil;&otilde;es s&atilde;o normalmente realizadas de forma completa,
incluindo <code>.</code> (multiplica&ccedil;&atilde;o n&atilde;o comutativa).
</p>
<p>Multiplica&ccedil;&atilde;o de matrizes &eacute; representada pelo operador de multiplica&ccedil;&atilde;o n&atilde;o comutativa <code>.</code>.
O correspondente operador de exponencia&ccedil;&atilde;o n&atilde;o comutativa &eacute; <code>^^</code>.
Para uma matriz <code><var>A</var></code>, <code><var>A</var>.<var>A</var> = <var>A</var>^^2</code> e
<code><var>A</var>^^-1</code> &eacute; a inversa de <var>A</var>, se existir.
</p>
<p>Existem comutadores para controlar a simplifica&ccedil;&atilde;o de expres&otilde;es
envolvendo opera&ccedil;&otilde;es escalar e matriz-lista.
S&atilde;o eles
<code>doallmxops</code>, <code>domxexpt</code>
<code>domxmxops</code>, <code>doscmxops</code>, e <code>doscmxplus</code>.
</p>
<p>Existem op&ccedil;&otilde;es adicionais que s&atilde;o relacionadas a matrizes.  S&atilde;o elas:
<code>lmxchar</code>, <code>rmxchar</code>, <code>ratmx</code>, <code>listarith</code>, <code>detout</code>,
<code>scalarmatrix</code>,
e <code>sparse</code>.
</p>
<p>Existe um n&uacute;mero de
fun&ccedil;&otilde;es que pegam matrizes como argumentos ou devolvem matrizes como valor de retorno.
Veja <code>eigenvalues</code>, <code>eigenvectors</code>,
<code>determinant</code>,
<code>charpoly</code>, <code>genmatrix</code>, <code>addcol</code>, <code>addrow</code>, 
<code>copymatrix</code>, <code>transpose</code>, <code>echelon</code>,
e <code>rank</code>.
</p>
<p>Exemplos:
</p>
<ul>
<li>
Constru&ccedil;&atilde;o de matrizes de listas.
</li></ul>
<pre class="example">(%i1) x: matrix ([17, 3], [-8, 11]);
                           [ 17   3  ]
(%o1)                      [         ]
                           [ - 8  11 ]
(%i2) y: matrix ([%pi, %e], [a, b]);
                           [ %pi  %e ]
(%o2)                      [         ]
                           [  a   b  ]
</pre><ul>
<li>
Adi&ccedil;&atilde;o, elemento por elemento.
</li></ul>
<pre class="example">(%i3) x + y;
                      [ %pi + 17  %e + 3 ]
(%o3)                 [                  ]
                      [  a - 8    b + 11 ]
</pre><ul>
<li>
Subtra&ccedil;&atilde;o, elemento por elemento.
</li></ul>
<pre class="example">(%i4) x - y;
                      [ 17 - %pi  3 - %e ]
(%o4)                 [                  ]
                      [ - a - 8   11 - b ]
</pre><ul>
<li>
Multiplica&ccedil;&atilde;o, elemento por elemento.
</li></ul>
<pre class="example">(%i5) x * y;
                        [ 17 %pi  3 %e ]
(%o5)                   [              ]
                        [ - 8 a   11 b ]
</pre><ul>
<li>
Divis&atilde;o, elemento por elemento.
</li></ul>
<pre class="example">(%i6) x / y;
                        [ 17       - 1 ]
                        [ ---  3 %e    ]
                        [ %pi          ]
(%o6)                   [              ]
                        [   8    11    ]
                        [ - -    --    ]
                        [   a    b     ]
</pre><ul>
<li>
Matriz para um expoente escalar, elemento por elemento.
</li></ul>
<pre class="example">(%i7) x ^ 3;
                         [ 4913    27  ]
(%o7)                    [             ]
                         [ - 512  1331 ]
</pre><ul>
<li>
Base escalar para um expoente matriz, elemento por elemento.
</li></ul>
<pre class="example">(%i8) exp(y); 
                         [   %pi    %e ]
                         [ %e     %e   ]
(%o8)                    [             ]
                         [    a     b  ]
                         [  %e    %e   ]
</pre><ul>
<li>
Base matriz para um expoente matriz.  Essa n&atilde;o &eacute; realizada elemento por elemento.
</li></ul>
<pre class="example">(%i9) x ^ y;
                                [ %pi  %e ]
                                [         ]
                                [  a   b  ]
                     [ 17   3  ]
(%o9)                [         ]
                     [ - 8  11 ]
</pre><ul>
<li>
Multiplica&ccedil;&atilde;o n&atilde;o comutativa de matrizes.
</li></ul>
<pre class="example">(%i10) x . y;
                  [ 3 a + 17 %pi  3 b + 17 %e ]
(%o10)            [                           ]
                  [ 11 a - 8 %pi  11 b - 8 %e ]
(%i11) y . x;
                [ 17 %pi - 8 %e  3 %pi + 11 %e ]
(%o11)          [                              ]
                [  17 a - 8 b     11 b + 3 a   ]
</pre><ul>
<li>
Exponencia&ccedil;&atilde;o n&atilde;o comutativa de matrizes.
Uma base escalar <var>b</var> para uma pot&ecirc;ncia matriz <var>M</var>
&eacute; realizada elemento por elemento e ent&atilde;o <code>b^^m</code> &eacute; o mesmo que <code>b^m</code>.
</li></ul>
<pre class="example">(%i12) x ^^ 3;
                        [  3833   1719 ]
(%o12)                  [              ]
                        [ - 4584  395  ]
(%i13) %e ^^ y;
                         [   %pi    %e ]
                         [ %e     %e   ]
(%o13)                   [             ]
                         [    a     b  ]
                         [  %e    %e   ]
</pre><ul>
<li>
A matriz elevada a um expoente -1 com exponencia&ccedil;&atilde;o n&atilde;o comutativa &eacute; a matriz inversa,
se existir.
</li></ul>
<pre class="example">(%i14) x ^^ -1;
                         [ 11      3  ]
                         [ ---  - --- ]
                         [ 211    211 ]
(%o14)                   [            ]
                         [  8    17   ]
                         [ ---   ---  ]
                         [ 211   211  ]
(%i15) x . (x ^^ -1);
                            [ 1  0 ]
(%o15)                      [      ]
                            [ 0  1 ]
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>matrixmap</b><i> (<var>f</var>, <var>M</var>)</i>
<a name="IDX803"></a>
</dt>
<dd><p>Retorna uma matriz com elemento <code>i,j</code> igual a <code><var>f</var>(<var>M</var>[i,j])</code>.
</p>
<p>Veja tamb&eacute;m <code>map</code>, <code>fullmap</code>, <code>fullmapl</code>, e <code>apply</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>matrixp</b><i> (<var>expr</var>)</i>
<a name="IDX804"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>expr</var> &eacute; uma matriz, de outra forma retorna <code>false</code>.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>matrix_element_add</b>
<a name="IDX805"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>+</code>
</p>
<p><code>matrix_element_add</code> &eacute; a opera&ccedil;&atilde;o 
invocada em lugar da adi&ccedil;&atilde;o em uma multiplica&ccedil;&atilde;o de matrizes.
A <code>matrix_element_add</code> pode ser atribu&iacute;do qualquer operador n-&aacute;rio
(que &eacute;, uma fun&ccedil;&atilde;o que manuseia qualquer n&uacute;mero de argumentos).
Os valores atribu&iacute;dos podem ser o nome de um operador entre aspas duplas,
o nome da fun&ccedil;&atilde;o,
ou uma express&atilde;o lambda.
</p>
<p>Veja tamb&eacute;m <code>matrix_element_mult</code> e <code>matrix_element_transpose</code>.
</p>
<p>Exemplo:
</p>
<pre class="example">(%i1) matrix_element_add: &quot;*&quot;$
(%i2) matrix_element_mult: &quot;^&quot;$
(%i3) aa: matrix ([a, b, c], [d, e, f]);
                           [ a  b  c ]
(%o3)                      [         ]
                           [ d  e  f ]
(%i4) bb: matrix ([u, v, w], [x, y, z]);
                           [ u  v  w ]
(%o4)                      [         ]
                           [ x  y  z ]
(%i5) aa . transpose (bb);
                     [  u  v  w   x  y  z ]
                     [ a  b  c   a  b  c  ]
(%o5)                [                    ]
                     [  u  v  w   x  y  z ]
                     [ d  e  f   d  e  f  ]
</pre>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>matrix_element_mult</b>
<a name="IDX806"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>*</code>
</p>
<p><code>matrix_element_mult</code> &eacute; a opera&ccedil;&atilde;o
invocada em lugar da multiplica&ccedil;&atilde;o em uma multiplica&ccedil;&atilde;o de matrizes.
A <code>matrix_element_mult</code> pode ser atribu&iacute;do qualquer operador bin&aacute;rio.
O valor atribu&iacute;do pode ser o nome de um operador entre aspas duplas,
o nome de uma fun&ccedil;&atilde;o,
ou uma express&atilde;o lambda.
</p>
<p>O operador do ponto <code>.</code> &eacute; uma escolha &uacute;til em alguns contextos.
</p>
<p>Veja tamb&eacute;m <code>matrix_element_add</code> e <code>matrix_element_transpose</code>.
</p>
<p>Exemplo:
</p>
<pre class="example">(%i1) matrix_element_add: lambda ([[x]], sqrt (apply (&quot;+&quot;, x)))$
(%i2) matrix_element_mult: lambda ([x, y], (x - y)^2)$
(%i3) [a, b, c] . [x, y, z];
                          2          2          2
(%o3)         sqrt((c - z)  + (b - y)  + (a - x) )
(%i4) aa: matrix ([a, b, c], [d, e, f]);
                           [ a  b  c ]
(%o4)                      [         ]
                           [ d  e  f ]
(%i5) bb: matrix ([u, v, w], [x, y, z]);
                           [ u  v  w ]
(%o5)                      [         ]
                           [ x  y  z ]
(%i6) aa . transpose (bb);
               [             2          2          2  ]
               [ sqrt((c - w)  + (b - v)  + (a - u) ) ]
(%o6)  Col 1 = [                                      ]
               [             2          2          2  ]
               [ sqrt((f - w)  + (e - v)  + (d - u) ) ]

                         [             2          2          2  ]
                         [ sqrt((c - z)  + (b - y)  + (a - x) ) ]
                 Col 2 = [                                      ]
                         [             2          2          2  ]
                         [ sqrt((f - z)  + (e - y)  + (d - x) ) ]
</pre>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>matrix_element_transpose</b>
<a name="IDX807"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>
</p>
<p><code>matrix_element_transpose</code> &eacute; a opera&ccedil;&atilde;o
aplicada a cada elemento de uma matriz quando for uma transposta.
A <code>matrix_element_mult</code> pode ser atribu&iacute;do qualquer operador un&aacute;rio.
O valor atribu&iacute;do pode ser  nome de um operador entre aspas duplas,
o nome de uma fun&ccedil;&atilde;o,
ou uma express&atilde;o lambda.
</p>
<p>Quando <code>matrix_element_transpose</code> for igual a <code>transpose</code>,
a fun&ccedil;&atilde;o  <code>transpose</code> &eacute; aplicada a todo elemento.
Quando <code>matrix_element_transpose</code> for igual a <code>nonscalars</code>,
a fun&ccedil;&atilde;o <code>transpose</code> &eacute; aplicada a todo elemento n&atilde;o escalar.
Se algum elemento &eacute; um &aacute;tomo, a op&ccedil;&atilde;o <code>nonscalars</code> aplica
<code>transpose</code> somente se o &aacute;tomo for declarado n&atilde;o escalar,
enquanto a op&ccedil;&atilde;o <code>transpose</code> sempre aplica <code>transpose</code>.
</p>
<p>O valor padr&atilde;o, <code>false</code>, significa nenhuma opera&ccedil;&atilde;o &eacute; aplicada.
</p>
<p>Veja tamb&eacute;m <code>matrix_element_add</code> e <code>matrix_element_mult</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) declare (a, nonscalar)$
(%i2) transpose ([a, b]);
                        [ transpose(a) ]
(%o2)                   [              ]
                        [      b       ]
(%i3) matrix_element_transpose: nonscalars$
(%i4) transpose ([a, b]);
                        [ transpose(a) ]
(%o4)                   [              ]
                        [      b       ]
(%i5) matrix_element_transpose: transpose$
(%i6) transpose ([a, b]);
                        [ transpose(a) ]
(%o6)                   [              ]
                        [ transpose(b) ]
(%i7) matrix_element_transpose: lambda ([x], realpart(x) - %i*imagpart(x))$
(%i8) m: matrix ([1 + 5*%i, 3 - 2*%i], [7*%i, 11]);
                     [ 5 %i + 1  3 - 2 %i ]
(%o8)                [                    ]
                     [   7 %i       11    ]
(%i9) transpose (m);
                      [ 1 - 5 %i  - 7 %i ]
(%o9)                 [                  ]
                      [ 2 %i + 3    11   ]
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>mattrace</b><i> (<var>M</var>)</i>
<a name="IDX808"></a>
</dt>
<dd><p>Retorna o tra&ccedil;o (que &eacute;, a soma dos elementos sobre a diagonal principal) da
matriz quadrada <var>M</var>.  
</p>
<p><code>mattrace</code> &eacute; chamada por <code>ncharpoly</code>,
uma alternativa para <code>charpoly</code> do Maxima.
</p>
<p><code>load (&quot;nchrpl&quot;)</code> chama essa fun&ccedil;&atilde;o.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>minor</b><i> (<var>M</var>, <var>i</var>, <var>j</var>)</i>
<a name="IDX809"></a>
</dt>
<dd><p>Retorna o <var>i</var>, <var>j</var> menor do elemento localizado na linha <var>i</var> coluna <var>j</var> da matriz <var>M</var>.  Que &eacute; <var>M</var>
com linha <var>i</var> e coluna <var>j</var> ambas removidas.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ncexpt</b><i> (<var>a</var>, <var>b</var>)</i>
<a name="IDX810"></a>
</dt>
<dd><p>Se uma express&atilde;o exponencial n&atilde;o comutativa &eacute; muito
alta para ser mostrada como <code><var>a</var>^^<var>b</var></code> aparecer&aacute; como <code>ncexpt (<var>a</var>,<var>b</var>)</code>.
</p>
<p><code>ncexpt</code> n&atilde;o &eacute; o nome de uma fun&ccedil;&atilde;o ou operador;
o nome somente aparece em sa&iacute;das, e n&atilde;o &eacute; reconhecido em entradas.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ncharpoly</b><i> (<var>M</var>, <var>x</var>)</i>
<a name="IDX811"></a>
</dt>
<dd><p>Retorna o polin&ocirc;mio caracter&iacute;stico da matriz <var>M</var>
com rela&ccedil;&atilde;o a <var>x</var>.  Essa &eacute; uma alternativa para <code>charpoly</code> do Maxima.
</p>
<p><code>ncharpoly</code> trabalha pelo c&aacute;lculo dos tra&ccedil;os das pot&ecirc;ncias na dada matriz,
que s&atilde;o sabidos serem iguais a somas de pot&ecirc;ncias das ra&iacute;zes do
polin&ocirc;mio caracter&iacute;stico.  Para essas quantidade a fun&ccedil;&atilde;o
sim&eacute;trica das ra&iacute;zes pode ser calculada, que nada mais s&atilde;o que
os coeficientes do polin&ocirc;mio caracter&iacute;stico.  <code>charpoly</code> trabalha
formatando o determinante de <code><var>x</var> * ident [n] - a</code>.  Dessa forma <code>ncharpoly</code> &eacute; vencedor,
por exemplo, no caso de largas e densas matrizes preencidas com inteiros,
desde que isso evite inteiramente a aritm&eacute;tica polinomial.
</p>
<p><code>load (&quot;nchrpl&quot;)</code> loads this file.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>newdet</b><i> (<var>M</var>, <var>n</var>)</i>
<a name="IDX812"></a>
</dt>
<dd><p>Calcula o determinante de uma matriz ou array <var>M</var> pelo
algor&iacute;tmo da &aacute;rvore menor de Johnson-Gentleman.
O argumento <var>n</var> &eacute; a ordem; isso &eacute; opcional se <var>M</var> for uma matriz.
</p>
</dd></dl>

<dl>
<dt><u>Declara&ccedil;&atilde;o:</u> <b>nonscalar</b>
<a name="IDX813"></a>
</dt>
<dd><p>Faz &aacute;tomos ser comportarem da mesma forma que uma lista ou matriz em rela&ccedil;&atilde;o ao
operador do ponto.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>nonscalarp</b><i> (<var>expr</var>)</i>
<a name="IDX814"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>expr</var> &eacute; um n&atilde;o escalar, i.e., isso cont&eacute;m
&aacute;tomos declarados como n&atilde;o escalares, listas, ou matrizes.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>permanent</b><i> (<var>M</var>, <var>n</var>)</i>
<a name="IDX815"></a>
</dt>
<dd><p>Calcula o permanente da matriz <var>M</var>.  Um permanente
&eacute; como um determinante mas sem mudan&ccedil;a de sinal.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>rank</b><i> (<var>M</var>)</i>
<a name="IDX816"></a>
</dt>
<dd><p>Calcula o posto da matriz <var>M</var>.  Que &eacute;, a ordem do
mais largo determinante n&atilde;o singular de <var>M</var>.
</p>
<p><var>rank</var> pode retornar uma
resposta ruim se n&atilde;o puder determinar que um elemento da matriz que &eacute;
equivalente a zero &eacute; realmente isso.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>ratmx</b>
<a name="IDX817"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>
</p>
<p>Quando <code>ratmx</code> &eacute; <code>false</code>, adi&ccedil;&atilde;o, subtra&ccedil;&atilde;o,
e multiplica&ccedil;&atilde;o para determinantes e matrizes s&atilde;o executados na
representa&ccedil;&atilde;o dos elementos da matriz e fazem com que o resultado da
invers&atilde;o de matrizes seja esquerdo na representa&ccedil;&atilde;o geral.
</p>
<p>Quando <code>ratmx</code> &eacute; <code>true</code>,
as 4 opera&ccedil;&otilde;es mencionadas acima s&atilde;o executadas na forma CRE e o
resultado da matriz inversa &eacute; dado na forma CRE.  Note isso pode
fazer com que os elementos sejam expandidos (dependendo da escolha de <code>ratfac</code>)
o que pode n&atilde;o ser desejado sempre.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>row</b><i> (<var>M</var>, <var>i</var>)</i>
<a name="IDX818"></a>
</dt>
<dd><p>retorna a <var>i</var>'&eacute;sima linha da matriz <var>M</var>.
O valor de retorno &eacute; uma matriz.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>scalarmatrixp</b>
<a name="IDX819"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>scalarmatrixp</code> &eacute; <code>true</code>, ent&atilde;o sempre que uma matriz 1 x 1
&eacute; produzida como um resultado de c&aacute;lculos o produto do ponto de matrizes 
&eacute; simplificado para um escalar, a saber o elemento solit&aacute;rio da matriz.
</p>
<p>Quando <code>scalarmatrixp</code> &eacute; <code>all</code>,
ent&atilde;o todas as matrizes 1 x 1 ser&atilde;o simplificadas para escalares.
</p>
<p>Quando <code>scalarmatrixp</code> &eacute; <code>false</code>, matrizes 1 x 1 n&atilde;o s&atilde;o simplificadas para escalares.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>scalefactors</b><i> (<var>coordinatetransform</var>)</i>
<a name="IDX820"></a>
</dt>
<dd><p>Aqui coordinatetransform
avalia para a forma [[expres&atilde;o1, expres&atilde;o2, ...],
indetermina&ccedil;&atilde;o1, indetermina&ccedil;&atilde;o2, ...], onde indetermina&ccedil;&atilde;o1,
indetermina&ccedil;&atilde;o2, etc.  s&atilde;o as vari&aacute;veis de coordenadas curvil&iacute;neas e
onde a escolha de componentes cartesianas retangulares &eacute; dada em termos das
coordenadas curvil&iacute;neas por [expres&atilde;o1, expres&atilde;o2, ...].
<code>coordinates</code> &eacute; escolhida para o vetor [indetermina&ccedil;&atilde;o1, indetermina&ccedil;&atilde;o2,...],
e <code>dimension</code> &eacute; escolhida para o comprimento desse vetor.  SF[1], SF[2],
..., SF[DIMENSION] s&atilde;o escohidos para fatores de escala de coordenada, e <code>sfprod</code>
&eacute; escohido para o produto desse fatores de escala.  Inicialmente, <code>coordinates</code>
&eacute; [X, Y, Z], <code>dimension</code> &eacute; 3, e SF[1]=SF[2]=SF[3]=SFPROD=1,
correspondendo a coordenadas Cartesianas retangulares 3-dimensional.
Para expandir uma expres&atilde;o dentro de componentes f&iacute;sicos no sistema de coordenadas
corrente , existe uma fun&ccedil;&atilde;o com uso da forma
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>setelmx</b><i> (<var>x</var>, <var>i</var>, <var>j</var>, <var>M</var>)</i>
<a name="IDX821"></a>
</dt>
<dd><p>Atribue <var>x</var> para o (<var>i</var>, <var>j</var>)'&eacute;simo elemento da matriz <var>M</var>,
e retorna a matriz alterada.
</p>
<p><code><var>M</var> [<var>i</var>, <var>j</var>]: <var>x</var></code> tem o mesmo efeito,
mas retorna <var>x</var> em lugar de <var>M</var>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>similaritytransform</b><i> (<var>M</var>)</i>
<a name="IDX822"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>simtran</b><i> (<var>M</var>)</i>
<a name="IDX823"></a>
</dt>
<dd><p><code>similaritytransform</code> calcula uma transforma&ccedil;&atilde;o homot&eacute;tica da matriz <code>M</code>.
Isso retorna uma lista que &eacute; a sa&iacute;da do
comando <code>uniteigenvectors</code>.  Em adi&ccedil;&atilde;o se o sinalizador <code>nondiagonalizable</code>
&eacute; <code>false</code> duas matrizes globais <code>leftmatrix</code> e <code>rightmatrix</code> s&atilde;o calculadas.
Essas matrizes possuem a propriedade de
<code>leftmatrix . <var>M</var> . rightmatrix</code> &eacute; uma matriz diagonal com os autovalores
de <var>M</var> sobre a diagonal.  Se <code>nondiagonalizable</code> &eacute; <code>true</code> as matrizes esquerda e
direita n&atilde;o s&atilde;o computadas.
</p>
<p>Se o sinalizador <code>hermitianmatrix</code> &eacute; <code>true</code>
ent&atilde;o <code>leftmatrix</code> &eacute; o conjugado complexo da transposta de
<code>rightmatrix</code>.  De outra forma <code>leftmatrix</code> &eacute; a inversa de <code>rightmatrix</code>.
</p>
<p><code>rightmatrix</code> &eacute; a matriz cujas colunas s&atilde;o os autovetores
unit&aacute;rios de <var>M</var>.  Os outros sinalizadores (veja <code>eigenvalues</code> e
<code>eigenvectors</code>) possuem o mesmo efeito desde que
<code>similaritytransform</code> chama as outras fun&ccedil;&otilde;es no pacote com o objetivo de
estar habilitado para a forma <code>rightmatrix</code>.
</p>
<p><code>load (&quot;eigen&quot;)</code> chama essa fun&ccedil;&atilde;o.
</p>
<p><code>simtran</code> &eacute; um sin&ocirc;nimo para <code>similaritytransform</code>.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>sparse</b>
<a name="IDX824"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>
</p>
<p>Quando <code>sparse</code> &eacute; <code>true</code>, e se <code>ratmx</code> &eacute; <code>true</code>, ent&atilde;o <code>determinant</code>
usar&aacute; rotinas especiais para calcular determinantes esparsos.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>submatrix</b><i> (<var>i_1</var>, ..., <var>i_m</var>, <var>M</var>, <var>j_1</var>, ..., <var>j_n</var>)</i>
<a name="IDX825"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>submatrix</b><i> (<var>i_1</var>, ..., <var>i_m</var>, <var>M</var>)</i>
<a name="IDX826"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>submatrix</b><i> (<var>M</var>, <var>j_1</var>, ..., <var>j_n</var>)</i>
<a name="IDX827"></a>
</dt>
<dd><p>Retorna uma nova matriz formada pela
matrix <var>M</var> com linhas <var>i_1</var>, ..., <var>i_m</var> exclu&iacute;das, e colunas <var>j_1</var>, ..., <var>j_n</var> exclu&iacute;das.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>transpose</b><i> (<var>M</var>)</i>
<a name="IDX828"></a>
</dt>
<dd><p>Retorna a transposta de <var>M</var>.
</p>
<p>Se <var>M</var> &eacute; uma matriz, o valor de retorno &eacute; outra matriz <var>N</var>
tal que <code>N[i,j] = M[j,i]</code>.
</p>
<p>Se <var>M</var> for uma lista, o valor de retorno &eacute; uma matrix <var>N</var>
de <code>length (m)</code> linhas e 1 coluna, tal que <code>N[i,1] = M[i]</code>.
</p>
<p>De outra forma <var>M</var> &eacute; um s&iacute;mbolo,
e o valor de retorno &eacute; uma express&atilde;o substantiva <code>'transpose (<var>M</var>)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>triangularize</b><i> (<var>M</var>)</i>
<a name="IDX829"></a>
</dt>
<dd><p>Retorna a maior forma triangular da matriz <code>M</code>, como produzido atrav&eacute;s da elimina&ccedil;&atilde;o de Gauss.
O valor de retorno &eacute; o mesmo que <code>echelon</code>,
exceto que o o coeficiente lider n&atilde;o nulo em cada linha n&atilde;o &eacute; normalizado para 1.
</p>
<p><code>lu_factor</code> e <code>cholesky</code> s&atilde;o outras fun&ccedil;&otilde;es que retornam matrizes triangularizadas.
</p>
<pre class="example">(%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                       [  3   7  aa  bb ]
                       [                ]
(%o1)                  [ - 1  8  5   2  ]
                       [                ]
                       [  9   2  11  4  ]
(%i2) triangularize (M);
             [ - 1   8         5            2      ]
             [                                     ]
(%o2)        [  0   - 74     - 56         - 22     ]
             [                                     ]
             [  0    0    626 - 74 aa  238 - 74 bb ]
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>uniteigenvectors</b><i> (<var>M</var>)</i>
<a name="IDX830"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ueivects</b><i> (<var>M</var>)</i>
<a name="IDX831"></a>
</dt>
<dd><p>Calcula autovetores unit&aacute;rios da matriz <var>M</var>.
O valor de retorno &eacute; uma lista de listas, a primeiro sublista &eacute; a
sa&iacute;da do comando <code>eigenvalues</code>, e as outras sublistas s&atilde;o
os autovetores unit&aacute;rios da matriz correspondente a esses autovalores
respectivamente.
</p>
<p>Os sinalizadores mencionados na descri&ccedil;&atilde;o do
comando <code>eigenvectors</code> possuem o mesmo efeito aqui tamb&eacute;m.
</p>
<p>Quando <code>knowneigvects</code> &eacute; <code>true</code>, o pacote <code>eigen</code> assume
que os autovetores da matriz s&atilde;o conhecidos para o usu&aacute;rio s&atilde;o
armazenados sob o nome global <code>listeigvects</code>.  <code>listeigvects</code> pode ser ecolhido
para uma lista similar &agrave; sa&iacute;da do comando <code>eigenvectors</code>.
</p>
<p>Se <code>knowneigvects</code> &eacute; escolhido para <code>true</code> e a lista de autovetores &eacute; dada a
escolha do sinalizador <code>nondiagonalizable</code> pode n&atilde;o estar correta.  Se esse &eacute;
o caso por favor ecolha isso para o valor correto.  O autor assume que
o usu&aacute;rio sabe o que est&aacute; fazendo e que n&atilde;o tentar&aacute; diagonalizar uma
matriz cujos autovetores n&atilde;o geram o mesmo espa&ccedil;o vetorial de
dimens&atilde;o apropriada.
</p>
<p><code>load (&quot;eigen&quot;)</code> chama essa fun&ccedil;&atilde;o.
</p>
<p><code>ueivects</code> &eacute; um sin&ocirc;nimo para <code>uniteigenvectors</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>unitvector</b><i> (<var>x</var>)</i>
<a name="IDX832"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>uvect</b><i> (<var>x</var>)</i>
<a name="IDX833"></a>
</dt>
<dd><p>Retorna <em><var>x</var>/norm(<var>x</var>)</em>;
isso &eacute; um vetor unit&aacute;rio na mesma dire&ccedil;&atilde;o que <var>x</var>.
</p>
<p><code>load (&quot;eigen&quot;)</code> chama essa fun&ccedil;&atilde;o.
</p>
<p><code>uvect</code> &eacute; um sin&ocirc;nimo para <code>unitvector</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>vectorsimp</b><i> (<var>expr</var>)</i>
<a name="IDX834"></a>
</dt>
<dd><p>Aplica simplifica&ccedil;&otilde;es e expans&otilde;es conforme
os seguintes sinalizadores globais:
</p>
<p><code>expandall</code>, <code>expanddot</code>, <code>expanddotplus</code>, <code>expandcross</code>, <code>expandcrossplus</code>,
<code>expandcrosscross</code>, <code>expandgrad</code>, <code>expandgradplus</code>, <code>expandgradprod</code>,
<code>expanddiv</code>, <code>expanddivplus</code>, <code>expanddivprod</code>, <code>expandcurl</code>, <code>expandcurlplus</code>,
<code>expandcurlcurl</code>, <code>expandlaplacian</code>, <code>expandlaplacianplus</code>,
e <code>expandlaplacianprod</code>.
</p>
<p>Todos esses sinalizadores possuem valor padr&atilde;o <code>false</code>.  O sufixo <code>plus</code> refere-se a
utiliza&ccedil;&atilde;o aditivamente ou distribuitivamente.  O sufixo <code>prod</code> refere-se a
expans&atilde;o para um operando que &eacute; qualquer tipo de produto.
</p>
<dl compact="compact">
<dt> <code>expandcrosscross</code></dt>
<dd><p>Simplifica <em>p ~ (q ~ r)</em> para <em>(p . r)*q - (p . q)*r</em>.
</p></dd>
<dt> <code>expandcurlcurl</code></dt>
<dd><p>Simplifica <em>curl curl p</em> para <em>grad div p + div grad p</em>.
</p></dd>
<dt> <code>expandlaplaciantodivgrad</code></dt>
<dd><p>Simplifica <em>laplacian p</em> para <em>div grad p</em>.
</p></dd>
<dt> <code>expandcross</code></dt>
<dd><p>Habilita <code>expandcrossplus</code> e <code>expandcrosscross</code>.
</p></dd>
<dt> <code>expandplus</code></dt>
<dd><p>Habilita <code>expanddotplus</code>, <code>expandcrossplus</code>, <code>expandgradplus</code>,
<code>expanddivplus</code>, <code>expandcurlplus</code>, e <code>expandlaplacianplus</code>.
</p></dd>
<dt> <code>expandprod</code></dt>
<dd><p>Habilita <code>expandgradprod</code>, <code>expanddivprod</code>, e <code>expandlaplacianprod</code>.
</p></dd>
</dl>

<p>Esses sinalizadores foram todos declarados <code>evflag</code>.
</p>

</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>vect_cross</b>
<a name="IDX835"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>
</p>
<p>Quando <code>vect_cross</code> &eacute; <code>true</code>, isso permite DIFF(X~Y,T) trabalhar onde
~ &eacute; definido em SHARE;VECT (onde VECT_CROSS &eacute; escolhido para <code>true</code>, de qualqeur modo.)
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>zeromatrix</b><i> (<var>m</var>, <var>n</var>)</i>
<a name="IDX836"></a>
</dt>
<dd><p>Retorna um matriz <var>m</var> por <var>n</var>, com todos os elementos sendo zero.
</p>
</dd></dl>

<dl>
<dt><u>S&iacute;mbolo especial:</u> <b>[</b>
<a name="IDX837"></a>
</dt>
<dt><u>S&iacute;mbolo especial:</u> <b>]</b>
<a name="IDX838"></a>
</dt>
<dd><p><code>[</code> e <code>]</code> marcam o ome&ccedil;o e o fim, respectivamente, de uma lista.
</p>
<p><code>[</code> e <code>]</code> tamb&eacute;m envolvem os subscritos de
uma lista, array, array desordenado, ou fun&ccedil;&atilde;o array.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) x: [a, b, c];
(%o1)                       [a, b, c]
(%i2) x[3];
(%o2)                           c
(%i3) array (y, fixnum, 3);
(%o3)                           y
(%i4) y[2]: %pi;
(%o4)                          %pi
(%i5) y[2];
(%o5)                          %pi
(%i6) z['foo]: 'bar;
(%o6)                          bar
(%i7) z['foo];
(%o7)                          bar
(%i8) g[k] := 1/(k^2+1);
                                  1
(%o8)                     g  := ------
                           k     2
                                k  + 1
(%i9) g[10];
                                1
(%o9)                          ---
                               101
</pre>
</dd></dl>

<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC81" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC87" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Robert</em> on <em>Dezembro, 3 2012</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
