@c Language: Brazilian Portuguese, Encoding: iso-8859-1
@c /Function.texi/1.48/Sat Jun  2 00:12:46 2007/-ko/
@menu
* Introdu@value{cedilha}@~{a}o a Defini@value{cedilha}@~{a}o de Fun@value{cedilha}@~{a}o::  
* Fun@value{cedilha}@~{a}o::                    
* Macros::                      
* Fun@value{cedilha}@~{o}es e Vari@'{a}veis para Defini@value{cedilha}@~{a}o de Fun@value{cedilha}@~{a}o::  
@end menu

@node Introdu@value{cedilha}@~{a}o a Defini@value{cedilha}@~{a}o de Fun@value{cedilha}@~{a}o, Fun@value{cedilha}@~{a}o, Defini@value{cedilha}@~{a}o de Fun@value{cedilha}@~{a}o, Defini@value{cedilha}@~{a}o de Fun@value{cedilha}@~{a}o
@section Introdu@value{cedilha}@~{a}o a Defini@value{cedilha}@~{a}o de Fun@value{cedilha}@~{a}o

@node Fun@value{cedilha}@~{a}o, Macros, Introdu@value{cedilha}@~{a}o a Defini@value{cedilha}@~{a}o de Fun@value{cedilha}@~{a}o, Defini@value{cedilha}@~{a}o de Fun@value{cedilha}@~{a}o
@c NEEDS WORK, THIS TOPIC IS IMPORTANT
@c MENTION DYNAMIC SCOPE (VS LEXICAL SCOPE)
@section Fun@value{cedilha}@~{a}o
@subsection Ordinary functions

Para definir uma fun@value{cedilha}@~{a}o no Maxima voc@^{e} usa o operador @code{:=}.
E.g.

@example
f(x) := sin(x)
@end example

@noindent
define uma fun@value{cedilha}@~{a}o @code{f}.
Fun@value{cedilha}@~{o}es an@^{o}nimas podem tamb@'{e}m serem criadas usando @code{lambda}.
Por exemplo

@example
lambda ([i, j], ...)
@end example

@noindent
pode ser usada em lugar de @code{f}
onde

@example
f(i,j) := block ([], ...);
map (lambda ([i], i+1), l)
@end example

@noindent
retornar@'{a} uma lista com 1 adicionado a cada termo.

Voc@^{e} pode tamb@'{e}m definir uma fun@value{cedilha}@~{a}o com um n@'{u}mero vari@'{a}vel de argumentos,
teno um argumento final que @'{e} atribu@'{i}do para uma lista de argumentos
extras:

@example
(%i1) f ([u]) := u;
(%o1)                      f([u]) := u
(%i2) f (1, 2, 3, 4);
(%o2)                     [1, 2, 3, 4]
(%i3) f (a, b, [u]) := [a, b, u];
(%o3)               f(a, b, [u]) := [a, b, u]
(%i4) f (1, 2, 3, 4, 5, 6);
(%o4)                 [1, 2, [3, 4, 5, 6]]
@end example

O lado direito de uma fun@value{cedilha}@~{a}o @'{e} uma express@~{a}o.  Desse modo
Se voc@^{e} quer uma seq@"{u}@^{e}ncia de express@~{o}es, voc@^{e} faz

@example
f(x) := (expr1, expr2, ...., exprn);
@end example

e o valor de @var{exprn} @'{e} que @'{e} retornado pela fun@value{cedilha}@~{a}o.

Se voc@^{e} deseja fazer um @code{return} de alguma express@~{a}o dentro da
fun@value{cedilha}@~{a}o ent@~{a}o voc@^{e} deve usar @code{block} e @code{return}.

@example
block ([], expr1, ..., if (a > 10) then return(a), ..., exprn)
@end example

@'{e} em si mesma uma express@~{a}o, e ent@~{a}o poder@'{a} ocupar o lugar do
lado direito de uma defini@value{cedilha}@~{a}o de fun@value{cedilha}@~{a}o.  Aqui pode acontecer
que o retorno aconte@value{cedilha}a mais facilmente que no exemplo anterior a essa @'{u}ltima express@~{a}o.

@c COPY THIS STUFF TO @defun block AS NEEDED
@c ESPECIALLY STUFF ABOUT LOCAL VARIABLES
O primeiro @code{[]} no bloco, pode conter uma lista de vari@'{a}veis e
atribui@value{cedilha}@~{o}es de vari@'{a}veis, tais como @code{[a: 3, b, c: []]}, que far@~{a}o com que as
tr@^{e}s vari@'{a}veis @code{a},@code{b},e @code{c} n@~{a}o se refiram a seus
valores globais, mas ao contr@'{a}rio tenham esses valores especiais enquanto o
c@'{o}digo estiver executando a parte dentro do bloco @code{block}, ou dentro da fun@value{cedilha}@~{o}es chamadas de
dentro do bloco @code{block}.  Isso @'{e} chamado associa@value{cedilha}@~{a}o @i{dynamic}, uma vez que as
vari@'{a}veis permanecem do in@'{i}cio do bloco pelo tempo que ele existir.  Uma vez que
voc@^{e} retorna do @code{block}, ou descarta-o, os valores antigos (quaisquer que
sejam) das vari@'{a}veis ser@~{a}o restaurados.   @'{E} certamente uma boa id@'{e}ia
para proteger suas vari@'{a}veis nesse caminho.   Note que as atribui@value{cedilha}@~{o}es
em vari@'{a}veis do bloco, s@~{a}o conclu@'{i}das em paralelo.   Isso significa, que se
tiver usado @code{c: a} acima, o valor de @code{c} ser@'{a}
o valor de @code{a} a partir do momento em que voc@^{e}ntrou no bloco,
mas antes @code{a} foi associado.   Dessa forma fazendo alguma coisa como

@example
block ([a: a], expr1, ...  a: a+3, ..., exprn)
@end example

proteger@'{a} o valor externo de @code{a} de ser alterado, mas
impedir@'{a} voc@^{e} acessar o valor antigo.   Dessa forma o lado direito
de atribui@value{cedilha}@~{o}es, @'{e} avaliado no contexto inserido, antes que
qualquer avalia@value{cedilha}@~{a}o ocorra.
Usando apenas @code{block ([x], ...} faremos com que o @code{x} tenha a si mesmo
como valor, apenas como x teria se voc@^{e} tivesse entrado numa breve sess@~{a}o do
@b{Maxima}.

Os atuais argumentos para uma fun@value{cedilha}@~{a}o s@~{a}o tratados exatamente da mesma que
as vari@'{a}veis em um bloco.  Dessa forma em

@example
f(x) := (expr1, ..., exprn);
@end example

e

@example
f(1);
@end example

teremos um contexto similar para avalia@value{cedilha}@~{a}o de express@~{o}es
como se tiv@'{e}ssemos conclu@'{i}do

@example
block ([x: 1], expr1, ..., exprn)
@end example

Dentro de fun@value{cedilha}@~{o}es, quando o lado direito de uma defini@value{cedilha}@~{a}o,
pode ser calculado em tempo de execu@value{cedilha}@~{a}o, isso @'{e} @'{u}ti para usar @code{define} e
possivelmente @code{buildq}.  

@subsection Fun@value{cedilha}@~{a}o de Array

Uma fun@value{cedilha}@~{a}o de Array armazena o valor da fun@value{cedilha}@~{a}o na primeira vez que ela for chamada com um argumento dado,
e retorna o valor armazenado, sem recalcular esse valor, quando o mesmo argumento for fornecido.
De modo que uma fun@value{cedilha}@~{a}o @'{e} muitas vezes chamada uma @i{fun@value{cedilha}@~{a}o de memoriza@value{cedilha}@~{a}o}.

Nomes de fun@value{cedilha}@~{o}es de Array s@~{a}o anexados ao final da lista global @code{arrays}
(n@~{a}o na lista global @code{functions}).
O comando @code{arrayinfo} retorna a lista de argumentos para os quais exite valores armazenados,
e @code{listarray} retorna os valores armazenados. 
Os comandos @code{dispfun} e @code{fundef} retornam a defini@value{cedilha}@~{a}o da fun@value{cedilha}@~{a}o de array.

O comando @code{arraymake} contr@'{o}i uma chamada de fun@value{cedilha}@~{a}o de array,
an@'{a}logamente a @code{funmake} para fun@value{cedilha}@~{o}es comuns.
O comando @code{arrayapply} aplica uma fun@value{cedilha}@~{a}o de array a seus argmentos,
an@'{a}logamente a @code{apply} para fun@value{cedilha}@~{o}es comuns.
N@~{a}o existe nada exatamente an@'{a}logo a @code{map} para fun@value{cedilha}@~{o}es de array,
embora @code{map(lambda([@var{x}], @var{a}[@var{x}]), @var{L})} ou
@code{makelist(@var{a}[@var{x}], @var{x}, @var{L})}, onde @var{L} @'{e} uma lista,
n@~{a}o estejam t@~{a}o longe disso.

O comando @code{remarray} remove uma defini@value{cedilha}@~{a}o de fun@value{cedilha}@~{a}o de array (incluindo qualquer valor armazenado pela fun@value{cedilha}@~{a}o removida),
an@'{a}logo a @code{remfunction} para fun@value{cedilha}@~{o}es comuns.

o comando @code{kill(@var{a}[@var{x}])} remove o valor da fun@value{cedilha}@~{a}o de array @var{a}
armazenado para o argumento @var{x};
a pr@'{o}xima vez que @var{a} foor chamada com o argumento @var{x},
o valor da fun@value{cedilha}@~{a}o @'{e} recomputado.
Todavia, n@~{a}o exite caminho para remover todos os valores armazenados de uma vez,
exceto para @code{kill(@var{a})} ou @code{remarray(@var{a})},
o qual remove tamb@'{e}m remove a defini@value{cedilha}@~{a}o da fun@value{cedilha}@~{a}o de array.

@node Macros, Fun@value{cedilha}@~{o}es e Vari@'{a}veis para Defini@value{cedilha}@~{a}o de Fun@value{cedilha}@~{a}o, Fun@value{cedilha}@~{a}o, Defini@value{cedilha}@~{a}o de Fun@value{cedilha}@~{a}o
@section Macros

@deffn {Fun@value{cedilha}@~{a}o} buildq (@var{L}, @var{expr})
Substitue vari@'{a}veis nomeadas pela lista @var{L} dentro da express@~{a}o @var{expr},
paralelamente,
sem avaliar @var{expr}.
A express@~{a}o resultante @'{e} simplificada,
mas n@~{a}o avaliada,
ap@'{o}s @code{buildq} realizar a substitui@value{cedilha}@~{a}o.

Os elementos de @var{L} s@~{a}o s@'{i}mbolos ou express@~{o}es de atribui@value{cedilha}@~{a}o @code{@var{s@'{i}mbolo}: @var{valor}},
avaliadas paralelamente.
Isto @'{e}, a associa@value{cedilha}@~{a}o de uma vari@'{a}vel sobre o lado direito de uma atribui@value{cedilha}@~{a}o
@'{e} a associa@value{cedilha}@~{a}o daquela vari@'{a}vel no contexto do qual @code{buildq} for chamada,
n@~{a}o a associa@value{cedilha}@~{a}o daquela vari@'{a}vel na lista @var{L} de vari@'{a}veis.
Se alguma vari@'{a}vel em @var{L} n@~{a}o dada como uma atribui@value{cedilha}@~{a}o expl@'{i}cita,
sua associa@value{cedilha}@~{a}o em @code{buildq} @'{e} a mesma que no contexto no qual @code{buildq} for chamada.

Ent@~{a}o as vari@'{a}veis nomeadas em @var{L} s@~{a}o substituidas em @var{expr} paralelamente.
Isto @'{e}, a substitui@value{cedilha}@~{a}o para cada vari@'{a}vel @'{e} determinada antes que qualquer substitui@value{cedilha}@~{a}o seja feita,
ent@~{a}o a substitui@value{cedilha}@~{a}o para uma vari@'{a}vel n@~{a}o tem efeito sobre qualquer outra.

Se qualquer vari@'{a}vel @var{x} aparecer como @code{splice (@var{x})} em @var{expr},
ent@~{a}o @var{x} deve estar associada para uma lista,
e a lista recebe uma aplica@value{cedilha}@~{a}o da fun@value{cedilha}@~{a}o @code{splice} (@'{e} interpolada) na @var{expr} em lugar de substitu@'{i}da.

Quaisquer vari@'{a}veis em @var{expr} n@~{a}o aparecendo em @var{L} s@~{a}o levados no resultado tal como foram escritos,
mesmo se elas tiverem associa@value{cedilha}@~{o}es no contexto do qual @code{buildq} tiver sido chamada.

Exemplos

@code{a} @'{e} explicitamente associada a @code{x},
enquanto @code{b} tem a mesma associa@value{cedilha}@~{a}o (nomeadamente 29) como no contexto chamado,
e @code{c} @'{e} levada do come@value{cedilha}o ao fim da forma como foi escrita.
A express@~{a}o resultante n@~{a}o @'{e} avaliada at@'{e} a avalia@value{cedilha}@~{a}o expl@'{i}cita ( com duplo ap@'{o}strofo - n@~{a}o com aspas - @code{''%}.

@c ===beg===
@c (a: 17, b: 29, c: 1729)$
@c buildq ([a: x, b], a + b + c);
@c ''%;
@c ===end===
@example
(%i1) (a: 17, b: 29, c: 1729)$
(%i2) buildq ([a: x, b], a + b + c);
(%o2)                      x + c + 29
(%i3) ''%;
(%o3)                       x + 1758
@end example

@code{e} est@'{a} associado a uma lista, a qual aparece tamb@'{e}m como tal nos argumentos de @code{foo},
e interpolada nos argumentos de @code{bar}.

@c ===beg===
@c buildq ([e: [a, b, c]], foo (x, e, y));
@c buildq ([e: [a, b, c]], bar (x, splice (e), y));
@c ===end===
@example
(%i1) buildq ([e: [a, b, c]], foo (x, e, y));
(%o1)                 foo(x, [a, b, c], y)
(%i2) buildq ([e: [a, b, c]], bar (x, splice (e), y));
(%o2)                  bar(x, a, b, c, y)
@end example

O resultado @'{e} simplificado ap@'{o}s substitui@value{cedilha}@~{a}o.
Se a simplifica@value{cedilha}@~{a}o for aplicada antes da substitui@value{cedilha}@~{a}o, esses dois resultados podem ser iguais.
@c ===beg===
@c buildq ([e: [a, b, c]], splice (e) + splice (e));
@c buildq ([e: [a, b, c]], 2 * splice (e));
@c ===end===
@example
(%i1) buildq ([e: [a, b, c]], splice (e) + splice (e));
(%o1)                    2 c + 2 b + 2 a
(%i2) buildq ([e: [a, b, c]], 2 * splice (e));
(%o2)                        2 a b c
@end example

As vari@'{a}veis em @var{L} s@~{a}o associadas em paralelo; se associadas seq@"{u}@^{e}ncialmente,
o primeiro resultado pode ser @code{foo (b, b)}.
Substitui@value{cedilha}@~{o}es s@~{a}o realizadas em paralelo;
compare o segundo resultado com o resultado de @code{subst},
que realiza substitui@value{cedilha}@~{o}es seq@"{u}@^{e}ncialmente.

@c ===beg===
@c buildq ([a: b, b: a], foo (a, b));
@c buildq ([u: v, v: w, w: x, x: y, y: z, z: u], bar (u, v, w, x, y, z));
@c subst ([u=v, v=w, w=x, x=y, y=z, z=u], bar (u, v, w, x, y, z));
@c ===end===
@example
(%i1) buildq ([a: b, b: a], foo (a, b));
(%o1)                       foo(b, a)
(%i2) buildq ([u: v, v: w, w: x, x: y, y: z, z: u], bar (u, v, w, x, y, z));
(%o2)                 bar(v, w, x, y, z, u)
(%i3) subst ([u=v, v=w, w=x, x=y, y=z, z=u], bar (u, v, w, x, y, z));
(%o3)                 bar(u, u, u, u, u, u)
@end example

Constr@'{o}i uma lista de euq@value{cedilha}@~{o}es com algumas vari@'{a}veis ou express@~{o}es sobre o lado esquerdo
e seus valores sobre o lado direito.
@code{macroexpand} mostra a express@~{a}o retornada por @code{show_values}.

@c ===beg===
@c show_values ([L]) ::= buildq ([L], map ("=", 'L, L));
@c (a: 17, b: 29, c: 1729)$
@c show_values (a, b, c - a - b);
@c macroexpand (show_values (a, b, c - a - b));
@c ===end===
@example
(%i1) show_values ([L]) ::= buildq ([L], map ("=", 'L, L));
(%o1)   show_values([L]) ::= buildq([L], map("=", 'L, L))
(%i2) (a: 17, b: 29, c: 1729)$
(%i3) show_values (a, b, c - a - b);
(%o3)          [a = 17, b = 29, c - b - a = 1683]
(%i4) macroexpand (show_values (a, b, c - a - b));
(%o4)    map(=, '([a, b, c - b - a]), [a, b, c - b - a])
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} macroexpand (@var{expr})
Retorna a expans@~{a}o da macro de @var{expr} sem avaliar a express@~{a}o,
quando @code{expr} for uma chamada de fun@value{cedilha}@~{a}o de macro.
De outra forma, @code{macroexpand} retorna @var{expr}.

Se a expans@~{a}o de @var{expr} retorna outra chamada de fun@value{cedilha}@~{a}o de macro,
aquela chamada de fun@value{cedilha}@~{a}o de macro @'{e} tamb@'{e}m expandida.

@code{macroexpand} coloca ap@'{o}strofo em seus argumentos, isto @'{e}, n@~{a}o os avalia.
Todavia, se a expans@~{a}o de uma chamada de fun@value{cedilha}@~{a}o de macro tiver algum efeito,
esse efeito colateral @'{e} executado.

Veja tamb@'{e}m @code{::=}, @code{macros}, e @code{macroexpand1}.

Exemplos

@c ===beg===
@c g (x) ::= x / 99;
@c h (x) ::= buildq ([x], g (x - a));
@c a: 1234;
@c macroexpand (h (y));
@c h (y);
@c ===end===
@example
(%i1) g (x) ::= x / 99;
                                    x
(%o1)                      g(x) ::= --
                                    99
(%i2) h (x) ::= buildq ([x], g (x - a));
(%o2)            h(x) ::= buildq([x], g(x - a))
(%i3) a: 1234;
(%o3)                         1234
(%i4) macroexpand (h (y));
                              y - a
(%o4)                         -----
                               99
(%i5) h (y);
                            y - 1234
(%o5)                       --------
                               99
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} macroexpand1 (@var{expr})
Retorna a expans@~{a}o de macro de @var{expr} sem avaliar a express@~{a}o,
quando @code{expr} for uma chamada de fun@value{cedilha}@~{a}o de macro.
De outra forma, @code{macroexpand1} retorna @var{expr}.

@code{macroexpand1} n@~{a}o avalia seus argumentos.
Todavia, se a expans@~{a}o de uma chamada de fun@value{cedilha}@~{a}o de macro tiver algum efeito,
esse efeito colateral @'{e} executado.

Se a expans@~{a}o de @var{expr} retornar outra chamada de fun@value{cedilha}@~{a}o de macro,
aquela chamada de fun@value{cedilha}@~{a}o de macro n@~{a}o @'{e} expandida.

Veja tamb@'{e}m @code{::=}, @code{macros}, e @code{macroexpand}.

Exemplos

@c ===beg===
@c g (x) ::= x / 99;
@c h (x) ::= buildq ([x], g (x - a));
@c a: 1234;
@c macroexpand1 (h (y));
@c h (y);
@c ===end===
@example
(%i1) g (x) ::= x / 99;
                                    x
(%o1)                      g(x) ::= --
                                    99
(%i2) h (x) ::= buildq ([x], g (x - a));
(%o2)            h(x) ::= buildq([x], g(x - a))
(%i3) a: 1234;
(%o3)                         1234
(%i4) macroexpand1 (h (y));
(%o4)                       g(y - a)
(%i5) h (y);
                            y - 1234
(%o5)                       --------
                               99
@end example

@end deffn

@defvr {Global variable} macros
Default value: @code{[]}

@code{macros} @'{e} a lista de fun@value{cedilha}@~{o}es de macro definidas pelo usu@'{a}rio.
O operador de defini@value{cedilha}@~{a}o de fun@value{cedilha}@~{a}o de macro @code{::=} coloca uma nova fun@value{cedilha}@~{a}o de macro nessa lista,
e @code{kill}, @code{remove}, e @code{remfunction} removem fun@value{cedilha}@~{o}es de macro da lista.

Veja tamb@'{e}m @code{infolists}.

@end defvr

@deffn {Fun@value{cedilha}@~{a}o} splice (@var{a})
Une como se fosse um elo de liga@value{cedilha}@~{a}o (interpola) a lista nomeada atrav@'{e}s do @'{a}tomo @var{a} em uma express@~{a}o,
mas somente se @code{splice} aparecer dentro de @code{buildq};
de outra forma, @code{splice} @'{e} tratada como uma fun@value{cedilha}@~{a}o indefinida.
Se aparecer dentro de @code{buildq} com @var{a} sozinho (sem @code{splice}),
@var{a} @'{e} substituido (n@~{a}o interpolado) como uma lista no resultado.
O argumento de @code{splice} pode somente ser um @'{a}tomo;
n@~{a}o pode ser uma lista lateral ou uma express@~{a}o que retorna uma lista.

Tipicamente @code{splice} fornece os argumentos para uma fun@value{cedilha}@~{a}o ou operador.
Para uma fun@value{cedilha}@~{a}o @code{f}, a express@~{a}o @code{f (splice (@var{a}))} dentro de @code{buildq}
expande para @code{f (@var{a}[1], @var{a}[2], @var{a}[3], ...)}.
Para um operador @code{o}, a express@~{a}o @code{"o" (splice (@var{a})} dentro de @code{buildq}
expande para @code{"o" (@var{a}[1], @var{a}[2], @var{a}[3], ...)},
onde @code{o} pode ser qualquer tipo de operador (tipicamente um que toma multiplos argumentos).
Note que o operador deve ser contido dentro de aspas duplas @code{"}.

Exemplos

@c ===beg===
@c buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
@c buildq ([x: [1, %pi]], "/" (splice (x)));
@c matchfix ("<>", "<>");
@c buildq ([x: [1, %pi, z - y]], "<>" (splice (x)));
@c ===end===
@example
(%i1) buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
                       foo(1, %pi, z - y)
(%o1)                -----------------------
                     length([1, %pi, z - y])
(%i2) buildq ([x: [1, %pi]], "/" (splice (x)));
                                1
(%o2)                          ---
                               %pi
(%i3) matchfix ("<>", "<>");
(%o3)                          <>
(%i4) buildq ([x: [1, %pi, z - y]], "<>" (splice (x)));
(%o4)                   <>1, %pi, z - y<>
@end example

@end deffn


@c end concepts Defini@value{cedilha}@~{a}o de Fun@value{cedilha}@~{a}o
@node Fun@value{cedilha}@~{o}es e Vari@'{a}veis para Defini@value{cedilha}@~{a}o de Fun@value{cedilha}@~{a}o,  , Macros, Defini@value{cedilha}@~{a}o de Fun@value{cedilha}@~{a}o
@section Fun@value{cedilha}@~{o}es e Vari@'{a}veis para Defini@value{cedilha}@~{a}o de Fun@value{cedilha}@~{a}o

@deffn {Fun@value{cedilha}@~{a}o} apply (@var{F}, [@var{x_1}, ..., @var{x_n}])
Constr@'{o}i e avalia uma express@~{a}p @code{@var{F}(@var{arg_1}, ..., @var{arg_n})}.

@code{apply} n@~{a}o tenta distinguir fun@value{cedilha}@~{o}es de array de fun@value{cedilha}@~{o}es comuns;
quando @var{F} for o nome de uma fun@value{cedilha}@~{a}o de array,
@code{apply} avalia @code{@var{F}(...)}
(isto @'{e}, uma chamada de fun@value{cedilha}@~{a}o com par@^{e}ntesis em lugar de colch@^{e}tes).
@code{arrayapply} avalia uma chamada de fun@value{cedilha}@~{a}o com colch@^{e}tes nesse caso.

Exemplos:

@code{apply} avalia seus argumentos.
Nesse exemplo, @code{min} @'{e} aplicado a @code{L}.

@c ===beg===
@c L : [1, 5, -10.2, 4, 3];
@c apply (min, L);
@c ===end===
@example
(%i1) L : [1, 5, -10.2, 4, 3];
(%o1)                 [1, 5, - 10.2, 4, 3]
(%i2) apply (min, L);
(%o2)                        - 10.2
@end example

@code{apply} avalia argumentos, mesmo se a fun@value{cedilha}@~{a}o @var{F} disser que os argumentos n@~{a}o devem ser avaliados.

@c ===beg===
@c F (x) := x / 1729;
@c fname : F;
@c dispfun (F);
@c dispfun (fname);
@c apply (dispfun, [fname]);
@c ===end===
@example
(%i1) F (x) := x / 1729;
                                   x
(%o1)                     F(x) := ----
                                  1729
(%i2) fname : F;
(%o2)                           F
(%i3) dispfun (F);
                                   x
(%t3)                     F(x) := ----
                                  1729

(%o3)                         [%t3]
(%i4) dispfun (fname);
fname is not the name of a user function.
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) apply (dispfun, [fname]);
                                   x
(%t5)                     F(x) := ----
                                  1729

(%o5)                         [%t5]
@end example

@code{apply} avalia o nome de fun@value{cedilha}@~{a}o @var{F}.
Ap@'{o}strofo @code{'} evita avalia@value{cedilha}@~{a}o.
@code{demoivre} @'{e} o nome de uma vari@'{a}vel global e tamb@'{e}m de uma fun@value{cedilha}@~{a}o.

@c ===beg===
@c demoivre;
@c demoivre (exp (%i * x));
@c apply (demoivre, [exp (%i * x)]);
@c apply ('demoivre, [exp (%i * x)]);
@c ===end===
@example
(%i1) demoivre;
(%o1)                         false
(%i2) demoivre (exp (%i * x));
(%o2)                  %i sin(x) + cos(x)
(%i3) apply (demoivre, [exp (%i * x)]);
demoivre evaluates to false
Improper name or value in functional position.
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) apply ('demoivre, [exp (%i * x)]);
(%o4)                  %i sin(x) + cos(x)
@end example

@end deffn


@deffn {Fun@value{cedilha}@~{a}o} block ([@var{v_1}, ..., @var{v_m}], @var{expr_1}, ..., @var{expr_n})
@deffnx {Fun@value{cedilha}@~{a}o} block (@var{expr_1}, ..., @var{expr_n})
@code{block} avalia @var{expr_1}, ..., @var{expr_n} em seq@"{u}@^{e}ncia
e retorna o valor da @'{u}ltima express@~{a}o avaliada.
A seq@"{u}@^{e}ncia pode ser modificada pelas fun@value{cedilha}@~{o}es @code{go}, @code{throw}, e @code{return}.
A @'{u}ltima express@~{a}o @'{e} @var{expr_n} a menos que @code{return} ou uma express@~{a}o contendo @code{throw}
seja avaliada.
Algumas vari@'{a}veis @var{v_1}, ..., @var{v_m} podem ser declaradas locais para o bloco;
essas s@~{a}o distinguidas das vari@'{a}veis globais dos mesmos nomes.
Se vari@'{a}veis n@~{a}o forem declaradas locais ent@~{a}o a lista pode ser omitida.
Dentro do bloco,
qualquer vari@'{a}vel que n@~{a}o @var{v_1}, ..., @var{v_m} @'{e} uma vari@'{a}vel global.

@code{block} salva os valores correntes das vari@'{a}veis @var{v_1}, ..., @var{v_m} (quaisquer valores)
na hora da entrada para o bloco,
ent@~{a}o libera as vari@'{a}veis dessa forma eles avaliam para si mesmos.
As vari@'{a}veis locais podem ser associadas a valores arbitr@'{a}rios dentro do bloco mas quando o
bloco @'{e} encerrado o valores salvos s@~{a}o restaurados,
e os valores atribu@'{i}dos dentro do bloco s@~{a}o perdidos.

@code{block} pode aparecer dentro de outro @code{block}.
Vari@'{a}veis locais s@~{a}o estabelecidas cada vez que um novo @code{block} @'{e} avaliado.
Vari@'{a}veis locais parecem ser globais para quaisquer blocos fechados.
Se uma vari@'{a}vel @'{e} n@~{a}o local em um bloco,
seu valor @'{e} o valor mais recentemente atribu@'{i}do por um bloco fechado, quaisquer que sejam,
de outra forma, seu valor @'{e} o valor da vari@'{a}vel no ambiente global.
Essa pol@'{i}tica pode coincidir com o entendimento usual de "escopo din@^{a}mico".

Se isso for desejado para salvar e restaurar outras propriedades locais
ao lado de @code{value}, por exemplo @code{array} (exceto para arrays completos),
@code{function}, @code{dependencies}, @code{atvalue}, @code{matchdeclare}, @code{atomgrad}, @code{constant}, e
@code{nonscalar} ent@~{a}o a fun@value{cedilha}@~{a}o @code{local} pode ser usada dentro do bloco
com argumentos sendo o nome das vari@'{a}veis.

O valor do bloco @'{e} o valor da @'{u}ltima declara@value{cedilha}@~{a}o ou o
valor do argumento para a fun@value{cedilha}@~{a}o @code{return} que pode ser usada para sair
explicitamente do bloco.  A fun@value{cedilha}@~{a}o @code{go} pode ser usada para transferir o
controle para a declara@value{cedilha}@~{a}o do bloco que @'{e} identificada com o argumento
para @code{go}.  Para identificar uma declara@value{cedilha}@~{a}o, coloca-se antes dela um argumento at@^{o}mico como
outra declara@value{cedilha}@~{a}o no bloco.  Por exemplo:
@code{block ([x], x:1, loop, x: x+1, ..., go(loop), ...)}.  O argumento para @code{go} deve
ser o nome de um identificador que aparece dentro do bloco.  N@~{a}o se deve usar @code{go} para
transferir para um identificador em um outro bloco a n@~{a}o ser esse que cont@'{e}m o @code{go}.

Blocos tipicamente aparecem do lado direito de uma defini@value{cedilha}@~{a}o de fun@value{cedilha}@~{a}o
mas podem ser usados em outros lugares tamb@'{e}m.

@end deffn

@c REPHRASE, NEEDS EXAMPLE
@deffn {Fun@value{cedilha}@~{a}o} break (@var{expr_1}, ..., @var{expr_n})
Avalia e imprime @var{expr_1}, ..., @var{expr_n} e ent@~{a}o
causa uma parada do Maxima nesse ponto e o usu@'{a}rio pode examinar e alterar
seu ambiente.  Nessa situa@value{cedilha}@~{a}o digite @code{exit;} para que o c@'{a}lculo seja retomado.

@end deffn

@c FOR SOME REASON throw IS IN SOME OTHER FILE.  MOVE throw INTO THIS FILE.
@c NEEDS CLARIFICATION
@deffn {Fun@value{cedilha}@~{a}o} catch (@var{expr_1}, ..., @var{expr_n})
Avalia @var{expr_1}, ..., @var{expr_n} uma por uma; se qualquer avalia@value{cedilha}@~{a}o
levar a uma avalia@value{cedilha}@~{a}o de uma express@~{a}o da
forma @code{throw (arg)}, ent@~{a}o o valor de @code{catch} @'{e} o valor de
@code{throw (arg)}, e express@~{o}es adicionais n@~{a}o s@~{a}o avaliadas.
Esse "retorno n@~{a}o local" atravessa assim qualquer profundidade de
aninhar para o mais pr@'{o}ximo contendo @code{catch}.
Se n@~{a}o existe nenhum @code{catch} contendo um @code{throw}, uma mensagem de erro @'{e} impressa.

Se a avalia@value{cedilha}@~{a}o de argumentos n@~{a}o leva para a avalia@value{cedilha}@~{a}o de qualquer @code{throw}
ent@~{a}o o valor de @code{catch} @'{e} o valor de @var{expr_n}.

@example
(%i1) lambda ([x], if x < 0 then throw(x) else f(x))$
(%i2) g(l) := catch (map (''%, l))$
(%i3) g ([1, 2, 3, 7]);
(%o3)               [f(1), f(2), f(3), f(7)]
(%i4) g ([1, 2, -3, 7]);
(%o4)                          - 3
@end example

@c REWORD THIS PART.
A fun@value{cedilha}@~{a}o @code{g} retorna uma lista de @code{f} de cada elemento de @code{l} se @code{l}
consiste somente de n@'{u}meros n@~{a}o negativos; de outra forma, @code{g} "captura" o
primeiro elemento negativo de @code{l} e "arremessa-o".

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} compfile (@var{nomearquivo}, @var{f_1}, ..., @var{f_n})
@deffnx {Fun@value{cedilha}@~{a}o} compfile (@var{nomearquivo}, fun@value{cedilha}@~{o}es)
@deffnx {Fun@value{cedilha}@~{a}o} compfile (@var{nomearquivo}, all)

Traduz fu@value{cedilha}@~{o}es Maxima para Lisp 
e escreve o c@'{o}digo traduzido no arquivo @var{nomearquivo}.

@code{compfile(@var{nomearquivo}, @var{f_1}, ..., @var{f_n})} traduz as
fun@value{cedilha}@~{o}es especificadas.
@code{compfile(@var{nomearquivo}, functions)} e @code{compfile(@var{nomearquivo}, all)}
traduz todas as fun@value{cedilha}@~{o}es definidas pelo usu@'{a}rio.

As tradu@value{cedilha}@~{o}es Lisp n@~{a}o s@~{a}o avaliadas, nem @'{e} o arquivo de sa@'{i}da processado pelo compilador Lisp.
@c SO LET'S CONSIDER GIVING THIS FUNCTION A MORE ACCURATE NAME.
@code{translate} cria e avalia tradu@value{cedilha}@~{o}es Lisp.
@code{compile_file} traduz Maxima para Lisp, e ent@~{a}o executa o compilador Lisp.  

Veja tamb@'{e}m @code{translate}, @code{translate_file}, e @code{compile_file}.

@end deffn

@c THIS VARIABLE IS OBSOLETE: ASSIGNING compgrind: true CAUSES compfile
@c TO EVENTUALLY CALL AN OBSOLETE FUNCTION SPRIN1.
@c RECOMMENDATION IS TO CUT THIS ITEM, AND CUT $compgrind FROM src/transs.lisp
@c @defvar compgrind
@c Default value: @code{false}
@c 
@c When @code{compgrind} @'{e} @code{true}, function definitions printed by
@c @code{compfile} are pretty-printed.
@c 
@c @end defvar

@deffn {Fun@value{cedilha}@~{a}o} compile (@var{f_1}, ..., @var{f_n})
@deffnx {Fun@value{cedilha}@~{a}o} compile (fun@value{cedilha}@~{o}es)
@deffnx {Fun@value{cedilha}@~{a}o} compile (all)
Traduz fun@value{cedilha}@~{o}es Maxima @var{f_1}, ..., @var{f_n} para Lisp, avalia a tradu@value{cedilha}@~{a}o Lisp,
e chama a fun@value{cedilha}@~{a}o Lisp @code{COMPILE} sobre cada fun@value{cedilha}@~{a}o traduzida.
@code{compile} retorna uma lista de nomes de fun@value{cedilha}@~{o}es compiladas.

@code{compile (all)} ou @code{compile (fun@value{cedilha}@~{o}es)} compila todas as fun@value{cedilha}@~{o}es definidas pelo usu@'{a}rio.

@code{compile} n@~{a}o avalia seus argumentos; 
o operador ap@'{o}strofo-ap@'{o}strofo @code{'@w{}'} faz com que ocorra avalia@value{cedilha}@~{a}o sobrepondo-se ao ap@'{o}strofo.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} define (@var{f}(@var{x_1}, ..., @var{x_n}), @var{expr})
@deffnx {Fun@value{cedilha}@~{a}o} define (@var{f}[@var{x_1}, ..., @var{x_n}], @var{expr})
@deffnx {Fun@value{cedilha}@~{a}o} define (funmake (@var{f}, [@var{x_1}, ..., @var{x_n}]), @var{expr})
@deffnx {Fun@value{cedilha}@~{a}o} define (arraymake (@var{f}, [@var{x_1}, ..., @var{x_n}]), @var{expr})
@deffnx {Fun@value{cedilha}@~{a}o} define (ev (@var{expr_1}), @var{expr_2})

Define uma fun@value{cedilha}@~{a}o chamada @var{f} com argumentos @var{x_1}, ..., @var{x_n} e corpo da fun@value{cedilha}@~{a}o @var{expr}.
@code{define} sempre avalia seu segundo argumento (a menos que expl@'{i}citamente receba um apostrofo de forma a evitar a avalia@value{cedilha}@~{a}o).
A fun@value{cedilha}@~{a}o ent@~{a}o definida pode ser uma fun@value{cedilha}@~{a}o comum do Maxima (com argumentos contidos entre par@^{e}tesis)
ou uma fun@value{cedilha}@~{a}o de array (com argumentos contidos entre colch@^{e}tes).

Quando o @'{u}ltimo ou @'{u}nico argumento da fun@value{cedilha}@~{a}o @var{x_n} for uma lista de um elemento,
a fun@value{cedilha}@~{a}o definida por @code{define} aceita um n@'{u}mero vari@'{a}vel de argumentos.
Os argumentos atuais s@~{a}o atribu@'{i}dos um a um a argumentos formais @var{x_1}, ..., @var{x_(n - 1)},
e quaisquer argumentos adicionais atuais, se estiverem presentes, s@~{a}o atribu@'{i}dos a @var{x_n} como uma lista.

Quando o primeiro argumento de @code{define} for uma express@~{a}o da forma
@code{@var{f}(@var{x_1}, ..., @var{x_n})} or @code{@var{f}[@var{x_1}, ..., @var{x_n}]},
os argumentos s@~{a}o avaliados mas @var{f} n@~{a}o @'{e} avaliada,
mesmo se j@'{a} existe anteriormente uma fun@value{cedilha}@~{a}o ou vari@'{a}vel com aquele nome.

Quando o primeiro argumento for uma express@~{a}o com operador @code{funmake}, @code{arraymake}, ou @code{ev},
o primeiro argumento ser@'{a} avaliado;
isso permite para o nome da fun@value{cedilha}@~{a}o seja calculado, tamb@'{e}m como o corpo.

Todas as defini@value{cedilha}@~{o}es de fun@value{cedilha}@~{a}o aparecem no mesmo n@'{i}vel de escopo e visibilidade;
definindo uma fun@value{cedilha}@~{a}o @code{f} dentro de outra fun@value{cedilha}@~{a}o @code{g}
n@~{a}o limita o escopo de @code{f} a @code{g}.

Se algum argumento formal @var{x_k} for um s@'{i}mbolo com ap@'{o}strofo (ap@'{o}s ter sido feita uma avalia@value{cedilha}@~{a}o),
a fun@value{cedilha}@~{a}o definida por @code{define} n@~{a}o avalia o correspondente atual argumento.
de outra forma todos os argumentos atuais s@~{a}o avaliados.

Veja tamb@'{e}m @code{:=} and @code{::=}.

Exemplos:

@code{define} sempre avalia seu segundo argumento (a menos que expl@'{i}citamente receba um apostrofo de forma a evitar a avalia@value{cedilha}@~{a}o).

@c ===beg===
@c expr : cos(y) - sin(x);
@c define (F1 (x, y), expr);
@c F1 (a, b);
@c F2 (x, y) := expr;
@c F2 (a, b);
@c ===end===
@example
(%i1) expr : cos(y) - sin(x);
(%o1)                    cos(y) - sin(x)
(%i2) define (F1 (x, y), expr);
(%o2)              F1(x, y) := cos(y) - sin(x)
(%i3) F1 (a, b);
(%o3)                    cos(b) - sin(a)
(%i4) F2 (x, y) := expr;
(%o4)                   F2(x, y) := expr
(%i5) F2 (a, b);
(%o5)                    cos(y) - sin(x)
@end example

A fun@value{cedilha}@~{a}o definida por @code{define} pode ser uma fun@value{cedilha}@~{a}o comum do Maxima ou uma fun@value{cedilha}@~{a}o de array.

@c ===beg===
@c define (G1 (x, y), x.y - y.x);
@c define (G2 [x, y], x.y - y.x);
@c ===end===
@example
(%i1) define (G1 (x, y), x.y - y.x);
(%o1)               G1(x, y) := x . y - y . x
(%i2) define (G2 [x, y], x.y - y.x);
(%o2)                G2     := x . y - y . x
                       x, y
@end example

Quando o @'{u}ltimo ou @'{u}nico argumento da fun@value{cedilha}@~{a}o @var{x_n} for uma lista de um @'{u}nico elemento,
a fun@value{cedilha}@~{a}o definida por @code{define} aceita um n@'{u}mero vari@'{a}vel de argumentos.

@c ===beg===
@c define (H ([L]), '(apply ("+", L)));
@c H (a, b, c);
@c ===end===
@example
(%i1) define (H ([L]), '(apply ("+", L)));
(%o1)                H([L]) := apply("+", L)
(%i2) H (a, b, c);
(%o2)                       c + b + a
@end example

When the first argument is an expression with operator @code{funmake}, @code{arraymake}, or @code{ev},
the first argument is evaluated.

@c ===beg===
@c [F : I, u : x];
@c funmake (F, [u]);
@c define (funmake (F, [u]), cos(u) + 1);
@c define (arraymake (F, [u]), cos(u) + 1);
@c define (foo (x, y), bar (y, x));
@c define (ev (foo (x, y)), sin(x) - cos(y));
@c ===end===
@example
(%i1) [F : I, u : x];
(%o1)                        [I, x]
(%i2) funmake (F, [u]);
(%o2)                         I(x)
(%i3) define (funmake (F, [u]), cos(u) + 1);
(%o3)                  I(x) := cos(x) + 1
(%i4) define (arraymake (F, [u]), cos(u) + 1);
(%o4)                   I  := cos(x) + 1
                         x
(%i5) define (foo (x, y), bar (y, x));
(%o5)                foo(x, y) := bar(y, x)
(%i6) define (ev (foo (x, y)), sin(x) - cos(y));
(%o6)             bar(y, x) := sin(x) - cos(y)
@end example

@end deffn

@c SEE NOTE BELOW ABOUT THE DOCUMENTATION STRING
@c @deffn {Fun@value{cedilha}@~{a}o} define_variable (@var{name}, @var{default_value}, @var{mode}, @var{documentation})
@deffn {Fun@value{cedilha}@~{a}o} define_variable (@var{name}, @var{default_value}, @var{mode})

Introduz uma vari@'{a}vel global dentro do ambiente Maxima.
@c IMPORT OF FOLLOWING STATEMENT UNCLEAR: IN WHAT WAY IS define_variable MORE USEFUL IN TRANSLATED CODE ??
@code{define_variable} @'{e} @'{u}til em pacotes escritos pelo usu@'{a}rio, que s@~{a}o muitas vezes traduzidos ou compilados.

@code{define_variable} realiza os seguintes passos:

@enumerate
@item
@code{mode_declare (@var{name}, @var{mode})} declara o modo de @var{name} para o tradutor.
Veja @code{mode_declare} para uma lista dos modos poss@'{i}veis.

@item
Se a vari@'{a}vel @'{e} n@~{a}o associada, @var{default_value} @'{e} atribu@'{i}do para @var{name}.

@item
@code{declare (@var{name}, special)} declara essa vari@'{a}vel especial.
@c CLARIFY THE MEANING OF SPECIAL FOR THE BENEFIT OF READERS OTHER THAN LISP PROGRAMMERS

@item
Associa @var{name} com uma fun@value{cedilha}@~{a}o de teste
para garantir que a @var{name} seja somente atribu@'{i}do valores do modo declarado.
@end enumerate


@c FOLLOWING STATEMENT APPEARS TO BE OUT OF DATE.
@c EXAMINING DEFMSPEC $DEFINE_VARIABLE AND DEF%TR $DEFINE_VARIABLE IN src/trmode.lisp,
@c IT APPEARS THAT THE 4TH ARGUMENT IS NEVER REFERRED TO.
@c EXECUTING translate_file ON A MAXIMA BATCH FILE WHICH CONTAINS
@c define_variable (foo, 2222, integer, "THIS IS FOO");
@c DOES NOT PUT "THIS IS FOO" INTO THE LISP FILE NOR THE UNLISP FILE.
@c The optional 4th argumento @'{e} a documentation string.  When
@c @code{translate_file} @'{e} used on a package which includes documentation
@c strings, a second file @'{e} output in addition to the Lisp file which
@c will contain the documentation strings, formatted suitably for use in
@c manuals, usage files, or (for instance) @code{describe}.

A propriedade @code{value_check} pode ser atribu@'{i}da a qualquer vari@'{a}vel que tenha sido definida
via @code{define_variable} com um outro modo que n@~{a}o @code{any}.
A propriedade @code{value_check} @'{e} uma express@~{a}o lambda ou o nome de uma fun@value{cedilha}@~{a}o de uma vari@'{a}vel,
que @'{e} chamada quando uma tentativa @'{e} feita para atribuir um valor a uma vari@'{a}vel.
O argumento da  fun@value{cedilha}@~{a}o @code{value_check} @'{e} o valor que ser@'{a} atribu@'{i}do.

@code{define_variable} avalia @code{default_value}, e n@~{a}o avalia @code{name} e @code{mode}.
@code{define_variable} retorna o valor corrente de @code{name},
que @'{e} @code{default_value} se @code{name} n@~{a}o tiver sido associada antes,
e de outra forma isso @'{e} o valor pr@'{e}vio de @code{name}.

Exemplos:

@code{foo} @'{e} uma vari@'{a}vel Booleana, com o valor inicial @code{true}.
@c GENERATED FROM:
@c define_variable (foo, true, boolean);
@c foo;
@c foo: false;
@c foo: %pi;
@c foo;

@example
(%i1) define_variable (foo, true, boolean);
(%o1)                         true
(%i2) foo;
(%o2)                         true
(%i3) foo: false;
(%o3)                         false
(%i4) foo: %pi;
Error: foo was declared mode boolean, has value: %pi
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) foo;
(%o5)                         false
@end example

@code{bar} @'{e} uma vari@'{a}vel inteira, que deve ser um n@'{u}mero primo.
@c GENERATED FROM:
@c define_variable (bar, 2, integer);
@c qput (bar, prime_test, value_check);
@c prime_test (y) := if not primep(y) then error (y, "is not prime.");
@c bar: 1439;
@c bar: 1440;
@c bar;

@example
(%i1) define_variable (bar, 2, integer);
(%o1)                           2
(%i2) qput (bar, prime_test, value_check);
(%o2)                      prime_test
(%i3) prime_test (y) := if not primep(y) then error (y, "is not prime.");
(%o3) prime_test(y) := if not primep(y)

                                   then error(y, "is not prime.")
(%i4) bar: 1439;
(%o4)                         1439
(%i5) bar: 1440;
1440 @'{e} not prime.
#0: prime_test(y=1440)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i6) bar;
(%o6)                         1439
@end example

@code{baz_quux} @'{e} uma vari@'{a}vel que n@~{a}o pode receber a atribui@value{cedilha}@~{a}o de um valor.
O modo @code{any_check} @'{e} como @code{any}, 
mas @code{any_check} habilita o mecanismo @code{value_check}, e @code{any} n@~{a}o habilita.
@c GENERATED FROM:
@c define_variable (baz_quux, 'baz_quux, any_check);
@c F: lambda ([y], if y # 'baz_quux then error ("Cannot assign to `baz_quux'."));
@c qput (baz_quux, ''F, value_check);
@c baz_quux: 'baz_quux;
@c baz_quux: sqrt(2);
@c baz_quux;

@example
(%i1) define_variable (baz_quux, 'baz_quux, any_check);
(%o1)                       baz_quux
(%i2) F: lambda ([y], if y # 'baz_quux then error ("Cannot assign to `baz_quux'."));
(%o2) lambda([y], if y # 'baz_quux

                        then error(Cannot assign to `baz_quux'.))
(%i3) qput (baz_quux, ''F, value_check);
(%o3) lambda([y], if y # 'baz_quux

                        then error(Cannot assign to `baz_quux'.))
(%i4) baz_quux: 'baz_quux;
(%o4)                       baz_quux
(%i5) baz_quux: sqrt(2);
Cannot assign to `baz_quux'.
#0: lambda([y],if y # 'baz_quux then error("Cannot assign to `baz_quux'."))(y=sqrt(2))
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i6) baz_quux;
(%o6)                       baz_quux
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} dispfun (@var{f_1}, ..., @var{f_n})
@deffnx {Fun@value{cedilha}@~{a}o} dispfun (all)
Mostra a defini@value{cedilha}@~{a}o de fun@value{cedilha}@~{o}es definidas pelo usu@'{a}rio @var{f_1}, ..., @var{f_n}.
Cada argumento pode ser o nome de uma macro (definida com @code{::=}),
uma fun@value{cedilha}@~{a}o comum (definida com @code{:=} ou @code{define}),
uma fun@value{cedilha}@~{a}o array (definida com @code{:=} ou com @code{define},
mas contendo argumentos entre colch@^{e}tes @code{[ ]}),
uma fun@value{cedilha}@~{a}o subscrita, (definida com @code{:=} ou @code{define},
mas contendo alguns argumentos entre colch@^{e}tes e outros entre par@^{e}ntesis @code{( )})
uma da fam@'{i}lia de fun@value{cedilha}@~{o}es subscritas selecionadas por um valor subscrito particular,
ou uma fun@value{cedilha}@~{a}o subscrita definida com uma constante subscrita.

@code{dispfun (all)} mostra todas as fun@value{cedilha}@~{o}es definidas pelo usu@'{a}rio como
dadas pelas @code{functions}, @code{arrays}, e listas de @code{macros},
omitindo fun@value{cedilha}@~{o}es subscritas definidas com constantes subscritas.

@code{dispfun} cria um R@'{o}tulo de express@~{a}o intermedi@'{a}ria
(@code{%t1}, @code{%t2}, etc.)
para cada fun@value{cedilha}@~{a}o mostrada, e atribui a defini@value{cedilha}@~{a}o de fun@value{cedilha}@~{a}o para o r@'{o}tulo.
Em contraste, @code{fundef} retorna a defini@value{cedilha}@~{a}o de fun@value{cedilha}@~{a}o.

@code{dispfun} n@~{a}o avalia seus argumentos; 
O operador ap@'{o}strofo-ap@'{o}strofo @code{'@w{}'} faz com que ocorra avalia@value{cedilha}@~{a}o.
@code{dispfun} retorna a lista de r@'{o}tulos de express@~{o}es intermedi@'{a}rias correspondendo @`as fun@value{cedilha}@~{o}es mostradas.

Exemplos:

@c ===beg===
@c m(x, y) ::= x^(-y);
@c f(x, y) :=  x^(-y);
@c g[x, y] :=  x^(-y);
@c h[x](y) :=  x^(-y);
@c i[8](y) :=  8^(-y);
@c dispfun (m, f, g, h, h[5], h[10], i[8]);
@c ''%;
@c ===end===
@example
(%i1) m(x, y) ::= x^(-y);
                                     - y
(%o1)                   m(x, y) ::= x
(%i2) f(x, y) :=  x^(-y);
                                     - y
(%o2)                    f(x, y) := x
(%i3) g[x, y] :=  x^(-y);
                                    - y
(%o3)                     g     := x
                           x, y
(%i4) h[x](y) :=  x^(-y);
                                    - y
(%o4)                     h (y) := x
                           x
(%i5) i[8](y) :=  8^(-y);
                                    - y
(%o5)                     i (y) := 8
                           8
(%i6) dispfun (m, f, g, h, h[5], h[10], i[8]);
                                     - y
(%t6)                   m(x, y) ::= x

                                     - y
(%t7)                    f(x, y) := x

                                    - y
(%t8)                     g     := x
                           x, y

                                    - y
(%t9)                     h (y) := x
                           x

                                    1
(%t10)                     h (y) := --
                            5        y
                                    5

                                     1
(%t11)                    h  (y) := ---
                           10         y
                                    10

                                    - y
(%t12)                    i (y) := 8
                           8

(%o12)       [%t6, %t7, %t8, %t9, %t10, %t11, %t12]
(%i12) ''%;
                     - y              - y            - y
(%o12) [m(x, y) ::= x   , f(x, y) := x   , g     := x   , 
                                            x, y
                  - y           1              1             - y
        h (y) := x   , h (y) := --, h  (y) := ---, i (y) := 8   ]
         x              5        y   10         y   8
                                5             10
@end example

@end deffn

@defvr {Vari@'{a}vel de sistema} functions
Valor padr@~{a}o: @code{[]}

@code{functions} @'{e} a lista de todas as fun@value{cedilha}@~{o}es comuns do Maxima
na sess@~{a}o corrente.
Uma fun@value{cedilha}@~{a}o comum @'{e} uma fun@value{cedilha}@~{a}o constru@'{i}da atrav@'{e}s de
@code{define} ou de @code{:=} e chamada com par@^{e}ntesis @code{()}.
Uma fun@value{cedilha}@~{a}o pode ser definida pela linha de comando do Maxima de forma interativa com o usu@'{a}rio
ou em um arquivo Maxima chamado por @code{load} ou @code{batch}.

Fun@value{cedilha}@~{o}es de array (chamadas com colch@^{e}tes, e.g., @code{F[x]})
e fun@value{cedilha}@~{o}es com subscritos (chamadas com colch@^{e}tes e par@^{e}ntesis, e.g., @code{F[x](y)})
s@~{a}o lsitados atrav@'{e}s da vari@'{a}vel global @code{arrays}, e n@~{a}o por meio de @code{functions}.

Fun@value{cedilha}@~{o}es Lisp n@~{a}o s@~{a}o mantidas em nenhuma lista.

Exemplos:

@c ===beg===
@c F_1 (x) := x - 100;
@c F_2 (x, y) := x / y;
@c define (F_3 (x), sqrt (x));
@c G_1 [x] := x - 100;
@c G_2 [x, y] := x / y;
@c define (G_3 [x], sqrt (x));
@c H_1 [x] (y) := x^y;
@c functions;
@c arrays;
@c ===end===
@example
(%i1) F_1 (x) := x - 100;
(%o1)                   F_1(x) := x - 100
(%i2) F_2 (x, y) := x / y;
                                      x
(%o2)                    F_2(x, y) := -
                                      y
(%i3) define (F_3 (x), sqrt (x));
(%o3)                   F_3(x) := sqrt(x)
(%i4) G_1 [x] := x - 100;
(%o4)                    G_1  := x - 100
                            x
(%i5) G_2 [x, y] := x / y;
                                     x
(%o5)                     G_2     := -
                             x, y    y
(%i6) define (G_3 [x], sqrt (x));
(%o6)                    G_3  := sqrt(x)
                            x
(%i7) H_1 [x] (y) := x^y;
                                      y
(%o7)                     H_1 (y) := x
                             x
(%i8) functions;
(%o8)              [F_1(x), F_2(x, y), F_3(x)]
(%i9) arrays;
(%o9)                 [G_1, G_2, G_3, H_1]
@end example

@end defvr

@deffn {Fun@value{cedilha}@~{a}o} fundef (@var{f})
Retorna a defini@value{cedilha}@~{a}o da fun@value{cedilha}@~{a}o @var{f}.

@c PROBABLY THIS WOULD BE CLEARER AS A BULLET LIST
O argumento pode ser o nome de uma macro (definida com @code{::=}),
uma fun@value{cedilha}@~{a}o comum (definida com @code{:=} ou @code{define}),
uma fun@value{cedilha}@~{a}o array (definida com @code{:=} ou @code{define},
mas contendo argumentos entre colch@^{e}tes @code{[ ]}),
Uma fun@value{cedilha}@~{a}o subscrita, (definida com @code{:=} ou @code{define},
mas contendo alguns argumentos entre colch@^{e}tes e par@^{e}ntesis @code{( )})
uma da fam@'{i}lia de fun@value{cedilha}@~{o}es subscritas selecionada por um valor particular subscrito,
ou uma fun@value{cedilha}@~{a}o subscrita definida com uma constante subscrita.

@code{fundef} n@~{a}o avalia seu argumento;
o operador ap@'{o}strofo-ap@'{o}strofo @code{'@w{}'} faz com que ocorra avalia@value{cedilha}@~{a}o.

@code{fundef (@var{f})} retorna a defini@value{cedilha}@~{a}o de @var{f}.
Em contraste, @code{dispfun (@var{f})} cria um r@'{o}tulo de express@~{a}o intermedi@'{a}ria
e atribui a defini@value{cedilha}@~{a}o para o r@'{o}tulo.

@c PROBABLY NEED SOME EXAMPLES HERE
@end deffn

@deffn {Fun@value{cedilha}@~{a}o} funmake (@var{F}, [@var{arg_1}, ..., @var{arg_n}])
Retorna uma express@~{a}o @code{@var{F}(@var{arg_1}, ..., @var{arg_n})}.
O valor de retorno @'{e} simplificado, mas n@~{a}o avaliado,
ent@~{a}o a fun@value{cedilha}@~{a}o @var{F} n@~{a}o @'{e} chamada, mesmo se essa fun@value{cedilha}@~{a}o @var{F} existir.

@code{funmake} n@~{a}o tenta distinguir fun@value{cedilha}@~{o}es de array de fun@value{cedilha}@~{o}es comuns;
quando @var{F} for o nome de uma fun@value{cedilha}@~{a}o de array,
@code{funmake} retorna @code{@var{F}(...)}
(isto @'{e}, uma chamada de fun@value{cedilha}@~{a}o com par@^{e}ntesis em lugar de colch@^{e}tes).
@code{arraymake} retorna uma chamada de fun@value{cedilha}@~{a}o com colch@^{e}tes nesse caso.

@code{funmake} avalia seus argumentos.

Exemplos:

@code{funmake} aplicada a uma fun@value{cedilha}@~{a}o comum do Maxima.

@c ===beg===
@c F (x, y) := y^2 - x^2;
@c funmake (F, [a + 1, b + 1]);
@c ''%;
@c ===end===
@example
(%i1) F (x, y) := y^2 - x^2;
                                   2    2
(%o1)                  F(x, y) := y  - x
(%i2) funmake (F, [a + 1, b + 1]);
(%o2)                    F(a + 1, b + 1)
(%i3) ''%;
                              2          2
(%o3)                  (b + 1)  - (a + 1)
@end example

@code{funmake} aplicada a uma macro.

@c ===beg===
@c G (x) ::= (x - 1)/2;
@c funmake (G, [u]);
@c ''%;
@c ===end===
@example
(%i1) G (x) ::= (x - 1)/2;
                                  x - 1
(%o1)                    G(x) ::= -----
                                    2
(%i2) funmake (G, [u]);
(%o2)                         G(u)
(%i3) ''%;
                              u - 1
(%o3)                         -----
                                2
@end example

@code{funmake} aplicada a uma fun@value{cedilha}@~{a}o subscrita.

@c ===beg===
@c H [a] (x) := (x - 1)^a;
@c funmake (H [n], [%e]);
@c ''%;
@c funmake ('(H [n]), [%e]);
@c ''%;
@c ===end===
@example
(%i1) H [a] (x) := (x - 1)^a;
                                        a
(%o1)                   H (x) := (x - 1)
                         a
(%i2) funmake (H [n], [%e]);
                                       n
(%o2)               lambda([x], (x - 1) )(%e)
(%i3) ''%;
                                    n
(%o3)                       (%e - 1)
(%i4) funmake ('(H [n]), [%e]);
(%o4)                        H (%e)
                              n
(%i5) ''%;
                                    n
(%o5)                       (%e - 1)
@end example

@code{funmake} aplicada a um s@'{i}mbolo que n@~{a}o @'{e} uma fun@value{cedilha}@~{a}o definida de qualquer tipo.

@c ===beg===
@c funmake (A, [u]);
@c ''%;
@c ===end===
@example
(%i1) funmake (A, [u]);
(%o1)                         A(u)
(%i2) ''%;
(%o2)                         A(u)
@end example

 @code{funmake} avalia seus argumentos, mas n@~{a}o o valor de retorno.

@c ===beg===
@c det(a,b,c) := b^2 -4*a*c;
@c (x : 8, y : 10, z : 12);
@c f : det;
@c funmake (f, [x, y, z]);
@c ''%;
@c ===end===
@example
(%i1) det(a,b,c) := b^2 -4*a*c;
                                    2
(%o1)              det(a, b, c) := b  - 4 a c
(%i2) (x : 8, y : 10, z : 12);
(%o2)                          12
(%i3) f : det;
(%o3)                          det
(%i4) funmake (f, [x, y, z]);
(%o4)                    det(8, 10, 12)
(%i5) ''%;
(%o5)                         - 284
@end example

Maxima simplifica o valor de retorno de @code{funmake}.

@c ===beg===
@c funmake (sin, [%pi / 2]);
@c ===end===
@example
(%i1) funmake (sin, [%pi / 2]);
(%o1)                           1
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} lambda ([@var{x_1}, ..., @var{x_m}], @var{expr_1}, ..., @var{expr_n})
@deffnx {Fun@value{cedilha}@~{a}o} lambda ([[@var{L}]], @var{expr_1}, ..., @var{expr_n})
@deffnx {Fun@value{cedilha}@~{a}o} lambda ([@var{x_1}, ..., @var{x_m}, [@var{L}]], @var{expr_1}, ..., @var{expr_n})
Define e retorna uma express@~{a}o lambda (que @'{e}, uma fun@value{cedilha}@~{a}o an@^{o}nima)
A fun@value{cedilha}@~{a}o pode ter argumentos que sejam necess@'{a}rios @var{x_1}, ..., @var{x_m}
e/ou argumentos opcionais @var{L}, os quais aparecem dentro do corpo da fun@value{cedilha}@~{a}o como uma lista.
O valor de retorno da fun@value{cedilha}@~{a}o @'{e} @var{expr_n}.
Uma express@~{a}o lambda pode ser atribu@'{i}da para uma vari@'{a}vel e avaliada como uma fun@value{cedilha}@~{a}o comum.
Uma express@~{a}o lambda pode aparecer em alguns contextos nos quais um nome de fun@value{cedilha}@~{a}o @'{e} esperado.

Quando a fun@value{cedilha}@~{a}o @'{e} avaliada,
vari@'{a}veis locais n@~{a}o associadas @var{x_1}, ..., @var{x_m} s@~{a}o criadas.
@code{lambda} pode aparecer dentro de @code{block} ou outra fun@value{cedilha}@~{a}o @code{lambda};
vari@'{a}veis locais s@~{a}o estabelecidas cada vez que outro @code{block} ou fun@value{cedilha}@~{a}o @code{lambda} @'{e} avaliada.
Vari@'{a}veis locais parecem ser globais para qualquer coisa contendo @code{block} ou @code{lambda}.
Se uma vari@'{a}vel @'{e} n@~{a}o local,
seu valor @'{e} o valor mais recentemente atribu@'{i}do em alguma coisa contendo @code{block} ou @code{lambda}, qualquer que seja,
de outra forma, seu valor @'{e} o valor da vari@'{a}vel no ambiente global.
Essa pol@'{i}tica pode coincidir com o entendimento usual de "escopo din@^{a}mico".

Ap@'{o}s vari@'{a}veis locais serem estabelecidas,
@var{expr_1} at@'{e} @var{expr_n} s@~{a}o avaliadas novamente.
a vari@'{a}vel especial @code{%%}, representando o valor da express@~{a}o precedente,
@'{e} reconhecida.
@code{throw} e @code{catch} pode tamb@'{e}m aparecer na lista de express@~{o}es.

@code{return} n@~{a}o pode aparecer em uma express@~{a}o lambda a menos que contendo @code{block},
nesse caso @code{return} define o valor de retorno do  bloco e n@~{a}o da
express@~{a}o lambda,
a menos que o bloco seja @var{expr_n}.
Da mesma forma, @code{go} n@~{a}o pode aparecer em uma express@~{a}o lambda a menos que contendo @code{block}.

@code{lambda} n@~{a}o avalia seus argumentos; 
o operador ap@'{o}strofo-ap@'{o}strofo @code{'@w{}'} faz com que ocorra avalia@value{cedilha}@~{a}o.

Exemplos:

@itemize @bullet
@item
A express@~{a}o lambda pode ser atribu@'{i}da para uma vari@'{a}vel e avaliada como uma fun@value{cedilha}@~{a}o comum.
@end itemize
@c ===beg===
@c f: lambda ([x], x^2);
@c f(a);
@c ===end===
@example
(%i1) f: lambda ([x], x^2);
                                      2
(%o1)                    lambda([x], x )
(%i2) f(a);
                                2
(%o2)                          a
@end example
@itemize @bullet
@item
Uma express@~{a}o lambda pode aparecer em contextos nos quais uma avalia@value{cedilha}@~{a}o de fun@value{cedilha}@~{a}o @'{e} esperada como resposta.
@end itemize
@c ===beg===
@c lambda ([x], x^2) (a);
@c apply (lambda ([x], x^2), [a]);
@c map (lambda ([x], x^2), [a, b, c, d, e]);
@c ===end===
@example
(%i3) lambda ([x], x^2) (a);
                                2
(%o3)                          a
(%i4) apply (lambda ([x], x^2), [a]);
                                2
(%o4)                          a
(%i5) map (lambda ([x], x^2), [a, b, c, d, e]);
                        2   2   2   2   2
(%o5)                 [a , b , c , d , e ]
@end example
@itemize @bullet
@item
Vari@'{a}veis argumento s@~{a}o vari@'{a}veis locais.
Outras vari@'{a}veis aparecem para serem vari@'{a}veis globais.
Vari@'{a}veis globais s@~{a}o avaliadas ao mesmo tempo em que a express@~{a}o lambda @'{e} avaliada,
a menos que alguma avalia@value{cedilha}@~{a}o especial seja for@value{cedilha}ada por alguns meios, tais como @code{'@w{}'}.
@end itemize
@c ===beg===
@c a: %pi$
@c b: %e$
@c g: lambda ([a], a*b);
@c b: %gamma$
@c g(1/2);
@c g2: lambda ([a], a*''b);
@c b: %e$
@c g2(1/2);
@c ===end===
@example
(%i6) a: %pi$
(%i7) b: %e$
(%i8) g: lambda ([a], a*b);
(%o8)                   lambda([a], a b)
(%i9) b: %gamma$
(%i10) g(1/2);
                             %gamma
(%o10)                       ------
                               2
(%i11) g2: lambda ([a], a*''b);
(%o11)                lambda([a], a %gamma)
(%i12) b: %e$
(%i13) g2(1/2);
                             %gamma
(%o13)                       ------
                               2
@end example
@itemize @bullet
@item
Express@~{o}es lambda podem ser aninhadas.
Vari@'{a}veis locais dentro de outra express@~{a}o lambda parece ser global para a express@~{a}o interna
a menos que mascarada por vari@'{a}veis locais de mesmos nomes.
@end itemize
@c ===beg===
@c h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
@c h(%pi, %gamma);
@c ===end===
@example
(%i14) h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
                                                   1
(%o14)    lambda([a, b], h2 : lambda([a], a b), h2(-))
                                                   2
(%i15) h(%pi, %gamma);
                             %gamma
(%o15)                       ------
                               2
@end example
@itemize @bullet
@item
Uma vez que @code{lambda} n@~{a}o avalia seus argumentos, a express@~{a}o lambda @code{i} abaixo
n@~{a}o define uma fun@value{cedilha}@~{a}o "multiplica@value{cedilha}@~{a}o por @code{a}".
Tanto uma fun@value{cedilha}@~{a}o pode ser definida via @code{buildq}, como na express@~{a}o lambda @code{i2} abaixo.
@end itemize
@c ===beg===
@c i: lambda ([a], lambda ([x], a*x));
@c i(1/2);
@c i2: lambda([a], buildq([a: a], lambda([x], a*x)));
@c i2(1/2);
@c i2(1/2)(%pi);
@c ===end===
@example
(%i16) i: lambda ([a], lambda ([x], a*x));
(%o16)            lambda([a], lambda([x], a x))
(%i17) i(1/2);
(%o17)                  lambda([x], a x)
(%i18) i2: lambda([a], buildq([a: a], lambda([x], a*x)));
(%o18)    lambda([a], buildq([a : a], lambda([x], a x)))
(%i19) i2(1/2);
                                     x
(%o19)                   lambda([x], -)
                                     2
(%i20) i2(1/2)(%pi);
                               %pi
(%o20)                         ---
                                2
@end example
@itemize @bullet
@item
Uma express@~{a}o lambda pode receber um n@'{u}mero vari@'{a}vel de argumentos,
os quais s@~{a}o indicados por meio de @code{[@var{L}]} como o argumento @'{u}nico ou argumento final.
Os argumentos aparecem dentro do corpo da fun@value{cedilha}@~{a}o como uma lista.
@end itemize
@c ===beg===
@c f : lambda ([aa, bb, [cc]], aa * cc + bb);
@c f (foo, %i, 17, 29, 256);
@c g : lambda ([[aa]], apply ("+", aa));
@c g (17, 29, x, y, z, %e);
@c ===end===
@example
(%i1) f : lambda ([aa, bb, [cc]], aa * cc + bb);
(%o1)          lambda([aa, bb, [cc]], aa cc + bb)
(%i2) f (foo, %i, 17, 29, 256);
(%o2)       [17 foo + %i, 29 foo + %i, 256 foo + %i]
(%i3) g : lambda ([[aa]], apply ("+", aa));
(%o3)             lambda([[aa]], apply(+, aa))
(%i4) g (17, 29, x, y, z, %e);
(%o4)                  z + y + x + %e + 46
@end example
@end deffn

@c NEEDS CLARIFICATION AND EXAMPLES
@deffn {Fun@value{cedilha}@~{a}o} local (@var{v_1}, ..., @var{v_n})
Declara as vari@'{a}veis @var{v_1}, ..., @var{v_n} para serem locais com
rela@value{cedilha}@~{a}o a todas as propriedades na declara@value{cedilha}@~{a}o na qual essa fun@value{cedilha}@~{a}o
@'{e} usada.

@code{local} n@~{a}o avalia seus argumentos.
@code{local} retorna @code{done}.

@code{local} pode somente ser usada em @code{block}, no corpo de defini@value{cedilha}@~{o}es
de fun@value{cedilha}@~{a}o ou express@~{o}es @code{lambda}, ou na fun@value{cedilha}@~{a}o @code{ev}, e somente uma
ocorr@^{e}cia @'{e} permitida em cada.

@code{local} @'{e} independente de @code{context}.

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} macroexpansion
Valor padr@~{a}o: @code{false}

@code{macroexpansion} controla se a expans@~{a}o (isto @'{e}, o valor de retorno) de uma fun@value{cedilha}@~{a}o de macro
@'{e} substitu@'{i}do pela chamada @`{a} fun@value{cedilha}@~{a}o de macro.
Uma substitui@value{cedilha}@~{a}o pode aumentar a velocidade de subseq@"{u}@^{e}nte avalia@value{cedilha}@~{o}es da express@~{a}o,
ao custo de armazenar a expans@~{a}o.

@table @code
@item false
A expans@~{a}o de uma fun@value{cedilha}@~{a}o de macro n@~{a}o @'{e} substitu@'{i}da pela chamada de fun@value{cedilha}@~{a}o de macro.
@item expand
Da primeira vez que a fun@value{cedilha}@~{a}o de macro @'{e} avaliada,
a expans@~{a}o @'{e} armazenada.
A expans@~{a}o n@~{a}o @'{e} recalculada sobre chamadas subseq@"{u}@^{e}ntes;
qualquer efeito colateral (tais como @code{print} ou atribui@value{cedilha}@~{o}es a vari@'{a}veis globais) ocorrem
somente quando chamadas @`{a} fun@value{cedilha}@~{a}o de macro forem avaliadas primeiramente.
Expans@~{o}es em uma express@~{a}o n@~{a}o afetam outras express@~{o}es
que possuem a mesma chamada @`{a} fun@value{cedilha}@~{a}o de macro.
@item displace
Na primeira vez que uma fun@value{cedilha}@~{a}o de macro @'{e} avaliada,
a expans@~{a}o @'{e} substitu@'{i}da pela chamada,
dessa forma modificando a express@~{a}o a partir da qual a fun@value{cedilha}@~{a}o de macro foi chamada.
A expans@~{a}o n@~{a}o @'{e} recalculada nas chamadas subseq@"{u}@^{e}ntes;
qualquer efeito colateral acontece somente quando a chamada @`{a} fun@value{cedilha}@~{a}o de macro for avaliada primeiramente.
Expans@~{o}es na express@~{a}o n@~{a}o afetam outras express@~{o}es
que possuem a mesma chamada @`{a} fun@value{cedilha}@~{a}o de macro.
@end table

Exemplos

Quandon @code{macroexpansion} for @code{false},
uma fun@value{cedilha}@~{a}o de macro @'{e} chamada a cada vez que a express@~{a}o que est@'{a} chamando @'{e} avaliada,
e a express@~{a}o que est@'{a} chamandon@~{a}o @'{e} modificada.

@c ===beg===
@c f (x) := h (x) / g (x);
@c g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
@c h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
@c macroexpansion: false;
@c f (a * b);
@c dispfun (f);
@c f (a * b);
@c ===end===
@example
(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
(%o2) g(x) ::= block(print("x + 99 is equal to", x), 
                                                  return(x + 99))
(%i3) h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
(%o3) h(x) ::= block(print("x - 99 is equal to", x), 
                                                  return(x - 99))
(%i4) macroexpansion: false;
(%o4)                         false
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                  h(x)
(%t6)                     f(x) := ----
                                  g(x)

(%o6)                         done
(%i7) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o7)                       --------
                            a b + 99
@end example

Quando @code{macroexpansion} for @code{expand},
uma fun@value{cedilha}@~{a}o de macro @'{e} chamada uma @'{u}nica vez,
e a express@~{a}o que est@'{a} chamando n@~{a}o @'{e} modificada.

@c ===beg===
@c f (x) := h (x) / g (x);
@c g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
@c h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
@c macroexpansion: expand;
@c f (a * b);
@c dispfun (f);
@c f (a * b);
@c ===end===
@example
(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
(%o2) g(x) ::= block(print("x + 99 is equal to", x), 
                                                  return(x + 99))
(%i3) h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
(%o3) h(x) ::= block(print("x - 99 is equal to", x), 
                                                  return(x - 99))
(%i4) macroexpansion: expand;
(%o4)                        expand
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                  h(x)
(%t6)                     f(x) := ----
                                  g(x)

(%o6)                         done
(%i7) f (a * b);
                            a b - 99
(%o7)                       --------
                            a b + 99
@end example

Quando @code{macroexpansion} for @code{expand},
uma fun@value{cedilha}@~{a}o de macro @'{e} chamada uma @'{u}nica vez,
e a express@~{a}o que est@'{a} chamando @'{e} modificada.

@c ===beg===
@c f (x) := h (x) / g (x);
@c g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
@c h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
@c macroexpansion: displace;
@c f (a * b);
@c dispfun (f);
@c f (a * b);
@c ===end===
@example
(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
(%o2) g(x) ::= block(print("x + 99 is equal to", x), 
                                                  return(x + 99))
(%i3) h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
(%o3) h(x) ::= block(print("x - 99 is equal to", x), 
                                                  return(x - 99))
(%i4) macroexpansion: displace;
(%o4)                       displace
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                 x - 99
(%t6)                    f(x) := ------
                                 x + 99

(%o6)                         done
(%i7) f (a * b);
                            a b - 99
(%o7)                       --------
                            a b + 99
@end example

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} mode_checkp
Valor padr@~{a}o: @code{true}

@c WHAT DOES THIS MEAN ??
Quando @code{mode_checkp} @'{e} @code{true}, @code{mode_declare} verifica os modos
de associa@value{cedilha}@~{a}o de vari@'{a}veis.
@c NEED SOME EXAMPLES HERE.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} mode_check_errorp
Valor padr@~{a}o: @code{false}

@c WHAT DOES THIS MEAN ??
Quando @code{mode_check_errorp} @'{e} @code{true}, @code{mode_declare} chama
a fun@value{cedilha}@~{a}o "error".
@c NEED SOME EXAMPLES HERE.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} mode_check_warnp
Valor padr@~{a}o: @code{true}

@c WHAT DOES THIS MEAN ??
Quando @code{mode_check_warnp} @'{e} @code{true}, modo "errors" s@~{a}o
descritos.
@c NEED SOME EXAMPLES HERE.

@end defvr

@c NEEDS CLARIFICATION AND EXAMPLES
@deffn {Fun@value{cedilha}@~{a}o} mode_declare (@var{y_1}, @var{mode_1}, ..., @var{y_n}, @var{mode_n})
@code{mode_declare} @'{e} usado para declarar os modos de vari@'{a}veis e
fun@value{cedilha}@~{o}es para subseq@"{u}@^{e}nte tradu@value{cedilha}@~{a}o ou compila@value{cedilha}@~{a}o das fun@value{cedilha}@~{o}es.
@code{mode_declare} @'{e} tipicamente colocada no in@'{i}cio de uma defini@value{cedilha}@~{a}o de
fun@value{cedilha}@~{a}o, no in@'{i}cio de um script Maxima, ou executado atrav@'{e}s da linha de comando de forma interativa.

Os argumentos de @code{mode_declare} s@~{a}o pares consistindo de  uma vari@'{a}vel e o modo que @'{e}
um de @code{boolean}, @code{fixnum}, @code{number}, @code{rational}, ou @code{float}.
Cada vari@'{a}vel pode tamb@'{e}m
ser uma lista de vari@'{a}veis todas as quais s@~{a}o declaradas para ter o mesmo modo.

@c WHAT DOES THE FOLLOWING STATEMENT MEAN ???
Se uma vari@'{a}vel @'{e} um array, e se todo elemento do array que @'{e}
referenciado tiver um valor ent@~{a}o @code{array (yi, complete, dim1, dim2, ...)}
em lugar de 
@example
array(yi, dim1, dim2, ...)
@end example
dever@'{a} ser usado primeiro
declarando as associa@value{cedilha}@~{o}es do array.
@c WHAT DOES THE FOLLOWING STATEMENT MEAN ???
Se todos os elementos do array
est@~{a}o no modo @code{fixnum} (@code{float}), use @code{fixnum} (@code{float}) em lugar de @code{complete}.
@c WHAT DOES THE FOLLOWING STATEMENT MEAN ???
Tamb@'{e}m se todo elemento do array est@'{a} no mesmo modo, digamos @code{m}, ent@~{a}o

@example
mode_declare (completearray (yi), m))
@end example

dever@'{a} ser usado para uma tradu@value{cedilha}@~{a}o
eficiente.

C@'{o}digo num@'{e}ricos usando arrays podem rodar mais r@'{a}pidamente
se for decladado o tamanho esperado do array, como em:

@example
mode_declare (completearray (a [10, 10]), float)
@end example

para um array num@'{e}rico em ponto flutuante que @'{e} 10 x 10.

Pode-se declarar o modo do resultado de uma fun@value{cedilha}@~{a}o
usando @code{function (f_1, f_2, ...)} como um argumento;
aqui @code{f_1}, @code{f_2}, ...  s@~{a}o nomes
de fun@value{cedilha}@~{o}es.  Por exemplo a express@~{a}o,

@example
mode_declare ([function (f_1, f_2, ...)], fixnum)
@end example

declara que os valores retornados por @code{f_1}, @code{f_2}, ...  s@~{a}o inteiros palavra simples.

@code{modedeclare} @'{e} um sin@^{o}nimo para @code{mode_declare}.

@end deffn

@c WHAT IS THIS ABOUT ??
@c NEEDS CLARIFICATION AND EXAMPLES
@deffn {Fun@value{cedilha}@~{a}o} mode_identity (@var{arg_1}, @var{arg_2})
Uma forma especial usada com @code{mode_declare} e
@code{macros} para declarar, e.g., uma lista de listas de n@'{u}meros em ponto flutuante ou outros
objetos de dados.  O primeiro argumento para @code{mode_identity} @'{e} um valor primitivo
nome de modo como dado para @code{mode_declare} (i.e., um de @code{float}, @code{fixnum}, @code{number},
@code{list}, ou @code{any}), e o segundo argumento @'{e} uma express@~{a}o que @'{e}
avaliada e retornada com o valor de @code{mode_identity}.  Todavia, se o
valor de retorno n@~{a}o @'{e} permitido pelo modo declarado no primeiro
argumento, um erro ou alerta @'{e} sinalizado.  Um ponto importante @'{e}
que o modo da express@~{a}o como determinado pelo Maxima para o tradutor
Lisp, ser@'{a} aquele dado como o primeiro argumento, independente de
qualquer coisa que v@'{a} no segundo argumento.
E.g., @code{x: 3.3; mode_identity (fixnum, x);} retorna um erro.  @code{mode_identity (flonum, x)}
returns 3.3 .  
Isso tem n@'{u}merosas utilidades, e.g., se voc@^{e} soube que @code{first (l)} retornou um
n@'{u}mero ent@~{a}o voc@^{e} pode escrever @code{mode_identity (number, first (l))}.  Todavia,
um mais eficiente caminho para fazer isso @'{e} definir uma nova primitiva,

@example
firstnumb (x) ::= buildq ([x], mode_identity (number, x));
@end example

e usar @code{firstnumb}
toda vez que voc@^{e} pegar o primeiro de uma lista de n@'{u}meros.

@end deffn

@c IS THERE ANY REASON TO SET transcompile: false ??
@c MAYBE THIS VARIABLE COULD BE PERMANENTLY SET TO true AND STRUCK FROM THE DOCUMENTATION.
@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} transcompile
Valor padr@~{a}o: @code{true}

Quando @code{transcompile} @'{e} @code{true}, @code{translate} e @code{translate_file} geram
declara@value{cedilha}@~{o}es para fazer o c@'{o}digo traduzido mais adequado para compila@value{cedilha}@~{a}o.
@c BUT THE DECLARATIONS DON'T SEEM TO BE NECESSARY, SO WHAT'S THE POINT AGAIN ??

@code{compfile} escolhe @code{transcompile: true} para a dura@value{cedilha}@~{a}o.

@end defvr

@deffn {Fun@value{cedilha}@~{a}o} translate (@var{f_1}, ..., @var{f_n})
@deffnx {Fun@value{cedilha}@~{a}o} translate (fun@value{cedilha}@~{o}es)
@deffnx {Fun@value{cedilha}@~{a}o} translate (all)
Traduz fun@value{cedilha}@~{o}es definidas pelo usu@'{a}rio
@var{f_1}, ..., @var{f_n} da linguagem de Maxima para Lisp
e avalia a tradu@value{cedilha}@~{a}o Lisp.
Tipicamente as fun@value{cedilha}@~{o}es traduzidas executam mais r@'{a}pido que as originais.

@code{translate (all)} ou @code{translate (fun@value{cedilha}@~{o}es)} traduz todas as fun@value{cedilha}@~{o}es definidas pelo usu@'{a}rio.

Fun@value{cedilha}@~{o}es a serem traduzidas incluir~ao uma chamada para @code{mode_declare} no
in@'{i}cio quando poss@'{i}vel com o objetivo de produzir um c@'{o}digo mais eficiente.  Por
exemplo:

@example
f (x_1, x_2, ...) := block ([v_1, v_2, ...],
    mode_declare (v_1, mode_1, v_2, mode_2, ...), ...)
@end example

@noindent

quando @var{x_1}, @var{x_2}, ...  s@~{a}o par@^{a}metros para a fun@value{cedilha}@~{a}o e
@var{v_1}, @var{v_2}, ...  s@~{a}o vari@'{a}veis locais.

Os nomes de fun@value{cedilha}@~{o}es traduzidas
s@~{a}o removidos da lista @code{functions} se @code{savedef} @'{e} @code{false} (veja abaixo)
e s@~{a}o adicionados nas listas @code{props}.

Fun@value{cedilha}@~{o}es n@~{a}o poder@~{a}o ser traduzidas
a menos que elas sejam totalmente depuradas.

Express@~{o}es s@~{a}o assumidas simplificadas; se n@~{a}o forem, um c@'{o}digo correto ser@'{a} gerado mas n@~{a}o ser@'{a} um c@'{o}digo
@'{o}timo.  Dessa forma, o usu@'{a}rio n@~{a}o poder@'{a} escolher o comutador @code{simp} para @code{false}
o qual inibe simplifica@value{cedilha}@~{a}o de express@~{o}es a serem traduzidas.

O comutador @code{translate}, se @code{true}, causa tradu@value{cedilha}@~{a}o
automatica de uma fun@value{cedilha}@~{a}o de usu@'{a}rio para Lisp.

Note que fun@value{cedilha}@~{o}es
traduzidas podem n@~{a}o executar identicamente para o caminho que elas faziam antes da
tradu@value{cedilha}@~{a}o como certas incompatabilidades podem existir entre o Lisp
e vers@~{o}es do Maxima.  Principalmente, a fun@value{cedilha}@~{a}o  @code{rat} com mais de
um argumento e a fun@value{cedilha}@~{a}o @code{ratvars} n@~{a}o poder@'{a} ser usada se quaisquer
vari@'{a}veis s@~{a}o declaradas com @code{mode_declare} como sendo express@~{o}es rotacionais can@^{o}nicas(CRE).
Tamb@'{e}m a escolha @code{prederror: false}
n@~{a}o traduzir@'{a}.
@c WHAT ABOUT % AND %% ???

@code{savedef} - se @code{true} far@'{a} com que a vers@~{a}o Maxima de uma fun@value{cedilha}@~{a}o
 usu@'{a}rio permane@value{cedilha}a quando a fun@value{cedilha}@~{a}o @'{e} traduzida com @code{translate}.  Isso permite a
que defini@value{cedilha}@~{a}o seja mostrada por @code{dispfun} e autoriza a fun@value{cedilha}@~{a}o a ser
editada.

@code{transrun} - se @code{false} far@'{a} com que a vers@~{a}o interpretada de todas as
fun@value{cedilha}@~{o}es sejam executadas (desde que estejam ainda dispon@'{i}veis) em lugar da
vers@~{a}o traduzida.

O resultado retornado por @code{translate} @'{e} uma lista de nomes de
fun@value{cedilha}@~{o}es traduzidas.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} translate_file (@var{maxima_nomearquivo})
@deffnx {Fun@value{cedilha}@~{a}o} translate_file (@var{maxima_nomearquivo}, @var{lisp_nomearquivo})
Traduz um arquivo com c@'{o}digo Maxima para um arquivo com c@'{o}digo Lisp.
@code{translate_file} retorna uma lista de tr@^{e}s nomes de arquivo:
O nome do arquivo Maxima, o nome do arquivo Lisp, e o nome do arquivo
contendo informa@value{cedilha}@~{o}es adicionais sobre a tradu@value{cedilha}@~{a}o.
@code{translate_file} avalia seus argumentos.

@code{translate_file ("foo.mac"); load("foo.LISP")} @'{e} o mesmo que
@code{batch ("foo.mac")} exceto por certas restri@value{cedilha}@~{o}es,
o uso de @code{'@w{}'} e @code{%}, por exemplo.
@c FIGURE OUT WHAT THE RESTRICTIONS ARE AND STATE THEM

@code{translate_file (@var{maxima_nomearquivo})} traduz um arquivo Maxima @var{maxima_nomearquivo}
para um similarmente chamado arquivo Lisp.
Por exemplo, @code{foo.mac} @'{e} traduzido em @code{foo.LISP}.
O nome de arquivo Maxima pod incluir nome ou nomes de diret@'{o}rio(s),
nesse caso o arquivo de sa@'{i}da Lisp @'{e} escrito
para o mesmo diret@'{o}rio que a entrada Maxima.

@code{translate_file (@var{maxima_nomearquivo}, @var{lisp_nomearquivo})} traduz
um arquivo Maxima @var{maxima_nomearquivo} em um arquivo Lisp @var{lisp_nomearquivo}.
@code{translate_file} ignora a extens@~{a}o do nome do arquivo, se qualquer, de @code{lisp_nomearquivo};
a extens@~{a}o do arquivo de sa@'{i}da Lisp @'{e} sempre @code{LISP}.
O nome de arquivo Lisp pode incluir um nome ou nomes de diret@'{o}rios),
nesse caso o arquivo de sa@'{i}da Lisp @'{e} escrito para o diret@'{o}rio especificado.

@code{translate_file} tamb@'{e}m escreve um arquivo de mensagens de alerta
do tradutor em v@'{a}rios graus de severidade.
A extens@~{a}o do nome de arquivo desse arquivo @'{e} @code{UNLISP}.
Esse arquivo pode conter informa@value{cedilha}@~{a}o valiosa, apesar de possivelmente obscura,
para rastrear erros no c@'{o}digo traduzido.
O arquivo @code{UNLISP} @'{e} sempre escrito
para o mesmo diret@'{o}rio que a entrada Maxima.

@code{translate_file} emite c@'{o}digo Lisp o qual faz com que
algumas defini@value{cedilha}@~{o}es tenham efeito t@~{a}o logo
o c@'{o}digo Lisp @'{e} compilado.
Veja @code{compile_file} para mais sobre esse t@'{o}pico.

@c CHECK ALL THESE AND SEE WHICH ONES ARE OBSOLETE
Veja tamb@'{e}m @code{tr_array_as_ref},
@c tr_bind_mode_hook EXISTS BUT IT APPEARS TO BE A GROTESQUE UNDOCUMENTED HACK
@c WE DON'T WANT TO MENTION IT
@c @code{tr_bind_mode_hook}, 
@code{tr_bound_function_applyp},
@c tr_exponent EXISTS AND WORKS AS ADVERTISED IN src/troper.lisp
@c NOT OTHERWISE DOCUMENTED; ITS EFFECT SEEMS TOO WEAK TO MENTION
@code{tr_exponent},
@code{tr_file_tty_messagesp}, 
@code{tr_float_can_branch_complex},
@code{tr_function_call_default}, 
@code{tr_numer},
@code{tr_optimize_max_loop}, 
@code{tr_semicompile},
@code{tr_state_vars}, 
@code{tr_warnings_get},
@code{tr_warn_bad_function_calls},
@code{tr_warn_fexpr}, 
@code{tr_warn_meval},
@code{tr_warn_mode},
@code{tr_warn_undeclared},
e @code{tr_warn_undefined_variable}.

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} transrun
Valor padr@~{a}o: @code{true}

Quando @code{transrun} @'{e} @code{false} far@'{a} com que a vers@~{a}o
interpretada de todas as fun@value{cedilha}@~{o}es sejam executadas (desde que estejam ainda dispon@'{i}veis)
em lugar de vers@~{a}o traduzidas.

@end defvr

@c IN WHAT CONTEXT IS tr_array_as_ref: false APPROPRIATE ??? NOT SEEING THE USEFULNESS HERE.
@c ALSO, I GUESS WE SHOULD HAVE AN ITEM FOR translate_fast_arrays, ANOTHER CONFUSING FLAG ...
@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} tr_array_as_ref
Valor padr@~{a}o: @code{true}

Se @code{translate_fast_arrays} for @code{false}, refer@^{e}ncias a arrays no
C@'{o}digo Lisp emitidas por @code{translate_file} s@~{a}o afetadas por @code{tr_array_as_ref}.
Quando @code{tr_array_as_ref} @'{e} @code{true},
nomes de arrays s@~{a}o avaliados,
de outra forma nomes de arrays aparecem como s@'{i}mbolos literais no c@'{o}digo traduzido.

@code{tr_array_as_ref} n@~{a}o ter@~{a}o efeito se @code{translate_fast_arrays} for @code{true}.

@end defvr

@c WHY IS THIS FLAG NEEDED ??? UNDER WHAT CIRCUMSTANCES CAN TRANSLATION
@c OF A BOUND VARIABLE USED AS A FUNCTION GO WRONG ???
@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} tr_bound_function_applyp
Valor padr@~{a}o: @code{true}

Quando @code{tr_bound_function_applyp} for @code{true}, Maxima emite um alerta se uma associa@value{cedilha}@~{a}o
de vari@'{a}vel (tal como um argumento de fun@value{cedilha}@~{a}o) @'{e} achada sendo usada como uma fun@value{cedilha}@~{a}o.
+@c WHAT DOES THIS MEAN ??
@code{tr_bound_function_applyp} n@~{a}o afeta o c@'{o}digo gerado em tais casos.

Por exemplo, uma express@~{a}o tal como @code{g (f, x) := f (x+1)} ir@'{a} disparar
a mensagem de alerta.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} tr_file_tty_messagesp
Valor padr@~{a}o: @code{false}

Quando @code{tr_file_tty_messagesp} @'{e} @code{true},
messagens geradas por @code{translate_file} durante a tradu@value{cedilha}@~{a}o de um arquivo s@~{a}o mostradas
sobre o console e inseridas dentro do arquivo UNLISP.  
Quando @code{false}, messagens sobre tradu@value{cedilha}@~{o}es de
arquivos s@~{a}o somente inseridas dentro do arquivo UNLISP.

@end defvr

@c THIS FLAG APPEARS TO HAVE NO EFFECT.  SHOULD CUT OUT THIS ITEM AND RELATED CODE.
@c NOTE THAT THERE IS CODE IN src/transf.lisp WHICH USES THIS FLAG BUT THE MODE
@c FLAG IS LOST SOMEWHERE ALONG THE WAY TO THE LISP OUTPUT FILE.
@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} tr_float_can_branch_complex
Valor padr@~{a}o: @code{true}

Diz ao tradutor Maxima-para-Lisp assumir que as fun@value{cedilha}@~{o}es 
@code{acos}, @code{asin}, @code{asec}, e @code{acsc} podem retornar resultados complexos.

O efeito ostensivo de @code{tr_float_can_branch_complex} @'{e} mostrado adiante.
Todavia, parece que esse sinalizador n@~{a}o tem efeito sobre a sa@'{i}da do tradutor.

Quando isso for @code{true} ent@~{a}o @code{acos(x)} ser@'{a} do modo @code{any}
sempre que @code{x} for do modo @code{float} (como escolhido por @code{mode_declare}).
Quando @code{false} ent@~{a}o @code{acos(x)} ser@'{a} do modo
@code{float} se e somente se @code{x} for do modo @code{float}.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} tr_function_call_default
Valor padr@~{a}o: @code{general}

@code{false} significa abandonando e
chamando @code{meval}, @code{expr} significa que Lisp assume fun@value{cedilha}@~{a}o de argumento fixado.  @code{general}, o
c@'{o}digo padr@~{a}o dado como sendo bom para @code{mexprs} e @code{mlexprs} mas n@~{a}o @code{macros}.
@code{general} garante que associa@value{cedilha}@~{o}es de vari@'{a}vel s@~{a}o corretas em c@'{o}digos compilados.  No
modo @code{general}, quando traduzindo F(X), se F for uma vari@'{a}vel associada, ent@~{a}o isso
assumir@'{a} que @code{apply (f, [x])} @'{e} significativo, e traduz como tal, com
o alerta apropriado.  N@~{a}o @'{e} necess@'{a}rio desabilitar isso.  Com as
escolhas padr@~{a}o, sem mensagens de alerta implica compatibilidade total do
c@'{o}digo traduzido e compilado com o interpretador Maxima.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} tr_numer
Valor padr@~{a}o: @code{false}

Quando @code{tr_numer} for @code{true} propriedades @code{numer} s@~{a}o usadas para
@'{a}tomos que possuem essa propriedade, e.g. @code{%pi}.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} tr_optimize_max_loop
Valor padr@~{a}o: 100

@code{tr_optimize_max_loop} @'{e} n@'{u}mero m@'{a}ximo de vezes do
passo de macro-expans@~{a}o e otimiza@value{cedilha}@~{a}o que o tradutor ir@'{a} executar
considerando uma forma.  Isso @'{e} para capturar erros de expans@~{a}o de macro, e
propriedades de otimiza@value{cedilha}@~{a}o n@~{a}o terminadas.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} tr_semicompile
Valor padr@~{a}o: @code{false}

Quando @code{tr_semicompile} for @code{true}, as formas de sa@'{i}da de @code{translate_file}
e @code{compfile} ser@~{a}o macroexpandidas mas n@~{a}o compiladas em c@'{o}digo
de m@'{a}quina pelo compilador Lisp.

@end defvr

@c ARE ANY OF THESE OBSOLETE ??
@defvr {Vari@'{a}vel de sistema} tr_state_vars
Valor padr@~{a}o:
@example
[transcompile, tr_semicompile, tr_warn_undeclared, tr_warn_meval,
tr_warn_fexpr, tr_warn_mode, tr_warn_undefined_variable,
tr_function_call_default, tr_array_as_ref,tr_numer]
@end example

A lista de comutadores que afetam a forma de sa@'{i}da da
tradu@value{cedilha}@~{a}o.
@c DOES THE GENERAL USER REALLY CARE ABOUT DEBUGGING THE TRANSLATOR ???
Essa informa@value{cedilha}@~{a}o @'{e} @'{u}til para sistemas populares quando
tentam depurar o tradutor.  Comparando o produto traduzido
para o qual pode ter sido produzido por um dado estado, isso @'{e} poss@'{i}vel para
rastrear erros.

@end defvr

@c tr_warnings_get EXISTS AND FUNCTIONS AS ADVERTISED (SORT OF) -- RETURNS *tr-runtime-warned*
@c WHICH HAS ONLY A FEW KINDS OF WARNINGS PUSHED ONTO IT; IT'S CERTAINLY NOT COMPREHENSIVE
@c DO WE REALLY NEED THIS SLIGHTLY WORKING FUNCTION ??
@deffn {Fun@value{cedilha}@~{a}o} tr_warnings_get ()
Imprime uma lista de alertas que podem ter sido dadas pelo
tradutor durante a tradu@value{cedilha}@~{a}o corrente.

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} tr_warn_bad_function_calls
Valor padr@~{a}o: @code{true}

- Emite um alerta quando
chamadas de fun@value{cedilha}@~{a}o est@~{a}o sendo feitas por um caminho que pode n@~{a}o ser correto devido
a declara@value{cedilha}@~{o}es impr@'{o}prias que foram feitas em tempo de tradu@value{cedilha}@~{a}o.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} tr_warn_fexpr
Valor padr@~{a}o: @code{compfile}

- Emite um alerta se quaisquer FEXPRs forem
encontradas.  FEXPRs n@~{a}o poder@~{a}o normalmente ser sa@'{i}da em c@'{o}digo traduzido,
todas as formas de programa especial leg@'{i}timo s@~{a}o traduzidas.

@end defvr

@defvr {Vari@'{a}vel} tr_warn_meval
Valor padr@~{a}o: @code{compfile}

- Emite um alerta se a fun@value{cedilha}@~{a}o
@code{meval} recebe chamadas.  Se @code{meval} @'{e} chamada isso indica problemas na
tradu@value{cedilha}@~{a}o.

@end defvr

@defvr {Vari@'{a}vel} tr_warn_mode
Valor padr@~{a}o: @code{all}

- Emite um alerta quando a vari@'{a}veis forem
atribu@'{i}dos valores inapropriados para seu modo.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} tr_warn_undeclared
Valor padr@~{a}o: @code{compile}

- Determina quando enviar
alertas sobre vari@'{a}veis n@~{a}o declaradas para o TTY.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} tr_warn_undefined_variable
Valor padr@~{a}o: @code{all}

- Emite um alerta quando
vari@'{a}veis globais indefinidas forem vistas.

@end defvr

@deffn {Fun@value{cedilha}@~{a}o} compile_file (@var{nomearquivo})
@deffnx {Fun@value{cedilha}@~{a}o} compile_file (@var{nomearquivo}, @var{nomearquivo_compilado})
@deffnx {Fun@value{cedilha}@~{a}o} compile_file (@var{nomearquivo}, @var{nomearquivo_compilado}, @var{lisp_nomearquivo})
Traduz o arquivo Maxima @var{nomearquivo} para Lisp,
executa o compilador Lisp,
e, se a tradu@value{cedilha}@~{a}o e a compila@value{cedilha}@~{a}o obtiverem sucesso, chama o c@'{o}digo compilado dentro do Maxima.

@code{compile_file} retorna uma lista dos nomes de quatro arquivos:
o arquivo original do Maxima, o nome da tradu@value{cedilha}@~{a}o Lisp, uma arquivo de notas sobre a tradu@value{cedilha}@~{a}o, e o nome do arquivo que cont@'{e}m o c@'{o}digo compilado.
Se a compila@value{cedilha}@~{a}o falhar,
o quarto item @'{e} @code{false}.

Algumas declara@value{cedilha}@~{o}es e defini@value{cedilha}@~{o}es passam a ter efeito t@~{a}o logo
o c@'{o}digo Lisp seja compilado (sem que seja necess@'{a}rio chamar o c@'{o}digo compilado).
Isso inclui fun@value{cedilha}@~{o}es definidas com o operador @code{:=},
macros definidas com o operador @code{::=}, @c HEDGE -- DON'T KNOW IF THERE IS ANOTHER WAY
@code{alias}, @code{declare},
@code{define_variable},  @code{mode_declare},
e 
@code{infix}, @code{matchfix},
@code{nofix}, @code{postfix}, @code{prefix},
e @code{compfile}.

Atribui@value{cedilha}@~{o}es e chamadas de fun@value{cedilha}@~{a}o n@~{a}o ser@~{a}o avaliadas at@'{e} que o c@'{o}digo compilado seja carregado.
Em particular, dentro do arquivo Maxima,
atribui@value{cedilha}@~{o}es para sinalizadores traduzidos (@code{tr_numer}, etc.) n@~{a}o t@^{e}m efeito sobre a tradu@value{cedilha}@~{a}o.

@c @code{compile_file} may mistake warnings for errors and
@c return @code{false} as the name of the compiled code when, in fact,
@c the compilation succeeded.  This @'{e} a bug.  
@c REPORTED AS SOURCEFORGE BUG # 1103722.

@var{nomearquivo} pode n@~{a}o conter declara@value{cedilha}@~{o}es @code{:lisp}.

@code{compile_file} avalia seus argumentos.

@end deffn

@c NEEDS CLARIFICATION
@deffn {Fun@value{cedilha}@~{a}o} declare_translated (@var{f_1}, @var{f_2}, ...)
Quando traduzindo um arquivo do c@'{o}digo Maxima
para Lisp, @'{e} importante para o programa tradutor saber quais fun@value{cedilha}@~{o}es
no arquivo s@~{a}o para serem chamadas como fun@value{cedilha}@~{o}es traduzidas ou compiladas,
e quais outras s@~{a}o apenas fun@value{cedilha}@~{o}es Maxima ou indefinidas.  Colocando essa
declara@value{cedilha}@~{a}o no topo do arquivo, faremos conhecido que embora um s@'{i}mbolo
diga que n@~{a}o temos ainda um valor de fun@value{cedilha}@~{a}o Lisp, teremos uma em
tempo de chamada.  @code{(MFUNCTION-CALL fn arg1 arg2 ...)} @'{e} gerado quando
o tradutor n~ao sabe que @code{fn} est@'{a} sendo compilada para ser uma fun@value{cedilha}@~{a}o Lisp.

@end deffn

