<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on Dezembro, 3 2012 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual do Maxima: 38. Conjuntos</title>

<meta name="description" content="Manual do Maxima: 38. Conjuntos">
<meta name="keywords" content="Manual do Maxima: 38. Conjuntos">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body
{
    color: black;
    background: white; 
    margin-left: 8%;
    margin-right: 13%;
}

h1
{
    margin-left: +8%;
    font-size: 150%;
    font-family: sans-serif
}

h2
{
    font-size: 125%;
    font-family: sans-serif
}

h3
{
    font-size: 100%;
    font-family: sans-serif
}

h2,h3,h4,h5,h6 { margin-left: +4%; }

div.textbox
{
    border: solid;
    border-width: thin;
    /* width: 100%; */
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em
}

div.titlebox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
    background: rgb(200,255,255);
    font-family: sans-serif
}

div.synopsisbox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
     background: rgb(255,220,255);
    /*background: rgb(200,255,255); */
    /* font-family: fixed */
}

pre.example
{
    border: 1px solid gray;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 1em;
    padding-right: 1em;
    /* background: rgb(247,242,180); */ /* kind of sandy */
    /* background: rgb(200,255,255); */ /* sky blue */
    background-color: #F1F5F9; /* light blue-gray */
    /* font-family: "Lucida Console", monospace */
}

div.spacerbox
{
    border: none;
    padding-top: 2em;
    padding-bottom: 2em
}

div.image
{
    margin: 0;
    padding: 1em;
    text-align: center;
}

div.categorybox
{
    border: 1px solid gray;
    padding-top: 0px;
    padding-bottom: 0px;
    padding-left: 1em;
    padding-right: 1em;
    background: rgb(247,242,220);
}


-->
</style>

<link rel="icon" href="http://maxima.sourceforge.net/favicon.ico"/>
</head>

<body lang="pt" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Conjuntos"></a>
<a name="SEC151"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_37.html#SEC150" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC152" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC148" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_39.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 38. Conjuntos </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC152">38.1 Introdu&ccedil;&atilde;o a Conjuntos</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC157">38.2 Fun&ccedil;&otilde;es e Vari&aacute;veis Definidas para Conjuntos</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       
</td></tr>
</table>

<hr size="6">
<a name="Introdu_00e7_00e3o-a-Conjuntos"></a>
<a name="SEC152"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC151" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC153" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC151" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC151" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_39.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 38.1 Introdu&ccedil;&atilde;o a Conjuntos </h2>

<p>Maxima fornece fun&ccedil;&otilde;es de conjunto, tais como intersec&ccedil;&atilde;o e
uni&atilde;o, para conjuntos finitos que s&atilde;o definidos por enumera&ccedil;&atilde;o expl&iacute;citamente.
Maxima trata
listas e conjuntos como objetos distintos. Esse recurso torna poss&iacute;vel
trabalhar com conjuntos que possuem elementos que s&atilde;o ou listas ou conjuntos.
</p>
<p>Adicionalmente para fun&ccedil;&otilde;es de conjuntos finitos, Maxima fornece algumas
funoes relacionadas a an&aacute;lise combinat&oacute;ria; essas incluem os n&uacute;meros de
Stirling de primero e de segundo tipo, os n&uacute;meros de Bell, coefincientes
multinomiais, parti&ccedil;&otilde;es de inteiros n&atilde;o negativos, e umas poucas outras. 
Maxima tamb&eacute;m define uma fun&ccedil;&atilde;o delta de Kronecker.
</p>
<hr size="6">
<a name="SEC153"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC152" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC154" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC151" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC152" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_39.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 38.1.1 Utiliza&ccedil;&atilde;o </h3>

<p>Para construir um conjunto com elementos <code>a_1, ..., a_n</code>, escreva
<code>set(a_1, ..., a_n)</code> ou <code>{a_1, ..., a_n}</code>;
para construir o conjunto vazio, escreva <code>set()</code> ou <code>{}</code>.
Para inser&ccedil;&atilde;o de dados, <code>set(...)</code> e <code>{ ... }</code> s&atilde;o equivalentes.
Conjuntos s&atilde;o sempre mostrados entre chaves (<code>{ ... }</code>).
</p>
<p>Se um elemento &eacute; listado mais de uma
vez, a simplifica&ccedil;&atilde;o elimina o elemento redundante.
</p>
<pre class="example">(%i1) set();
(%o1)                          {}
(%i2) set(a, b, a);
(%o2)                        {a, b}
(%i3) set(a, set(b));
(%o3)                       {a, {b}}
(%i4) set(a, [b]);
(%o4)                       {a, [b]}
(%i5) {};
(%o5)                          {}
(%i6) {a, b, a};
(%o6)                        {a, b}
(%i7) {a, {b}};
(%o7)                       {a, {b}}
(%i8) {a, [b]};
(%o8)                       {a, [b]}
</pre>
<p>Dois elementos <var>x</var> e <var>y</var> s&atilde;o redundantes
(i.e., considerados o mesmo para prop&oacute;sito de constru&ccedil;&atilde;o de conjuntos)
se e somente se <code>is(<var>x</var> = <var>y</var>)</code> retornar <code>true</code>.
Note que <code>is(equal(<var>x</var>, <var>y</var>))</code> pode retornar <code>true</code>
enquanto <code>is(<var>x</var> = <var>y</var>)</code> retorna <code>false</code>;
nesse caso os elementos <var>x</var> e <var>y</var> s&atilde;o considerados distintos.
</p>
<pre class="example">(%i1) x: a/c + b/c;
                              b   a
(%o1)                         - + -
                              c   c
(%i2) y: a/c + b/c;
                              b   a
(%o2)                         - + -
                              c   c
(%i3) z: (a + b)/c;
                              b + a
(%o3)                         -----
                                c
(%i4) is (x = y);
(%o4)                         true
(%i5) is (y = z);
(%o5)                         false
(%i6) is (equal (y, z));
(%o6)                         true
(%i7) y - z;
                           b + a   b   a
(%o7)                    - ----- + - + -
                             c     c   c
(%i8) ratsimp (%);
(%o8)                           0
(%i9) {x, y, z};
                          b + a  b   a
(%o9)                    {-----, - + -}
                            c    c   c
</pre>
<p>Para construir um conjunto dos elementos de uma lista, use <code>setify</code>.
</p>
<pre class="example">(%i1) setify ([b, a]);
(%o1)                        {a, b}
</pre>
<p>Os elementos de conjuntos <code>x</code> e <code>y</code> s&atilde;o iguais fornecendo <code>is(x = y)</code> 
avaliando para <code>true</code>. Dessa forma <code>rat(x)</code> e <code>x</code> s&atilde;o iguais como elementos de conjuntos;
conseq&uuml;entemente, 
</p>
<pre class="example">(%i1) {x, rat(x)};
(%o1)                          {x}
</pre>
<p>Adicionalmente, uma vez que <code>is((x - 1)*(x + 1) = x^2 - 1)</code> avalia para <code>false</code>, 
<code>(x - 1)*(x + 1)</code> e <code>x^2 - 1</code> s&atilde;o distintos elementos de conjunto; dessa forma 
</p>
<pre class="example">(%i1) {(x - 1)*(x + 1), x^2 - 1};
                                       2
(%o1)               {(x - 1) (x + 1), x  - 1}
</pre>
<p>Para reduzir esse conjunto a um conjunto simples, apliquemos <code>rat</code> a cada elemeto do conjunto
</p>
<pre class="example">(%i1) {(x - 1)*(x + 1), x^2 - 1};
                                       2
(%o1)               {(x - 1) (x + 1), x  - 1}
(%i2) map (rat, %);
                              2
(%o2)/R/                    {x  - 1}
</pre>
<p>Para remover redund&acirc;ncias de outros conjuntos, voc&ecirc; pode precisar usar outras
fun&ccedil;&otilde;es de simplifica&ccedil;&atilde;o. Aqui est&aacute; um exemplo que usa <code>trigsimp</code>:
</p>
<pre class="example">(%i1) {1, cos(x)^2 + sin(x)^2};
                            2         2
(%o1)                {1, sin (x) + cos (x)}
(%i2) map (trigsimp, %);
(%o2)                          {1}
</pre>
<p>Um conjunto esta'simplificado quando seus elementos n&atilde;o s&atilde;o redundantes e
o conjunto est&aacute; ordenado. A vers&atilde;o corrente das fun&ccedil;&otilde;es de conjunto usam a fun&ccedil;&atilde;o do M&aacute;xima
<code>orderlessp</code> para ordenar conjuntos; odavia, <i>vers&otilde;es futuras das 
fun&ccedil;&otilde;es de conjunto podem usar uma fun&ccedil;&atilde;o de ordena&ccedil;&atilde;o diferente</i>.
</p>
<p>Algumas opera&ccedil;&otilde;es sobre conjuntos, tais como substitui&ccedil;&otilde;es, for&ccedil;am automaticamente a uma 
re-simplifica&ccedil;&atilde;o; por exemplo,
</p>
<pre class="example">(%i1) s: {a, b, c}$
(%i2) subst (c=a, s);
(%o2)                        {a, b}
(%i3) subst ([a=x, b=x, c=x], s);
(%o3)                          {x}
(%i4) map (lambda ([x], x^2), set (-1, 0, 1));
(%o4)                        {0, 1}
</pre>
<p>Maxima trata listas e conjuntos como objetos distintos;
fun&ccedil;&otilde;es tais como <code>union</code> e <code>intersection</code> reclamam
se qualquer argumetno n&atilde;o for um conjunto. se voc&ecirc; precisar aplicar uma fun&ccedil;&atilde;o
de conjunto a uma lista, use a fun&ccedil;&atilde;o <code>setify</code> para converter essa lsita
para um conjunto. dessa forma
</p>
<pre class="example">(%i1) union ([1, 2], {a, b});
Function union expects a set, instead found [1,2]
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i2) union (setify ([1, 2]), {a, b});
(%o2)                     {1, 2, a, b}
</pre>
<p>Para extrair todos os elemetnos de conjunto de um conjunto <code>s</code> que satisfazem um predicado
<code>f</code>, use <code>subset(s, f)</code>. (Um <i>predicado</i> &eacute; um 
uma fun&ccedil;&atilde;o que avalia para os valores booleanos <code>true</code>/<code>false</code>.) Por exemplo, para encontrar as equa&ccedil;&otilde;es 
em um dado conjunto que n&atilde;o depende de uma vari&aacute;vel <code>z</code>, use
</p>
<pre class="example">(%i1) subset ({x + y + z, x - y + 4, x + y - 5}, lambda ([e], freeof (z, e)));
(%o1)               {- y + x + 4, y + x - 5}
</pre>
<p>A se&ccedil;&atilde;o <a href="#SEC157">Fun&ccedil;&otilde;es e Vari&aacute;veis Definidas para Conjuntos</a> passui uma lista completa das
fun&ccedil;&otilde;es de conjunto no Maxima.
</p>
<hr size="6">
<a name="SEC154"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC153" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC155" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC151" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC152" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_39.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 38.1.2 Itera&ccedil;&otilde;es entre Elementos de Conjuntos </h3>

<p>Existem dois camainhos para fazer itera&ccedil;&otilde;es sobre elementos de conjuntos. Um caminho &eacute; usar
<code>map</code>; por exemplo:
</p>
<pre class="example">(%i1) map (f, {a, b, c});
(%o1)                  {f(a), f(b), f(c)}
</pre>
<p>O outro caminho &eacute; usar <code>for <var>x</var> in <var>s</var> do</code>
</p>
<pre class="example">(%i1) s: {a, b, c};
(%o1)                       {a, b, c}
(%i2) for si in s do print (concat (si, 1));
a1 
b1 
c1 
(%o2)                         done
</pre>
<p>A fun&ccedil;&atilde;o Maxima <code>first</code> e <code>rest</code> trabalham
atualmente sobre conjuntos. Aplicada a um conjunto, <code>first</code> retorna o primeiro
elemento mostrado de um conjunto; qual &eacute;lemento que &eacute; mostrado pode ser
dependente da implementa&ccedil;&atilde;o. Se <code>s</code> for um conjunto, ent&atilde;o
<code>rest(s)</code> &eacute; equivalente a <code>disjoin(first(s), s)</code>.
Atualmente, existem outras fun&ccedil;&otilde;es do Maxima que trabalham corretamente
sobre conjuntos.
Em futuras vers&otilde;es das fun&ccedil;&otilde;es de conjunto,
<code>first</code> e <code>rest</code> podem vir a funcionar diferentemente ou n&atilde;o completamente.
</p>
<hr size="6">
<a name="SEC155"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC154" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC156" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC151" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC152" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_39.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 38.1.3 Erros </h3>

<p>As fun&ccedil;&otilde;es de conjunto usam a fun&ccedil;&atilde;o Maxima <code>orderlessp</code> para 
organizar os elementos de cum conjunto e a fun&ccedil;&atilde;o (a n&iacute;vel de Lisp) <code>like</code> para testar a
igualdade entre elementos de conjuntos. Ambas essas fun&ccedil;&otilde;es possuem falhas conhecidas
que podem se manifestar se voc&ecirc; tentar usar
conjuntos com elementos que s&atilde;o listas ou matrizes que contenham express&otilde;es
na forma racional can&ocirc;nica (CRE). Um exemplo &eacute;
</p>
<pre class="example">(%i1) {[x], [rat (x)]};
Maxima encountered a Lisp error:

  The value #:X1440 is not of type LIST.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
</pre>
<p>Essa express&atilde;o faz com que o Maxima fique exitante com um erro (a mensagem de erro
depende de qual a vers&atilde;o do Lisp seu Maxima est&aacute; usando). Outro
exemplo &eacute;
</p>
<pre class="example">(%i1) setify ([[rat(a)], [rat(b)]]);
Maxima encountered a Lisp error:

  The value #:A1440 is not of type LIST.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
</pre>
<p>Essas falhas s&atilde;o causadas por falhas em <code>orderlessp</code> e <code>like</code>; elas
n&atilde;o s&atilde;o caudadas por falhas nas fun&ccedil;&otilde;es de conjunto. Para ilustrar, tente as express&otilde;es
</p>
<pre class="example">(%i1) orderlessp ([rat(a)], [rat(b)]);
Maxima encountered a Lisp error:

  The value #:B1441 is not of type LIST.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
(%i2) is ([rat(a)] = [rat(a)]);
(%o2)                         false
</pre>
<p>At&eacute; que essas falhas sejam corrigidas, n&atilde;o construa conjuntos com com elementos que
sejam listas ou matrizes contendo express&otilde;es na forma racional can&ocirc;nica (CRE); um conjunto com um 
elemento na forma CRE, todavia, pode n&atilde;o ser um problema:
</p>
<pre class="example">(%i1) {x, rat (x)};
(%o1)                          {x}
</pre>
<p>A <code>orderlessp</code> do Maxima possui outra falha que pode causr problemas
com fun&ccedil;&otilde;es de conjunto, sabidamente o predicado de ordena&ccedil;&atilde;o <code>orderlessp</code> &eacute;
n&atilde;o transitivo. o mais simples exemplo conhecido que mostra isso &eacute;
</p>
<pre class="example">(%i1) q: x^2$
(%i2) r: (x + 1)^2$
(%i3) s: x*(x + 2)$
(%i4) orderlessp (q, r);
(%o4)                         true
(%i5) orderlessp (r, s);
(%o5)                         true
(%i6) orderlessp (q, s);
(%o6)                         false
</pre>
<p>Essa falha pode causar problemas com todas as fun&ccedil;&otilde;es de conjutno bem como com
fun&ccedil;&otilde;es Maxima em geral. &Eacute; prov&aacute;vel, mas n&atilde;o certo, que 
essa falha possa ser evitada
se todos os elementos do conjunto estiverem ou na forma CRE ou tiverem sido simplificado
usando <code>ratsimp</code>.
</p>
<p>Os mecanismos <code>orderless</code> e <code>ordergreat</code> do Maxima s&atilde;o 
incompat&iacute;veis com as fun&ccedil;&otilde;es de conjunto. Se voc&ecirc; rpecisar usar ou <code>orderless</code>
ou <code>ordergreat</code>, chame todas essas fun&ccedil;&otilde;es antes de construir quaisquer conjuntos,
e n&atilde;o chame <code>unorder</code>. 
</p>

<p>Se voc&ecirc; encontrar alguma coisa que voc&ecirc; pense ser uma falha em alguma fun&ccedil;&otilde; de conjunto, por favor 
relate isso para a base de dados de falhas do Maxima. Veja <code>bug_report</code>.
</p>
<hr size="6">
<a name="SEC156"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC155" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC157" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC151" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC152" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_39.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 38.1.4 Autores </h3>

<p>Stavros Macrakis de Cambridge, Massachusetts e Barton Willis da 
Universidade e Nebraska e Kearney (UNK) escreveram as fn&ccedil;&otilde;es de conjunto do Maxima e sua
documenta&ccedil;&atilde;o. 
</p>
<hr size="6">
<a name="Fun_00e7_00f5es-e-Vari_00e1veis-Definidas-para-Conjuntos"></a>
<a name="SEC157"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC156" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_39.html#SEC158" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC151" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC151" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_39.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 38.2 Fun&ccedil;&otilde;es e Vari&aacute;veis Definidas para Conjuntos </h2>

<p><a name="adjoin"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>adjoin</b><i> (<var>x</var>, <var>a</var>) </i>
<a name="IDX1238"></a>
</dt>
<dd><p>Retorna a uni&atilde;o do conjunto <var>a</var> com <code>{<var>x</var>}</code>.
</p>
<p><code>adjoin</code> reclama se <var>a</var> n&atilde;o for um conjunto literal.
</p>
<p><code>adjoin(<var>x</var>, <var>a</var>)</code> e <code>union(set(<var>x</var>), <var>a</var>)</code>
s&atilde;o equivalentes;
todavia, <code>adjoin</code> pode ser um pouco mais r&aacute;pida que <code>union</code>.
</p>
<p>Veja tamb&eacute;m <code>disjoin</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) adjoin (c, {a, b});
(%o1)                       {a, b, c}
(%i2) adjoin (a, {a, b});
(%o2)                        {a, b}
</pre>
</dd></dl>

<p><a name="belln"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>belln</b><i> (<var>n</var>)</i>
<a name="IDX1239"></a>
</dt>
<dd><p>Representa o <em>n</em>-&eacute;simo n&uacute;mero de Bell number.
<code>belln(n)</code> &eacute; o n&uacute;mero de parti&ccedil;&otilde;es de um conjunto <var>n</var> elementos.
</p>
<p>Para inteiros n&atilde;o negativos <var>n</var>,
<code>belln(<var>n</var>)</code> simplifica para o <em>n</em>-&eacute;simo n&uacute;mero de Bell.
<code>belln</code> n&atilde;o simplifica para qualquer outro tipo de argumento.
</p>
<p><code>belln</code> distribui sobre equa&ccedil;&otilde;es, listas, matrizes e conjuntos.
</p>
<p>Exemplos:
</p>
<p><code>belln</code> aplicado a inteiros n&atilde;o negativos.
</p>
<pre class="example">(%i1) makelist (belln (i), i, 0, 6);
(%o1)               [1, 1, 2, 5, 15, 52, 203]
(%i2) is (cardinality (set_partitions ({})) = belln (0));
(%o2)                         true
(%i3) is (cardinality (set_partitions ({1, 2, 3, 4, 5, 6})) = belln (6));
(%o3)                         true
</pre>
<p><code>belln</code> aplicado a argumentos que n&atilde;o s&atilde;o inteiros n&atilde;o negativos.
</p>
<pre class="example">(%i1) [belln (x), belln (sqrt(3)), belln (-9)];
(%o1)        [belln(x), belln(sqrt(3)), belln(- 9)]
</pre>
</dd></dl>

<p><a name="cardinality"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>cardinality</b><i> (<var>a</var>)</i>
<a name="IDX1240"></a>
</dt>
<dd><p>Retorna o n&uacute;mero de elementos distintos do conjunto <var>a</var>. 
</p>
<p><code>cardinality</code> ignora elementos redundantes
mesmo quando a simplifica&ccedil;&atilde;o est&aacute; dessabilitada.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) cardinality ({});
(%o1)                           0
(%i2) cardinality ({a, a, b, c});
(%o2)                           3
(%i3) simp : false;
(%o3)                         false
(%i4) cardinality ({a, a, b, c});
(%o4)                           3
</pre>
</dd></dl>

<p><a name="cartesian_005fproduct"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>cartesian_product</b><i> (<var>b_1</var>, ... , <var>b_n</var>)</i>
<a name="IDX1241"></a>
</dt>
<dd><p>Retorna um conjunto de listas da forma <code>[<var>x_1</var>, ..., <var>x_n</var>]</code>, onde
<var>x_1</var>, ..., <var>x_n</var> s&atilde;o elementos dos conjuntos <var>b_1</var>, ... , <var>b_n</var>,
respectivamente.
</p>
<p><code>cartesian_product</code> reclama se qualquer argumento n&atilde;o for um conjunto literal.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) cartesian_product ({0, 1});
(%o1)                      {[0], [1]}
(%i2) cartesian_product ({0, 1}, {0, 1});
(%o2)           {[0, 0], [0, 1], [1, 0], [1, 1]}
(%i3) cartesian_product ({x}, {y}, {z});
(%o3)                      {[x, y, z]}
(%i4) cartesian_product ({x}, {-1, 0, 1});
(%o4)              {[x, - 1], [x, 0], [x, 1]}
</pre></dd></dl>


<p><a name="disjoin"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>disjoin</b><i> (<var>x</var>, <var>a</var>)</i>
<a name="IDX1242"></a>
</dt>
<dd><p>Retorna o conjunto <var>a</var> sem o elemento <var>x</var>.
Se <var>x</var> n&atilde;o for um elemento de <var>a</var>, retorna <var>a</var> sem modifica&ccedil;&otilde;es.
</p>
<p><code>disjoin</code> reclama se <var>a</var> n&atilde;o for um conjunto literal.
</p>
<p><code>disjoin(<var>x</var>, <var>a</var>)</code>, <code>delete(<var>x</var>, <var>a</var>)</code>, e
<code>setdifference(<var>a</var>, set(<var>x</var>))</code> s&atilde;o todos equivalentes. 
Desses, <code>disjoin</code> &eacute; geralmente mais r&aacute;pido que os outros.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) disjoin (a, {a, b, c, d});
(%o1)                       {b, c, d}
(%i2) disjoin (a + b, {5, z, a + b, %pi});
(%o2)                      {5, %pi, z}
(%i3) disjoin (a - b, {5, z, a + b, %pi});
(%o3)                  {5, %pi, b + a, z}
</pre>
</dd></dl>

<p><a name="disjointp"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>disjointp</b><i> (<var>a</var>, <var>b</var>) </i>
<a name="IDX1243"></a>
</dt>
<dd><p>Retorna <code>true</code> se e somente se os conjuntos <var>a</var> e <var>b</var> forem disjuntos.
</p>
<p><code>disjointp</code> reclama se ou <var>a</var> ou <var>b</var> n&atilde;o forem conjuntos literais.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) disjointp ({a, b, c}, {1, 2, 3});
(%o1)                         true
(%i2) disjointp ({a, b, 3}, {1, 2, 3});
(%o2)                         false
</pre>
</dd></dl>

<p><a name="divisors"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>divisors</b><i> (<var>n</var>)</i>
<a name="IDX1244"></a>
</dt>
<dd><p>Representa o conjunto dos divisores de <var>n</var>.
</p>
<p><code>divisors(<var>n</var>)</code> simplifica para um conjunto de inteiros
quando <var>n</var> for um inteiro n&atilde;o nulo.
O cojunto dos divisores inclui os elementos 1 e <var>n</var>.
Os divisores de um inteiro negativo s&atilde;o os divisores de seu valor absoluto.
</p>
<p><code>divisors</code> distribui sobre equa&ccedil;&otilde;es, listas, matrizes, e conjuntos.
</p>
<p>Exemplos:
</p>
<p>Podemos verificar que 28 &eacute; um n&uacute;mero perfeito:
a adi&ccedil;&atilde;o de seus divisores (exceto o pr&oacute;prio 28) &eacute; 28.
</p>
<pre class="example">(%i1) s: divisors(28);
(%o1)                 {1, 2, 4, 7, 14, 28}
(%i2) lreduce (&quot;+&quot;, args(s)) - 28;
(%o2)                          28
</pre>
<p><code>divisors</code> &eacute; uma fun&ccedil;&atilde;o de simplifica&ccedil;&atilde;o.
Substituindo 8 por <code>a</code> em <code>divisors(a)</code>
retorna os divisores sem fazer a reavalia&ccedil;&atilde;o de <code>divisors(8)</code>.
</p>
<pre class="example">(%i1) divisors (a);
(%o1)                      divisors(a)
(%i2) subst (8, a, %);
(%o2)                     {1, 2, 4, 8}
</pre>
<p><code>divisors</code> distribui sobre equa&ccedil;&otilde;es, listas, matrizes, e conjuntos.
</p>
<pre class="example">(%i1) divisors (a = b);
(%o1)               divisors(a) = divisors(b)
(%i2) divisors ([a, b, c]);
(%o2)        [divisors(a), divisors(b), divisors(c)]
(%i3) divisors (matrix ([a, b], [c, d]));
                  [ divisors(a)  divisors(b) ]
(%o3)             [                          ]
                  [ divisors(c)  divisors(d) ]
(%i4) divisors ({a, b, c});
(%o4)        {divisors(a), divisors(b), divisors(c)}
</pre></dd></dl>

<p><a name="elementp"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>elementp</b><i> (<var>x</var>, <var>a</var>)</i>
<a name="IDX1245"></a>
</dt>
<dd><p>Retorna <code>true</code> se e somente se <var>x</var> for um elemento do 
conjunto <var>a</var>.
</p>
<p><code>elementp</code> reclama se <var>a</var> n&atilde;o for um conjunto literal.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) elementp (sin(1), {sin(1), sin(2), sin(3)});
(%o1)                         true
(%i2) elementp (sin(1), {cos(1), cos(2), cos(3)});
(%o2)                         false
</pre>
</dd></dl>

<p><a name="emptyp"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>emptyp</b><i> (<var>a</var>)</i>
<a name="IDX1246"></a>
</dt>
<dd><p>Retorna <code>true</code> se e somente se <var>a</var> for o conjunto vazio ou
a lista vazia.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) map (emptyp, [{}, []]);
(%o1)                     [true, true]
(%i2) map (emptyp, [a + b, {{}}, %pi]);
(%o2)                 [false, false, false]
</pre></dd></dl>
       
<p><a name="equiv_005fclasses"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>equiv_classes</b><i> (<var>s</var>, <var>F</var>)</i>
<a name="IDX1247"></a>
</dt>
<dd><p>Retorna um conjunto das classes de equival&ecirc;ncias do conjunto <var>s</var> com rela&ccedil;&atilde;o
&agrave; rela&ccedil;&atilde;o de equival&ecirc;ncia <var>F</var>.
</p>
<p><var>F</var> &eacute; uma fun&ccedil;&atilde;o de duas vari&aacute;veis definida sobre o produto cartesiano <var>s</var> por <var>s</var>.
O valor de retorno de <var>F</var> &eacute; ou <code>true</code> ou <code>false</code>,
ou uma express&atilde;o <var>expr</var> tal que <code>is(<var>expr</var>)</code> &eacute; ou <code>true</code> ou <code>false</code>.
</p>
<p>Quando <var>F</var> n&otilde; for um rela&ccedil;&atilde;o de equival&ecirc;ncia,
<code>equiv_classes</code> aceita sem reclama&ccedil;&atilde;o,
mas o resultado &eacute; geralmente incorreto nesse caso.
</p>

<p>Exemplos:
</p>
<p>A rela&ccedil;&atilde;o de equival&ecirc;ncia &eacute; uma express&atilde;o lambda a qual retorna <code>true</code> ou <code>false</code>.
</p>
<pre class="example">(%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0}, lambda ([x, y], is (equal (x, y))));
(%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}
</pre>
<p>A rela&ccedil;&atilde;o de equival&ecirc;ncia &eacute; o nome de uma fun&ccedil;&atilde;o relacional
que avalia para <code>true</code> ou <code>false</code>.
</p>
<pre class="example">(%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0}, equal);
(%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}
</pre>
<p>As classes de equival&ecirc;ncia s&atilde;o n&uacute;meros que diferem por um multiplo de 3.
</p>
<pre class="example">(%i1) equiv_classes ({1, 2, 3, 4, 5, 6, 7}, lambda ([x, y], remainder (x - y, 3) = 0));
(%o1)              {{1, 4, 7}, {2, 5}, {3, 6}}
</pre></dd></dl>

<p><a name="every"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>every</b><i> (<var>f</var>, <var>s</var>)</i>
<a name="IDX1248"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>every</b><i> (<var>f</var>, <var>L_1</var>, ..., <var>L_n</var>)</i>
<a name="IDX1249"></a>
</dt>
<dd><p>Retorna <code>true</code> se o predicado <var>f</var> for <code>true</code> para todos os argumentos fornecidos.
</p>
<p>Dado um conjunto como sgundo argumento, 
<code>every(<var>f</var>, <var>s</var>)</code> retorna <code>true</code>
se <code>is(<var>f</var>(<var>a_i</var>))</code> retornar <code>true</code> para todos os <var>a_i</var> em <var>s</var>.
<code>every</code> pode ou n&atilde;o avaliar <var>f</var> para todos os <var>a_i</var> em <var>s</var>.
Uma vez que conjuntos s&atilde;o desordenados,
<code>every</code> pode avaliar <code><var>f</var>(<var>a_i</var>)</code> em qualquer ordem.
</p>
<p>Dada uma ou mais listas como argumentos,
<code>every(<var>f</var>, <var>L_1</var>, ..., <var>L_n</var>)</code> retorna <code>true</code>
se <code>is(<var>f</var>(<var>x_1</var>, ..., <var>x_n</var>))</code> retornar <code>true</code> 
para todos os <var>x_1</var>, ..., <var>x_n</var> em <var>L_1</var>, ..., <var>L_n</var>, respectivamente.
<code>every</code> pode ou n&atilde;o avaliar 
<var>f</var> para toda combina&ccedil;&atilde;o <var>x_1</var>, ..., <var>x_n</var>.
<code>every</code> avalia listas na ordem de incremento do &iacute;ndice.
</p>
<p>Dado um conjunto vazio <code>{}</code> ou uma lista vazia <code>[]</code> como argumentos,
<code>every</code> retorna <code>false</code>.
</p>
<p>Quando o sinalizador global <code>maperror</code> for <code>true</code>, todas as listas 
<var>L_1</var>, ..., <var>L_n</var> devem ter o mesmo comprimento. 
Quando <code>maperror</code> for <code>false</code>, argumentos listas s&atilde;o
efetivamente truncados para o comprimento da menor lista. 
</p>
<p>Retorna valores do predicado <var>f</var> que avaliam (via <code>is</code>)
para alguma coisa outra que n&atilde;o <code>true</code> ou <code>false</code>
s&atilde;o governados atrav&eacute;s do sinalizador global <code>prederror</code>.
Quando <code>prederror</code> for <code>true</code>,
tais valores s&atilde;o tratados como <code>false</code>,
e o valor de retorno de <code>every</code> &eacute; <code>false</code>.
Quando <code>prederror</code> for <code>false</code>,
tais valores s&atilde;o tratados como <code>unknown</code>,
e o valor de retorno de <code>every</code> &eacute; <code>unknown</code>.
</p>
<p>Exemplos:
</p>
<p><code>every</code> aplicada a um conjunto simples.
O predicado &eacute; uma fun&ccedil;&atilde;o de um argumento.
</p>
<pre class="example">(%i1) every (integerp, {1, 2, 3, 4, 5, 6});
(%o1)                         true
(%i2) every (atom, {1, 2, sin(3), 4, 5 + y, 6});
(%o2)                         false
</pre>
<p><code>every</code> aplicada a duas listas.
O predicado &eacute; uma fun&ccedil;&atilde;o de dois argumentos.
</p>
<pre class="example">(%i1) every (&quot;=&quot;, [a, b, c], [a, b, c]);
(%o1)                         true
(%i2) every (&quot;#&quot;, [a, b, c], [a, b, c]);
(%o2)                         false
</pre>
<p>Retorna valores do predicado <var>f</var> que avalia
para alguma coisa outra que n&atilde;o <code>true</code> ou <code>false</code>
s&atilde;o governados por meio do sinalizador global <code>prederror</code>.
</p>
<pre class="example">(%i1) prederror : false;
(%o1)                         false
(%i2) map (lambda ([a, b], is (a &lt; b)), [x, y, z], [x^2, y^2, z^2]);
(%o2)              [unknown, unknown, unknown]
(%i3) every (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z^2]);
(%o3)                        unknown
(%i4) prederror : true;
(%o4)                         true
(%i5) every (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z^2]);
(%o5)                         false
</pre>
</dd></dl>
 
<p><a name="extremal_005fsubset"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>extremal_subset</b><i> (<var>s</var>, <var>f</var>, max)</i>
<a name="IDX1250"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>extremal_subset</b><i> (<var>s</var>, <var>f</var>, min)</i>
<a name="IDX1251"></a>
</dt>
<dd><p>Retorna o subconjunto de <var>s</var> para o qual a fun&ccedil;&atilde;o <var>f</var> toma valore m&aacute;ximos ou m&iacute;nimos.
</p>
<p><code>extremal_subset(<var>s</var>, <var>f</var>, max)</code> retorna o subconjunto do conjunto ou 
lista <var>s</var> para os quais a fun&ccedil;&atilde;o real <var>f</var> assume valor maximo.
</p>
<p><code>extremal_subset(<var>s</var>, <var>f</var>, min)</code> retorna o subconjuno do conjunto ou 
lista <var>s</var> para a qual a fun&ccedil;&atilde;o real <var>f</var> assume valor m&iacute;nimo.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) extremal_subset ({-2, -1, 0, 1, 2}, abs, max);
(%o1)                       {- 2, 2}
(%i2) extremal_subset ({sqrt(2), 1.57, %pi/2}, sin, min);
(%o2)                       {sqrt(2)}
</pre></dd></dl>

<p><a name="flatten"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>flatten</b><i> (<var>expr</var>)</i>
<a name="IDX1252"></a>
</dt>
<dd><p>Recebe argumentos de subexpress&otilde;es que possuem o mesmo operator como <var>expr</var>
e constr&oacute;i uma express&atilde;o a partir desses argumentos coletados.
</p>
<p>subexpress&otilde;es nas quais o operador &eacute; diferente do operador principal de <code>expr</code>
s&atilde;o copiadas sem modifica&ccedil;&atilde;o,
mesmo se elas, in turn, contiverem a mesma subexpress&atilde;o na qual o operador seja o mesmo que em <code>expr</code>.
</p>
<p>Pode ser poss&iacute;vel para <code>flatten</code> construir express&otilde;es nas quais o n&uacute;mero
de argumentos difira dos argumentos declarados para um operador;
isso pode provocar uma mensagem de erro do simplificador ou do avaliador.
<code>flatten</code> n&atilde;o tenta detectar tais situa&ccedil;&otilde;es.
</p>
<p>Express&otilde;es com representa&ccedil;&otilde;es especiais, por exemplo, express&atilde;oes racionais can&ocirc;nicas (CRE), 
n&atilde;o podem usar a fun&ccedil;&atilde;o <code>flatten</code>; nesses casos, <code>flatten</code> retorna seus argumentos sem modifica&ccedil;&atilde;o.
</p>
<p>Exemplos:
</p>
<p>Aplicado a uma lista, <code>flatten</code> reune todos os elementos de lista que s&atilde;o listas.
</p>
<pre class="example">(%i1) flatten ([a, b, [c, [d, e], f], [[g, h]], i, j]);
(%o1)            [a, b, c, d, e, f, g, h, i, j]
</pre>
<p>Aplicado a um conjunto, <code>flatten</code> reune todos os elementos de conjunto que s&atilde;o conjuntos.
</p>
<pre class="example">(%i1) flatten ({a, {b}, {{c}}});
(%o1)                       {a, b, c}
(%i2) flatten ({a, {[a], {a}}});
(%o2)                       {a, [a]}
</pre>
<p><code>flatten</code> &eacute; similar ao efeito de declarar o operador principal para ser en&aacute;rio.
Todavia, <code>flatten</code> n&atilde;o faz efeito sobre subexpress&otilde;es que possuem um operador
diferente do operador principal, enquanto uma declara&ccedil;&atilde;o en&aacute;ria faz efeito.
</p>
<pre class="example">(%i1) expr: flatten (f (g (f (f (x)))));
(%o1)                     f(g(f(f(x))))
(%i2) declare (f, nary);
(%o2)                         done
(%i3) ev (expr);
(%o3)                      f(g(f(x)))
</pre>
<p><code>flatten</code> trata fun&ccedil;&otilde;es subscritas da mesma forma que qualquer outro operador.
</p>
<pre class="example">(%i1) flatten (f[5] (f[5] (x, y), z));
(%o1)                      f (x, y, z)
                            5
</pre>
<p>Pode ser poss&iacute;vel para <code>flatten</code> construir express&otilde;es nas quais o n&uacute;mero de
argumentos difira dos argumentos declarados  para um operador;
</p>
<pre class="example">(%i1) 'mod (5, 'mod (7, 4));
(%o1)                   mod(5, mod(7, 4))
(%i2) flatten (%);
(%o2)                     mod(5, 7, 4)
(%i3) ''%, nouns;
Wrong number of arguments to mod
 -- an error.  Quitting.  To debug this try debugmode(true);
</pre></dd></dl>

<p><a name="full_005flistify"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>full_listify</b><i> (<var>a</var>)</i>
<a name="IDX1253"></a>
</dt>
<dd><p>Substitui todo oeradr de conjutno em <var>a</var> por um operadro de lista,
e retorna o resultado.
<code>full_listify</code> substitui operadores de conjunto em subexpress&otilde;es restantes,
mesmo se o operadro principal n&atilde;o for conjunto (<code>set</code>).
</p>
<p><code>listify</code> substitui somente o operador principal.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) full_listify ({a, b, {c, {d, e, f}, g}});
(%o1)               [a, b, [c, [d, e, f], g]]
(%i2) full_listify (F (G ({a, b, H({c, d, e})})));
(%o2)              F(G([a, b, H([c, d, e])]))
</pre>
</dd></dl>

<p><a name="fullsetify"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>fullsetify</b><i> (<var>a</var>)</i>
<a name="IDX1254"></a>
</dt>
<dd><p>Quando <var>a</var> for uma lista, substitui o operador de lista por um operador de conjunto,
e aplica <code>fullsetify</code> a cada elemento que for um conjunto.
Quando <var>a</var> n&atilde;o for uma lista, essa n&atilde;o lista &eacute; retornada em sua forma original e sem modifica&ccedil;&otilde;es.
</p>
<p><code>setify</code> substitui somente o operador principal.
</p>
<p>Exemplos:
</p>
<p>Na linha (%o2), o argumento de <code>f</code> n&atilde;o &eacute; convertido para um conjunto
porque o operador principal de <code>f([b])</code> n&atilde;o &eacute; uma lista.
</p>
<pre class="example">(%i1) fullsetify ([a, [a]]);
(%o1)                       {a, {a}}
(%i2) fullsetify ([a, f([b])]);
(%o2)                      {a, f([b])}
</pre>
</dd></dl>

<p><a name="identity"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>identity</b><i> (<var>x</var>)</i>
<a name="IDX1255"></a>
</dt>
<dd><p>Retorna <var>x</var> para qualquer argumento <var>x</var>.
</p>
<p>Exemplos:
</p>
<p><code>identity</code> pode ser usado como um predicado quando os argumentos
forem  valores Booleanos.
</p>
<pre class="example">(%i1) every (identity, [true, true]);
(%o1)                         true
</pre></dd></dl>

<p><a name="integer_005fpartitions"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>integer_partitions</b><i> (<var>n</var>)</i>
<a name="IDX1256"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>integer_partitions</b><i> (<var>n</var>, <var>len</var>)</i>
<a name="IDX1257"></a>
</dt>
<dd><p>Retorna parti&ccedil;&otilde;es inteiras de <var>n</var>, isto &eacute;,
listas de inteiros cuja soma dos elementos de cada lista &eacute; <var>n</var>.
</p>
<p><code>integer_partitions(<var>n</var>)</code> retorna o conjunto de
todas as parti&ccedil;&otilde;es do inteiro <var>n</var>.
Cada parti&ccedil;&atilde;o &eacute; uma lista ordenada do maior para o menor.
</p>
<p><code>integer_partitions(<var>n</var>, <var>len</var>)</code>
retorna todas as parti&ccedil;&otilde;es que possuem comprimento <var>len</var> ou menor; nesse
caso, zeros s&atilde;o anexado ao final de cada parti&ccedil;&atilde;o de comprimento menor que <var>len</var>
terms to make each partition have exactly <var>len</var> terms.
Each partition is a list sorted from greatest to least.
</p>
<p>Uma lista <em>[a_1, ..., a_m]</em> &eacute; uma parti&ccedil;&atilde;o de inteiros n&atilde;o negativos
<em>n</em> quando (1) cada <em>a_i</em> &eacute; um inteiro n&atilde;o nulo, e (2) 
<em>a_1 + ... + a_m = n.</em> Dessa forma 0 n&atilde;o tem parti&ccedil;&atilde;oes.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) integer_partitions (3);
(%o1)               {[1, 1, 1], [2, 1], [3]}
(%i2) s: integer_partitions (25)$
(%i3) cardinality (s);
(%o3)                         1958
(%i4) map (lambda ([x], apply (&quot;+&quot;, x)), s);
(%o4)                         {25}
(%i5) integer_partitions (5, 3);
(%o5) {[2, 2, 1], [3, 1, 1], [3, 2, 0], [4, 1, 0], [5, 0, 0]}
(%i6) integer_partitions (5, 2);
(%o6)               {[3, 2], [4, 1], [5, 0]}
</pre>
<p>Para encontrar todas as parti&ccedil;&otilde;es que satisfazem uma condi&ccedil;&atilde;o, use a fun&ccedil;&atilde;o <code>subset</code>;
aqui est&aacute; um exemplo que encontra todas as parti&ccedil;&otilde;es de 10 cujos elementos da lista s&atilde;o n&uacute;meros primos.
</p>
<pre class="example">(%i1) s: integer_partitions (10)$
(%i2) cardinality (s);
(%o2)                          42
(%i3) xprimep(x) := integerp(x) and (x &gt; 1) and primep(x)$
(%i4) subset (s, lambda ([x], every (xprimep, x)));
(%o4) {[2, 2, 2, 2, 2], [3, 3, 2, 2], [5, 3, 2], [5, 5], [7, 3]}
</pre>
</dd></dl>

<p><a name="intersect"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>intersect</b><i> (<var>a_1</var>, ..., <var>a_n</var>)</i>
<a name="IDX1258"></a>
</dt>
<dd><p><code>intersect</code> &eacute; o mesmo que <code>intersection</code>, como veremos.
</p>
</dd></dl>

<p><a name="intersection"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>intersection</b><i> (<var>a_1</var>, ..., <var>a_n</var>)</i>
<a name="IDX1259"></a>
</dt>
<dd><p>Retorna um conjunto contendo os elementos que s&atilde;o comuns aos 
conjuntos <var>a_1</var> at&eacute; <var>a_n</var>.
</p>
<p><code>intersection</code> reclama se qualquer argumento n&atilde;o for um conjunto literal.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) S_1 : {a, b, c, d};
(%o1)                     {a, b, c, d}
(%i2) S_2 : {d, e, f, g};
(%o2)                     {d, e, f, g}
(%i3) S_3 : {c, d, e, f};
(%o3)                     {c, d, e, f}
(%i4) S_4 : {u, v, w};
(%o4)                       {u, v, w}
(%i5) intersection (S_1, S_2);
(%o5)                          {d}
(%i6) intersection (S_2, S_3);
(%o6)                       {d, e, f}
(%i7) intersection (S_1, S_2, S_3);
(%o7)                          {d}
(%i8) intersection (S_1, S_2, S_3, S_4);
(%o8)                          {}
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>kron_delta</b><i> (<var>x</var>, <var>y</var>)</i>
<a name="IDX1260"></a>
</dt>
<dd><p>Representa a fun&ccedil;&atilde;o delta de Kronecker.
</p>
<p><code>kron_delta</code> simplifica para 1 quando <var>x</var> e <var>y</var> forem identicos ou demonstadamente equivalentes,
e simplifica para 0 quando <var>x</var> e <var>y</var> demonstradamente n&atilde;o equivalentes.
De outra forma,
se n&atilde;o for certo que <var>x</var> e <var>y</var> s&atilde;o equivalentes,
e <code>kron_delta</code> simplifica para uma express&atilde;o substantiva.
<code>kron_delta</code> implementa uma pol&iacute;tica de seguran&ccedil;a para express&otilde;es em ponto flutuante:
se a diferen&ccedil;a <code><var>x</var> - <var>y</var></code> for um n&uacute;mero em ponto flutuante,
<code>kron_delta</code> simplifica para uma express&atilde;o substantiva quando <var>x</var> for aparentemente equivalente a <var>y</var>.
</p>
<p>Specificamente,
<code>kron_delta(<var>x</var>, <var>y</var>)</code> simplifica para 1
quando <code>is(x = y)</code> for <code>true</code>.
<code>kron_delta</code> tamb&eacute;m simplifica para 1
quando <code>sign(abs(<var>x</var> - <var>y</var>))</code> for <code>zero</code>
e <code><var>x</var> - <var>y</var></code> n&atilde;o for um n&uacute;mero em ponto flutuante
(e tamb&eacute;m n&atilde;o for um n&uacute;mero de precis&atilde;o simples em ponto flutuante e tamb&eacute;m n&atilde;o for um n&uacute;mero de precis&atilde;o dupla em poto flutuante, isto &eacute;, n&atilde;o for um bigfloat).
<code>kron_delta</code> simplifica para 0
quando <code>sign(abs(<var>x</var> - <var>y</var>))</code> for <code>pos</code>.
</p>
<p>De outra forma, <code>sign(abs(<var>x</var> - <var>y</var>))</code> &eacute;
alguma coisa outra que n&atilde;o <code>pos</code> ou <code>zero</code>,
ou se for <code>zero</code> e <code><var>x</var> - <var>y</var></code>
for umn&uacute;mero em ponto flutuante.
Nesses casos, <code>kron_delta</code> retorna um express&atilde;o substantiva.
</p>
<p><code>kron_delta</code> &eacute; declarada para ser sim&eacute;trica.
Isto &eacute;,
<code>kron_delta(<var>x</var>, <var>y</var>)</code> &eacute; igual a <code>kron_delta(<var>y</var>, <var>x</var>)</code>.
</p>
<p>Exemplos:
</p>
<p>Os argumentos de <code>kron_delta</code> s&atilde;o identicos.
<code>kron_delta</code> simplifica para 1.
</p>
<pre class="example">(%i1) kron_delta (a, a);
(%o1)                           1
(%i2) kron_delta (x^2 - y^2, x^2 - y^2);
(%o2)                           1
(%i3) float (kron_delta (1/10, 0.1));
(%o3)                           1
</pre>
<p>Os argumentos de <code>kron_delta</code> s&atilde;o equivalentes,
e a diferen&ccedil;a entre eles n&atilde;o &eacute; um n&uacute;mero em ponto flutuante.
<code>kron_delta</code> simplifica para 1.
</p>
<pre class="example">(%i1) assume (equal (x, y));
(%o1)                     [equal(x, y)]
(%i2) kron_delta (x, y);
(%o2)                           1
</pre>
<p>Os argumentos de <code>kron_delta</code> n&atilde;o s&atilde;o equivalentes.
<code>kron_delta</code> simplifica para 0.
</p>
<pre class="example">(%i1) kron_delta (a + 1, a);
(%o1)                           0
(%i2) assume (a &gt; b)$
(%i3) kron_delta (a, b);
(%o3)                           0
(%i4) kron_delta (1/5, 0.7);
(%o4)                           0
</pre>
<p>Os argumentos de <code>kron_delta</code> podem ou n&atilde;o serem equivalentes.
<code>kron_delta</code> simplifica para uma express&atilde;o substantiva.
</p>
<pre class="example">(%i1) kron_delta (a, b);
(%o1)                   kron_delta(a, b)
(%i2) assume(x &gt;= y)$
(%i3) kron_delta (x, y);
(%o3)                   kron_delta(x, y)
</pre>
<p>Os argumentos de <code>kron_delta</code> s&atilde;o equivalentes,
mas a diferen&ccedil;a entre eles &eacute; um n&uacute;mero em ponto flutuante.
<code>kron_delta</code> simplifica para uma express&atilde;o substantiva.
</p>
<pre class="example">(%i1) 1/4 - 0.25;
(%o1)                          0.0
(%i2) 1/10 - 0.1;
(%o2)                          0.0
(%i3) 0.25 - 0.25b0;
Warning:  Float to bigfloat conversion of 0.25
(%o3)                         0.0b0
(%i4) kron_delta (1/4, 0.25);
                                  1
(%o4)                  kron_delta(-, 0.25)
                                  4
(%i5) kron_delta (1/10, 0.1);
                                  1
(%o5)                  kron_delta(--, 0.1)
                                  10
(%i6) kron_delta (0.25, 0.25b0);
Warning:  Float to bigfloat conversion of 0.25
(%o6)               kron_delta(0.25, 2.5b-1)
</pre>
<p><code>kron_delta</code> &eacute; sim&eacute;trica.
</p>
<pre class="example">(%i1) kron_delta (x, y);
(%o1)                   kron_delta(x, y)
(%i2) kron_delta (y, x);
(%o2)                   kron_delta(x, y)
(%i3) kron_delta (x, y) - kron_delta (y, x);
(%o3)                           0
(%i4) is (equal (kron_delta (x, y), kron_delta (y, x)));
(%o4)                         true
(%i5) is (kron_delta (x, y) = kron_delta (y, x));
(%o5)                         true
</pre>
</dd></dl>

<p><a name="listify"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>listify</b><i> (<var>a</var>)</i>
<a name="IDX1261"></a>
</dt>
<dd><p>Retorna uma lista contendo os elementos de <var>a</var> quando <var>a</var> for um conjunto.
De outra forma, <code>listify</code> retorna <var>a</var>.
</p>
<p><code>full_listify</code> substitui todos os operadores de conjunto em <var>a</var> por operadores de lista.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) listify ({a, b, c, d});
(%o1)                     [a, b, c, d]
(%i2) listify (F ({a, b, c, d}));
(%o2)                    F({a, b, c, d})
</pre>
</dd></dl>

<p><a name="lreduce"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>lreduce</b><i> (<var>F</var>, <var>s</var>)</i>
<a name="IDX1262"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>lreduce</b><i> (<var>F</var>, <var>s</var>, <var>s_0</var>)</i>
<a name="IDX1263"></a>
</dt>
<dd><p>Extende a fun&ccedil;&atilde;o de dois operadores <var>F</var> para uma fun&ccedil;&atilde;o de <code>n</code> operadores usando composi&ccedil;&atilde;o,
onde <var>s</var> &eacute; uma lista.
</p>
<p><code>lreduce(<var>F</var>, <var>s</var>)</code> returns <code>F(... F(F(s_1, s_2), s_3), ... s_n)</code>.
Quando o argumento opcional <var>s_0</var> estiver presente,
o resultado &eacute; equivalente a <code>lreduce(<var>F</var>, cons(<var>s_0</var>, <var>s</var>))</code>.
</p>
<p>A fun&ccedil;&atilde;o <var>F</var> &eacute; primeiramente aplicada &agrave;
lista de elementos <i>leftmost - mais &agrave; esquerda</i>, da&iacute; o nome &quot;lreduce&quot;. 
</p>
<p>Veja tamb&eacute;m <code>rreduce</code>, <code>xreduce</code>, e <code>tree_reduce</code>.
</p>
<p>Exemplos:
</p>
<p><code>lreduce</code> sem o argumento opcional.
</p>
<pre class="example">(%i1) lreduce (f, [1, 2, 3]);
(%o1)                     f(f(1, 2), 3)
(%i2) lreduce (f, [1, 2, 3, 4]);
(%o2)                  f(f(f(1, 2), 3), 4)
</pre>
<p><code>lreduce</code> com o argumento opcional.
</p>
<pre class="example">(%i1) lreduce (f, [1, 2, 3], 4);
(%o1)                  f(f(f(4, 1), 2), 3)
</pre>
<p><code>lreduce</code> aplicada a operadores de dois argumentos internos (j&aacute; definidos por padr&atilde;o) do Maxima.
<code>/</code> &eacute; o operador de divis&atilde;o.
</p>
<pre class="example">(%i1) lreduce (&quot;^&quot;, args ({a, b, c, d}));
                               b c d
(%o1)                       ((a ) )
(%i2) lreduce (&quot;/&quot;, args ({a, b, c, d}));
                                a
(%o2)                         -----
                              b c d
</pre>
</dd></dl>

<p><a name="makeset"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>makeset</b><i> (<var>expr</var>, <var>x</var>, <var>s</var>)</i>
<a name="IDX1264"></a>
</dt>
<dd><p>Retorna um conjunto com elementos gerados a partir da express&atilde;o <var>expr</var>,
onde <var>x</var> &eacute; uma lista de vari&aacute;veis em <var>expr</var>,
e <var>s</var>&eacute; um conjunto ou lista de listas.
Para gerar cada elemento do conjunto,
<var>expr</var> &eacute; avaliada com as vari&aacute;veis <var>x</var> paralelamente a um elemento de <var>s</var>.
</p>
<p>Cada elemento de <var>s</var> deve ter o mesmo comprimento que <var>x</var>.
A lista de vari&aacute;veis <var>x</var> deve ser uma lista de s&iacute;mbolos, sem subscritos.
Mesmo se existir somente um s&iacute;mbolo, <var>x</var> deve ser uma lista de um elemento,
e cada elemento de <var>s</var> deve ser uma lista de um elemento.
</p>

<p>Veja tamb&eacute;m <code>makelist</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) makeset (i/j, [i, j], [[1, a], [2, b], [3, c], [4, d]]);
                           1  2  3  4
(%o1)                     {-, -, -, -}
                           a  b  c  d
(%i2) S : {x, y, z}$
(%i3) S3 : cartesian_product (S, S, S);
(%o3) {[x, x, x], [x, x, y], [x, x, z], [x, y, x], [x, y, y], 
[x, y, z], [x, z, x], [x, z, y], [x, z, z], [y, x, x], 
[y, x, y], [y, x, z], [y, y, x], [y, y, y], [y, y, z], 
[y, z, x], [y, z, y], [y, z, z], [z, x, x], [z, x, y], 
[z, x, z], [z, y, x], [z, y, y], [z, y, z], [z, z, x], 
[z, z, y], [z, z, z]}
(%i4) makeset (i + j + k, [i, j, k], S3);
(%o4) {3 x, 3 y, y + 2 x, 2 y + x, 3 z, z + 2 x, z + y + x, 
                                       z + 2 y, 2 z + x, 2 z + y}
(%i5) makeset (sin(x), [x], {[1], [2], [3]});
(%o5)               {sin(1), sin(2), sin(3)}
</pre></dd></dl>

<p><a name="moebius"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>moebius</b><i> (<var>n</var>)</i>
<a name="IDX1265"></a>
</dt>
<dd><p>Representa a fun&ccedil;&atilde;o de Moebius.
</p>
<p>Quando <var>n</var> for o produto de <em>k</em> primos distintos,
<code>moebius(<var>n</var>)</code> simplifica para <em>(-1)^k</em>;
quando <em><var>n</var> = 1</em>, simplifica para 1;
e simplifica para 0 para todos os outros inteiros positivos. 
</p>
<p><code>moebius</code> distribui sobre equa&ccedil;&otilde;es, listas, matrizes, e conjuntos.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) moebius (1);
(%o1)                           1
(%i2) moebius (2 * 3 * 5);
(%o2)                          - 1
(%i3) moebius (11 * 17 * 29 * 31);
(%o3)                           1
(%i4) moebius (2^32);
(%o4)                           0
(%i5) moebius (n);
(%o5)                      moebius(n)
(%i6) moebius (n = 12);
(%o6)                    moebius(n) = 0
(%i7) moebius ([11, 11 * 13, 11 * 13 * 15]);
(%o7)                      [- 1, 1, 1]
(%i8) moebius (matrix ([11, 12], [13, 14]));
                           [ - 1  0 ]
(%o8)                      [        ]
                           [ - 1  1 ]
(%i9) moebius ({21, 22, 23, 24});
(%o9)                      {- 1, 0, 1}
</pre>
</dd></dl>
 
<p><a name="multinomial_005fcoeff"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>multinomial_coeff</b><i> (<var>a_1</var>, ..., <var>a_n</var>)</i>
<a name="IDX1266"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>multinomial_coeff</b><i> ()</i>
<a name="IDX1267"></a>
</dt>
<dd><p>Retorna o coeficiente multinomial.
</p>
<p>Quando cada <var>a_k</var> for um inteiro n&atilde;o negativo, o coeficiente multinomial
fornece o n&uacute;mero de formas poss&iacute;veis de colocar <code><var>a_1</var> + ... + <var>a_n</var></code> 
objetos distintos em <em>n</em> caixas com <var>a_k</var> elementos na
<em>k</em>'&eacute;sima caixa. Em geral, <code>multinomial_coeff (<var>a_1</var>, ..., <var>a_n</var>)</code>
avalia para <code>(<var>a_1</var> + ... + <var>a_n</var>)!/(<var>a_1</var>! ... <var>a_n</var>!)</code>.
</p>
<p><code>multinomial_coeff()</code> (sem argumentos) avalia para 1.
</p>
<p><code>minfactorial</code> pode estar apta a simplificar o valor retornado por <code>multinomial_coeff</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) multinomial_coeff (1, 2, x);
                            (x + 3)!
(%o1)                       --------
                              2 x!
(%i2) minfactorial (%);
                     (x + 1) (x + 2) (x + 3)
(%o2)                -----------------------
                                2
(%i3) multinomial_coeff (-6, 2);
                             (- 4)!
(%o3)                       --------
                            2 (- 6)!
(%i4) minfactorial (%);
(%o4)                          10
</pre></dd></dl>

<p><a name="num_005fdistinct_005fpartitions"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>num_distinct_partitions</b><i> (<var>n</var>)</i>
<a name="IDX1268"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>num_distinct_partitions</b><i> (<var>n</var>, list)</i>
<a name="IDX1269"></a>
</dt>
<dd><p>Retorna o n;umero de parti&ccedil;&otilde;es de inteiros distintos de <var>n</var>
quando <var>n</var> for um inteiro n&atilde;o negativo.
De outra forma, <code>num_distinct_partitions</code> retorna uma express&atilde;o substantiva.
</p>
<p><code>num_distinct_partitions(<var>n</var>, list)</code> retorna uma 
lista do n&uacute;mero de parti&ccedil;&otilde;es distintas de 1, 2, 3, ..., <var>n</var>. 
</p>
<p>Uma parti&ccedil;&atilde;o distinta de <var>n</var> &eacute;
uma lista de inteiros positivos distintos <em>k_1</em>, ..., <em>k_m</em>
tais que <em><var>n</var> = k_1 + ... + k_m</em>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) num_distinct_partitions (12);
(%o1)                          15
(%i2) num_distinct_partitions (12, list);
(%o2)      [1, 1, 1, 2, 2, 3, 4, 5, 6, 8, 10, 12, 15]
(%i3) num_distinct_partitions (n);
(%o3)              num_distinct_partitions(n)
</pre>
</dd></dl>

<p><a name="num_005fpartitions"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>num_partitions</b><i> (<var>n</var>)</i>
<a name="IDX1270"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>num_partitions</b><i> (<var>n</var>, list)</i>
<a name="IDX1271"></a>
</dt>
<dd><p>Retorna o n&uacute;mero das parti&ccedil;&otilde;es inteiras de <var>n</var>
quando <var>n</var> for um inteiro n&atilde;o negativo.
De outra forma, <code>num_partitions</code> retorna uma express&atilde;o substantiva.
</p>
<p><code>num_partitions(<var>n</var>, list)</code> retorna uma
lista do n&uacute;mero de parti&ccedil;&otilde;es inteiras de 1, 2, 3, ..., <var>n</var>.
</p>
<p>Para um inteiro n&atilde;o negativo <var>n</var>, <code>num_partitions(<var>n</var>)</code> &eacute; igual a
<code>cardinality(integer_partitions(<var>n</var>))</code>; todavia, <code>num_partitions</code> 
n&atilde;o constr&oacute;i atualmente o conjunto das parti&ccedil;&otilde;es, nesse sentido <code>num_partitions</code> &eacute; mais r&aacute;pida.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) num_partitions (5) = cardinality (integer_partitions (5));
(%o1)                         7 = 7
(%i2) num_partitions (8, list);
(%o2)            [1, 1, 2, 3, 5, 7, 11, 15, 22]
(%i3) num_partitions (n);
(%o3)                   num_partitions(n)
</pre>
</dd></dl>



<p><a name="partition_005fset"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>partition_set</b><i> (<var>a</var>, <var>f</var>)</i>
<a name="IDX1272"></a>
</dt>
<dd><p>Parti&ccedil;&otilde;es do conjunto <var>a</var> que satisfazem o predicado <var>f</var>.
</p>
<p><code>partition_set</code> retorna uma lista de dois conjuntos.
O primeiro conjunto compreende os elementos de <var>a</var> para os quais <var>f</var> avalia para <code>false</code>,
e o segundo conjunto compreende quaisquer outros elementos de <var>a</var>.
<code>partition_set</code> n&atilde;o aplica <code>is</code> ao valor de retorno de <var>f</var>.
</p>
<p><code>partition_set</code> reclama se <var>a</var> n&atilde;o for um conjunto literal.
</p>
<p>Veja tamb&eacute;m <code>subset</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) partition_set ({2, 7, 1, 8, 2, 8}, evenp);
(%o1)                   [{1, 7}, {2, 8}]
(%i2) partition_set ({x, rat(y), rat(y) + z, 1}, lambda ([x], ratp(x)));
(%o2)/R/              [{1, x}, {y, y + z}]
</pre></dd></dl>

<p><a name="permutations"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>permutations</b><i> (<var>a</var>)</i>
<a name="IDX1273"></a>
</dt>
<dd><p>Retorna um conjunto todas as permuta&ccedil;&otilde;es distintas dos elementos da 
lista ou do conjunto <var>a</var>. Cada permuta&ccedil;&atilde;o &eacute; uma lista, n&atilde;o um conjunto. 
</p>
<p>Quando <var>a</var> for uma lista, elementos duplicados de <var>a</var> s&atilde;o inclu&iacute;dos
nas permuta&ccedil;&otilde;es.
</p>
<p><code>permutations</code> reclama se <var>a</var> n&atilde;o for um conjunto literal ou uma lista literal.
</p>
<p>Veja tamb&eacute;m <code>random_permutation</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) permutations ([a, a]);
(%o1)                       {[a, a]}
(%i2) permutations ([a, a, b]);
(%o2)           {[a, a, b], [a, b, a], [b, a, a]}
</pre>
</dd></dl>

<p><a name="powerset"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>powerset</b><i> (<var>a</var>)</i>
<a name="IDX1274"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>powerset</b><i> (<var>a</var>, <var>n</var>)</i>
<a name="IDX1275"></a>
</dt>
<dd><p>Retorna o conjunto de todos os dubconjuntos de <var>a</var>, ou um subconjunto de <var>a</var>.
</p>
<p><code>powerset(<var>a</var>)</code> retorna o conjunto de todos os subconjuntos do conjunto <var>a</var>.
<code>powerset(<var>a</var>)</code> tem <code>2^cardinality(<var>a</var>)</code> elementos.
</p>
<p><code>powerset(<var>a</var>, <var>n</var>)</code> retorna o conjunto de todos os subconjuntos de <var>a</var> que possuem 
cardinalidade <var>n</var>.
</p>
<p><code>powerset</code> reclama se <var>a</var> n&atilde;o for um conjunto literal,
ou se <var>n</var> n&atilde;o for um inteiro n&atilde;o negativo.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) powerset ({a, b, c});
(%o1) {{}, {a}, {a, b}, {a, b, c}, {a, c}, {b}, {b, c}, {c}}
(%i2) powerset ({w, x, y, z}, 4);
(%o2)                    {{w, x, y, z}}
(%i3) powerset ({w, x, y, z}, 3);
(%o3)     {{w, x, y}, {w, x, z}, {w, y, z}, {x, y, z}}
(%i4) powerset ({w, x, y, z}, 2);
(%o4)   {{w, x}, {w, y}, {w, z}, {x, y}, {x, z}, {y, z}}
(%i5) powerset ({w, x, y, z}, 1);
(%o5)                 {{w}, {x}, {y}, {z}}
(%i6) powerset ({w, x, y, z}, 0);
(%o6)                         {{}}
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>random_permutation</b><i> (<var>a</var>)</i>
<a name="IDX1276"></a>
</dt>
<dd><p>Retorna uma permuta&ccedil;&atilde;o aleat&oacute;ria do conjunto ou da lista <var>a</var>,
como constru&iacute;do pelo algor&iacute;timo de embaralhar desenvolvido por Knuth.
</p>
<p>O valor de retorno &eacute; uma nova lista, que &eacute; diferente
da lista/conjunto original podendo inclusive ser a propria lista repetida.
Todavia, os elementos do argumento n&atilde;o s&atilde;o copiados.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) random_permutation ([a, b, c, 1, 2, 3]);
(%o1)                  [c, 1, 2, 3, a, b]
(%i2) random_permutation ([a, b, c, 1, 2, 3]);
(%o2)                  [b, 3, 1, c, a, 2]
(%i3) random_permutation ({x + 1, y + 2, z + 3});
(%o3)                 [y + 2, z + 3, x + 1]
(%i4) random_permutation ({x + 1, y + 2, z + 3});
(%o4)                 [x + 1, y + 2, z + 3]
</pre>
</dd></dl>

<p><a name="rreduce"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>rreduce</b><i> (<var>F</var>, <var>s</var>)</i>
<a name="IDX1277"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>rreduce</b><i> (<var>F</var>, <var>s</var>, <var>s_{n + 1}</var>)</i>
<a name="IDX1278"></a>
</dt>
<dd><p>Extende a fun&ccedil;&atilde;o de dois argumentos <var>F</var> para uma fun&ccedil;&atilde;o de <var>n</var> argumentos usando composi&ccedil;&atilde;o de fun&ccedil;&otilde;es,
onde <var>s</var> &eacute; uma lista.
</p>
<p><code>rreduce(<var>F</var>, <var>s</var>)</code> retorna <code>F(s_1, ... F(s_{n - 2}, F(s_{n - 1}, s_n)))</code>.
Quando o argumetno opcional <var>s_{n + 1}</var> estiver presente,
o resultado &eacute; equivalente a <code>rreduce(<var>F</var>, endcons(<var>s_{n + 1}</var>, <var>s</var>))</code>.
</p>
<p>A fun&ccedil;&atilde;o <var>F</var> &eacute; primeiro aplicada &agrave;
lista de elementos <i>mais &agrave; direita - rightmost</i>, da&iacute; o nome &quot;rreduce&quot;. 
</p>
<p>Veja tamb&eacute;m <code>lreduce</code>, <code>tree_reduce</code>, e <code>xreduce</code>.
</p>
<p>Exemplos:
</p>
<p><code>rreduce</code> sem o argumento opcional.
</p>
<pre class="example">(%i1) rreduce (f, [1, 2, 3]);
(%o1)                     f(1, f(2, 3))
(%i2) rreduce (f, [1, 2, 3, 4]);
(%o2)                  f(1, f(2, f(3, 4)))
</pre>
<p><code>rreduce</code> com o argumetno opcional.
</p>
<pre class="example">(%i1) rreduce (f, [1, 2, 3], 4);
(%o1)                  f(1, f(2, f(3, 4)))
</pre>
<p><code>rreduce</code> aplicada a operadores de dois argumentos internos ( definidos por padr&atilde;o) ao Maxima.
<code>/</code> &eacute; o operadro de divis&atilde;o.
</p>
<pre class="example">(%i1) rreduce (&quot;^&quot;, args ({a, b, c, d}));
                                 d
                                c
                               b
(%o1)                         a
(%i2) rreduce (&quot;/&quot;, args ({a, b, c, d}));
                               a c
(%o2)                          ---
                               b d
</pre>
</dd></dl>

<p><a name="setdifference"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>setdifference</b><i> (<var>a</var>, <var>b</var>)</i>
<a name="IDX1279"></a>
</dt>
<dd><p>Retorna um conjunto contendo os elementos no conjunto <var>a</var> que
n&atilde;o est&atilde;ono conjunto <var>b</var>.
</p>
<p><code>setdifference</code> reclama se ou <var>a</var> ou <var>b</var> n&atilde;o for um conjunto literal.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) S_1 : {a, b, c, x, y, z};
(%o1)                  {a, b, c, x, y, z}
(%i2) S_2 : {aa, bb, c, x, y, zz};
(%o2)                 {aa, bb, c, x, y, zz}
(%i3) setdifference (S_1, S_2);
(%o3)                       {a, b, z}
(%i4) setdifference (S_2, S_1);
(%o4)                     {aa, bb, zz}
(%i5) setdifference (S_1, S_1);
(%o5)                          {}
(%i6) setdifference (S_1, {});
(%o6)                  {a, b, c, x, y, z}
(%i7) setdifference ({}, S_1);
(%o7)                          {}
</pre>
</dd></dl>

<p><a name="setequalp"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>setequalp</b><i> (<var>a</var>, <var>b</var>)</i>
<a name="IDX1280"></a>
</dt>
<dd><p>Retorna <code>true</code> se os conjuntos <var>a</var> e <var>b</var> possuirem o mesmo n&uacute;mero de elementos
e <code>is(<var>x</var> = <var>y</var>)</code> for <code>true</code>
para <code>x</code> nos elementos de <var>a</var>
e <code>y</code> nos elementos de <var>b</var>,
considerados na ordem determinada por <code>listify</code>.
De outra forma, <code>setequalp</code> retorna <code>false</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) setequalp ({1, 2, 3}, {1, 2, 3});
(%o1)                         true
(%i2) setequalp ({a, b, c}, {1, 2, 3});
(%o2)                         false
(%i3) setequalp ({x^2 - y^2}, {(x + y) * (x - y)});
(%o3)                         false
</pre>
</dd></dl>

<p><a name="setify"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>setify</b><i> (<var>a</var>)</i>
<a name="IDX1281"></a>
</dt>
<dd><p>Constr&oacute;i um conjunto de elementos a partir da lista <var>a</var>. Elementos
duplicados da lista <var>a</var> s&atilde;o apagados e os elementos
s&atilde;o ordenados de acordo com o predicado <code>orderlessp</code>.
</p>
<p><code>setify</code> reclama se <var>a</var> n&atilde;o for uma lista literal.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) setify ([1, 2, 3, a, b, c]);
(%o1)                  {1, 2, 3, a, b, c}
(%i2) setify ([a, b, c, a, b, c]);
(%o2)                       {a, b, c}
(%i3) setify ([7, 13, 11, 1, 3, 9, 5]);
(%o3)                {1, 3, 5, 7, 9, 11, 13}
</pre>
</dd></dl>

<p><a name="setp"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>setp</b><i> (<var>a</var>)</i>
<a name="IDX1282"></a>
</dt>
<dd><p>Retorna <code>true</code> se e somente se <var>a</var> for um conjunto na interpreta&ccedil;&atilde;o do Maxima.
</p>
<p><code>setp</code> retorna <code>true</code> para conjuntos n&atilde;o simplificados (isto &eacute;, conjuntos com elementos redundantes)
e tamb&eacute;m para conjuntos simplificados.
</p>
<p><code>setp</code> &eacute; equivalente &agrave; fun&ccedil;&atilde;o do Maxima
<code>setp(a) := not atom(a) and op(a) = 'set</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) simp : false;
(%o1)                         false
(%i2) {a, a, a};
(%o2)                       {a, a, a}
(%i3) setp (%);
(%o3)                         true
</pre>
</dd></dl>

<p><a name="set_005fpartitions"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>set_partitions</b><i> (<var>a</var>)</i>
<a name="IDX1283"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>set_partitions</b><i> (<var>a</var>, <var>n</var>)</i>
<a name="IDX1284"></a>
</dt>
<dd><p>Retorna o conjunto de todas as parti&ccedil;&otilde;es de <var>a</var>, ou um subconjunto daquele conjunto de parti&ccedil;&otilde;es.
</p>
<p><code>set_partitions(<var>a</var>, <var>n</var>)</code> retorna um conjunto de todas as
decomposi&ccedil;&otilde;es de <var>a</var> em <var>n</var> subconjutnos disjuntos n&atilde;o vazios.
</p>
<p><code>set_partitions(<var>a</var>)</code> retorna o conjunto de todas as parti&ccedil;&otilde;es.
</p>
<p><code>stirling2</code> retorna a cardinalidade de um conjuntode parti&ccedil;&otilde;es de um conjunto.
</p>
<p>Um conjunto de conjuntos <em>P</em> &eacute; uma parti&ccedil;&atilde;o de um conjunto <em>S</em> quando
</p>
<ol>
<li>
cada elemento de <em>P</em> &eacute; um conjunto n&atilde;o vazio,
</li><li>
elementos distintos de <em>P</em> s&atilde;o disjuntos,
</li><li>
a uni&atilde;o dos elementos de <em>P</em> &eacute; igual a <em>S</em>.
</li></ol>

<p>Exemplos:
</p>
<p>O conjunto vazio &eacute; uma parti&ccedil;&atilde;o de si mesmo, as ondi&ccedil;&otilde;es 1 e 2 s&atilde;o &quot;vaziamente&quot; verdadeiras.
</p>
<pre class="example">(%i1) set_partitions ({});
(%o1)                         {{}}
</pre>
<p>A cardinalidade do conjunto de parti&ccedil;&otilde;es de um conjunto pode ser encontrada usando <code>stirling2</code>.
</p>
<pre class="example">(%i1) s: {0, 1, 2, 3, 4, 5}$
(%i2) p: set_partitions (s, 3)$ 
(%i3) cardinality(p) = stirling2 (6, 3);
(%o3)                        90 = 90
</pre>
<p>Cada elemento de <code>p</code> pode ter <var>n</var> = 3 elementos; vamos verificar.
</p>
<pre class="example">(%i1) s: {0, 1, 2, 3, 4, 5}$
(%i2) p: set_partitions (s, 3)$ 
(%i3) map (cardinality, p);
(%o3)                          {3}
</pre>
<p>Finalmente, para cada elementos de <code>p</code>, a uni&atilde;o de seus elementos possivelmente ser&aacute; 
igua a <code>s</code>; novamente vamos comprovar.
</p>
<pre class="example">(%i1) s: {0, 1, 2, 3, 4, 5}$
(%i2) p: set_partitions (s, 3)$ 
(%i3) map (lambda ([x], apply (union, listify (x))), p);
(%o3)                 {{0, 1, 2, 3, 4, 5}}
</pre></dd></dl>

<p><a name="some"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>some</b><i> (<var>f</var>, <var>a</var>)</i>
<a name="IDX1285"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>some</b><i> (<var>f</var>, <var>L_1</var>, ..., <var>L_n</var>)</i>
<a name="IDX1286"></a>
</dt>
<dd><p>Retorna <code>true</code> se o predicado <var>f</var> for <code>true</code> para um ou mais argumentos dados.
</p>
<p>Given one set as the second argument, 
<code>some(<var>f</var>, <var>s</var>)</code> returns <code>true</code>
if <code>is(<var>f</var>(<var>a_i</var>))</code> returns <code>true</code> for one or more <var>a_i</var> in <var>s</var>.
<code>some</code> may or may not evaluate <var>f</var> for all <var>a_i</var> in <var>s</var>.
Since sets are unordered,
<code>some</code> may evaluate <code><var>f</var>(<var>a_i</var>)</code> in any order.
</p>
<p>Dadas uma ou mais listas como argumentos,
<code>some(<var>f</var>, <var>L_1</var>, ..., <var>L_n</var>)</code> retorna <code>true</code>
se <code>is(<var>f</var>(<var>x_1</var>, ..., <var>x_n</var>))</code> retornar <code>true</code> 
para um ou mais <var>x_1</var>, ..., <var>x_n</var> em <var>L_1</var>, ..., <var>L_n</var>, respectivamente.
<code>some</code> pode ou n&atilde;o avaliar 
<var>f</var> para algumas combina&ccedil;&otilde;es <var>x_1</var>, ..., <var>x_n</var>.
<code>some</code> avalia listas na ordem do &iacute;ndice de incremento.
</p>
<p>Dado um conjunto vazio <code>{}</code> ou uma lista vazia <code>[]</code> como argumentos,
<code>some</code> retorna <code>false</code>.
</p>
<p>Quando o sinalizador global <code>maperror</code> for <code>true</code>, todas as listas
<var>L_1</var>, ..., <var>L_n</var> devem ter obrigat&oacute;riamente comprimentos iguais.
Quando <code>maperror</code> for <code>false</code>, argumentos do tipo lista s&atilde;o
efetivamente truncados para o comprimento da menor lista. 
</p>
<p>Retorna o valor de um predicado <var>f</var> o qual avalia (por meio de <code>is</code>)
para alguma coisa outra que n&atilde;o <code>true</code> ou <code>false</code>
e s&atilde;o governados pelo sinalizador global <code>prederror</code>.
Quando <code>prederror</code> for <code>true</code>,
tais valores s&atilde;o tratados como <code>false</code>.
Quando <code>prederror</code> for <code>false</code>,
tais valores s&atilde;o tratados como <code>unknown</code> (desconhecidos).
</p>
<p>Exemplos:
</p>
<p><code>some</code> aplicado a um conjunto simples.
O predicado &eacute; uma fun&ccedil;&atilde;o de um argumento.
</p>
<pre class="example">(%i1) some (integerp, {1, 2, 3, 4, 5, 6});
(%o1)                         true
(%i2) some (atom, {1, 2, sin(3), 4, 5 + y, 6});
(%o2)                         true
</pre>
<p><code>some</code> aplicada a duas listas.
O predicado &eacute; uma fun&ccedil;&atilde;o de dois argumentos.
</p>
<pre class="example">(%i1) some (&quot;=&quot;, [a, b, c], [a, b, c]);
(%o1)                         true
(%i2) some (&quot;#&quot;, [a, b, c], [a, b, c]);
(%o2)                         false
</pre>
<p>Retorna o valor do predicado <var>f</var> o qual avalia
para alguma coisa que n&atilde;o <code>true</code> ou <code>false</code>
e s&atilde;o governados atrav&eacute;s do sinalizador global <code>prederror</code>.
</p>
<pre class="example">(%i1) prederror : false;
(%o1)                         false
(%i2) map (lambda ([a, b], is (a &lt; b)), [x, y, z], [x^2, y^2, z^2]);
(%o2)              [unknown, unknown, unknown]
(%i3) some (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z^2]);
(%o3)                        unknown
(%i4) some (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z + 1]);
(%o4)                         true
(%i5) prederror : true;
(%o5)                         true
(%i6) some (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z^2]);
(%o6)                         false
(%i7) some (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z + 1]);
(%o7)                         true
</pre></dd></dl>

<p><a name="stirling1"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>stirling1</b><i> (<var>n</var>, <var>m</var>)</i>
<a name="IDX1287"></a>
</dt>
<dd><p>Representa o n&uacute;mero de Stirling de primeiro tipo.
</p>
<p>Quando <var>n</var> e <var>m</var> forem n&atilde;o negativos 
inteiros, a magnitude de <code>stirling1 (<var>n</var>, <var>m</var>)</code> &eacute; o n&uacute;mero de 
permuta&ccedil;&otilde;es de um conjunto com <var>n</var> elementos que possui <var>m</var> ciclos.
Para detalhes, veja Graham, Knuth e Patashnik <i>Concrete Mathematics</i>.
Maxima utiliza uma rela&ccedil;&atilde;o recursiva para definir <code>stirling1 (<var>n</var>, <var>m</var>)</code> para
<var>m</var> menor que 0; <code>stirling1</code> n&atilde;o &eacute; definida para <var>n</var> menor que 0 e para argumetnos
n&atilde;o inteiros.
</p>
<p><code>stirling1</code> &eacute; uma fun&ccedil;&atilde;o de simplifica&ccedil;&atilde;o.
Maxima conhece as seguintes identidades:
</p>
<ol>
<li>
<em>stirling1(0, n) = kron_delta(0, n)</em> (Ref. [1])
</li><li>
<em>stirling1(n, n) = 1</em> (Ref. [1])
</li><li>
<em>stirling1(n, n - 1) = binomial(n, 2)</em> (Ref. [1])
</li><li>
<em>stirling1(n + 1, 0) = 0</em> (Ref. [1])
</li><li>
<em>stirling1(n + 1, 1) = n!</em> (Ref. [1])
</li><li>
<em>stirling1(n + 1, 2) = 2^n  - 1</em> (Ref. [1])
</li></ol>

<p>Essas identidades s&atilde;o aplicadas quando os argumentos forem inteiros literais
ou s&iacute;mbolos declarados como inteiros, e o primeiro argumento for n&atilde;o negativo.
<code>stirling1</code> n&atilde;o simplififca para argumentos n&atilde;o inteiros.
</p>
<p>Refer&ecirc;ncias:
</p>
<p>[1] Donald Knuth, <i>The Art of Computer Programming,</i>
terceira edi&ccedil;&atilde;o, Volume 1, Se&ccedil;&atilde;o 1.2.6, Equa&ccedil;&otilde;es 48, 49, e 50.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) declare (n, integer)$
(%i2) assume (n &gt;= 0)$
(%i3) stirling1 (n, n);
(%o3)                           1
</pre>
<p><code>stirling1</code> n&atilde;o simplifica para argumentos n&atilde;o inteiros.
</p>
<pre class="example">(%i1) stirling1 (sqrt(2), sqrt(2));
(%o1)              stirling1(sqrt(2), sqrt(2))
</pre>
<p>Maxima aplica identidades a <code>stirling1</code>.
</p>
<pre class="example">(%i1) declare (n, integer)$
(%i2) assume (n &gt;= 0)$
(%i3) stirling1 (n + 1, n);
                            n (n + 1)
(%o3)                       ---------
                                2
(%i4) stirling1 (n + 1, 1);
(%o4)                          n!
</pre></dd></dl>

<p><a name="stirling2"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>stirling2</b><i> (<var>n</var>, <var>m</var>)</i>
<a name="IDX1288"></a>
</dt>
<dd><p>Representa o n&uacute;mero de Stirling de segundo tipo.
</p>
<p>Quando <var>n</var> e <var>m</var> forem inteiros
n&atilde;o negativos, <code>stirling2 (<var>n</var>, <var>m</var>)</code> &eacute; o n&uacute;mero de maneiras atrav&eacute;s dos quais um conjunto com
cardinalidade <var>n</var> pode ser particionado em <var>m</var> subconjuntos disjuntos.
Maxima utiliza uma rela&ccedil;&atilde;o recursiva para definir <code>stirling2 (<var>n</var>, <var>m</var>)</code> para
<var>m</var> menor que 0; <code>stirling2</code> &eacute; indefinida para <var>n</var> menor que 0 e para argumentos
n&atilde;o inteiros.
</p>
<p><code>stirling2</code> &eacute; uma fun&ccedil;&atilde;o de simplifica&ccedil;&atilde;o.
Maxima conhece as seguintes identidades.
</p>
<ol>
<li>
<em>stirling2(0, n) = kron_delta(0, n)</em> (Ref. [1])
</li><li>
<em>stirling2(n, n) = 1</em> (Ref. [1])
</li><li>
<em>stirling2(n, n - 1) = binomial(n, 2)</em> (Ref. [1])
</li><li>
<em>stirling2(n + 1, 1) = 1</em> (Ref. [1])
</li><li>
<em>stirling2(n + 1, 2) = 2^n  - 1</em> (Ref. [1])
</li><li>
<em>stirling2(n, 0) = kron_delta(n, 0)</em> (Ref. [2])
</li><li>
<em>stirling2(n, m) = 0</em> when <em>m &gt; n</em> (Ref. [2])
</li><li>
<em>stirling2(n, m) = sum((-1)^(m - k) binomial(m k) k^n,i,1,m) / m!</em>
onde <em>m</em> e <em>n</em> s&atilde;o inteiros, e <em>n</em> &eacute; n&atilde;o negativo. (Ref. [3])
</li></ol>

<p>Essas identidades s&atilde;o aplicadas quando os argumentos forem inteiros literais
ou s&iacute;mbolos declarados como inteiros, e o primeiro argumento for n&atilde;o negativo.
<code>stirling2</code> n&atilde;o simplifica para argumentos n&atilde;o inteiros.
</p>
<p>Refer&ecirc;ncias:
</p>
<p>[1] Donald Knuth. <i>The Art of Computer Programming</i>,
terceira edi&ccedil;&atilde;o, Volume 1, Se&ccedil;&atilde;o 1.2.6, Equa&ccedil;&otilde;es 48, 49, e 50.
</p>
<p>[2] Graham, Knuth, e Patashnik. <i>Concrete Mathematics</i>, Tabela 264.
</p>
<p>[3] Abramowitz e Stegun. <i>Handbook of Mathematical Fun&ccedil;&atilde;os</i>, Se&ccedil;&atilde;o 24.1.4.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) declare (n, integer)$
(%i2) assume (n &gt;= 0)$
(%i3) stirling2 (n, n);
(%o3)                           1
</pre>
<p><code>stirling2</code> n&atilde;o simplifica para argumentos n&atilde;o inteiros.
</p>
<pre class="example">(%i1) stirling2 (%pi, %pi);
(%o1)                  stirling2(%pi, %pi)
</pre>
<p>Maxima aplica identidades a <code>stirling2</code>.
</p>
<pre class="example">(%i1) declare (n, integer)$
(%i2) assume (n &gt;= 0)$
(%i3) stirling2 (n + 9, n + 8);
                         (n + 8) (n + 9)
(%o3)                    ---------------
                                2
(%i4) stirling2 (n + 1, 2);
                              n
(%o4)                        2  - 1
</pre></dd></dl>

<p><a name="subset"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>subset</b><i> (<var>a</var>, <var>f</var>)</i>
<a name="IDX1289"></a>
</dt>
<dd><p>Retorna o subconjuntode um conjunto <var>a</var> que satisfaz o predicado <var>f</var>. 
</p>
<p><code>subset</code> returns um conjunto which comprises the elements of <var>a</var>
for which <var>f</var> returns anything other than <code>false</code>.
<code>subset</code> does not apply <code>is</code> to the return value of <var>f</var>.
</p>
<p><code>subset</code> reclama se <var>a</var> n&atilde;o for um conjunto literal.
</p>
<p>See also <code>partition_set</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) subset ({1, 2, x, x + y, z, x + y + z}, atom);
(%o1)                     {1, 2, x, z}
(%i2) subset ({1, 2, 7, 8, 9, 14}, evenp);
(%o2)                      {2, 8, 14}
</pre>
</dd></dl>

<p><a name="subsetp"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>subsetp</b><i> (<var>a</var>, <var>b</var>)</i>
<a name="IDX1290"></a>
</dt>
<dd><p>Retorna <code>true</code> se e somente se o conjunto <var>a</var> for um subconjunto de <var>b</var>.
</p>
<p><code>subsetp</code> reclama se ou <var>a</var> ou <var>b</var> n&atilde;o forem um conjunto literal.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) subsetp ({1, 2, 3}, {a, 1, b, 2, c, 3});
(%o1)                         true
(%i2) subsetp ({a, 1, b, 2, c, 3}, {1, 2, 3});
(%o2)                         false
</pre>
</dd></dl>

<p><a name="symmdifference"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>symmdifference</b><i> (<var>a_1</var>, ..., <var>a_n</var>)</i>
<a name="IDX1291"></a>
</dt>
<dd><p>Retorna a diferen&ccedil;a sim&eacute;trica, isto &eacute;,
o conjunto dos elemetnos que ocorrem em exatamente um conjunto <var>a_k</var>.
</p>
<p>Given two arguments, <code>symmdifference(<var>a</var>, <var>b</var>)</code> is
the same as <code>union(setdifference(<var>a</var>, <var>b</var>), setdifference(<var>b</var>, <var>a</var>))</code>.
</p>
<p><code>symmdifference</code> reclama se any argument n&atilde;o for um conjunto literal.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) S_1 : {a, b, c};
(%o1)                       {a, b, c}
(%i2) S_2 : {1, b, c};
(%o2)                       {1, b, c}
(%i3) S_3 : {a, b, z};
(%o3)                       {a, b, z}
(%i4) symmdifference ();
(%o4)                          {}
(%i5) symmdifference (S_1);
(%o5)                       {a, b, c}
(%i6) symmdifference (S_1, S_2);
(%o6)                        {1, a}
(%i7) symmdifference (S_1, S_2, S_3);
(%o7)                        {1, z}
(%i8) symmdifference ({}, S_1, S_2, S_3);
(%o8)                        {1, z}
</pre>
</dd></dl>

<p><a name="tree_005freduce"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>tree_reduce</b><i> (<var>F</var>, <var>s</var>)</i>
<a name="IDX1292"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>tree_reduce</b><i> (<var>F</var>, <var>s</var>, <var>s_0</var>)</i>
<a name="IDX1293"></a>
</dt>
<dd><p>Extende a fun&ccedil;&atilde;o bin&aacute;ria <var>F</var> a uma fun&ccedil;&atilde;o en&aacute;ria atrav&eacute;s de composi&ccedil;&atilde;o,
onde <var>s</var> &eacute; um conjunto ou uma lista.
</p>
<p><code>tree_reduce</code> &eacute; equivalente ao seguinte:
Aplicar <var>F</var> a sucessivos pares de elementos
para formar uma nova lista <code>[<var>F</var>(<var>s_1</var>, <var>s_2</var>), <var>F</var>(<var>s_3</var>, <var>s_4</var>), ...]</code>,
mantendo o elemento final inalterado caso haja um n&uacute;mero &iacute;mpar de elementos.
Repetindo ent&atilde;o o processo at&eacute; que a lista esteja reduzida a um elemento simples, o qual &eacute; o valor de retorno da fun&ccedil;&atilde;o.
</p>
<p>Quando o argumento opcional <var>s_0</var> estiver presente,
o resultado &eacute; equivalente a <code>tree_reduce(<var>F</var>, cons(<var>s_0</var>, <var>s</var>)</code>.
</p>
<p>Para adi&ccedil;&otilde;es em ponto flutuante,
<code>tree_reduce</code> pode retornar uma soma que possui um menor ero de arredondamento
que <code>rreduce</code> ou <code>lreduce</code>.
</p>
<p>Os elementos da lista <var>s</var> e os resultados parciais podem ser arranjados em uma &aacute;rvore bin&aacute;ria de profundidade m&iacute;nima,
da&iacute; o nome &quot;tree_reduce&quot;.
</p>
<p>Exemplos:
</p>
<p><code>tree_reduce</code> aplicada a uma lista com um n&uacute;mero par de elementos.
</p>
<pre class="example">(%i1) tree_reduce (f, [a, b, c, d]);
(%o1)                  f(f(a, b), f(c, d))
</pre>
<p><code>tree_reduce</code> aplicada a uma lista com um n&uacute;mero &iacute;mpar de elementos.
</p>
<pre class="example">(%i1) tree_reduce (f, [a, b, c, d, e]);
(%o1)               f(f(f(a, b), f(c, d)), e)
</pre>
</dd></dl>

<p><a name="union"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>union</b><i> (<var>a_1</var>, ..., <var>a_n</var>)</i>
<a name="IDX1294"></a>
</dt>
<dd><p>Retorna a uni&atilde;o dos conjuntos de <var>a_1</var> a <var>a_n</var>. 
</p>
<p><code>union()</code> (sem argumentos) retorna o conjunto vazio.
</p>
<p><code>union</code> reclama se qualquer argumento n&atilde;o for um conjunto literal.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) S_1 : {a, b, c + d, %e};
(%o1)                   {%e, a, b, d + c}
(%i2) S_2 : {%pi, %i, %e, c + d};
(%o2)                 {%e, %i, %pi, d + c}
(%i3) S_3 : {17, 29, 1729, %pi, %i};
(%o3)                {17, 29, 1729, %i, %pi}
(%i4) union ();
(%o4)                          {}
(%i5) union (S_1);
(%o5)                   {%e, a, b, d + c}
(%i6) union (S_1, S_2);
(%o6)              {%e, %i, %pi, a, b, d + c}
(%i7) union (S_1, S_2, S_3);
(%o7)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}
(%i8) union ({}, S_1, S_2, S_3);
(%o8)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}
</pre>
</dd></dl>

<p><a name="xreduce"></a>
</p><dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>xreduce</b><i> (<var>F</var>, <var>s</var>)</i>
<a name="IDX1295"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>xreduce</b><i> (<var>F</var>, <var>s</var>, <var>s_0</var>)</i>
<a name="IDX1296"></a>
</dt>
<dd><p>Extendendo a fun&ccedil;&atilde;o <var>F</var> para uma fun&ccedil;&atilde;o en&aacute;ria por composi&ccedil;&atilde;o,
ou, se <var>F</var> j&aacute; for en&aacute;ria, aplica-se <var>F</var> a <var>s</var>.
Quando <var>F</var> n&atilde;o for en&aacute;ria, <code>xreduce</code> funciona da mesma forma que <code>lreduce</code>.
O argumento <var>s</var> &eacute; uma lista.
</p>
<p>Fun&ccedil;&otilde;es sabidamente en&aacute;rias inclui
adi&ccedil;&atilde;o <code>+</code>, multiplica&ccedil;&atilde;o <code>*</code>, <code>and</code>, <code>or</code>, <code>max</code>,
<code>min</code>, e <code>append</code>.
Fun&ccedil;&otilde;es podem tamb&eacute;m serem declaradas en&aacute;rias por meio de <code>declare(<var>F</var>, nary)</code>.
Para essas fun&ccedil;&otilde;es,
&eacute; esperado que <code>xreduce</code> seja mais r&aacute;pida que ou <code>rreduce</code> ou <code>lreduce</code>.
</p>
<p>Quando o argumento opcional <var>s_0</var> estiver presente,
o resultado &eacute; equivalente a <code>xreduce(<var>s</var>, cons(<var>s_0</var>, <var>s</var>))</code>.
</p>
<p>Adi&ccedil;&otilde;es em ponto flutuante n&atilde;o s&atilde;o exatamente associativas; quando a associatividade ocorrer,
<code>xreduce</code> aplica a adi&ccedil;&atilde;o en&aacute;ria do Maxima quando <var>s</var> contiver n&uacute;meros em ponto flutuante.
</p>
<p>Exemplos:
</p>
<p><code>xreduce</code> aplicada a uma fun&ccedil;&atilde;o sabidamente en&aacute;ria.
<code>F</code> &eacute; chamada uma vez, com todos os argumentos.
</p>
<pre class="example">(%i1) declare (F, nary);
(%o1)                         done
(%i2) F ([L]) := L;
(%o2)                      F([L]) := L
(%i3) xreduce (F, [a, b, c, d, e]);
(%o3)         [[[[[(&quot;[&quot;, simp), a], b], c], d], e]
</pre>
<p><code>xreduce</code> aplicada a uma fun&ccedil;&atilde;o n&atilde;o sabidamente en&aacute;ria.
<code>G</code> &eacute; chamada muitas vezes, com dois argumentos de cada vez.
</p>
<pre class="example">(%i1) G ([L]) := L;
(%o1)                      G([L]) := L
(%i2) xreduce (G, [a, b, c, d, e]);
(%o2)         [[[[[(&quot;[&quot;, simp), a], b], c], d], e]
(%i3) lreduce (G, [a, b, c, d, e]);
(%o3)                 [[[[a, b], c], d], e]
</pre>
</dd></dl>

<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC151" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_39.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Robert</em> on <em>Dezembro, 3 2012</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
