.TH "StdLabels.List" 3 2012-04-16 OCamldoc "OCaml library"
.SH NAME
StdLabels.List \- no description
.SH Module
Module   StdLabels.List
.SH Documentation
.sp
Module
.BI "List"
 : 
.B sig  end

.sp

.sp

.sp
.sp

.I val length 
: 
.B 'a list -> int
.sp

.sp

.I val hd 
: 
.B 'a list -> 'a
.sp

.sp

.I val tl 
: 
.B 'a list -> 'a list
.sp

.sp

.I val nth 
: 
.B 'a list -> int -> 'a
.sp

.sp

.I val rev 
: 
.B 'a list -> 'a list
.sp

.sp

.I val append 
: 
.B 'a list -> 'a list -> 'a list
.sp

.sp

.I val rev_append 
: 
.B 'a list -> 'a list -> 'a list
.sp

.sp

.I val concat 
: 
.B 'a list list -> 'a list
.sp

.sp

.I val flatten 
: 
.B 'a list list -> 'a list
.sp

.sp

.I val iter 
: 
.B f:('a -> unit) -> 'a list -> unit
.sp

.sp

.I val map 
: 
.B f:('a -> 'b) -> 'a list -> 'b list
.sp

.sp

.I val rev_map 
: 
.B f:('a -> 'b) -> 'a list -> 'b list
.sp

.sp

.I val fold_left 
: 
.B f:('a -> 'b -> 'a) -> init:'a -> 'b list -> 'a
.sp

.sp

.I val fold_right 
: 
.B f:('a -> 'b -> 'b) -> 'a list -> init:'b -> 'b
.sp

.sp

.I val iter2 
: 
.B f:('a -> 'b -> unit) -> 'a list -> 'b list -> unit
.sp

.sp

.I val map2 
: 
.B f:('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list
.sp

.sp

.I val rev_map2 
: 
.B f:('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list
.sp

.sp

.I val fold_left2 
: 
.B f:('a -> 'b -> 'c -> 'a) -> init:'a -> 'b list -> 'c list -> 'a
.sp

.sp

.I val fold_right2 
: 
.B f:('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> init:'c -> 'c
.sp

.sp

.I val for_all 
: 
.B f:('a -> bool) -> 'a list -> bool
.sp

.sp

.I val exists 
: 
.B f:('a -> bool) -> 'a list -> bool
.sp

.sp

.I val for_all2 
: 
.B f:('a -> 'b -> bool) -> 'a list -> 'b list -> bool
.sp

.sp

.I val exists2 
: 
.B f:('a -> 'b -> bool) -> 'a list -> 'b list -> bool
.sp

.sp

.I val mem 
: 
.B 'a -> set:'a list -> bool
.sp

.sp

.I val memq 
: 
.B 'a -> set:'a list -> bool
.sp

.sp

.I val find 
: 
.B f:('a -> bool) -> 'a list -> 'a
.sp

.sp

.I val filter 
: 
.B f:('a -> bool) -> 'a list -> 'a list
.sp

.sp

.I val find_all 
: 
.B f:('a -> bool) -> 'a list -> 'a list
.sp

.sp

.I val partition 
: 
.B f:('a -> bool) -> 'a list -> 'a list * 'a list
.sp

.sp

.I val assoc 
: 
.B 'a -> ('a * 'b) list -> 'b
.sp

.sp

.I val assq 
: 
.B 'a -> ('a * 'b) list -> 'b
.sp

.sp

.I val mem_assoc 
: 
.B 'a -> map:('a * 'b) list -> bool
.sp

.sp

.I val mem_assq 
: 
.B 'a -> map:('a * 'b) list -> bool
.sp

.sp

.I val remove_assoc 
: 
.B 'a -> ('a * 'b) list -> ('a * 'b) list
.sp

.sp

.I val remove_assq 
: 
.B 'a -> ('a * 'b) list -> ('a * 'b) list
.sp

.sp

.I val split 
: 
.B ('a * 'b) list -> 'a list * 'b list
.sp

.sp

.I val combine 
: 
.B 'a list -> 'b list -> ('a * 'b) list
.sp

.sp

.I val sort 
: 
.B cmp:('a -> 'a -> int) -> 'a list -> 'a list
.sp

.sp

.I val stable_sort 
: 
.B cmp:('a -> 'a -> int) -> 'a list -> 'a list
.sp

.sp

.I val fast_sort 
: 
.B cmp:('a -> 'a -> int) -> 'a list -> 'a list
.sp

.sp

.I val merge 
: 
.B cmp:('a -> 'a -> int) -> 'a list -> 'a list -> 'a list
.sp

.sp
