.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XDOTOOL 1"
.TH XDOTOOL 1 "2011-05-30" "" ""
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
xdotool \- command\-line X11 automation tool
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBxdotool\fR \fIcmd\fR \fIargs...\fR
.PP
Notation: Some documentation uses \fI[window]\fR to denote an optional
window argument. This case means that the argument, if not present, will
default to \*(L"%1\*(R". See \*(L"\s-1WINDOW\s0 \s-1STACK\s0\*(R" for what \*(L"%1\*(R" means.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBxdotool\fR lets you programatically (or manually) simulate keyboard input and
mouse activity, move and resize windows, etc. It does this using X11's
\&\s-1XTEST\s0 extension and other Xlib functions.
.PP
There is some support for Extended Window Manager Hints (aka \s-1EWMH\s0 or NetWM).
See the \*(L"\s-1EXTENDED\s0 \s-1WINDOW\s0 \s-1MANAGER\s0 \s-1HINTS\s0\*(R" section for more information.
.SH "KEYBOARD COMMANDS"
.IX Header "KEYBOARD COMMANDS"
.IP "\fBkey\fR \fI[options]\fR \fIkeystroke\fR [\fIkeystroke\fR ...]" 4
.IX Item "key [options] keystroke [keystroke ...]"
Options:
.RS 4
.IP "\fB\-\-window window\fR" 4
.IX Item "--window window"
Send keystrokes to a specific window id. You can use
\&\*(L"\s-1WINDOW\s0 \s-1STACK\s0\*(R" references like \*(L"%1\*(R" and \*(L"%@\*(R" here. If there is a window stack,
then \*(L"%1\*(R" is the default, otherwise the current window is used.
.Sp
See also: \*(L"\s-1SENDEVENT\s0 \s-1NOTES\s0\*(R" and \*(L"\s-1WINDOW\s0 \s-1STACK\s0\*(R"
.IP "\fB\-\-clearmodifiers\fR" 4
.IX Item "--clearmodifiers"
Clear modifiers before sending keystrokes. See \s-1CLEARMODIFIERS\s0 below.
.IP "\fB\-\-delay milliseconds\fR" 4
.IX Item "--delay milliseconds"
Delay between keystrokes. Default is 12ms.
.RE
.RS 4
.Sp
Type a given keystroke. Examples being \*(L"alt+r\*(R", \*(L"Control_L+J\*(R",
\&\*(L"ctrl+alt+n\*(R", \*(L"BackSpace\*(R".
.Sp
Generally, any valid X Keysym string will work. Multiple keys are
separated by '+'. Aliases exist for \*(L"alt\*(R", \*(L"ctrl\*(R", \*(L"shift\*(R", \*(L"super\*(R",
and \*(L"meta\*(R" which all map to Foo_L, such as Alt_L and Control_L, etc.
.Sp
In cases where your keyboard doesn't actually have the key you want to type,
xdotool will automatically find an unused keycode and use that to type the key.
.Sp
With respect to \*(L"\s-1COMMAND\s0 \s-1CHAINING\s0\*(R", this command consumes the remainder of the
arguments or until a new xdotool command is seen, because no xdotool commands
are valid keystrokes.
.Sp
Example: Send the keystroke \*(L"F2\*(R"
 xdotool key F2
.Sp
Example: Send 'a' with an accent over it (not on english keyboards, but still
works with xdotool)
 xdotool key Aacute
.Sp
Example: Send ctrl+l and then BackSpace as separate keystrokes:
 xdotool key ctrl+l BackSpace
.Sp
Example: Send ctrl+c to all windows matching title 'gdb' (See \*(L"\s-1COMMAND\s0 \s-1CHAINING\s0\*(R")
 xdotool search \-\-name gdb key ctrl+c
.RE
.IP "\fBkeydown\fR \fI[options]\fR \fIkeystroke\fR" 4
.IX Item "keydown [options] keystroke"
Same as above, except only keydown (press) events are sent.
.IP "\fBkeyup\fR \fIkeystroke\fR" 4
.IX Item "keyup keystroke"
Same as above, except only keyup (release) events are sent.
.IP "\fBtype\fR \fI[options]\fR \fIsomething to type\fR" 4
.IX Item "type [options] something to type"
Options:
.RS 4
.IP "\fB\-\-window windowid\fR" 4
.IX Item "--window windowid"
Send keystrokes to a specific window id. See \*(L"\s-1SENDEVENT\s0 \s-1NOTES\s0\*(R" below. The
default, if no window is given, depends on the window stack. If the window
stack is empty the current window is typed at using \s-1XTEST\s0. Otherwise, the
default is \*(L"%1\*(R" (see \*(L"\s-1WINDOW\s0 \s-1STACK\s0\*(R").
.IP "\fB\-\-delay milliseconds\fR" 4
.IX Item "--delay milliseconds"
Delay between keystrokes. Default is 12ms.
.IP "\fB\-\-clearmodifiers\fR" 4
.IX Item "--clearmodifiers"
Clear modifiers before sending keystrokes. See \s-1CLEARMODIFIERS\s0 below.
.RE
.RS 4
.Sp
Types as if you had typed it. Supports newlines and tabs (\s-1ASCII\s0 newline and
tab). Each keystroke is separated by a delay given by the \fB\-\-delay\fR option.
.Sp
With respect to \*(L"\s-1COMMAND\s0 \s-1CHAINING\s0\*(R", this command consumes the remainder of the
arguments and types them. That is, no commands can chain after 'type'.
.Sp
Example: to type 'Hello world!' you would do:
 xdotool type 'Hello world!'
.RE
.SH "MOUSE COMMANDS"
.IX Header "MOUSE COMMANDS"
.IP "\fBmousemove\fR \fI[options]\fR \fIx y \s-1OR\s0 'restore'\fR" 4
.IX Item "mousemove [options] x y OR 'restore'"
Move the mouse to the specific X and Y coordinates on the screen.
.Sp
You can move the mouse to the previous location if you specify 'restore'
instead of an X and Y coordinate. Restoring only works if you have moved
previously in this same command invocation. Further, it does not work with the
\&\-\-window option.
.Sp
For example, to click the top-left corner of the screen and move the mouse to
the original position before you moved it, use this:
 xdotool mousemove 0 0 click 1 mousemove restore
.RS 4
.IP "\fB\-\-window \s-1WINDOW\s0\fR" 4
.IX Item "--window WINDOW"
Specify a window to move relative to. Coordinates 0,0 are at the top left of
the window you choose.
.Sp
\&\*(L"\s-1WINDOW\s0 \s-1STACK\s0\*(R" references are valid here, such as \f(CW%1\fR and %@. Though, using %@
probably doesn't make sense.
.IP "\fB\-\-screen \s-1SCREEN\s0\fR" 4
.IX Item "--screen SCREEN"
Move the mouse to the specified screen to move to. This is only useful if you
have multiple screens and \s-1ARE\s0 \s-1NOT\s0 using Xinerama.
.Sp
The default is the current screen. If you specify \-\-window, the \-\-screen flag
is ignored.
.IP "\fB\-\-polar\fR" 4
.IX Item "--polar"
Use polar coordinates. This makes 'x' an angle (in degrees, 0\-360, etc) and 'y'
the distance.
.Sp
Rotation starts at 'up' (0 degrees) and rotates clockwise: 90 = right, 180 =
down, 270 = left.
.Sp
The origin defaults to the center of the current screen. If you specify a
\&\-\-window, then the origin is the center of that window.
.IP "\fB\-\-clearmodifiers\fR" 4
.IX Item "--clearmodifiers"
See \s-1CLEARMODIFIERS\s0
.IP "\fB\-\-sync\fR" 4
.IX Item "--sync"
After sending the mouse move request, wait until the mouse is actually
moved. If no movement is necessary, we will not wait. This is useful for
scripts that depend on actions being completed before moving on.
.Sp
Note: We wait until the mouse moves at all, not necessarily that it
actually reaches your intended destination. Some applications lock the 
mouse cursor to certain regions of the screen, so waiting for any movement is
better in the general case than waiting for a specific target.
.RE
.RS 4
.RE
.IP "\fBmousemove_relative\fR [options] \fIx\fR \fIy\fR" 4
.IX Item "mousemove_relative [options] x y"
Move the mouse x,y pixels relative to the current position of the mouse cursor.
.RS 4
.IP "\fB\-\-polar\fR" 4
.IX Item "--polar"
Use polar coordinates. This makes 'x' an angle (in degrees, 0\-360, etc) and 'y'
the distance.
.Sp
Rotation starts at 'up' (0 degrees) and rotates clockwise: 90 = right, 180 =
down, 270 = left.
.IP "\fB\-\-sync\fR" 4
.IX Item "--sync"
After sending the mouse move request, wait until the mouse is actually
moved. If no movement is necessary, we will not wait. This is useful for
scripts that depend on actions being completed before moving on.
.Sp
Note that we wait until the mouse moves at all, not necessarily that it
actually reaches your intended destination. Some applications lock the mouse
cursor to certain regions of the screen, so waiting for any movement is better
in the general case than waiting for a specific target.
.IP "\fB\-\-clearmodifiers\fR" 4
.IX Item "--clearmodifiers"
See \s-1CLEARMODIFIERS\s0
.RE
.RS 4
.RE
.IP "\fBclick\fR \fI[options]\fR \fIbutton\fR" 4
.IX Item "click [options] button"
Send a click, that is, a mousedown followed by mouseup for the given button
with a short delay between the two (currently 12ms).
.Sp
Buttons generally map this way: Left mouse is 1, middle is 2, right is 3,
wheel up is 4, wheel down is 5.
.RS 4
.IP "\fB\-\-clearmodifiers\fR" 4
.IX Item "--clearmodifiers"
Clear modifiers before clicking. See \s-1CLEARMODIFIERS\s0 below.
.IP "\fB\-\-repeat\fR \s-1REPEAT\s0" 4
.IX Item "--repeat REPEAT"
Specify how many times to click. Default is 1. For a double-click, use
\&'\-\-repeat 2'
.IP "\fB\-\-delay\fR \s-1MILLISECONDS\s0" 4
.IX Item "--delay MILLISECONDS"
Specify how long, in milliseconds, to delay between clicks. This option is not
used if the \fI\-\-repeat\fR flag is set to 1 (default).
.IP "\fB\-\-window\fR \s-1WINDOW\s0" 4
.IX Item "--window WINDOW"
Specify a window to send a click to. See \*(L"\s-1SENDEVENT\s0 \s-1NOTES\s0\*(R" below for caveats. Uses the
current mouse position when generating the event.
.Sp
The default, if no window is given, depends on the window stack. If the window
stack is empty the current window is typed at using \s-1XTEST\s0. Otherwise, the
default is \*(L"%1\*(R" (see \*(L"\s-1WINDOW\s0 \s-1STACK\s0\*(R").
.RE
.RS 4
.RE
.IP "\fBmousedown\fR \fI[options]\fR \fIbutton\fR" 4
.IX Item "mousedown [options] button"
Same as \fBclick\fR, except only a mouse down is sent.
.IP "\fBmouseup\fR \fI[options]\fR \fIbutton\fR" 4
.IX Item "mouseup [options] button"
Same as \fBclick\fR, except only a mouse up is sent.
.IP "\fBgetmouselocation\fR \fI[\-\-shell]\fR" 4
.IX Item "getmouselocation [--shell]"
Outputs the x, y, screen, and window id of the mouse cursor. Screen numbers will
be nonzero if you have multiple monitors and are not using Xinerama.
.RS 4
.IP "\fB\-\-shell\fR" 4
.IX Item "--shell"
This makes getmouselocation output shell data you can eval. Example:
.Sp
.Vb 5
\& % xdotool getmouselocation \-\-shell
\& X=880
\& Y=443
\& SCREEN=0
\& WINDOW=16777250
\&
\& % eval $(xdotool getmouselocation \-\-shell)
\& % echo $X,$Y
\& 714,324
.Ve
.RE
.RS 4
.RE
.IP "\fBbehave_screen_edge\fR \fI[options]\fR \fIwhere\fR \fIcommand ...\fR" 4
.IX Item "behave_screen_edge [options] where command ..."
Bind an action to events when the mouse hits the screen edge or corner.
.Sp
Options are:
.RS 4
.IP "\fI\-\-delay \s-1MILLISECONDS\s0\fR" 4
.IX Item "--delay MILLISECONDS"
Delay in milliseconds before running the command. This allows you to require
a given edge or corner to be held for a short period before your command will
run. If you leave the edge or corner before the delay expires then the time
will reset.
.IP "\fI\-\-quiesce \s-1MILLISECONDS\s0\fR" 4
.IX Item "--quiesce MILLISECONDS"
Delay in milliseconds before the next command will run. This helps prevent
accidentally running your command extra times; especially useful if you have
a very short \-\-delay (like the default of 0).
.RE
.RS 4
.Sp
Event timeline
.Sp
.Vb 5
\& * Mouse hits an edge or corner.
\& * If delay is nonzero, the mouse must stay in this edge or corner until delay time expires.
\& * If still in the edge/corner, trigger.
\& * If quiesce is nonzero, then there is a cool\-down period where the next
\&   trigger cannot occur
.Ve
.Sp
Valid 'where' values are:
.IP "left" 4
.IX Item "left"
.PD 0
.IP "top-left" 4
.IX Item "top-left"
.IP "top" 4
.IX Item "top"
.IP "top-right" 4
.IX Item "top-right"
.IP "right" 4
.IX Item "right"
.IP "bottom-left" 4
.IX Item "bottom-left"
.IP "bottom" 4
.IX Item "bottom"
.IP "bottom-right" 4
.IX Item "bottom-right"
.RE
.RS 4
.PD
.Sp
Examples:
 # Activate google-chrome when you move the mouse to the bottom-left corner:
 xdotool behave_screen_edge bottom-left \e
   search \-\-class google-chrome windowactivate
.Sp
.Vb 2
\& # Go to the next workspace (right). Known to work in GNOME (metacity and compiz)
\& xdotool behave_screen_edge \-\-delay 500 bottom\-right key XF86Forward
\&
\& # Activate firefox and do a web search in a new tab for text in your clipboard
\& xdotool behave_screen_edge \-\-delay 1000 top\-left \e
\&     search \-\-classname Navigator \e
\&     windowactivate \-\-sync key \-\-delay 250 ctrl+t ctrl+k ctrl+v Return
.Ve
.RE
.SH "WINDOW COMMANDS"
.IX Header "WINDOW COMMANDS"
.IP "\fBsearch\fR \fI[options]\fR \fIpattern\fR" 4
.IX Item "search [options] pattern"
Search for windows with titles, names, or classes with a regular expression
pattern. The output is line-delimited list of X window identifiers. If you
are using \*(L"\s-1COMMAND\s0 \s-1CHAINING\s0\*(R", the search command will only write window
ids to stdout if it is the last (or only) command in the chain; otherwise, it
is silent.
.Sp
The result is saved to the window stack for future chained commands. See
\&\*(L"\s-1WINDOW\s0 \s-1STACK\s0\*(R" and \*(L"\s-1COMMAND\s0 \s-1CHAINING\s0\*(R" for details.
.Sp
The default options are \f(CW\*(C`\-\-name \-\-class \-\-classname\*(C'\fR (unless you specify one
one or more of \-\-name \-\-class or \-\-classname).
.Sp
The options available are:
.RS 4
.IP "\fB\-\-class\fR" 4
.IX Item "--class"
Match against the window class.
.IP "\fB\-\-classname\fR" 4
.IX Item "--classname"
Match against the window classname.
.IP "\fB\-\-maxdepth\fR N" 4
.IX Item "--maxdepth N"
Set recursion/child search depth. Default is \-1,
meaning infinite. 0 means no depth, only root windows will be searched. If you
only want toplevel windows, set maxdepth of 1 (or 2, depending on how your
window manager does decorations).
.IP "\fB\-\-name\fR" 4
.IX Item "--name"
Match against the window name. This is the same string that is displayed in the
window titlebar.
.IP "\fB\-\-onlyvisible\fR" 4
.IX Item "--onlyvisible"
Show only visible windows in the results. This means ones with map state
IsViewable.
.IP "\fB\-\-pid \s-1PID\s0\fR" 4
.IX Item "--pid PID"
Match windows that belong to a specific process id. This may not work for some
X applications that do not set this metadata on its windows.
.IP "\fB\-\-screen N\fR" 4
.IX Item "--screen N"
Select windows only on a specific screen. Default is to
search all screens. Only meaningful if you have multiple displays and are not
using Xinerama.
.IP "\fB\-\-desktop N\fR" 4
.IX Item "--desktop N"
Only match windows on a certain desktop. 'N' is a number. The default
is to search all desktops.
.IP "\fB\-\-limit N\fR" 4
.IX Item "--limit N"
Stop searching after finding N matching windows. Specifying a limit will help
speed up your search if you only want a few results.
.Sp
The default is no search limit (which is equivalent to '\-\-limit 0')
.IP "\fB\-\-title\fR" 4
.IX Item "--title"
\&\s-1DEPRECATED\s0. See \-\-name.
.IP "\fB\-\-all\fR" 4
.IX Item "--all"
Require that all conditions be met. For example:
.Sp
.Vb 1
\& xdotool search \-\-all \-\-pid 1424 \-\-name "Hello World"
.Ve
.Sp
This will match only windows that have \*(L"Hello World\*(R" as a name and are owned by
pid 1424.
.IP "\fB\-\-any\fR" 4
.IX Item "--any"
Match windows that match any condition (logically, 'or'). This is on by
default. For example:
.Sp
.Vb 1
\& xdotool search \-\-any \-\-pid 1424 \-\-name "Hello World"
.Ve
.Sp
This will match any windows owned by pid 1424 or windows with name \*(L"Hello
World\*(R"
.IP "\fB\-\-sync \fR" 4
.IX Item "--sync "
Block until there are results. This is useful when you are launching an
application want want to wait until the application window is visible.
For example:
.Sp
.Vb 2
\& google\-chrome &
\& xdotool search \-\-sync \-\-onlyvisible \-\-class "google\-chrome"
.Ve
.RE
.RS 4
.RE
.IP "\fBselectwindow\fR" 4
.IX Item "selectwindow"
Get the window id (for a client) by clicking on it. Useful for having scripts
query you humans for what window to act on. For example, killing a window by
clicking on it:
.Sp
.Vb 1
\& xdotool selectwindow windowkill
.Ve
.IP "\fBbehave\fR \fIwindow\fR \fIaction\fR \fIcommand ...\fR" 4
.IX Item "behave window action command ..."
Bind an action to an event on a window. This lets you run additional xdotool
commands whenever a matched event occurs.
.Sp
The command run as a result of the behavior is run with \f(CW%1\fR being the window
that was acted upon. Examples follow after the event list.
.Sp
The following are valid events:
.RS 4
.IP "\fBmouse-enter\fR" 4
.IX Item "mouse-enter"
Fires when the mouse enters a window. This is similar to 'mouse over' events in
javascript, if that helps.
.IP "\fBmouse-leave\fR" 4
.IX Item "mouse-leave"
Fires when the mouse leaves a window. This is the opposite of 'mouse\-enter'
.IP "\fBmouse-click\fR" 4
.IX Item "mouse-click"
Fires when the mouse is clicked. Specifically, when the mouse button is released.
.IP "\fBfocus\fR" 4
.IX Item "focus"
Fires when the window gets input focus.
.IP "\fBblur\fR" 4
.IX Item "blur"
Fires when the window loses focus.
.RE
.RS 4
.Sp
Examples:
.Sp
.Vb 3
\& # Print the cursor location whenever the mouse enters a currently\-visible
\& # window:
\& xdotool search \-\-onlyvisible . behave %@ mouse\-enter getmouselocation
\&
\& # Print the window title and pid whenever an xterm gets focus
\& xdotool search \-\-class xterm behave %@ focus getwindowname getwindowpid
\&
\& # Emulate focus\-follows\-mouse
\& xdotool search . behave %@ mouse\-enter windowfocus
.Ve
.RE
.IP "\fBgetwindowpid\fR \fI[window]\fR" 4
.IX Item "getwindowpid [window]"
Output the \s-1PID\s0 owning a given window. This requires effort from the application
owning a window and may not work for all windows. This uses _NET_WM_PID
property of the window. See \*(L"\s-1EXTENDED\s0 \s-1WINDOW\s0 \s-1MANAGER\s0 \s-1HINTS\s0\*(R" below for more
information.
.Sp
If no window is given, the default is '%1'. If no windows are on the stack, then
this is an error. See \*(L"\s-1WINDOW\s0 \s-1STACK\s0\*(R" for more details.
.Sp
Example: Find the \s-1PID\s0 for all xterms:
 xdotool search \-\-class xterm getwindowpid %@
.IP "\fBgetwindowname\fR \fI[window]\fR" 4
.IX Item "getwindowname [window]"
Output the name of a given window, also known as the title. This is the text
displayed in the window's titlebar by your window manager.
.Sp
If no window is given, the default is '%1'. If no windows are on the stack, then
this is an error. See \*(L"\s-1WINDOW\s0 \s-1STACK\s0\*(R" for more details.
.IP "\fBgetwindowgeometry\fR [options] \fI[window]\fR" 4
.IX Item "getwindowgeometry [options] [window]"
Output the geometry (location and position) of a window. The values include: x,
y, width, height, and screen number.
.RS 4
.IP "\fB\-\-shell\fR" 4
.IX Item "--shell"
Output values suitable for 'eval' in a shell.
.RE
.RS 4
.RE
.IP "\fBgetwindowfocus\fR [\-f]" 4
.IX Item "getwindowfocus [-f]"
Prints the window id of the currently focused window. Saves the result to the
window stack. See \*(L"\s-1WINDOW\s0 \s-1STACK\s0\*(R" for more details.
.Sp
If the current window has no \s-1WM_CLASS\s0 property, we assume it is not a normal
top-level window and traverse up the parents until we find a window with a
\&\s-1WM_CLASS\s0 set and return that window id.
.Sp
If you really want the window currently having focus and don't care if it has a
\&\s-1WM_CLASS\s0 setting, then use 'getwindowfocus \-f'
.IP "\fBwindowsize\fR [options] [window] width height" 4
.IX Item "windowsize [options] [window] width height"
Set the window size of the given window. If no window is given, \f(CW%1\fR is the
default.  See \*(L"\s-1WINDOW\s0 \s-1STACK\s0\*(R" and \*(L"\s-1COMMAND\s0 \s-1CHAINING\s0\*(R" for more details.
.Sp
Percentages are valid for width and height. They are relative to the geometry
of the screen the window is on. For example, to make a window the full width of
the screen, but half height:
.Sp
.Vb 1
\& xdotool windowsize I<window> 100% 50%
.Ve
.Sp
Percentages are valid with \-\-usehints and still mean pixel-width relative to
the screen size.
.Sp
The options available are:
.RS 4
.IP "\fB\-\-usehints\fR" 4
.IX Item "--usehints"
Use window sizing hints (when available) to set width and height.  This is
useful on terminals for setting the size based on row/column of text rather
than pixels.
.IP "\fB\-\-sync\fR" 4
.IX Item "--sync"
After sending the window size request, wait until the window is actually
resized. If no change is necessary, we will not wait. This is useful for
scripts that depend on actions being completed before moving on.
.Sp
Note: Because many window managers may ignore or alter the original resize
request, we will wait until the size changes from its original size, not 
necessary to the requested size.
.RE
.RS 4
.Sp
Example: To set a terminal to be 80x24 characters, you would use:
 xdotool windowsize \-\-usehints \fIsome_windowid\fR 80 24
.RE
.IP "\fBwindowmove\fR \fI[options]\fR \fI[window]\fR \fIx\fR \fIy\fR" 4
.IX Item "windowmove [options] [window] x y"
Move the window to the given position. If no window is given, \f(CW%1\fR is the
default. See \*(L"\s-1WINDOW\s0 \s-1STACK\s0\*(R" and \*(L"\s-1COMMAND\s0 \s-1CHAINING\s0\*(R" for more details.
.Sp
If the given x coordinate is literally 'x', then the window's current x
position will be unchanged. The same applies for 'y'.
.Sp
Examples:
.Sp
.Vb 4
\& xdotool getactivewindow windowmove 100 100    # Moves to 100,100
\& xdotool getactivewindow windowmove x 100      # Moves to x,100
\& xdotool getactivewindow windowmove 100 y      # Moves to 100,y
\& xdotool getactivewindow windowmove 100 y      # Moves to 100,y
.Ve
.RS 4
.IP "\fB\-\-sync\fR" 4
.IX Item "--sync"
After sending the window move request, wait until the window is actually
moved. If no movement is necessary, we will not wait. This is useful for
scripts that depend on actions being completed before moving on.
.IP "\fB\-\-relative\fR" 4
.IX Item "--relative"
Make movement relative to the current window position.
.RE
.RS 4
.RE
.IP "\fBwindowfocus\fR \fI[options]\fR \fI[window]\fR" 4
.IX Item "windowfocus [options] [window]"
Focus a window. If no window is given, \f(CW%1\fR is the default. See \*(L"\s-1WINDOW\s0 \s-1STACK\s0\*(R"
and \*(L"\s-1COMMAND\s0 \s-1CHAINING\s0\*(R" for more details.
.Sp
Uses XSetInputFocus which may be ignored by some window managers or programs.
.RS 4
.IP "\fB\-\-sync\fR" 4
.IX Item "--sync"
After sending the window focus request, wait until the window is actually
focused. This is useful for scripts that depend on actions being completed
before moving on.
.RE
.RS 4
.RE
.IP "\fBwindowmap\fR \fI[options]\fR \fI[window]\fR" 4
.IX Item "windowmap [options] [window]"
Map a window. In X11 terminology, mapping a window means making it visible on
the screen. If no window is given, \f(CW%1\fR is the default. See \*(L"\s-1WINDOW\s0 \s-1STACK\s0\*(R" and
\&\*(L"\s-1COMMAND\s0 \s-1CHAINING\s0\*(R" for more details.
.RS 4
.IP "\fB\-\-sync\fR" 4
.IX Item "--sync"
After requesting the window map, wait until the window is actually mapped
(visible). This is useful for scripts that depend on actions being completed
before moving on.
.RE
.RS 4
.RE
.IP "\fBwindowminimize\fR \fI[options]\fR \fI[window]\fR" 4
.IX Item "windowminimize [options] [window]"
Minimize a window. In X11 terminology, this is called 'iconify.'
If no window is given, \f(CW%1\fR is the default. See \*(L"\s-1WINDOW\s0 \s-1STACK\s0\*(R" and
\&\*(L"\s-1COMMAND\s0 \s-1CHAINING\s0\*(R" for more details.
.RS 4
.IP "\fB\-\-sync\fR" 4
.IX Item "--sync"
After requesting the window minimize, wait until the window is actually
minimized. This is useful for scripts that depend on actions being completed
before moving on.
.RE
.RS 4
.RE
.IP "\fBwindowraise\fR \fI[window_id=%1]\fR" 4
.IX Item "windowraise [window_id=%1]"
Raise the window to the top of the stack. This may not work on all window
managers. If no window is given, \f(CW%1\fR is the default. See \*(L"\s-1WINDOW\s0 \s-1STACK\s0\*(R" and
\&\*(L"\s-1COMMAND\s0 \s-1CHAINING\s0\*(R" for more details.
.IP "\fBwindowreparent\fR \fI[source_window]\fR \fIdestination_window\fR" 4
.IX Item "windowreparent [source_window] destination_window"
Reparent a window. This moves the \fIsource_window\fR to be a child window of
\&\fIdestination_window\fR. If no source is given, \f(CW%1\fR is the default. 
\&\*(L"\s-1WINDOW\s0 \s-1STACK\s0\*(R" window references (like \f(CW%1\fR) are valid for both \fIsource_window\fR
and \fIdestination_window\fR See \*(L"\s-1WINDOW\s0 \s-1STACK\s0\*(R" and \*(L"\s-1COMMAND\s0 \s-1CHAINING\s0\*(R" for more
details.
.IP "\fBwindowkill\fR \fI[window]\fR" 4
.IX Item "windowkill [window]"
Kill a window. This action will destroy the window and kill the client
controlling it. If no window is given, \f(CW%1\fR is the default. See \s-1WINDOW\s0
\&\s-1STACK\s0 and \*(L"\s-1COMMAND\s0 \s-1CHAINING\s0\*(R" for more details.
.IP "\fBwindowunmap\fR \fI[options]\fR \fI[window_id=%1]\fR" 4
.IX Item "windowunmap [options] [window_id=%1]"
Unmap a window, making it no longer appear on your screen. If no window is
given, \f(CW%1\fR is the default. See \*(L"\s-1WINDOW\s0 \s-1STACK\s0\*(R" and \*(L"\s-1COMMAND\s0 \s-1CHAINING\s0\*(R" for more
details.
.RS 4
.IP "\fB\-\-sync\fR" 4
.IX Item "--sync"
After requesting the window unmap, wait until the window is actually unmapped
(hidden). This is useful for scripts that depend on actions being completed
before moving on.
.RE
.RS 4
.RE
.IP "\fBset_window\fR \fI[options]\fR \fI[windowid=%1]\fR" 4
.IX Item "set_window [options] [windowid=%1]"
Set properties about a window. If no window is given, \f(CW%1\fR is the default. See
\&\*(L"\s-1WINDOW\s0 \s-1STACK\s0\*(R" and \*(L"\s-1COMMAND\s0 \s-1CHAINING\s0\*(R" for more details.
.Sp
Options:
.RS 4
.IP "\fB\-\-name newname\fR" 4
.IX Item "--name newname"
Set window \s-1WM_NAME\s0 (the window title, usually)
.IP "\fB\-\-icon\-name newiconname\fR" 4
.IX Item "--icon-name newiconname"
Set window \s-1WM_ICON_NAME\s0 (the window title when minimized, usually)
.IP "\fB\-\-role newrole\fR" 4
.IX Item "--role newrole"
Set window \s-1WM_WINDOW_ROLE\s0
.IP "\fB\-\-classname newclassname\fR" 4
.IX Item "--classname newclassname"
Set window class name (not to be confused with window class)
.IP "\fB\-\-class newclass\fR" 4
.IX Item "--class newclass"
Set window class (not to be confused with window class name)
.IP "\fB\-\-overrideredirect value\fR" 4
.IX Item "--overrideredirect value"
Set window's override_redirect value. This value is a hint to the window
manager for whether or not it should be managed. If the redirect value is 0,
then the window manager will draw borders and treat this window normally. If
the value is 1, the window manager will ignore this window.
.Sp
If you change this value, your window manager may not notice the change until
the window is mapped again, so you may want to issue 'windowunmap' and
\&'windowmap' to make the window manager take note.
.RE
.RS 4
.RE
.SH "DESKTOP AND WINDOW COMMANDS"
.IX Header "DESKTOP AND WINDOW COMMANDS"
These commands follow the \s-1EWMH\s0 standard. See the section \*(L"\s-1EXTENDED\s0 \s-1WINDOW\s0
\&\s-1MANAGER\s0 \s-1HINTS\s0\*(R" for more information.
.IP "\fBwindowactivate\fR \fI[options]\fR \fI[window]\fR" 4
.IX Item "windowactivate [options] [window]"
Activate the window. This command is different from windowfocus:
if the window is on another desktop, we will switch to that desktop. It also
uses a different method for bringing the window up. I recommend trying this
command before using windowfocus, as it will work on more window managers.
.Sp
If no window is given, \f(CW%1\fR is the default. See \*(L"\s-1WINDOW\s0 \s-1STACK\s0\*(R" and
\&\*(L"\s-1COMMAND\s0 \s-1CHAINING\s0\*(R" for more details.
.RS 4
.IP "\fB\-\-sync\fR" 4
.IX Item "--sync"
After sending the window activation, wait until the window is actually
activated. This is useful for scripts that depend on actions being completed
before moving on.
.RE
.RS 4
.RE
.IP "\fBgetactivewindow\fR" 4
.IX Item "getactivewindow"
Output the current active window. This command is often more reliable than
getwindowfocus. The result is saved to the window stack. See \*(L"\s-1WINDOW\s0 \s-1STACK\s0\*(R"
for more details.
.IP "\fBset_num_desktops\fR \fInumber\fR" 4
.IX Item "set_num_desktops number"
Changes the number of desktops or workspaces.
.IP "\fBget_num_desktops\fR" 4
.IX Item "get_num_desktops"
Output the current number of desktops.
.IP "\fBget_desktop_viewport\fR \fI[\-\-shell]\fR" 4
.IX Item "get_desktop_viewport [--shell]"
Report the current viewport's position. If \-\-shell is given, the output is
friendly to shell eval.
.Sp
Viewports are sometimes used instead of 'virtual desktops' on some window
managers. A viewport is simply a view on a very large desktop area.
.IP "\fBset_desktop_viewport\fR \fIx\fR \fIy\fR" 4
.IX Item "set_desktop_viewport x y"
Move the viewport to the given position. Not all requests will be obeyed \- some
windowmangers only obey requests that align to workspace boundaries, such as
the screen size.
.Sp
For example, if your screen is 1280x800, you can move to the 2nd workspace by doing:
 xdotool set_desktop_viewport 1280 0
.IP "\fBset_desktop\fR \fI[options]\fR \fIdesktop_number\fR" 4
.IX Item "set_desktop [options] desktop_number"
Change the current view to the specified desktop.
.RS 4
.IP "\fB\-\-relative\fR" 4
.IX Item "--relative"
Use relative movements instead of absolute. This lets you move relative to the
current desktop.
.RE
.RS 4
.RE
.IP "\fBget_desktop\fR" 4
.IX Item "get_desktop"
Output the current desktop in view.
.IP "\fBset_desktop_for_window\fR \fI[window]\fR \fIdesktop_number\fR" 4
.IX Item "set_desktop_for_window [window] desktop_number"
Move a window to a different desktop. If no window is given, \f(CW%1\fR is the
default. See \*(L"\s-1WINDOW\s0 \s-1STACK\s0\*(R" and \*(L"\s-1COMMAND\s0 \s-1CHAINING\s0\*(R" for more details.
.IP "\fBget_desktop_for_window\fR \fI[window]\fR" 4
.IX Item "get_desktop_for_window [window]"
Output the desktop currently containing the given window. Move a window to a
different desktop. If no window is given, \f(CW%1\fR is the default. See \s-1WINDOW\s0
\&\s-1STACK\s0 and \*(L"\s-1COMMAND\s0 \s-1CHAINING\s0\*(R" for more details.
.SH "MISCELLANEOUS COMMANDS"
.IX Header "MISCELLANEOUS COMMANDS"
.IP "\fBexec\fR \fI[options]\fR \fIcommand\fR \fI[...]\fR" 4
.IX Item "exec [options] command [...]"
Execute a program. This is often useful when combined with behave_screen_edge
to do things like locking your screen.
.Sp
Options:
.RS 4
.IP "\fB\-\-sync\fR" 4
.IX Item "--sync"
Block until the child process exits. The child process exit status is then
passed to the parent process (xdotool) which copies it.
.RE
.RS 4
.Sp
Examples:
 # Lock the screen when the mouse sits in the top-right corner
 xdotool behave_screen_edge \-\-delay 1000 top-right \e
   exec gnome-screensaver-command \-\-lock
 # Substitute 'xscreensaver\-command \-lock' if you use that program.
.Sp
.Vb 3
\& # The following will fail to move the mouse because we use \*(Aq\-\-sync\*(Aq and
\& # /bin/false exits nonzero:
\& xdotool exec \-\-sync /bin/false mousemove 0 0
\&
\& # This succeeds, though, since we do not use \-\-sync on the exec command.
\& xdotool exec /bin/false mousemove 0 0
.Ve
.RE
.IP "\fBsleep\fR \fIseconds\fR" 4
.IX Item "sleep seconds"
Sleep for a specified period. Fractions of seconds (like 1.3, or 0.4) are
valid, here.
.SH "SCRIPTS"
.IX Header "SCRIPTS"
xdotool can read a list of commands via stdin or a file if you want. A script
will fail when any command fails.
.PP
Truthfully, 'script' mode isn't fully fleshed out and may fall below your
expectations. If you have suggestions, please email the list or file a bug (See
\&\s-1CONTACT\s0).
.PP
Scripts can use positional arguments (Represented by \f(CW$1\fR, \f(CW$2\fR, ...) and
environment variables (like \f(CW$HOME\fR or \f(CW$WINDOWID\fR). Quoting arguments should work
as expected.
.PP
Scripts are processed for parameter and environment variable expansion and then
run as if you had invoked xdotool with the entire script on one line (using
\&\s-1COMMAND\s0 \s-1CHAINING\s0).
.IP "\(bu" 4
Read commands from a file:
.Sp
.Vb 1
\& xdotool filename
.Ve
.IP "\(bu" 4
Read commands from stdin:
.Sp
.Vb 1
\& xdotool \-
.Ve
.IP "\(bu" 4
Read commands from a redirected file
.Sp
.Vb 1
\& xdotool \- < myfile
.Ve
.PP
You can also write scripts that only execute xdotool. Example:
.PP
.Vb 2
\& #!/usr/local/bin/xdotool
\& search \-\-onlyvisible \-\-classname $1
\&
\& windowsize %@ $2 $3
\& windowraise %@
\&
\& windowmove %1 0 0
\& windowmove %2 $2 0
\& windowmove %3 0 $3
\& windowmove %4 $2 $3
.Ve
.PP
This script will take all windows matched by the classname query given by arg1
($1) and sizes/moves them into a 2x2 grid with windows sized by the 2nd and 3rd
parameters.
.PP
Here's an example usage:
.PP
.Vb 1
\& % ./myscript xterm 600 400
.Ve
.PP
Running it like this will take 4 visible xterms, raise them, and move them into
a 2x2 tile grid with each window 600x400 pixels in size.
.SH "CLEARMODIFIERS"
.IX Header "CLEARMODIFIERS"
Any command taking the \fI\-\-clearmodifiers\fR flag will attempt to clear any
active input modifiers during the command and restore them afterwards.
.PP
For example, if you were to run this command:
 xdotool key a
.PP
The result would be 'a' or 'A' depending on whether or not you were holding the
shift key on your keyboard. Often it is undesirable to have any modifiers
active, so you can tell xdotool to clear any active modifiers.
.PP
The order of operations if you hold shift while running 'xdotool key \-\-clearmodifiers a' is this:
.IP "1. Query for all active modifiers (finds shift, in this case)" 4
.IX Item "1. Query for all active modifiers (finds shift, in this case)"
.PD 0
.IP "2. Try to clear shift by sending 'key up' for the shift key" 4
.IX Item "2. Try to clear shift by sending 'key up' for the shift key"
.IP "3. Runs normal 'xdotool key a'" 4
.IX Item "3. Runs normal 'xdotool key a'"
.IP "4. Restore shift key by sending 'key down' for shift" 4
.IX Item "4. Restore shift key by sending 'key down' for shift"
.PD
.PP
The \fI\-\-clearmodifiers\fR flag can currently clear of the following:
.IP "\(bu" 4
any key in your active keymap that has a modifier associated with it.
(See \fIxmodmap\fR\|(1)'s 'xmodmap \-pm' output)
.IP "\(bu" 4
mouse buttons (1, 2, 3, 4, and 5)
.IP "\(bu" 4
caps lock
.SH "SENDEVENT NOTES"
.IX Header "SENDEVENT NOTES"
If you are trying to send key input to a specific window, and it does not
appear to be working, then it's likely your application is ignoring the events
xdotool is generating. This is fairly common.
.PP
Sending keystrokes to a specific window uses a different \s-1API\s0 than simply typing
to the active window. If you specify 'xdotool type \-\-window 12345 hello'
xdotool will generate key events and send them directly to window 12345.
However, X11 servers will set a special flag on all events generated in this
way (see XEvent.xany.send_event in X11's manual). Many programs observe this
flag and reject these events.
.PP
It is important to note that for key and mouse events, we only use
XSendEvent when a specific window is targeted. Otherwise, we use \s-1XTEST\s0.
.PP
Some programs can be configured to accept events even if they are generated by
xdotool. Seek the documentation of your application for help.
.PP
Specific application notes (from the author's testing):
* Firefox 3 seems to ignore all input when it does not have focus.
* xterm can be configured while running with ctrl+leftclick, 'Allow SendEvents'
* gnome-terminal appears to accept generated input by default.
.SH "WINDOW STACK"
.IX Header "WINDOW STACK"
Certain commands (search, getactivewindow, getwindowfocus) will find windows
for you. These results generally printed to stdout, but they are also saved
to memory for future use during the lifetime of the xdotool process. See
\&\*(L"\s-1COMMAND\s0 \s-1CHAINING\s0\*(R" for more information.
.PP
The only modifications support for the window stack are to replace it. That is,
two of two sequential searches, only the last one's results will be the window
stack.
.SH "COMMAND CHAINING"
.IX Header "COMMAND CHAINING"
xdotool supports running multiple commands on a single invocation. Generally,
you'll start with a search command (see \*(L"\s-1WINDOW\s0 \s-1STACK\s0\*(R") and then perform a 
set of actions on those results.
.PP
To query the window stack, you can use special notation \*(L"%N\*(R" where N is a
number or the '@' symbol. If \f(CW%N\fR is given, the Nth window will be selected from
the window stack. Generally you will only want the first window or all windows.
Note that the order of windows in the window stack corresponds to the window
stacking order, i.e. the bottom-most window will be reported first (see
\&\fIXQueryTree\fR\|(3)). Thus the order of the windows in the window stack may not be
consistent across invocations.
.PP
The notation described above is used as the \*(L"window\*(R" argument for any given
command.
.PP
For example, to resize all xterms to 80x24:
.PP
.Vb 1
\& xdotool search \-\-class xterm \-\- windowsize \-\-usehints %@ 80 24
.Ve
.PP
Resize move the current window:
.PP
.Vb 1
\& xdotool getactivewindow windowmove 0 0
.Ve
.PP
In all cases, the default window argument, if omitted, will default to \*(L"%1\*(R". It is
obviously an error if you omit the window argument and the window stack is empty. If you
try to use the window stack and it is empty, it is also an error.
.PP
To activate the first firefox window found:
.PP
.Vb 1
\& xdotool search \-\-class firefox windowactivate
.Ve
.PP
These would error:
.PP
.Vb 3
\& xdotool windowactivate
\& xdotool windowactivate %1
\& xdotool windowactivate %@
.Ve
.PP
When xdotool exits, the current window stack is lost.
.PP
Additinally, commands that modify the \*(L"\s-1WINDOW\s0 \s-1STACK\s0\*(R" will not print the
results if they are not the last command. For example:
.PP
.Vb 3
\& # Output the active window:
\& % xdotool getactivewindow 
\& 20971533
\&
\& # Output the pid of the active window, but not the active window id:
\& % xdotool getactivewindow getwindowpid
\& 4686
.Ve
.SH "EXTENDED WINDOW MANAGER HINTS"
.IX Header "EXTENDED WINDOW MANAGER HINTS"
The following pieces of the \s-1EWMH\s0 standard are supported:
.IP "_NET_SUPPORTED" 4
.IX Item "_NET_SUPPORTED"
Asks the window manager what is supported
.IP "_NET_CURRENT_DESKTOP" 4
.IX Item "_NET_CURRENT_DESKTOP"
Query and set the current desktop. Support for this enables these commands:
\&\f(CW\*(C`set_desktop\*(C'\fR, \f(CW\*(C`get_desktop\*(C'\fR.
.IP "_NET_WM_DESKTOP" 4
.IX Item "_NET_WM_DESKTOP"
Query and set what desktop a window is living in. Support for this enables
these commands: \f(CW\*(C`set_desktop_for_window\*(C'\fR, \f(CW\*(C`get_desktop_for_window\*(C'\fR.
.IP "_NET_ACTIVE_WINDOW" 4
.IX Item "_NET_ACTIVE_WINDOW"
Allows you to query and set the active window by asking the window manager to
bring it forward. Support for this enables these commands: \f(CW\*(C`windowactivate\*(C'\fR, \f(CW\*(C`getactivewindow\*(C'\fR.
.IP "_NET_WM_PID" 4
.IX Item "_NET_WM_PID"
This feature is application dependent, not window-manager dependent. Query the
\&\s-1PID\s0 owning a given window. Support for this enables these commands:
\&\f(CW\*(C`getwindowpid\*(C'\fR.
.SH "SUPPORTED FEATURES"
.IX Header "SUPPORTED FEATURES"
xdotool (and libxdo) will try to function under all circumstances. However, there may
be some cases where functionality is not provided by your X server or by your
window manager. In these cases, xdotool will try to detect and tell you if an action
requires a feature not currently supported by your system.
.PP
For window-manager specific features, see \*(L"\s-1EXTENDED\s0 \s-1WINDOW\s0 \s-1MANAGER\s0 \s-1HINTS\s0\*(R".
.IP "\s-1XTEST\s0" 4
.IX Item "XTEST"
If your X server does not support \s-1XTEST\s0, then some typing and mouse movement
features may not work. Specifically, typing and mouse actions that act on the
\&\*(L"current window\*(R" (window 0 in libxdo) are unlikely to work.
.Sp
In most cases, \s-1XTEST\s0 is a feature you can enable on your X server if it is
not enabled by default.
.Sp
You can see the list of supported X extensions by typing 'xdpyinfo' and looking
the text 'number of extensions: ...'
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIxprop\fR\|(1), \fIxwininfo\fR\|(1),
.PP
Project site: <http://www.semicomplete.com/projects/xdotool>
.PP
Google Code: <http://semicomplete.googlecode.com/>
.PP
\&\s-1EWMH\s0 specification: <http://standards.freedesktop.org/wm\-spec/wm\-spec\-1.3.html>
.SH "CONTACT"
.IX Header "CONTACT"
Please send questions to xdotool\-users@googlegroups.com. File bugs and feature requests at the following \s-1URL:\s0
.PP
<http://code.google.com/p/semicomplete/issues/list>
.PP
Alternately, if you prefer email, feel free to file bugs by emailing the list.
What works for you :)
.SH "AUTHOR"
.IX Header "AUTHOR"
xdotool was written by Jordan Sissel.
.PP
This manual page was written originally by Daniel Kahn Gillmor
<dkg@fifthhorseman.net> for the Debian project (but may be
used by others). It is maintained by Jordan Sissel.
.PP
Patches, ideas, and other contributions by many, nice folks. See the \s-1CHANGELIST\s0
file for who provided what.
